---
id: nexus-services-operations
title: Nexus Services and Operations
sidebar_label: Nexus Service and Operations
description: Discover how Nexus Service and Operations enable the creation of well-defined API contracts for sharing capabilities across team and Namespace boundaries, leveraging Temporal's durable and scalable infrastructure.
toc_max_heading_level: 4
slug: /temporalnexus/services-operations
keywords:
  - Nexus Services
  - Nexus Operations
  - API contracts
  - durable execution
  - Temporal SDK
tags:
  - distributed systems
  - integration
  - temporal
---

The following page covers: 
- [Nexus Services](#nexus-services)
- [Nexus Operations](#nexus-services)
   - Operation Lifecycle
   - Automatic Retries
   - Execution Semantics
   - Versioning

## Nexus Services {#nexus-services}

A Nexus `Service` is a named collection of arbitrary-duration Nexus `Operations` that provide an API contract suitable for sharing across team boundaries. Nexus Services are registered with a Temporal `Worker` that is listening on the target Namespace and Task Queue for an Endpoint.

For example a Nexus Service is often registered in the same Worker as the underlying Workflow they abstract:

```
func main() {
	c, err := client.Dial(client.Options{})
	if err != nil {
		log.Fatalln("Unable to create client", err)
	}
	defer c.Close()

	w := worker.New(c, taskQueue, worker.Options{})
	service := nexus.NewService(service.HelloServiceName)
	err = service.Register(handler.EchoOperation, handler.HelloOperation)
	if err != nil {
		log.Fatalln("Unable to register operations", err)
	}
	w.RegisterNexusService(service)
	w.RegisterWorkflow(handler.HelloHandlerWorkflow)

	err = w.Run(worker.InterruptCh())
	if err != nil {
		log.Fatalln("Unable to start worker", err)
	}
}
```

## Operations {#nexus-operations}

Nexus `Operations` are not intrinsically durable, but can be made durable by backing them with Temporal primitives like a `Workflow`, `Update`, or `Signal`. The Temporal SDK provides helper functions to create Operations that may be registered with a Service in a Temporal Worker.

Calling a Nexus `Operation` from a caller `Workflow` presents as a non-blocking, arbitrary duration operation. This schedules the `Operation` with the caller’s Temporal Service and does not block caller `Workflow` execution. The caller’s Nexus Machinery is responsible for making the underlying Nexus RPC calls and updating the caller’s Workflow history with the result.

### Operation Lifecycle

The Temporal Go SDK is used for the operation lifecycle examples below.

Handlers are created with the Go SDK using:

- `temporalnexus.NewWorkflowRunOperation()`
  - start a `Workflow` as an asynchronous operation
- `temporalnexus.NewSyncOperation()`
  - invoke an underlying `Query` or `Signal` as a synchronous operation
  - invoke an `Update` as a synchronous operation
  - execute arbitrary code as a synchronous operation

Caller Workflows use the following to execute a Nexus Operation:

- `svc := Workflow.CreateNexusClient(endpoint, service)` and then
- `svc.ExecuteOperation()`

#### Asynchronous Operation Lifecycle {#asynchronous-operation-lifecycle}

An asynchronous Nexus Operation may take up to 2 months to complete, to allow for callback URL token validation with asymmetric key rotation at those intervals.

The lifecycle of an asynchronous Nexus `Operation`:

1. Caller’s Workflow does a `myServiceClient.ExecuteOperation()`
   1. **`NexusOperationScheduled`** added to caller’s event history
   2. Nexus `Operation` added to Nexus Machinery in the caller’s Temporal cluster
   3. Immediately returns a Nexus `OperationHandle`, so the Workflow doesn’t block.
   4. Caller’s Workflow can interact with the `Operation` using the `OperationHandle`
      1. `WaitStarted()`, `GetResult()`, and the ability to cancel.
2. Start Nexus operation on the target cluster is attempted by the caller’s Temporal cluster
   1. Via the Nexus Machinery in the target cluster
   2. Retries are processed by the Nexus Machinery in the caller’s Temporal cluster and tracked as part of the caller Workflow, similar to Activities.
3. Nexus `Operation handler` in the target cluster processes the Nexus `Operation`
   1. `Operation handler` pulls operation `Task` from Task Queue
   2. `Operation handler` starts a `Workflow` in the target cluster with attached Nexus `Callback`
   3. Nexus operation `id` is returned since the Nexus operation is asynchronous
   4. **`NexusOperationStarted`** added to caller’s event history
   5. Operation `id` is added to the caller’s operation `OperationHandle`
4. Handler’s Nexus Machinery sends a Nexus completion `Callback` when the `Workflow` has completed.
   1. Operation `result` is returned via callback since the operation is asynchronous
   2. **`NexusOperationCompleted`** added to caller’s event history
5. Caller’s Workflow `handle.GetResult()` returns the result

#### Synchronous Operations Lifecycle

An synchronous Nexus Operation may take up to 10 seconds to complete and will then timeout.

The lifecycle of a synchronous Nexus `Operation`, for example to do a `Query` or a `Signal`:

1. Caller’s Workflow does a `myServiceClient.ExecuteOperation()`
   1. **`NexusOperationScheduled`** added to caller’s event history
   2. Nexus `Operation` added to Nexus Machinery in the caller’s Temporal cluster
   3. Immediately returns an `OperationHandle`, so the Workflow does not block.
   4. Caller’s Workflow can interact with the `Operation` using the `OperationHandle`
      1. `WaitStarted()`, `GetResult()`
2. Start Nexus operation on the target cluster is attempted by the caller’s Temporal cluster
   1. Via the Nexus Machinery in the target cluster
   2. Retries are processed by the Nexus Machinery in the caller’s Temporal cluster and tracked as part of the caller Workflow, similar to Activities.
3. Nexus `Operation handler` in the target cluster processes the Nexus `Operation`
   1. `Operation handler` pulls operation `Task` from Task Queue
   2. `Operation handler` starts a `Workflow` in the target cluster
   3. Operation `result` is returned inline, since the operation is synchronous
   4. **`NexusOperationCompleted`** added to caller’s event history
4. Caller’s Workflow `handle.GetResult()` returns the result

#### Executing Arbitrary (non-durable code) from a Sync Handler {#executing-arbitrary-(non-durable-code)-from-a-sync-handler}

Nexus `Operation handlers` can execute arbitrary code, but unlike Activities they should be relatively short-lived, due to the lack of [heartbeats](https://community.temporal.io/t/best-practices-for-long-running-Activities/934) and a default 10 second NexusOperationStarted timeout. Nexus `Operation handlers` are not required to use underlying Temporal primitives like a `Workflow` or `Signal`.

## Automatic Retries

Once the caller `Workflow` schedules an `Operation` with the caller’s Temporal cluster, the caller’s Nexus Machinery keeps trying to start the `Operation`, with automatic retries and exponential backoff. If a Nexus `Operation` returns a [retryable error](https://github.com/temporalio/temporal/blob/13d6cd8cf7a4ba0c4660cf98f672bbd645dca3e7/components/nexusoperations/executors.go#L659) when attempting to start, the `Operation` it will be retried up to the [default retry policy’s](https://github.com/temporalio/temporal/blob/de7c8879e103be666a7b067cc1b247f0ac63c25c/components/nexusoperations/config.go#L111) max attempts and expiration interval.

## Execution Semantics

### At-least-once Execution Semantics and Idempotency

Since the caller's Nexus Machinery will keep trying to start the Operation over and over, the Nexus `Operation` handler should be idempotent just like Activities should be idempotent. It's not required in all cases, but highly recommended in general. With retries an Operation, like Activities, has at-least-once execution semantics, so an Operation should be idempotent as a general rule.

### At-most-once Execution Semantics via Underlying WorkflowIdReusePolicy

To dedupe work and get at-most-once execution semantics, an `Operation` can start a `Workflow` with a `WorkflowIdReusePolicy` of `RejectDuplicates` which only allows one `Workflow Execution` per `Workflow Id` within a `Namespace` for the retention period.

## Versioning

Task Routing is the simplest way to version your service code.

If you have a new backward-incompatible Nexus `Operation` Handler, for example due to a wire-level incompatible breaking change, start by using a different Service and Task Queue. The version may be part of the service name, for example `prod.payments.v2`. 
Callers can then migrate to the new version in their normal deployment schedule.
---
id: mesh
title: Jargon Mesh - Introduction to Temporal's core concepts
sidebar_label: Jargon Mesh
---

**Welcome to Temporal's core terminology!**

This page is dedicated to defining and describing the terms, components, and concepts of the Temporal system in a holistic way.

## Workflow

A fault-oblivious stateful function that orchestrates [**Activities**](#activity).

- A Workflow has full control over which [**Activities**](#activity) are executed, and in which order.
- A Workflow must not affect the external world directly, only through [**Activities**](#activity).
- What makes Workflow code a Workflow is that its state is preserved by Temporal. Therefore any failure of a [**Worker**](#worker) process that hosts the Workflow code does not affect the [**Workflow Execution**](#workflow-execution). The Workflow continues as if these failures did not happen. At the same time, [**Activities**](#activity) can fail any moment for any reason.
- Because Workflow code is fully fault-oblivious, it is guaranteed to get notifications about [**Activity**](#activity) failures or timeouts and act accordingly.
- The duration of a Workflow has no limit.

### Workflow Execution

An instance of a [**Workflow**](#workflow).

- It is possible for a Workflow Execution to be composed of multiple [**Workflow**](#workflow) runs. When the [**Event History**](#event-history) of a [**Workflow**](#workflow) grows too large, the next invocation can be called with a "Continue as New" flag to create a new run automatically.

### Workflow Id

A unique identifier for a [**Workflow Execution**](#workflow-execution).

- Temporal guarantees the uniqueness of an Id within a [**Namespace**](#namespace).
- An attempt to start a [**Workflow**](#workflow) with a duplicate Id results in an **already started** error if there is another open Workflow execution. However, this behavior depends on the `WorkflowIdReusePolicy` flag; if set to `ALLOW_DUPLICATE`, it is possible to start a new execution with the same Workflow Id.

### Run Id

A UUID that a Temporal service assigns to each [**Workflow**](#workflow) run.

- Temporal guarantees that only one [**Workflow Execution**](#workflow-execution) with a given [**Workflow Id**](#workflow-id) can be open at a time. But after the [**Workflow Execution**](#workflow-execution) has completed, if allowed by a configured policy, you might be able to re-execute a [**Workflow**](#workflow) after it has closed or failed, using the same [**Workflow Id**](#workflow-id).
- Each such re-execution is called a run. Run Id is used to uniquely identify a run even if it shares a [**Workflow Id**](#workflow-id) with others.

### Workflow Task

A [**Task**](#task) that contains invocation information for a [**Workfow**](#workflow).

- Every time a new external event that might affect a [**Workflow**](#workflow) state is recorded, a Workflow Task that contains the event is added to a [**Task Queue**](#task-queue) and then picked up by a [**Workflow Worker**](#worker).
- After the new event is handled, the Workflow Task is completed with a list of [**Commands**](#command).
- Handling of a Workflow Task is usually very fast and is not related to the duration of operations that the [**Workflow**](#workflow) invokes.

## Activity

A business-level function that implements your application logic, such as calling a service or transcoding a media file.

- An Activity usually implements a single well-defined action; it can be short or long running.
- An Activity can be implemented as a synchronous method or fully asynchronously involving multiple processes.
- An Activity can be retried indefinitely according to the provided exponential retry policy.
- If for any reason an Activity is not completed within the specified timeout, an error is reported to the [**Workflow**](#workflow), which decides how to handle it. The duration of an Activity has no limit.
- Activities support an [**Activity Heartbeat**](#activity-heartbeat) that helps to identify timeouts faster in case the Activity execution fails.

### Activity Id

A unique Id that identifies an [**Activity**](#activity) that is executing. The Id can be generated by the system, or it can be provided by the Workflow code that invoked the [**Activity**](#activity). An Activity Id can be used to complete the [**Activity**](#activity) asynchronously.

### Activity Task

A [**Task**](#task) that contains invocation information for an [**Activity**](#activity) that is delivered to an [**Activity Worker**](#worker) through a [**Task Queue**](#task-queue).

- Upon receiving an [**Activity Task**](#activity-task), an [**Activity Worker**](#worker) executes the corresponding [**Activity**](#activity).

### Activity Heartbeat

Provides to the Temporal server the status of an [**Activity Task**](#activity-task) that is being executed.

- Activity Heartbeats help ensure that [**Activity**](#activity) execution failures and timeouts are identified quickly.
- Activity Heartbeats are implemented in code and are recorded at the discretion of the [**Workflow**](#workflow) implementation.
- Custom [**Activity**](#activity) progress information can be included in an Activity Heartbeat and can be used when the [**Activity**](#activity) is retried.

### Local Activity

An [**Activity**](#activity) that is invoked directly in the same process by Workflow code.

- Although a Local Activity consumes less resources than a normal [**Activity**](#activity), it is subject to shorter durations and a lack of rate limiting.

## Retry Policy

A collection of attributes that instructs Temporal Server how to retry a failure of an Activity Task Execution or a [**Workflow Execution**](#workflow-execution).
Any custom Retry Policy must be provided when an [**Activity Task**](#activity-task) or Workflow starts.

Retrying an [**Activity Task**](#activity-task) produces a new Activity Task Execution that uses the same parameters [VERIFY] and Task Queue as the previous attempt.

An Activity Task Execution has a default Retry Policy and thus retries by default.

A [**Workflow Execution**](#workflow-execution) does not have a default Retry Policy and thus does not retry by default.
The intention is that a Workflow is written to never fail due to intermittent issues; an Activity is designed to handle such issues.
(Be aware that, by default, a Workflow Task Execution does retry indefinitely.)

A [**Workflow Execution**](#workflow-execution) should be retried only in specific scenarios, such as the following:
* A Cron Workflow or some other stateless always-running Workflow Execution that can benefit from retries.
* A file-processing or media-encoding Workflow Execution that downloads files to a host.

A Retry Policy does not apply to a Workflow Task Execution, which is governed by the Schedule-To-Start timeout.

The time between retries is the _retry interval_. A retry interval is the smaller of two values:
- The [initial interval](#initial-interval) multiplied by the [backoff coefficient](#backoff-coefficient) raised to power of the number of retries.
- The [maximum interval](#maximum-interval).

A Retry Policy contains the following settings:

### Initial interval

- **Description**: Amount of time that must elapse before the first retry occurs.
  This setting has no default value.
  If a Retry Policy is provided, this setting must be specified.
- **Use case**: This value is also the base interval time that the [backoff coefficient](#backoff-coefficient) is multiplied against.

### Backoff coefficient

- **Description**: Specifies how quickly the retry interval increases.
  The default value is 2.0.
  A backoff coefficient of 1.0 means that the retry interval always equals the [initial interval](#initial-interval).
- **Use case**: Use this setting to increase the interval between retries.
  By having a backoff coefficient greater than 1.0, the first few retries happen relatively quickly to overcome intermittent failures, but subsequent retries happen farther and farther apart to account for longer outages.
  Use the [maximum interval](#maximum-interval) setting to prevent the coefficient from increasing the retry interval too much.

### Maximum interval

- **Description**: Specifies the maximum interval between retries.
  The default value is 100 times the [initial interval](#initial-interval).
- **Use case**: This setting is useful for [backoff coefficients](#backoff-coefficient) that are greater than 1.0 because it prevents the retry interval from growing infinitely.

### Maximum attempts

- **Description**: Specifies the maximum number of attempts that can be made in the presence of failures.
  If this limit is exceeded, the Activity Task Execution or [**Workflow Execution**](#workflow-execution) fails without retrying again.
  The default is unlimited. 
  Setting the value to 0 also means unlimited.
- **Use case**: Use this setting to ensure that retries do not continue indefinitely.
  However, in the majority of cases, we recommend relying on the [execution timeout](#execution-timeout) to limit the duration of the retries instead of using this setting.

### Non-retryable error reasons

- **Description**: Specifies errors that shouldn't be retried. If one of those errors occurs, the Activity Task Execution or [**Workflow Execution**](#workflow-execution) is not retried.
- **Use case**: For example, retrying an error caused by invalid arguments doesn't make sense in some scenarios.


## Event

For each [**Workflow**](#workflow), Temporal tracks two types of Events:

1. [**Command**](#command) Events.
2. Everything else.

- Command Events are events that correspond to [**Commands**](#command) produced by the [**Workflow Worker**](#worker).
- All other events represent various external occurrences that the [**Workflow**] is expected to react to, such as an [**Activity**](#activity) completion, a timer firing, or a cancellation request.
- All Events are recorded in the [**Event History**](#event-history).

## Event History

An append-log of [**Events**](#event) for your application.

- Event History is durably persisted by the Temporal service, enabling seamless recovery of your application state from crashes or failures.
- It also serves as an audit log for debugging.

## Command

Any action requested by the [**Workflow**](#workflow) durable function.

- Scheduling an [**Activity**](#activity), canceling a child [**Workflow**](#workflow), or starting a timer are all examples of Commands.
- A [**Workflow Task**](#workflow-task) contains an optional list of Commands.
- A [**Worker**](#worker) executing a [**Workflow**](#workflow) generates a list of Commands as a result of a [**Workflow Task**](#workflow-task). This list is sent to the Temporal service as part of the [**Workflow Task**](#workflow-task) completion request.
- Every Command is recorded in the [**Event History**](#event-history) as an [**Event**](#event). For example, the `StartTimer` command is recorded as a corresponding `TimerStarted` event.

## Archival

A feature that automatically moves [**Event Histories**](#event-history) from normal persistence to a blob store after the [**Workflow**](#workflow) retention period.

- The purpose of Archival is to keep [**Event Histories**](#event-history) as long as needed while not overwhelming the persistence store.
- You might want to keep [**Event Histories**](#event-history) after the retention period has passed for two reasons:
  1. Compliance: For legal reasons, [**Event Histories**](#event-history) may need to be stored for a long period of time.
  2. Debugging: Older [**Event Histories**](#event-history) can be referenced to help with debugging.

## Client Stub

A client-side proxy in the Java SDK that is used to make remote invocations on an entity that it represents.

- To start a [**Workflow**](#workflow), for example, a Stub object that represents the [**Workflow**](#workflow) is created through a special API. Then the Stub is used to start, query, or signal the corresponding [**Workflow**](#worker).
- The Go SDK does not use Client Stubs.

## Namespace

The unit of isolation within Temporal, which is backed by a multi-tenant service.

- By default, a Temporal service is provisioned with a "default" Namespace. All APIs and tools, such as the UI and CLI, default to the "default" Namespace if it is not specified. So, if you are not planning to use multiple Namespaces, we recommend using the default one.
- [**Task Queue**](#task-queue) names and [**Workflow Ids**](#workflow-id) correspond to a specific Namespace. For example, when a [**Workflow**](#workflow) is started, it starts within a specific Namespace.
- Temporal guarantees a unique [**Workflow Id**](#workflow-id) within a Namespace. Temporal supports running [**Workflow Executions**](#workflow-execution) that use the same [**Workflow Id**](#workflow-id) if they are in different Namespaces.
- Various configuration options like the retention period or [**Archival**](#archival) destination are configured per Namespace through a special CRUD API or through [`tctl`](/docs/system-tools/tctl/).
- In a multi-cluster deployment, Namespace is a unit of fail-over.
- Each Namespace can be active on only a single Temporal cluster at a time. However, different Namespaces can be active in different clusters and can fail-over independently.

## Query

From the caller's point of view, a synchronous operation that is used to report the state of a [**Workflow**](#workflow).

- Query logic is implemented as code within a [**Workflow**](#workflow).
- A Query is inherently read-only and cannot affect a [**Workflow**](#workflow) state.

## Signal

An external asynchronous request to a [**Workflow**](#workflow).

- A Signal can be used to deliver notifications or updates to a running [**Workflow**](#workflow) at any point in its existence.

## Task

The context needed to execute a specific [**Activity**](#activity) or [**Workflow**](#workflow) state transition.

- There are two types of tasks:
  - [**Activity Task**](#activity-task)
  - [**Workflow Task**](#workflow-task)
- A single [**Activity**](#activity) execution corresponds to a single [**Activity Task**](#activity-task), while a [**Workflow Execution**](#workflow-execution) employs multiple [**Workflow Tasks**](#workflow-task).

### Task Queue

A queue that a [**Worker**](#worker) subscribes to and polls to pick up tasks to execute.

- Each Task Queue is capable of queuing [**Activity Tasks**](#activity-task) and [**Workflow Tasks**](#workflow-task).
- Task Queues rely on the same persistent storage as the rest of the Temporal service. (Task Queues are not based on other technologies such as Kafka.)

### Task Token

A unique correlation Id for a Temporal [**Activity**](#activity).

- [**Activity**](#activity) completion calls take either a single Task Token, or the [**Namespace**](#namespace), [**Workflow Id**](#workflow-id), and [**Activity Id**](#activity-id) as a set of arguments.

## Worker

A service that hosts the [**Workflow**](#workflow) and [**Activity**](#activity) implementations.

- A single Worker actually contains both an [**Activity Worker**](#worker) and a [**Workflow Worker**](#worker), abstracting the logical separation and having the ability to execute both types of tasks.
- The Worker polls the Temporal service for [**Tasks**](#task), performs those [**Tasks**](#task), and communicates [**Task**](#task) execution results back to the Temporal service.
- Worker services are developed, deployed, and operated by Temporal customers.

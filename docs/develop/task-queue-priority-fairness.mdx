---
id: task-queue-priority-fairness
title: Task Queue Priority and Fairness
sidebar_label: Task queue priority and fairness
description: How the Task Queue Priority and Fairness features can be used.
toc_max_heading_level: 4
hide_table_of_contents: true
keywords:
 - task queue
 - task queue priority
 - task queue fairness
 - task queue priority and fairness
tags:
 - Task Queues
 - Priority and Fairness
---

import SdkTabs from '@site/src/components';

## Task Queue priority

**Task Queue priority** allows you to control the execution order of Workflows, Activities, and child Workflows based on assigned priority values within a *single* Task Queue. You can select a priority level in the integer range `[1,5]`. A lower value implies higher priority, so `1` is the highest priority level. The default priority if unspecified is `3`.

If you're using Temporal Cloud, contact Temporal support or your Temporal account team to enable this feature for your cloud Namespaces.

If you're self-hosting Temporal, use the latest pre-release development server and set `matching.useNewMatcher` to `true` in the [dynamic config](https://github.com/temporalio/temporal/blob/a3a53266c002ae33b630a41977274f8b5b587031/common/dynamicconfig/constants.go#L1345-L1348) on the relevant Task Queues or Namespaces.


Choose your SDK below to see an example of setting priority for your Workflows:

<SdkTabs>
<SdkTabs.Go>
```go
workflowOptions := client.StartWorkflowOptions{
  ID:        "my-workflow-id",
  TaskQueue: "my-task-queue",
  Priority:  temporal.Priority{PriorityKey: 5},
}
we, err := c.ExecuteWorkflow(context.Background(), workflowOptions, MyWorkflow)
```
</SdkTabs.Go>
<SdkTabs.Java>
```java
WorkflowOptions options = WorkflowOptions.newBuilder()
  .setTaskQueue("my-task-queue")
  .setPriority(Priority.newBuilder().setPriorityKey(5).build()) 
  .build();

WorkflowClient client = WorkflowClient.newInstance(service);
MyWorkflow workflow = client.newWorkflowStub(MyWorkflow.class, options);
workflow.run();
```
</SdkTabs.Java>
<SdkTabs.Python>
```python
await client.start_workflow(
  MyWorkflow.run,
  args="hello",
  id="my-workflow-id",
  task_queue="my-task-queue",
  priority=Priority(priority_key=1),
)
```
</SdkTabs.Python>
<SdkTabs.DotNet>
```csharp
var handle = await Client.StartWorkflowAsync(
  (MyWorkflow wf) => wf.RunAsync("hello"),
  new StartWorkflowOptions(
    id: "my-workflow-id",
    taskQueue: "my-task-queue"
  )
  {
    Priority = new Priority(1),
  }
);
```
</SdkTabs.DotNet>
</SdkTabs>

Choose your SDK below to see an example of setting priority for your Activities:

<SdkTabs>
<SdkTabs.Go>
```go
ao := workflow.ActivityOptions{
  StartToCloseTimeout: time.Minute,
  Priority:            temporal.Priority{PriorityKey: 3},
}
ctx := workflow.WithActivityOptions(ctx, ao)
err := workflow.ExecuteActivity(ctx, MyActivity).Get(ctx, nil)
```
</SdkTabs.Go>
<SdkTabs.Java>
```java
ActivityOptions options = ActivityOptions.newBuilder()
  .setStartToCloseTimeout(Duration.ofMinutes(1))
  .setPriority(Priority.newBuilder().setPriorityKey(3).build())
  .build();

MyActivity activity = Workflow.newActivityStub(MyActivity.class, options);
activity.perform();
```
</SdkTabs.Java>
<SdkTabs.Python>
```python
await workflow.execute_activity(
  say_hello,
  "hi",
  priority=Priority(priority_key=3),
  start_to_close_timeout=timedelta(seconds=5),
)
```
</SdkTabs.Python>
<SdkTabs.TypeScript>
</SdkTabs.TypeScript>
<SdkTabs.DotNet>
```csharp
await Workflow.ExecuteActivityAsync(
  () => SayHello("hi"),
    new()
    {
      StartToCloseTimeout = TimeSpan.FromSeconds(5),
      Priority = new(3),
    }
  );
```
</SdkTabs.DotNet>
</SdkTabs>

Choose your SDK below to see an example of setting priority for your Child Workflows:

<SdkTabs>
<SdkTabs.Go>
```go
cwo := workflow.ChildWorkflowOptions{
  WorkflowID: "child-workflow-id",
  TaskQueue:  "child-task-queue",
  Priority:   temporal.Priority{PriorityKey: 1},
}
ctx := workflow.WithChildOptions(ctx, cwo)
err := workflow.ExecuteChildWorkflow(ctx, MyChildWorkflow).Get(ctx, nil)
```
</SdkTabs.Go>
<SdkTabs.Java>
```java
ChildWorkflowOptions childOptions = ChildWorkflowOptions.newBuilder()
  .setTaskQueue("child-task-queue")
  .setWorkflowId("child-workflow-id")
  .setPriority(Priority.newBuilder().setPriorityKey(1).build())
  .build();

MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, childOptions);
child.run();
```
</SdkTabs.Java>
<SdkTabs.Python>
```python
await workflow.execute_child_workflow(
  MyChildWorkflow.run,
  args="hello child",
  priority=Priority(priority_key=1),
)
```
</SdkTabs.Python>
<SdkTabs.DotNet>
```csharp
await Workflow.ExecuteChildWorkflowAsync(
  (MyChildWorkflow wf) => wf.RunAsync("hello child"),
  new() { Priority = new(1) });
```
</SdkTabs.DotNet>
</SdkTabs>

## Task Queue fairness

Task Queue fairness allows for more control over the order that Tasks are dispatched from a backlog. It’s intended to address common situations like, multi-tenant applications and reserved capacity bands.

Fairness creates multiple “virtual queues”, one for each _fairness key_, within a Task Queue that are dispatched in a weighted-round-robin manner. This lets you handle scenarios like:

- Multi-tenant applications with big and small tenants where small tenants should not not be blocked by big ones and any single user should be able to use all available resources rather than being rate limited at some fixed level.
- Assign Tasks to bands and then dispatch 80% from one band and 20% from another, for example, without limiting overall capacity when one band is empty.

To enable this feature, use the latest pre-release development server and set `matching.enableFairness` to `true` in the [dynamic config](https://github.com/temporalio/temporal/blob/a3a53266c002ae33b630a41977274f8b5b587031/common/dynamicconfig/constants.go#L1350-L1353) on the relevant Task Queues or Namespaces.

:::warning
For **Public Preview**, fairness cannot be enabled for active Task Queues. The Task Queues have to be new or idle and there can't be any running Workflows. Once fairness is enabled, all existing backlog Tasks in the Task Queue will be abandoned.
:::

### How it works

Each priority level acts as a separate virtual Task Queue. Fairness attempts to distribute all the Tasks from a higher priority level first before distributing any from a lower priority. There are _fairness keys_ which are the attribute used to distinguish Tasks in the context of fair dispatch. There are also _fairness weights_ which is the weight assigned to a fairness key to allow for unequal distribution among tenants or for allocating fractions of capacity to different levels or types of Tasks.

Fairness applies within each priority level. It sequences Tasks in the Task Queue probabilistically using a weighted round-robin, based on:

- Fairness weights the customer sets
- The current backlog of Tasks
- A data structure that tracks how Tasks are distributed for different fairness keys

### When to use fairness

Fairness applies to backlogged Tasks when there isn't sufficient Worker capacity to dispatch Tasks immediately. If all Tasks can be dispatched immediately, the you don't need to use fairness.

Fairness applies at Task dispatch time based on information about the Tasks passing through the Task Queue and considers each Task as having equal cost. It doesn't consider any Task execution that is currently being done by Workers. So if you look at Tasks being process by Workers, you might not see "fairness" across tenants.

### Limitations of fairness

When you use Worker Versioning and you're moving Workflows from one version to another, the ordering of Workflow Tasks that are moved to the next version is undefined. Tasks redirected to a new Worker version may not be treated fairly with respect to each other or Tasks that aren't redirected.

There isn't a limit on the number of fairness keys you can use, but their accuracy can degrade as you add more fairness keys.

Task Queues are internally [partitioned](/task-queue#task-ordering) and Tasks are distributed to partitions randomly. This could interfer with fairnesss. Depending on your use case, you can reach out to Temporal support to get your Task Queues set to a single partition.

Choose your SDK below to see an example of setting fairness for your Workflows:

<SdkTabs>
<SdkTabs.Go>
```go
workflowOptions := client.StartWorkflowOptions{
  ID:        "my-workflow-id",
  TaskQueue: "my-task-queue",
  Priority:  temporal.Priority{
    PriorityKey:    1,
    FairnessKey:    "a-key",
    FairnessWeight: 3.14,
  },
}
we, err := c.ExecuteWorkflow(context.Background(), workflowOptions, MyWorkflow)
```
</SdkTabs.Go>
<SdkTabs.Java>
```java
WorkflowOptions options = WorkflowOptions.newBuilder()
  .setTaskQueue("my-task-queue")
  .setPriority(Priority.newBuilder().setPriorityKey(5).setFairnessKey("a-key").setFairnessWeight(3.14).build())
  .build();
WorkflowClient client = WorkflowClient.newInstance(service);
MyWorkflow workflow = client.newWorkflowStub(MyWorkflow.class, options);
workflow.run();
```
</SdkTabs.Java>
<SdkTabs.Python>
```python
await client.start_workflow(
  MyWorkflow.run,
  args="hello",
  id="my-workflow-id",
  task_queue="my-task-queue",
  priority=Priority(priority_key=3, fairness_key="a-key", fairness_weight=3.14),
)
```
</SdkTabs.Python>
<SdkTabs.Ruby>
```ruby
client.start_workflow(
  MyWorkflow, "input-arg",
  id: "my-workflow-id",
  task_queue: "my-task-queue",
  priority: Temporalio::Priority.new(
    priority_key: 3,
    fairness_key: "a-key",
    fairness_weight: 3.14
  )
)
```
</SdkTabs.Ruby>
<SdkTabs.TypeScript>
```ts
const handle = await startWorkflow(workflows.priorityWorkflow, {
  args: [false, 1],
  priority: { priorityKey: 3, fairnessKey: 'a-key', fairnessWeight: 3.14 },
});
```
</SdkTabs.TypeScript>
<SdkTabs.DotNet>
```csharp
var handle = await Client.StartWorkflowAsync(
  (MyWorkflow wf) => wf.RunAsync("hello"),
  new StartWorkflowOptions(
    id: "my-workflow-id",
    taskQueue: "my-task-queue"
  )
  {
    Priority = new Priority(
      priorityKey: 3,
      fairnessKey: "a-key",
      fairnessWeight: 3.14
    )
  }
);
```
</SdkTabs.DotNet>
</SdkTabs>

Choose your SDK below to see an example of setting fairness for your Activities:

<SdkTabs>
<SdkTabs.Go>
```go
ao := workflow.ActivityOptions{
  Stardd
}
ctx := workflow.WithActivityOptions(ctx, ao)
err := workflow.ExecuteActivity(ctx, MyActivity).Get(ctx, nil)
```
</SdkTabs.Go>
<SdkTabs.Java>
```java
ActivityOptions options = ActivityOptions.newBuilder()
  .setStartToCloseTimeout(Duration.ofMinutes(1))
  .setPriority(Priority.newBuilder().setPriorityKey(3).setFairnessKey("a-key").setFairnessWeight(3.14).build())
  .build();
MyActivity activity = Workflow.newActivityStub(MyActivity.class, options);
activity.perform();
```
</SdkTabs.Java>
<SdkTabs.Python>
```python
await workflow.execute_activity(
  say_hello,
  "hi",
  priority=Priority(priority_key=3, fairness_key="a-key", fairness_weight=3.14),
  start_to_close_timeout=timedelta(seconds=5),
)
```
</SdkTabs.Python>
<SdkTabs.Ruby>
```ruby
client.start_activity(
  MyActivity, "input-arg",
  id: "my-workflow-id",
  task_queue: "my-task-queue",
  priority: Temporalio::Priority.new(
    priority_key: 3,
    fairness_key: "a-key",
    fairness_weight: 3.14
  )
)
```
</SdkTabs.Ruby>
<SdkTabs.TypeScript>
```ts
const handle = await startWorkflow(workflows.priorityWorkflow, {
  args: [false, 1],
  priority: { priorityKey: 3, fairnessKey: 'a-key', fairnessWeight: 3.14 },
});
```
</SdkTabs.TypeScript>
<SdkTabs.DotNet>
```csharp
var handle = await Client.StartWorkflowAsync(
  (MyWorkflow wf) => wf.RunAsync("hello"),
  new StartWorkflowOptions(
    id: "my-workflow-id",
    taskQueue: "my-task-queue"
  )
  {
    Priority = new Priority(
      priorityKey: 3,
      fairnessKey: "a-key",
      fairnessWeight: 3.14
    )
  }
);
```
</SdkTabs.DotNet>
</SdkTabs>

Choose your SDK below to see an example of setting fairness for your Child Workflows:

<SdkTabs>
<SdkTabs.Go>
```go
cwo := workflow.ChildWorkflowOptions{
  WorkflowID: "child-workflow-id",
  TaskQueue:  "child-task-queue",
  Priority:   temporal.Priority{
    PriorityKey:    1,
    FairnessKey:    "a-key",
    FairnessWeight: 3.14,
  },
}
ctx := workflow.WithChildOptions(ctx, cwo)
err := workflow.ExecuteChildWorkflow(ctx, MyChildWorkflow).Get(ctx, nil)
```
</SdkTabs.Go>
<SdkTabs.Java>
```java
ChildWorkflowOptions childOptions = ChildWorkflowOptions.newBuilder()
  .setTaskQueue("child-task-queue")
  .setWorkflowId("child-workflow-id")
  .setPriority(Priority.newBuilder().setPriorityKey(1).setFairnessKey("a-key").setFairnessWeight(3.14).build())
  .build();
MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, childOptions);
child.run();
```
</SdkTabs.Java>
<SdkTabs.Python>
```python
await workflow.execute_child_workflow(
  MyChildWorkflow.run,
  args="hello child",
  priority=Priority(priority_key=3, fairness_key="a-key", fairness_weight=3.14),
)
```
</SdkTabs.Python>
<SdkTabs.Ruby>
```ruby
client.start_child_workflow(
  MyChildWorkflow, "input-arg",
  id: "my-child-workflow-id",
  task_queue: "my-task-queue",
  priority: Temporalio::Priority.new(
    priority_key: 3,
    fairness_key: "a-key",
    fairness_weight: 3.14
  )
)
```
</SdkTabs.Ruby>
<SdkTabs.TypeScript>
```ts
const handle = await startChildWorkflow(workflows.priorityWorkflow, {
  args: [false, 1],
  priority: { priorityKey: 3, fairnessKey: 'a-key', fairnessWeight: 3.14 },
});
```
</SdkTabs.TypeScript>
<SdkTabs.DotNet>
```csharp
var handle = await Client.StartWorkflowAsync(
  (MyWorkflow wf) => wf.RunAsync("hello"),
  new StartWorkflowOptions(
    id: "my-workflow-id",
    taskQueue: "my-task-queue"
  )
  {
    Priority = new Priority(
      priorityKey: 3,
      fairnessKey: "a-key",
      fairnessWeight: 3.14
    )
  }
);
```
</SdkTabs.DotNet>
</SdkTabs>
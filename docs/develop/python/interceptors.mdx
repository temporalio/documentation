---
id: interceptors
title: Interceptors - Python SDK
sidebar_label: Interceptors
description: Learn how to implement Interceptors in the Temporal Python SDK to manage inbound and outbound SDK calls, enhance tracing, and add authorization to your Workflows and Activities.
toc_max_heading_level: 2
keywords:
  - interceptors
tags:
  - Interceptors
  - Python SDK
  - Temporal SDKs
---

### Interceptors

The behavior of the Python SDK can be customized in many useful ways by modifying inbound and outbound calls using
interceptors. This is similar to the use of middleware in other frameworks.

There are five categories of inbound and outbound calls that you can modify in this way:

1. Outbound Client calls, such as `start_workflow()`, `signal_workflow()`, `list_workflows()`, `update_schedule()`, etc.

2. Inbound Workflow calls: `execute_workflow()`, `handle_signal()`, `handle_update_handler()`, etc

3. Outbound Workflow calls: `start_activity()`, `start_child_workflow()`, `start_nexus_operation()`, etc

4. Inbound call to execute an Activity: `execute_activity()`

5. Outbound Activity calls: `info()` and `heartbeat()`

To modify outbound Client calls, define a class inheriting from
[`client.Interceptor`](https://python.temporal.io/temporalio.client.Interceptor.html), and implement the method
`intercept_client()` to return an instance of
[`OutboundInterceptor`](https://python.temporal.io/temporalio.client.OutboundInterceptor.html) that implements the
subset of outbound Client calls that you wish to modify.

Then, pass a list containing an instance of your `client.Interceptor` class as the
`interceptors` argument of [`Client.connect()`](https://python.temporal.io/temporalio.client.Client.html#connect).

The purpose of the interceptor framework is that the methods you implement on your interceptor classes can perform
arbitrary side effects and/or arbitrary modifications to the data, before it is received by the SDK's "real"
implementation. The `interceptors` list can contain multiple interceptors. In this case they form a chain: a method
implemented on an interceptor instance in the list can perform side effects, and modify the data, before passing it on
to the corresponding method on the next interceptor in the list. Your interceptor classes need not implement every
method; the default implementation is always to pass the data on to the next method in the interceptor chain.

The remaining four categories are Worker calls. To modify these, define a class inheriting from
[`worker.Interceptor`](https://python.temporal.io/temporalio.worker.Interceptor.html) and implement methods on that
class to define the
[`ActivityInboundInterceptor`](https://python.temporal.io/temporalio.worker.ActivityInboundInterceptor.html),
[`ActivityOutboundInterceptor`](https://python.temporal.io/temporalio.worker.ActivityOutboundInterceptor.html),
[`WorkflowInboundInterceptor`](https://python.temporal.io/temporalio.worker.WorkflowInboundInterceptor.html), and
[`WorkflowOutboundInterceptor`](https://python.temporal.io/temporalio.worker.WorkflowOutboundInterceptor.html) classes
that you wish to use to effect your modifications. Then, pass a list containing an instance of your `worker.Interceptor`
class as the `interceptors` argument of the [`Worker()`](https://python.temporal.io/temporalio.worker.Worker.html)
constructor.

It often happens that your Worker and Client interceptors will share code because they implement closely related logic.
For convenience, you can create an interceptor class that inherits from _both_ `client.Interceptor` and
`worker.Interceptor` (their method sets do not overlap). You can then pass this in the `interceptors` argument of
`Client.connect()` when starting your Worker _as well as_ in your client/starter code. If you do this, your Worker will
automatically pick up the interceptors from its underlying Client (and you should not pass them directly to the
`Worker()` constructor).

This is best explained by example. The [Context Propagation Interceptor Sample](https://github.com/temporalio/samples-python/tree/main/context_propagation) is a good starting point. In
[context_propagation/interceptor.py](https://github.com/temporalio/samples-python/blob/main/context_propagation/interceptor.py)
a class is defined that inherits from both `client.Interceptor` and `worker.Interceptor`. It implements the various
methods such that the outbound Client and Workflow calls set a certain key in the outbound `headers` field, and the
inbound Workflow and Activity calls retrieve the header value from the inbound Workflow/Activity input data:


```python
class ContextPropagationInterceptor(
    temporalio.client.Interceptor, temporalio.worker.Interceptor
):
    """Interceptor that propagates a value through client, workflow and activity calls.

    This interceptor implements methods `temporalio.client.Interceptor` and  `temporalio.worker.Interceptor` so that

    (1) a user ID key is taken from context by the client code and sent in a header field with outbound requests
    (2) workflows take this value from their task input, set it in context, and propagate it into the header field of
        their outbound calls
    (3) activities similarly take the value from their task input and set it in context so that it's available for their
        outbound calls
    """

    def __init__(
        self,
        payload_converter: temporalio.converter.PayloadConverter = temporalio.converter.default().payload_converter,
    ) -> None:
        self._payload_converter = payload_converter

    def intercept_client(
        self, next: temporalio.client.OutboundInterceptor
    ) -> temporalio.client.OutboundInterceptor:
        return _ContextPropagationClientOutboundInterceptor(
            next, self._payload_converter
        )

    def intercept_activity(
        self, next: temporalio.worker.ActivityInboundInterceptor
    ) -> temporalio.worker.ActivityInboundInterceptor:
        return _ContextPropagationActivityInboundInterceptor(next)

    def workflow_interceptor_class(
        self, input: temporalio.worker.WorkflowInterceptorClassInput
    ) -> Type[_ContextPropagationWorkflowInboundInterceptor]:
        return _ContextPropagationWorkflowInboundInterceptor
```


An instance of this interceptor class is passed to `Client.connect()` when [starting the
worker](https://github.com/temporalio/samples-python/blob/main/context_propagation/worker.py) and when connecting the
Client in the [Workflow starter
code](https://github.com/temporalio/samples-python/blob/main/context_propagation/starter.py):

```python
    client = await Client.connect(
        "localhost:7233",
        # Use our interceptor
        interceptors=[interceptor.ContextPropagationInterceptor()],
    )
```


---
id: continue-as-new
title: Continue-As-New - Python SDK
sidebar_label: Continue-As-New
description: Learn how to use Temporal's Continue-As-New in Python to manage large Event Histories by atomically creating new Workflow Executions with the same Workflow Id and fresh parameters.
toc_max_heading_level: 2
keywords:
  - continue-as-new workflow
  - restart workflow
  - fresh event history
  - avoid large event histories
  - temporal python continue-as-new
tags:
  - Workflows
  - continue-as-new
  - Python SDK
  - Temporal SDKs
---

I'll edit this technical documentation to improve clarity, readability, and simplicity while following your formatting requirements. Here's the revised version:

This page answers the following questions for Python developers:

- [What is Continue-As-New?](#what)
- [How to Continue-As-New?](#how)
- [When is it right to Continue-as-New?](#when)
- [How to test Continue-as-New?](#how-to-test)

## What is Continue-As-New? {#what}

[Continue-As-New](/workflow-execution/continue-as-new) lets a Workflow Execution close successfully and create a new Workflow Execution. You can think of it as a checkpoint when your Workflow gets too long or approaches certain scaling limits.

The new Workflow Execution keeps the same Workflow Id but gets a new Run Id and a fresh Event History.
It also receives your Workflow's usual parameters.
Note that Continue-As-New works as an atomic operation.

## How to Continue-As-New using the Python SDK {#how}

To Continue-As-New in Python, call the [`continue_as_new()`](https://python.temporal.io/temporalio.workflow.html#continue_as_new) function inside your Workflow.
This stops the Workflow right away and starts a new one.

<div class="copycode-notice-container">
  <a href="https://github.com/temporalio/documentation/blob/main/sample-apps/python/continue_as_new/your_workflows_dacx.py">
    View the source code
  </a>{' '}
  in the context of the rest of the application code.
</div>

```python
# ...
@workflow.defn
class LoopingWorkflow:
    @workflow.run
    async def run(self, iteration: int) -> None:
        if iteration == 5:
            return
        await asyncio.sleep(10)
        workflow.continue_as_new(iteration + 1)
```

### Considerations for Workflows with Message Handlers

If you use Updates or Signals, don't call Continue-as-New from the handlers.
Instead, wait for your handlers to finish before you run `continue_as_new`.
See how with [`all_handlers_finished`](message-passing#wait-for-message-handlers).

## When is it right to Continue-as-New using the Python SDK? {#when}

Use Continue-as-New when your Workflow might hit scaling limits:

- When the Event History grows too large
- When the Workflow might get too many Updates or Signals

Temporal tracks when you should Continue-as-New.
Just call `workflow.info().is_continue_as_new_suggested()` to check if it's time.

## How to test Continue-as-New using the Python SDK {#how-to-test}

Testing Workflows that naturally Continue-as-New takes too much time and resources.
Instead, add a test hook to check your Workflow's Continue-as-New behavior faster in automated tests.
For example, create a test-only variable called `self.max_history_length`, set it to a small value, and add this helper in your Workflow:

<div class="copycode-notice-container">
  <a href="https://github.com/temporalio/samples-python/blob/main/message_passing/safe_message_handlers/workflow.py">
    View the source code
  </a>{' '}
  in the context of the rest of the application code.
</div>

```python
def should_continue_as_new(self) -> bool:
    if workflow.info().is_continue_as_new_suggested():
        return True
    # For testing
    if (
        self.max_history_length
        and workflow.info().get_current_history_length() > self.max_history_length
    ):
        return True
    return False
```

Check this helper each time you consider using Continue-as-New.

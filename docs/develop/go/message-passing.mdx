---
id: message-passing
title: Workflow message passing  - Temporal Go SDK feature guide
sidebar_label: Messages
description: Learn how to develop with Signals, Queries, and Updates using the Go SDK in Temporal. Methods covered include Signal handling, Query definitions, and Update integrations.
toc_max_heading_level: 4
keywords:
  - temporal go signals
  - send signal from client
  - send signal from workflow
  - signal with start
  - workflow queries
  - sending queries
  - workflow updates
  - dynamic workflows
  - dynamic activities
  - dynamic signals
  - dynamic queries
tags:
  - go
  - go-sdk
  - workflows
  - messages
  - signals
  - queries
  - updates
  - dynamic-handlers
---

See [Workflow message passing](/encyclopedia/workflow-message-passing#sending-queries) for an introduction to using messages with Temporal Workflows.

General guidelines for writing message handlers:

- Arguments and return values of handlers, signal channels, and the main Workflow function must be [serializable](/dataconversion): a struct is often a good choice to make changes easier in the future. This practice enables you to add fields in future versions while maintaining backward compatibility.
- It's possible to write handler methods that take multiple arguments, but this is not recommended: instead use a single struct to which fields can be added as needed.

### Query handlers {#handle-query}

A [Query](/encyclopedia/workflow-message-passing#sending-queries) is a synchronous operation that's used to get the state of a Workflow Execution.

```go
type Language string

const Chinese Language = "chinese"
const English Language = "english"
const French Language = "french"
const Spanish Language = "spanish"
const Portuguese Language = "portuguese"

const GetLanguagesQuery = "GetLanguages"

type GetLanguagesInput struct {
	IncludeUnsupported bool
}

func GreetingWorkflow(ctx workflow.Context) (string, error) {
    ...
    greeting := map[Language]string{English: "Hello", Chinese: "你好，世界"}
    err := workflow.SetQueryHandler(ctx, GetLanguagesQuery, func(input GetLanguagesInput) ([]Language, error) {
        // 👉 A Query handler returns a value: it can inspect but must not mutate the Workflow state.
        if input.IncludeUnsupported {
            return []Language{Chinese, English, French, Spanish, Portuguese}, nil
        } else {
            // Range over map is a nondeterministic operation.
            // It is OK to have a non-deterministic operation in a query function.
            //workflowcheck:ignore
            return maps.Keys(greeting), nil
        }
    })
    ...
}
```

- Use [`SetQueryHandler`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SetQueryHandler) to set a Query Handler that listens for a Query by name.
- Don't include any logic that causes [Command](/workflows#command) generation within a Query handler (such as executing Activities).
Including such logic causes unexpected behavior.
- The handler must be a function that returns two values, a serializable result and an error

### Signal Channels {#handle-signal}

A [Signal](/encyclopedia/workflow-message-passing#sending-signals) is a message sent asynchronously to a running Workflow Execution which can be used to change the state and control the flow of a Workflow Execution.

```go
const ApproveSignal = "approve"

type ApproveInput struct {
	Name string
}

func GreetingWorkflow(ctx workflow.Context) error {
    logger := workflow.GetLogger(ctx)
	approverName := ""
	...
	// Block until the language is approved
	var approveInput ApproveInput
	workflow.GetSignalChannel(ctx, ApproveSignal).Receive(ctx, &approveInput)
	approverName = approveInput.Name
	logger.Info("Received approval", "Approver", approverName)
	...
}
```

- Use [`GetSignalChannel`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetSignalChannel) to get the Signal Channel that listen for Signals by the Signal's name.
- Before completing the Workflow or using [Continue-As-New](/develop/go/continue-as-new), make sure to do an asynchronous drain on the Signal channel.
Otherwise, the Signals will be lost.

### Update handlers and validators {#handle-update}

An [Update](/encyclopedia/workflow-message-passing#sending-updates) is a trackable request sent synchronously to a running Workflow Execution that can change the state and control the flow of a Workflow Execution, and return a result. The sender of the request must wait until the Update is at least accepted or rejected by a Worker, and will often opt to wait further to receive the value returned by the Update handler, or an error indicating what went wrong.

```go
type Language string

const SetLanguageUpdate = "set-language"

func GreetingWorkflow(ctx workflow.Context) error {
	language := English

	err = workflow.SetUpdateHandlerWithOptions(ctx, SetLanguageUpdate, func(ctx workflow.Context, newLanguage Language) (Language, error) {
		// 👉 An Update handler can mutate the Workflow state and return a value.
		var previousLanguage Language
		previousLanguage, language = language, newLanguage
		return previousLanguage, nil
	}, workflow.UpdateHandlerOptions{
		Validator: func(ctx workflow.Context, newLanguage Language) error {
			if _, ok := greeting[newLanguage]; !ok {
				// 👉 In an Update validator you return any error to reject the Update.
				return fmt.Errorf("%s unsupported language", newLanguage)
			}
			return nil
		},
	})
  ...
}
```

- Register an Update handler for a given name using either [workflow.SetUpdateHandler](https://pkg.go.dev/go.temporal.io/sdk/workflow#SetUpdateHandler) or [workflow.SetUpdateHandler](https://pkg.go.dev/go.temporal.io/sdk/workflow#SetUpdateHandlerWithOptions).
- You must include a `workflow.Context` parameter in the first position of the function.
- The function can return either a serializable value with an error or just an error.
- To reject an update you must return an error or panic in the validator.
- Validators are optional; if you don't want to be able to reject updates then you don't need a validator.
- The validator must take the same argument type as the handler, but always returns an error.
- The Workflow's WorkflowPanicPolicy determines how panics are handled inside the Handler function.

## Sending Messages

### Sending a Query {#send-query}

Queries are sent from a Temporal Client.

Use [`Client.QueryWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/client#Client.QueryWorkflow) or [`Client.QueryWorkflowWithOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#Client.QueryWorkflowWithOptions).

```go
// ...
supportedLangResult, err := temporalClient.QueryWorkflow(context.Background(), we.GetID(), we.GetRunID(), message.GetLanguagesQuery, message.GetLanguagesInput{IncludeUnsupported: false})
if err != nil {
    log.Fatalf("Unable to query workflow: %v", err)
}
var supportedLang []message.Language
err = supportedLangResult.Get(&supportedLang)
if err != nil {
    log.Fatalf("Unable to get query result: %v", err)
}
log.Println("Supported languages:", supportedLang)
// ...
```

- Sending a Query does not add any events to the Workflow's Event History.
- You can send a Query to a Workflow Execution that has closed.

### Sending a Signal {#send-signal}

- A Signal can only be sent to a Workflow Execution that has not already closed.
- A Signal can be sent to a Workflow Execution from a Temporal Client or from another Workflow Execution.

#### Sending a Signal from a Client {#send-signal-from-client}

Use [`Client.SignalWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/client#Client.SignalWorkflow).

Pass in both the [Workflow Id](/workflows#workflow-id) and [Run Id](/workflows#run-id) to uniquely identify the Workflow Execution.
If only the Workflow Id is supplied (provide an empty string as the Run Id param), the Workflow Execution that is Running receives the Signal.

```go
// ...
err = temporalClient.SignalWorkflow(context.Background(), we.GetID(), we.GetRunID(), message.ApproveSignal, message.ApproveInput{Name: ""})
if err != nil {
    log.Fatalf("Unable to signal workflow: %v", err)
}
// ...
```
- The call will return as soon as the server accepts the Signal: it does _not_ wait for the Signal to be delivered to the Workflow Execution.
- The [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Workflow's Event History if the Server accepts the Signal.

#### Sending a Signal from a Workflow {#send-signal-from-workflow}

A Workflow can send a Signal to another Workflow, in which case it's called an External Signal.

```go
// ...
func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {
  ...
  signal := MySignal {
    Message: "Some important data",
  }
  err :=  workflow.SignalExternalWorkflow(ctx, "some-workflow-id", "", "your-signal-name", signal).Get(ctx, nil)
  if err != nil {
    // ...
  }
// ...
}
```

When an External Signal is sent:
- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.
- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.

#### Signal-With-Start {#signal-with-start}

Signal-With-Start is used from the Client.
It takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.

If there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.

Use the [`Client.SignalWithStartWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/client#Client.SignalWithStartWorkflow) API to start a Workflow Execution (if not already running) and pass it the Signal at the same time.

Because the Workflow Execution might not exist, this API does not take a Run ID as a parameter

```go
// ...
signal := MySignal {
  Message: "Some important data",
}
err = temporalClient.SignalWithStartWorkflow(context.Background(), "your-workflow-id", "your-signal-name", signal)
if err != nil {
	log.Fatalln("Error sending the Signal", err)
	return
}
```

### Sending an Update {#send-update}

- A client sending an Update must be prepared to wait until the Server has delivered the Update to the Worker: that means that the Worker must not be offline, and must not respond too slowly. If you want the server to send a response as soon as it receives your request, then you must use a Signal instead.
- WorkflowExecutionUpdateAccepted will be added to Event History when the Worker has responded to the Server that the Update passed validation.
- WorkflowExecutionUpdateCompleted will be added to Event History when the Worker has responded to the Server that the Update has completed.

It is not yet possible to send an Update to another Workflow, or to do the Update equivalent of Signal-With-Start.

Use the [`Client.UpdateWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/client#Client.UpdateWorkflow) API to a Workflow Execution.

You must provide the Workflow Id, but specifying a Run Id is optional.
If you supply only the Workflow Id (and provide an empty string as the Run Id param), the currently running Workflow Execution receives the Update.

You must provide a `WaitForStage` when calling `UpdateWorkflow()`.
This parameter controls what stage the update must reach before a handle is returned to the caller. If `WaitForStage` is set to `WorkflowUpdateStageCompleted` the handle is returned after the update completes, if `WaitForStage` is set to `WorkflowUpdateStageAccepted` the handle is returned after the update is accepted (i.e. the validator has run).

```go
updateHandle, err := temporalClient.UpdateWorkflow(context.Background(), client.UpdateWorkflowOptions{
    WorkflowID:   we.GetID(),
    RunID:        we.GetRunID(),
    UpdateName:   message.SetLanguageUpdate,
    WaitForStage: client.WorkflowUpdateStageAccepted,
    Args:         []interface{}{message.Chinese},
})
if err != nil {
    log.Fatalf("Unable to update workflow: %v", err)
}
var previousLang message.Language
err = updateHandle.Get(context.Background(), &previousLang)
if err != nil {
    log.Fatalf("Unable to get update result: %v", err)
}
```

## Troubleshooting

See [Exceptions in message handlers](/encyclopedia/workflow-message-passing#exceptions) for a non–Go-specific introduction.

As a client, when you send a Signal, Update, or Query to a Workflow, the following two errors are always possible:
1. **The client can't contact the server**
1. **The workflow does not exist**

### Problems when sending an Update
1. **There is no Workflow Worker polling the Task Queue**

    Your request will be retried by the SDK Client until the calling context is cancelled.

1. **Update failed.**

        Update failure is analogous to [Workflow failure](/references/failures#errors-in-workflows) in the sense that all the things that cause Workflow failure when they happen in the main Workflow function, cause Update failure when they happen in an Update handler.
        Examples of things that cause Update/Workflow failure in this way include:
        - A failed Child Workflow
        - A failed Activity (if the activity retries have been set to a finite number)
        - The Workflow author retuning an `error`
        - A panic in the handler depending on the `WorkflowPanicPolicy`.

1. **The handler caused the Workflow Task to fail.**

    As always with a [Workflow Task Failure](/references/failures#errors-in-workflows), the server starts to retry the Workflow Task indefinitely.
    What happens to your Update request depends on the stage that it has got to.
    If it had not yet been accepted by the server then you'll get a [`FAILED_PRECONDITION`](https://pkg.go.dev/go.temporal.io/api/serviceerror#FailedPrecondition).
    On the other hand, if it had been [accepted](#send-update) by the server, then it is durable, and as soon as the Workflow becomes healthy again (perhaps as a result of a code deploy) then you can use an [`WorkflowUpdateHandle`](https://pkg.go.dev/go.temporal.io/sdk/client#WorkflowUpdateHandle) to fetch the update result.

1. **Workflow finished while the Update handler execution was in progress**

    You'll get a [`ServiceError`](https://pkg.go.dev/go.temporal.io/api/serviceerror#ServiceError) "workflow execution already completed"`

    This will happen if the Workflow finished while the Update handler execution was in progress, for example because
    - The Workflow was canceled or failed.
    - The Workflow completed normally or continued-as-new and the Workflow author did not [wait for handlers to be finished](/encyclopedia/workflow-message-passing#finishing-message-handlers).

### Problems when sending a Query

1. **There is no Workflow Worker polling the Task Queue**

    You'll get an [`ServiceError`](https://pkg.go.dev/go.temporal.io/api/serviceerror#ServiceError) on which the `status` is `FAILED_PRECONDITION`.

1. **Query failed.**
    You'll get [`QueryFailed`](https://pkg.go.dev/go.temporal.io/api/serviceerror#QueryFailed).
    Any panic in a Query handler will cause this.
    Note that this differs from Signal and Update, for which panics can cause Workflow Task Failure.

1. **The handler caused the Workflow Task to fail.**
    This would happen, for example, if the Query handler blocks the thread for too long without yielding.

## Message handler patterns {#message-handler-patterns}

In addition to the topics below, see [Inject work into the main Workflow](/encyclopedia/workflow-message-passing#injecting-work-into-main-workflow) and [Ensuring your messages are processed exactly once](/encyclopedia/workflow-message-passing#exactly-once-message-processing).

### Blocking handlers {#blocking-handlers}

In the examples above, all the Update handlers did not block. But handlers can also be blocking. This means you can wait for Activities, Child Workflows, timers, `workflow.Await` conditions, etc, in Update Handlers thus opening up many powerful possibilities. However, this means that handler executions, and your main Workflow method, are all running concurrently, with switching occurring between them at await calls. (I.e. they interleave, but there is no parallelism.) It's essential to understand the things that could go wrong in order to use blocking handlers safely. See Workflow message passing for guidance on safe usage of async Update handlers, the Safe message handlers sample, and the Controlling handler concurrency and Waiting for message handlers to finish sections below.

As an example of an blocking update handler, in the following code sample the Update handler from above has been changed to be an async def so that it can execute an Activity to make a network call to a remote service:

```go
func GreetingWorkflow(ctx workflow.Context) error {
	language := English

	err = workflow.SetUpdateHandler(ctx, SetLanguageUpdate, func(ctx workflow.Context, newLanguage Language) (Language, error) {
        if _, ok := greeting[newLanguage]; !ok {
            ao := workflow.ActivityOptions{
                StartToCloseTimeout: 10 * time.Second,
            }
            ctx = workflow.WithActivityOptions(ctx, ao)

            var greeting string
            err := workflow.ExecuteActivity(ctx, CallGreetingService, newLanguage).Get(ctx, &greeting)
            if err != nil {
                return nil, err
            }
            greeting[newLanguage] = greeting
        }
		var previousLanguage Language
		previousLanguage, language = language, newLanguage
		return previousLanguage, nil
	})
  ...
}
```

#### Waiting

[`workflow.Await(...)`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Await) is very useful in Temporal Workflow Definitions.
It allows Workflow code to wait until an arbitrary function returns `true`. See [Workflow message passing](/encyclopedia/workflow-message-passing) for guidance on safe usage of blocking Update handlers, the [Safe message handlers](https://github.com/temporalio/samples-python/tree/main/updates_and_signals/safe_message_handlers) sample, and the [Controlling handler concurrency](#control-handler-concurrency) and [Waiting for message handlers to finish](#wait-for-message-handlers) sections below.

For example, in an workflow function it could be used to wait until the handler execution can proceed, according to Workflow implementation logic:
```go
err = workflow.SetUpdateHandler(ctx, "UpdateHandler", func(ctx workflow.Context, input UpdateInput) error {
    workflow.Await(ctx, updateUnblockedFunc)
    ...
})
```
This is necessary if your Update handlers require something in the main Workflow function to be done first, since an Update handler can execute concurrently with the main Workflow function.

#### Use `workflow.Mutex` to prevent concurrent handler execution {#control-handler-concurrency}
See [Message handler concurrency](/encyclopedia/workflow-message-passing#message-handler-concurrency).

Sometimes you may write code that is incorrect if multiple instances of a handler are in progress concurrently. Here's an example:
```go
// ...
func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {
    ...
    err := workflow.SetUpdateHandler(ctx, "BadUpdateHandler", func(ctx workflow.Context) error {
        ao := workflow.ActivityOptions{
            StartToCloseTimeout: 10 * time.Second,
        }
	    ctx = workflow.WithActivityOptions(ctx, ao)

	    var result Data
	    err := workflow.ExecuteActivity(ctx, FetchData, name).Get(ctx, &result)
        x = result.x
        // 🐛🐛 Bug!! If multiple instances of this handler are executing concurrently, then
        // there may be times when the Workflow has self.x from one Activity execution and self.y from another.
        err = workflow.Sleep(ctx, time.Second)
		if err != nil {
			return err
		}
        y = result.y
    })
    ...
}
```
To make this safe, you can use `workflow.Mutex`:

```go
func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {
    ...
	err := workflow.SetUpdateHandler(ctx, "SafeUpdateHandler", func(ctx workflow.Context) error {
		err := mutex.Lock(ctx)
		if err != nil {
			return err
		}
		defer mutex.Unlock()
		ao := workflow.ActivityOptions{
			StartToCloseTimeout: 10 * time.Second,
		}
		ctx = workflow.WithActivityOptions(ctx, ao)

		var result Data
		err := workflow.ExecuteActivity(ctx, FetchData, name).Get(ctx, &result)
		x = data.x
		err = workflow.Sleep(ctx, time.Second)
		if err != nil {
			return err
		}
		self.y = data.y
	})
    ...
}

```

#### Finishing handlers before the Workflow completes {#wait-for-message-handlers}
See [Finishing handlers before the Workflow completes](/encyclopedia/workflow-message-passing#finishing-message-handlers).

Invoke the `UpdateWorkflow()` method on an instance of the [Go SDK Temporal Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) to dispatch an [Update](/encyclopedia/workflow-message-passing#sending-updates) to a Workflow Execution.

If your Workflow has an Update handler, then there is nothing to stop you allowing your Workflow function to return or continue-as-new while a handler execution is waiting on something such as an Activity result.
However, this means that the handler may have been interrupted before it finished important work and the client will get an error when they try to retrieve their Update result.


You can avoid this by using [`workflow.Await`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Await) to wait for [`AllHandlersFinished`](https://pkg.go.dev/go.temporal.io/sdk/workflow#AllHandlersFinished) to return `true`:

```go
func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {
    ...
	err = workflow.Await(ctx, func() bool {
		return workflow.AllHandlersFinished(ctx)
	})
    return nil
}
```

By default, your Worker will log a warning if you allow your Workflow Execution to finish with unfinished update handler executions.
You can silence these warnings on a per-handler basis by setting `UnfinishedPolicy` field on [`workflow.UpdateHandlerOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#UpdateHandlerOptions) struct:

```go
	err = workflow.SetUpdateHandlerWithOptions(ctx, UpdateHandlerName, UpdateFunc, workflow.UpdateHandlerOptions{
        UnfinishedPolicy: workflow.HandlerUnfinishedPolicyAbandon,
	})
```
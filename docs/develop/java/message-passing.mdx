---
id: message-passing
title: Messages - Temporal Java SDK feature guide
sidebar_label: Messages
description: A Signal is a message sent to a running Workflow Execution, defined and handled in Workflow Definition code. Signals can be sent from a Temporal Client or another Workflow Execution.
toc_max_heading_level: 4
keywords:
  - temporal java signals
  - send signal from client
  - send signal from workflow
  - signal with start
  - workflow queries
  - sending queries
  - workflow updates
  - dynamic workflows
  - dynamic activities
  - dynamic signals
  - dynamic queries
tags:
  - java
  - java-sdk
  - workflows
  - messages
  - signals
  - queries
  - updates
  - dynamic-handlers
---

See [Workflow message passing](/encyclopedia/workflow-message-passing) for a nonâ€“Java-specific
introduction to using messages with Temporal Workflows.

The code samples below form part of a complete working sample, viewable at [message_passing/introduction](TODO).

General guidelines for writing message handlers:

- Arguments and return values of handlers (and the main Workflow function) must be [serializable](/dataconversion): a class will often be the right choice.
- It's possible to write handler methods that take multiple arguments, but this is not recommended: instead use a single class argument to which fields can be added as needed.

### Query handlers {#handle-query}

A [Query](/encyclopedia/workflow-message-passing#sending-queries) is a synchronous operation that's used to get the state of a Workflow Execution.

```java
public class MessagePassingIntro {

    public enum Language {
        CHINESE,
        ENGLISH,
        FRENCH,
        SPANISH,
        PORTUGUESE,
    }

    public static class GetLanguagesInput {
        public boolean includeUnsupported;

        public GetLanguagesInput() {
            this.includeUnsupported = false;
        }

        public GetLanguagesInput(boolean includeUnsupported) {
            this.includeUnsupported = includeUnsupported;
        }
    }

    @WorkflowInterface
    public interface GreetingWorkflow {
        ...
        @QueryMethod
        List<Language> getLanguages(GetLanguagesInput input);
    }

    public static class GreetingWorkflowImpl implements GreetingWorkflow {
        ...
        @Override
        public List<Language> getLanguages(GetLanguagesInput input) {
            if (input.includeUnsupported) {
                return Arrays.asList(Language.values());
            } else {
                return new ArrayList(greetings.keySet());
            }
        }
    }

}
```

- The annotation can take arguments. See the API reference docs: [`@QueryMethod`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/QueryMethod.html).
- A Query handler must not modify workflow state, you can't do any blocking operations such as executing an Activity in a Query handler.

### Signal handlers {#handle-signal}

A [Signal](/encyclopedia/workflow-message-passing#sending-signals) is a message sent asynchronously to a running Workflow Execution which can be used to change the state and control the flow of a Workflow Execution.

```java
public class MessagePassingIntro {
  
    public static class ApproveInput {
        private String name;

        public ApproveInput() {}

        public ApproveInput(String name) {
            this.name = name;
        }
    }

    @WorkflowInterface
    public interface GreetingWorkflow {
        ...
        @SignalMethod
        void approve(ApproveInput input);
    }

    public static class GreetingWorkflowImpl implements GreetingWorkflow {
        ...
        @Override
        public Language setLanguage(Language language) {
            Language previousLanguage = this.language;
            this.language = language;
            return previousLanguage;
        }
    }
}
```

- The annotation can take arguments. See the API reference docs: [`@SignalMethod`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/SignalMethod.html).
- The handler cannot return a value: (the sender of a signal gets a response immediately from the server, without waiting for the workflow to receive the signal).
- Signal (and Update) handlers can also be blocking and thus use Activities, Child Workflows, durable [`Workflow.sleep`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#sleep(java.time.Duration)) timers, [`Workflow.await`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#await(java.time.Duration,java.util.function.Supplier)) conditions, etc. See [Async handlers](#async-handlers) below, and read [Workflow message passing](/encyclopedia/workflow-message-passing) for an introduction to safe usage of async Signal and Update handlers.

### Update handlers and validators {#handle-update}

An [Update](/encyclopedia/workflow-message-passing#sending-updates) is a trackable request sent synchronously to a running Workflow Execution that can change the state and control the flow of a Workflow Execution, and return a result. The sender of the request must wait until the Update is at least accepted or rejected by a Worker, and will often opt to wait further to receive the value returned by the Update handler, or an exception indicating what went wrong.

```java
public class MessagePassingIntro {
    @WorkflowInterface
    public interface GreetingWorkflow {
        ...
        @UpdateMethod
        Language setLanguage(Language language);

        @UpdateValidatorMethod(updateName = "setLanguage")
        void setLanguageValidator(Language language);
    }

    public static class GreetingWorkflowImpl implements GreetingWorkflow {
        ...
        @Override
        public Language setLanguage(Language language) {
            Language previousLanguage = this.language;
            this.language = language;
            return previousLanguage;
        }

        @Override
        public void setLanguageValidator(Language language) {
            if (!greetings.containsKey(language)) {
                throw new IllegalArgumentException("Unsupported language: " + language);
            }
        }
    }
}
```

- The annotation can take arguments. See the API reference docs: [`@UpdateMethod`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/UpdateMethod.html).
- Validators are optional; if you don't want to be able to reject updates then you don't need a validator.
- Update (and Signal) handlers can also be blocking and thus use Activities, Child Workflows, durable [`Workflow.sleep`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#sleep(java.time.Duration)) timers, [`Workflow.await`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#await(java.time.Duration,java.util.function.Supplier)) conditions, etc. See [Async handlers](#async-handlers) below, and read [Workflow message passing](/encyclopedia/workflow-message-passing) for an introduction to safe usage of async Signal and Update handlers.

## Sending messages

To send Queries, Signals, or Updates you call the annotated methods on a `WorkflowInterface` often called the ``WorkflowStub`.
To obtain the `WorkflowStub`, you can:
- Use the [newWorkflowStub(java.lang.Class<T> workflowInterface, WorkflowOptions options)](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClient.html#newWorkflowStub(java.lang.Class,io.temporal.client.WorkflowOptions)) to create a stub for a workflow.
- Use the [newWorkflowStubâ€‹(java.lang.Class<T> workflowInterface, java.lang.String workflowId, java.util.Optional<java.lang.String> runId)](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClient.html#newWorkflowStub(java.lang.Class,java.lang.String,java.util.Optional)) method to get a Workflow handle for a existing workflow execution.

```java
WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();

WorkflowClient client = WorkflowClient.newInstance(service);

WorkflowOptions workflowOptions =
    WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();

// Create the workflow client stub. It is used to start the workflow execution.
GreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);

// Start workflow asynchronously and call its getGreeting workflow method
WorkflowClient.start(workflow::getGreetings);
```

### Sending a Query {#send-query}

To send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.

For example:
```java
List<Language> languages = workflow.getLanguages(new GetLanguagesInput(false));
System.out.println("Supported languages: " + languages);
```

To find out what argument type to provide (and what return type to expect for Queries and Updates), look at the corresponding handler method on the Workflow interface.

- Sending a Query does not add any events to the Workflow's Event History.
- You can send a Query to a Workflow Execution that has closed.

### Sending a Signal

- A Signal can only be sent to a Workflow Execution that has not already closed.
- A Signal can be sent to a Workflow Execution from a Temporal Client or from another Workflow Execution.

#### Sending a Signal from a Client {#send-signal-from-client}

To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.

```java
workflow.approve(new ApproveInput("Me"));
```

- The call will return as soon as the server accepts the Signal: it does _not_ wait for the Signal to be delivered to the Workflow Execution.
- The [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Workflow's Event History if the Server accepts the Signal.

#### Sending a Signal from a Workflow {#send-signal-from-workflow}

A Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.

To send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow:
- Use [`Workflow.newExternalWorkflowStub`](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#newExternalWorkflowStub(java.lang.Class,io.temporal.api.common.v1.WorkflowExecution)) to get a `WorkflowStub` to an existing Workflow.

```java
public String sendGreeting(String name) {
    // initiate ExternalWorkflowStub to call another Workflow by its Id "ReplyWF"
    GreetingWorkflows parent =
          Workflow.newExternalWorkflowStub(GreetingWorkflows.class, ReplyWF);
    String responseTrigger = activity.greeting("Hello", name);

    // send a Signal from this sendGreeting Workflow to the other Workflow
    // by calling the Signal method name "getGreetCall" defined in that Workflow.
    parent.getGreetCall(responseTrigger);

    return responseTrigger;
}

When an External Signal is sent:
- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.
- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.

#### Signal-With-Start {#signal-with-start}

Signal-With-Start is sent by a Client.

If there's a Workflow running with the given Workflow Id, the Signal will be sent to it. If there isn't, a new Workflow will be started and the Signal will be sent immediately on start.

In the following example, the Client code uses `SignalWithStart` to send the Signal `setCustomer` to the `UntypedWorkflowStub` named `GreetingWorkflow`.
If the `GreetingWorkflow` Workflow Execution is not running, the `SignalWithStart` starts the Workflow Execution.

```java
public static void signalWithStart() {
    // WorkflowStub is a client-side stub to a single Workflow instance
    WorkflowStub untypedWorkflowStub = client.newUntypedWorkflowStub("GreetingWorkflow",
    WorkflowOptions.newBuilder()
            .setWorkflowId(workflowId)
            .setTaskQueue(taskQueue)
            .build());

    untypedWorkflowStub.signalWithStart("setCustomer", new Object[] {customer2}, new Object[] {customer1});

    printWorkflowStatus();

    try {
        String greeting = untypedWorkflowStub.getResult(String.class);
        printWorkflowStatus();
        System.out.println("Greeting: " + greeting);
    } catch(WorkflowFailedException e) {
        System.out.println("Workflow failed: " + e.getCause().getMessage());
        printWorkflowStatus();
    }
}
```

The following example shows the Workflow interface for the `GreetingWorkflow` called in the previous example.

```java
@WorkflowInterface
public interface GreetingWorkflow {
    @WorkflowMethod
    String greet(Customer customer);

    @SignalMethod
    void setCustomer(Customer customer);

    @QueryMethod
    Customer getCustomer();
}
```

Note that the Signal handler `setCustomer` is executed before the `@WorkflowMethod` `greet` is called.

### Sending an Update {#send-update}

- A client sending an Update must be prepared to wait until the Server has delivered the Update to the Worker: that means that the Worker must not be offline, and must not respond too slowly.
  If you want the server to send a response as soon as it receives your request, then you must use a Signal instead. 
- `WorkflowExecutionUpdateAccepted` will be added to Event History when the Worker has responded to the Server that the Update passed validation.
- `WorkflowExecutionUpdateCompleted` will be added to Event History when the Worker has responded to the Server that the Update has completed.

It is not yet possible to send an Update to another Workflow, or to do the Update equivalent of Signal-With-Start.

To send an Update to a Workflow Execution, you have two choices:
1. Call the Update method, annotated with `@UpdateMethod` in the Workflow interface, from the Client code. This sends an Update and waits until it has been completed by a Worker. It returns the Update result:
```java
  Language previousLanguage = workflow.setLanguage(Language.CHINESE);
```
2. Use [`startUpdate`](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html#startUpdate(io.temporal.client.UpdateOptions,java.lang.Object...)) to receive a handle as soon as the update is accepted or rejected. It returns an [`UpdateHandle`](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/UpdateHandle.html):
You would use this when the Update handler does some long-running blocking code (i.e. it waits for Activities, Child Workflows, timers, or `await`), but you don't want to wait for all this activity to be finished; instead you want to wait only until the Worker has accepted or rejected the Update.
See the "Async handlers" section.
```java
UpdateHandle<Language> handle =
    WorkflowStub.fromTyped(workflow)
        .startUpdate(
            "setLanguage", WorkflowUpdateStage.ACCEPTED, Language.class, Language.ENGLISH);
previousLanguage = handle.getResultAsync().get();
```

#### Non-type safe APIs

Note that all the sample code in this document assumes that you can import the Workflow Interface.
If you do not have access to the Workflow Interface (or it is not written in Java) then you can still do everything documented here by using non type-safe APIs.
This involves passing method names instead of methods to [`WorkflowClient.newUntypedWorkflowStub`](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClient.html#newUntypedWorkflowStub(java.lang.String,io.temporal.client.WorkflowOptions)) / [`WorkflowStub.query`](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html#query(java.lang.String,java.lang.Class,java.lang.Object...)) / [`WorkflowStub.signal`](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html#signal(java.lang.String,java.lang.Object...)) / [`WorkflowStub.update`](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html#update(java.lang.String,java.lang.Class,java.lang.Object...)) / [`WorkflowStub.startUpdate`](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html#startUpdate(io.temporal.client.UpdateOptions,java.lang.Object...)), and using the non type-safe APIs [`newUntypedWorkflowStubâ€‹`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClient.html#newUntypedWorkflowStub(java.lang.String,io.temporal.client.WorkflowOptions)) and [`Workflow.newUntypedExternalWorkflowStub`](https://javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#newUntypedExternalWorkflowStub(java.lang.String)).

## Exceptions

See [Exceptions in message handlers](/encyclopedia/workflow-message-passing#exceptions) for a nonâ€“Java-specific introduction to this topic.


## Message handler patterns {#message-handler-patterns}

In addition to the topics below, see [Inject work into the main Workflow](/encyclopedia/workflow-message-passing#injecting-work-into-main-workflow) and [Ensuring your messages are processed exactly once](/encyclopedia/workflow-message-passing#exactly-once-message-processing).

### Async handlers {#async-handlers}

Users may choose to block in update handlers to wait for Activities, Child Workflows, [`Workflow.sleep`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#sleep(java.time.Duration)) timers, [`Workflow.await`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#await(java.time.Duration,java.util.function.Supplier)), etc, thus opening up many powerful possibilities.
However, this means that handler executions, and your main Workflow method, are all running concurrently, with switching occurring between them at blocking call sites.
(I.e. they interleave, but there is no parallelism.)
It's essential to understand the things that could go wrong in order to use blocking handlers safely.
See [Workflow message passing](/encyclopedia/workflow-message-passing) for guidance on safe usage of blocking Signal and Update handlers, and the [Controlling handler concurrency](#control-handler-concurrency) and [Waiting for message handlers to finish](#wait-for-message-handlers) sections below.

As an example of an blocking handler, in the following code sample the Update handler from above has been changed to be blocking so that it can execute an Activity to make a network call to a remote service:

```java
public static class GreetingWorkflowImpl implements GreetingWorkflow {
    ...
    @Override
    public Language setLanguage(Language language) {
        if (!greetings.containsKey(language)) {
            String greeting = activity.greetingService(language);
            if (greeting == null) {
                // ðŸ‘‰ An update validator cannot be blocking, so cannot be used to check that the remote
                // greetingService supports the requested language. Throwing an ApplicationFailure
                // will fail the Update, but the WorkflowExecutionUpdateAccepted event will still be
                // added to history.
                throw ApplicationFailure.newFailure("Greeting service does not support", "GreetingFailure")
            }
            greetings.put(language, greeting);
        }
        Language previousLanguage = this.language;
        this.language = language;
        return previousLanguage;
    }
}
```

The Update handler is now able to schedule an Activity and wait for the result -- but this could be done with a Signal handler also.
In contrast to a Signal, the client sending the Update will not get an Update result until the Activity has completed and the Workflow has received a response or error from the remote service.

#### Waiting

[`Workflow.await`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#await(java.time.Duration,java.util.function.Supplier)) is very useful in Temporal Workflow Definitions.
It allows Workflow code to wait until an arbitrary function returns `true`.

```java
    @Override
    public String setLanguage(UpdateInput input) {
        Workflow.await(() -> this.updateReadyToExecute(input));
        ...
    }
```

This is necessary if your Signal or Update handlers require something in the main Workflow method to be done first, since a Signal or Update handler can execute before the main Workflow method has started.


#### Use `WorkflowLock` to prevent concurrent handler execution {#control-handler-concurrency}

See [Message handler concurrency](/encyclopedia/workflow-message-passing#message-handler-concurrency).

Sometimes you may write code that is incorrect if multiple instances of a handler are in progress concurrently.

```java
public class DataWorkflowImpl implements DataWorkflow {
    ...
    @Override
    public void badSignalHandler() {
        Data data = activity.fetchData();
        this.x = data.x;
        // ðŸ›ðŸ› Bug!! If multiple instances of this method are executing concurrently, then
        // there may be times when the Workflow has self.x from one Activity execution and self.y from another.
        Workflow.sleep(Duration.ofSeconds(1));
        this.y = data.y;
    }
}
```

To make this safe, you can use a `WorkflowLock`:

```java
public class DataWorkflowImpl implements DataWorkflow {
    WorkflowLock lock = Workflow.newWorkflowLock();
    ...
    @Override
    public void sageSignalHandler() {
        try {
            lock.lock();    
            Data data = activity.fetchData();
            this.x = data.x;
            // ðŸ›ðŸ› Bug!! If multiple instances of this method are executing concurrently, then
            // there may be times when the Workflow has self.x from one Activity execution and self.y from another.
            Workflow.sleep(Duration.ofSeconds(1));
            this.y = data.y;
        } finally {
            lock.unlock()
        }
    }
}
```

#### Finishing handlers before the Workflow completes {#wait-for-message-handlers}
See [Finishing handlers before the Workflow completes](/encyclopedia/workflow-message-passing#finishing-message-handlers).


If your Workflow has a blocking Signal or Update handlers, then there is nothing to stop you allowing your main Workflow method to return or continue-as-new while a handler execution is waiting on something such as an Activity result.
However, this means that the handler may have been interrupted before it finished important work.
And if it's an Update handler, then the client will get an error when they try to retrieve their Update result.

You can avoid this by using [`Workflow.await`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#await(java.time.Duration,java.util.function.Supplier)) to wait for [`Workflow.isEveryHandlerFinished`]() to return `true`:
```java
public class MyWorkflowImpl implements MyWorkflow {
    ...
    @Override
    public String run() {
        ...
        Workflow.await(() -> Workflow.isEveryHandlerFinished());
        return "workflow-result";
    }
}
```

By default, your Worker will log a warning if you allow your Workflow Execution to finish with unfinished handler executions.
You can silence these warnings on a per-handler basis by passing the `unfinishedPolicy` argument to the [`@SignalMethod`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/SignalMethod.html) / [`@UpdateMethod`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/UpdateMethod.html) annotation:

```java
@WorkflowInterface
public interface MyWorkflow {
    ...
    @UpdateMethod(unfinishedPolicy = HandlerUnfinishedPolicy.ABANDON)
    void myUpdate();
}
```

## Dynamic Handlers {#dynamic-handler}

**What is a Dynamic Handler in Temporal Java SDK?**

Temporal supports Dynamic Workflows, Activities, Signals, and Queries.
These are unnamed handlers that are invoked if no other statically defined handler with the given name exists.

Dynamic Handlers provide flexibility to handle cases where the names of Workflows, Activities, Signals, or Queries aren't known at runtime.

:::caution

Dynamic Handlers should be used judiciously as a fallback mechanism rather than the primary approach.
Overusing them can lead to maintainability and debugging issues down the line.

Instead, Workflows, Activities, Signals, and Queries should be defined statically whenever possible, with clear names that indicate their purpose.
Use static definitions as the primary way of structuring your Workflows.

Reserve Dynamic Handlers for cases where the handler names are not known at compile time and need to be looked up dynamically at runtime.
They are meant to handle edge cases and act as a catch-all, not as the main way of invoking logic.

:::

### Set a Dynamic Workflow {#set-a-dynamic-workflow}

Use [`DynamicWorkflow`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/DynamicWorkflow.html) to implement Workflow Types dynamically.
Register a Workflow implementation type that extends `DynamicWorkflow` to implement any Workflow Type that is not explicitly registered with the Worker.

The dynamic Workflow interface is implemented with the `execute` method. This method takes in `EncodedValues` that are inputs to the Workflow Execution.
These inputs can be specified by the Client when invoking the Workflow Execution.

```java
public class MyDynamicWorkflow implements DynamicWorkflow {
    @Override
    public Object execute(EncodedValues args) {
    }
}
```

### How to set a Dynamic Activity {#set-a-dynamic-activity}

To handle Activity types that do not have an explicitly registered handler, you can directly implement a dynamic Activity.

Use `DynamicActivity` to implement any number of Activity types dynamically.
When an Activity implementation that extends `DynamicActivity` is registered, it is called for any Activity type invocation that doesn't have an explicitly registered handler.

The dynamic Activity interface is implemented with the `execute` method, as shown in the following example.

```java
// Dynamic Activity implementation
public static class DynamicGreetingActivityImpl implements DynamicActivity {
    @Override
    public Object execute(EncodedValues args) {
        String activityType = Activity.getExecutionContext().getInfo().getActivityType();
        return activityType
            + ": "
            + args.get(0, String.class)
            + " "
            + args.get(1, String.class)
            + " from: "
            + args.get(2, String.class);
    }
}
```

Use `Activity.getExecutionContext()` to get information about the Activity type that should be implemented dynamically.

### How to set a Dynamic Signal {#set-a-dynamic-signal}

You can also implement Signal handlers dynamically. This is useful for library-level code and implementation of DSLs.

Use `Workflow.registerListener(Object)` to register an implementation of the `DynamicSignalListener` in the Workflow implementation code.

```java
Workflow.registerListener(
  (DynamicSignalHandler)
      (signalName, encodedArgs) -> name = encodedArgs.get(0, String.class));
```

When registered, any Signals sent to the Workflow without a defined handler will be delivered to the `DynamicSignalHandler`.
Note that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.
`DynamicSignalHandler` can be implemented in both regular and dynamic Workflow implementations.

### How to set a Dynamic Query {#set-a-dynamic-query}

You can also implement Query handlers dynamically. This is useful for library-level code and implementation of DSLs.

Use `Workflow.registerListener(Object)` to register an implementation of the `DynamicQueryListener` in the Workflow implementation code.

```java
Workflow.registerListener(
  (DynamicQueryHandler)
      (queryName, encodedArgs) -> name = encodedArgs.get(0, String.class));
```

When registered, any Queries sent to the Workflow without a defined handler will be delivered to the `DynamicQueryHandler`.
Note that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.
`DynamicQueryHandler` can be implemented in both regular and dynamic Workflow implementations.


**Dynamic Update Handler**

You can also implement Update handlers dynamically.
This is useful for library-level code and implementation of DSLs.

```java
Workflow.registerListener(
  (DynamicUpdateHandler)
      (updateName, encodedArgs) -> encodedArgs.get(0, String.class));
```

When registered, any Updates sent to the Workflow without a defined handler will be delivered to the `DynamicUpdateHandler`.
You can only register one `Workflow.registerListener(Object)` per Workflow Execution.
`DynamicUpdateHandler` can be implemented in both regular and dynamic Workflow implementations.

---
id: application-development-guide
title: Temporal Application development guide
sidebar_label: Application development
description: This guide is meant to be a comprehensive overview of Temporal concepts.
toc_max_heading_level: 3
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This guide is meant to be a comprehensive overview of Temporal concepts.

:::caution

This guide is a work in progress.
Some sections may be incomplete or missing for some languages.

:::

This guide is meant to be a comprehensive resource for developing a [Temporal Application](/docs/concepts/what-is-a-temporal-application).

It is broken down into four large sections:

- [Foundations](#foundations): The minimum things required to build and run a simple Workflow with a single Activity.
- [Features](#features): All of the general features available to a Temporal Application.
- [Analysis](#analysis): Features and tools available that give you insight into you application.
- [Scaling](#scaling): Things to consider and look for when scaling a Temporal Application to millions or billions of Workflow Executions.

## Foundations

This section covers the minimum set of concepts and implementation details needed to build and run a simple [Temporal Application](/docs/concepts/what-is-a-temporal-application).

### Run a dev Cluster

Whenever we are developing Temporal Applications, we want to have a [Temporal Cluster](/docs/concepts/what-is-a-temporal-cluster) up and running.
We can interact with a Cluster through [Temporal Client](/docs/concepts/what-is-a-temporal-sdk/#what-is-a-temporal-client) APIs and [tctl](/docs/tctl) commands.

There are four ways to quickly install and run a Temporal Cluster:

- [Docker](#docker): Using Docker Compose makes it easy to develop your Temporal Application locally.
- [Render](#render): Our [temporalio/docker-compose](https://github.com/temporalio/docker-compose) experience has been translated to Render's Blueprint format for an alternative cloud connection.
- [Helm charts](#helm-charts): Deploying a Cluster to [Kubernetes](https://kubernetes.io/) is an easy way to test the system and develop Temporal Applications.
- [Gitpod](#gitpod): One-click deployments are available for Go and TypeScript.

**We do not recommend using any of these methods in a [full (production) environment](/docs/server/production-deployment).**

#### Helm charts

Use [Temporal Helm charts](https://github.com/temporalio/helm-charts) to deploy the Temporal Server to a [Kubernetes](https://kubernetes.io/) cluster.

Deploying the Temporal Cluster with Helm is not recommended for a production environment, but it is a great way to test the system while developing Workflows.

#### Docker Compose

Use Docker Compose and Temporal Cluster Docker images to quickly install and run a Temporal Cluster locally while developing Workflows.

You must have [Docker](https://docs.docker.com/engine/install) and [Docker Compose](https://docs.docker.com/compose/install) installed.

Then clone the [temporalio/docker-compose](https://github.com/temporalio/docker-compose) repository and run `docker-compose up` from the root of that repo:

```bash
git clone https://github.com/temporalio/docker-compose.git
cd  docker-compose
docker-compose up
```

When the Temporal Cluster is running, the Temporal Web UI becomes available in your browser: [localhost:8088](http://localhost:8088/)

The preceding steps start and run a Temporal Cluster using a default configuration.
To try other configurations (different dependencies and databases), or to try a custom Docker image, follow the [temporalio/docker-compose README](https://github.com/temporalio/docker-compose/blob/main/README.md).

#### Render

[temporal-render-simple](https://github.com/temporalio/temporal-render-simple) translates our docker-compose to Render by using the [Auto-Setup Docker image](https://docs.temporal.io/blog/auto-setup).
We do not recommend using this technique for production because all four Temporal internal services (Frontend, Matching, History, and Worker) are run in one process, but the benefit is one-click deployments.

[![Deploy to Render](https://render.com/images/deploy-to-render-button.svg)](https://render.com/deploy?repo=https://github.com/temporalio/temporal-render-simple)

#### Gitpod

You can run a Temporal Cluster and develop Temporal Applications in your browser using [Gitpod](https://www.gitpod.io/).

One-click deployments are available for the [temporalio/samples-go](https://github.com/temporalio/samples-go) repo and the [temporalio/samples-typescript](https://github.com/temporalio/samples-typescript) repo.

A one-click deployment starts a Temporal Cluster using a Temporal Cluster Docker image, starts a Worker Process, and starts one of the application's sample Workflows.

It can take up to a full minute for the one-click deployments to get fully up and running.
When it is running, you can customize the application samples.

### Add your SDK

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

[![Build Status](https://badge.buildkite.com/ce6df3b1a8b375270261ae70fb2d2756af298fef3a0dac4d20.svg?theme=github&branch=master)](https://buildkite.com/temporal/temporal-go-client) [![Coverage Status](https://coveralls.io/repos/github/temporalio/temporal-go-sdk/badge.svg?branch=master)](https://coveralls.io/github/temporalio/temporal-go-sdk?branch=master) [![Go reference](https://pkg.go.dev/badge/go.temporal.io/sdk)](https://pkg.go.dev/go.temporal.io/sdk)

The Temporal Go SDK provides a framework for Temporal Application development in the Go language.
The SDK contains the following tools:

- A Temporal Client to communicate with a Temporal Cluster
- APIs to use within your Workflows
- APIs to create and manage Worker Entities and Worker Processes

#### Get the SDK

Add the [Temporal Go SDK](https://github.com/temporalio/sdk-go) to your project:

```bash
go get -u go.temporal.io/sdk@latest
```

Or clone the Go SDK repo to your preferred location:

```bash
git clone git@github.com:temporalio/sdk-go.git
```

#### Are there executable code samples?

You can find a complete list of executable code samples in the [samples library](/docs/samples-library/#go), which includes Temporal Go SDK code samples from the [temporalio/samples-go](https://github.com/temporalio/samples-go) repo.
Additionally, each of the Go SDK Tutorials is backed by a fully executable template application.

#### Where is the Go SDK technical reference?

The [Temporal Go SDK API reference](https://pkg.go.dev/go.temporal.io/sdk) is published on [pkg.go.dev](https://pkg.go.dev/go.temporal.io/sdk)

#### Where can I find video demos?

[Temporal Go SDK YouTube playlist](https://www.youtube.com/playlist?list=PLl9kRkvFJrlRYHYaTPnsvE46szyMIZLdk)

</TabItem>
<TabItem value="java">

[![Build status](https://badge.buildkite.com/663f6d1be81be6700c28c242b35905f20b68c4fda7b2c7c4e3.svg?branch=master)](https://buildkite.com/temporal/java-sdk-public)

The Temporal Java SDK provides a framework for Temporal Application development in Java.
The SDK contains the following tools:

- A Temporal Client to communicate with a Temporal Cluster
- APIs to use within your Workflows
- APIs to create and manage Worker Entities and Worker Processes

#### Get the SDK

Add the [Temporal Java SDK](https://github.com/temporalio/sdk-java) to your project as a dependency:

**[Apache Maven](https://maven.apache.org/)**:

```maven
<dependency>
  <groupId>io.temporal</groupId>
  <artifactId>temporal-sdk</artifactId>
  <version>1.9.1</version>
</dependency>
```

**[Gradle Groovy DSL](https://gradle.org/)**:

```groovy
implementation 'io.temporal:temporal-sdk:1.9.1'
```

**Other**:

Additional scripts for each SDK version are available here: [https://search.maven.org/artifact/io.temporal/temporal-sdk](https://search.maven.org/artifact/io.temporal/temporal-sdk).
Select an SDK version to see available scripts.

#### Are there executable code samples?\*\*

You can find a complete list of executable code samples in the [samples library](/docs/samples-library/#java), which includes Temporal Java SDK code samples from the temporalio/samples-java repo.
Additionally, several of the [Java SDK Tutorials](/docs/learning-paths) are backed by a fully executable template application.

#### Where is the Java SDK technical reference?\*\*

The [Java SDK API reference](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/index.html) is published to [javadoc.io](https://www.javadoc.io/).

#### Where can I find video demos?\*\*

[Temporal Java SDK YouTube playlist](https://www.youtube.com/playlist?list=PLl9kRkvFJrlQ8KsM6m9cFfCeQegq_B8x4)

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Develop Workflows

Workflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/docs/concepts/what-is-a-workflow-definition).

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

In the Temporal Go SDK programming model, a [Workflow Definition](/docs/concepts/what-is-a-workflow-definition) is an exportable function.

```go
func YourWorkflowDefinition(ctx workflow.Context) error {
  // ...
  return nil
}
```

#### Workflow parameters in Go

The first parameter of a Go-based Workflow Definition must be of the [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk@v1.8.0/workflow#Context) type, as it is used by the Temporal Go SDK to pass around Workflow Execution context, and virtually all the Go SDK APIs that are callable from the Workflow require it.
It is acquired from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk@v1.8.0/workflow) package.

```go
import (
    "go.temporal.io/sdk/workflow"
)

func YourWorkflowDefinition(ctx workflow.Context, param string) error {
  // ...
}
```

The `workflow.Context` entity operates similarly to the standard `context.Context` entity provided by Go.
The only difference between `workflow.Context` and `context.Context` is that the `Done()` function, provided by `workflow.Context`, returns `workflow.Channel` instead of the standard Go `chan`.

The second parameter, `string`, is a custom parameter that is passed to the Workflow when it is invoked.
A Workflow Definition may support multiple custom parameters, or none. These parameters can be regular type variabes or safe pointers.
However, the best practice is to pass a single parameter that is of a `struct` type so there can be some backward compatibility if new parameters are added.

```go
type YourWorkflowParam struct {
  WorkflowParamFieldOne string
  WorkflowParamFieldTwo int
}

func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {
  // ...
}
```

All Workflow Definition parameters must be serializable, regardless of whether pointers or regular type values are used. Parameters can’t be channels, functions, variadic, or unsafe pointers.

#### Workflow return values in Go

A Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.
Again, the best practice here is to use a `struct` type to hold all custom values.

```go
type YourWorkflowResponse struct{
  WorkflowResultFieldOne string
  WorkflowResultFieldTwo int
}

func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {
  // ...
  if err != nil {
    return "", err
  }
  responseVar := YourWorkflowResponse {
    FieldOne: "super",
    FieldTwo: 1,
  }
  return responseVar, nil
}
```

A Workflow Definition written in Go can return both a custom value and an error.
However, it is not possible to receive both a custom value and an error in the calling process as is normal in Go.
The caller will receive either one or the other.
Returning a non-nil `error` from a Workflow indicates that an error was encountered during its execution and the Workflow Execution should be [Terminated](#) and any custom return values will be ignored by the system.

#### Workflow logic requirements in Go

Workflow Definition code cannot directly do the following:

- Iterate over maps using `range`, because with `range` the order of the map's iteration is randomized.
  Instead you can collect the keys of the map, sort them, and then iterate over the sorted keys to access the map.
  This technique provides deterministic results.
  You can also use a Side Effect or an Activity to process the map instead.
- Call an external API, conduct a file I/O operation, talk to another service, etc. (Use an Activity for these.)

Additionally the Temporal Go SDK offers APIs to handle equivalent Go constructs:

- `workflow.Now()` This is a replacement for `time.Now()`.
- `workflow.Sleep()` This is a replacement for `time.Sleep()`.
- `workflow.GetLogger()` This ensures that the provided logger does not duplicate logs during a replay.
- `workflow.Go()` This is a replacement for the `go` statement.
- `workflow.Channel` This is a replacement for the native `chan` type.
  Temporal provides support for both buffered and unbuffered channels.
- `workflow.Selector` This is a replacement for the `select` statement. Learn more on the [Go SDK Selectors](https://docs.temporal.io/docs/go/selectors) page
- `workflow.Context` This is a replacement for `context.Context`. Learn more on the [Go SDK Context Propagation](https://docs.temporal.io/docs/go/tracing) page.

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Develop Activities

One of the primary things that Workflows do, is orchestrate the execution of Activities.
Activities are normal function/method executions that can interact with the world.
For the Workflow to be able to execute the Activity we must define the [Activity Definition](/docs/concepts/what-is-an-activity-definition)

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

In the Temporal Go SDK programming model, an Activity Definition is an exportable function or a `struct` method.

#### Function

```go
// basic function signature
func YourActivityDefinition(ctx context.Context) error {
  // ...
  return nil
}

// with parameters and return values
func SimpleActivity(ctx context.Context, value string) (string, error)
```

#### Struct method

```go
type YourActivityStruct struct {
  ActivityFieldOne string
  ActivityFieldTwo int
}

func(a *YourActivityStruct) YourActivityDefinition(ctx context.Context) error {
  // ...
}

func(a *YourActivityStruct) YourActivityDefinitionTwo(ctx context.Context) error {
  // ...
}
```

An "Activity struct" can have more than one method, with each method acting as a separate Activity Type.
Activities written as struct methods can use shared struct variables such as:

- an application level DB pool
- client connection to another service
- reusable utilities
- any other expensive resources you only want to initialize once per process

Because this is such a common need, the rest of this guide shows Activities written as `struct` methods.

#### Activity parameters in Go

The first parameter of an Activity Definition is `context.Context`.
This parameter is optional for an Activity Definition, though it is recommended especially if the Activity is expected to use other Go SDK APIs.

An Activity Definition can support as many other custom parameters as needed.
However, all parameters must be serializable (parameters can’t be channels, functions, variadic, or unsafe pointers), and it is recommended to pass a single struct that can be updated later.

```go
type YourActivityParam struct {
  ActivityParamFieldOne string
  ActivityParamFieldTwo int
}

type YourActivityStruct struct {
  // ...
}

func (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {
  // ...
}
```

There is no explicit limit to the amount of parameter data that can be passed to an Activity.
However, all parameters are recorded in the Workflow Execution History and a large Workflow Execution History can adversely impact the performance of your Workflow Execution.

#### Activity return values in Go

A Go-based Activity Definition can return either just an `error` or a `customValue, error` combination (same as a Workflow Definition).
You may wish to use a `struct` type to hold all custom values, just keep in mind they must all be serializable.

```go
type YourActivityResult struct{
  ActivityResultFieldOne string
  ActivityResultFieldTwo int
}

func (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResult, error) {
  // ...
  result := YourActivityResult {
    ActivityResultFieldOne: a.ActivityFieldOne,
    ActivityResultFieldTwo: a.ActivityFieldTwo,
  }
  return result, nil
}
```

#### Other notes for developing Activities

All native features of the Go programming language can be used within an Activity and there are no other limitations to Activity Definition logic:

- **Performance**: Keep in mind that all parameters and return values are recorded in the [Workflow Execution Event History](/docs/concepts/what-is-an-event-history).
  A large Workflow Execution Event History can adversely impact the performance of your Workflow Executions, because the entire Event History is transferred to Worker Processes with every [Workflow Task](/docs/concepts/what-is-a-workflow-task).
- **Idiomatic usage**: You are free to use:
  - your own loggers and metrics controllers
  - the standard Go concurrency constructs
  - make calls to other services across a network

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Spawn Activity Execution

Calls to spawn [Activity Executions](/docs/concepts/what-is-an-activity-execution) are written within a Workflow Definition.
The call to spawn an Activity Execution generates the [ScheduleActivityTask](/docs/concepts/what-is-a-command#scheduleactivitytask) Command.
This results in the set of three [Activity Task](/docs/concepts/what-is-an-activity-task) related Events ([ActivityTaskScheduled](/docs/references/events/#activitytaskscheduled), [ActivityTaskStarted](/docs/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

To spawn an [Activity Execution](/docs/concepts/what-is-an-activity-execution), use the [`ExecuteActivity()`](https://pkg.go.dev/go.temporal.io/sdk@v1.8.0/workflow#ExecuteActivity) API call inside your Workflow Definition.
The API is available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk@v1.8.0/workflow) package.

The `ExecuteActivity()` API call requires an instance of `workflow.Context`, the Activity function name, and any variables to be passed to the Activity Execution.

```go
import (
  // ...

  "go.temporal.io/sdk/workflow"
)

func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {
  // ...
  yourActivityParam := YourActivityParam{
    // ...
  }
  var activities *YourActivityStruct
  future := workflow.ExecuteActivity(ctx, activities.YourActivityDefinition, yourActivityParam)
  // ...
}

func (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {
  // ...
}
```

The Activity function name can be provided as a variable object (no quotations) or as a string.

```go
// ...
  future := workflow.ExecuteActivity(ctx, "YourActivityDefinition", yourActivityParam)
// ...
```

The benefit of passing the actual function object is that the framework can validate the parameters against the Activity Definition.

The `ExecuteActivity` call returns a Future, which can be used to get the result of the Activity Execution.

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

#### Required timeout

TODO


<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

**How to set a Schedule-To-Close Timeout in Go**

This or `ScheduleToStart` must be set.

- Type: `time.Duration`
- Default: ∞ (infinity - no limit)

```go
activityoptions := workflow.ActivityOptions{
  ScheduleToCloseTimeout: 10 * time.Second,
}
ctx = workflow.WithActivityOptions(ctx, activityoptions)
var yourActivityResult YourActivityResult
err = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)
if err != nil {
  // ...
}
```


</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

**How to set a [Start-To-Close Timeout](/docs/concepts/what-is-a-start-to-close-timeout) in Go**

This or `ScheduleToClose` must be set.

- Type: `time.Duration`
- Default: Same as the `ScheduleToCloseTimeout`

```go
activityoptions := workflow.ActivityOptions{
  StartToCloseTimeout: 10 * time.Second,
}
ctx = workflow.WithActivityOptions(ctx, activityoptions)
var yourActivityResult YourActivityResult
err = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)
if err != nil {
  // ...
}
```


</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Get Activity results

The call to spawn an [Activity Execution](/docs/concepts/what-is-an-activity-execution) generates the [ScheduleActivityTask](/docs/concepts/what-is-a-command/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.
Workflow Executions can either block progress until the result is available via the Awaitable or continue progressing, making use of the result when it becomes available.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

The `ExecuteActivity` API call returns an instance of [`workflow.Future`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Futures) which has the following two methods:

- `Get()`: Takes an instance of the `workflow.Context`, that was passed to the Activity Execution, and a pointer as parameters.
  The variable associated with the pointer is populated with the Activity Execution result.
  This call blocks until the result is available.
- `IsReady()`: Returns `true` when the result of the Activity Execution is ready.

Call the `Get()` method on the instance of `workflow.Future` to get the result of the Activity Execution.
The type of the result parameter must match the type of the return value declared by the Activity function.

```go
func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {
  // ...
  future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)
  var yourActivityResult YourActivityResult
  if err := future.Get(ctx, &yourActivityResult); err != nil {
    // ...
  }
  // ...
}
```

Use the `IsReady()` method first to make sure the `Get()` call doesn't cause the Workflow Execution to wait on the result.

```go
func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {
  // ...
  future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)
  // ...
  if(future.IsReady()) {
    var yourActivityResult YourActivityResult
    if err := future.Get(ctx, &yourActivityResult); err != nil {
      // ...
    }
  }
  // ...
}
```

It is idiomatic to invoke multiple Activity Executions from within a Workflow.
Therefore it is also idiomatic to either block on the results of any of the Activity Executions or continue on to execute additional logic, checking for the Activity Execution results at a later time.

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Create Temporal Clients

No content is available.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

Content is not available

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Run Worker Processes

The [Worker Process](/docs/concepts/what-is-a-worker-process) is where Workflow Functions and Activity Functions are executed.
Each [Worker Entity](/docs/concepts/what-is-a-worker-entity) in the Worker Process must register the exact Workflow Types and Activity Types it may execute.
Each Worker Entity must also associate itself with exactly one [Task Queue](/docs/concepts/what-is-a-task-queue).
Each Worker Entity polling the same Task Queue must be registered with the same Workflow Types and Activity Types.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

Create an instance of [`Worker`](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) by calling [`worker.New()`](https://pkg.go.dev/go.temporal.io/sdk/worker#New), available via the `go.temporal.io/sdk/worker` package, and pass it the following parameters:

1. An instance of the Temporal Go SDK `Client`.
2. The name of the Task Queue that it will poll.
3. An instance of [`worker.Options`](/docs/go/how-to-set-workeroptions-in-go), which can be empty.

Then, register the Workflow Types and the Activity Types that the Worker will be capable of executing.

Lastly, call either the `Start()` or the `Run()` method on the instance of the Worker.
Run accepts an interrupt channel as a parameter, so that the Worker can be stopped in the terminal.
Otherwise the `Stop()` method must be called to stop the Worker.

```go
package main

import (
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
)

func main() {
	c, err := client.NewClient(client.Options{})
	if err != nil {
		// ...
	}
	defer c.Close()
	w := worker.New(c, "your-task-queue", worker.Options{})
	w.RegisterWorkflow(YourWorkflowDefinition)
	w.RegisterActivity(YourActivityDefinition)
	err = w.Run(worker.InterruptCh())
	if err != nil
		// ...
	}
  // ...
}

func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {
  // ...
}

func YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResponse, error) {
  // ...
}
```

Start the Worker Process by running `go run <filename>.go`.

:::tip

If you have [`gow`](https://github.com/mitranim/gow) installed, the Worker Process automatically "reloads" when you update the file:

```bash
go install github.com/mitranim/gow@latest
gow run worker/main.go # automatically reload when file changed
```

:::

The `RegisterWorkflow()` and `RegisterActivity()` calls essentially create an in-memory mapping between the Workflow Types and their implementations, inside the Worker process.

Notice that the Task Queue name is the same as the name provided when the [Workflow Execution is spawned](#spawn-workflow-execution).

The name of the Task Queue that is provided to the Worker must be the same Task Queue name that is provided with the invocation of the Workflow Execution.

All Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.

If a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.
However, the failure of the Task will not cause the associated Workflow Execution to fail.

#### Registering Activity `structs`

Per [Activity Definition](#develop-activities) best practices, you may have an Activity struct that has multiple methods and fields. When you use `RegisterActivity()` for an Activity struct, that Worker has access to all exported methods.

#### Registering multiple Types

To register multiple Activity Types and/or Workflow Types with the Worker Entity, just make multiple Activity registration calls, but make sure each Type name is unique:

```go
w.registerActivity(ActivityA)
w.registerActivity(ActivityB)
w.registerActivity(ActivityC)
w.registerWorkflow(WorkflowA)
w.registerWorkflow(WorkflowB)
w.registerWorkflow(WorkflowC)
```

#### Registering with options

Options can be applied when the Type is registered.

For example, an Activity Type name can be customized to something other than the function name using the [`RegisterActivityWithOptions`](/docs/go/how-to-set-registeractivityoptions-in-go) call.

And a Workflow Type name can be customized to something other than the function name using the [`RegisterWorkflowWithOptions`](/docs/go/how-to-set-registerworkflowoptions-in-go) call.

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Spawn Workflow Execution

[Workflow Execution](/docs/concepts/what-is-a-workflow-execution) semantics rely on several parameters - that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language specific contextual data, and Workflow Function parameters.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

To spawn a [Workflow Execution](/docs/concepts/what-is-a-workflow-execution), use the `ExecuteWorkflow()` method on the Go SDK [`Client`](https://pkg.go.dev/go.temporal.io/sdk@v1.8.0/client#Client), which is available via [`NewClient()`](https://pkg.go.dev/go.temporal.io/sdk@v1.8.0/client#NewClient) in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk@v1.8.0/client) package.

The Go SDK Temporal Client should never be used inside a [Workflow Definition](/docs/concepts/what-is-a-workflow-definition).
To spawn a Workflow Execution from within another Workflow, use the [`ExecuteChildWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ExecuteChildWorkflow) API.
For more information, see [How to spawn a Child Workflow Execution in Go](/docs/go/how-to-spawn-a-child-workflow-execution-in-go).

The `ExecuteWorkflow()` API call requires an instance of [`context.Context`](https://pkg.go.dev/context#Context), an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.8.0/client#StartWorkflowOptions), a Workflow Type name, and all variables to be passed to the Workflow Execution.
The `ExecuteWorkflow()` call returns a Future, which can be used to get the result of the Workflow Execution.

```go
package main

import (
  // ...

  "go.temporal.io/sdk/client"
)

func main() {
  c, err := client.NewClient(client.Options{})
  if err != nil {
    // ...
  }
  defer c.Close()
  // ...
  workflowOptions := client.StartWorkflowOptions{
    ID: "Your-Custom-Workflow-Id",
    TaskQueue: "your-task-queue",
  }
  workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)
  if err != nil {
    // ...
  }
  // ...
}

func YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {
  // ...
}
```

Start the preceding process by running `go run <filename>.go`.

Notice that the Task Queue name is the same as the name provided when a Worker Entity is created.

The only field, of the `StartWorkflowOptions` instance, that requires a value is the `TaskQueue`.
A Task Queue name is also provided to the Worker that is registered to execute that particular Workflow Type.
The Task Queue name must be the same for both.

We recommend supplying your own custom Workflow Id that can be used to get the result of the Workflow Execution asynchronously at another point in time.
A custom Workflow Id is intended to correspond to a business-level identifier.

By default, the Workflow Type name is the same as the function name.
If the invocation process has access to the function directly, then the Workflow Type name parameter can be passed as if the function name were a variable, without quotations.

If the invocation process does not have direct access to the statically defined Workflow Definition, for example, if the Workflow Definition is in an un-importable package, or it is written in a completely different language, then the Workflow Type can be provided as a `string`.

```go
workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, "YourWorkflowDefinition", param)
```

In Go, the name of the Workflow Type can be customized when the Workflow Definition is registered with a Worker Entity.

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Set Task Queue

TODO

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

Content is not available

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Set Workflow Id

TODO

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

Content is not available

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

### Get Workflow results

TODO

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Typescript', value: 'typescript'},]}>

<TabItem value="go">

The `ExecuteWorkflow` call returns an instance of [`WorkflowRun`](https://pkg.go.dev/go.temporal.io/sdk/client#WorkflowRun), which is the `workflowRun` variable in the following line.

```go
  workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, app.YourWorkflowDefinition, param)
  if err != nil {
    // ...
  }
  // ...
}
```

The instance of `WorkflowRun` has the following three methods:

- `GetWorkflowID()`: Returns the Workflow Id of the invoked Workflow Execution.
- `GetRunID()`: Always returns the Run Id of the initial Run (See [Continue As New](#)) in the series of Runs that make up the full Workflow Execution.
- `Get`: Takes a pointer as a parameter and populates the associated variable with the Workflow Execution result.

To wait on the result of Workflow Execution in the same process that invoked it, call `Get()` on the instance of `WorkflowRun` that is returned by the `ExecuteWorkflow()` call.

```go
  workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)
  if err != nil {
    // ...
  }
  var result YourWorkflowResponse
  err = workflowRun.Get(context.Background(), &result)
  if err != nil {
      // ...
  }
  // ...
}
```

However, the result of a Workflow Execution can be obtained from a completely different process.
All that is needed is the [Workflow Id](#).
(A [Run Id](#) is optional if more than one closed Workflow Execution has the same Workflow Id.)
The result of the Workflow Execution is available for as long as the Workflow Execution Event History remains in the system.

<!-- TODO (See [How long do Workflow Execution Histories persist](#)). -->

Call the `GetWorkflow()` method on the an instance of the Go SDK Client and pass it the Workflow Id used to spawn the Workflow Execution.
Then call the `Get()` method on the instance of `WorkflowRun` that is returned, passing it a pointer to populate the result.

```go
  // ...
  workflowID := "Your-Custom-Workflow-Id"
  workflowRun := c.GetWorkflow(context.Background, workflowID)

  var result YourWorkflowResponse
  err = workflowRun.Get(context.Background(), &result)
  if err != nil {
      // ...
  }
  // ...
```

#### Get last completion result

In the case of a [Temporal Cron Job](/docs/concepts/what-is-a-temporal-cron-job), you might need to get the result of the previous Workflow Run and use it in the current Workflow Run.

To do this, use the [`HasLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#HasLastCompletionResult) and [`GetLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLastCompletionResult) APIs, available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package, directly in your Workflow code.

```go
type CronResult struct {
  Count int
}

func YourCronWorkflowDefinition(ctx workflow.Context) (CronResult, error) {
  count := 1

  if workflow.HasLastCompletionResult(ctx) {
    var lastResult CronResult
    if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {
      count = count + lastResult.Count
    }
  }

  newResult := CronResult {
    Count: count,
  }
  return newResult, nil
}
```

This will work even if one of the cron Workflow Runs fails.
The next Workflow Run gets the result of the last successfully Completed Workflow Run.

</TabItem>
<TabItem value="java">

Content is not available

</TabItem>
<TabItem value="php">

Content is not available

</TabItem>
<TabItem value="typescript">

Content is not available

</TabItem>
</Tabs>

## Features

This section covers many of the features that are available to use in your [Temporal Application](/docs/concepts/what-is-a-temporal-application).

### Signals

TODO

### Queries

TODO

### Timers

TODO

### Child Workflows

TODO

### Activity Heartbeats

TODO

### Cron Jobs



### Local Activities

TODO

## Observability

TODO

### Logging

TODO

### Visibility

TODO

## Testing

TODO


---
id: introduction
title: Introduction to Temporal's core concepts
sidebar_label: Introduction
---

:::note

This page is a work in progress!

:::

**Welcome to Temporal's core terminology!**

This page is dedicated to defining and describing the terms, components, and concepts of the Temporal system in a holistic way.

## Workflow

A fault-oblivious stateful function that orchestrates [Activities](#activity).

- A Workflow has full control over which [Activities](#activity) are executed, and in which order.
- A Workflow must not affect the external world directly, only through [Activities](#activity).
- What makes Workflow code a Workflow is that its state is preserved by Temporal. Therefore any failure of a [Worker](#worker) process that hosts the Workflow code does not affect the [Workflow Execution](#workflow-execution). The Workflow continues as if these failures did not happen. At the same time, [Activities](#activity) can fail any moment for any reason.
- Because Workflow code is fully fault-oblivious, it is guaranteed to get notifications about [Activity](#activity) failures or timeouts and act accordingly.
- The duration of a Workflow has no limit.

### Workflow Execution

An instance of a [Workflow](#workflow).

- It is possible for a Workflow Execution to be composed of multiple [Workflow](#workflow) runs. When the [Event History](#event-history) of a [Workflow](#workflow) grows too large, the next invocation can be called with a "Continue as New" flag to create a new run automatically.

### Workflow Id

A unique identifier for a [Workflow Execution](#workflow-execution).

- Temporal guarantees the uniqueness of an Id within a [Namespace](#namespace).
- An attempt to start a [Workflow](#workflow) with a duplicate Id results in an **already started** error if there is another open Workflow execution. However, this behavior depends on the `WorkflowIdReusePolicy` flag; if set to `ALLOW_DUPLICATE`, it is possible to start a new execution with the same Workflow Id.

### Run Id

A UUID that a Temporal service assigns to each [Workflow](#workflow) run.

- Temporal guarantees that only one [Workflow Execution](#workflow-execution) with a given [Workflow Id](#workflow-id) can be open at a time. But after the [Workflow Execution](#workflow-execution) has completed, if allowed by a configured policy, you might be able to re-execute a [Workflow](#workflow) after it has closed or failed, using the same [Workflow Id](#workflow-id).
- Each such re-execution is called a run. Run Id is used to uniquely identify a run even if it shares a [Workflow Id](#workflow-id) with others.

### Workflow Task

A [Task](#task) that contains invocation information for a [Workfow](#workflow).

- Every time a new external event that might affect a [Workflow](#workflow) state is recorded, a Workflow Task that contains the event is added to a [Task Queue](#task-queue) and then picked up by a [Workflow Worker](#worker).
- After the new event is handled, the Workflow Task is completed with a list of [Commands](#command).
- Handling of a Workflow Task is usually very fast and is not related to the duration of operations that the [Workflow](#workflow) invokes.

### Workflow Task Execution

Coming soon.

## Activity

A business-level function that implements your application logic, such as calling a service or transcoding a media file.

- An Activity usually implements a single well-defined action; it can be short or long running.
- An Activity can be implemented as a synchronous method or fully asynchronously involving multiple processes.
- An Activity can be retried indefinitely according to the provided exponential retry policy.
- If for any reason an Activity is not completed within the specified timeout, an error is reported to the [Workflow](#workflow), which decides how to handle it. The duration of an Activity has no limit.
- Activities support an [Activity Heartbeat](#activity-heartbeat) that helps to identify timeouts faster in case the Activity execution fails.

### Activity Execution

Coming soon.

### Activity Task

A [Task](#task) that contains invocation information for an [Activity](#activity) that is delivered to an [Activity Worker](#worker) through a [Task Queue](#task-queue).

- Upon receiving an [Activity Task](#activity-task), an [Activity Worker](#worker) executes the corresponding [Activity](#activity).

### Activity Task Execution

Coming soon.

### Activity Id

A unique Id that identifies an [Activity](#activity) that is executing. The Id can be generated by the system, or it can be provided by the Workflow code that invoked the [Activity](#activity). An Activity Id can be used to complete the [Activity](#activity) asynchronously.

### Activity Heartbeat

Provides to the Temporal server the status of an [Activity Task](#activity-task) that is being executed.

- Activity Heartbeats help ensure that [Activity](#activity) execution failures and timeouts are identified quickly.
- Activity Heartbeats are implemented in code and are recorded at the discretion of the [Workflow](#workflow) implementation.
- Custom [Activity](#activity) progress information can be included in an Activity Heartbeat and can be used when the [Activity](#activity) is retried.

### Local Activity

An [Activity](#activity) that is invoked directly in the same process by Workflow code.

- Although a Local Activity consumes less resources than a normal [Activity](#activity), it is subject to shorter durations and a lack of rate limiting.

## Retry Policy

A collection of attributes that instructs the Temporal Server how to retry a failure of an [Activity Task Execution](#activity-task-execution) or a [Workflow Execution](#workflow-execution).

- If a custom Retry Policy is to be used, it must be provided as an options parameter when an [Activity Execution](#activity-execution) or [Workflow Execution](#workflow-execution) is invoked.

- The wait time before a retry is the _retry interval_.
  A retry interval is the smaller of two values:
  - The [Initial Interval](#initial-interval) multiplied by the [Backoff Coefficient](#backoff-coefficient) raised to the power of the number of retries.
  - The [Maximum Interval](#maximum-interval).

<!-- ![Diagram that shows the retry interval and its formula](/img/retry-interval-diagram.png) -->

- When a [Workflow Execution](#workflow-execution) is invoked it is not associated with a default Retry Policy and thus does not retry by default.
  The intention is that a Workflow Definition should be written to never fail due to intermittent issues; an Activity is designed to handle such issues.

:::note

Retry Policies do not apply to [Workflow Task Executions](#workflow-task-execution), which, by default, retry indefinitely.

:::

- A Retry Policy can be provided to a [Workflow Execution](#workflow-execution) when it is invoked, but only certain scenarios merit doing this, such as the following:

  - A cron Workflow or some other stateless, always-running Workflow Execution that can benefit from retries.
  - A file-processing or media-encoding Workflow Execution that downloads files to a host.

- When an [Activity Execution](#activity-execution) is invoked, it is associated with a default Retry Policy, and thus [Activity Task Executions](#activity-execution) are retried by default.
  When an [Activity Task Execution](#activity-execution) is retried, the Server places a new [Activity Task](#activity-task) into its respective [Activity Task Queue](#activity-task-queue), which results in a new [Activity Task Execution](#activity-task-execution).

**Default values for Retry Policy**

```
Initial Interval     = 1 second
Backoff Coefficient  = 2.0
Maximum Interval     = 100 × Initial Interval
Maximum Attempts     = ∞
Non-Retryable Errors = []
```

### Initial Interval

- **Description**: Amount of time that must elapse before the first retry occurs.
  - **The default value is 1 second.**
- **Use case**: This is used as the base interval time for the [Backoff Coefficient](#backoff-coefficient) to multiply against.

### Backoff Coefficient

- **Description**: The value dictates how much the _retry interval_ increases.
  - **The default value is 2.0.**
  - A backoff coefficient of 1.0 means that the retry interval always equals the [Initial Interval](#initial-interval).
- **Use case**: Use this attribute to increase the interval between retries.
  By having a backoff coefficient greater than 1.0, the first few retries happen relatively quickly to overcome intermittent failures, but subsequent retries happen farther and farther apart to account for longer outages.
  Use the [Maximum Interval](#maximum-interval) attribute to prevent the coefficient from increasing the retry interval too much.

### Maximum Interval

- **Description**: Specifies the maximum interval between retries.
  - **The default value is 100 times the [Initial Interval](#initial-interval).**
- **Use case**: This attribute is useful for [Backoff Coefficients](#backoff-coefficient) that are greater than 1.0 because it prevents the retry interval from growing infinitely.

### Maximum Attempts

- **Description**: Specifies the maximum number of execution attempts that can be made in the presence of failures.
  - **The default is unlimited.**
  - If this limit is exceeded, the execution fails without retrying again. When this happens an error is returned.
  - Setting the value to 0 also means unlimited.
  - Setting the value to 1 means a single execution attempt and no retries.
  - Setting the value to a negative integer results in an error when the execution is invoked.
- **Use case**: Use this attribute to ensure that retries do not continue indefinitely.
  However, in the majority of cases, we recommend relying on the Workflow Execution Timeout, in the case of [Workflows](#workflow), or Schedule-To-Close Timeout, in the case of [Activities](#activity), to limit the total duration of retries instead of using this attribute.

### Non-Retryable Errors

- **Description**: Specifies errors that shouldn't be retried.
  - **Default is none.**
  - If one of those errors occurs, the [Activity Task Execution](#activity-task-execution) or [Workflow Execution](#workflow-execution) is not retried.
- **Use case**: There may be errors that you know of that should not trigger a retry.
  In this case you can specify them such that if they occur, the given execution will not be retried.

## Event

For each [Workflow](#workflow), Temporal tracks two types of Events:

1. [Command](#command) Events.
2. Everything else.

- Command Events are events that correspond to [Commands](#command) produced by the [Workflow Worker](#worker).
- All other events represent various external occurrences that the [Workflow] is expected to react to, such as an [Activity](#activity) completion, a timer firing, or a cancellation request.
- All Events are recorded in the [Event History](#event-history).

## Event History

An append-log of [Events](#event) for your application.

- Event History is durably persisted by the Temporal service, enabling seamless recovery of your application state from crashes or failures.
- It also serves as an audit log for debugging.

## Command

Any action requested by the [Workflow](#workflow) durable function.

- Scheduling an [Activity](#activity), canceling a child [Workflow](#workflow), or starting a timer are all examples of Commands.
- A [Workflow Task](#workflow-task) contains an optional list of Commands.
- A [Worker](#worker) executing a [Workflow](#workflow) generates a list of Commands as a result of a [Workflow Task](#workflow-task). This list is sent to the Temporal service as part of the [Workflow Task](#workflow-task) completion request.
- Every Command is recorded in the [Event History](#event-history) as an [Event](#event). For example, the `StartTimer` command is recorded as a corresponding `TimerStarted` event.

## Archival

A feature that automatically moves [Event Histories](#event-history) from normal persistence to a blob store after the [Workflow](#workflow) retention period.

- The purpose of Archival is to keep [Event Histories](#event-history) as long as needed while not overwhelming the persistence store.
- You might want to keep [Event Histories](#event-history) after the retention period has passed for two reasons:
  1. Compliance: For legal reasons, [Event Histories](#event-history) may need to be stored for a long period of time.
  2. Debugging: Older [Event Histories](#event-history) can be referenced to help with debugging.

## Client Stub

A client-side proxy in the Java SDK that is used to make remote invocations on an entity that it represents.

- To start a [Workflow](#workflow), for example, a Stub object that represents the [Workflow](#workflow) is created through a special API. Then the Stub is used to start, query, or signal the corresponding [Workflow](#worker).
- The Go SDK does not use Client Stubs.

## Namespace

The unit of isolation within Temporal, which is backed by a multi-tenant service.

- By default, a Temporal service is provisioned with a "default" Namespace. All APIs and tools, such as the UI and CLI, default to the "default" Namespace if it is not specified. So, if you are not planning to use multiple Namespaces, we recommend using the default one.
- [Task Queue](#task-queue) names and [Workflow Ids](#workflow-id) correspond to a specific Namespace. For example, when a [Workflow](#workflow) is started, it starts within a specific Namespace.
- Temporal guarantees a unique [Workflow Id](#workflow-id) within a Namespace. Temporal supports running [Workflow Executions](#workflow-execution) that use the same [Workflow Id](#workflow-id) if they are in different Namespaces.
- Various configuration options like the retention period or [Archival](#archival) destination are configured per Namespace through a special CRUD API or through [`tctl`](/docs/system-tools/tctl/).
- In a multi-cluster deployment, Namespace is a unit of fail-over.
- Each Namespace can be active on only a single Temporal cluster at a time. However, different Namespaces can be active in different clusters and can fail-over independently.

## Query

From the caller's point of view, a synchronous operation that is used to report the state of a [Workflow](#workflow).

- Query logic is implemented as code within a [Workflow](#workflow).
- A Query is inherently read-only and cannot affect a [Workflow](#workflow) state.

## Signal

An external asynchronous request to a [Workflow](#workflow).

- A Signal can be used to deliver notifications or updates to a running [Workflow](#workflow) at any point in its existence.

## Task

The context needed to execute a specific [Activity](#activity) or [Workflow](#workflow) state transition.

- There are two types of tasks:
  - [Activity Task](#activity-task)
  - [Workflow Task](#workflow-task)
- A single [Activity](#activity) execution corresponds to a single [Activity Task](#activity-task), while a [Workflow Execution](#workflow-execution) employs multiple [Workflow Tasks](#workflow-task).

### Task Queue

A queue that a [Worker](#worker) subscribes to and polls to pick up tasks to execute.

- Each Task Queue is capable of queuing [Activity Tasks](#activity-task) and [Workflow Tasks](#workflow-task).
- Task Queues rely on the same persistent storage as the rest of the Temporal service. (Task Queues are not based on other technologies such as Kafka.)

### Task Token

A unique correlation Id for a Temporal [Activity](#activity).

- [Activity](#activity) completion calls take either a single Task Token, or the [Namespace](#namespace), [Workflow Id](#workflow-id), and [Activity Id](#activity-id) as a set of arguments.

## Worker

A service that hosts the [Workflow](#workflow) and [Activity](#activity) implementations.

- A single Worker actually contains both an [Activity Worker](#worker) and a [Workflow Worker](#worker), abstracting the logical separation and having the ability to execute both types of tasks.
- The Worker polls the Temporal service for [Tasks](#task), performs those [Tasks](#task), and communicates [Task](#task) execution results back to the Temporal service.
- Worker services are developed, deployed, and operated by Temporal customers.

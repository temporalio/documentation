---
id: security
title: Temporal Platform security features
sidebar_label: Security
description: This guide is an overview of the Temporal Platform security features.
toc_max_heading_level: 4
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::info Work in progress

This guide is a work in progress. Some sections may be incomplete. Information may change at any time.

:::

:::info General company security

For information about the general security habits of Temporal Technologies see our [company security page](/temporal-technologies-inc-security).

:::

The Temporal Plaform is designed with security in mind, and there are many features that you can use to keep both the Platform itself and your user's data secure.

A secured Temporal Server has its network communication encrypted and has authentication and authorization protocols set up for API calls made to it.
Without these, your server could be accessed by unwanted entities.

What is documented on this page are the built-in opt-in security measures that come with Temporal.
However users may also choose to design their own security architecture with reverse proxies or run unsecured instances inside of a VPC environment.

### Server Samples

The https://github.com/temporalio/samples-server repo offers two examples, which are further explained below:

- **TLS**: how to configure Transport Layer Security (TLS) to secure network communication with and within a Temporal cluster.
- **Authorizer**: how to inject a low-level authorizer component that can control access to all API calls.

### Encryption in transit with mTLS

Temporal supports Mutual Transport Layer Security (mTLS) as a way of encrypting network traffic between the services of a cluster and also between application processes and a Cluster.
Self-signed or properly minted certificates can be used for mTLS.
mTLS is set in Temporal's [TLS configuration](/references/configuration/#tls).
The configuration includes two sections such that intra-Cluster and external traffic can be encrypted with different sets of certificates and settings:

- `internode`: Configuration for encrypting communication between nodes in the cluster.
- `frontend`: Configuration for encrypting the Frontend's public endpoints.

A customized configuration can be passed using either the [WithConfig](/references/server-options#withconfig) or [WithConfigLoader](/references/server-options#withconfigloader) Server options.

See [TLS configuration reference](/references/configuration/#tls) for more details.

### Authentication

There are a few authentication protocols available to prevent unwanted access such as authentication of servers, clients, and users.

### Servers

To prevent spoofing and [MITM attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) you can specify the `serverName` in the `client` section of your respective mTLS configuration.
This enables established connections to authenticate the endpoint, ensuring that the server certificate presented to any connecting Client has the appropriate server name in its CN property.
It can be used for both `internode` and `frontend` endpoints.

More guidance on mTLS setup can be found in [the `samples-server` repo](https://github.com/temporalio/samples-server/tree/main/tls) and you can reach out to us for further guidance.

### Client connections

To restrict a client's network access to cluster endpoints you can limit it to clients with certificates issued by a specific Certificate Authority (CA).
Use the `clientCAFiles`/ `clientCAData` and `requireClientAuth` properties in both the `internode` and `frontend` sections of the [mTLS configuration](/references/configuration/#tls).

### Users

To restrict access to specific users, authentication and authorization is performed through extensibility points and plugins as described in the [Authorization](#authorization) section below.

#### Authorization

:::note
Information regarding <a class="tdlp" href="#authorizer-plugin">`Authorizer`<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">What is an Authorizer Plugin?</p><p class="tdlppd">undefined</p><p class="tdlplm"><a class="tdlplma" href="#authorizer-plugin">Learn more</a></p></div></a> and <a class="tdlp" href="#claim-mapper">`ClaimMapper`<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">What is a ClaimMapper Plugin?</p><p class="tdlppd">The Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).</p><p class="tdlplm"><a class="tdlplma" href="#claim-mapper">Learn more</a></p></div></a> has been moved to another location.
:::

Temporal offers two plugin interfaces for implementing API call authorization:

- <a class="tdlp" href="#claim-mapper">`ClaimMapper`<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">What is a ClaimMapper Plugin?</p><p class="tdlppd">The Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).</p><p class="tdlplm"><a class="tdlplma" href="#claim-mapper">Learn more</a></p></div></a>
- <a class="tdlp" href="#authorizer-plugin">`Authorizer`<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">What is an Authorizer Plugin?</p><p class="tdlppd">undefined</p><p class="tdlplm"><a class="tdlplma" href="#authorizer-plugin">Learn more</a></p></div></a>

The authorization and claim mapping logic is customizable, making it available to a variety of use cases and identity schemes.
When these are provided the frontend invokes the implementation of these interfaces before executing the requested operation.

See https://github.com/temporalio/samples-server/blob/main/extensibility/authorizer for a sample implementation.

![](/img/docs/frontend-authorization-order-of-operations.png)

### Single sign-on integration

Temporal can be integrated with a single sign-on (SSO) experience by utilizing the `ClaimMapper` and `Authorizer` plugins.
The default JWT `ClaimMapper` implementation can be used as is or as a base for a custom implementation of a similar plugin.

#### Temporal Web

To enable SSO for the Temporal Web UI edit the web service's configuration per the [Temporal Web README](https://github.com/temporalio/web#configuring-authentication-optional).

## Data Converter

A Data Converter is a Temporal SDK component that encodes and decodes data entering and exiting a Temporal Server.

- TypeScript: [Data Converters](https://legacy-documentation-sdks.temporal.io/typescript/data-converters)
- Go: [Create a custom Data Converter](https://legacy-documentation-sdks.temporal.io/go/how-to-create-a-custom-data-converter-in-go)

<div class="tdiw"><div class="tditw"><p class="tdit">Data Converter encodes and decodes data</p></div><div class="tdiiw"><img class="tdi" src="/diagrams/default-data-converter.svg" alt="Data Converter encodes and decodes data" /></div></div>

Data is encoded before it is sent to a Temporal Server, and it is decoded when it is received from a Temporal Server.

The main pieces of data that run through the Data Converter are arguments and return values:

- The Client:
  - Encodes Workflow, Signal, and Query arguments.
  - Decodes Workflow and Query return values.
- The Worker:
  - Decodes Workflow, Signal, and Query arguments.
  - Encodes Workflow and Query return values.
  - Decodes and encodes Activity arguments and return values.

Each piece of data (like a single argument or return value) is encoded as a [`Payload`](https://github.com/temporalio/api/blob/2f980f7ce4349e808b16ec0f21e0fe675f79330f/temporal/api/common/v1/message.proto#L49) Protobuf message, which consists of binary `data` and key-value `metadata`.

## Default Data Converter

Each Temporal SDK includes a default Data Converter.
In most SDKs, the default converter supports binary, JSON, and Protobufs.
(In SDKs that cannot determine parameter types at runtime—like TypeScript—Protobufs aren't included in the default converter.)
It tries to encode values in the following order:

- Null
- Binary
- Protobuf JSON
- JSON

For example:

- If a value is an instance of a Protobuf message, it will be encoded with [proto3 JSON](https://developers.google.com/protocol-buffers/docs/proto3#json).
- If a value isn't null, binary, or a Protobuf, it will be encoded as JSON. If any part of it is not serializable as JSON (for example, a Date—see [JSON data types](https://en.wikipedia.org/wiki/JSON#Data_types)), an error will be thrown.

The default converter also supports decoding binary Protobufs.

## Custom Data Converter

Applications can create their own custom Data Converters to alter the format (for example using [MessagePack](https://msgpack.org/) instead of JSON) or add compression or encryption.

To use a custom Data Converter, provide it in the following contexts:

- The Client and Worker in the SDKs you use.
- Temporal Web via [`tctl data-converter web`](/tctl-v1/dataconverter#web) (for displaying decoded data in the Web UI).
- `tctl` via [`--data-converter-plugin`](/tctl-next/#--data-converter-plugin) (for displaying decoded headers in `tctl` output).

Custom Data Converters are not applied to all data:

- `searchAttributes` are always encoded with JSON.
- Headers are not encoded by the SDK (the one exception will be—when implemented—the SDK [running OTel baggage through custom Codecs](https://github.com/temporalio/sdk-typescript/issues/514)).

### Payload Codecs

In [TypeScript](https://legacy-documentation-sdks.temporal.io/typescript/data-converters#custom-data-converter), [Go](https://pkg.go.dev/go.temporal.io/sdk/converter#PayloadCodec), and [Python](https://python.temporal.io/temporalio.converter.DataConverter.html), data conversion happens in two stages:

1. A Payload Converter converts a value into a [`Payload`](https://github.com/temporalio/api/blob/2f980f7ce4349e808b16ec0f21e0fe675f79330f/temporal/api/common/v1/message.proto#L49).
2. A Payload Codec transforms an array of Payloads (for example, a list of Workflow arguments) into another array of Payloads.

The Payload Codec is an optional step that happens between the wire and the Payload Converter:

```
Temporal Server <--> Wire <--> Payload Codec <--> Payload Converter <--> User code
```

Common Payload Codec transformations are compression and encryption.

In codec implementations, we recommended running the function (whether it be compressing, encrypting, etc) on the entire input Payload, and putting the result in a new Payload's `data` field. That way, the input Payload's headers are preserved. See, for example:

- [`ZlibCodec`](https://github.com/temporalio/sdk-go/blob/706516c7077ba2e9b40304aeddbed47e25b2a68f/converter/codec.go#L77-L105) in the Go SDK
- [Encryption Data Converter](https://github.com/temporalio/samples-go/blob/15be864c80d4d983ebb8a8fbd3fa5263bcef6930/encryption/data_converter.go#L100-L126) in Go's encryption sample

### Encryption

Doing encryption in a custom Data Converter ensures that all application data is encrypted during the following actions:

- Being sent to/from Temporal Server.
- Moving inside Temporal Server.
- Stored by Temporal Server.

Then data exists unencrypted in memory only on the Client and in the Worker Process that is executing Workflows and Activities on hosts that the application developer controls.

Our encryption samples use AES GCM with 256-bit keys:

- [TypeScript sample](https://github.com/temporalio/samples-typescript/tree/main/encryption)
- [Go sample](https://github.com/temporalio/samples-go/tree/main/encryption)
- [Python sample](https://github.com/temporalio/samples-python/tree/main/encryption)
- [Java sample](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/encryptedpayloads)

## Codec Server

A Codec Server is an HTTP server that runs data from [tctl](/tctl-v1) or the [Web UI](/web-ui) through a <a class="tdlp" href="#payload-codecs">Payload Codec<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">What is a Data Converter?</p><p class="tdlppd">A Data Converter is a Temporal SDK component that encodes and decodes data entering and exiting a Temporal Server.</p><p class="tdlplm"><a class="tdlplma" href="#payload-codecs">Learn more</a></p></div></a>.

- <a class="tdlp" href="#codec-server">How to set up a Codec Server<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">How to set up a Codec Server</p><p class="tdlppd">Run a Codec Server with your Payload Codec and then configure tctl and the Web UI to use the server.</p><p class="tdlplm"><a class="tdlplma" href="#codec-server">Learn more</a></p></div></a>

By default, tctl and the Web UI use the <a class="tdlp" href="#default-data-converter">Default Data Converter<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">What is a Data Converter?</p><p class="tdlppd">A Data Converter is a Temporal SDK component that encodes and decodes data entering and exiting a Temporal Server.</p><p class="tdlplm"><a class="tdlplma" href="#default-data-converter">Learn more</a></p></div></a> without a <a class="tdlp" href="#payload-codecs">Payload Codec<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">What is a Data Converter?</p><p class="tdlppd">A Data Converter is a Temporal SDK component that encodes and decodes data entering and exiting a Temporal Server.</p><p class="tdlplm"><a class="tdlplma" href="#payload-codecs">Learn more</a></p></div></a>.
If you use a Payload Codec with your SDK, you may not be able to understand the Payload data displayed in the Web UI/tctl (for example, it may be encrypted or compressed).
In order to convert the data to its original format, you can configure the Web UI/tctl to use a Codec Server that uses your Payload Codec.

![](/img/tctl-diagram-codec-server.svg)

## Use case: tctl

Suppose that you want to view Workflow History.
This information needs to be decoded before it can be viewed.

You can use [tctl workflow showid](/tctl-v1/workflow#show) to view a Workflow Execution Event History.

```bash
tctl workflow showid <workflowID>
```

With a Codec Server, Payloads that are part of the Event History will be sent to the Codec Server to be decoded before being deserialized by the Default Data Converter and displayed in your terminal.

- <a class="tdlp" href="#configure-tctl">How to configure tctl with a Codec Server<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">How to set up a Codec Server</p><p class="tdlppd">Run a Codec Server with your Payload Codec and then configure tctl and the Web UI to use the server.</p><p class="tdlplm"><a class="tdlplma" href="#configure-tctl">Learn more</a></p></div></a>

## Use case: Web UI

Workflow Execution Event History is available in the Web UI.
Payload information for each Event is captured within Event 'input' and 'result' fields.
Without a Codec Server, this information remains encoded.

Passing these Payloads through a Codec Server returns decoded results to the Web UI.

- <a class="tdlp" href="#configure-the-web-ui">How to configure the Web UI with a Codec Server<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">How to set up a Codec Server</p><p class="tdlppd">Run a Codec Server with your Payload Codec and then configure tctl and the Web UI to use the server.</p><p class="tdlplm"><a class="tdlplma" href="#configure-the-web-ui">Learn more</a></p></div></a>

### Codec Server

To use a <a class="tdlp" href="#codec-server">Codec Server<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">What is a Codec Server?</p><p class="tdlppd">A Codec Server is an HTTP server that runs data from tctl or the Web UI through a Payload Codec.</p><p class="tdlplm"><a class="tdlplma" href="#codec-server">Learn more</a></p></div></a>, first run it with your Payload Codec and then configure [tctl](/tctl-v1) and the [Web UI](/web-ui) to use it.

### Run the server

A Codec Server is an HTTP server that implements two endpoints:

- `POST /encode`
- `POST /decode`

Each endpoint receives and responds with a JSON body that has a `payloads` property with an array of Payloads.
The endpoints run the Payloads through a <a class="tdlp" href="#payload-codecs">Payload Codec<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><div class="tdlpc"><p class="tdlppt">What is a Data Converter?</p><p class="tdlppd">A Data Converter is a Temporal SDK component that encodes and decodes data entering and exiting a Temporal Server.</p><p class="tdlplm"><a class="tdlplma" href="#payload-codecs">Learn more</a></p></div></a> before returning them.

Sample Codec Servers:

- [Go](https://github.com/temporalio/samples-go/tree/main/codec-server)
- [Python](https://github.com/temporalio/samples-python/blob/main/encryption/codec_server.py)
- [TypeScript](https://github.com/temporalio/samples-typescript/blob/main/encryption/src/codec-server.ts)

### Configure tctl

Once the Codec Server is started, for example on `http://localhost:8888`, provide it to tctl using the `--codec_endpoint` global option:

```bash
tctl --codec_endpoint 'http://localhost:8888' workflow show --wid workflow-id-123
```

### Configure the Web UI

Once the Codec Server is started, there are two ways to provide it to the Web UI:

#### In the UI

<div class="tdiw"><div class="tditw"><p class="tdit">Data Encoder icon</p></div><div class="tdiiw"><img class="tdi" src="/img/docs/data-encoder-button.png" alt="Data Encoder icon" /></div></div>

Select the icon with an up-down arrow on the bottom left of the screen.
This action displays the codec endpoint dialog.

Enter the URL and port number for your codec endpoint.
Exit the dialog, go back to the previous page, and refresh the page.

The button should now be light blue, and your Payloads should be displayed in a readable format.

#### In the config file

The codec endpoint can be specified in the [configuration file](/references/web-ui-configuration#codec):

```yaml
codec:
    endpoint: {{ default .Env.TEMPORAL_CODEC_ENDPOINT "{namespace}"}}
```

## Plugins

Temporal Clusters support some pluggable components.

### Claim Mapper

The Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).

This process is achieved with the method `GetClaims`, which translates `AuthInfo` structs from the caller into `Claims` about the caller's roles within Temporal.

A `Role` (within Temporal) is a bit mask that combines one or more of the role constants.
In the following example, the role is assigned constants that allow the caller to read and write information.

```go
role := authorization.RoleReader | authorization.RoleWriter
```

`GetClaims` is customizable and can be modified with the `temporal.WithClaimMapper` server option.
Temporal also offers a default JWT `ClaimMapper` for your use.

A typical approach is for `ClaimMapper` to interpret custom `Claims` from a caller's JWT, such as membership in groups, and map them to Temporal roles for the user.
The subject information from the caller's mTLS certificate can also be a parameter in determining roles.

#### `AuthInfo`

`AuthInfo` is a struct that is passed to `GetClaims`. `AuthInfo` contains an authorization token extracted from the `authorization` header of the gRPC request.

`AuthInfo` includes a pointer to the `pkix.Name` struct.
This struct contains an [x.509](https://www.ibm.com/docs/en/ibm-mq/7.5?topic=certificates-distinguished-names) Distinguished Name from the caller's mTLS certificate.

#### `Claims`

`Claims` is a struct that contains information about permission claims granted to the caller.

`Authorizer` assumes that the caller has been properly authenticated, and trusts the `Claims` when making an authorization decision.

#### Default JWT ClaimMapper

Temporal offers a default JWT `ClaimMapper` that extracts the information needed to form Temporal `Claims`.
This plugin requires a public key to validate digital signatures.

To get an instance of the default JWT `ClaimMapper`, call `NewDefaultJWTClaimMapper` and provide it with the following:

- a `TokenKeyProvider` instance
- a `config.Authorization` pointer
- a logger

The code for the default `ClaimMapper` can also be used to build a custom `ClaimMapper`.

#### Token key provider

A `TokenKeyProvider` obtains public keys from specified issuers' URIs that adhere to a specific format.
The default JWT `ClaimMapper` uses this component to obtain and refresh public keys over time.

Temporal provides an `rsaTokenKeyProvider`.
This component dynamically obtains public keys that follow the [JWKS format](https://tools.ietf.org/html/rfc7517).
`rsaTokenKeyProvider` uses only the `RSAKey` and `Close` methods.

```go
provider := authorization.NewRSAKeyProvider(cfg)
```

:::note

`KeySourceURIs` are the HTTP endpoints that return public keys of token issuers in the [JWKS format](https://tools.ietf.org/html/rfc7517).
`RefreshInterval` defines how frequently keys should be refreshed.
For example, [Auth0](https://auth0.com/) exposes endpoints such as `https://YOUR_DOMAIN/.well-known/jwks.json`.

:::

By default, "permissions" is used to name the `permissionsClaimName` value.

Configure the plugin with `config.Config.Global.Authorization.JWTKeyProvider`.

#### JSON Web Token format

The default JWT `ClaimMapper` expects authorization tokens to be formatted as follows:

```
Bearer <token>
```

The Permissions Claim in the JWT Token is expected to be a collection of Individual Permission Claims.
Each Individual Permission Claim must be formatted as follows:

```
<namespace> : <permission>
```

These permissions are then converted into Temporal roles for the caller.
This can be one of Temporal's four values:

- read
- write
- worker
- admin

Multiple permissions for the same Namespace are overridden by the `ClaimMapper`.

##### Example of a payload for the default JWT ClaimMapper

```
{
   "permissions":[
      "system:read",
      "namespace1:write"
   ],
   "aud":[
      "audience"
   ],
   "exp":1630295722,
   "iss":"Issuer"
}
```

### Authorizer Plugin

The `Authorizer` plugin contains a single `Authorize` method, which is invoked for each incoming API call.
`Authorize` receives information about the API call, along with the role and permission claims of the caller.

`Authorizer` allows for a wide range of authorization logic, including call target, role/permissions claims, and other data available to the system.

#### Configuration

The following arguments must be passed to `Authorizer`:

- `context.Context`: General context of the call.
- `authorization.Claims`: Claims about the roles assigned to the caller. Its intended use is described in the [`Claims`](#claims) section earlier on this page.
- `authorization.CallTarget`: Target of the API call.

`Authorizer` then returns one of two decisions:

- `DecisionDeny`: the requested API call is not invoked and an error is returned to the caller.
- `DecisionAllow`: the requested API call is invoked.

:::warning

`Authorizer` allows all API calls pass by default. Disable the `nopAuthority` authorizer and configure your own to prevent this behavior.

:::

Configure your `Authorizer` when you start the server via the [`temporal.WithAuthorizer`](/references/server-options#withauthorizer) server option.

If an `Authorizer` is not set in the server options, Temporal uses the `nopAuthority` authorizer that unconditionally allows all API calls to pass through.

```go
a := authorization.NewDefaultAuthorizer()
```

#### Authorize API calls

When authentication is enabled, you can authorize API calls made to the Frontend Service.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

Content is currently unavailable.

</TabItem>
<TabItem value="java">

The Temporal Server [expects](/security/#authentication) an `authorization` gRPC header with an authorization token to be passed with API calls if [requests authorization](/security/#authorization) is configured.

Authorization Tokens may be provided to the Temporal Java SDK by implementing a `io.temporal.authorization.AuthorizationTokenSupplier` interface.
The implementation should be used to create `io.temporal.authorization.AuthorizationGrpcMetadataProvider` that may be configured on ServiceStub gRPC interceptors list.

The implementation is called for each SDK gRPC request and may supply dynamic tokens.

**JWT**

One of the token types that may be passed this way are JWT tokens.
Temporal Server provides a [default implementation of JWT authentication](/security/#default-jwt-claimmapper).

**Example**

```java
  AuthorizationTokenSupplier tokenSupplier =
    //your implementation of token supplier
    () -> "Bearer <Base64 url-encoded value of the token for default JWT ClaimMapper>";
  WorkflowServiceStubsOptions serviceStubOptions =
    WorkflowServiceStubsOptions.newBuilder()
      //other service stub options
      .addGrpcMetadataProvider(new AuthorizationGrpcMetadataProvider(tokenSupplier))
      .build();
  WorkflowServiceStubs service = WorkflowServiceStubs.newServiceStubs(serviceStubOptions);
  WorkflowClient client = WorkflowClient.newInstance(service);
```

Related read:

- [How to secure a Temporal Cluster](/security)

</TabItem>
<TabItem value="php">

Content is currently unavailable.

</TabItem>
<TabItem value="python">

Content is currently unavailable.

</TabItem>
<TabItem value="typescript">

Content is currently unavailable.

</TabItem>
</Tabs>


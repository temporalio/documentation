---
id: versioning
title: Versioning Node.js Workflows
sidebar_label: Versioning (Migration)
---

Workflow code has to be [deterministic](/docs/node/determinism) by taking the same code path when replaying history events. Any Workflow code change that affects the order in which commands are generated breaks this assumption.
The solution that allows updating code of already running Workflows is to keep both the old and new code.
When replaying, use the code version that the events were generated with and when executing a new code path, always take the
new code.

## Introduction to Versioning

Because we design for potentially long running workflows at scale, versioning with Temporal works differently than with other workflow systems. We explain more in this optional 30 minute introduction:

> NOTE: While in principal the Node.js versioning mechanism works similarly to the one presented in the video the API is different.

import { ResponsivePlayer } from '../../src/components'

<ResponsivePlayer url='https://www.youtube.com/watch?v=kkP899WxgzY' />

## Node.js Versioning API

Given an initial Workflow version `v1`:

```js
export const myWorkflow = () => {
  await activityA();
  await activityThatMustRunAfterA();
};
```

We decide to update our code and run `activityB` instead.

:::danger Do not do this!

`v2`:

```js
export const myWorkflow = () => {
  await activityB();
};
```

:::

We cannot directly deploy `v2` until we know for sure there aren't any incomplete Workflows created using `v1` code.

Instead we must deploy `v2'` (below) and use the [`patched`](https://nodejs.temporal.io/api/namespaces/workflow#patched) function to check which version of the code should be executed.

`patched` inserts a marker into the Workflow history. During replay, when a Worker picks up a history with that marker it will fail the Workflow task when running Workflow code that does not emit the same patch marker (in this case `my-change-id`); therefore it is safe to deploy `v2'` alongside the original version (`v1`).

`v2'`:

```js
import { patched } from '@temporalio/workflow';

export const myWorkflow = () => {
  if (patched('my-change-id')) {
    await activityB();
  } else {
    await activityA();
    await activityThatMustRunAfterA();
  }
};
```

Once we know that all Workflows started with `v1` code have completed we can [deprecate the patch](https://nodejs.temporal.io/api/namespaces/workflow#deprecatepatch).
Deprected patches bridge between `v2'` and `v2` (the end result), they work similarly to regular patches by recording a marker in the Workflow history, this marker does not fail replay when Workflow code does not emit it.

If while we're deploying `v3` (below) there are still live Workers running `v2'` code and those Workers pick up Workflow histories generated by `v3`, they will safely use the patched branch.

`v3`:

```js
import { deprecatePatch } from '@temporalio/workflow';

export const myWorkflow = () => {
  deprecatePatch('my-change-id');
  await activityB();
};
```

`v2` is safe to deploy once all `v2'` or earlier workflows are complete due to the assertion mentioned above.

### Workflow dependencies

Upgrading Workflow dependencies (such as ones installed into `node_modules`) _might_ break determinism in unpredictable ways.
It is highly recommended to use a lock file (`package-lock.json` or `yarn.lock`) in order to fix Workflow dependency versions and gain control of when they're updated.

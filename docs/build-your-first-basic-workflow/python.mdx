---
id: python
title: Run your first Temporal application with the Python SDK
sidebar_label: Python
description: Learn Temporal's core concepts by building a money transfer Workflow with the Python SDK. Experience reliability, failure handling, and live debugging in a 10-minute tutorial.
keywords:
  - temporal
  - python
  - workflow
  - tutorial
  - money transfer
  - reliability
tags:
  - Python
  - SDK
  - Getting Started
hide_table_of_contents: false
---

import { SetupSteps, SetupStep, CodeSnippet } from "@site/src/components/elements/SetupSteps";
import { CallToAction } from "@site/src/components/elements/CallToAction";

You can think of Temporal as a sort of "cure-all" for the pains you experience as a developer when trying to build reliable applications. Whether you're writing a complex transaction-based Workflow or working with remote APIs, you know that creating reliable applications is a complex process.

<div style={{display: 'flex', gap: '0.5rem', marginBottom: '2rem'}}>
  <span className="badge badge--primary">‚≠ê Temporal beginner</span>
  <span className="badge badge--success">üêç Python SDK</span>
</div>


## Introduction

In this tutorial, you'll run your first Temporal Application. 
You'll use Temporal's Web UI for application state visibility, and then explore how Temporal helps you recover from a couple of common failures.

### Prerequisites

Before starting this tutorial:

- **Set up a local development environment** for developing Temporal Applications using the Python programming language
- **Ensure you have Git installed** to clone the project

<CallToAction 
  href="/develop/python/set-up-your-local-python"
  buttonText="Python Quickstart Guide"
  description="Run through the Quickstart to get your set up complete."
/>

### Application overview

This project in this tutorial simulates a **money transfer application**, focusing on essential transactions such as withdrawals, deposits, and refunds. The importance of Temporal in this context lies in its ability to handle your code efficiently and reliably.

<div style={{textAlign: 'center', margin: '2rem 0'}}>
  <img src="/img/moneytransfer/money-withdrawal.png" alt="Money Transfer Application Flow" style={{maxWidth: '100%', height: 'auto'}} />
</div>


In this sample application, money comes out of one account and goes into another. However, there are a few things that can go wrong with this process. If the withdrawal fails, then there is no need to try to make a deposit. But if the withdrawal succeeds, but the deposit fails, then the money needs to go back to the original account.

One of Temporal's most important features is its ability to **maintain the application state when something fails**. When failures happen, Temporal recovers processes where they left off or rolls them back correctly. This allows you to focus on business logic, instead of writing application code to recover from failure.

<SetupSteps>

<SetupStep code={
  <CodeSnippet language="bash">
git clone https://github.com/temporalio/money-transfer-project-template-python
cd money-transfer-project-template-python
  </CodeSnippet>
}>

### Download the example application

The application you'll use in this tutorial is available in a GitHub repository.

Open a new terminal window and use `git` to clone the repository, then change to the project directory.


Now that you've downloaded the project, let's dive into the code.



</SetupStep>
:::tip
The repository for this tutorial is a GitHub Template repository, which means you could clone it to your own account and use it as the foundation for your own Temporal application.
:::

<SetupStep code={
  <div style={{textAlign: 'center', padding: '2rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '0.5rem'}}>
    <div style={{marginBottom: '1rem'}}>
      <strong>Temporal Application Components</strong>
    </div>
    <div style={{textAlign: 'center', margin: '2rem 0'}}>
  <img src="/img/moneytransfer/yourapplication.png" alt="Your Temporal Application" style={{maxWidth: '100%', height: 'auto'}} />
</div>
    
    </div>

}>



### Let's Recap: Temporal's Application Structure 

The Temporal Application will consist of the following pieces:

1. **A Workflow** written in Python using the Python SDK. A Workflow defines the overall flow of the application.
2. **An Activity** is a method that encapsulates business logic prone to failure (e.g., calling a service that may go down). These Activities can be automatically retried upon some failure.
3. **A Worker**, provided by the Temporal SDK, which runs your Workflow and Activities reliably and consistently.




</SetupStep>
:::important
None of your application code runs on the Temporal Server. Your Worker, Workflow, and Activity run on your infrastructure, along with the rest of your applications.
:::

## Run a Money Transfer Flow 
### Step 1: Workflow Definition

A Workflow Definition in Python uses the `@workflow.defn` decorator on the Workflow class to identify a Workflow.

**workflows.py**
```python
from datetime import timedelta
from temporalio import workflow
from temporalio.common import RetryPolicy
from temporalio.exceptions import ActivityError

with workflow.unsafe.imports_passed_through():
    from activities import BankingActivities
    from shared import PaymentDetails

@workflow.defn
class MoneyTransfer:
    @workflow.run
    async def run(self, payment_details: PaymentDetails):
        retry_policy = RetryPolicy(
            maximum_attempts=3,
            maximum_interval=timedelta(seconds=2),
            non_retryable_error_types=["InvalidAccountError", "InsufficientFundsError"],
        )

        # Withdraw money
        withdraw_output = await workflow.execute_activity_method(
            BankingActivities.withdraw,
            payment_details,
            start_to_close_timeout=timedelta(seconds=5),
            retry_policy=retry_policy,
        )

        # Deposit money
        try:
            deposit_output = await workflow.execute_activity_method(
                BankingActivities.deposit,
                payment_details,
                start_to_close_timeout=timedelta(seconds=5),
                retry_policy=retry_policy,
            )

            result = "Transfer complete (transaction IDs: " + str(withdraw_output) + ", " + str(deposit_output) + ")"
            return result
        except ActivityError as deposit_err:
            # Handle deposit error
            workflow.logger.error("Deposit failed: " + str(deposit_err))
            # Attempt to refund
            try:
                refund_output = await workflow.execute_activity_method(
                    BankingActivities.refund,
                    payment_details,
                    start_to_close_timeout=timedelta(seconds=5),
                    retry_policy=retry_policy,
                )
                workflow.logger.info("Refund successful. Confirmation ID: " + str(refund_output))
                raise deposit_err
            except ActivityError as refund_error:
                workflow.logger.error("Refund failed: " + str(refund_error))
                raise refund_error
```

The `MoneyTransfer` class takes in transaction details. It executes Activities to withdraw and deposit the money. It also returns the results of the process.

The asynchronous `run` method signature includes an `input` variable typed as `PaymentDetails`. This class stores details that the Workflow uses to perform the money transfer.

### Step 2: Activity Definition

Each Activity method simulates calling an external service. 
Each method can fail or succeed independently.

In the money transfer application, you have three Activity methods: `withdraw()`, `deposit()`, and `refund()`. These symbolize the movement of funds between accounts.


**activities.py**
```python
import asyncio
from dataclasses import dataclass
from temporalio import activity
from shared import PaymentDetails

@dataclass
class BankingActivities:
    @activity.defn
    @staticmethod
    async def withdraw(data: PaymentDetails):
        print("Withdrawing money from account")
        
        # Simulate time to call other services that may fail
        await asyncio.sleep(1)
        
        return "Withdrew money from account"

    @activity.defn
    @staticmethod
    async def deposit(data: PaymentDetails):
        print("Depositing money into account")
        
        # Simulate time to call other services that may fail
        await asyncio.sleep(1)
        
        # Comment/uncomment the next line to simulate failures.
        # raise Exception("This deposit has failed.")

        return "Deposited money into account"

    @activity.defn
    @staticmethod
    async def refund(data: PaymentDetails):
        print("Refunding money back to account")
        
        # Simulate time to call other services that may fail
        await asyncio.sleep(1)
        
        return "Refunded money back to account"
```

**shared.py**
```python
from dataclasses import dataclass

MONEY_TRANSFER_TASK_QUEUE_NAME = "money-transfer"

@dataclass
class PaymentDetails:
    source_account: str
    target_account: str
    amount: int
    reference_id: str
```

The Activities are defined as static methods with the `@activity.defn` decorator.

Note the `PaymentDetails` type, defined in `shared.py`. This contains the transaction information passed between the Workflow and Activities.

### Step 3: Start the Worker

The Worker hosts the Workflow and Activity functions and executes them one at a time.

The Worker is configured to execute Workflows and Activities from the Task Queue. Since the Worker and Workflow are both configured to use the same Task Queue, the Worker will execute any Workflows and Activities sent to the Task Queue.

**run_worker.py**
```python
import asyncio
from temporalio.client import Client
from temporalio.worker import Worker
from activities import BankingActivities
from shared import MONEY_TRANSFER_TASK_QUEUE_NAME
from workflows import MoneyTransfer

async def main():
    client = await Client.connect("localhost:7233")
    
    worker = Worker(
        client,
        task_queue=MONEY_TRANSFER_TASK_QUEUE_NAME,
        workflows=[MoneyTransfer],
        activities=[BankingActivities.withdraw, BankingActivities.deposit, BankingActivities.refund],
    )
    
    await worker.run()

if __name__ == "__main__":
    asyncio.run(main())
```



When you start the Worker, it begins polling the Temporal Server for work.

<SetupStep code={
  <div>
    <div style={{marginBottom: '1rem'}}>
      <strong>Terminal 1 - Start the Temporal server:</strong>
      <CodeSnippet language="bash">
temporal server start-dev
      </CodeSnippet>
    </div>
    <div style={{marginBottom: '1rem'}}>
      <strong>Terminal 2 - Start the Worker:</strong>
      <CodeSnippet language="bash">
python run_worker.py
      </CodeSnippet>
    </div>
    <div style={{marginBottom: '1rem'}}>
      <strong>Terminal 3 - Start the Workflow:</strong>
      <CodeSnippet language="bash">
python run_workflow.py
      </CodeSnippet>
    </div>
    <div style={{marginTop: '2rem', padding: '1rem', background: 'rgba(16, 185, 129, 0.1)', borderRadius: '0.5rem'}}>
      <strong>‚úÖ Expected Success Output:</strong>
      <CodeSnippet language="text">
Result: Transfer complete (transaction IDs: Withdrew $250 from account 85-150. ReferenceId: 12345, Deposited $250 into account 43-812. ReferenceId: 12345)
      </CodeSnippet>
    </div>
  </div>
}>

### Run Your Application 

Now that your Worker is running and polling for tasks, you can start a Workflow execution.

**In Terminal 3, start the Workflow:**

The `run_workflow.py` script starts a Workflow Execution. Each time you run this file, the Temporal Server starts a new Workflow Execution.

A Workflow Execution has exclusive access to its local state and executes concurrently to all other Workflow Executions.

</SetupStep>

<SetupStep code={
  <CallToAction 
    href="http://localhost:8233"
    buttonText="üîç Open Temporal Web UI ‚Üí"
    description="View the state of the Workflow with the Temporal Web UI"
  />
}>


## View the state of the Workflow with the Temporal Web UI

The Temporal Web UI lets you see details about the Workflow you just ran.

**What you'll see in the UI:**
- List of Workflows with their execution status
- Workflow summary with input and result
- History tab showing all events in chronological order
- Query, Signal, and Update capabilities
- Stack Trace tab for debugging

**Try This:** Click on a Workflow in the list to see all the details of the Workflow Execution.

</SetupStep>

<div style={{textAlign: 'center', margin: '2rem 0'}}>
  <img src="/img/moneytransfer/webuisample.png" alt="Money Transfer Web UI " style={{maxWidth: '100%', height: 'auto'}} />
</div>

</SetupSteps>




<div className="row">
  <div className="col col--4">
    <CallToAction 
      href="/develop/python/core-application"
      buttonText="Build from Scratch"
      description="Learn to create Temporal apps step by step"
    />
  </div>
  <div className="col col--4">
    <CallToAction 
      href="https://learn.temporal.io/courses/"
      buttonText="Take a Free Course"
      description="Comprehensive learning paths"
    />
  </div>
  <div className="col col--4">
    <CallToAction 
      href="/develop/python"
      buttonText="Python SDK Guide"
      description="Complete developer documentation"
    />
  </div>
</div>
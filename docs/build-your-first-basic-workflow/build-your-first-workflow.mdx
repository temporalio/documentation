---
id: build-your-first-workflow
title: Build Your First Workflow
sidebar_label: "Part 1: Build Your First Workflow"
hide_table_of_contents: true
description: Learn Temporal's core concepts by building a money transfer Workflow. Experience reliability, failure handling, and live debugging in a short tutorial.
keywords:
  - temporal
  - workflow
  - tutorial
  - money transfer
  - reliability
tags:
  - Getting Started
  - Tutorial
---

import { SetupSteps, SetupStep, CodeSnippet } from "@site/src/components/elements/SetupSteps";
import { CallToAction } from "@site/src/components/elements/CallToAction";
import { TemporalProgress } from "@site/src/components/TemporalProgress";
import { StatusIndicators } from "@site/src/components/StatusIndicators";
import { RetryPolicyComparison } from "@site/src/components/RetryPolicyComparison";
import { NextButton } from "@site/src/components/TutorialNavigation";
import SdkTabs from "@site/src/components/elements/SdkTabs";
import { FaPython, FaJava } from 'react-icons/fa';
import { SiGo, SiTypescript, SiPhp, SiDotnet, SiRuby } from 'react-icons/si';

export const TUTORIAL_LANGUAGE_ORDER = [
  { key: 'py', label: 'Python', icon: FaPython },
  { key: 'go', label: 'Go', icon: SiGo },
  { key: 'java', label: 'Java', icon: FaJava },
  { key: 'ts', label: 'TypeScript', icon: SiTypescript },
  { key: 'php', label: 'PHP', icon: SiPhp },
  { key: 'dotnet', label: '.NET', icon: SiDotnet },
  { key: 'rb', label: 'Ruby', icon: SiRuby },
];

You can think of Temporal as a sort of "cure-all" for the pains you experience as a developer when trying to build reliable applications. Whether you're writing a complex transaction-based Workflow or working with remote APIs, you know that creating reliable applications is a complex process.

<div style={{display: 'flex', gap: '0.5rem', marginBottom: '2rem'}}>
  <span className="badge badge--success">Temporal beginner</span>
</div>

<TemporalProgress steps={[
  { id: 'part1', label: 'Part 1: Build Your First Workflow', status: 'active' },
  { id: 'part2', label: 'Part 2: Failure Simulation', status: 'pending' }
]} />


## Introduction

In this tutorial, you'll build and run your first Temporal Application. 
You'll learn how to construct Workflows and Activities, understand the core building blocks, and see you can get full visibility into its execution.

### Prerequisites

Before starting this tutorial:

- **Set up a local development environment** for developing Temporal Applications
- **Ensure you have Git installed** to clone the project

<CallToAction 
  href="/quickstarts"
  buttonText="Quickstart Guide"
  description="Run through the Quickstart to get your set up complete."
/>

### What You'll Build

You'll construct a **money transfer application** from the ground up, learning to design and implement essential transactions such as withdrawals, deposits, and refunds using Temporal's powerful building blocks. 

**Why This Application?** It demonstrates real-world complexity while teaching you how to build reliable, fault-tolerant systems that handle money safely.

<div style={{textAlign: 'center', margin: '2rem 0'}}>
  <img src="/img/moneytransfer/money-withdrawal.png" alt="Money Transfer Application Flow" style={{maxWidth: '100%', height: 'auto'}} />
</div>


In this sample application, money comes out of one account and goes into another. However, there are a few things that can go wrong with this process. If the withdrawal fails, then there is no need to try to make a deposit. But if the withdrawal succeeds, but the deposit fails, then the money needs to go back to the original account.

One of Temporal's most important features is its ability to **maintain the application state when something fails**. When failures happen, Temporal recovers processes where they left off or rolls them back correctly. This allows you to focus on business logic, instead of writing application code to recover from failure.

<SetupSteps>

<SetupStep code={
  <CodeSnippet language="bash">
git clone https://github.com/temporalio/money-transfer-project-template-python
cd money-transfer-project-template-python
  </CodeSnippet>
}>

### Download the example application

The application you'll use in this tutorial is available in a GitHub repository.

Open a new terminal window and use `git` to clone the repository, then change to the project directory.

Now that you've downloaded the project, let's dive into the code.



</SetupStep>
:::tip
The repository for this tutorial is a GitHub Template repository, which means you could clone it to your own account and use it as the foundation for your own Temporal application.
:::

<SetupStep code={
  <div style={{textAlign: 'center', padding: '2rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '0.5rem'}}>
    <div style={{marginBottom: '1rem'}}>
      <strong>Temporal Application Components</strong>
    </div>
    <div style={{textAlign: 'center', margin: '2rem 0'}}>
  <img src="/img/moneytransfer/yourapplication.png" alt="Your Temporal Application" style={{maxWidth: '250px', height: 'auto'}} />
</div>
    
    </div>

}>



### Let's Recap: Temporal's Application Structure 

The Temporal Application will consist of the following pieces:

1. **A Workflow** written in Python using the Python SDK. A Workflow defines the overall flow of the application.
2. **An Activity** is a method that encapsulates business logic prone to failure (e.g., calling a service that may go down). These Activities can be automatically retried upon some failure. They handle individual tasks like withdraw(), deposit(), and refund().
3. **A Worker**, provided by the Temporal SDK, which runs your Workflow and Activities reliably and consistently.

</SetupStep>

</SetupSteps>

:::important
None of your application code runs on the Temporal Server. Your Worker, Workflow, and Activity run on your infrastructure, along with the rest of your applications.
:::

## Step 1: Build your Workflow and Activities 

<SdkTabs languageOrder={TUTORIAL_LANGUAGE_ORDER}>
<SdkTabs.Python>

<h3>Workflow Definition</h3>

A Workflow Definition in Python uses the `@workflow.defn` decorator on the Workflow class to identify a Workflow.

This is what the Workflow Definition looks like for this kind of process:

**workflows.py**

```python
from datetime import timedelta
from temporalio import workflow
from temporalio.common import RetryPolicy
from temporalio.exceptions import ActivityError

with workflow.unsafe.imports_passed_through():
    from activities import BankingActivities
    from shared import PaymentDetails

@workflow.defn
class MoneyTransfer:
    @workflow.run
    async def run(self, payment_details: PaymentDetails) -> str:
        retry_policy = RetryPolicy(
            maximum_attempts=3,
            maximum_interval=timedelta(seconds=2),
            non_retryable_error_types=["InvalidAccountError", "InsufficientFundsError"],
        )

        # Withdraw money
        withdraw_output = await workflow.execute_activity_method(
            BankingActivities.withdraw,
            payment_details,
            start_to_close_timeout=timedelta(seconds=5),
            retry_policy=retry_policy,
        )

        # Deposit money
        try:
            deposit_output = await workflow.execute_activity_method(
                BankingActivities.deposit,
                payment_details,
                start_to_close_timeout=timedelta(seconds=5),
                retry_policy=retry_policy,
            )

            result = f"Transfer complete (transaction IDs: {withdraw_output}, {deposit_output})"
            return result
        except ActivityError as deposit_err:
            # Handle deposit error
            workflow.logger.error(f"Deposit failed: {deposit_err}")
            # Attempt to refund
            try:
                refund_output = await workflow.execute_activity_method(
                    BankingActivities.refund,
                    payment_details,
                    start_to_close_timeout=timedelta(seconds=5),
                    retry_policy=retry_policy,
                )
                workflow.logger.info(
                    f"Refund successful. Confirmation ID: {refund_output}"
                )
                raise deposit_err
            except ActivityError as refund_error:
                workflow.logger.error(f"Refund failed: {refund_error}")
                raise refund_error
```

<h3>Activity Definition</h3>

Activities handle the business logic. Each activity method calls an external banking service:

**activities.py**

```python
import asyncio
from temporalio import activity
from shared import PaymentDetails

class BankingActivities:
    @activity.defn
    async def withdraw(self, data: PaymentDetails) -> str:
        reference_id = f"{data.reference_id}-withdrawal"
        try:
            confirmation = await asyncio.to_thread(
                self.bank.withdraw, data.source_account, data.amount, reference_id
            )
            return confirmation
        except InvalidAccountError:
            raise
        except Exception:
            activity.logger.exception("Withdrawal failed")
            raise
```

</SdkTabs.Python>

<SdkTabs.Go>

<h3>Workflow Definition</h3>

In the Temporal Go SDK, a Workflow Definition is a Go function that accepts a Workflow Context and input parameters.

This is what the Workflow Definition looks like for the money transfer process:

**workflow.go**

```go
func MoneyTransfer(ctx workflow.Context, input PaymentDetails) (string, error) {
    // RetryPolicy specifies how to automatically handle retries if an Activity fails.
    retrypolicy := &temporal.RetryPolicy{
        InitialInterval:        time.Second,
        BackoffCoefficient:     2.0,
        MaximumInterval:        100 * time.Second,
        MaximumAttempts:        500, // 0 is unlimited retries
        NonRetryableErrorTypes: []string{"InvalidAccountError", "InsufficientFundsError"},
    }

    options := workflow.ActivityOptions{
        // Timeout options specify when to automatically timeout Activity functions.
        StartToCloseTimeout: time.Minute,
        // Optionally provide a customized RetryPolicy.
        // Temporal retries failed Activities by default.
        RetryPolicy: retrypolicy,
    }

    // Apply the options.
    ctx = workflow.WithActivityOptions(ctx, options)

    // Withdraw money.
    var withdrawOutput string
    withdrawErr := workflow.ExecuteActivity(ctx, Withdraw, input).Get(ctx, &withdrawOutput)
    if withdrawErr != nil {
        return "", withdrawErr
    }

    // Deposit money.
    var depositOutput string
    depositErr := workflow.ExecuteActivity(ctx, Deposit, input).Get(ctx, &depositOutput)
    if depositErr != nil {
        // The deposit failed; put money back in original account.
        var result string
        refundErr := workflow.ExecuteActivity(ctx, Refund, input).Get(ctx, &result)
        if refundErr != nil {
            return "",
                fmt.Errorf("Deposit: failed to deposit money into %v: %v. Money could not be returned to %v: %w",
                    input.TargetAccount, depositErr, input.SourceAccount, refundErr)
        }
        return "", fmt.Errorf("Deposit: failed to deposit money into %v: Money returned to %v: %w",
            input.TargetAccount, input.SourceAccount, depositErr)
    }

    result := fmt.Sprintf("Transfer complete (transaction IDs: %s, %s)", withdrawOutput, depositOutput)
    return result, nil
}
```

The `MoneyTransfer` function takes in the details about the transaction, executes Activities to withdraw and deposit the money, and returns the results of the process. The `PaymentDetails` type is defined in `shared.go`:

**shared.go**

```go
type PaymentDetails struct {
    SourceAccount string
    TargetAccount string
    Amount        int
    ReferenceID   string
}
```

<h3>Activity Definition</h3>

Activities handle the business logic. Each Activity function calls an external banking service:

**activity.go**

```go
func Withdraw(ctx context.Context, data PaymentDetails) (string, error) {
    log.Printf("Withdrawing $%d from account %s.\n\n",
        data.Amount,
        data.SourceAccount,
    )

    referenceID := fmt.Sprintf("%s-withdrawal", data.ReferenceID)
    bank := BankingService{"bank-api.example.com"}
    confirmation, err := bank.Withdraw(data.SourceAccount, data.Amount, referenceID)
    return confirmation, err
}

func Deposit(ctx context.Context, data PaymentDetails) (string, error) {
    log.Printf("Depositing $%d into account %s.\n\n",
        data.Amount,
        data.TargetAccount,
    )

    referenceID := fmt.Sprintf("%s-deposit", data.ReferenceID)
    bank := BankingService{"bank-api.example.com"}
    confirmation, err := bank.Deposit(data.TargetAccount, data.Amount, referenceID)
    return confirmation, err
}
```

</SdkTabs.Go>

<SdkTabs.Java>

<h3>Workflow Definition</h3>

In the Temporal Java SDK, a Workflow Definition is marked by the `@WorkflowInterface` attribute placed above the class interface.

**MoneyTransferWorkflow.java**

```java
@WorkflowInterface
public interface MoneyTransferWorkflow {
    @WorkflowMethod
    void transfer(TransactionDetails transaction);
}
```

**MoneyTransferWorkflowImpl.java**

```java
public class MoneyTransferWorkflowImpl implements MoneyTransferWorkflow {
    
    // RetryOptions specify how to automatically handle retries when Activities fail
    private final RetryOptions retryoptions = RetryOptions.newBuilder()
        .setInitialInterval(Duration.ofSeconds(1))
        .setMaximumInterval(Duration.ofSeconds(20))
        .setBackoffCoefficient(2)
        .setMaximumAttempts(5000)
        .build();

    private final ActivityOptions defaultActivityOptions = ActivityOptions.newBuilder()
        .setRetryOptions(retryoptions)
        .setStartToCloseTimeout(Duration.ofSeconds(2))
        .setScheduleToCloseTimeout(Duration.ofSeconds(5000))
        .build();

    private final AccountActivity accountActivityStub = 
        Workflow.newActivityStub(AccountActivity.class, defaultActivityOptions);

    @Override
    public void transfer(TransactionDetails transaction) {
        String sourceAccountId = transaction.getSourceAccountId();
        String destinationAccountId = transaction.getDestinationAccountId();
        String transactionReferenceId = transaction.getTransactionReferenceId();
        int amountToTransfer = transaction.getAmountToTransfer();

        // Stage 1: Withdraw funds from source
        try {
            accountActivityStub.withdraw(sourceAccountId, transactionReferenceId, amountToTransfer);
        } catch (Exception e) {
            System.out.printf("[%s] Withdrawal of $%d from account %s failed", 
                            transactionReferenceId, amountToTransfer, sourceAccountId);
            return;
        }

        // Stage 2: Deposit funds to destination
        try {
            accountActivityStub.deposit(destinationAccountId, transactionReferenceId, amountToTransfer);
            System.out.printf("[%s] Transaction succeeded.\n", transactionReferenceId);
            return;
        } catch (Exception e) {
            System.out.printf("[%s] Deposit of $%d to account %s failed.\n", 
                            transactionReferenceId, amountToTransfer, destinationAccountId);
        }

        // Compensate with a refund
        try {
            System.out.printf("[%s] Refunding $%d to account %s.\n", 
                            transactionReferenceId, amountToTransfer, sourceAccountId);
            accountActivityStub.refund(sourceAccountId, transactionReferenceId, amountToTransfer);
            System.out.printf("[%s] Refund to originating account was successful.\n", transactionReferenceId);
        } catch (Exception e) {
            System.out.printf("[%s] Workflow failed.", transactionReferenceId);
            throw(e);
        }
    }
}
```

The `TransactionDetails` interface:

**TransactionDetails.java**

```java
public interface TransactionDetails {
    String getSourceAccountId();
    String getDestinationAccountId();
    String getTransactionReferenceId();
    int getAmountToTransfer();
}
```

<h3>Activity Definition</h3>

Activities handle the business logic. Each Activity method calls an external banking service:

**AccountActivity.java**

```java
@ActivityInterface
public interface AccountActivity {
    @ActivityMethod
    void withdraw(String accountId, String referenceId, int amount);

    @ActivityMethod
    void deposit(String accountId, String referenceId, int amount);

    @ActivityMethod
    void refund(String accountId, String referenceId, int amount);
}
```

**AccountActivityImpl.java**

```java
public class AccountActivityImpl implements AccountActivity {
    @Override
    public void withdraw(String accountId, String referenceId, int amount) {
        System.out.printf("\nWithdrawing $%d from account %s.\n[ReferenceId: %s]\n", 
                         amount, accountId, referenceId);
    }

    @Override
    public void deposit(String accountId, String referenceId, int amount) {
        System.out.printf("\nDepositing $%d into account %s.\n[ReferenceId: %s]\n", 
                         amount, accountId, referenceId);
    }

    @Override
    public void refund(String accountId, String referenceId, int amount) {
        System.out.printf("\nRefunding $%d to account %s.\n[ReferenceId: %s]\n", 
                         amount, accountId, referenceId);
    }
}
```

</SdkTabs.Java>

<SdkTabs.TypeScript>

<h3>Workflow Definition</h3>

In the Temporal TypeScript SDK, a Workflow Definition is a regular TypeScript function that accepts some input values.

This is what the Workflow Definition looks like for the money transfer process:

**workflows.ts**

```typescript
import { proxyActivities } from '@temporalio/workflow';
import { ApplicationFailure } from '@temporalio/common';

import type * as activities from './activities';
import type { PaymentDetails } from './shared';

export async function moneyTransfer(details: PaymentDetails): Promise<string> {
  // Get the Activities for the Workflow and set up the Activity Options.
  const { withdraw, deposit, refund } = proxyActivities<typeof activities>({
    // RetryPolicy specifies how to automatically handle retries if an Activity fails.
    retry: {
      initialInterval: '1 second',
      maximumInterval: '1 minute',
      backoffCoefficient: 2,
      maximumAttempts: 500,
      nonRetryableErrorTypes: ['InvalidAccountError', 'InsufficientFundsError'],
    },
    startToCloseTimeout: '1 minute',
  });

  // Execute the withdraw Activity
  let withdrawResult: string;
  try {
    withdrawResult = await withdraw(details);
  } catch (withdrawErr) {
    throw new ApplicationFailure(`Withdrawal failed. Error: ${withdrawErr}`);
  }

  //Execute the deposit Activity
  let depositResult: string;
  try {
    depositResult = await deposit(details);
  } catch (depositErr) {
    // The deposit failed; try to refund the money.
    let refundResult;
    try {
      refundResult = await refund(details);
      throw ApplicationFailure.create({
        message: `Failed to deposit money into account ${details.targetAccount}. Money returned to ${details.sourceAccount}. Cause: ${depositErr}.`,
      });
    } catch (refundErr) {
      throw ApplicationFailure.create({
        message: `Failed to deposit money into account ${details.targetAccount}. Money could not be returned to ${details.sourceAccount}. Cause: ${refundErr}.`,
      });
    }
  }
  return `Transfer complete (transaction IDs: ${withdrawResult}, ${depositResult})`;
}
```

The `PaymentDetails` type is defined in `shared.ts`:

**shared.ts**

```typescript
export type PaymentDetails = {
  amount: number;
  sourceAccount: string;
  targetAccount: string;
  referenceId: string;
};
```

<h3>Activity Definition</h3>

Activities handle the business logic. Each Activity function calls an external banking service:

**activities.ts**

```typescript
import type { PaymentDetails } from './shared';
import { BankingService } from './banking-client';

export async function withdraw(details: PaymentDetails): Promise<string> {
  console.log(
    `Withdrawing $${details.amount} from account ${details.sourceAccount}.\n\n`
  );
  const bank1 = new BankingService('bank1.example.com');
  return await bank1.withdraw(
    details.sourceAccount,
    details.amount,
    details.referenceId
  );
}

export async function deposit(details: PaymentDetails): Promise<string> {
  console.log(
    `Depositing $${details.amount} into account ${details.targetAccount}.\n\n`
  );
  const bank2 = new BankingService('bank2.example.com');
  return await bank2.deposit(
    details.targetAccount,
    details.amount,
    details.referenceId
  );
}

export async function refund(details: PaymentDetails): Promise<string> {
  console.log(
    `Refunding $${details.amount} to account ${details.sourceAccount}.\n\n`
  );
  const bank1 = new BankingService('bank1.example.com');
  return await bank1.deposit(
    details.sourceAccount,
    details.amount,
    details.referenceId
  );
}
```

</SdkTabs.TypeScript>

<SdkTabs.Ruby>

<h3>Workflow Definition</h3>

In the Temporal Ruby SDK, a Workflow Definition is a class that extends `Temporalio::Workflow::Definition`.

This is what the Workflow Definition looks like for the money transfer process:

**workflow.rb**

```ruby
class MoneyTransferWorkflow < Temporalio::Workflow::Definition
  def execute(details)
    retry_policy = Temporalio::RetryPolicy.new(
      max_interval: 10,
      non_retryable_error_types: [
        'InvalidAccountError',
        'InsufficientFundsError'
      ]
    )

    Temporalio::Workflow.logger.info("Starting workflow (#{details})")

    withdraw_result = Temporalio::Workflow.execute_activity(
      BankActivities::Withdraw,
      details,
      start_to_close_timeout: 5,
      retry_policy: retry_policy
    )

    begin
      deposit_result = Temporalio::Workflow.execute_activity(
        BankActivities::Deposit,
        details,
        start_to_close_timeout: 5,
        retry_policy: retry_policy
      )
      
      "Transfer complete (transaction IDs: #{withdraw_result}, #{deposit_result})"
    rescue Temporalio::Error::ActivityError => e
      # Since the deposit failed, attempt to recover by refunding
      begin
        refund_result = Temporalio::Workflow.execute_activity(
          BankActivities::Refund,
          details,
          start_to_close_timeout: 5,
          retry_policy: retry_policy
        )
        
        "Transfer complete (transaction IDs: #{withdraw_result}, #{refund_result})"
      rescue Temporalio::Error::ActivityError => refund_error
        Temporalio::Workflow.logger.error("Refund failed: #{refund_error}")
      end
    end
  end
end
```

The `TransferDetails` struct is defined in `shared.rb`:

**shared.rb**

```ruby
TransferDetails = Struct.new(:source_account, :target_account, :amount, :reference_id) do
  def to_s
    "TransferDetails { #{source_account}, #{target_account}, #{amount}, #{reference_id} }"
  end
end
```

<h3>Activity Definition</h3>

Activities handle the business logic. Each Activity class calls an external banking service:

**activities.rb**

```ruby
module BankActivities
  class Withdraw < Temporalio::Activity::Definition
    def execute(details)
      puts("Doing a withdrawal from #{details.source_account} for #{details.amount}")
      raise InsufficientFundsError, 'Transfer amount too large' if details.amount > 1000
      
      "OKW-#{details.amount}-#{details.source_account}"
    end
  end

  class Deposit < Temporalio::Activity::Definition
    def execute(details)
      puts("Doing a deposit into #{details.target_account} for #{details.amount}")
      raise InvalidAccountError, 'Invalid account number' if details.target_account == 'B5555'
      
      "OKD-#{details.amount}-#{details.target_account}"
    end
  end

  class Refund < Temporalio::Activity::Definition
    def execute(details)
      puts("Refunding #{details.amount} back to account #{details.source_account}")
      
      "OKR-#{details.amount}-#{details.source_account}"
    end
  end
end
```

</SdkTabs.Ruby>

<SdkTabs.DotNet>

<h3>Workflow Definition</h3>

In the Temporal .NET SDK, a Workflow Definition is marked by the `[Workflow]` attribute placed above the class.

This is what the Workflow Definition looks like for this process:

**MoneyTransferWorker/Workflow.cs**

```csharp
[Workflow]
public class MoneyTransferWorkflow
{
    [WorkflowRun]
    public async Task<string> RunAsync(PaymentDetails details)
    {
        // Retry policy
        var retryPolicy = new RetryPolicy
        {
            InitialInterval = TimeSpan.FromSeconds(1),
            MaximumInterval = TimeSpan.FromSeconds(100),
            BackoffCoefficient = 2,
            MaximumAttempts = 3,
            NonRetryableErrorTypes = new[] { "InvalidAccountException", "InsufficientFundsException" }
        };

        string withdrawResult;
        try
        {
            withdrawResult = await Workflow.ExecuteActivityAsync(
                () => BankingActivities.WithdrawAsync(details),
                new ActivityOptions { StartToCloseTimeout = TimeSpan.FromMinutes(5), RetryPolicy = retryPolicy }
            );
        }
        catch (ApplicationFailureException ex) when (ex.ErrorType == "InsufficientFundsException")
        {
            throw new ApplicationFailureException("Withdrawal failed due to insufficient funds.", ex);
        }

        string depositResult;
        try
        {
            depositResult = await Workflow.ExecuteActivityAsync(
                () => BankingActivities.DepositAsync(details),
                new ActivityOptions { StartToCloseTimeout = TimeSpan.FromMinutes(5), RetryPolicy = retryPolicy }
            );
            return $"Transfer complete (transaction IDs: {withdrawResult}, {depositResult})";
        }
        catch (Exception depositEx)
        {
            try
            {
                // if the deposit fails, attempt to refund the withdrawal
                string refundResult = await Workflow.ExecuteActivityAsync(
                    () => BankingActivities.RefundAsync(details),
                    new ActivityOptions { StartToCloseTimeout = TimeSpan.FromMinutes(5), RetryPolicy = retryPolicy }
                );
                throw new ApplicationFailureException($"Failed to deposit money into account {details.TargetAccount}. Money returned to {details.SourceAccount}.", depositEx);
            }
            catch (Exception refundEx)
            {
                throw new ApplicationFailureException($"Failed to deposit money into account {details.TargetAccount}. Money could not be returned to {details.SourceAccount}. Cause: {refundEx.Message}", refundEx);
            }
        }
    }
}
```

The `PaymentDetails` record is defined in `PaymentDetails.cs`:

**MoneyTransferWorker/PaymentDetails.cs**

```csharp
public record PaymentDetails(
    string SourceAccount,
    string TargetAccount,
    int Amount,
    string ReferenceId);
```

<h3>Activity Definition</h3>

Activities handle the business logic. Each Activity method calls an external banking service:

**MoneyTransferWorker/Activities.cs**

```csharp
public class BankingActivities
{
    [Activity]
    public static async Task<string> WithdrawAsync(PaymentDetails details)
    {
        var bankService = new BankingService("bank1.example.com");
        Console.WriteLine($"Withdrawing ${details.Amount} from account {details.SourceAccount}.");
        try
        {
            return await bankService.WithdrawAsync(details.SourceAccount, details.Amount, details.ReferenceId).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            throw new ApplicationFailureException("Withdrawal failed", ex);
        }
    }

    [Activity]
    public static async Task<string> DepositAsync(PaymentDetails details)
    {
        var bankService = new BankingService("bank2.example.com");
        Console.WriteLine($"Depositing ${details.Amount} into account {details.TargetAccount}.");
        
        try
        {
            return await bankService.DepositAsync(details.TargetAccount, details.Amount, details.ReferenceId);
        }
        catch (Exception ex)
        {
            throw new ApplicationFailureException("Deposit failed", ex);
        }
    }
}
```

</SdkTabs.DotNet>

</SdkTabs>

## Step 2: Set the Retry Policy

Temporal makes your software durable and fault tolerant by default. If an Activity fails, Temporal automatically retries it, but you can customize this behavior through a Retry Policy.

### Retry Policy Configuration

In the `MoneyTransfer` Workflow, you'll see a Retry Policy that controls this behavior:

<SdkTabs languageOrder={TUTORIAL_LANGUAGE_ORDER}>
<SdkTabs.Python>

**workflows.py**

```python
# ...
retry_policy = RetryPolicy(
    maximum_attempts=3,                    # Stop after 3 tries
    maximum_interval=timedelta(seconds=2), # Don't wait longer than 2s
    non_retryable_error_types=[           # Never retry these errors
        "InvalidAccountError", 
        "InsufficientFundsError"
    ],
)
```

</SdkTabs.Python>

<SdkTabs.Go>

**workflow.go**

```go
// ...
// RetryPolicy specifies how to automatically handle retries if an Activity fails.
retrypolicy := &temporal.RetryPolicy{
    InitialInterval:        time.Second,                                             // Start with 1 second wait
    BackoffCoefficient:     2.0,                                                     // Double the wait each time
    MaximumInterval:        100 * time.Second,                                       // Don't wait longer than 100s
    MaximumAttempts:        500,                                                     // Stop after 500 tries (0 = unlimited)
    NonRetryableErrorTypes: []string{"InvalidAccountError", "InsufficientFundsError"}, // Never retry these errors
}

options := workflow.ActivityOptions{
    StartToCloseTimeout: time.Minute, 
    RetryPolicy: retrypolicy,         
}

// Apply the options.
```

</SdkTabs.Go>

<SdkTabs.Java>

**src/main/java/moneytransfer/MoneyTransferWorkflowImpl.java**

```java
// ...
private static final String WITHDRAW = "Withdraw";

// RetryOptions specify how to automatically handle retries when Activities fail
private final RetryOptions retryoptions = RetryOptions.newBuilder()
    .setInitialInterval(Duration.ofSeconds(1))  // Start with 1 second wait
    .setMaximumInterval(Duration.ofSeconds(20)) // Don't wait longer than 20s
    .setBackoffCoefficient(2)                   // Double the wait each time (1s, 2s, 4s, etc)
    .setMaximumAttempts(5000)                   // Stop after 5000 tries
    .build();                                   
```

</SdkTabs.Java>

<SdkTabs.TypeScript>

**src/workflows.ts**

```typescript
// ...
const { withdraw, deposit, refund } = proxyActivities<typeof activities>({
  // RetryPolicy specifies how to automatically handle retries if an Activity fails.
  retry: {
    initialInterval: '1 second',                                                    // Start with 1 second wait
    maximumInterval: '1 minute',                                                    // Don't wait longer than 1 minute
    backoffCoefficient: 2,                                                          // Double the wait each time
    maximumAttempts: 500,                                                           // Stop after 500 tries
    nonRetryableErrorTypes: ['InvalidAccountError', 'InsufficientFundsError'],      // Never retry these errors
  },
  startToCloseTimeout: '1 minute',                                                   // Activity must complete within 1 minute
});
```

</SdkTabs.TypeScript>

<SdkTabs.DotNet>

**MoneyTransferWorker/Workflow.cs**

```csharp
// ...
// Retry policy
var retryPolicy = new RetryPolicy
{
    InitialInterval = TimeSpan.FromSeconds(1),                                                 // Start with 1 second wait
    MaximumInterval = TimeSpan.FromSeconds(100),                                               // Don't wait longer than 100s
    BackoffCoefficient = 2,                                                                    // Double the wait each time
    MaximumAttempts = 3,                                                                       // Stop after 3 tries
    NonRetryableErrorTypes = new[] { "InvalidAccountException", "InsufficientFundsException" } // Never retry these errors
};
```

</SdkTabs.DotNet>

<SdkTabs.Ruby>

**workflow.rb**

```ruby
# Temporal Workflow that withdraws the specified amount from the source
# account and deposits it into the target account, refunding the source
# account if the deposit cannot be completed.
class MoneyTransferWorkflow < Temporalio::Workflow::Definition
  def execute(details)
    retry_policy = Temporalio::RetryPolicy.new(
      max_interval: 10,                    # Don't wait longer than 10s
      non_retryable_error_types: [         # Never retry these errors
        'InvalidAccountError',
        'InsufficientFundsError'
      ]
    )
```

</SdkTabs.Ruby>

</SdkTabs>

### What Makes Errors Non-Retryable?
Without retry policies, a temporary network glitch could cause your entire money transfer to fail. With Temporal's intelligent retries, your workflow becomes resilient to these common infrastructure issues.


<RetryPolicyComparison />

:::important This is a Simplified Example
This tutorial shows core Temporal features and is not intended for production use. A real money transfer system would need additional logic for edge cases, cancellations, and error handling.
:::

## Step 3: Create a Worker file

A Worker is responsible for executing your Workflow and Activity code. It:

- Can only execute Workflows and Activities registered to it
- Knows which piece of code to execute based on Tasks from the Task Queue
- Only listens to the Task Queue that it's registered to
- Returns execution results back to the Temporal Server

<SdkTabs languageOrder={TUTORIAL_LANGUAGE_ORDER}>
<SdkTabs.Python>

**run_worker.py**

```python
import asyncio

from temporalio.client import Client
from temporalio.worker import Worker

from activities import BankingActivities
from shared import MONEY_TRANSFER_TASK_QUEUE_NAME
from workflows import MoneyTransfer


async def main() -> None:
    client: Client = await Client.connect("localhost:7233", namespace="default")
    # Run the worker
    activities = BankingActivities()
    worker: Worker = Worker(
        client,
        task_queue=MONEY_TRANSFER_TASK_QUEUE_NAME,
        workflows=[MoneyTransfer],
        activities=[activities.withdraw, activities.deposit, activities.refund],
    )
    await worker.run()


if __name__ == "__main__":
    asyncio.run(main())
```

</SdkTabs.Python>

<SdkTabs.Go>

**worker/main.go**

```go
func main() {
    c, err := client.Dial(client.Options{})
    if err != nil {
        log.Fatalln("Unable to create Temporal client.", err)
    }
    defer c.Close()

    w := worker.New(c, app.MoneyTransferTaskQueueName, worker.Options{})

    // This worker hosts both Workflow and Activity functions.
    w.RegisterWorkflow(app.MoneyTransfer)
    w.RegisterActivity(app.Withdraw)
    w.RegisterActivity(app.Deposit)
    w.RegisterActivity(app.Refund)

    // Start listening to the Task Queue.
    err = w.Run(worker.InterruptCh())
    if err != nil {
        log.Fatalln("unable to start Worker", err)
    }
}
```

</SdkTabs.Go>

<SdkTabs.Java>

**src/main/java/moneytransfer/MoneyTransferWorker.java**

```java
package moneytransferapp;

import io.temporal.client.WorkflowClient;
import io.temporal.serviceclient.WorkflowServiceStubs;
import io.temporal.worker.Worker;
import io.temporal.worker.WorkerFactory;

public class MoneyTransferWorker {
    public static void main(String[] args) {
        // Create a stub that accesses a Temporal Service on the local development machine
        WorkflowServiceStubs serviceStub = WorkflowServiceStubs.newLocalServiceStubs();

        // The Worker uses the Client to communicate with the Temporal Service
        WorkflowClient client = WorkflowClient.newInstance(serviceStub);

        // A WorkerFactory creates Workers
        WorkerFactory factory = WorkerFactory.newInstance(client);

        // A Worker listens to one Task Queue.
        // This Worker processes both Workflows and Activities
        Worker worker = factory.newWorker(Shared.MONEY_TRANSFER_TASK_QUEUE);

        // Register a Workflow implementation with this Worker
        // The implementation must be known at runtime to dispatch Workflow tasks
        // Workflows are stateful so a type is needed to create instances.
        worker.registerWorkflowImplementationTypes(MoneyTransferWorkflowImpl.class);

        // Register Activity implementation(s) with this Worker.
        // The implementation must be known at runtime to dispatch Activity tasks
        // Activities are stateless and thread safe so a shared instance is used.
        worker.registerActivitiesImplementations(new AccountActivityImpl());

        System.out.println("Worker is running and actively polling the Task Queue.");
        System.out.println("To quit, use ^C to interrupt.");

        // Start all registered Workers. The Workers will start polling the Task Queue.
        factory.start();
    }
}
```

</SdkTabs.Java>

<SdkTabs.TypeScript>

**src/worker.ts**

```typescript
import { Worker } from '@temporalio/worker';
import * as activities from './activities';
import { namespace, taskQueueName } from './shared';

async function run() {
  // Register Workflows and Activities with the Worker and connect to
  // the Temporal server.
  const worker = await Worker.create({
    workflowsPath: require.resolve('./workflows'),
    activities,
    namespace,
    taskQueue: taskQueueName,
  });

  // Start accepting tasks from the Task Queue.
  await worker.run();
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
```

</SdkTabs.TypeScript>

<SdkTabs.DotNet>

**MoneyTransferWorker/Program.cs**

```csharp
// This file is designated to run the worker
using Temporalio.Client;
using Temporalio.Worker;
using Temporalio.MoneyTransferProject.MoneyTransferWorker;

// Create a client to connect to localhost on "default" namespace
var client = await TemporalClient.ConnectAsync(new("localhost:7233"));

// Cancellation token to shutdown worker on ctrl+c
using var tokenSource = new CancellationTokenSource();
Console.CancelKeyPress += (_, eventArgs) =>
{
    tokenSource.Cancel();
    eventArgs.Cancel = true;
};

// Create an instance of the activities since we have instance activities.
// If we had all static activities, we could just reference those directly.
var activities = new BankingActivities();

// Create a worker with the activity and workflow registered
using var worker = new TemporalWorker(
    client, // client
    new TemporalWorkerOptions(taskQueue: "MONEY_TRANSFER_TASK_QUEUE")
        .AddAllActivities(activities) // Register activities
        .AddWorkflow<MoneyTransferWorkflow>() // Register workflow
);

// Run the worker until it's cancelled
Console.WriteLine("Running worker...");
try
{
    await worker.ExecuteAsync(tokenSource.Token);
}
catch (OperationCanceledException)
{
    Console.WriteLine("Worker cancelled");
}
```

</SdkTabs.DotNet>

<SdkTabs.Ruby>

**worker.rb**

```ruby
require_relative 'activities'
require_relative 'shared'
require_relative 'workflow'
require 'logger'
require 'temporalio/client'
require 'temporalio/worker'

# Create a Temporal Client that connects to a local Temporal Service, uses
# a Namespace called 'default', and displays log messages to standard output
client = Temporalio::Client.connect(
  'localhost:7233',
  'default',
  logger: Logger.new($stdout, level: Logger::INFO)
)

# Create a Worker that polls the specified Task Queue and can 
# fulfill requests for the specified Workflow and Activities
worker = Temporalio::Worker.new(
  client:,
  task_queue: MoneyTransfer::TASK_QUEUE_NAME,
  workflows: [MoneyTransfer::MoneyTransferWorkflow],
  activities: [MoneyTransfer::BankActivities::Withdraw, 
               MoneyTransfer::BankActivities::Deposit,
               MoneyTransfer::BankActivities::Refund]
)

# Start the Worker, which will poll the Task Queue until stopped
puts 'Starting Worker (press Ctrl+C to exit)'
worker.run(shutdown_signals: ['SIGINT'])
```

</SdkTabs.Ruby>

</SdkTabs>

## Step 4: Define the Task Queue

A Task Queue is where Temporal Workers look for Tasks about Workflows and Activities to execute. 
Each Task Queue is identified by a name, which you will specify when you configure the Worker and again in the code that starts the Workflow Execution. 
To ensure that the same name is used in both places, this project follows the recommended practice of specifying the Task Queue name in a constant referenced from both places.

### Set Your Task Queue Name

To ensure your Worker and Workflow starter use the same queue, define the Task Queue name as a constant:

<SdkTabs languageOrder={TUTORIAL_LANGUAGE_ORDER}>
<SdkTabs.Python>

**shared.py**

```python
# Task Queue name - used by both Worker and Workflow starter
MONEY_TRANSFER_TASK_QUEUE_NAME = "MONEY_TRANSFER_TASK_QUEUE"
```

</SdkTabs.Python>

<SdkTabs.Go>

**app/shared.go**

```go
package app

// MoneyTransferTaskQueueName is the task queue name used by both
// the Worker and the Workflow starter
const MoneyTransferTaskQueueName = "MONEY_TRANSFER_TASK_QUEUE"
```

</SdkTabs.Go>

<SdkTabs.Java>

**src/main/java/moneytransfer/Shared.java**

```java
package moneytransferapp;

public class Shared {
    // Task Queue name used by both Worker and Workflow starter
    public static final String MONEY_TRANSFER_TASK_QUEUE = "MONEY_TRANSFER_TASK_QUEUE";
}
```

</SdkTabs.Java>

<SdkTabs.TypeScript>

**src/shared.ts**

```typescript
// Task Queue name - used by both Worker and Workflow starter
export const taskQueueName = 'MONEY_TRANSFER_TASK_QUEUE';
export const namespace = 'default';
```

</SdkTabs.TypeScript>

<SdkTabs.DotNet>

**Shared/Constants.cs**

```csharp
namespace MoneyTransferProject.Shared
{
    public static class Constants
    {
        // Task Queue name used by both Worker and Workflow starter
        public const string MONEY_TRANSFER_TASK_QUEUE = "MONEY_TRANSFER_TASK_QUEUE";
    }
}
```

</SdkTabs.DotNet>

<SdkTabs.Ruby>

**shared.rb**

```ruby
module MoneyTransfer
  # Task Queue name used by both Worker and Workflow starter
  TASK_QUEUE_NAME = "MONEY_TRANSFER_TASK_QUEUE".freeze
end
```

</SdkTabs.Ruby>

</SdkTabs>

:::tip Why Use Constants?
Using a shared constant prevents typos that would cause your Worker to listen to a different Task Queue than where your Workflow tasks are being sent. It's a common source of "Why isn't my Workflow running?" issues.
:::

## Step 5: Execute the Workflow

Now you'll create a client program that starts a Workflow execution. This code connects to the Temporal Service and submits a Workflow execution request:

<SdkTabs languageOrder={TUTORIAL_LANGUAGE_ORDER}>
<SdkTabs.Python>

**start_workflow.py**

```python
import asyncio
from temporalio.client import Client
from workflows import MoneyTransfer
from shared import MONEY_TRANSFER_TASK_QUEUE_NAME

async def main():
    # Create the Temporal Client to connect to the Temporal Service
    client = await Client.connect("localhost:7233", namespace="default")
    
    # Define the money transfer details
    details = {
        "source_account": "A1001",
        "target_account": "B2002", 
        "amount": 100,
        "reference_id": "12345"
    }
    
    # Start the Workflow execution
    handle = await client.start_workflow(
        MoneyTransfer.run,
        details,
        id=f"money-transfer-{details['reference_id']}",
        task_queue=MONEY_TRANSFER_TASK_QUEUE_NAME,
    )
    
    print(f"Started Workflow {handle.id}")
    print(f"Transferring ${details['amount']} from {details['source_account']} to {details['target_account']}")
    
    # Wait for the result
    result = await handle.result()
    print(f"Workflow result: {result}")

if __name__ == "__main__":
    asyncio.run(main())
```

</SdkTabs.Python>

<SdkTabs.Go>

**start/main.go**

```go
func main() {
    // Create the client object just once per process
    c, err := client.Dial(client.Options{})
    if err != nil {
        log.Fatalln("Unable to create Temporal client:", err)
    }
    defer c.Close()

    input := app.PaymentDetails{
        SourceAccount: "85-150",
        TargetAccount: "43-812",
        Amount:        250,
        ReferenceID:   "12345",
    }

    options := client.StartWorkflowOptions{
        ID:        "pay-invoice-701",
        TaskQueue: app.MoneyTransferTaskQueueName,
    }

    log.Printf("Starting transfer from account %s to account %s for %d", 
               input.SourceAccount, input.TargetAccount, input.Amount)

    we, err := c.ExecuteWorkflow(context.Background(), options, app.MoneyTransfer, input)
    if err != nil {
        log.Fatalln("Unable to start the Workflow:", err)
    }

    log.Printf("WorkflowID: %s RunID: %s\n", we.GetID(), we.GetRunID())

    var result string
    err = we.Get(context.Background(), &result)
    if err != nil {
        log.Fatalln("Unable to get Workflow result:", err)
    }

    log.Println(result)
}
```

</SdkTabs.Go>

<SdkTabs.Java>

**src/main/java/moneytransfer/TransferApp.java**

```java
public class TransferApp {
    public static void main(String[] args) throws Exception {
        // A WorkflowServiceStubs communicates with the Temporal front-end service.
        WorkflowServiceStubs serviceStub = WorkflowServiceStubs.newLocalServiceStubs();

        // A WorkflowClient wraps the stub and can be used to start, signal, query, cancel, and terminate Workflows.
        WorkflowClient client = WorkflowClient.newInstance(serviceStub);

        // Workflow options configure Workflow stubs.
        // A WorkflowId prevents duplicate instances.
        WorkflowOptions options = WorkflowOptions.newBuilder()
                .setTaskQueue(Shared.MONEY_TRANSFER_TASK_QUEUE)
                .setWorkflowId("money-transfer-workflow")
                .build();

        // WorkflowStubs enable calls to methods as if the Workflow object is local
        // but actually perform a gRPC call to the Temporal Service.
        MoneyTransferWorkflow workflow = client.newWorkflowStub(MoneyTransferWorkflow.class, options);
        
        // Configure the details for this money transfer request
        String referenceId = UUID.randomUUID().toString().substring(0, 18);
        String fromAccount = "A1001";
        String toAccount = "B2002";
        int amountToTransfer = 100;
        TransactionDetails transaction = new CoreTransactionDetails(fromAccount, toAccount, referenceId, amountToTransfer);

        // Perform asynchronous execution
        WorkflowExecution we = WorkflowClient.start(workflow::transfer, transaction);

        System.out.printf("Initiating transfer of $%d from [Account %s] to [Account %s].\n",
                          amountToTransfer, fromAccount, toAccount);
        System.out.printf("[WorkflowID: %s] [RunID: %s] [Reference: %s]\n", 
                          we.getWorkflowId(), we.getRunId(), referenceId);
    }
}
```

</SdkTabs.Java>

<SdkTabs.TypeScript>

**src/client.ts**

```typescript
import { Connection, Client } from '@temporalio/client';
import { moneyTransfer } from './workflows';
import type { PaymentDetails } from './shared';
import { namespace, taskQueueName } from './shared';

async function run() {
  const connection = await Connection.connect();
  const client = new Client({ connection, namespace });

  const details: PaymentDetails = {
    amount: 400,
    sourceAccount: '85-150',
    targetAccount: '43-812',
    referenceId: '12345',
  };

  console.log(
    `Starting transfer from account ${details.sourceAccount} to account ${details.targetAccount} for $${details.amount}`
  );

  const handle = await client.workflow.start(moneyTransfer, {
    args: [details],
    taskQueue: taskQueueName,
    workflowId: 'pay-invoice-801',
  });

  console.log(
    `Started Workflow ${handle.workflowId} with RunID ${handle.firstExecutionRunId}`
  );
  console.log(await handle.result());
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
```

</SdkTabs.TypeScript>

<SdkTabs.DotNet>

**MoneyTransferStarter/Program.cs**

```csharp
using Temporalio.Client;
using Temporalio.MoneyTransferProject.MoneyTransferWorker;

// Create a client to connect to localhost on "default" namespace
var client = await TemporalClient.ConnectAsync(new("localhost:7233"));

// Configure the money transfer details
var transferDetails = new TransferDetails
{
    SourceAccount = "A1001",
    TargetAccount = "B2002", 
    Amount = 100,
    ReferenceId = "12345"
};

Console.WriteLine($"Starting transfer of ${transferDetails.Amount} from {transferDetails.SourceAccount} to {transferDetails.TargetAccount}");

// Start the workflow
var handle = await client.StartWorkflowAsync(
    (MoneyTransferWorkflow wf) => wf.RunAsync(transferDetails),
    new(id: $"money-transfer-{transferDetails.ReferenceId}", taskQueue: "MONEY_TRANSFER_TASK_QUEUE"));

Console.WriteLine($"Started workflow {handle.Id}");

// Wait for result
var result = await handle.GetResultAsync();
Console.WriteLine($"Workflow result: {result}");
```

</SdkTabs.DotNet>

<SdkTabs.Ruby>

**starter.rb**

```ruby
require_relative 'shared'
require_relative 'workflow'
require 'securerandom'
require 'temporalio/client'

# Create the Temporal Client that connects to the Temporal Service
client = Temporalio::Client.connect('localhost:7233', 'default')

# Default values for the payment details
details = MoneyTransfer::TransferDetails.new('A1001', 'B2002', 100, SecureRandom.uuid)

# Use the Temporal Client to submit a Workflow Execution request
handle = client.start_workflow(
  MoneyTransfer::MoneyTransferWorkflow,
  details,
  id: "moneytransfer-#{details.reference_id}",
  task_queue: MoneyTransfer::TASK_QUEUE_NAME
)

puts "Initiated transfer of $#{details.amount} from #{details.source_account} to #{details.target_account}"
puts "Workflow ID: #{handle.id}"

# Keep running (and retry) if the Temporal Service becomes unavailable
begin
  puts "Workflow result: #{handle.result}"
rescue Temporalio::Error::RPCError
  puts 'Temporal Service unavailable while awaiting result'
  retry
end
```

</SdkTabs.Ruby>

</SdkTabs>

This code uses a Temporal Client to connect to the Temporal Service, calling its workflow start method to request execution. This returns a handle, and calling result on that handle will block until execution is complete, at which point it provides the result.

## Run Your Money Transfer

<SetupStep code={
  <div>
    <div style={{marginBottom: '1rem'}}>
      <strong>Terminal 1 - Start the Temporal server:</strong>
      <CodeSnippet language="bash">
temporal server start-dev
      </CodeSnippet>
    </div>
    <div style={{marginBottom: '1rem'}}>
      <strong>Terminal 2 - Start the Worker:</strong>
      <CodeSnippet language="bash">
python run_worker.py
      </CodeSnippet>
    </div>
    <div style={{marginBottom: '1rem'}}>
      <strong>Terminal 3 - Start the Workflow:</strong>
      <CodeSnippet language="bash">
python run_workflow.py
      </CodeSnippet>
    </div>
    <div style={{marginTop: '2rem', padding: '1rem', background: 'rgba(16, 185, 129, 0.1)', borderRadius: '0.5rem'}}>
      <strong> Expected Success Output: 
      
      </strong>
      <CodeSnippet language="text">
Result: Transfer complete (transaction IDs: Withdrew $250 from account 85-150. ReferenceId: 12345, Deposited $250 into account 43-812. ReferenceId: 12345)

      </CodeSnippet>
    </div>
  </div>
}>

Now that your Worker is running and polling for tasks, you can start a Workflow Execution.

**In Terminal 3, start the Workflow:**

The `run_workflow.py` script starts a Workflow Execution. Each time you run this file, the Temporal Server starts a new Workflow Execution.

<StatusIndicators items={[
  { id: 'workflow', label: 'Workflow Status', value: 'EXECUTING', status: 'running' },
  { id: 'withdraw', label: 'Withdraw Activity', value: 'RUNNING', status: 'running' },
  { id: 'deposit', label: 'Deposit Activity', value: 'RUNNING', status: 'running' },
  { id: 'transaction', label: 'Transaction', value: 'COMPLETED', status: 'success' }
]} />

</SetupStep>

## Check the Temporal Web UI

<SetupStep code={
  <CallToAction 
    href="http://localhost:8233"
    buttonText="Open the Temporal UI "
    description="View the state of the Workflow with the Temporal Web UI"
  />
}>

The Temporal Web UI lets you see details about the Workflow you just ran.

**What you'll see in the UI:**
- List of Workflows with their execution status
- Workflow summary with input and result
- History tab showing all events in chronological order
- Query, Signal, and Update capabilities
- Stack Trace tab for debugging

**Try This:** Click on a Workflow in the list to see all the details of the Workflow Execution.



</SetupStep>

<div style={{textAlign: 'center', margin: '2rem 0'}}>
  <img src="/img/moneytransfer/webuisample.png" alt="Money Transfer Web UI " style={{maxWidth: '100%', height: 'auto'}} />
</div>

## Ready for Part 2?

<NextButton 
  href="/build-your-first-basic-workflow/failure-simulation" 
  description="Simulate crashes, fix bugs in running workflows, and experience Temporal's reliability superpowers"
>
  Continue to Part 2: Simulate Failures
</NextButton>

---
id: namespaces
title: Namespaces
sidebar_label: Namespaces
description: Namespaces are a logical unit of isolation within the Temporal Platform.
toc_max_heading_level: 4
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

Namespaces are a logical unit of isolation within the Temporal Platform.

A Namespace is a unit of isolation within the Temporal Platform.

- [How to register a new Namespace using tctl](/tctl/namespace/register)
- [How to list Namespaces in a Cluster using tctl](/tctl/namespace/list)
- [How to view (describe) Namespace metadata and details using tctl](/tctl/namespace/describe)
- [How to set the Namespace for a Temporal Client in Go](/go/how-to-set-the-namespace-for-a-temporal-client-in-go)
- [How to set the Namespace for a Temporal Client in Java](/java/how-to-set-the-namespace-for-a-temporal-client-in-java)
- [How to set the Namespace for a Temporal Client in Typescript](/typescript/how-to-set-the-namespace-for-a-temporal-client-in-typescript)

A single Namespace is still multi-tenant.
You can use Namespaces to match the development lifecycle; for example, having separate `dev` and `prod` Namespaces.
Or you could use them to ensure Workflow Executions between different teams never communicate; such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.

- If no other Namespace is specified, the Temporal Cluster uses the Namespace "default" for all Temporal SDKs and tctl.
  - If you are deploying through Docker Compose or using the [auto-setup image](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) in a custom Docker Compose application, the Namespace "default" is created, through the auto-setup script.
  - If you are deploying through the [Temporal Helm charts](https://github.com/temporalio/helm-charts), you can create the "default" Namespace by using tctl; for example, `tctl namespace default`.
    We recommend using the default Namespace if you arenâ€™t using multiple Namespaces.
- **Case Insensitive**: Because of DNS, Namespaces are case insensitive on the network and routing side.
  We recommend using lowercase for namespace names to avoid potential issues.
- **Membership**: [Task Queue](/tasks/#task-queues) names and [Workflow Ids](/workflows/#workflow-id) must all correspond to a specific Namespace.
  For example, when a Workflow Execution is spawned, it does so within a specific Namespace.
- **Uniqueness**: Temporal guarantees a unique Workflow Id within a Namespace.
  Workflow Executions may have the same Workflow Id if they are in different Namespaces.
- **Namespace Configuration**: Various configuration options like the retention period and the [Archival](/clusters/#archival) destination are configured per Namespace through a special CRUD API or through [`tctl`](/tctl).

## Global Namespace

A Global Namespace is a [Namespace](#) that exists across Clusters when [Multi-Cluster Replication](/clusters/#multi-cluster-replication) is set up.

- [How to register a Global Namespace](/tctl/namespace/register/#--global-namespace)
- [How to change the active Cluster for a Global Namespace](/tctl/namespace/update/#--active-cluster)

The Global Namespace feature enables Workflow Executions to progress through another Cluster in the event of a failover.

A Global Namespace may be replicated to any number of Clusters, but is active in only one Cluster at any given time.

For a failover to be successful, Worker Processes must be polling for Tasks for the Global Namespace on all Clusters.

A Global Namespace has a failover version.
Because a failover can be triggered from any Cluster, the failover version prevents certain conflicts from occurring if a failover is mistakenly triggered simultaneously on two Clusters.

Only the active Cluster dispatches [Tasks](/tasks/#); however, certain conflicts are possible.
Unlike regular Namespaces, which provide at-most-once semantics for an Activity Execution, Global Namespaces can support only at-least-once semantics (see [Conflict resolution](/concepts/what-is-multi-cluster-replication/#conflict-resolution)).
Worker Processes on the standby Clusters are idle until a failover occurs and their Cluster becomes active.

Temporal Application API calls made to a non-active Cluster are rejected with a **NamespaceNotActiveError** which contains the name of the current active Cluster.
It is the responsibility of the Temporal Application to call the Cluster that is currently active.

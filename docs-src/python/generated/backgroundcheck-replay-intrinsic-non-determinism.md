---
id: backgroundcheck-replay-intrinsic-non-determinism
title: Intrinsic non-deterministic logic
sidebar_label: intrinsic-non-deterministic-logic
description: This kind of logic prevents the Workflow code from executing to completion because the Workflow can take a different code path than the one expected from the Event History.
tags:
- tests
- replay
- event history
---

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-python/blob/replay-tests/backgroundcheck_replay/backgroundcheck_non_deterministic_code_dacx.py. -->

Referred to as "intrinsic non-determinism" this kind of "bad" Workflow code can prevent the Workflow code from completing because the Workflow can take a different code path than the one expected from the Event History.

The following are some common operations that **can't** be done inside of a Workflow Definition:

- Generate and rely on random numbers.
  - Use `workflow.random()` as a replacement for `randint()`
- Accessing / mutating external systems or state.
  This includes calling an external API, conducting a file I/O operation, talking to another service, etc. (use Activities instead).
- Relying on system time.
  - Use [workflow.now()](https://python.temporal.io/temporalio.workflow.html#now) as a replacement for `time.now()`.
  - Workflows are backed by custom https://docs.python.org/3/library/asyncio.html event loop. Meaning that many common `asyncio` calls works as expected.
    - Use `asyncio.sleep()`.
- Iterating over data structures with unknown ordering.
  This includes iterating over maps using `range`, because with `range` the order of the map's iteration is randomized.
  Instead you can collect the keys of the map, sort them, and then iterate over the sorted keys to access the map.
  This technique provides deterministic results.
  You can also use a Side Effect or an Activity to process the map instead.
- Storing or evaluating the run Id.

If a Workflow Execution performs a non-deterministic event, an exception is thrown, which results in failing the Task Worker.

The Workflow will not progress until the code is fixed.

For example, if you try to produce a non-deterministic error by using a random number to sleep inside the Workflow, you'll receive the following Restricted Workflow Access Error:

```python
temporalio.worker.workflow_sandbox._restrictions.RestrictedWorkflowAccessError:
```

From the following example code:

<div class="copycode-notice-container"><div class="copycode-notice"><img data-style="copycode-icon" src="/icons/copycode.png" alt="Copy code icon" /> Sample application code information <img id="i-f8f6f12f-47f3-4c47-97b3-b72574fda335" data-event="clickable-copycode-info" data-style="chevron-icon" src="/icons/chevron.png" alt="Chevron icon" /></div><div id="copycode-info-f8f6f12f-47f3-4c47-97b3-b72574fda335" class="copycode-info">The following code sample comes from a working and tested sample application. The code sample might be abridged within the guide to highlight key aspects. Visit the source repository to <a href="https://github.com/temporalio/documentation-samples-python/blob/replay-tests/backgroundcheck_replay/backgroundcheck_non_deterministic_code_dacx.py">view the source code</a> in the context of the rest of the application code.</div></div>

```python
import asyncio
from datetime import timedelta

from temporalio import workflow

with workflow.unsafe.imports_passed_through():
    from random import randint
    from ssntraceactivity import ssn_trace_activity



@workflow.defn()
class BackgroundCheckNonDeterministic:
    @workflow.run
    async def run(self, ssn: str) -> str:
        random_number = randint(1, 100)
        if random_number < 50:
            await asyncio.sleep(60)
            workflow.logger.info("Sleeping for 60 seconds")
        return await workflow.execute_activity(
            ssn_trace_activity,
            ssn,
            schedule_to_close_timeout=timedelta(seconds=5),
        )
```

{"cfgs":[{"file_name":"cluster-deployment-guide.md","id":"cluster-deployment-guide","file_dir":"/","title":"Temporal Cluster deployment guide","sidebar_label":"Cluster deployment","description":"This guide provides a comprehensive overview to deploy and operate a Temporal Cluster in a live environment.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":false,"sections":[{"type":"p","id":"cluster-ops-context/intro","node":{"file_name":"intro.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cluster-ops-context/intro.md","id":"cluster-ops-context/intro","title":"How to deploy a Temporal Cluster","description":"This guide is a work in progress","label":"Deploy a Temporal Cluster","tags":["guide-context"],"markdown_content":":::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete.\nInformation may change at any time.\n\nLegacy production deployment information is available [here](/server/production-deployment)\n\n:::","is_empty":false}},{"type":"h2","id":"clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster","node":{"file_name":"how-to-integrate-elasticsearch-into-a-temporal-cluster.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster.md","id":"clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster","title":"How to integrate Elasticsearch into a Temporal Cluster","description":"To integrate Elasticsearch with your Temporal Cluster, edit the `persistence` section of your `development.yaml` configuration file and run the index schema setup commands.","label":"Elasticsearch","tags":["operation-guide","filtered-lists","visibility"],"markdown_content":"[Advanced Visibility](/visibility#advanced-visibility) features depend on an integration with Elasticsearch.\n\nTo integrate Elasticsearch with your Temporal Cluster, edit the `persistence` section of your `development.yaml` configuration file and run the index schema setup commands.\n\n:::note\n\nThese steps are needed only if you have a \"plain\" [Temporal Server Docker image](https://hub.docker.com/r/temporalio/server).\n\nIf you operate a Temporal Cluster using our [Helm charts](https://github.com/temporalio/helm-charts) or\n[docker-compose](https://github.com/temporalio/docker-compose), the Elasticsearch index schema and index are created automatically using the [auto-setup Docker image](https://hub.docker.com/r/temporalio/auto-setup).\n\n:::\n\n:::note Supported versions\n\n- Elasticsearch v7.10 is supported from Temporal version 1.7.0 onwards\n- Elasticsearch v6.8 is supported in all Temporal versions\n- Both versions are explicitly supported with AWS Elasticsearch\n\n:::\n\n#### Edit persistence\n\n1. Add the `advancedVisibilityStore: es-visibility` key-value pair to the `persistence` section.\n   The [development_es.yaml](https://github.com/temporalio/temporal/blob/master/config/development_es.yaml) file in the `temporalio/temporal` repo is a working example.\n   The configuration instructs the Temporal Cluster how and where to connect to Elasticsearch storage.\n\n```yaml\npersistence:\n  ...\n  advancedVisibilityStore: es-visibility\n```\n\n2. Define the Elasticsearch datastore connection information under the `es-visibility` key:\n\n```yaml\npersistence:\n  ...\n  advancedVisibilityStore: es-visibility\n  datastores:\n    ...\n    es-visibility:\n      elasticsearch:\n        version: \"v7\"\n        url:\n          scheme: \"http\"\n          host: \"127.0.0.1:9200\"\n        indices:\n          visibility: temporal_visibility_v1_dev\n```\n\n#### Create index schema and index\n\nRun the following commands to create the index schema and index:\n\n```bash\n# ES_SERVER is the URL of Elasticsearch server; for example, \"http://localhost:9200\".\nSETTINGS_URL=\"${ES_SERVER}/_cluster/settings\"\nSETTINGS_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/cluster_settings_${ES_VERSION}.json\nTEMPLATE_URL=\"${ES_SERVER}/_template/temporal_visibility_v1_template\"\nSCHEMA_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/index_template_${ES_VERSION}.json\nINDEX_URL=\"${ES_SERVER}/${ES_VIS_INDEX}\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SETTINGS_URL}\" -H \"Content-Type: application/json\" --data-binary \"@${SETTINGS_FILE}\" --write-out \"\\n\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${TEMPLATE_URL}\" -H 'Content-Type: application/json' --data-binary \"@${SCHEMA_FILE}\" --write-out \"\\n\"\ncurl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${INDEX_URL}\" --write-out \"\\n\"\n```\n\n#### Set Elasticsearch privileges\n\nEnsure that the following privileges are granted for the Elasticsearch Temporal index:\n\n- **Read**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `create`, `index`, `delete`, `read`\n- **Write**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `write`\n- **Custom Search Attributes**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `manage`\n  - [cluster privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-cluster): `monitor` or `manage`.\n\n#### Add custom Search Attributes (optional)\n\nThis step is optional.\nHere we are adding custom Search Attributes to your Cluster.\n\nRun the following `tctl` command to add the `ProductId` custom Search Attribute to the Temporal Cluster (and Elasticsearch Temporal index):\n\n```bash\ntctl admin cluster add-search-attributes --name ProductId --type Keyword\n```\n\nRun the following `tctl` command to add custom Search Attributes used by samples and SDK integration tests:\n\n```bash\ntctl --auto_confirm admin cluster add-search-attributes \\\n    --name CustomKeywordField --type Keyword \\\n    --name CustomStringField --type Text \\\n    --name CustomTextField --type Text \\\n    --name CustomIntField --type Int \\\n    --name CustomDatetimeField --type Datetime \\\n    --name CustomDoubleField --type Double \\\n    --name CustomBoolField --type Bool\n```","is_empty":false}},{"type":"h2","id":"cluster-ops-context/archival","node":{"file_name":"archival.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cluster-ops-context/archival.md","id":"cluster-ops-context/archival","title":"How to use Archival","description":"Archival is a feature that automatically backs up Workflow Execution Event Histories and Visibility data from Temporal Cluster persistence to a custom blob store.","label":"Archival","tags":["guide-context"],"markdown_content":"[Archival](/clusters#archival) is a feature that automatically backs up Workflow Execution Event Histories and Visibility data from Temporal Cluster persistence to a custom blob store.","is_empty":false}},{"type":"h3","id":"clusters/how-to-set-up-archival","node":{"file_name":"how-to-set-up-archival.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/clusters/how-to-set-up-archival.md","id":"clusters/how-to-set-up-archival","title":"How to set up Archival","description":"This guide covers Temporal's archiving capabilities and how to set up the Archival feature.","label":"Set up Archival","tags":["how-to"],"markdown_content":"[Archival](/clusters#archival) consists of the following elements:\n\n- **Configuration**: Archival is controlled by the [server configuration](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L81) (i.e. the `config/development.yaml` file).\n- **Provider**: Location where the data should be archived. Supported providers are S3, GCloud, and the local file system.\n- **URI**: Specifies which provider should be used. The system uses the URI schema and path to make the determination.\n\nTake the following steps to set up Archival:\n\n1. [Set up the provider](#providers) of your choice.\n2. [Configure Archival](#configuration).\n3. [Create a Namespace](#namespace-creation) that uses a valid URI and has Archival enabled.\n\n#### Providers\n\nTemporal directly supports several providers:\n\n- **Local file system**: The [filestore archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) is used to archive data in the file system of whatever host the Temporal server is running on. This provider is used mainly for local installations and testing and should not be relied on for production environments.\n- **Google Cloud**: The [gcloud archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud) is used to connect and archive data with [Google Cloud](https://cloud.google.com/storage).\n- **S3**: The [s3store archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store) is used to connect and archive data with [S3](https://aws.amazon.com/s3).\n- **Custom**: If you want to use a provider that is not currently supported, you can [create your own archiver](#custom-archiver) to support it.\n\nMake sure that you save the provider's storage location URI in a place where you can reference it later, because it is passed as a parameter when you [create a Namespace](#namespace-creation).\n\n#### Configuration\n\nArchival configuration is defined in the [`config/development.yaml`](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L93) file.\nLet's look at an example configuration:\n\n```yaml\n# Cluster level Archival config\narchival:\n  # Event History configuration\n  history:\n    # Archival is enabled at the cluster level\n    state: \"enabled\"\n    enableRead: true\n    # Namespaces can use either the local filestore provider or the Google Cloud provider\n    provider:\n      filestore:\n        fileMode: \"0666\"\n        dirMode: \"0766\"\n      gstorage:\n        credentialsPath: \"/tmp/gcloud/keyfile.json\"\n\n# Default values for a Namespace if none are provided at creation\nnamespaceDefaults:\n  # Archival defaults\n  archival:\n    # Event History defaults\n    history:\n      state: \"enabled\"\n      # New Namespaces will default to the local provider\n      URI: \"file:///tmp/temporal_archival/development\"\n```\n\nYou can disable Archival by setting `archival.history.state` and `namespaceDefaults.archival.history.state` to `\"disabled\"`.\n\nExample:\n\n```yaml\narchival:\n  history:\n    state: \"disabled\"\n\nnamespaceDefaults:\n  archival:\n    history:\n      state: \"disabled\"\n```\n\nThe following table showcases acceptable values for each configuration and what purpose they serve.\n\n| Config                                         | Acceptable values                                                                  | Description                                                                                                                  |\n| ---------------------------------------------- | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\n| `archival.history.state`                       | `enabled`, `disabled`                                                              | Must be `enabled` to use the Archival feature with any Namespace in the cluster.                                             |\n| `archival.history.enableRead`                  | `true`, `false`                                                                    | Must be `true` to read from the archived Event History.                                                                      |\n| `archival.history.provider`                    | Sub provider configs are `filestore`, `gstorage`, `s3`, or `your_custom_provider`. | Default config specifies `filestore`.                                                                                        |\n| `archival.history.provider.filestore.fileMode` | File permission string                                                             | File permissions of the archived files. We recommend using the default value of `\"0666\"` to avoid read/write issues.         |\n| `archival.history.provider.filestore.dirMode`  | File permission string                                                             | Directory permissions of the archive directory. We recommend using the default value of `\"0766\"` to avoid read/write issues. |\n| `namespaceDefaults.archival.history.state`     | `enabled`, `disabled`                                                              | Default state of the Archival feature whenever a new Namespace is created without specifying the Archival state.             |\n| `namespaceDefaults.archival.history.URI`       | Valid URI                                                                          | Must be a URI of the file store location and match a schema that correlates to a provider.                                   |\n\n#### Namespace creation\n\nAlthough Archival is configured at the cluster level, it operates independently within each Namespace.\nIf an Archival URI is not specified when a Namespace is created, the Namespace uses the value of `defaultNamespace.archival.history.URI` from the `config/development.yaml` file.\nThe Archival URI cannot be changed after the Namespace is created.\nEach Namespace supports only a single Archival URI, but each Namespace can use a different URI.\nA Namespace can safely switch Archival between `enabled` and `disabled` states as long as Archival is enabled at the cluster level.\n\nArchival is supported in [Global Namespaces](/concepts/what-is-a-global-namespace/) (Namespaces that span multiple clusters).\nWhen Archival is running in a Global Namespace, it first runs on the active cluster; later it runs on the standby cluster. Before archiving, a history check is done to see what has been previously archived.\n\n#### Test setup\n\nTo test Archival locally, start by running a Temporal server:\n\n```bash\n./temporal-server start\n```\n\nThen register a new Namespace with Archival enabled.\n\n```bash\n./tctl --ns samples-namespace namespace register --gd false --history_archival_state enabled --retention 3\n```\n\n:::note\n\nIf the retention period isn't set, it defaults to 2 days.\nThe minimum retention period is 1 day.\nThe maximum retention period is 30 days.\n\nSetting the retention period to 0 results in the error _A valid retention period is not set on request_.\n\n:::\n\nNext, run a sample Workflow such as the [helloworld temporal sample](https://github.com/temporalio/temporal-go-samples/tree/master/helloworld).\n\nWhen execution is finished, Archival occurs.\n\n#### Retrieve archives\n\nYou can retrieve archived Event Histories by copying the `workflowId` and `runId` of the completed Workflow from the log output and running the following command:\n\n```bash\n./temporal --ns samples-namespace wf show --wid <workflowId> --rid <runId>\n```","is_empty":false}},{"type":"h3","id":"clusters/how-to-create-a-custom-archiver","node":{"file_name":"how-to-create-a-custom-archiver.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/clusters/how-to-create-a-custom-archiver.md","id":"clusters/how-to-create-a-custom-archiver","title":"How to create a custom Archiver","description":"todo","label":"Custom Archiver","tags":["how-to"],"markdown_content":"To archive data with a given provider, using the [Archival](/clusters#archival) feature, Temporal must have a corresponding Archiver component installed.\nThe platform does not limit you to the existing providers.\nTo use a provider that is not currently supported, you can create your own Archiver.\n\n#### Create a new package\n\nThe first step is to create a new package for your implementation in [/common/archiver](https://github.com/temporalio/temporal/tree/master/common/archiver).\nCreate a directory in the archiver folder and arrange the structure to look like the following:\n\n```\ntemporal/common/archiver\n  - filestore/                      -- Filestore implementation\n  - provider/\n      - provider.go                 -- Provider of archiver instances\n  - yourImplementation/\n      - historyArchiver.go          -- HistoryArchiver implementation\n      - historyArchiver_test.go     -- Unit tests for HistoryArchiver\n      - visibilityArchiver.go       -- VisibilityArchiver implementations\n      - visibilityArchiver_test.go  -- Unit tests for VisibilityArchiver\n```\n\n#### Archiver interfaces\n\nNext, define objects that implement the [HistoryArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L80) and the [VisibilityArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L121) interfaces.\n\nThe objects should live in `historyArchiver.go` and `visibilityArchiver.go`, respectively.\n\n#### Update provider\n\nUpdate the `GetHistoryArchiver` and `GetVisibilityArchiver` methods of the `archiverProvider` object in the [/common/archiver/provider/provider.go](https://github.com/temporalio/temporal/blob/master/common/archiver/provider/provider.go) file so that it knows how to create an instance of your archiver.\n\n#### Add configs\n\nAdd configs for your archiver to the `config/development.yaml` file and then modify the [HistoryArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L376) and [VisibilityArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L393) structs in `/common/common/config.go` accordingly.\n\n#### Custom archiver FAQ\n\n**If my custom Archive method can automatically be retried by the caller, how can I record and access progress between retries?**\n\nHandle this situation by using `ArchiverOptions`.\nHere is an example:\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n    var progress progress\n    // Check if the feature for recording progress is enabled.\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.LoadProgress(ctx, & prevProgress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n\n    // Your archiver implementation...\n\n    // Record current progress\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.RecordProgress(ctx, progress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n}\n```\n\n**If my `Archive` method encounters an error that is non-retryable, how do I indicate to the caller that it should not retry?**\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n\n    err: = youArchiverImpl()\n\n    if nonRetryableErr(err) {\n        if featureCatalog.NonRetryableError != nil {\n            return featureCatalog.NonRetryableError() // when the caller gets this error type back it will not retry anymore.\n        }\n    }\n}\n```\n\n**How does my history archiver implementation read history?**\n\nThe archiver package provides a utility called [HistoryIterator](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) which is a wrapper of [ExecutionManager](https://github.com/temporalio/temporal/blob/master/common/persistence/dataInterfaces.go#L1014).\n`HistoryIterator` is more simple than the `HistoryManager`, which is available in the BootstrapContainer, so archiver implementations can choose to use it when reading Workflow histories.\nSee the [historyIterator.go](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) file for more details.\nUse the [filestore historyArchiver implementation](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) as an example.\n\n**Should my archiver define its own error types?**\n\nEach archiver is free to define and return its own errors.\nHowever, many common errors that exist between archivers are already defined in [common/archiver/constants.go](https://github.com/temporalio/temporal/blob/master/common/archiver/constants.go).\n\n**Is there a generic query syntax for the visibility archiver?**\n\nCurrently, no.\nBut this is something we plan to do in the future.\nAs for now, try to make your syntax similar to the one used by our advanced list Workflow API.\n\n- [s3store](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store#visibility-query-syntax)\n- [gcloud](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud#visibility-query-syntax)","is_empty":false}},{"type":"h2","id":"clusters/how-to-upgrade-the-temporal-server-version","node":{"file_name":"how-to-upgrade-the-temporal-server-version.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/clusters/how-to-upgrade-the-temporal-server-version.md","id":"clusters/how-to-upgrade-the-temporal-server-version","title":"How to upgrade the Temporal Server version","description":"If a newer version of the Temporal Server is available, a notification appears in the Temporal Web UI.","label":"Upgrade Server","tags":["how-to"],"markdown_content":"If a newer version of the [Temporal Server](/clusters#temporal-server) is available, a notification appears in the Temporal Web UI.\n\n:::info\n\nIf you are using a version that is older than 1.0.0, reach out to us at [community.temporal.io](http://community.temporal.io) to ask how to upgrade.\n\n:::\n\nFirst check to see if an upgrade to the database schema is required for the version you wish to upgrade to.\nIf a database schema upgrade is required, it will be called out directly in the [release notes](https://github.com/temporalio/temporal/releases).\nSome releases require changes to the schema, and some do not.\nWe ensure that any consecutive versions are compatible in terms of database schema upgrades, features, and system behavior, however there is no guarantee that there is compatibility between _any_ 2 non-consecutive versions.\n\nUse one of the upgrade tools to upgrade your database schema to be compatible with the Temporal Server version being upgraded to.\n\nIf you are using a schema tools version prior to 1.8.0, we strongly recommend _never_ using the \"dryrun\" (`-y`, or `--dryrun`) options in any of your schema update commands.\nUsing this option might lead to potential loss of data, as when using it will create a new database and drop your\nexisting one.\nThis flag was removed in the 1.8.0 release.\n\n### Upgrade Cassandra schema\n\nIf you are using Cassandra for your Cluster's persistence, use the `temporal-cassandra-tool` to upgrade both the default and visibility schemas.\n\n**Example default schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/temporal/versioned\n\n```\n\n**Example visibility schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal_visibility \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/visibility/versioned\n\n```\n\n### Upgrade MySQL / PostgreSQL schema\n\nIf you are using MySQL or PostgreSQL use the `temporal-sql-tool`, which works similarly to the `temporal-cassandra-tool`.\n\nRefer to this [Makefile](https://github.com/temporalio/temporal/blob/v1.4.1/Makefile#L367-L383) for context.\n\n#### PostgreSQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal update-schema -d ./schema/postgresql/v96/temporal/versioned\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal_visibility update-schema -d ./schema/postgresql/v96/visibility/versioned\n```\n\n#### MySQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal update-schema -d ./schema/mysql/v57/temporal/versioned/\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal_visibility update-schema -d ./schema/mysql/v57/visibility/versioned/\n```\n\n### Roll-out technique\n\nWe recommend preparing a staging Cluster and then do the following to verify the upgrade is successful:\n\n1. Create some simulation load on the staging cluster.\n2. Upgrade the database schema in the staging cluster.\n3. Wait and observe for a few minutes to verify that there is no unstable behavior from both the server and the simulation load logic.\n4. Upgrade the server.\n5. Now do the same to the live environment cluster.","is_empty":false}},{"type":"h2","id":"clusters/how-to-set-up-multi-cluster-replication","node":{"file_name":"how-to-set-up-multi-cluster-replication.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/clusters/how-to-set-up-multi-cluster-replication.md","id":"clusters/how-to-set-up-multi-cluster-replication","title":"How to set up Multi-Cluster Replication","description":"Multi-Cluster Replication can be enabled by setting the appropriate values in the `clusterMetadata` section of your configuration file.","label":"Set up Multi-Cluster Replication","tags":["how-to","cluster"],"markdown_content":"The [Multi-Cluster Replication](/clusters#multi-cluster-replication) feature asynchronously replicates Workflow Execution Event Histories from active Clusters to other passive Clusters, and can be enabled by setting the appropriate values in the `clusterMetadata` section of your configuration file.\n\n1. `enableGlobalNamespace` must be set to `true`.\n2. `failoverVersionIncrement` has to be equal across connected Clusters.\n3. `initialFailoverVersion` in each Cluster has to assign a different value.\n   No equal value is allowed across connected Clusters.\n\nAfter the above conditions are satisfied, you can start to configure a multi-cluster setup.\n\n#### Set up Multi-Cluster Replication prior to v1.14\n\nYou can set this up with [`clusterMetadata` configuration](/references/configuration#clustermetadata); however, this is meant to be only a conceptual guide rather than a detailed tutorial.\nPlease reach out to us if you need to set this up.\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\n#### Set up Multi-Cluster Replication in v1.14 and later\n\nYou still need to set up local cluster [`clusterMetadata` configuration](/references/configuration#clustermetadata)\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterB\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\nThen you can use the `tctl admin` tool to add cluster connections. All operations should be executed in both Clusters.\n\n```shell\n# Add cluster B connection into cluster A\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\"\n# Add cluster A connection into cluster B\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\"\n\n# Disable connections\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\" --enable_connection false\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\" --enable_connection false\n\n# Delete connections\ntctl -address 127.0.0.1:7233 admin cluster remove-remote-cluster --cluster \"clusterB\"\ntctl -address 127.0.0.1:8233 admin cluster remove-remote-cluster --cluster \"clusterA\"\n```","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"","node_id":"cluster-ops-context/intro"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"elasticsearch","node_id":"clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"archival","node_id":"cluster-ops-context/archival"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"set-up-archival","node_id":"clusters/how-to-set-up-archival"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"custom-archiver","node_id":"clusters/how-to-create-a-custom-archiver"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"upgrade-server","node_id":"clusters/how-to-upgrade-the-temporal-server-version"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"set-up-multi-cluster-replication","node_id":"clusters/how-to-set-up-multi-cluster-replication"}],"markdown_content":"---\nid: cluster-deployment-guide\ntitle: Temporal Cluster deployment guide\nsidebar_label: Cluster deployment\ndescription: This guide provides a comprehensive overview to deploy and operate a Temporal Cluster in a live environment.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nThis guide provides a comprehensive overview to deploy and operate a Temporal Cluster in a live environment.\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete.\nInformation may change at any time.\n\nLegacy production deployment information is available [here](/server/production-deployment)\n\n:::\n\n## Elasticsearch\n\n[Advanced Visibility](/visibility#advanced-visibility) features depend on an integration with Elasticsearch.\n\nTo integrate Elasticsearch with your Temporal Cluster, edit the `persistence` section of your `development.yaml` configuration file and run the index schema setup commands.\n\n:::note\n\nThese steps are needed only if you have a \"plain\" [Temporal Server Docker image](https://hub.docker.com/r/temporalio/server).\n\nIf you operate a Temporal Cluster using our [Helm charts](https://github.com/temporalio/helm-charts) or\n[docker-compose](https://github.com/temporalio/docker-compose), the Elasticsearch index schema and index are created automatically using the [auto-setup Docker image](https://hub.docker.com/r/temporalio/auto-setup).\n\n:::\n\n:::note Supported versions\n\n- Elasticsearch v7.10 is supported from Temporal version 1.7.0 onwards\n- Elasticsearch v6.8 is supported in all Temporal versions\n- Both versions are explicitly supported with AWS Elasticsearch\n\n:::\n\n#### Edit persistence\n\n1. Add the `advancedVisibilityStore: es-visibility` key-value pair to the `persistence` section.\n   The [development_es.yaml](https://github.com/temporalio/temporal/blob/master/config/development_es.yaml) file in the `temporalio/temporal` repo is a working example.\n   The configuration instructs the Temporal Cluster how and where to connect to Elasticsearch storage.\n\n```yaml\npersistence:\n  ...\n  advancedVisibilityStore: es-visibility\n```\n\n2. Define the Elasticsearch datastore connection information under the `es-visibility` key:\n\n```yaml\npersistence:\n  ...\n  advancedVisibilityStore: es-visibility\n  datastores:\n    ...\n    es-visibility:\n      elasticsearch:\n        version: \"v7\"\n        url:\n          scheme: \"http\"\n          host: \"127.0.0.1:9200\"\n        indices:\n          visibility: temporal_visibility_v1_dev\n```\n\n#### Create index schema and index\n\nRun the following commands to create the index schema and index:\n\n```bash\n# ES_SERVER is the URL of Elasticsearch server; for example, \"http://localhost:9200\".\nSETTINGS_URL=\"${ES_SERVER}/_cluster/settings\"\nSETTINGS_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/cluster_settings_${ES_VERSION}.json\nTEMPLATE_URL=\"${ES_SERVER}/_template/temporal_visibility_v1_template\"\nSCHEMA_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/index_template_${ES_VERSION}.json\nINDEX_URL=\"${ES_SERVER}/${ES_VIS_INDEX}\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SETTINGS_URL}\" -H \"Content-Type: application/json\" --data-binary \"@${SETTINGS_FILE}\" --write-out \"\\n\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${TEMPLATE_URL}\" -H 'Content-Type: application/json' --data-binary \"@${SCHEMA_FILE}\" --write-out \"\\n\"\ncurl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${INDEX_URL}\" --write-out \"\\n\"\n```\n\n#### Set Elasticsearch privileges\n\nEnsure that the following privileges are granted for the Elasticsearch Temporal index:\n\n- **Read**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `create`, `index`, `delete`, `read`\n- **Write**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `write`\n- **Custom Search Attributes**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `manage`\n  - [cluster privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-cluster): `monitor` or `manage`.\n\n#### Add custom Search Attributes (optional)\n\nThis step is optional.\nHere we are adding custom Search Attributes to your Cluster.\n\nRun the following `tctl` command to add the `ProductId` custom Search Attribute to the Temporal Cluster (and Elasticsearch Temporal index):\n\n```bash\ntctl admin cluster add-search-attributes --name ProductId --type Keyword\n```\n\nRun the following `tctl` command to add custom Search Attributes used by samples and SDK integration tests:\n\n```bash\ntctl --auto_confirm admin cluster add-search-attributes \\\n    --name CustomKeywordField --type Keyword \\\n    --name CustomStringField --type Text \\\n    --name CustomTextField --type Text \\\n    --name CustomIntField --type Int \\\n    --name CustomDatetimeField --type Datetime \\\n    --name CustomDoubleField --type Double \\\n    --name CustomBoolField --type Bool\n```\n\n## Archival\n\n[Archival](/clusters#archival) is a feature that automatically backs up Workflow Execution Event Histories and Visibility data from Temporal Cluster persistence to a custom blob store.\n\n### Set up Archival\n\n[Archival](/clusters#archival) consists of the following elements:\n\n- **Configuration**: Archival is controlled by the [server configuration](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L81) (i.e. the `config/development.yaml` file).\n- **Provider**: Location where the data should be archived. Supported providers are S3, GCloud, and the local file system.\n- **URI**: Specifies which provider should be used. The system uses the URI schema and path to make the determination.\n\nTake the following steps to set up Archival:\n\n1. [Set up the provider](#providers) of your choice.\n2. [Configure Archival](#configuration).\n3. [Create a Namespace](#namespace-creation) that uses a valid URI and has Archival enabled.\n\n#### Providers\n\nTemporal directly supports several providers:\n\n- **Local file system**: The [filestore archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) is used to archive data in the file system of whatever host the Temporal server is running on. This provider is used mainly for local installations and testing and should not be relied on for production environments.\n- **Google Cloud**: The [gcloud archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud) is used to connect and archive data with [Google Cloud](https://cloud.google.com/storage).\n- **S3**: The [s3store archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store) is used to connect and archive data with [S3](https://aws.amazon.com/s3).\n- **Custom**: If you want to use a provider that is not currently supported, you can [create your own archiver](#custom-archiver) to support it.\n\nMake sure that you save the provider's storage location URI in a place where you can reference it later, because it is passed as a parameter when you [create a Namespace](#namespace-creation).\n\n#### Configuration\n\nArchival configuration is defined in the [`config/development.yaml`](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L93) file.\nLet's look at an example configuration:\n\n```yaml\n# Cluster level Archival config\narchival:\n  # Event History configuration\n  history:\n    # Archival is enabled at the cluster level\n    state: \"enabled\"\n    enableRead: true\n    # Namespaces can use either the local filestore provider or the Google Cloud provider\n    provider:\n      filestore:\n        fileMode: \"0666\"\n        dirMode: \"0766\"\n      gstorage:\n        credentialsPath: \"/tmp/gcloud/keyfile.json\"\n\n# Default values for a Namespace if none are provided at creation\nnamespaceDefaults:\n  # Archival defaults\n  archival:\n    # Event History defaults\n    history:\n      state: \"enabled\"\n      # New Namespaces will default to the local provider\n      URI: \"file:///tmp/temporal_archival/development\"\n```\n\nYou can disable Archival by setting `archival.history.state` and `namespaceDefaults.archival.history.state` to `\"disabled\"`.\n\nExample:\n\n```yaml\narchival:\n  history:\n    state: \"disabled\"\n\nnamespaceDefaults:\n  archival:\n    history:\n      state: \"disabled\"\n```\n\nThe following table showcases acceptable values for each configuration and what purpose they serve.\n\n| Config                                         | Acceptable values                                                                  | Description                                                                                                                  |\n| ---------------------------------------------- | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\n| `archival.history.state`                       | `enabled`, `disabled`                                                              | Must be `enabled` to use the Archival feature with any Namespace in the cluster.                                             |\n| `archival.history.enableRead`                  | `true`, `false`                                                                    | Must be `true` to read from the archived Event History.                                                                      |\n| `archival.history.provider`                    | Sub provider configs are `filestore`, `gstorage`, `s3`, or `your_custom_provider`. | Default config specifies `filestore`.                                                                                        |\n| `archival.history.provider.filestore.fileMode` | File permission string                                                             | File permissions of the archived files. We recommend using the default value of `\"0666\"` to avoid read/write issues.         |\n| `archival.history.provider.filestore.dirMode`  | File permission string                                                             | Directory permissions of the archive directory. We recommend using the default value of `\"0766\"` to avoid read/write issues. |\n| `namespaceDefaults.archival.history.state`     | `enabled`, `disabled`                                                              | Default state of the Archival feature whenever a new Namespace is created without specifying the Archival state.             |\n| `namespaceDefaults.archival.history.URI`       | Valid URI                                                                          | Must be a URI of the file store location and match a schema that correlates to a provider.                                   |\n\n#### Namespace creation\n\nAlthough Archival is configured at the cluster level, it operates independently within each Namespace.\nIf an Archival URI is not specified when a Namespace is created, the Namespace uses the value of `defaultNamespace.archival.history.URI` from the `config/development.yaml` file.\nThe Archival URI cannot be changed after the Namespace is created.\nEach Namespace supports only a single Archival URI, but each Namespace can use a different URI.\nA Namespace can safely switch Archival between `enabled` and `disabled` states as long as Archival is enabled at the cluster level.\n\nArchival is supported in [Global Namespaces](/concepts/what-is-a-global-namespace/) (Namespaces that span multiple clusters).\nWhen Archival is running in a Global Namespace, it first runs on the active cluster; later it runs on the standby cluster. Before archiving, a history check is done to see what has been previously archived.\n\n#### Test setup\n\nTo test Archival locally, start by running a Temporal server:\n\n```bash\n./temporal-server start\n```\n\nThen register a new Namespace with Archival enabled.\n\n```bash\n./tctl --ns samples-namespace namespace register --gd false --history_archival_state enabled --retention 3\n```\n\n:::note\n\nIf the retention period isn't set, it defaults to 2 days.\nThe minimum retention period is 1 day.\nThe maximum retention period is 30 days.\n\nSetting the retention period to 0 results in the error _A valid retention period is not set on request_.\n\n:::\n\nNext, run a sample Workflow such as the [helloworld temporal sample](https://github.com/temporalio/temporal-go-samples/tree/master/helloworld).\n\nWhen execution is finished, Archival occurs.\n\n#### Retrieve archives\n\nYou can retrieve archived Event Histories by copying the `workflowId` and `runId` of the completed Workflow from the log output and running the following command:\n\n```bash\n./temporal --ns samples-namespace wf show --wid <workflowId> --rid <runId>\n```\n\n### Custom Archiver\n\nTo archive data with a given provider, using the [Archival](/clusters#archival) feature, Temporal must have a corresponding Archiver component installed.\nThe platform does not limit you to the existing providers.\nTo use a provider that is not currently supported, you can create your own Archiver.\n\n#### Create a new package\n\nThe first step is to create a new package for your implementation in [/common/archiver](https://github.com/temporalio/temporal/tree/master/common/archiver).\nCreate a directory in the archiver folder and arrange the structure to look like the following:\n\n```\ntemporal/common/archiver\n  - filestore/                      -- Filestore implementation\n  - provider/\n      - provider.go                 -- Provider of archiver instances\n  - yourImplementation/\n      - historyArchiver.go          -- HistoryArchiver implementation\n      - historyArchiver_test.go     -- Unit tests for HistoryArchiver\n      - visibilityArchiver.go       -- VisibilityArchiver implementations\n      - visibilityArchiver_test.go  -- Unit tests for VisibilityArchiver\n```\n\n#### Archiver interfaces\n\nNext, define objects that implement the [HistoryArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L80) and the [VisibilityArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L121) interfaces.\n\nThe objects should live in `historyArchiver.go` and `visibilityArchiver.go`, respectively.\n\n#### Update provider\n\nUpdate the `GetHistoryArchiver` and `GetVisibilityArchiver` methods of the `archiverProvider` object in the [/common/archiver/provider/provider.go](https://github.com/temporalio/temporal/blob/master/common/archiver/provider/provider.go) file so that it knows how to create an instance of your archiver.\n\n#### Add configs\n\nAdd configs for your archiver to the `config/development.yaml` file and then modify the [HistoryArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L376) and [VisibilityArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L393) structs in `/common/common/config.go` accordingly.\n\n#### Custom archiver FAQ\n\n**If my custom Archive method can automatically be retried by the caller, how can I record and access progress between retries?**\n\nHandle this situation by using `ArchiverOptions`.\nHere is an example:\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n    var progress progress\n    // Check if the feature for recording progress is enabled.\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.LoadProgress(ctx, & prevProgress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n\n    // Your archiver implementation...\n\n    // Record current progress\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.RecordProgress(ctx, progress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n}\n```\n\n**If my `Archive` method encounters an error that is non-retryable, how do I indicate to the caller that it should not retry?**\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n\n    err: = youArchiverImpl()\n\n    if nonRetryableErr(err) {\n        if featureCatalog.NonRetryableError != nil {\n            return featureCatalog.NonRetryableError() // when the caller gets this error type back it will not retry anymore.\n        }\n    }\n}\n```\n\n**How does my history archiver implementation read history?**\n\nThe archiver package provides a utility called [HistoryIterator](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) which is a wrapper of [ExecutionManager](https://github.com/temporalio/temporal/blob/master/common/persistence/dataInterfaces.go#L1014).\n`HistoryIterator` is more simple than the `HistoryManager`, which is available in the BootstrapContainer, so archiver implementations can choose to use it when reading Workflow histories.\nSee the [historyIterator.go](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) file for more details.\nUse the [filestore historyArchiver implementation](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) as an example.\n\n**Should my archiver define its own error types?**\n\nEach archiver is free to define and return its own errors.\nHowever, many common errors that exist between archivers are already defined in [common/archiver/constants.go](https://github.com/temporalio/temporal/blob/master/common/archiver/constants.go).\n\n**Is there a generic query syntax for the visibility archiver?**\n\nCurrently, no.\nBut this is something we plan to do in the future.\nAs for now, try to make your syntax similar to the one used by our advanced list Workflow API.\n\n- [s3store](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store#visibility-query-syntax)\n- [gcloud](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud#visibility-query-syntax)\n\n## Upgrade Server\n\nIf a newer version of the [Temporal Server](/clusters#temporal-server) is available, a notification appears in the Temporal Web UI.\n\n:::info\n\nIf you are using a version that is older than 1.0.0, reach out to us at [community.temporal.io](http://community.temporal.io) to ask how to upgrade.\n\n:::\n\nFirst check to see if an upgrade to the database schema is required for the version you wish to upgrade to.\nIf a database schema upgrade is required, it will be called out directly in the [release notes](https://github.com/temporalio/temporal/releases).\nSome releases require changes to the schema, and some do not.\nWe ensure that any consecutive versions are compatible in terms of database schema upgrades, features, and system behavior, however there is no guarantee that there is compatibility between _any_ 2 non-consecutive versions.\n\nUse one of the upgrade tools to upgrade your database schema to be compatible with the Temporal Server version being upgraded to.\n\nIf you are using a schema tools version prior to 1.8.0, we strongly recommend _never_ using the \"dryrun\" (`-y`, or `--dryrun`) options in any of your schema update commands.\nUsing this option might lead to potential loss of data, as when using it will create a new database and drop your\nexisting one.\nThis flag was removed in the 1.8.0 release.\n\n### Upgrade Cassandra schema\n\nIf you are using Cassandra for your Cluster's persistence, use the `temporal-cassandra-tool` to upgrade both the default and visibility schemas.\n\n**Example default schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/temporal/versioned\n\n```\n\n**Example visibility schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal_visibility \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/visibility/versioned\n\n```\n\n### Upgrade MySQL / PostgreSQL schema\n\nIf you are using MySQL or PostgreSQL use the `temporal-sql-tool`, which works similarly to the `temporal-cassandra-tool`.\n\nRefer to this [Makefile](https://github.com/temporalio/temporal/blob/v1.4.1/Makefile#L367-L383) for context.\n\n#### PostgreSQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal update-schema -d ./schema/postgresql/v96/temporal/versioned\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal_visibility update-schema -d ./schema/postgresql/v96/visibility/versioned\n```\n\n#### MySQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal update-schema -d ./schema/mysql/v57/temporal/versioned/\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal_visibility update-schema -d ./schema/mysql/v57/visibility/versioned/\n```\n\n### Roll-out technique\n\nWe recommend preparing a staging Cluster and then do the following to verify the upgrade is successful:\n\n1. Create some simulation load on the staging cluster.\n2. Upgrade the database schema in the staging cluster.\n3. Wait and observe for a few minutes to verify that there is no unstable behavior from both the server and the simulation load logic.\n4. Upgrade the server.\n5. Now do the same to the live environment cluster.\n\n## Set up Multi-Cluster Replication\n\nThe [Multi-Cluster Replication](/clusters#multi-cluster-replication) feature asynchronously replicates Workflow Execution Event Histories from active Clusters to other passive Clusters, and can be enabled by setting the appropriate values in the `clusterMetadata` section of your configuration file.\n\n1. `enableGlobalNamespace` must be set to `true`.\n2. `failoverVersionIncrement` has to be equal across connected Clusters.\n3. `initialFailoverVersion` in each Cluster has to assign a different value.\n   No equal value is allowed across connected Clusters.\n\nAfter the above conditions are satisfied, you can start to configure a multi-cluster setup.\n\n#### Set up Multi-Cluster Replication prior to v1.14\n\nYou can set this up with [`clusterMetadata` configuration](/references/configuration#clustermetadata); however, this is meant to be only a conceptual guide rather than a detailed tutorial.\nPlease reach out to us if you need to set this up.\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\n#### Set up Multi-Cluster Replication in v1.14 and later\n\nYou still need to set up local cluster [`clusterMetadata` configuration](/references/configuration#clustermetadata)\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterB\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\nThen you can use the `tctl admin` tool to add cluster connections. All operations should be executed in both Clusters.\n\n```shell\n# Add cluster B connection into cluster A\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\"\n# Add cluster A connection into cluster B\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\"\n\n# Disable connections\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\" --enable_connection false\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\" --enable_connection false\n\n# Delete connections\ntctl -address 127.0.0.1:7233 admin cluster remove-remote-cluster --cluster \"clusterB\"\ntctl -address 127.0.0.1:8233 admin cluster remove-remote-cluster --cluster \"clusterA\"\n```\n\n"},{"file_name":"web-ui.md","id":"web-ui","file_dir":"/","title":"Temporal Web UI","sidebar_label":"Web UI","description":"This guide is an overview of the Temporal Web UI.","toc_max_heading_level":4,"add_tabs_support":false,"sections":[{"type":"p","id":"concepts/what-is-the-temporal-web-ui","node":{"file_name":"what-is-the-temporal-web-ui.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-the-temporal-web-ui.md","id":"concepts/what-is-the-temporal-web-ui","title":"What is the Temporal Web UI?","description":"The Temporal Web UI","label":"Temporal Web UI","tags":["term","web-ui"],"markdown_content":":::info Upgrade available\n\nTemporal Web UI v2 is now generally available.\n\nTemporal Web UI v1 is being deprecated on September 30, 2022.\n\n:::\n\nThe Temporal Web UI is a GUI that provides users with Workflow Execution state and metadata and is intended to be used to debug execution issues.\nIt ships with every [docker-compose](/application-development/foundations#docker-compose) update and is available with [Temporal Cloud](/cloud).\n\nYou can configure the Temporal Web UI to work in your own environment.\nSee the [UI configuration reference](/references/ui-configuration).\n\nWeb UI open source repos:\n\n- [temporalio/ui](https://github.com/temporalio/ui)\n- [temporalio/ui-server](https://github.com/temporalio/ui-server)\n\nThe Web UI is packed with several features.\n\n### Namespace selection\n\nUsers can switch between Namespaces by clicking the Namespace Switcher icon in the left navigation.\nClicking the Namespace Switcher reveals a side panel where users can search for a Namespace or select a Namespace from the list.\nAfter a Namespace is selected, the user is redirected to the Recent Workflows page for that Namespace.\nIn Temporal Cloud, users can access only Namespaces that they have been granted access to.\n\n### Recent Workflows\n\nThe Recent Workflows page lists the most recent 1,000 Workflow Executions in the past 24 hours, by default.\nUsers can list Workflow Executions by any of the following:\n\n- [Workflow ID](/workflows#workflow-id)\n- [Workflow Type](/workflows#workflow-type)\n- Status\n- Date & Timeusers can set their preferred date & time format as one of the following:\n  - UTC\n  - Local\n  - Relative\n- A [List Filter](/visibility#list-filter)\n\nSelect a Workflow Execution to see a breakdown of the Workflow Execution's History, Workers, and pending Activities.\n\n#### History\n\nThis is a view of the [Events](/workflows#event) and Event fields that make up the Workflow Execution.\nApproximately [40 different Events](/references/events) can appear in a Workflow Execution's Event History.\nThe top of the page lists the following execution metadata:\n\n- [Workflow Type](/workflows#workflow-type)\n- [Run ID](/workflows#run-id)\n- Start Time and Close Time\n- [Task Queue](/tasks#task-queue)\n- Parent and Parent ID\n- State Transitions\n\nThe Input and Results section displays the function arguments and return values for debugging purposes.\nResults are not available until the Workflow finishes.\n\nThe Recent Events tab has the following views:\n\n- Timeline: A chronological or reverse-chronological order of events with a summary.\n  Clicking into an Event displays all details for that Event.\n  Clicking Expand all displays all Event details.\n  Similarly, clicking Collapse all collapses the table and displays only the summary.\n- Compact: A logical grouping of Activities, Signals and Timers.\n- JSON: The full JSON code for the workflow.\n\n#### Download Event History\n\nThe entire Workflow Execution Event History, in JSON format, can be downloaded from this screen.\n\n#### Terminate Workflow\n\nWorkflow Executions can be Terminated directly from the UI.\nA custom note can be logged from the UI when that happens.\n\n#### Workers\n\nDisplays the Workers currently polling on the Workflow Task Queue with a count.\nIf no Workers are polling, an error displays.\n\n#### Pending Activities\n\nDisplays a summary of recently active and/or pending Activity Executions.\nClicking a pending Activity directs the user to the Pending Activities tab to view details.\n\n#### Stack Trace\n\nThe screen shows the captured result from the [\\_\\_stack_trace](/workflows#stack-trace-query) Query.\nThe Query is performed when the tab is selected.\nIt works only if a Worker is running and available to return the stack trace.\n\n#### Queries\n\nLists all Queries sent to the Workflow Execution.\n\n### Settings\n\nDisplays the following information:\n\n- Description of the Namespace.\n- Owner: Namespace owner.\n- Global?: Whether the Namespace is a Global Namespace\n- Retention Period: Namespace Retention Period\n- History Archival: Whether History Archival is enabled\n- Visibility Archival: Whether Visibility Archival is enabled\n- Failover Version: Namespace Failover Version\n- Clusters: Cluster information\n\n### Archival\n\n[Archival](/clusters#archival) feature information.\n\n### Import Event History\n\nNavigate to `/import` to import an Event History in JSON format and populate a Workflow details page.\n\n### Data Encoder\n\nThe Web UI can use the same Data Converter that Workers use for inputs and return values.\nThe UI supports both a Remote Codec endpoint and/or the tctl plugin port.","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"web-ui","local_ref":"","node_id":"concepts/what-is-the-temporal-web-ui"}],"markdown_content":"---\nid: web-ui\ntitle: Temporal Web UI\nsidebar_label: Web UI\ndescription: This guide is an overview of the Temporal Web UI.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\n:::info Upgrade available\n\nTemporal Web UI v2 is now generally available.\n\nTemporal Web UI v1 is being deprecated on September 30, 2022.\n\n:::\n\nThe Temporal Web UI is a GUI that provides users with Workflow Execution state and metadata and is intended to be used to debug execution issues.\nIt ships with every [docker-compose](/application-development/foundations#docker-compose) update and is available with [Temporal Cloud](/cloud).\n\nYou can configure the Temporal Web UI to work in your own environment.\nSee the [UI configuration reference](/references/ui-configuration).\n\nWeb UI open source repos:\n\n- [temporalio/ui](https://github.com/temporalio/ui)\n- [temporalio/ui-server](https://github.com/temporalio/ui-server)\n\nThe Web UI is packed with several features.\n\n### Namespace selection\n\nUsers can switch between Namespaces by clicking the Namespace Switcher icon in the left navigation.\nClicking the Namespace Switcher reveals a side panel where users can search for a Namespace or select a Namespace from the list.\nAfter a Namespace is selected, the user is redirected to the Recent Workflows page for that Namespace.\nIn Temporal Cloud, users can access only Namespaces that they have been granted access to.\n\n### Recent Workflows\n\nThe Recent Workflows page lists the most recent 1,000 Workflow Executions in the past 24 hours, by default.\nUsers can list Workflow Executions by any of the following:\n\n- [Workflow ID](/workflows#workflow-id)\n- [Workflow Type](/workflows#workflow-type)\n- Status\n- Date & Timeusers can set their preferred date & time format as one of the following:\n  - UTC\n  - Local\n  - Relative\n- A [List Filter](/visibility#list-filter)\n\nSelect a Workflow Execution to see a breakdown of the Workflow Execution's History, Workers, and pending Activities.\n\n#### History\n\nThis is a view of the [Events](/workflows#event) and Event fields that make up the Workflow Execution.\nApproximately [40 different Events](/references/events) can appear in a Workflow Execution's Event History.\nThe top of the page lists the following execution metadata:\n\n- [Workflow Type](/workflows#workflow-type)\n- [Run ID](/workflows#run-id)\n- Start Time and Close Time\n- [Task Queue](/tasks#task-queue)\n- Parent and Parent ID\n- State Transitions\n\nThe Input and Results section displays the function arguments and return values for debugging purposes.\nResults are not available until the Workflow finishes.\n\nThe Recent Events tab has the following views:\n\n- Timeline: A chronological or reverse-chronological order of events with a summary.\n  Clicking into an Event displays all details for that Event.\n  Clicking Expand all displays all Event details.\n  Similarly, clicking Collapse all collapses the table and displays only the summary.\n- Compact: A logical grouping of Activities, Signals and Timers.\n- JSON: The full JSON code for the workflow.\n\n#### Download Event History\n\nThe entire Workflow Execution Event History, in JSON format, can be downloaded from this screen.\n\n#### Terminate Workflow\n\nWorkflow Executions can be Terminated directly from the UI.\nA custom note can be logged from the UI when that happens.\n\n#### Workers\n\nDisplays the Workers currently polling on the Workflow Task Queue with a count.\nIf no Workers are polling, an error displays.\n\n#### Pending Activities\n\nDisplays a summary of recently active and/or pending Activity Executions.\nClicking a pending Activity directs the user to the Pending Activities tab to view details.\n\n#### Stack Trace\n\nThe screen shows the captured result from the [\\_\\_stack_trace](/workflows#stack-trace-query) Query.\nThe Query is performed when the tab is selected.\nIt works only if a Worker is running and available to return the stack trace.\n\n#### Queries\n\nLists all Queries sent to the Workflow Execution.\n\n### Settings\n\nDisplays the following information:\n\n- Description of the Namespace.\n- Owner: Namespace owner.\n- Global?: Whether the Namespace is a Global Namespace\n- Retention Period: Namespace Retention Period\n- History Archival: Whether History Archival is enabled\n- Visibility Archival: Whether Visibility Archival is enabled\n- Failover Version: Namespace Failover Version\n- Clusters: Cluster information\n\n### Archival\n\n[Archival](/clusters#archival) feature information.\n\n### Import Event History\n\nNavigate to `/import` to import an Event History in JSON format and populate a Workflow details page.\n\n### Data Encoder\n\nThe Web UI can use the same Data Converter that Workers use for inputs and return values.\nThe UI supports both a Remote Codec endpoint and/or the tctl plugin port.\n\n"},{"file_name":"activities.md","id":"activities","file_dir":"/","title":"Activities","sidebar_label":"Activities","description":"This guide provides a comprehensive overview of Temporal Activities.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"concepts/what-is-an-activity","node":{"file_name":"what-is-an-activity.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-activity.md","id":"concepts/what-is-an-activity","title":"What is an Activity?","description":"In day-to-day conversations, the term \"Activity\" frequently denotes either an Activity Type, an Activity Definition, or an Activity Execution.","label":"Activity","tags":["term","explanation"],"markdown_content":"In day-to-day conversations, the term _Activity_ frequently denotes either an [Activity Definition](#activity-definition), an [Activity Type](#activity-type), or an [Activity Execution](#activity-execution).\nTemporal documentation aims to be explicit and differentiate between them.\n\nAn Activity is a normal function or object method that executes a single, well-defined action (either short or long running), such as calling another service, transcoding a media file, or sending an email message.\n\nWorkflow code orchestrates the execution of Activities, persisting the results.\nIf an Activity Function Execution fails, any future execution starts from initial state (except Heartbeats).\nTherefore, an Activity function is allowed to contain any code without restrictions.\n\nActivity Functions are executed by Worker Processes.\nWhen the Activity Function returns, the Worker sends the results back to the Temporal Cluster as part of the `ActivityTaskCompleted` Event.\nThe Event is added to the Workflow Execution's Event History.","is_empty":false}},{"type":"h2","id":"concepts/what-is-an-activity-definition","node":{"file_name":"what-is-an-activity-definition.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-activity-definition.md","id":"concepts/what-is-an-activity-definition","title":"What is an Activity Definition?","description":"An Activity Definition is the code that defines the constraints of an Activity Task Execution.","label":"Activity Definition","tags":["term","explanation"],"markdown_content":"An Activity Definition is the code that defines the constraints of an [Activity Task Execution](/tasks#activity-task-execution).\n\n- [How to develop an Activity Definition](/application-development/foundations#develop-activities)\n\nThe term 'Activity Definition' is used to refer to the full set of primitives in any given language SDK that provides an access point to an Activity Function Definitionthe method or function that is invoked for an [Activity Task Execution](/tasks#activity-task-execution).\nTherefore, the terms Activity Function and Activity Method refer to the source of an instance of an execution.\n\nActivity Definitions are named and referenced in code by their [Activity Type](#activity-type).\n\n![Activity Definition](/diagrams/activity-definition.svg)\n\n#### Constraints\n\nActivity Definitions are executed as normal functions.\n\nIn the event of failure, the function begins at its initial state when retried (except when Activity Heartbeats are established).\n\nTherefore, an Activity Definition has no restrictions on the code it contains.\n\n#### Parameters\n\nAn Activity Definition can support as many parameters as needed.\n\nAll values passed through these parameters are recorded in the [Event History](/workflows#event-history) of the Workflow Execution.\nReturn values are also captured in the Event History for the calling Workflow Execution.\n\nActivity Definitions must contain the following parameters:\n\n- Context: an optional parameter that provides Activity context within multiple APIs.\n- Heartbeat: a notification from the Worker to the Temporal Cluster that the Activity Execution is progressing. Cancelations are allowed only if the Activity Definition permits Heartbeating.\n- Timeouts: intervals that control the execution and retrying of Activity Task Executions.\n\nOther parameters, such as [Retry Policies](/retry-policies#) and return values, can be seen in the implementation guides, listed in the next section.","is_empty":false}},{"type":"h3","id":"concepts/what-is-an-activity-type","node":{"file_name":"what-is-an-activity-type.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-activity-type.md","id":"concepts/what-is-an-activity-type","title":"What is an Activity Type?","description":"An Activity Type is the mapping of a name to an Activity Definition.","label":"Activity Type","tags":["term","explanation"],"markdown_content":"An Activity Type is the mapping of a name to an Activity Definition.\n\nActivity Types are scoped through Task Queues.","is_empty":false}},{"type":"h2","id":"concepts/what-is-an-activity-execution","node":{"file_name":"what-is-an-activity-execution.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-activity-execution.md","id":"concepts/what-is-an-activity-execution","title":"What is an Activity Execution?","description":"An Activity Execution is the full chain of Activity Task Executions.","label":"Activity Execution","tags":["term","explanation"],"markdown_content":"An Activity Execution is the full chain of [Activity Task Executions](/tasks#activity-task-execution).\n\n- [How to spawn an Activity Execution](/application-development/foundations#start-activity-execution)\n\n![Activity Execution](/diagrams/activity-execution.svg)\n\nAn Activity Execution has no time limit.\nActivity Execution time limits and retries can be optimized for each situation within the Temporal Application.\n\nIf for any reason an Activity Execution does not complete (exhausts all retries), the error is returned to the [Workflow](/workflows), which decides how to handle it.\n\n### Request Cancellation\n\nA Workflow can request to cancel an Activity Execution.\nWhen an Activity Execution is canceled, or its Workflow Execution has completed or failed, the context passed into its function is canceled, which also sets its channels closed state to `Done`.\nAn Activity can use that to perform any necessary cleanup and abort its execution.\n\nCancellation requests are only delivered to Activity Executions that Heartbeat:\n\n- The Heartbeat request fails with a special error indicating that the Activity Execution is canceled.\n  Heartbeats can also fail when the Workflow Execution that spawned it is in a completed state.\n- The Activity should perform all necessary cleanup and report when it is done.\n- The Workflow can decide if it wants to wait for the Activity cancellation confirmation or proceed without waiting.","is_empty":false}},{"type":"h3","id":"concepts/what-is-an-activity-id","node":{"file_name":"what-is-an-activity-id.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-activity-id.md","id":"concepts/what-is-an-activity-id","title":"What is an Activity Id?","description":"A unique identifier for an Activity Execution.","label":"Activity Id","tags":["term","explanation"],"markdown_content":"A unique identifier for an [Activity Execution](#activity-execution).\nThe identifier can be generated by the system, or it can be provided by the Workflow code that spawns the Activity Execution.\nAn Activity Id can be used to complete the Activity asynchronously.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-schedule-to-start-timeout","node":{"file_name":"what-is-a-schedule-to-start-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-schedule-to-start-timeout.md","id":"concepts/what-is-a-schedule-to-start-timeout","title":"What is a Schedule-To-Start Timeout?","description":"A Schedule-To-Start Timeout is the maximum amount of time that is allowed from when an Activity Task is placed in a Task Queue to when a Worker picks it up from the Task Queue.","label":"Schedule-To-Start Timeout","tags":["term","explanation","timeouts"],"markdown_content":"A Schedule-To-Start Timeout is the maximum amount of time that is allowed from when an [Activity Task](/tasks#activity-task) is scheduled (that is, placed in a Task Queue) to when a [Worker](/workers#) starts (that is, picks up from the Task Queue) that Activity Task.\nIn other words, it's a limit for how long an Activity Task can be enqueued.\n\n[How to set a Schedule-To-Start Timeout](/application-development/features#schedule-to-start-timeout)\n\nThe moment that the Task is picked by the Worker from the Task Queue is considered to be the start of the Activity Task for the purposes of the Schedule-To-Start Timeout and associated metrics.\nThis definition of \"Start\" avoids issues that a clock difference between the Temporal Cluster and a Worker might create.\n\n![Schedule-To-Start Timeout period](/diagrams/schedule-to-start-timeout.svg)\n\n\"Schedule\" in Schedule-To-Start and Schedule-To-Close have different frequency guarantees.\n\nThe Schedule-To-Start Timeout is enforced for each Activity Task, whereas the Schedule-To-Close Timeout is enforced once per Activity Execution.\nThus, \"Schedule\" in Schedule-To-Start refers to the scheduling moment of _every_ Activity Task in the sequence of Activity Tasks that make up the Activity Execution, while\n\"Schedule\" in Schedule-To-Close refers to the _first_ Activity Task in that sequence.\n\nA [Retry Policy](/retry-policies#) attached to an Activity Execution retries an Activity Task.\n\n![Start-To-Close Timeout period with retries](/diagrams/schedule-to-start-timeout-with-retry.svg)\n\nThis timeout has two primary use cases:\n\n1. Detect whether an individual Worker has crashed.\n2. Detect whether the fleet of Workers polling the Task Queue is not able to keep up with the rate of Activity Tasks.\n\n**The default Schedule-To-Start Timeout is  (infinity).**\n\nIf this timeout is used, we recommend setting this timeout to the maximum time a Workflow Execution is willing to wait for an Activity Execution in the presence of all possible Worker outages, and have a concrete plan in place to reroute Activity Tasks to a different Task Queue.\nThis timeout **does not** trigger any retries regardless of the Retry Policy, as a retry would place the Activity Task back into the same Task Queue.\nWe do not recommend using this timeout unless you know what you are doing.\n\nIn most cases, we recommend monitoring the `temporal_activity_schedule_to_start_latency` metric to know when Workers slow down picking up Activity Tasks, instead of setting this timeout.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-start-to-close-timeout","node":{"file_name":"what-is-a-start-to-close-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-start-to-close-timeout.md","id":"concepts/what-is-a-start-to-close-timeout","title":"What is a Start-To-Close Timeout?","description":"A Start-To-Close Timeout is the maximum time allowed for a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["term","explanation","timeouts"],"markdown_content":"A Start-To-Close Timeout is the maximum time allowed for a single [Activity Task Execution](/tasks#activity-task-execution).\n\n- [How to set a Start-To-Close Timeout](/application-development/features#start-to-close-timeout)\n\n**The default Start-To-Close Timeout is the same as the default [Schedule-To-Close Timeout](#schedule-to-close-timeout).**\n\nAn Activity Execution must have either this timeout (Start-To-Close) or the [Schedule-To-Close Timeout](#schedule-to-close-timeout) set.\nWe recommend always setting this timeout; however, make sure that it is always set to be longer than the maximum possible time for the Activity Execution to take place.\nFor long running Activity Executions, we recommend also using [Activity Heartbeats](#activity-heartbeat) and [Heartbeat Timeouts](#heartbeat-timeout).\n\nThe main use case for the Start-To-Close timeout is to detect when a Worker crashes after it has started executing an Activity Task.\n\n![Start-To-Close Timeout period](/diagrams/start-to-close-timeout.svg)\n\nA [Retry Policy](/retry-policies#) attached to an Activity Execution retries an Activity Task Execution.\nThus, the Start-To-Close Timeout is applied to each Activity Task Execution within an Activity Execution.\n\nIf the first Activity Task Execution returns an error the first time, then the full Activity Execution might look like this:\n\n![Start-To-Close Timeout period with retries](/diagrams/start-to-close-timeout-with-retry.svg)\n\nIf this timeout is reached, the following actions occur:\n\n- An [ActivityTaskTimedOut](/references/events/#activitytasktimedout) Event is written to the Workflow Execution's mutable state.\n- If a Retry Policy dictates a retry, the Temporal Cluster schedules another Activity Task.\n  - The attempt count increments by 1 in the Workflow Execution's mutable state.\n  - The Start-To-Close Timeout timer is reset.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-schedule-to-close-timeout","node":{"file_name":"what-is-a-schedule-to-close-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-schedule-to-close-timeout.md","id":"concepts/what-is-a-schedule-to-close-timeout","title":"What is a Schedule-To-Close Timeout?","description":"A Schedule-To-Close Timeout is the maximum amount of time allowed for the overall Activity Execution, from when the first Activity Task is scheduled to when the last Activity Task, in the chain of Activity Tasks that make up the Activity Execution, reaches a Closed status.","label":"Schedule-To-Close Timeout","tags":["term","explanation","timeouts"],"markdown_content":"A Schedule-To-Close Timeout is the maximum amount of time allowed for the overall [Activity Execution](#activity-execution), from when the first [Activity Task](/tasks#activity-task) is scheduled to when the last Activity Task, in the chain of Activity Tasks that make up the Activity Execution, reaches a Closed status.\n\n- [How to set a Schedule-To-Close Timeout](/application-development/features#schedule-to-close-timeout)\n\n![Schedule-To-Close Timeout period](/diagrams/schedule-to-close-timeout.svg)\n\nExample Schedule-To-Close Timeout period for an Activity Execution that has a chain Activity Task Executions:\n\n![Schedule-To-Close Timeout period with a retry](/diagrams/schedule-to-close-timeout-with-retry.svg)\n\n**The default Schedule-To-Close Timeout is  (infinity).**\n\nAn Activity Execution must have either this timeout (Schedule-To-Close) or [Start-To-Close](#start-to-close-timeout) set.\nBy default, an Activity Execution Retry Policy dictates that retries will occur for up to 10 years.\nThis timeout can be used to control the overall duration of an Activity Execution in the face of failures (repeated Activity Task Executions), without altering the Maximum Attempts field of the Retry Policy.","is_empty":false}},{"type":"h3","id":"concepts/what-is-an-activity-heartbeat","node":{"file_name":"what-is-an-activity-heartbeat.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-activity-heartbeat.md","id":"concepts/what-is-an-activity-heartbeat","title":"What is an Activity Heartbeat?","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster. Each ping informs the Temporal Cluster that the Activity Execution is making progress and the Worker has not crashed.","label":"Activity Heartbeat","tags":["term","explanation"],"markdown_content":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.\nEach ping informs the Temporal Cluster that the Activity Execution is making progress and the Worker has not crashed.\n\n- [How to Heartbeat an Activity](/application-development/features#activity-heartbeats)\n\nActivity Heartbeats work in conjunction with a [Heartbeat Timeout](#heartbeat-timeout).\n\nActivity Heartbeats are implemented within the Activity Definition.\nCustom progress information can be included in the Heartbeat which can then be used by the Activity Execution should a retry occur.\n\nAn Activity Heartbeat can be recorded as often as needed (e.g. once a minute or every loop iteration).\nIt is often a good practice to Heartbeat on anything but the shortest Activity Function Execution.\nTemporal SDKs control the rate at which Heartbeats are sent to the Cluster.\n\nHeartbeating is not required from [Local Activities](#local-activity), and does nothing.\n\nFor _long-running_ Activities, we recommend using a relatively short Heartbeat Timeout and a frequent Heartbeat.\nThat way if a Worker fails it can be handled in a timely manner.\n\nA Heartbeat can include an application layer payload that can be used to _save_ Activity Execution progress.\nIf an [Activity Task Execution](/tasks#activity-task-execution) times out due to a missed Heartbeat, the next Activity Task can access and continue with that payload.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\n#### Throttling\n\nHeartbeats may not always be sent to the Clusterthey may be throttled by the Worker.\nThe throttle interval is the smaller of the following:\n\n- If `heartbeatTimeout` is provided, `heartbeatTimeout * 0.8`; otherwise, `defaultHeartbeatThrottleInterval`\n- `maxHeartbeatThrottleInterval`\n\n`defaultHeartbeatThrottleInterval` is 30 seconds by default, and `maxHeartbeatThrottleInterval` is 60 seconds by default.\nEach can be set in Worker options.\n\nThrottling is implemented as follows:\n\n- After sending a Heartbeat, the Worker sets a timer for the throttle interval.\n- The Worker stops sending Heartbeats, but continues receiving Heartbeats from the Activity and remembers the most recent one.\n- When the timer fires, the Worker:\n  - Sends the most recent Heartbeat.\n  - Sets the timer again.\n\n#### Which Activities should Heartbeat?\n\nHeartbeating is best thought about not in terms of time, but in terms of \"How do you know you are making progress?\"\nFor short-term operations, progress updates are not a requirement.\nHowever, checking the progress and status of Activity Executions that run over long periods is almost always useful.\n\nConsider the following when setting Activity Hearbeats:\n\n- Your underlying task must be able to report definite progress.\n  Note that your Workflow cannot read this progress information while the Activity is still executing (or it would have to store it in Event History).\n  You can report progress to external sources if you need it exposed to the user.\n\n- Your Activity Execution is long-running, and you need to verify whether the Worker that is processing your Activity is still alive and has not run out of memory or silently crashed.\n\nFor example, the following scenarios are suitable for Heartbeating:\n\n- Reading a large file from Amazon S3.\n- Running a ML training job on some local GPUs.\n\nAnd the following scenarios are not suitable for Heartbeating:\n\n- Making a quick API call.\n- Reading a small file from disk.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-heartbeat-timeout","node":{"file_name":"what-is-a-heartbeat-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-heartbeat-timeout.md","id":"concepts/what-is-a-heartbeat-timeout","title":"What is a Heartbeat Timeout?","description":"A Heartbeat Timeout is the maximum time between Activity Heartbeats.","label":"Heartbeat Timeout","tags":["term","explanation","timeouts"],"markdown_content":"A Heartbeat Timeout is the maximum time between [Activity Heartbeats](#activity-heartbeat).\n\n- [How to set a Heartbeat Timeout](/application-development/features#heartbeat-timeout)\n\n![Heartbeat Timeout periods](/diagrams/heartbeat-timeout.svg)\n\nIf this timeout is reached, the Activity Task fails and a retry occurs if a [Retry Policy](/retry-policies#) dictates it.","is_empty":false}},{"type":"h3","id":"concepts/what-is-asynchronous-activity-completion","node":{"file_name":"what-is-asynchronous-activity-completion.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-asynchronous-activity-completion.md","id":"concepts/what-is-asynchronous-activity-completion","title":"What is Asynchronous Activity Completion?","description":"Asynchronous Activity Completion occurs when an external system provides the final result of a computation, started by an Activity, to the Temporal System.","label":"Asynchronous Activity Completion","tags":["term","explanation"],"markdown_content":"Asynchronous Activity Completion is a feature that enables an Activity Function to return without causing the Activity Execution to complete.\nThe Temporal Client can then be used to both Heartbeat Activity Execution progress and eventually provide a result.\n\n- [How to complete an Activity Asynchronously](/application-development/features#async-activity-completion)\n\n#### When to use Async Completion\n\nThe intended use-case for this feature is when an external system has the final result of a computation, started by an Activity.\n\nConsider using Asynchronous Activities instead of Signals if the external process is unreliable and might fail to send critical status updates through a Signal.\n\nConsider using [Signals](/workflows#signal) as an alternative to Asynchronous Activities to return data back to a Workflow Execution if there is a human in the process loop.\nThe reason is that a human in the loop means multiple steps in the process.\nThe first is the Activity Function that stores state in an external system and at least one other step where a human would complete the activity.\nIf the first step fails, you want to detect that quickly and retry instead of waiting for the entire process, which could be significantly longer when humans are involved.","is_empty":false}},{"type":"h4","id":"concepts/what-is-a-task-token","node":{"file_name":"what-is-a-task-token.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-task-token.md","id":"concepts/what-is-a-task-token","title":"What is a Task Token?","description":"A Task Token is a unique Id that correlates to an Activity Execution.","label":"Task Token","tags":["term","explanation"],"markdown_content":"A Task Token is a unique Id that correlates to an [Activity Execution](#activity-execution).\n\nActivity Execution completion calls take either a single Task Token, or the [Namespace](/namespaces#), [Workflow Id](/workflows#workflow-id), and [Activity Id](#activity-id) as a set of arguments.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-local-activity","node":{"file_name":"what-is-a-local-activity.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-local-activity.md","id":"concepts/what-is-a-local-activity","title":"What is a Local Activity?","description":"A Local Activity is an Activity Execution that executes in the same process as the Workflow Execution that spawns it.","label":"Local Activity","tags":["term","explanation"],"markdown_content":"A Local Activity is an [Activity Execution](#activity-execution) that executes in the same process as the [Workflow Execution](/workflows#workflow-execution) that spawns it.\n\nSome Activity Executions are very short-living and do not need the queuing semantic, flow control, rate limiting, and routing capabilities.\nFor this case, Temporal supports the Local Activity feature.\n\nThe main benefit of Local Activities is that they use less Temporal service resources (e.g. lower state transitions) and have much lower latency overhead (because no need to roundtrip to the Cluster) compared to normal Activity Executions.\nHowever, Local Activities are subject to shorter durations and a lack of rate limiting.\n\nConsider using Local Activities for functions that are the following:\n\n- can be implemented in the same binary as the Workflow that calls them.\n- do not require global rate limiting.\n- do not require routing to a specific Worker or Worker pool.\n- no longer than a few seconds, inclusive of retries (shorter than the Workflow Task Timeout, which is 10 seconds by default).\n\nUsing a Local Activity without understanding its limitations can cause various production issues.\n**We recommend using regular Activities unless your use case requires very high throughput and large Activity fan outs of very short-lived Activities.**\nMore guidance in choosing between [Local Activity vs Activity](https://community.temporal.io/t/local-activity-vs-activity/290/3) is available in our forums.","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"activities","local_ref":"","node_id":"concepts/what-is-an-activity"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-definition","node_id":"concepts/what-is-an-activity-definition"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-type","node_id":"concepts/what-is-an-activity-type"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-execution","node_id":"concepts/what-is-an-activity-execution"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-id","node_id":"concepts/what-is-an-activity-id"},{"file_dir":"/","guide_id":"activities","local_ref":"schedule-to-start-timeout","node_id":"concepts/what-is-a-schedule-to-start-timeout"},{"file_dir":"/","guide_id":"activities","local_ref":"start-to-close-timeout","node_id":"concepts/what-is-a-start-to-close-timeout"},{"file_dir":"/","guide_id":"activities","local_ref":"schedule-to-close-timeout","node_id":"concepts/what-is-a-schedule-to-close-timeout"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-heartbeat","node_id":"concepts/what-is-an-activity-heartbeat"},{"file_dir":"/","guide_id":"activities","local_ref":"heartbeat-timeout","node_id":"concepts/what-is-a-heartbeat-timeout"},{"file_dir":"/","guide_id":"activities","local_ref":"asynchronous-activity-completion","node_id":"concepts/what-is-asynchronous-activity-completion"},{"file_dir":"/","guide_id":"activities","local_ref":"task-token","node_id":"concepts/what-is-a-task-token"},{"file_dir":"/","guide_id":"activities","local_ref":"local-activity","node_id":"concepts/what-is-a-local-activity"}],"markdown_content":"---\nid: activities\ntitle: Activities\nsidebar_label: Activities\ndescription: This guide provides a comprehensive overview of Temporal Activities.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nThis guide provides a comprehensive overview of Temporal Activities.\n\nIn day-to-day conversations, the term _Activity_ frequently denotes either an [Activity Definition](#activity-definition), an [Activity Type](#activity-type), or an [Activity Execution](#activity-execution).\nTemporal documentation aims to be explicit and differentiate between them.\n\nAn Activity is a normal function or object method that executes a single, well-defined action (either short or long running), such as calling another service, transcoding a media file, or sending an email message.\n\nWorkflow code orchestrates the execution of Activities, persisting the results.\nIf an Activity Function Execution fails, any future execution starts from initial state (except Heartbeats).\nTherefore, an Activity function is allowed to contain any code without restrictions.\n\nActivity Functions are executed by Worker Processes.\nWhen the Activity Function returns, the Worker sends the results back to the Temporal Cluster as part of the `ActivityTaskCompleted` Event.\nThe Event is added to the Workflow Execution's Event History.\n\n## Activity Definition\n\nAn Activity Definition is the code that defines the constraints of an [Activity Task Execution](/tasks#activity-task-execution).\n\n- [How to develop an Activity Definition](/application-development/foundations#develop-activities)\n\nThe term 'Activity Definition' is used to refer to the full set of primitives in any given language SDK that provides an access point to an Activity Function Definitionthe method or function that is invoked for an [Activity Task Execution](/tasks#activity-task-execution).\nTherefore, the terms Activity Function and Activity Method refer to the source of an instance of an execution.\n\nActivity Definitions are named and referenced in code by their [Activity Type](#activity-type).\n\n![Activity Definition](/diagrams/activity-definition.svg)\n\n#### Constraints\n\nActivity Definitions are executed as normal functions.\n\nIn the event of failure, the function begins at its initial state when retried (except when Activity Heartbeats are established).\n\nTherefore, an Activity Definition has no restrictions on the code it contains.\n\n#### Parameters\n\nAn Activity Definition can support as many parameters as needed.\n\nAll values passed through these parameters are recorded in the [Event History](/workflows#event-history) of the Workflow Execution.\nReturn values are also captured in the Event History for the calling Workflow Execution.\n\nActivity Definitions must contain the following parameters:\n\n- Context: an optional parameter that provides Activity context within multiple APIs.\n- Heartbeat: a notification from the Worker to the Temporal Cluster that the Activity Execution is progressing. Cancelations are allowed only if the Activity Definition permits Heartbeating.\n- Timeouts: intervals that control the execution and retrying of Activity Task Executions.\n\nOther parameters, such as [Retry Policies](/retry-policies#) and return values, can be seen in the implementation guides, listed in the next section.\n\n### Activity Type\n\nAn Activity Type is the mapping of a name to an Activity Definition.\n\nActivity Types are scoped through Task Queues.\n\n## Activity Execution\n\nAn Activity Execution is the full chain of [Activity Task Executions](/tasks#activity-task-execution).\n\n- [How to spawn an Activity Execution](/application-development/foundations#start-activity-execution)\n\n![Activity Execution](/diagrams/activity-execution.svg)\n\nAn Activity Execution has no time limit.\nActivity Execution time limits and retries can be optimized for each situation within the Temporal Application.\n\nIf for any reason an Activity Execution does not complete (exhausts all retries), the error is returned to the [Workflow](/workflows), which decides how to handle it.\n\n### Request Cancellation\n\nA Workflow can request to cancel an Activity Execution.\nWhen an Activity Execution is canceled, or its Workflow Execution has completed or failed, the context passed into its function is canceled, which also sets its channels closed state to `Done`.\nAn Activity can use that to perform any necessary cleanup and abort its execution.\n\nCancellation requests are only delivered to Activity Executions that Heartbeat:\n\n- The Heartbeat request fails with a special error indicating that the Activity Execution is canceled.\n  Heartbeats can also fail when the Workflow Execution that spawned it is in a completed state.\n- The Activity should perform all necessary cleanup and report when it is done.\n- The Workflow can decide if it wants to wait for the Activity cancellation confirmation or proceed without waiting.\n\n### Activity Id\n\nA unique identifier for an [Activity Execution](#activity-execution).\nThe identifier can be generated by the system, or it can be provided by the Workflow code that spawns the Activity Execution.\nAn Activity Id can be used to complete the Activity asynchronously.\n\n### Schedule-To-Start Timeout\n\nA Schedule-To-Start Timeout is the maximum amount of time that is allowed from when an [Activity Task](/tasks#activity-task) is scheduled (that is, placed in a Task Queue) to when a [Worker](/workers#) starts (that is, picks up from the Task Queue) that Activity Task.\nIn other words, it's a limit for how long an Activity Task can be enqueued.\n\n[How to set a Schedule-To-Start Timeout](/application-development/features#schedule-to-start-timeout)\n\nThe moment that the Task is picked by the Worker from the Task Queue is considered to be the start of the Activity Task for the purposes of the Schedule-To-Start Timeout and associated metrics.\nThis definition of \"Start\" avoids issues that a clock difference between the Temporal Cluster and a Worker might create.\n\n![Schedule-To-Start Timeout period](/diagrams/schedule-to-start-timeout.svg)\n\n\"Schedule\" in Schedule-To-Start and Schedule-To-Close have different frequency guarantees.\n\nThe Schedule-To-Start Timeout is enforced for each Activity Task, whereas the Schedule-To-Close Timeout is enforced once per Activity Execution.\nThus, \"Schedule\" in Schedule-To-Start refers to the scheduling moment of _every_ Activity Task in the sequence of Activity Tasks that make up the Activity Execution, while\n\"Schedule\" in Schedule-To-Close refers to the _first_ Activity Task in that sequence.\n\nA [Retry Policy](/retry-policies#) attached to an Activity Execution retries an Activity Task.\n\n![Start-To-Close Timeout period with retries](/diagrams/schedule-to-start-timeout-with-retry.svg)\n\nThis timeout has two primary use cases:\n\n1. Detect whether an individual Worker has crashed.\n2. Detect whether the fleet of Workers polling the Task Queue is not able to keep up with the rate of Activity Tasks.\n\n**The default Schedule-To-Start Timeout is  (infinity).**\n\nIf this timeout is used, we recommend setting this timeout to the maximum time a Workflow Execution is willing to wait for an Activity Execution in the presence of all possible Worker outages, and have a concrete plan in place to reroute Activity Tasks to a different Task Queue.\nThis timeout **does not** trigger any retries regardless of the Retry Policy, as a retry would place the Activity Task back into the same Task Queue.\nWe do not recommend using this timeout unless you know what you are doing.\n\nIn most cases, we recommend monitoring the `temporal_activity_schedule_to_start_latency` metric to know when Workers slow down picking up Activity Tasks, instead of setting this timeout.\n\n### Start-To-Close Timeout\n\nA Start-To-Close Timeout is the maximum time allowed for a single [Activity Task Execution](/tasks#activity-task-execution).\n\n- [How to set a Start-To-Close Timeout](/application-development/features#start-to-close-timeout)\n\n**The default Start-To-Close Timeout is the same as the default [Schedule-To-Close Timeout](#schedule-to-close-timeout).**\n\nAn Activity Execution must have either this timeout (Start-To-Close) or the [Schedule-To-Close Timeout](#schedule-to-close-timeout) set.\nWe recommend always setting this timeout; however, make sure that it is always set to be longer than the maximum possible time for the Activity Execution to take place.\nFor long running Activity Executions, we recommend also using [Activity Heartbeats](#activity-heartbeat) and [Heartbeat Timeouts](#heartbeat-timeout).\n\nThe main use case for the Start-To-Close timeout is to detect when a Worker crashes after it has started executing an Activity Task.\n\n![Start-To-Close Timeout period](/diagrams/start-to-close-timeout.svg)\n\nA [Retry Policy](/retry-policies#) attached to an Activity Execution retries an Activity Task Execution.\nThus, the Start-To-Close Timeout is applied to each Activity Task Execution within an Activity Execution.\n\nIf the first Activity Task Execution returns an error the first time, then the full Activity Execution might look like this:\n\n![Start-To-Close Timeout period with retries](/diagrams/start-to-close-timeout-with-retry.svg)\n\nIf this timeout is reached, the following actions occur:\n\n- An [ActivityTaskTimedOut](/references/events/#activitytasktimedout) Event is written to the Workflow Execution's mutable state.\n- If a Retry Policy dictates a retry, the Temporal Cluster schedules another Activity Task.\n  - The attempt count increments by 1 in the Workflow Execution's mutable state.\n  - The Start-To-Close Timeout timer is reset.\n\n### Schedule-To-Close Timeout\n\nA Schedule-To-Close Timeout is the maximum amount of time allowed for the overall [Activity Execution](#activity-execution), from when the first [Activity Task](/tasks#activity-task) is scheduled to when the last Activity Task, in the chain of Activity Tasks that make up the Activity Execution, reaches a Closed status.\n\n- [How to set a Schedule-To-Close Timeout](/application-development/features#schedule-to-close-timeout)\n\n![Schedule-To-Close Timeout period](/diagrams/schedule-to-close-timeout.svg)\n\nExample Schedule-To-Close Timeout period for an Activity Execution that has a chain Activity Task Executions:\n\n![Schedule-To-Close Timeout period with a retry](/diagrams/schedule-to-close-timeout-with-retry.svg)\n\n**The default Schedule-To-Close Timeout is  (infinity).**\n\nAn Activity Execution must have either this timeout (Schedule-To-Close) or [Start-To-Close](#start-to-close-timeout) set.\nBy default, an Activity Execution Retry Policy dictates that retries will occur for up to 10 years.\nThis timeout can be used to control the overall duration of an Activity Execution in the face of failures (repeated Activity Task Executions), without altering the Maximum Attempts field of the Retry Policy.\n\n### Activity Heartbeat\n\nAn Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.\nEach ping informs the Temporal Cluster that the Activity Execution is making progress and the Worker has not crashed.\n\n- [How to Heartbeat an Activity](/application-development/features#activity-heartbeats)\n\nActivity Heartbeats work in conjunction with a [Heartbeat Timeout](#heartbeat-timeout).\n\nActivity Heartbeats are implemented within the Activity Definition.\nCustom progress information can be included in the Heartbeat which can then be used by the Activity Execution should a retry occur.\n\nAn Activity Heartbeat can be recorded as often as needed (e.g. once a minute or every loop iteration).\nIt is often a good practice to Heartbeat on anything but the shortest Activity Function Execution.\nTemporal SDKs control the rate at which Heartbeats are sent to the Cluster.\n\nHeartbeating is not required from [Local Activities](#local-activity), and does nothing.\n\nFor _long-running_ Activities, we recommend using a relatively short Heartbeat Timeout and a frequent Heartbeat.\nThat way if a Worker fails it can be handled in a timely manner.\n\nA Heartbeat can include an application layer payload that can be used to _save_ Activity Execution progress.\nIf an [Activity Task Execution](/tasks#activity-task-execution) times out due to a missed Heartbeat, the next Activity Task can access and continue with that payload.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\n#### Throttling\n\nHeartbeats may not always be sent to the Clusterthey may be throttled by the Worker.\nThe throttle interval is the smaller of the following:\n\n- If `heartbeatTimeout` is provided, `heartbeatTimeout * 0.8`; otherwise, `defaultHeartbeatThrottleInterval`\n- `maxHeartbeatThrottleInterval`\n\n`defaultHeartbeatThrottleInterval` is 30 seconds by default, and `maxHeartbeatThrottleInterval` is 60 seconds by default.\nEach can be set in Worker options.\n\nThrottling is implemented as follows:\n\n- After sending a Heartbeat, the Worker sets a timer for the throttle interval.\n- The Worker stops sending Heartbeats, but continues receiving Heartbeats from the Activity and remembers the most recent one.\n- When the timer fires, the Worker:\n  - Sends the most recent Heartbeat.\n  - Sets the timer again.\n\n#### Which Activities should Heartbeat?\n\nHeartbeating is best thought about not in terms of time, but in terms of \"How do you know you are making progress?\"\nFor short-term operations, progress updates are not a requirement.\nHowever, checking the progress and status of Activity Executions that run over long periods is almost always useful.\n\nConsider the following when setting Activity Hearbeats:\n\n- Your underlying task must be able to report definite progress.\n  Note that your Workflow cannot read this progress information while the Activity is still executing (or it would have to store it in Event History).\n  You can report progress to external sources if you need it exposed to the user.\n\n- Your Activity Execution is long-running, and you need to verify whether the Worker that is processing your Activity is still alive and has not run out of memory or silently crashed.\n\nFor example, the following scenarios are suitable for Heartbeating:\n\n- Reading a large file from Amazon S3.\n- Running a ML training job on some local GPUs.\n\nAnd the following scenarios are not suitable for Heartbeating:\n\n- Making a quick API call.\n- Reading a small file from disk.\n\n### Heartbeat Timeout\n\nA Heartbeat Timeout is the maximum time between [Activity Heartbeats](#activity-heartbeat).\n\n- [How to set a Heartbeat Timeout](/application-development/features#heartbeat-timeout)\n\n![Heartbeat Timeout periods](/diagrams/heartbeat-timeout.svg)\n\nIf this timeout is reached, the Activity Task fails and a retry occurs if a [Retry Policy](/retry-policies#) dictates it.\n\n### Asynchronous Activity Completion\n\nAsynchronous Activity Completion is a feature that enables an Activity Function to return without causing the Activity Execution to complete.\nThe Temporal Client can then be used to both Heartbeat Activity Execution progress and eventually provide a result.\n\n- [How to complete an Activity Asynchronously](/application-development/features#async-activity-completion)\n\n#### When to use Async Completion\n\nThe intended use-case for this feature is when an external system has the final result of a computation, started by an Activity.\n\nConsider using Asynchronous Activities instead of Signals if the external process is unreliable and might fail to send critical status updates through a Signal.\n\nConsider using [Signals](/workflows#signal) as an alternative to Asynchronous Activities to return data back to a Workflow Execution if there is a human in the process loop.\nThe reason is that a human in the loop means multiple steps in the process.\nThe first is the Activity Function that stores state in an external system and at least one other step where a human would complete the activity.\nIf the first step fails, you want to detect that quickly and retry instead of waiting for the entire process, which could be significantly longer when humans are involved.\n\n#### Task Token\n\nA Task Token is a unique Id that correlates to an [Activity Execution](#activity-execution).\n\nActivity Execution completion calls take either a single Task Token, or the [Namespace](/namespaces#), [Workflow Id](/workflows#workflow-id), and [Activity Id](#activity-id) as a set of arguments.\n\n## Local Activity\n\nA Local Activity is an [Activity Execution](#activity-execution) that executes in the same process as the [Workflow Execution](/workflows#workflow-execution) that spawns it.\n\nSome Activity Executions are very short-living and do not need the queuing semantic, flow control, rate limiting, and routing capabilities.\nFor this case, Temporal supports the Local Activity feature.\n\nThe main benefit of Local Activities is that they use less Temporal service resources (e.g. lower state transitions) and have much lower latency overhead (because no need to roundtrip to the Cluster) compared to normal Activity Executions.\nHowever, Local Activities are subject to shorter durations and a lack of rate limiting.\n\nConsider using Local Activities for functions that are the following:\n\n- can be implemented in the same binary as the Workflow that calls them.\n- do not require global rate limiting.\n- do not require routing to a specific Worker or Worker pool.\n- no longer than a few seconds, inclusive of retries (shorter than the Workflow Task Timeout, which is 10 seconds by default).\n\nUsing a Local Activity without understanding its limitations can cause various production issues.\n**We recommend using regular Activities unless your use case requires very high throughput and large Activity fan outs of very short-lived Activities.**\nMore guidance in choosing between [Local Activity vs Activity](https://community.temporal.io/t/local-activity-vs-activity/290/3) is available in our forums.\n\n"},{"file_name":"index.md","id":"index","file_dir":"cloud","title":"Temporal Cloud documentation","sidebar_label":"Temporal Cloud","description":"Temporal Cloud documentation, including explanations and usage.","use_description":false,"toc_max_heading_level":4,"add_tabs_support":false,"sections":[{"type":"p","id":"concepts/what-is-temporal-cloud","node":{"file_name":"what-is-temporal-cloud.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-temporal-cloud.md","id":"concepts/what-is-temporal-cloud","title":"What is Temporal Cloud?","description":"Temporal Cloud is a managed, hosted Temporal environment that provides a platform for Temporal Applications.","label":"Temporal Cloud","tags":["term","explanation"],"markdown_content":"[Temporal Cloud](https://temporal.io/cloud) is a managed, hosted Temporal environment that provides a platform for [Temporal Applications](/temporal/#temporal-application)an alternative to deploying and operating your own [Temporal Cluster](/clusters).\n\nTemporal Cloud is offered in units of isolation known as [Namespaces](/namespaces). You can provision and use one or more Cloud Namespaces. A typical use case is to use separate Namespaces as development, testing, integration, staging, and production environments for an application.","is_empty":false}},{"type":"p","id":"cloud-context/cloud-intro","node":{"file_name":"cloud-intro.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/cloud-intro.md","id":"cloud-context/cloud-intro","title":"Temporal Cloud documentation","description":"Temporal Cloud documentation, including explanations and usage.","label":"Temporal Cloud","tags":["explanation"],"markdown_content":":::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\n- [Get started with Temporal Cloud](/cloud/how-to-get-started-with-temporal-cloud)\n- [Manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud)\n- [Manage Namespaces in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud)\n- [tcld (Temporal Cloud command-line interface)](/cloud/tcld)\n- [Temporal Cloud release notes](/cloud/release-notes)","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-cloud-account-id","node":{"file_name":"what-is-a-cloud-account-id.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-cloud-account-id.md","id":"concepts/what-is-a-cloud-account-id","title":"What is a Temporal Cloud Account Id?","description":"A Temporal Cloud Account Id is a unique identifier for a customer.","label":"Temporal Cloud Account Id","tags":["term","explanation"],"markdown_content":"A Temporal Cloud Account Id is a unique identifier for a customer for the entire time they use Temporal Cloud.\nTemporal Technologies assigns each Account Id, which is an opaque code of five or six alphanumeric characters, such as `f45a2`.","is_empty":false}},{"type":"h2","id":"cloud-context/what-are-the-account-level-roles-for-users-in-temporal-cloud","node":{"file_name":"what-are-the-account-level-roles-for-users-in-temporal-cloud.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/what-are-the-account-level-roles-for-users-in-temporal-cloud.md","id":"cloud-context/what-are-the-account-level-roles-for-users-in-temporal-cloud","title":"What are the account-level Roles for users in Temporal Cloud?","description":"Account-level Roles are Global Admin, Developer, and Read-Only.","label":"Account-level Roles","markdown_content":"When a Global Admin invites a user to join an account, the Global Admin selects one of the following Roles for that user:\n\n- **Global Admin**\n  - Has full administrative permissions across the account, including users and usage\n  - Has Namespace Admin [permissions](/cloud/#namespace-level-permissions) on all [Namespaces](/namespaces) in the account\n- **Developer**\n  - Can create and update Namespaces; has full control over [Workflows](/workflows)\n  - Has Namespace Admin permissions for each Namespace created by that user\n- **Read-Only:** Can only read information","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-cloud-namespace-name","node":{"file_name":"what-is-a-cloud-namespace-name.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-cloud-namespace-name.md","id":"concepts/what-is-a-cloud-namespace-name","title":"What is a Cloud Namespace Name?","description":"A Cloud Namespace Name is a customer-supplied name for a Namespace in Temporal Cloud.","label":"Temporal Cloud Namespace Name","tags":["term","explanation"],"markdown_content":"A Cloud Namespace Name is a customer-supplied name for a [Namespace](/namespaces) in Temporal Cloud.\nEach Namespace Name, such as `accounting-production`, is unique within the scope of a customer's account.\nIt cannot be changed after the Namespace is provisioned.\n\nEach Namespace Name must conform to the following rules:\n\n- A Namespace Name must contain at least 2 characters and no more than 34 characters.\n- A Namespace Name must begin with a letter, end with a letter or number, and contain only letters, numbers, and the hyphen (-) character.\n- Each hyphen (-) character must be immediately preceded _and_ followed by a letter or number; consecutive hyphens are not permitted.\n- All letters in a Namespace Name must be lowercase.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-cloud-namespace-id","node":{"file_name":"what-is-a-cloud-namespace-id.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-cloud-namespace-id.md","id":"concepts/what-is-a-cloud-namespace-id","title":"What is a Cloud Namespace Id?","description":"A Cloud Namespace Id is a globally unique identifier for a Namespace in Temporal Cloud.","label":"Temporal Cloud Namespace Id","tags":["term","explanation"],"markdown_content":"A Cloud Namespace Id is a globally unique identifier for a [Namespace](/namespaces) in Temporal Cloud.\nA Namespace Id is formed by concatenating the following:\n\n1. A [Namespace Name](#temporal-cloud-namespace-name)\n1. A period (.)\n1. The [Account Id](#temporal-cloud-account-id) to which the Namespace belongs\n\nFor example, for the Account Id `f45a2` and Namespace Name `accounting-production`, the Namespace Id is `accounting-production.f45a2`.","is_empty":false}},{"type":"h2","id":"cloud-context/what-are-the-namespace-level-permissions-for-users-in-temporal-cloud","node":{"file_name":"what-are-the-namespace-level-permissions-for-users-in-temporal-cloud.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/what-are-the-namespace-level-permissions-for-users-in-temporal-cloud.md","id":"cloud-context/what-are-the-namespace-level-permissions-for-users-in-temporal-cloud","title":"What are the Namespace-level permissions for users in Temporal Cloud?","description":"Namespace-level permissions are Namespace Admin, Write, and Read-Only.","label":"Namespace-level permissions","markdown_content":"A [Global Admin](/cloud/#account-level-roles) can assign permissions for any [Namespace](/namespaces) in an account.\nA Developer can assign permissions for a Namespace they create.\n\nFor a Namespace, a user can have one of the following permissions:\n\n- **Namespace Admin:** Can create and edit Namespaces; can create, rename, update, and delete [Workflows](/workflows)\n- **Write:** Can create, rename, update, and delete Workflows within the Namespace\n- **Read-Only:** Can only read information from the Namespace","is_empty":false}}],"link_index":[{"file_dir":"cloud","guide_id":"index","local_ref":"","node_id":"concepts/what-is-temporal-cloud"},{"file_dir":"cloud","guide_id":"index","local_ref":"temporal-cloud-account-id","node_id":"concepts/what-is-a-cloud-account-id"},{"file_dir":"cloud","guide_id":"index","local_ref":"account-level-roles","node_id":"cloud-context/what-are-the-account-level-roles-for-users-in-temporal-cloud"},{"file_dir":"cloud","guide_id":"index","local_ref":"temporal-cloud-namespace-name","node_id":"concepts/what-is-a-cloud-namespace-name"},{"file_dir":"cloud","guide_id":"index","local_ref":"temporal-cloud-namespace-id","node_id":"concepts/what-is-a-cloud-namespace-id"},{"file_dir":"cloud","guide_id":"index","local_ref":"namespace-level-permissions","node_id":"cloud-context/what-are-the-namespace-level-permissions-for-users-in-temporal-cloud"}],"markdown_content":"---\nid: index\ntitle: Temporal Cloud documentation\nsidebar_label: Temporal Cloud\ndescription: Temporal Cloud documentation, including explanations and usage.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\n[Temporal Cloud](https://temporal.io/cloud) is a managed, hosted Temporal environment that provides a platform for [Temporal Applications](/temporal/#temporal-application)an alternative to deploying and operating your own [Temporal Cluster](/clusters).\n\nTemporal Cloud is offered in units of isolation known as [Namespaces](/namespaces). You can provision and use one or more Cloud Namespaces. A typical use case is to use separate Namespaces as development, testing, integration, staging, and production environments for an application.\n\n:::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\n- [Get started with Temporal Cloud](/cloud/how-to-get-started-with-temporal-cloud)\n- [Manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud)\n- [Manage Namespaces in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud)\n- [tcld (Temporal Cloud command-line interface)](/cloud/tcld)\n- [Temporal Cloud release notes](/cloud/release-notes)\n\n## Temporal Cloud Account Id\n\nA Temporal Cloud Account Id is a unique identifier for a customer for the entire time they use Temporal Cloud.\nTemporal Technologies assigns each Account Id, which is an opaque code of five or six alphanumeric characters, such as `f45a2`.\n\n## Account-level Roles\n\nWhen a Global Admin invites a user to join an account, the Global Admin selects one of the following Roles for that user:\n\n- **Global Admin**\n  - Has full administrative permissions across the account, including users and usage\n  - Has Namespace Admin [permissions](/cloud/#namespace-level-permissions) on all [Namespaces](/namespaces) in the account\n- **Developer**\n  - Can create and update Namespaces; has full control over [Workflows](/workflows)\n  - Has Namespace Admin permissions for each Namespace created by that user\n- **Read-Only:** Can only read information\n\n## Temporal Cloud Namespace Name\n\nA Cloud Namespace Name is a customer-supplied name for a [Namespace](/namespaces) in Temporal Cloud.\nEach Namespace Name, such as `accounting-production`, is unique within the scope of a customer's account.\nIt cannot be changed after the Namespace is provisioned.\n\nEach Namespace Name must conform to the following rules:\n\n- A Namespace Name must contain at least 2 characters and no more than 34 characters.\n- A Namespace Name must begin with a letter, end with a letter or number, and contain only letters, numbers, and the hyphen (-) character.\n- Each hyphen (-) character must be immediately preceded _and_ followed by a letter or number; consecutive hyphens are not permitted.\n- All letters in a Namespace Name must be lowercase.\n\n## Temporal Cloud Namespace Id\n\nA Cloud Namespace Id is a globally unique identifier for a [Namespace](/namespaces) in Temporal Cloud.\nA Namespace Id is formed by concatenating the following:\n\n1. A [Namespace Name](#temporal-cloud-namespace-name)\n1. A period (.)\n1. The [Account Id](#temporal-cloud-account-id) to which the Namespace belongs\n\nFor example, for the Account Id `f45a2` and Namespace Name `accounting-production`, the Namespace Id is `accounting-production.f45a2`.\n\n## Namespace-level permissions\n\nA [Global Admin](/cloud/#account-level-roles) can assign permissions for any [Namespace](/namespaces) in an account.\nA Developer can assign permissions for a Namespace they create.\n\nFor a Namespace, a user can have one of the following permissions:\n\n- **Namespace Admin:** Can create and edit Namespaces; can create, rename, update, and delete [Workflows](/workflows)\n- **Write:** Can create, rename, update, and delete Workflows within the Namespace\n- **Read-Only:** Can only read information from the Namespace\n\n"},{"file_name":"clusters.md","id":"clusters","file_dir":"/","title":"Clusters","sidebar_label":"Clusters","description":"This guide provides a comprehensive overview of Temporal Clusters.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"concepts/what-is-a-temporal-cluster","node":{"file_name":"what-is-a-temporal-cluster.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-temporal-cluster.md","id":"concepts/what-is-a-temporal-cluster","title":"What is a Temporal Cluster?","description":"A Temporal Cluster is the Temporal Server paired with persistence.","label":"Temporal Cluster","tags":["term","explanation"],"markdown_content":"A Temporal Cluster is the group of services, known as the [Temporal Server](#temporal-server), combined with persistence stores, that together act as a component of the Temporal Platform.\n\n- [How to quickly install a Temporal Cluster for testing and development](/application-development/foundations#run-a-dev-cluster)\n- [Cluster deployment guide](/cluster-deployment-guide)\n\n![A Temporal Cluster (Server + persistence)](/diagrams/temporal-cluster.svg)\n\n### Persistence\n\nA Temporal Cluster's only required dependency for basic operation is a database.\nMultiple types of databases are supported.\n\n![Persistence](/diagrams/temporal-database.svg)\n\nThe database stores the following types of data:\n\n- Tasks: Tasks to be dispatched.\n- State of Workflow Executions:\n  - Execution table: A capture of the mutable state of Workflow Executions.\n  - History table: An append only log of Workflow Execution History Events.\n- Namespace metadata: Metadata of each Namespace in the Cluster.\n- Visibility data: Enables operations like \"show all running Workflow Executions\".\n  For production environments, we recommend using Elasticsearch.\n\nAn Elasticsearch database can be added to enable [Advanced Visibility](/visibility#advanced-visibility).\n\n#### Dependency versions\n\nTemporal tests compatibility by spanning the **minimum** and **maximum** stable non-EOL major versions for each supported database.\nAs of time of writing, these specific versions are used in our test pipelines and actively tested before we release any version of Temporal:\n\n- **Cassandra v3.11 and v4.0**\n- **PostgreSQL v10.18 and v13.4**\n- **MySQL v5.7 and v8.0** (specifically 8.0.19+ due to a bug)\n\nWe update these support ranges once a year.\nThe release notes of each Temporal Server declare when we plan to drop support for database versions reaching End of Life.\n\n- Because Temporal Server primarily relies on core database functionality, we do not expect compatibility to break often.\n  Temporal has no opinions on database upgrade paths; as long as you can upgrade your database according to each project's specifications, Temporal should work with any version within supported ranges.\n- We do not run tests with vendors like Vitess and CockroachDB, so you rely on their compatibility claims if you use them.\n  Feel free to discuss them with fellow users [in our forum](https://community.temporal.io/).\n- Temporal is [working on official SQLite v3.x persistence](https://github.com/temporalio/temporal/pulls?q=is%3Apr+sort%3Aupdated-desc+sqlite), but this is meant only for development and testing, not production usage.\n  Cassandra, MySQL, and PostgreSQL schemas are supported and thus can be used as the Server's database.\n\n### Monitoring and observation\n\nTemporal emits metrics by default in a format that is supported by Prometheus.\nMonitoring and observing those metrics is optional.\nAny software that can pull metrics that supports the same format could be used, but we ensure it works with Prometheus and Grafana versions only.\n\n- **Prometheus >= v2.0**\n- **Grafana >= v2.5**\n\n### Visibility\n\nTemporal has built-in [Visibility](/visibility#) features.\nTo enhance this feature, Temporal supports an [integration with Elasticsearch](/cluster-deployment-guide#elasticsearch).\n\n- Elasticsearch v7.10 is supported from Temporal version 1.7.0 onwards\n- Elasticsearch v6.8 is supported in all Temporal versions\n- Both versions are explicitly supported with AWS Elasticsearch\n\n### mTLS encryption\n\nTemporal supports Mutual Transport Layer Security (mTLS) as a method of encrypting network traffic between services within a Temporal Cluster, or between application processes and a Cluster.\n\nMutual TLS can be enabled in Temporals [TLS configuration](/references/configuration#tls).\nThis configuration can be passed through `WithConfig` or `WithConfigLoader`.\n\nThis configuration includes two sections that serve to separate intra-cluster and external traffic. That way, different certificates and settings can be used to encrypt each section of traffic:\n\n- `internode`: configuration for encrypting communication between nodes within the Cluster.\n- `frontend`: configuration for encrypting the Frontend's public endpoints\n\n### Temporal Client connections\n\nA client's network access can be limited by using certificates issued by a specific Certificate Authority (CA).\n\nTo restrict access to Temporal Cluster endpoints, use the `clientCAFiles` or `clientCAData` property and the `requireClientAuth` property.\nThese properties can be specified in both the `internode` and `frontend` sections of the [mTLS configuration](/references/configuration#tls).\n\n#### Server name specification\n\nSpecify the `serverName` in the `client` section of your mTLS configuration to prevent spoofing and [MITM attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack).\n\nEntering a value for `serverName` enables established connections to authenticate the endpoint.\nThis ensures that the server certificate presented to any connected client has the specified server name in its CN property.\n\nThis measure can be used for `internode` and `frontend` endpoints.\n\nFor more information on mTLS configuration, refer to our [TLS configuration guide](/references/configuration#tls).\n\n### Auth\n\n**Authentication** is the process of verifying users who want to access your application are actually the users you want accessing it.\n**Authorization** is the verification of applications and data that a user on your Cluster or application has access to.\n\nTemporal has several authentication protocols that can be set to restrict access to your data.\nThese protocols address three areas: servers, client connections, and users.\n\nServer attacks can be prevented by specifying `serverName` in the `client` section of your mTLS configuration.\nThis can be done for both `frontend` and `internode` endpoints.\n\nClient connections can be restricted to certain endpoints by requiring certificates from a specific CA.\nModify the `clientCaFiles`, `clientCaData`, and `requireClientAuth` properties in the `internode` and `frontend` sections of the mTLS configuration.\n\nUser access can be restricted through extensibility points and plugins.\nWhen implemented, the `frontend` invokes the plugin before executing the requested operation.\n\nTemporal offers two plugin interfaces for API call authentication and authorization.\n\n- [`ClaimMapper`](#claim-mapper)\n- [`Authorizer`](#authorizer-plugin)\n\nThe logic of both plugins can be customized to fit a variety of use cases.\nWhen provided, the frontend invokes the implementation of the plugins before running the requested operation.","is_empty":false}},{"type":"h2","id":"concepts/what-is-the-temporal-server","node":{"file_name":"what-is-the-temporal-server.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-the-temporal-server.md","id":"concepts/what-is-the-temporal-server","title":"What is the Temporal Server?","description":"The Temporal Server is a grouping of four horizontally scalable services.","label":"Temporal Server","tags":["term","explanation"],"markdown_content":"The Temporal Server consists of four independently scalable services:\n\n- Frontend gateway: for rate limiting, routing, authorizing.\n- History subsystem: maintains data (mutable state, queues, and timers).\n- Matching subsystem: hosts Task Queues for dispatching.\n- Worker Service: for internal background Workflows.\n\nFor example, a real-life production deployment can have 5 Frontend, 15 History, 17 Matching, and 3 Worker Services per cluster.\n\nThe Temporal Server services can run independently or be grouped together into shared processes on one or more physical or virtual machines.\nFor live (production) environments, we recommend that each service runs independently, because each one has different scaling requirements and troubleshooting becomes easier.\nThe History, Matching, and Worker Services can scale horizontally within a Cluster.\nThe Frontend Service scales differently than the others because it has no sharding or partitioning; it is just stateless.\n\nEach service is aware of the others, including scaled instances, through a membership protocol via [Ringpop](https://github.com/temporalio/ringpop-go).\n\n#### Versions and support\n\nAll Temporal Server releases abide by the [Semantic Versioning Specification](https://semver.org/).\n\nFairly precise upgrade paths and support have been established starting from Temporal `v1.7.0`.\n\nWe provide maintenance support for previously published minor and major versions by continuing to release critical bug fixes related to security, the prevention of data loss, and reliability, whenever they are found.\n\nWe aim to publish incremental upgrade guides for each minor and major version, which include specifics about dependency upgrades that we have tested for (such as Cassandra 3.0 -> 3.11).\n\nWe offer maintenance support of the last three **minor** versions after a release and do not plan to \"backport\" patches beyond that.\n\nWe offer maintenance support of **major** versions for at least 12 months after a GA release, and we provide at least 6 months' notice before EOL/deprecating support.\n\n#### Dependencies\n\nTemporal offers official support for, and is tested against, dependencies with the exact versions described in the `go.mod` file of the corresponding release tag.\n(For example, [v1.5.1](https://github.com/temporalio/temporal/tree/v1.5.1) dependencies are documented in [the go.mod for v1.5.1](https://github.com/temporalio/temporal/blob/v1.5.1/go.mod).)\n\n#### Frontend Service\n\nThe Frontend Service is a stateless gateway service that exposes a strongly typed [Proto API](https://github.com/temporalio/api/blob/master/temporal/api/workflowservice/v1/service.proto).\nThe Frontend Service is responsible for rate limiting, authorizing, validating, and routing all inbound calls.\n\n![Frontend Service](/diagrams/temporal-frontend-service.svg)\n\nTypes of inbound calls include the following:\n\n- Domain CRUD\n- External events\n- Worker polls\n- Visibility requests\n- Admin operations via [tctl](/tctl) (the Temporal CLI)\n- Calls from a remote Cluster related to [Multi-Cluster Replication](#multi-cluster-replication)\n\nEvery inbound request related to a Workflow Execution must have a Workflow Id, which is hashed for routing purposes.\nThe Frontend Service has access to the hash rings that maintain service membership information, including how many nodes (instances of each service) are in the Cluster.\n\nInbound call rate limiting is applied per host and per namespace.\n\nThe Frontend Service talks to the Matching Service, History Service, Worker Service, the database, and Elasticsearch (if in use).\n\n- It uses the grpcPort 7233 to host the service handler.\n- It uses port 6933 for membership-related communication.\n\n#### History Service\n\nThe History Service tracks the state of Workflow Executions.\n\n![History Service](/diagrams/temporal-history-service.svg)\n\nThe History Service scales horizontally via individual shards, configured during the Cluster's creation.\nThe number of shards remains static for the life of the Cluster (so you should plan to scale and over-provision).\n\nEach shard maintains data (routing identifiers, mutable state) and queues.\nA History shard maintains four types of queues:\n\n- Transfer queue: transfers internal tasks to the Matching Service.\n  Whenever a new Workflow Task needs to be scheduled, the History Service transactionally dispatches it to the Matching Service.\n- Timer queues: durably persists Timers.\n- Replicator queue: asynchronously replicates Workflow Executions from active Clusters to other passive Clusters (experimental Multi-Cluster feature).\n- Visibility queue: pushes data to the visibility index (Elasticsearch).\n\nThe History Service talks to the Matching Service and the database.\n\n- It uses grpcPort 7234 to host the service handler.\n- It uses port 6934 for membership-related communication.\n\n#### Matching Service\n\nThe Matching Service is responsible for hosting Task Queues for Task dispatching.\n\n![Matching Service](/diagrams/temporal-matching-service.svg)\n\nIt is responsible for matching Workers to Tasks and routing new Tasks to the appropriate queue.\nThis service can scale internally by having multiple instances.\n\nIt talks to the Frontend Service, History Service, and the database.\n\n- It uses grpcPort 7235 to host the service handler.\n- It uses port 6935 for membership related communication.\n\n#### Worker Service\n\nThe Worker Service runs background processing for the replication queue, system Workflows, and (in versions older than 1.5.0) the Kafka visibility processor.\n\n![Worker Service](/diagrams/temporal-worker-service.svg)\n\nIt talks to the Frontend Service.\n\n- It uses port 6939 for membership-related communication.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-retention-period","node":{"file_name":"what-is-a-retention-period.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-retention-period.md","id":"concepts/what-is-a-retention-period","title":"What is a Retention Period?","description":"A Retention Period is the amount of time a Workflow Execution Event History remains in the Cluster's persistence store.","label":"Retention Period","tags":["term","explanation"],"markdown_content":"A Retention Period is the amount of time a Workflow Execution Event History remains in the Cluster's persistence store.\n\n- [How to set the Retention Period for the Namespace](/tctl/namespace/register/#--retention)\n\nA Retention Period applies to a single [Namespace](/namespaces#) and is set when the Namespace is registered.\n\nIf the Retention Period isn't set, it defaults to 2 days.\nThe minimum Retention Period is 1 day.\nThe maximum Retention Period is 30 days.\nSetting the Retention Period to 0 results in the error _A valid retention period is not set on request_.","is_empty":false}},{"type":"h2","id":"concepts/what-is-archival","node":{"file_name":"what-is-archival.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-archival.md","id":"concepts/what-is-archival","title":"What is Archival?","description":"Archival is a feature that automatically backs up Event Histories from Temporal Cluster persistence to a custom blob store after the Closed Workflow Execution retention period is reached.","label":"Archival","tags":["term","explanation"],"markdown_content":"Archival is a feature that automatically backs up [Event Histories](/workflows#event-history) and Visibility records from Temporal Cluster persistence to a custom blob store.\n\n- [How to create a custom Archiver](/cluster-deployment-guide#custom-archiver)\n- [How to set up Archival](/cluster-deployment-guide#set-up-archival)\n\nWorkflow Execution Event Histories are backed up after the [Retention Period](/concepts/what-is-a-namespace/#retention-period) is reached.\nVisibility records are backed up immediately after a Workflow Execution reaches a Closed status.\n\nArchival enables Workflow Execution data to persist as long as needed, while not overwhelming the Cluster's persistence store.\n\nThis feature is helpful for compliance and debugging.\n\nTemporal's Archival feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nArchival is not supported when running Temporal via docker-compose and is disabled by default when installing the system manually and when deploying through [helm charts](https://github.com/temporalio/helm-charts/blob/master/templates/server-configmap.yaml) (but can be enabled in the [config](https://github.com/temporalio/temporal/blob/master/config/development.yaml)).","is_empty":false}},{"type":"h2","id":"concepts/what-is-multi-cluster-replication","node":{"file_name":"what-is-multi-cluster-replication.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-multi-cluster-replication.md","id":"concepts/what-is-multi-cluster-replication","title":"What is Multi-Cluster Replication?","description":"Multi-Cluster Replication is a feature which asynchronously replicates Workflow Executions from active Clusters to other passive Clusters, for backup and state reconstruction.","label":"Multi-Cluster Replication","tags":["term","explanation"],"markdown_content":"Multi-Cluster Replication is a feature which asynchronously replicates Workflow Executions from active Clusters to other passive Clusters, for backup and state reconstruction.\nWhen necessary, for higher availability, Cluster operators can failover to any of the backup Clusters.\n\nTemporal's Multi-Cluster Replication feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nTemporal automatically forwards Start, Signal, and Query requests to the active Cluster.\nThis feature must be enabled through a Dynamic Config flag per [Global Namespace](/namespaces#global-namespace).\n\nWhen the feature is enabled, Tasks are sent to the Parent Task Queue partition that matches that Namespace, if it exists.\n\nAll Visibility APIs can be used against active and standby Clusters.\nThis enables [Temporal Web](https://github.com/temporalio/temporal-web) to work seamlessly for Global Namespaces.\nApplications making API calls directly to the Temporal Visibility API continue to work even if a Global Namespace is in standby mode.\nHowever, they might see a lag due to replication delay when querying the Workflow execution state from a standby Cluster.\n\n#### Namespace Versions\n\nA _version_ is a concept in Multi-Cluster Replication that describes the chronological order of events per Namespace.\n\nWith Multi-Cluster Replication, all Namespace change events and Workflow Execution History events are replicated asynchronously for high throughput.\nThis means that data across clusters is **not** strongly consistent.\nTo guarantee that Namespace data and Workflow Execution data will achieve eventual consistency (especially when there is a data conflict during a failover), a **version** is introduced and attached to Namespaces.\nAll Workflow Execution History entries generated in a Namespace will also come with the version attached to that Namespace.\n\nAll participating Clusters are pre-configured with a unique initial version and a shared version increment:\n\n- `initial version < shared version increment`\n\nWhen performing failover for a Namespace from one Cluster to another Cluster, the version attached to the Namespace will be changed by the following rule:\n\n- for all versions which follow `version % (shared version increment) == (active cluster's initial version)`, find the smallest version which has `version >= old version in namespace`\n\nWhen there is a data conflict, a comparison will be made and Workflow Execution History entries with the highest version will be considered the source of truth.\n\nWhen a cluster is trying to mutate a Workflow Execution History, the version will be checked.\nA cluster can mutate a Workflow Execution History only if the following is true:\n\n- The version in the Namespace belongs to this cluster, i.e.\n  `(version in namespace) % (shared version increment) == (this cluster's initial version)`\n- The version of this Workflow Execution History's last entry (event) is equal or less than the version in the Namespace, i.e.\n  `(last event's version) <= (version in namespace)`\n\n<details>\n<summary>Namespace version change example\n</summary>\n\nAssuming the following scenario:\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: Namespace  is registered, with active Cluster set to Cluster A\n\n```\nnamespace 's version is 1\nall workflows events generated within this namespace, will come with version 1\n```\n\nT = 1: namespace  is registered, with active Cluster set to Cluster B\n\n```\nnamespace 's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 2: Namespace  is updated to with active Cluster set to Cluster B\n\n```\nnamespace 's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 3: Namespace  is updated to with active Cluster set to Cluster A\n\n```\nnamespace 's version is 11\nall workflows events generated within this namespace, will come with version 11\n```\n\n</details>\n\n#### Version history\n\nVersion history is a concept which provides a high level summary of version information in regards to Workflow Execution History.\n\nWhenever there is a new Workflow Execution History entry generated, the version from Namespace will be attached.\nThe Workflow Executions's mutable state will keep track of all history entries (events) and the corresponding version.\n\n<details>\n<summary>Version history example (without data conflict)\n</summary>\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: adding event with event ID == 1 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 1               | 1       |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 2 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 2: adding event with event ID == 3 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 3               | 1       |\n| 2        | 1             |                 |         |\n| 3        | 1             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 3: Namespace failover triggered, Namespace version is now 2\nadding event with event ID == 4 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 3               | 1       |\n| 2        | 1             | 4               | 2       |\n| 3        | 1             |                 |         |\n| 4        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 4: adding event with event ID == 5 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 3               | 1       |\n| 2        | 1             | 5               | 2       |\n| 3        | 1             |                 |         |\n| 4        | 2             |                 |         |\n| 5        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\n</details>\n\nSince Temporal is AP, during failover (change of active Temporal Cluster Namespace), there can exist cases where more than one Cluster can modify a Workflow Execution, causing divergence of Workflow Execution History. Below shows how the version history will look like under such conditions.\n\n<details>\n<summary>Version history example (with data conflict)\n</summary>\n\nBelow, shows version history of the same Workflow Execution in 2 different Clusters.\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Cluster C comes with initial version: 3\n- Shared version increment: 10\n\nT = 0:\n\nView in both Cluster B & C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             | 3               | 2       |\n| 3        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 4 & version == 2 in Cluster B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             | 4               | 2       |\n| 3        | 2             |                 |         |\n| 4        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 1: namespace failover to Cluster C, adding event with event ID == 4 & version == 3 in Cluster C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             | 3               | 2       |\n| 3        | 2             | 4               | 3       |\n| 4        | 3             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster C arrives in Cluster B\n\nNote: below are a tree structures\n\n```\n                | -------- | ------------- |\n                | Events                   |\n                | -------- | ------------- |\n                | Event ID | Event Version |\n                | -------- | ------------- |\n                | 1        | 1             |\n                | 2        | 1             |\n                | 3        | 2             |\n                | -------- | ------------- |\n                           |\n           | ------------- | ------------ |\n           |                              |\n| -------- | ------------- |   | -------- | ------------- |\n| Event ID | Event Version |   | Event ID | Event Version |\n| -------- | ------------- |   | -------- | ------------- |\n| 4        | 2             |   | 4        | 3             |\n| -------- | ------------- |   | -------- | ------------- |\n\n          | --------------- | ------- |\n          | Version History           |\n          | --------------- | ------- |\n          | Event ID        | Version |\n          | --------------- | ------- |\n          | 2               | 1       |\n          | 3               | 2       |\n          | --------------- | ------- |\n                            |\n                  | ------- | ------------------- |\n                  |                               |\n| --------------- | ------- |   | --------------- | ------- |\n| Event ID        | Version |   | Event ID        | Version |\n| --------------- | ------- |   | --------------- | ------- |\n| 4               | 2       |   | 4               | 3       |\n| --------------- | ------- |   | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster B arrives in Cluster C, same as above\n\n</details>\n\n#### Conflict resolution\n\nWhen a Workflow Execution History diverges, proper conflict resolution is applied.\n\nIn Multi-cluster Replication, Workflow Execution History Events are modeled as a tree, as shown in the second example in [Version History](#version-history).\n\nWorkflow Execution Histories that diverge will have more than one history branch.\nAmong all history branches, the history branch with the highest version is considered the `current branch` and the Workflow Execution's mutable state is a summary of the current branch.\nWhenever there is a switch between Workflow Execution History branches, a complete rebuild of the Workflow Execution's mutable state will occur.\n\nTemporal Multi-Cluster Replication relies on asynchronous replication of Events across Clusters, so in the case of a failover it is possible to have an Activity Task dispatched again to the newly active Cluster due to a replication task lag.\nThis also means that whenever a Workflow Execution is updated after a failover by the new Cluster, any previous replication tasks for that Execution cannot be applied.\nThis results in loss of some progress made by the Workflow Execution in the previous active Cluster.\nDuring such conflict resolution, Temporal re-injects any external Events like Signals in the new Event History before discarding replication tasks.\nEven though some progress could roll back during failovers, Temporal provides the guarantee that Workflow Executions wont get stuck and will continue to make forward progress.\n\nActivity Execution completions are not forwarded across Clusters.\nAny outstanding Activities will eventually time out based on the configuration.\nYour application should have retry logic in place so that the Activity gets retried and dispatched again to a Worker after the failover to the new Cluster.\nHandling this is similar to handling an Activity Task timeout caused by a Worker restarting.\n\n#### Zombie Workflows\n\nThere is an existing contract that for any Namespace and Workflow Id combination, there can be at most one run (Namespace + Workflow Id + Run Id) open / executing.\n\nMulti-cluster Replication aims to keep the Workflow Execution History as up-to-date as possible among all participating Clusters.\n\nDue to the nature of Multi-cluster Replication (for example, Workflow Execution History events are replicated asynchronously) different Runs (same Namespace and Workflow Id) can arrive at the target Cluster at different times, sometimes out of order, as shown below:\n\n```\n| ------------- |          | ------------- |          | ------------- |\n|   Cluster A   |          | Network Layer |          |   Cluster B   |\n| ------------- |          | ------------- |          | ------------- |\n        |                          |                          |\n        | Run 1 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        | Run 2 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          | Run 2 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n        |                          | Run 1 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n| ------------- |          | ------------- |          | ------------- |\n|   Cluster A   |          | Network Layer |          |   Cluster B   |\n| ------------- |          | ------------- |          | ------------- |\n```\n\nSince Run 2 appears in Cluster B first, Run 1 cannot be replicated as \"runnable\" due to the rule `at most one Run open` (see above), thus the \"zombie\" Workflow Execution state is introduced.\nA \"zombie\" state is one in which a Workflow Execution which cannot be actively mutated by a Cluster (assuming the corresponding Namespace is active in this Cluster). A zombie Workflow Execution can only be changed by a replication Task.\n\nRun 1 will be replicated similar to Run 2, except when Run 1's execution will become a \"zombie\" before Run 1 reaches completion.\n\n#### Workflow Task processing\n\nIn the context of Multi-cluster Replication, a Workflow Execution's mutable state is an entity which tracks all pending tasks.\nPrior to the introduction of Multi-cluster Replication, Workflow Execution History entries (events) are from a single branch, and the Temporal Server will only append new entries (events) to the Workflow Execution History.\n\nAfter the introduction of Multi-cluster Replication, it is possible that a Workflow Execution can have multiple Workflow Execution History branches.\nTasks generated according to one history branch may become invalidated by switching history branches during conflict resolution.\n\nExample:\n\nT = 0: task A is generated according to Event Id: 4, version: 2\n\n```\n| -------- | ------------- |\n| Events                   |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 1        | 1             |\n| 2        | 1             |\n| 3        | 2             |\n| -------- | ------------- |\n           |\n           |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event\n| -------- | ------------- |\n```\n\nT = 1: conflict resolution happens, Workflow Execution's mutable state is rebuilt and history Event Id: 4, version: 3 is written down to persistence\n\n```\n                | -------- | ------------- |\n                | Events                   |\n                | -------- | ------------- |\n                | Event ID | Event Version |\n                | -------- | ------------- |\n                | 1        | 1             |\n                | 2        | 1             |\n                | 3        | 2             |\n                | -------- | ------------- |\n                           |\n           | ------------- | -------------------------------------------- |\n           |                                                              |\n| -------- | ------------- |                                   | -------- | ------------- |\n| Event ID | Event Version |                                   | Event ID | Event Version |\n| -------- | ------------- |                                   | -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event  | 4        | 3             | <-- current branch / mutable state\n| -------- | ------------- |                                   | -------- | ------------- |\n```\n\nT = 2: task A is loaded.\n\nAt this time, due to the rebuild of a Workflow Execution's mutable state (conflict resolution), Task A is no longer relevant (Task A's corresponding Event belongs to non-current branch).\nTask processing logic will verify both the Event Id and version of the Task against a corresponding Workflow Execution's mutable state, then discard task A.","is_empty":false}},{"type":"h2","id":"concept-context/cluster-plugins","node":{"file_name":"cluster-plugins.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/concept-context/cluster-plugins.md","id":"concept-context/cluster-plugins","title":"Temporal Cluster plugins conceptual context","description":"Temporal Clusters support some pluggable components.","label":"Plugins","tags":["guide-context"],"markdown_content":"Temporal Clusters support some pluggable components.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-claimmapper-plugin","node":{"file_name":"what-is-a-claimmapper-plugin.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-claimmapper-plugin.md","id":"concepts/what-is-a-claimmapper-plugin","title":"What is a ClaimMapper Plugin?","description":"The Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).","label":"Claim Mapper","tags":["term"],"markdown_content":"The Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).\n\nThis process is achieved with the method `GetClaims`, which translates `AuthInfo` structs from the caller into `Claims` about the caller's roles within Temporal.\n\nA `Role` (within Temporal) is a bit mask that combines one or more of the role constants.\nIn the following example, the role is assigned constants that allow the caller to read and write information.\n\n```go\nrole := authorization.RoleReader | authorization.RoleWriter\n```\n\n`GetClaims` is customizable and can be modified with the `temporal.WithClaimMapper` server option.\nTemporal also offers a default JWT `ClaimMapper` for your use.\n\nA typical approach is for `ClaimMapper` to interpret custom `Claims` from a caller's JWT, such as membership in groups, and map them to Temporal roles for the user.\nThe subject information from the caller's mTLS certificate can also be a parameter in determining roles.\n\n#### `AuthInfo`\n\n`AuthInfo` is a struct that is passed to `GetClaims`. `AuthInfo` contains an authorization token extracted from the `authorization` header of the gRPC request.\n\n`AuthInfo` includes a pointer to the `pkix.Name` struct.\nThis struct contains an [x.509](https://www.ibm.com/docs/en/ibm-mq/7.5?topic=certificates-distinguished-names) Distinguished Name from the caller's mTLS certificate.\n\n#### `Claims`\n\n`Claims` is a struct that contains information about permission claims granted to the caller.\n\n`Authorizer` assumes that the caller has been properly authenticated, and trusts the `Claims` when making an authorization decision.\n\n#### Default JWT ClaimMapper\n\nTemporal offers a default JWT `ClaimMapper` that extracts the information needed to form Temporal `Claims`.\nThis plugin requires a public key to validate digital signatures.\n\nTo get an instance of the default JWT `ClaimMapper`, call `NewDefaultJWTClaimMapper` and provide it with the following:\n\n- a `TokenKeyProvider` instance\n- a `config.Authorization` pointer\n- a logger\n\nThe code for the default `ClaimMapper` can also be used to build a custom `ClaimMapper`.\n\n#### Token key provider\n\nA `TokenKeyProvider` obtains public keys from specified issuers' URIs that adhere to a specific format.\nThe default JWT `ClaimMapper` uses this component to obtain and refresh public keys over time.\n\nTemporal provides an `rsaTokenKeyProvider`.\nThis component dynamically obtains public keys that follow the [JWKS format](https://tools.ietf.org/html/rfc7517).\n`rsaTokenKeyProvider` uses only the `RSAKey` and `Close` methods.\n\n```go\nprovider := authorization.NewRSAKeyProvider(cfg)\n```\n\n:::note\n\n`KeySourceURIs` are the HTTP endpoints that return public keys of token issuers in the [JWKS format](https://tools.ietf.org/html/rfc7517).\n`RefreshInterval` defines how frequently keys should be refreshed.\nFor example, [Auth0](https://auth0.com/) exposes endpoints such as `https://YOUR_DOMAIN/.well-known/jwks.json`.\n\n:::\n\nBy default, \"permissions\" is used to name the `permissionsClaimName` value.\n\nConfigure the plugin with `config.Config.Global.Authorization.JWTKeyProvider`.\n\n#### JSON Web Token format\n\nThe default JWT `ClaimMapper` expects authorization tokens to be formatted as follows:\n\n```\nBearer <token>\n```\n\nThe Permissions Claim in the JWT Token is expected to be a collection of Individual Permission Claims.\nEach Individual Permission Claim must be formatted as follows:\n\n```\n<namespace> : <permission>\n```\n\nThese permissions are then converted into Temporal roles for the caller.\nThis can be one of Temporal's four values:\n\n- read\n- write\n- worker\n- admin\n\nMultiple permissions for the same Namespace are overridden by the `ClaimMapper`.\n\n##### Example of a payload for the default JWT ClaimMapper\n\n```\n{\n   \"permissions\":[\n      \"system:read\",\n      \"namespace1:write\"\n   ],\n   \"aud\":[\n      \"audience\"\n   ],\n   \"exp\":1630295722,\n   \"iss\":\"Issuer\"\n}\n```","is_empty":false}},{"type":"h3","id":"concepts/what-is-an-authorizer-plugin","node":{"file_name":"what-is-an-authorizer-plugin.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-authorizer-plugin.md","id":"concepts/what-is-an-authorizer-plugin","title":"What is an Authorizer Plugin?","label":"Authorizer Plugin","tags":["term"],"markdown_content":"The `Authorizer` plugin contains a single `Authorize` method, which is invoked for each incoming API call.\n`Authorize` receives information about the API call, along with the role and permission claims of the caller.\n\n`Authorizer` allows for a wide range of authorization logic, including call target, role/permissions claims, and other data available to the system.\n\n#### Configuration\n\nThe following arguments must be passed to `Authorizer`:\n\n- `context.Context`: General context of the call.\n- `authorization.Claims`: Claims about the roles assigned to the caller. Its intended use is described in the [`Claims`](#claims) section earlier on this page.\n- `authorization.CallTarget`: Target of the API call.\n\n`Authorizer` then returns one of two decisions:\n\n- `DecisionDeny`: the requested API call is not invoked and an error is returned to the caller.\n- `DecisionAllow`: the requested API call is invoked.\n\n:::warning\n\n`Authorizer` allows all API calls pass by default. Disable the `nopAuthority` authorizer and configure your own to prevent this behavior.\n\n:::\n\nConfigure your `Authorizer` when you start the server via the [`temporal.WithAuthorizer`](/references/server-options#withauthorizer) server option.\n\nIf an `Authorizer` is not set in the server options, Temporal uses the `nopAuthority` authorizer that unconditionally allows all API calls to pass through.\n\n```go\na := authorization.NewDefaultAuthorizer()\n```","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"clusters","local_ref":"","node_id":"concepts/what-is-a-temporal-cluster"},{"file_dir":"/","guide_id":"clusters","local_ref":"temporal-server","node_id":"concepts/what-is-the-temporal-server"},{"file_dir":"/","guide_id":"clusters","local_ref":"retention-period","node_id":"concepts/what-is-a-retention-period"},{"file_dir":"/","guide_id":"clusters","local_ref":"archival","node_id":"concepts/what-is-archival"},{"file_dir":"/","guide_id":"clusters","local_ref":"multi-cluster-replication","node_id":"concepts/what-is-multi-cluster-replication"},{"file_dir":"/","guide_id":"clusters","local_ref":"plugins","node_id":"concept-context/cluster-plugins"},{"file_dir":"/","guide_id":"clusters","local_ref":"claim-mapper","node_id":"concepts/what-is-a-claimmapper-plugin"},{"file_dir":"/","guide_id":"clusters","local_ref":"authorizer-plugin","node_id":"concepts/what-is-an-authorizer-plugin"}],"markdown_content":"---\nid: clusters\ntitle: Clusters\nsidebar_label: Clusters\ndescription: This guide provides a comprehensive overview of Temporal Clusters.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nThis guide provides a comprehensive overview of Temporal Clusters.\n\nA Temporal Cluster is the group of services, known as the [Temporal Server](#temporal-server), combined with persistence stores, that together act as a component of the Temporal Platform.\n\n- [How to quickly install a Temporal Cluster for testing and development](/application-development/foundations#run-a-dev-cluster)\n- [Cluster deployment guide](/cluster-deployment-guide)\n\n![A Temporal Cluster (Server + persistence)](/diagrams/temporal-cluster.svg)\n\n### Persistence\n\nA Temporal Cluster's only required dependency for basic operation is a database.\nMultiple types of databases are supported.\n\n![Persistence](/diagrams/temporal-database.svg)\n\nThe database stores the following types of data:\n\n- Tasks: Tasks to be dispatched.\n- State of Workflow Executions:\n  - Execution table: A capture of the mutable state of Workflow Executions.\n  - History table: An append only log of Workflow Execution History Events.\n- Namespace metadata: Metadata of each Namespace in the Cluster.\n- Visibility data: Enables operations like \"show all running Workflow Executions\".\n  For production environments, we recommend using Elasticsearch.\n\nAn Elasticsearch database can be added to enable [Advanced Visibility](/visibility#advanced-visibility).\n\n#### Dependency versions\n\nTemporal tests compatibility by spanning the **minimum** and **maximum** stable non-EOL major versions for each supported database.\nAs of time of writing, these specific versions are used in our test pipelines and actively tested before we release any version of Temporal:\n\n- **Cassandra v3.11 and v4.0**\n- **PostgreSQL v10.18 and v13.4**\n- **MySQL v5.7 and v8.0** (specifically 8.0.19+ due to a bug)\n\nWe update these support ranges once a year.\nThe release notes of each Temporal Server declare when we plan to drop support for database versions reaching End of Life.\n\n- Because Temporal Server primarily relies on core database functionality, we do not expect compatibility to break often.\n  Temporal has no opinions on database upgrade paths; as long as you can upgrade your database according to each project's specifications, Temporal should work with any version within supported ranges.\n- We do not run tests with vendors like Vitess and CockroachDB, so you rely on their compatibility claims if you use them.\n  Feel free to discuss them with fellow users [in our forum](https://community.temporal.io/).\n- Temporal is [working on official SQLite v3.x persistence](https://github.com/temporalio/temporal/pulls?q=is%3Apr+sort%3Aupdated-desc+sqlite), but this is meant only for development and testing, not production usage.\n  Cassandra, MySQL, and PostgreSQL schemas are supported and thus can be used as the Server's database.\n\n### Monitoring and observation\n\nTemporal emits metrics by default in a format that is supported by Prometheus.\nMonitoring and observing those metrics is optional.\nAny software that can pull metrics that supports the same format could be used, but we ensure it works with Prometheus and Grafana versions only.\n\n- **Prometheus >= v2.0**\n- **Grafana >= v2.5**\n\n### Visibility\n\nTemporal has built-in [Visibility](/visibility#) features.\nTo enhance this feature, Temporal supports an [integration with Elasticsearch](/cluster-deployment-guide#elasticsearch).\n\n- Elasticsearch v7.10 is supported from Temporal version 1.7.0 onwards\n- Elasticsearch v6.8 is supported in all Temporal versions\n- Both versions are explicitly supported with AWS Elasticsearch\n\n### mTLS encryption\n\nTemporal supports Mutual Transport Layer Security (mTLS) as a method of encrypting network traffic between services within a Temporal Cluster, or between application processes and a Cluster.\n\nMutual TLS can be enabled in Temporals [TLS configuration](/references/configuration#tls).\nThis configuration can be passed through `WithConfig` or `WithConfigLoader`.\n\nThis configuration includes two sections that serve to separate intra-cluster and external traffic. That way, different certificates and settings can be used to encrypt each section of traffic:\n\n- `internode`: configuration for encrypting communication between nodes within the Cluster.\n- `frontend`: configuration for encrypting the Frontend's public endpoints\n\n### Temporal Client connections\n\nA client's network access can be limited by using certificates issued by a specific Certificate Authority (CA).\n\nTo restrict access to Temporal Cluster endpoints, use the `clientCAFiles` or `clientCAData` property and the `requireClientAuth` property.\nThese properties can be specified in both the `internode` and `frontend` sections of the [mTLS configuration](/references/configuration#tls).\n\n#### Server name specification\n\nSpecify the `serverName` in the `client` section of your mTLS configuration to prevent spoofing and [MITM attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack).\n\nEntering a value for `serverName` enables established connections to authenticate the endpoint.\nThis ensures that the server certificate presented to any connected client has the specified server name in its CN property.\n\nThis measure can be used for `internode` and `frontend` endpoints.\n\nFor more information on mTLS configuration, refer to our [TLS configuration guide](/references/configuration#tls).\n\n### Auth\n\n**Authentication** is the process of verifying users who want to access your application are actually the users you want accessing it.\n**Authorization** is the verification of applications and data that a user on your Cluster or application has access to.\n\nTemporal has several authentication protocols that can be set to restrict access to your data.\nThese protocols address three areas: servers, client connections, and users.\n\nServer attacks can be prevented by specifying `serverName` in the `client` section of your mTLS configuration.\nThis can be done for both `frontend` and `internode` endpoints.\n\nClient connections can be restricted to certain endpoints by requiring certificates from a specific CA.\nModify the `clientCaFiles`, `clientCaData`, and `requireClientAuth` properties in the `internode` and `frontend` sections of the mTLS configuration.\n\nUser access can be restricted through extensibility points and plugins.\nWhen implemented, the `frontend` invokes the plugin before executing the requested operation.\n\nTemporal offers two plugin interfaces for API call authentication and authorization.\n\n- [`ClaimMapper`](#claim-mapper)\n- [`Authorizer`](#authorizer-plugin)\n\nThe logic of both plugins can be customized to fit a variety of use cases.\nWhen provided, the frontend invokes the implementation of the plugins before running the requested operation.\n\n## Temporal Server\n\nThe Temporal Server consists of four independently scalable services:\n\n- Frontend gateway: for rate limiting, routing, authorizing.\n- History subsystem: maintains data (mutable state, queues, and timers).\n- Matching subsystem: hosts Task Queues for dispatching.\n- Worker Service: for internal background Workflows.\n\nFor example, a real-life production deployment can have 5 Frontend, 15 History, 17 Matching, and 3 Worker Services per cluster.\n\nThe Temporal Server services can run independently or be grouped together into shared processes on one or more physical or virtual machines.\nFor live (production) environments, we recommend that each service runs independently, because each one has different scaling requirements and troubleshooting becomes easier.\nThe History, Matching, and Worker Services can scale horizontally within a Cluster.\nThe Frontend Service scales differently than the others because it has no sharding or partitioning; it is just stateless.\n\nEach service is aware of the others, including scaled instances, through a membership protocol via [Ringpop](https://github.com/temporalio/ringpop-go).\n\n#### Versions and support\n\nAll Temporal Server releases abide by the [Semantic Versioning Specification](https://semver.org/).\n\nFairly precise upgrade paths and support have been established starting from Temporal `v1.7.0`.\n\nWe provide maintenance support for previously published minor and major versions by continuing to release critical bug fixes related to security, the prevention of data loss, and reliability, whenever they are found.\n\nWe aim to publish incremental upgrade guides for each minor and major version, which include specifics about dependency upgrades that we have tested for (such as Cassandra 3.0 -> 3.11).\n\nWe offer maintenance support of the last three **minor** versions after a release and do not plan to \"backport\" patches beyond that.\n\nWe offer maintenance support of **major** versions for at least 12 months after a GA release, and we provide at least 6 months' notice before EOL/deprecating support.\n\n#### Dependencies\n\nTemporal offers official support for, and is tested against, dependencies with the exact versions described in the `go.mod` file of the corresponding release tag.\n(For example, [v1.5.1](https://github.com/temporalio/temporal/tree/v1.5.1) dependencies are documented in [the go.mod for v1.5.1](https://github.com/temporalio/temporal/blob/v1.5.1/go.mod).)\n\n#### Frontend Service\n\nThe Frontend Service is a stateless gateway service that exposes a strongly typed [Proto API](https://github.com/temporalio/api/blob/master/temporal/api/workflowservice/v1/service.proto).\nThe Frontend Service is responsible for rate limiting, authorizing, validating, and routing all inbound calls.\n\n![Frontend Service](/diagrams/temporal-frontend-service.svg)\n\nTypes of inbound calls include the following:\n\n- Domain CRUD\n- External events\n- Worker polls\n- Visibility requests\n- Admin operations via [tctl](/tctl) (the Temporal CLI)\n- Calls from a remote Cluster related to [Multi-Cluster Replication](#multi-cluster-replication)\n\nEvery inbound request related to a Workflow Execution must have a Workflow Id, which is hashed for routing purposes.\nThe Frontend Service has access to the hash rings that maintain service membership information, including how many nodes (instances of each service) are in the Cluster.\n\nInbound call rate limiting is applied per host and per namespace.\n\nThe Frontend Service talks to the Matching Service, History Service, Worker Service, the database, and Elasticsearch (if in use).\n\n- It uses the grpcPort 7233 to host the service handler.\n- It uses port 6933 for membership-related communication.\n\n#### History Service\n\nThe History Service tracks the state of Workflow Executions.\n\n![History Service](/diagrams/temporal-history-service.svg)\n\nThe History Service scales horizontally via individual shards, configured during the Cluster's creation.\nThe number of shards remains static for the life of the Cluster (so you should plan to scale and over-provision).\n\nEach shard maintains data (routing identifiers, mutable state) and queues.\nA History shard maintains four types of queues:\n\n- Transfer queue: transfers internal tasks to the Matching Service.\n  Whenever a new Workflow Task needs to be scheduled, the History Service transactionally dispatches it to the Matching Service.\n- Timer queues: durably persists Timers.\n- Replicator queue: asynchronously replicates Workflow Executions from active Clusters to other passive Clusters (experimental Multi-Cluster feature).\n- Visibility queue: pushes data to the visibility index (Elasticsearch).\n\nThe History Service talks to the Matching Service and the database.\n\n- It uses grpcPort 7234 to host the service handler.\n- It uses port 6934 for membership-related communication.\n\n#### Matching Service\n\nThe Matching Service is responsible for hosting Task Queues for Task dispatching.\n\n![Matching Service](/diagrams/temporal-matching-service.svg)\n\nIt is responsible for matching Workers to Tasks and routing new Tasks to the appropriate queue.\nThis service can scale internally by having multiple instances.\n\nIt talks to the Frontend Service, History Service, and the database.\n\n- It uses grpcPort 7235 to host the service handler.\n- It uses port 6935 for membership related communication.\n\n#### Worker Service\n\nThe Worker Service runs background processing for the replication queue, system Workflows, and (in versions older than 1.5.0) the Kafka visibility processor.\n\n![Worker Service](/diagrams/temporal-worker-service.svg)\n\nIt talks to the Frontend Service.\n\n- It uses port 6939 for membership-related communication.\n\n### Retention Period\n\nA Retention Period is the amount of time a Workflow Execution Event History remains in the Cluster's persistence store.\n\n- [How to set the Retention Period for the Namespace](/tctl/namespace/register/#--retention)\n\nA Retention Period applies to a single [Namespace](/namespaces#) and is set when the Namespace is registered.\n\nIf the Retention Period isn't set, it defaults to 2 days.\nThe minimum Retention Period is 1 day.\nThe maximum Retention Period is 30 days.\nSetting the Retention Period to 0 results in the error _A valid retention period is not set on request_.\n\n## Archival\n\nArchival is a feature that automatically backs up [Event Histories](/workflows#event-history) and Visibility records from Temporal Cluster persistence to a custom blob store.\n\n- [How to create a custom Archiver](/cluster-deployment-guide#custom-archiver)\n- [How to set up Archival](/cluster-deployment-guide#set-up-archival)\n\nWorkflow Execution Event Histories are backed up after the [Retention Period](/concepts/what-is-a-namespace/#retention-period) is reached.\nVisibility records are backed up immediately after a Workflow Execution reaches a Closed status.\n\nArchival enables Workflow Execution data to persist as long as needed, while not overwhelming the Cluster's persistence store.\n\nThis feature is helpful for compliance and debugging.\n\nTemporal's Archival feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nArchival is not supported when running Temporal via docker-compose and is disabled by default when installing the system manually and when deploying through [helm charts](https://github.com/temporalio/helm-charts/blob/master/templates/server-configmap.yaml) (but can be enabled in the [config](https://github.com/temporalio/temporal/blob/master/config/development.yaml)).\n\n## Multi-Cluster Replication\n\nMulti-Cluster Replication is a feature which asynchronously replicates Workflow Executions from active Clusters to other passive Clusters, for backup and state reconstruction.\nWhen necessary, for higher availability, Cluster operators can failover to any of the backup Clusters.\n\nTemporal's Multi-Cluster Replication feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nTemporal automatically forwards Start, Signal, and Query requests to the active Cluster.\nThis feature must be enabled through a Dynamic Config flag per [Global Namespace](/namespaces#global-namespace).\n\nWhen the feature is enabled, Tasks are sent to the Parent Task Queue partition that matches that Namespace, if it exists.\n\nAll Visibility APIs can be used against active and standby Clusters.\nThis enables [Temporal Web](https://github.com/temporalio/temporal-web) to work seamlessly for Global Namespaces.\nApplications making API calls directly to the Temporal Visibility API continue to work even if a Global Namespace is in standby mode.\nHowever, they might see a lag due to replication delay when querying the Workflow execution state from a standby Cluster.\n\n#### Namespace Versions\n\nA _version_ is a concept in Multi-Cluster Replication that describes the chronological order of events per Namespace.\n\nWith Multi-Cluster Replication, all Namespace change events and Workflow Execution History events are replicated asynchronously for high throughput.\nThis means that data across clusters is **not** strongly consistent.\nTo guarantee that Namespace data and Workflow Execution data will achieve eventual consistency (especially when there is a data conflict during a failover), a **version** is introduced and attached to Namespaces.\nAll Workflow Execution History entries generated in a Namespace will also come with the version attached to that Namespace.\n\nAll participating Clusters are pre-configured with a unique initial version and a shared version increment:\n\n- `initial version < shared version increment`\n\nWhen performing failover for a Namespace from one Cluster to another Cluster, the version attached to the Namespace will be changed by the following rule:\n\n- for all versions which follow `version % (shared version increment) == (active cluster's initial version)`, find the smallest version which has `version >= old version in namespace`\n\nWhen there is a data conflict, a comparison will be made and Workflow Execution History entries with the highest version will be considered the source of truth.\n\nWhen a cluster is trying to mutate a Workflow Execution History, the version will be checked.\nA cluster can mutate a Workflow Execution History only if the following is true:\n\n- The version in the Namespace belongs to this cluster, i.e.\n  `(version in namespace) % (shared version increment) == (this cluster's initial version)`\n- The version of this Workflow Execution History's last entry (event) is equal or less than the version in the Namespace, i.e.\n  `(last event's version) <= (version in namespace)`\n\n<details>\n<summary>Namespace version change example\n</summary>\n\nAssuming the following scenario:\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: Namespace  is registered, with active Cluster set to Cluster A\n\n```\nnamespace 's version is 1\nall workflows events generated within this namespace, will come with version 1\n```\n\nT = 1: namespace  is registered, with active Cluster set to Cluster B\n\n```\nnamespace 's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 2: Namespace  is updated to with active Cluster set to Cluster B\n\n```\nnamespace 's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 3: Namespace  is updated to with active Cluster set to Cluster A\n\n```\nnamespace 's version is 11\nall workflows events generated within this namespace, will come with version 11\n```\n\n</details>\n\n#### Version history\n\nVersion history is a concept which provides a high level summary of version information in regards to Workflow Execution History.\n\nWhenever there is a new Workflow Execution History entry generated, the version from Namespace will be attached.\nThe Workflow Executions's mutable state will keep track of all history entries (events) and the corresponding version.\n\n<details>\n<summary>Version history example (without data conflict)\n</summary>\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: adding event with event ID == 1 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 1               | 1       |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 2 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 2: adding event with event ID == 3 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 3               | 1       |\n| 2        | 1             |                 |         |\n| 3        | 1             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 3: Namespace failover triggered, Namespace version is now 2\nadding event with event ID == 4 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 3               | 1       |\n| 2        | 1             | 4               | 2       |\n| 3        | 1             |                 |         |\n| 4        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 4: adding event with event ID == 5 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 3               | 1       |\n| 2        | 1             | 5               | 2       |\n| 3        | 1             |                 |         |\n| 4        | 2             |                 |         |\n| 5        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\n</details>\n\nSince Temporal is AP, during failover (change of active Temporal Cluster Namespace), there can exist cases where more than one Cluster can modify a Workflow Execution, causing divergence of Workflow Execution History. Below shows how the version history will look like under such conditions.\n\n<details>\n<summary>Version history example (with data conflict)\n</summary>\n\nBelow, shows version history of the same Workflow Execution in 2 different Clusters.\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Cluster C comes with initial version: 3\n- Shared version increment: 10\n\nT = 0:\n\nView in both Cluster B & C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             | 3               | 2       |\n| 3        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 4 & version == 2 in Cluster B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             | 4               | 2       |\n| 3        | 2             |                 |         |\n| 4        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 1: namespace failover to Cluster C, adding event with event ID == 4 & version == 3 in Cluster C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             | 3               | 2       |\n| 3        | 2             | 4               | 3       |\n| 4        | 3             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster C arrives in Cluster B\n\nNote: below are a tree structures\n\n```\n                | -------- | ------------- |\n                | Events                   |\n                | -------- | ------------- |\n                | Event ID | Event Version |\n                | -------- | ------------- |\n                | 1        | 1             |\n                | 2        | 1             |\n                | 3        | 2             |\n                | -------- | ------------- |\n                           |\n           | ------------- | ------------ |\n           |                              |\n| -------- | ------------- |   | -------- | ------------- |\n| Event ID | Event Version |   | Event ID | Event Version |\n| -------- | ------------- |   | -------- | ------------- |\n| 4        | 2             |   | 4        | 3             |\n| -------- | ------------- |   | -------- | ------------- |\n\n          | --------------- | ------- |\n          | Version History           |\n          | --------------- | ------- |\n          | Event ID        | Version |\n          | --------------- | ------- |\n          | 2               | 1       |\n          | 3               | 2       |\n          | --------------- | ------- |\n                            |\n                  | ------- | ------------------- |\n                  |                               |\n| --------------- | ------- |   | --------------- | ------- |\n| Event ID        | Version |   | Event ID        | Version |\n| --------------- | ------- |   | --------------- | ------- |\n| 4               | 2       |   | 4               | 3       |\n| --------------- | ------- |   | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster B arrives in Cluster C, same as above\n\n</details>\n\n#### Conflict resolution\n\nWhen a Workflow Execution History diverges, proper conflict resolution is applied.\n\nIn Multi-cluster Replication, Workflow Execution History Events are modeled as a tree, as shown in the second example in [Version History](#version-history).\n\nWorkflow Execution Histories that diverge will have more than one history branch.\nAmong all history branches, the history branch with the highest version is considered the `current branch` and the Workflow Execution's mutable state is a summary of the current branch.\nWhenever there is a switch between Workflow Execution History branches, a complete rebuild of the Workflow Execution's mutable state will occur.\n\nTemporal Multi-Cluster Replication relies on asynchronous replication of Events across Clusters, so in the case of a failover it is possible to have an Activity Task dispatched again to the newly active Cluster due to a replication task lag.\nThis also means that whenever a Workflow Execution is updated after a failover by the new Cluster, any previous replication tasks for that Execution cannot be applied.\nThis results in loss of some progress made by the Workflow Execution in the previous active Cluster.\nDuring such conflict resolution, Temporal re-injects any external Events like Signals in the new Event History before discarding replication tasks.\nEven though some progress could roll back during failovers, Temporal provides the guarantee that Workflow Executions wont get stuck and will continue to make forward progress.\n\nActivity Execution completions are not forwarded across Clusters.\nAny outstanding Activities will eventually time out based on the configuration.\nYour application should have retry logic in place so that the Activity gets retried and dispatched again to a Worker after the failover to the new Cluster.\nHandling this is similar to handling an Activity Task timeout caused by a Worker restarting.\n\n#### Zombie Workflows\n\nThere is an existing contract that for any Namespace and Workflow Id combination, there can be at most one run (Namespace + Workflow Id + Run Id) open / executing.\n\nMulti-cluster Replication aims to keep the Workflow Execution History as up-to-date as possible among all participating Clusters.\n\nDue to the nature of Multi-cluster Replication (for example, Workflow Execution History events are replicated asynchronously) different Runs (same Namespace and Workflow Id) can arrive at the target Cluster at different times, sometimes out of order, as shown below:\n\n```\n| ------------- |          | ------------- |          | ------------- |\n|   Cluster A   |          | Network Layer |          |   Cluster B   |\n| ------------- |          | ------------- |          | ------------- |\n        |                          |                          |\n        | Run 1 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        | Run 2 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          | Run 2 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n        |                          | Run 1 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n| ------------- |          | ------------- |          | ------------- |\n|   Cluster A   |          | Network Layer |          |   Cluster B   |\n| ------------- |          | ------------- |          | ------------- |\n```\n\nSince Run 2 appears in Cluster B first, Run 1 cannot be replicated as \"runnable\" due to the rule `at most one Run open` (see above), thus the \"zombie\" Workflow Execution state is introduced.\nA \"zombie\" state is one in which a Workflow Execution which cannot be actively mutated by a Cluster (assuming the corresponding Namespace is active in this Cluster). A zombie Workflow Execution can only be changed by a replication Task.\n\nRun 1 will be replicated similar to Run 2, except when Run 1's execution will become a \"zombie\" before Run 1 reaches completion.\n\n#### Workflow Task processing\n\nIn the context of Multi-cluster Replication, a Workflow Execution's mutable state is an entity which tracks all pending tasks.\nPrior to the introduction of Multi-cluster Replication, Workflow Execution History entries (events) are from a single branch, and the Temporal Server will only append new entries (events) to the Workflow Execution History.\n\nAfter the introduction of Multi-cluster Replication, it is possible that a Workflow Execution can have multiple Workflow Execution History branches.\nTasks generated according to one history branch may become invalidated by switching history branches during conflict resolution.\n\nExample:\n\nT = 0: task A is generated according to Event Id: 4, version: 2\n\n```\n| -------- | ------------- |\n| Events                   |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 1        | 1             |\n| 2        | 1             |\n| 3        | 2             |\n| -------- | ------------- |\n           |\n           |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event\n| -------- | ------------- |\n```\n\nT = 1: conflict resolution happens, Workflow Execution's mutable state is rebuilt and history Event Id: 4, version: 3 is written down to persistence\n\n```\n                | -------- | ------------- |\n                | Events                   |\n                | -------- | ------------- |\n                | Event ID | Event Version |\n                | -------- | ------------- |\n                | 1        | 1             |\n                | 2        | 1             |\n                | 3        | 2             |\n                | -------- | ------------- |\n                           |\n           | ------------- | -------------------------------------------- |\n           |                                                              |\n| -------- | ------------- |                                   | -------- | ------------- |\n| Event ID | Event Version |                                   | Event ID | Event Version |\n| -------- | ------------- |                                   | -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event  | 4        | 3             | <-- current branch / mutable state\n| -------- | ------------- |                                   | -------- | ------------- |\n```\n\nT = 2: task A is loaded.\n\nAt this time, due to the rebuild of a Workflow Execution's mutable state (conflict resolution), Task A is no longer relevant (Task A's corresponding Event belongs to non-current branch).\nTask processing logic will verify both the Event Id and version of the Task against a corresponding Workflow Execution's mutable state, then discard task A.\n\n## Plugins\n\nTemporal Clusters support some pluggable components.\n\n### Claim Mapper\n\nThe Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).\n\nThis process is achieved with the method `GetClaims`, which translates `AuthInfo` structs from the caller into `Claims` about the caller's roles within Temporal.\n\nA `Role` (within Temporal) is a bit mask that combines one or more of the role constants.\nIn the following example, the role is assigned constants that allow the caller to read and write information.\n\n```go\nrole := authorization.RoleReader | authorization.RoleWriter\n```\n\n`GetClaims` is customizable and can be modified with the `temporal.WithClaimMapper` server option.\nTemporal also offers a default JWT `ClaimMapper` for your use.\n\nA typical approach is for `ClaimMapper` to interpret custom `Claims` from a caller's JWT, such as membership in groups, and map them to Temporal roles for the user.\nThe subject information from the caller's mTLS certificate can also be a parameter in determining roles.\n\n#### `AuthInfo`\n\n`AuthInfo` is a struct that is passed to `GetClaims`. `AuthInfo` contains an authorization token extracted from the `authorization` header of the gRPC request.\n\n`AuthInfo` includes a pointer to the `pkix.Name` struct.\nThis struct contains an [x.509](https://www.ibm.com/docs/en/ibm-mq/7.5?topic=certificates-distinguished-names) Distinguished Name from the caller's mTLS certificate.\n\n#### `Claims`\n\n`Claims` is a struct that contains information about permission claims granted to the caller.\n\n`Authorizer` assumes that the caller has been properly authenticated, and trusts the `Claims` when making an authorization decision.\n\n#### Default JWT ClaimMapper\n\nTemporal offers a default JWT `ClaimMapper` that extracts the information needed to form Temporal `Claims`.\nThis plugin requires a public key to validate digital signatures.\n\nTo get an instance of the default JWT `ClaimMapper`, call `NewDefaultJWTClaimMapper` and provide it with the following:\n\n- a `TokenKeyProvider` instance\n- a `config.Authorization` pointer\n- a logger\n\nThe code for the default `ClaimMapper` can also be used to build a custom `ClaimMapper`.\n\n#### Token key provider\n\nA `TokenKeyProvider` obtains public keys from specified issuers' URIs that adhere to a specific format.\nThe default JWT `ClaimMapper` uses this component to obtain and refresh public keys over time.\n\nTemporal provides an `rsaTokenKeyProvider`.\nThis component dynamically obtains public keys that follow the [JWKS format](https://tools.ietf.org/html/rfc7517).\n`rsaTokenKeyProvider` uses only the `RSAKey` and `Close` methods.\n\n```go\nprovider := authorization.NewRSAKeyProvider(cfg)\n```\n\n:::note\n\n`KeySourceURIs` are the HTTP endpoints that return public keys of token issuers in the [JWKS format](https://tools.ietf.org/html/rfc7517).\n`RefreshInterval` defines how frequently keys should be refreshed.\nFor example, [Auth0](https://auth0.com/) exposes endpoints such as `https://YOUR_DOMAIN/.well-known/jwks.json`.\n\n:::\n\nBy default, \"permissions\" is used to name the `permissionsClaimName` value.\n\nConfigure the plugin with `config.Config.Global.Authorization.JWTKeyProvider`.\n\n#### JSON Web Token format\n\nThe default JWT `ClaimMapper` expects authorization tokens to be formatted as follows:\n\n```\nBearer <token>\n```\n\nThe Permissions Claim in the JWT Token is expected to be a collection of Individual Permission Claims.\nEach Individual Permission Claim must be formatted as follows:\n\n```\n<namespace> : <permission>\n```\n\nThese permissions are then converted into Temporal roles for the caller.\nThis can be one of Temporal's four values:\n\n- read\n- write\n- worker\n- admin\n\nMultiple permissions for the same Namespace are overridden by the `ClaimMapper`.\n\n##### Example of a payload for the default JWT ClaimMapper\n\n```\n{\n   \"permissions\":[\n      \"system:read\",\n      \"namespace1:write\"\n   ],\n   \"aud\":[\n      \"audience\"\n   ],\n   \"exp\":1630295722,\n   \"iss\":\"Issuer\"\n}\n```\n\n### Authorizer Plugin\n\nThe `Authorizer` plugin contains a single `Authorize` method, which is invoked for each incoming API call.\n`Authorize` receives information about the API call, along with the role and permission claims of the caller.\n\n`Authorizer` allows for a wide range of authorization logic, including call target, role/permissions claims, and other data available to the system.\n\n#### Configuration\n\nThe following arguments must be passed to `Authorizer`:\n\n- `context.Context`: General context of the call.\n- `authorization.Claims`: Claims about the roles assigned to the caller. Its intended use is described in the [`Claims`](#claims) section earlier on this page.\n- `authorization.CallTarget`: Target of the API call.\n\n`Authorizer` then returns one of two decisions:\n\n- `DecisionDeny`: the requested API call is not invoked and an error is returned to the caller.\n- `DecisionAllow`: the requested API call is invoked.\n\n:::warning\n\n`Authorizer` allows all API calls pass by default. Disable the `nopAuthority` authorizer and configure your own to prevent this behavior.\n\n:::\n\nConfigure your `Authorizer` when you start the server via the [`temporal.WithAuthorizer`](/references/server-options#withauthorizer) server option.\n\nIf an `Authorizer` is not set in the server options, Temporal uses the `nopAuthority` authorizer that unconditionally allows all API calls to pass through.\n\n```go\na := authorization.NewDefaultAuthorizer()\n```\n\n"},{"file_name":"namespaces.md","id":"namespaces","file_dir":"/","title":"Namespaces","sidebar_label":"Namespaces","description":"This guide provides a comprehensive overview of Namespaces.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":false,"sections":[{"type":"p","id":"concepts/what-is-a-namespace","node":{"file_name":"what-is-a-namespace.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-namespace.md","id":"concepts/what-is-a-namespace","title":"What is a Namespace?","description":"A Namespace is a unit of isolation within the Temporal Platform","label":"Namespace","tags":["term","explanation"],"markdown_content":"A Namespace is a unit of isolation within the Temporal Platform.\n\n- [How to list Namespaces in a Cluster using tctl](/tctl/namespace/list)\n- [How to register a new Namespace using tctl](/tctl/namespace/register)\n- [How to set the Namespace for a Temporal Client](/application-development/foundations#set-namespace)\n- [How to view (describe) Namespace metadata and details using tctl](/tctl/namespace/describe)\n\nA single Namespace is still multi-tenant.\nYou can use Namespaces to match the development lifecycle; for example, having separate `dev` and `prod` Namespaces.\nOr you could use them to ensure Workflow Executions between different teams never communicate; such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.\n\n- If no other Namespace is specified, the Temporal Cluster uses the Namespace \"default\" for all Temporal SDKs and tctl.\n  - If you are deploying through Docker Compose or using the [auto-setup image](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) in a custom Docker Compose application, the Namespace \"default\" is created, through the auto-setup script.\n  - If you are deploying through the [Temporal Helm charts](https://github.com/temporalio/helm-charts), you can create the \"default\" Namespace by using tctl; for example, `tctl namespace default`.\n    We recommend using the default Namespace if you arent using multiple Namespaces.\n- **Case Insensitive**: Because of DNS, Namespaces are case insensitive on the network and routing side.\n  We recommend using lowercase for namespace names to avoid potential issues.\n- **Membership**: [Task Queue](/tasks#task-queue) names and [Workflow Ids](/workflows#workflow-id) must all correspond to a specific Namespace.\n  For example, when a Workflow Execution is spawned, it does so within a specific Namespace.\n- **Uniqueness**: Temporal guarantees a unique Workflow Id within a Namespace.\n  Workflow Executions may have the same Workflow Id if they are in different Namespaces.\n- **Namespace Configuration**: Various configuration options like the retention period and the [Archival](/clusters#archival) destination are configured per Namespace through a special CRUD API or through [`tctl`](/tctl).","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-global-namespace","node":{"file_name":"what-is-a-global-namespace.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-global-namespace.md","id":"concepts/what-is-a-global-namespace","title":"What is a Global Namespace?","description":"A Global Namespace is a Namespace that exists across Clusters when Multi-Cluster Replication is set up.","label":"Global Namespace","tags":["term","explanation"],"markdown_content":"A Global Namespace is a [Namespace](#) that exists across Clusters when [Multi-Cluster Replication](/clusters#multi-cluster-replication) is set up.\n\n- [How to register a Global Namespace](/tctl/namespace/register/#--global-namespace)\n- [How to change the active Cluster for a Global Namespace](/tctl/namespace/update/#--active-cluster)\n\nThe Global Namespace feature enables Workflow Executions to progress through another Cluster in the event of a failover.\n\nA Global Namespace may be replicated to any number of Clusters, but is active in only one Cluster at any given time.\n\nFor a failover to be successful, Worker Processes must be polling for Tasks for the Global Namespace on all Clusters.\n\nA Global Namespace has a failover version.\nBecause a failover can be triggered from any Cluster, the failover version prevents certain conflicts from occurring if a failover is mistakenly triggered simultaneously on two Clusters.\n\nOnly the active Cluster dispatches [Tasks](/tasks#); however, certain conflicts are possible.\nUnlike regular Namespaces, which provide at-most-once semantics for an Activity Execution, Global Namespaces can support only at-least-once semantics (see [Conflict resolution](/concepts/what-is-multi-cluster-replication/#conflict-resolution)).\nWorker Processes on the standby Clusters are idle until a failover occurs and their Cluster becomes active.\n\nTemporal Application API calls made to a non-active Cluster are rejected with a **NamespaceNotActiveError** which contains the name of the current active Cluster.\nIt is the responsibility of the Temporal Application to call the Cluster that is currently active.","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"namespaces","local_ref":"","node_id":"concepts/what-is-a-namespace"},{"file_dir":"/","guide_id":"namespaces","local_ref":"global-namespace","node_id":"concepts/what-is-a-global-namespace"}],"markdown_content":"---\nid: namespaces\ntitle: Namespaces\nsidebar_label: Namespaces\ndescription: This guide provides a comprehensive overview of Namespaces.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nThis guide provides a comprehensive overview of Namespaces.\n\nA Namespace is a unit of isolation within the Temporal Platform.\n\n- [How to list Namespaces in a Cluster using tctl](/tctl/namespace/list)\n- [How to register a new Namespace using tctl](/tctl/namespace/register)\n- [How to set the Namespace for a Temporal Client](/application-development/foundations#set-namespace)\n- [How to view (describe) Namespace metadata and details using tctl](/tctl/namespace/describe)\n\nA single Namespace is still multi-tenant.\nYou can use Namespaces to match the development lifecycle; for example, having separate `dev` and `prod` Namespaces.\nOr you could use them to ensure Workflow Executions between different teams never communicate; such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.\n\n- If no other Namespace is specified, the Temporal Cluster uses the Namespace \"default\" for all Temporal SDKs and tctl.\n  - If you are deploying through Docker Compose or using the [auto-setup image](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) in a custom Docker Compose application, the Namespace \"default\" is created, through the auto-setup script.\n  - If you are deploying through the [Temporal Helm charts](https://github.com/temporalio/helm-charts), you can create the \"default\" Namespace by using tctl; for example, `tctl namespace default`.\n    We recommend using the default Namespace if you arent using multiple Namespaces.\n- **Case Insensitive**: Because of DNS, Namespaces are case insensitive on the network and routing side.\n  We recommend using lowercase for namespace names to avoid potential issues.\n- **Membership**: [Task Queue](/tasks#task-queue) names and [Workflow Ids](/workflows#workflow-id) must all correspond to a specific Namespace.\n  For example, when a Workflow Execution is spawned, it does so within a specific Namespace.\n- **Uniqueness**: Temporal guarantees a unique Workflow Id within a Namespace.\n  Workflow Executions may have the same Workflow Id if they are in different Namespaces.\n- **Namespace Configuration**: Various configuration options like the retention period and the [Archival](/clusters#archival) destination are configured per Namespace through a special CRUD API or through [`tctl`](/tctl).\n\n## Global Namespace\n\nA Global Namespace is a [Namespace](#) that exists across Clusters when [Multi-Cluster Replication](/clusters#multi-cluster-replication) is set up.\n\n- [How to register a Global Namespace](/tctl/namespace/register/#--global-namespace)\n- [How to change the active Cluster for a Global Namespace](/tctl/namespace/update/#--active-cluster)\n\nThe Global Namespace feature enables Workflow Executions to progress through another Cluster in the event of a failover.\n\nA Global Namespace may be replicated to any number of Clusters, but is active in only one Cluster at any given time.\n\nFor a failover to be successful, Worker Processes must be polling for Tasks for the Global Namespace on all Clusters.\n\nA Global Namespace has a failover version.\nBecause a failover can be triggered from any Cluster, the failover version prevents certain conflicts from occurring if a failover is mistakenly triggered simultaneously on two Clusters.\n\nOnly the active Cluster dispatches [Tasks](/tasks#); however, certain conflicts are possible.\nUnlike regular Namespaces, which provide at-most-once semantics for an Activity Execution, Global Namespaces can support only at-least-once semantics (see [Conflict resolution](/concepts/what-is-multi-cluster-replication/#conflict-resolution)).\nWorker Processes on the standby Clusters are idle until a failover occurs and their Cluster becomes active.\n\nTemporal Application API calls made to a non-active Cluster are rejected with a **NamespaceNotActiveError** which contains the name of the current active Cluster.\nIt is the responsibility of the Temporal Application to call the Cluster that is currently active.\n\n"},{"file_name":"retry-policies.md","id":"retry-policies","file_dir":"/","title":"Retry Policies","sidebar_label":"Retry Policies","description":"A Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"concepts/what-is-a-retry-policy","node":{"file_name":"what-is-a-retry-policy.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-retry-policy.md","id":"concepts/what-is-a-retry-policy","title":"What is a Retry Policy?","description":"A Retry Policy is a collection of attributes that instructs the Temporal Server how to retry a failure of a Workflow Execution or an Activity Task Execution.","label":"Retry Policy","tags":["term","explanation"],"markdown_content":"A Retry Policy is a collection of attributes that instructs the Temporal Server how to retry a failure of a [Workflow Execution](/workflows#workflow-execution) or an [Activity Task Execution](/tasks#activity-task-execution).\n(Retry Policies do not apply to [Workflow Task Executions](/tasks#workflow-task-execution), which always retry indefinitely.)\n\n- [Activity retry simulator](/application-development/features#activity-retry-simulator)\n- [How to set a custom Retry Policy for an Activity](/application-development/features#activity-retry-policy)\n- [How to set a Retry Policy for a Workflow](/application-development/features#workflow-retry-policy)\n\n<!-- ![Diagram that shows the retry interval and its formula](/img/retry-interval-diagram.png) -->\n\n## Default behavior\n\n- **Workflow Execution**: When a Workflow Execution is spawned, it is not associated with a default Retry Policy and thus does not retry by default.\n  The intention is that a Workflow Definition should be written to never fail due to intermittent issues; an Activity is designed to handle such issues.\n\n- **Activity Execution**: When an Activity Execution is spawned, it is associated with a default Retry Policy, and thus Activity Task Executions are retried by default.\n  When an Activity Task Execution is retried, the Cluster places a new [Activity Task](/tasks#activity-task) into its respective [Activity Task Queue](/tasks#task-queue), which results in a new Activity Task Execution.\n\n## Custom Retry Policy\n\nTo use a custom Retry Policy, provide it as an options parameter when starting a Workflow Execution or Activity Execution.\nOnly certain scenarios merit starting a Workflow Execution with a custom Retry Policy, such as the following:\n\n- A [Temporal Cron Job](/workflows#temporal-cron-job) or some other stateless, always-running Workflow Execution that can benefit from retries.\n- A file-processing or media-encoding Workflow Execution that downloads files to a host.\n\n## Properties\n\n### Default values for Retry Policy\n\n```\nInitial Interval     = 1 second\nBackoff Coefficient  = 2.0\nMaximum Interval     = 100  Initial Interval\nMaximum Attempts     = \nNon-Retryable Errors = []\n```\n\n### Initial Interval\n\n- **Description**: Amount of time that must elapse before the first retry occurs.\n  - **The default value is 1 second.**\n- **Use case**: This is used as the base interval time for the [Backoff Coefficient](#backoff-coefficient) to multiply against.\n\n### Backoff Coefficient\n\n- **Description**: The value dictates how much the _retry interval_ increases.\n  - **The default value is 2.0.**\n  - A backoff coefficient of 1.0 means that the retry interval always equals the [Initial Interval](#initial-interval).\n- **Use case**: Use this attribute to increase the interval between retries.\n  By having a backoff coefficient greater than 1.0, the first few retries happen relatively quickly to overcome intermittent failures, but subsequent retries happen farther and farther apart to account for longer outages.\n  Use the [Maximum Interval](#maximum-interval) attribute to prevent the coefficient from increasing the retry interval too much.\n\n### Maximum Interval\n\n- **Description**: Specifies the maximum interval between retries.\n  - **The default value is 100 times the [Initial Interval](#initial-interval).**\n- **Use case**: This attribute is useful for [Backoff Coefficients](#backoff-coefficient) that are greater than 1.0 because it prevents the retry interval from growing infinitely.\n\n### Maximum Attempts\n\n- **Description**: Specifies the maximum number of execution attempts that can be made in the presence of failures.\n  - **The default is unlimited.**\n  - If this limit is exceeded, the execution fails without retrying again. When this happens an error is returned.\n  - Setting the value to 0 also means unlimited.\n  - Setting the value to 1 means a single execution attempt and no retries.\n  - Setting the value to a negative integer results in an error when the execution is invoked.\n- **Use case**: Use this attribute to ensure that retries do not continue indefinitely.\n  However, in the majority of cases, we recommend relying on the Workflow Execution Timeout, in the case of [Workflows](#workflow), or Schedule-To-Close Timeout, in the case of [Activities](#activity), to limit the total duration of retries instead of using this attribute.\n\n### Non-Retryable Errors\n\n- **Description**: Specifies errors that shouldn't be retried.\n  - **Default is none.**\n  - If one of those errors occurs, the [Activity Task Execution](#activity-task-execution) or [Workflow Execution](#workflow-execution) is not retried.\n- **Use case**: There may be errors that you know of that should not trigger a retry.\n  In this case you can specify them such that if they occur, the given execution will not be retried.\n\n## Retry interval\n\nThe wait time before a retry is the _retry interval_. A retry interval is the smaller of two values:\n\n- The [Initial Interval](#initial-interval) multiplied by the [Backoff Coefficient](#backoff-coefficient) raised to the power of the number of retries.\n- The [Maximum Interval](#maximum-interval).\n\n## Event History\n\nThere are some subtle nuances to how Events are recorded to an Event History when a Retry Policy comes into play.\n\n- For an Activity Execution, the [ActivityTaskStarted](/concepts/what-is-an-event#activitytaskstarted) Event will not show up in the Workflow Execution Event History until the Activity Execution has completed or failed (having exhausted all retries).\n  This is to avoid filling the Event History with noise.\n  Use the Describe API to get a pending Activity Execution's attempt count.\n\n- For a Workflow Execution with a Retry Policy, if the Workflow Execution fails, the Workflow Execution will [Continue-As-New](/workflows#continue-as-new) and the associated Event is written to the Event History.\n  The [WorkflowExecutionContinuedAsNew](/concepts/what-is-an-event#workflowexecutioncontinuedasnew) Event will have an \"initiator\" field that will specify the Retry Policy as the value and the new Run Id for the next retry attempt.\n  The new Workflow Execution is created immediately.\n  But the first Workflow Task won't be scheduled until the backoff duration is exhausted.\n  That duration is recorded as the `firstWorkflowTaskBackoff` field of the new run's `WorkflowExecutionStartedEventAttributes` event.","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"retry-policies","local_ref":"","node_id":"concepts/what-is-a-retry-policy"}],"markdown_content":"---\nid: retry-policies\ntitle: Retry Policies\nsidebar_label: Retry Policies\ndescription: A Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nA Retry Policy is a collection of attributes that instructs the Temporal Server how to retry a failure of a [Workflow Execution](/workflows#workflow-execution) or an [Activity Task Execution](/tasks#activity-task-execution).\n(Retry Policies do not apply to [Workflow Task Executions](/tasks#workflow-task-execution), which always retry indefinitely.)\n\n- [Activity retry simulator](/application-development/features#activity-retry-simulator)\n- [How to set a custom Retry Policy for an Activity](/application-development/features#activity-retry-policy)\n- [How to set a Retry Policy for a Workflow](/application-development/features#workflow-retry-policy)\n\n<!-- ![Diagram that shows the retry interval and its formula](/img/retry-interval-diagram.png) -->\n\n## Default behavior\n\n- **Workflow Execution**: When a Workflow Execution is spawned, it is not associated with a default Retry Policy and thus does not retry by default.\n  The intention is that a Workflow Definition should be written to never fail due to intermittent issues; an Activity is designed to handle such issues.\n\n- **Activity Execution**: When an Activity Execution is spawned, it is associated with a default Retry Policy, and thus Activity Task Executions are retried by default.\n  When an Activity Task Execution is retried, the Cluster places a new [Activity Task](/tasks#activity-task) into its respective [Activity Task Queue](/tasks#task-queue), which results in a new Activity Task Execution.\n\n## Custom Retry Policy\n\nTo use a custom Retry Policy, provide it as an options parameter when starting a Workflow Execution or Activity Execution.\nOnly certain scenarios merit starting a Workflow Execution with a custom Retry Policy, such as the following:\n\n- A [Temporal Cron Job](/workflows#temporal-cron-job) or some other stateless, always-running Workflow Execution that can benefit from retries.\n- A file-processing or media-encoding Workflow Execution that downloads files to a host.\n\n## Properties\n\n### Default values for Retry Policy\n\n```\nInitial Interval     = 1 second\nBackoff Coefficient  = 2.0\nMaximum Interval     = 100  Initial Interval\nMaximum Attempts     = \nNon-Retryable Errors = []\n```\n\n### Initial Interval\n\n- **Description**: Amount of time that must elapse before the first retry occurs.\n  - **The default value is 1 second.**\n- **Use case**: This is used as the base interval time for the [Backoff Coefficient](#backoff-coefficient) to multiply against.\n\n### Backoff Coefficient\n\n- **Description**: The value dictates how much the _retry interval_ increases.\n  - **The default value is 2.0.**\n  - A backoff coefficient of 1.0 means that the retry interval always equals the [Initial Interval](#initial-interval).\n- **Use case**: Use this attribute to increase the interval between retries.\n  By having a backoff coefficient greater than 1.0, the first few retries happen relatively quickly to overcome intermittent failures, but subsequent retries happen farther and farther apart to account for longer outages.\n  Use the [Maximum Interval](#maximum-interval) attribute to prevent the coefficient from increasing the retry interval too much.\n\n### Maximum Interval\n\n- **Description**: Specifies the maximum interval between retries.\n  - **The default value is 100 times the [Initial Interval](#initial-interval).**\n- **Use case**: This attribute is useful for [Backoff Coefficients](#backoff-coefficient) that are greater than 1.0 because it prevents the retry interval from growing infinitely.\n\n### Maximum Attempts\n\n- **Description**: Specifies the maximum number of execution attempts that can be made in the presence of failures.\n  - **The default is unlimited.**\n  - If this limit is exceeded, the execution fails without retrying again. When this happens an error is returned.\n  - Setting the value to 0 also means unlimited.\n  - Setting the value to 1 means a single execution attempt and no retries.\n  - Setting the value to a negative integer results in an error when the execution is invoked.\n- **Use case**: Use this attribute to ensure that retries do not continue indefinitely.\n  However, in the majority of cases, we recommend relying on the Workflow Execution Timeout, in the case of [Workflows](#workflow), or Schedule-To-Close Timeout, in the case of [Activities](#activity), to limit the total duration of retries instead of using this attribute.\n\n### Non-Retryable Errors\n\n- **Description**: Specifies errors that shouldn't be retried.\n  - **Default is none.**\n  - If one of those errors occurs, the [Activity Task Execution](#activity-task-execution) or [Workflow Execution](#workflow-execution) is not retried.\n- **Use case**: There may be errors that you know of that should not trigger a retry.\n  In this case you can specify them such that if they occur, the given execution will not be retried.\n\n## Retry interval\n\nThe wait time before a retry is the _retry interval_. A retry interval is the smaller of two values:\n\n- The [Initial Interval](#initial-interval) multiplied by the [Backoff Coefficient](#backoff-coefficient) raised to the power of the number of retries.\n- The [Maximum Interval](#maximum-interval).\n\n## Event History\n\nThere are some subtle nuances to how Events are recorded to an Event History when a Retry Policy comes into play.\n\n- For an Activity Execution, the [ActivityTaskStarted](/concepts/what-is-an-event#activitytaskstarted) Event will not show up in the Workflow Execution Event History until the Activity Execution has completed or failed (having exhausted all retries).\n  This is to avoid filling the Event History with noise.\n  Use the Describe API to get a pending Activity Execution's attempt count.\n\n- For a Workflow Execution with a Retry Policy, if the Workflow Execution fails, the Workflow Execution will [Continue-As-New](/workflows#continue-as-new) and the associated Event is written to the Event History.\n  The [WorkflowExecutionContinuedAsNew](/concepts/what-is-an-event#workflowexecutioncontinuedasnew) Event will have an \"initiator\" field that will specify the Retry Policy as the value and the new Run Id for the next retry attempt.\n  The new Workflow Execution is created immediately.\n  But the first Workflow Task won't be scheduled until the backoff duration is exhausted.\n  That duration is recorded as the `firstWorkflowTaskBackoff` field of the new run's `WorkflowExecutionStartedEventAttributes` event.\n\n"},{"file_name":"tasks.md","id":"tasks","file_dir":"/","title":"Tasks","sidebar_label":"Tasks","description":"Temporal Task Queues and Worker Processes are tightly coupled components.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"concepts/what-is-a-task","node":{"file_name":"what-is-a-task.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-task.md","id":"concepts/what-is-a-task","title":"What is a Task?","description":"A Task is the context needed to make progress with a specific Workflow Execution or Activity Execution.","label":"Task","tags":["term","explanation"],"markdown_content":"A Task is the context that a Worker needs to progress with a specific [Workflow Execution](/workflows#workflow-execution) or [Activity Execution](/activities#activity-execution).\n\nThere are two types of Tasks:\n\n- [Activity Task](#activity-task)\n- [Workflow Task](#workflow-task)","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-workflow-task","node":{"file_name":"what-is-a-workflow-task.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-task.md","id":"concepts/what-is-a-workflow-task","title":"What is a Workflow Task?","description":"A Workflow Task is a Task that contains the context needed to make progress with a Workflow Execution.","label":"Workflow Task","tags":["term","explanation"],"markdown_content":"A Workflow Task is a Task that contains the context needed to make progress with a Workflow Execution.\n\n- Every time a new external event that might affect a Workflow state is recorded, a Workflow Task that contains the event is added to a Task Queue and then picked up by a Workflow Worker.\n- After the new event is handled, the Workflow Task is completed with a list of [Commands](/workflows#command).\n- Handling of a Workflow Task is usually very fast and is not related to the duration of operations that the Workflow invokes.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-workflow-task-execution","node":{"file_name":"what-is-a-workflow-task-execution.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-task-execution.md","id":"concepts/what-is-a-workflow-task-execution","title":"What is a Workflow Task Execution?","description":"A Workflow Task Execution is when a Worker picks up a Workflow Task and uses it to make progress on the execution of a Workflow function.","label":"Workflow Task Execution","tags":["term","explanation"],"markdown_content":"A Workflow Task Execution is when a Worker picks up a Workflow Task and uses it to make progress on the execution of a Workflow function.","is_empty":false}},{"type":"h2","id":"concepts/what-is-an-activity-task","node":{"file_name":"what-is-an-activity-task.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-activity-task.md","id":"concepts/what-is-an-activity-task","title":"What is an Activity Task?","description":"An Activity Task contains the context needed to make an Activity Task Execution.","label":"Activity Task","tags":["term","explanation"],"markdown_content":"An Activity Task contains the context needed to proceed with an [Activity Task Execution](#activity-task-execution).\nActivity Tasks largely represent the Activity Task Scheduled Event, which contains the data needed to execute an Activity Function.\n\nIf Heartbeat data is being passed, an Activity Task will also contain the latest Heartbeat details.","is_empty":false}},{"type":"h2","id":"concepts/what-is-an-activity-task-execution","node":{"file_name":"what-is-an-activity-task-execution.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-activity-task-execution.md","id":"concepts/what-is-an-activity-task-execution","title":"What is an Activity Task Execution?","description":"An Activity Task Execution is the execution of an Activity Type.","label":"Activity Task Execution","tags":["term","explanation"],"markdown_content":"An Activity Task Execution is when the Worker uses the Context provided from the [Activity Task](#activity-task) and executes the [Activity Definition](/activities#activity-definition) (also known as the Activity Function).\n\nThe [ActivityTaskScheduled Event](/references/events#activitytaskscheduled) corresponds to when the Temporal Cluster puts the Activity Task into the Task Queue.\n\nThe [ActivityTaskStarted Event](/references/events#activitytaskstarted) corresponds to when the Worker picks up the Activity Task from the Task Queue.\n\nEither [ActivityTaskCompleted](/references/events#activitytaskcompleted) or one of the other Closed Activity Task Events corresponds to when the Worker has yielded back to the Temporal Cluster.\n\nThe API to schedule an Activity Execution provides an \"effectively once\" experience, even though there may be several Activity Task Executions that take place to successfully complete an Activity.\n\nOnce an Activity Task finishes execution, the Worker responds to the Cluster with a specific Event:\n\n- ActivityTaskCanceled\n- ActivityTaskCompleted\n- ActivityTaskFailed\n- ActivityTaskTerminated\n- ActivityTaskTimedOut","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-task-queue","node":{"file_name":"what-is-a-task-queue.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-task-queue.md","id":"concepts/what-is-a-task-queue","title":"What is a Task Queue?","description":"A Task Queue is a first-in, first-out queue that a Worker Process polls for Tasks.","label":"Task Queue","tags":["term","explanation"],"markdown_content":"A Task Queue is a lightweight, dynamically allocated queue that one or more [Worker Entities](/workers#worker-entity) poll for [Tasks](#).\n\nTask Queues do not have any ordering guarantees.\nIt is possible to have a Task that stays in a Task Queue for a period of time, if there is a backlog that wasn't drained for that time.\n\nThere are two types of Task Queues, Activity Task Queues and Workflow Task Queues.\n\n![Task Queue component](/diagrams/task-queue.svg)\n\nTask Queues are very lightweight components.\nTask Queues do not require explicit registration but instead are created on demand when a Workflow Execution or Activity spawns or when a Worker Process subscribes to it.\nWhen a Task Queue is created, both a Workflow Task Queue and an Activity Task Queue are created under the same name.\nThere is no limit to the number of Task Queues a Temporal Application can use or a Temporal Cluster can maintain.\n\nWorkers poll for Tasks in Task Queues via synchronous RPC.\nThis implementation offers several benefits:\n\n- A Worker Process polls for a message only when it has spare capacity, avoiding overloading itself.\n- In effect, Task Queues enable load balancing across many Worker Processes.\n- Task Queues enable what we call [Task Routing](#task-routing), which is the routing of specific Tasks to specific Worker Processes or even a specific process.\n- Task Queues support server-side throttling, which enables you to limit the Task dispatching rate to the pool of Worker Processes while still supporting Task dispatching at higher rates when spikes happen.\n- When all Worker Processes are down, messages simply persist in a Task Queue, waiting for the Worker Processes to recover.\n- Worker Processes do not need to advertise themselves through DNS or any other network discovery mechanism.\n- Worker Processes do not need to have any open ports, which is more secure.\n\nAll Workers listening to a given Task Queue must have identical registrations of Activities and/or Workflows.\nThe one exception is during a Server upgrade, where it is okay to have registration temporarily misaligned while the binary rolls out.\n\n#### Where to set Task Queues\n\nThere are four places where the name of the Task Queue can be set by the developer.\n\n1. A Task Queue must be set when spawning a Workflow Execution:\n\n- [How to start a Workflow Execution using an SDK](/application-development/foundations#set-task-queue)\n- [How to start a Workflow Execution using tctl](/tctl/workflow/start#--taskqueue)\n\n2. A Task Queue name must be set when creating a Worker Entity and when running a Worker Process:\n\n- [How to develop a Worker Program](/application-development/foundations#run-worker-processes)\n\nNote that all Worker Entities listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker Entity polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. A Task Queue name can be provided when spawning an Activity Execution:\n\nThis is optional.\nAn Activity Execution inherits the Task Queue name from its Workflow Execution if one is not provided.\n\n- [How to start an Activity Execution](/application-development/foundations#start-activity-execution)\n\n4. A Task Queue name can be provided when spawning a Child Workflow Execution:\n\nThis is optional.\nA Child Workflow Execution inherits the Task Queue name from its Parent Workflow Execution if one is not provided.\n\n- [How to start a Child Workflow Execution](/application-development/features#child-workflows)","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-sticky-execution","node":{"file_name":"what-is-a-sticky-execution.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-sticky-execution.md","id":"concepts/what-is-a-sticky-execution","title":"What is a Sticky Execution?","description":"A Sticky Execution is a when a Worker Entity caches the Workflow Execution Event History and creates a dedicated Task Queue to listen on.","label":"Sticky Execution","tags":["term","explanation"],"markdown_content":"A Sticky Execution is when a Worker Entity caches the Workflow Execution Event History and creates a dedicated Task Queue to listen on.\n\nA Sticky Execution occurs after a Worker Entity completes the first Workflow Task in the chain of Workflow Tasks for the Workflow Execution.\n\nThe Worker Entity caches the Workflow Execution Event History and begins polling the dedicated Task Queue for Workflow Tasks that contain updates, rather than the entire Event History.\n\nIf the Worker Entity does not pick up a Workflow Task from the dedicated Task Queue in an appropriate amount of time, the Cluster will resume Scheduling Workflow Tasks on the original Task Queue.\nAnother Worker Entity can then resume the Workflow Execution, and can set up its own Sticky Execution for future Workflow Tasks.\n\n- [How to set a `StickyScheduleToStartTimeout` on a Worker Entity in Go](/go/how-to-set-workeroptions-in-go/#stickyscheduletostarttimeout)\n\nSticky Executions are the default behavior of the Temporal Platform.","is_empty":false}},{"type":"h2","id":"concepts/what-is-task-routing","node":{"file_name":"what-is-task-routing.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-task-routing.md","id":"concepts/what-is-task-routing","title":"What is Task Routing?","description":"Task Routing is when a Task Queue is paired with one or more Worker Processes, primarily for Activity Task Executions.","label":"Task Routing","tags":["term","explanation"],"markdown_content":"Task Routing is simply when a Task Queue is paired with one or more Workers, primarily for Activity Task Executions.\n\nThis could also mean employing multiple Task Queues, each one paired with a Worker Process.\n\nTask Routing has many applicable use cases.\n\n### Flow control\n\nA Worker that consumes from a Task Queue asks for an Activity Task only when it has available capacity, so it is never overloaded by request spikes.\nIf Activity Tasks get created faster than Workers can process them, they are backlogged in the Task Queue.\n\n### Throttling\n\nThe rate at which each Activity Worker polls for and processes Activity Tasks is configurable per Worker.\nWorkers do not exceed this rate even if it has spare capacity.\nThere is also support for global Task Queue rate limiting.\nThis limit works across all Workers for the given Task Queue.\nIt is frequently used to limit load on a downstream service that an Activity calls into.\n\n### Specific environments\n\nIn some cases, you might need to execute Activities in a dedicated environment.\nTo send Activity Tasks to this environment, use a dedicated Task Queue.\n\n#### Route Activity Tasks to a specific host\n\nIn some use cases, such as file processing or machine learning model training, an Activity Task must be routed to a specific Worker Process or Worker Entity.\n\nFor example, suppose that you have a Workflow with the following three separate Activities:\n\n- Download a file.\n- Process the file in some way.\n- Upload a file to another location.\n\nThe first Activity, to download the file, could occur on any Worker on any host.\nHowever, the second and third Activities must be executed by a Worker on the same host where the first Activity downloaded the file.\n\nIn a real-life scenario, you might have many Worker Processes scaled over many hosts.\nYou would need to develop your Temporal Application to route Tasks to specific Worker Processes when needed.\n\nCode samples:\n\n- [Go file processing example](https://github.com/temporalio/samples-go/tree/master/fileprocessing)\n- [Java file processing example](https://github.com/temporalio/samples-java/tree/master/src/main/java/io/temporal/samples/fileprocessing)\n- [PHP file processing example](https://github.com/temporalio/samples-php/tree/master/app/src/FileProcessing)\n\n#### Sessions\n\nSome SDKs provide a Session API that provides a straightforward way to ensure that Activity Tasks are executed with the same Worker without requiring you to manually specify Task Queue names.\nIt also includes features like **concurrent session limitations** and **worker failure detection**.\n\n- [How to create Worker Sessions in Go](/go/how-to-create-a-worker-session-in-go)\n\n#### Route Activity Tasks to a specific process\n\nSome Activities load large datasets and cache them in the process.\nThe Activities that rely on those datasets should be routed to the same process.\n\nIn this case, a unique Task Queue would exist for each Worker Process involved.\n\n#### Workers with different capabilities\n\nSome Workers might exist on GPU boxes versus non-GPU boxes.\nIn this case, each type of box would have its own Task Queue and a Workflow can pick one to send Activity Tasks.\n\n### Multiple priorities\n\nIf your use case involves more than one priority, you can create one Task Queue per priority, with a Worker pool per priority.\n\n### Versioning\n\nTask Routing is the simplest way to version your code.\n\nIf you have a new backward-incompatible Activity Definition, start by using a different Task Queue.","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"tasks","local_ref":"","node_id":"concepts/what-is-a-task"},{"file_dir":"/","guide_id":"tasks","local_ref":"workflow-task","node_id":"concepts/what-is-a-workflow-task"},{"file_dir":"/","guide_id":"tasks","local_ref":"workflow-task-execution","node_id":"concepts/what-is-a-workflow-task-execution"},{"file_dir":"/","guide_id":"tasks","local_ref":"activity-task","node_id":"concepts/what-is-an-activity-task"},{"file_dir":"/","guide_id":"tasks","local_ref":"activity-task-execution","node_id":"concepts/what-is-an-activity-task-execution"},{"file_dir":"/","guide_id":"tasks","local_ref":"task-queue","node_id":"concepts/what-is-a-task-queue"},{"file_dir":"/","guide_id":"tasks","local_ref":"sticky-execution","node_id":"concepts/what-is-a-sticky-execution"},{"file_dir":"/","guide_id":"tasks","local_ref":"task-routing","node_id":"concepts/what-is-task-routing"}],"markdown_content":"---\nid: tasks\ntitle: Tasks\nsidebar_label: Tasks\ndescription: Temporal Task Queues and Worker Processes are tightly coupled components.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nTemporal Task Queues and Worker Processes are tightly coupled components.\n\nA Task is the context that a Worker needs to progress with a specific [Workflow Execution](/workflows#workflow-execution) or [Activity Execution](/activities#activity-execution).\n\nThere are two types of Tasks:\n\n- [Activity Task](#activity-task)\n- [Workflow Task](#workflow-task)\n\n## Workflow Task\n\nA Workflow Task is a Task that contains the context needed to make progress with a Workflow Execution.\n\n- Every time a new external event that might affect a Workflow state is recorded, a Workflow Task that contains the event is added to a Task Queue and then picked up by a Workflow Worker.\n- After the new event is handled, the Workflow Task is completed with a list of [Commands](/workflows#command).\n- Handling of a Workflow Task is usually very fast and is not related to the duration of operations that the Workflow invokes.\n\n## Workflow Task Execution\n\nA Workflow Task Execution is when a Worker picks up a Workflow Task and uses it to make progress on the execution of a Workflow function.\n\n## Activity Task\n\nAn Activity Task contains the context needed to proceed with an [Activity Task Execution](#activity-task-execution).\nActivity Tasks largely represent the Activity Task Scheduled Event, which contains the data needed to execute an Activity Function.\n\nIf Heartbeat data is being passed, an Activity Task will also contain the latest Heartbeat details.\n\n## Activity Task Execution\n\nAn Activity Task Execution is when the Worker uses the Context provided from the [Activity Task](#activity-task) and executes the [Activity Definition](/activities#activity-definition) (also known as the Activity Function).\n\nThe [ActivityTaskScheduled Event](/references/events#activitytaskscheduled) corresponds to when the Temporal Cluster puts the Activity Task into the Task Queue.\n\nThe [ActivityTaskStarted Event](/references/events#activitytaskstarted) corresponds to when the Worker picks up the Activity Task from the Task Queue.\n\nEither [ActivityTaskCompleted](/references/events#activitytaskcompleted) or one of the other Closed Activity Task Events corresponds to when the Worker has yielded back to the Temporal Cluster.\n\nThe API to schedule an Activity Execution provides an \"effectively once\" experience, even though there may be several Activity Task Executions that take place to successfully complete an Activity.\n\nOnce an Activity Task finishes execution, the Worker responds to the Cluster with a specific Event:\n\n- ActivityTaskCanceled\n- ActivityTaskCompleted\n- ActivityTaskFailed\n- ActivityTaskTerminated\n- ActivityTaskTimedOut\n\n## Task Queue\n\nA Task Queue is a lightweight, dynamically allocated queue that one or more [Worker Entities](/workers#worker-entity) poll for [Tasks](#).\n\nTask Queues do not have any ordering guarantees.\nIt is possible to have a Task that stays in a Task Queue for a period of time, if there is a backlog that wasn't drained for that time.\n\nThere are two types of Task Queues, Activity Task Queues and Workflow Task Queues.\n\n![Task Queue component](/diagrams/task-queue.svg)\n\nTask Queues are very lightweight components.\nTask Queues do not require explicit registration but instead are created on demand when a Workflow Execution or Activity spawns or when a Worker Process subscribes to it.\nWhen a Task Queue is created, both a Workflow Task Queue and an Activity Task Queue are created under the same name.\nThere is no limit to the number of Task Queues a Temporal Application can use or a Temporal Cluster can maintain.\n\nWorkers poll for Tasks in Task Queues via synchronous RPC.\nThis implementation offers several benefits:\n\n- A Worker Process polls for a message only when it has spare capacity, avoiding overloading itself.\n- In effect, Task Queues enable load balancing across many Worker Processes.\n- Task Queues enable what we call [Task Routing](#task-routing), which is the routing of specific Tasks to specific Worker Processes or even a specific process.\n- Task Queues support server-side throttling, which enables you to limit the Task dispatching rate to the pool of Worker Processes while still supporting Task dispatching at higher rates when spikes happen.\n- When all Worker Processes are down, messages simply persist in a Task Queue, waiting for the Worker Processes to recover.\n- Worker Processes do not need to advertise themselves through DNS or any other network discovery mechanism.\n- Worker Processes do not need to have any open ports, which is more secure.\n\nAll Workers listening to a given Task Queue must have identical registrations of Activities and/or Workflows.\nThe one exception is during a Server upgrade, where it is okay to have registration temporarily misaligned while the binary rolls out.\n\n#### Where to set Task Queues\n\nThere are four places where the name of the Task Queue can be set by the developer.\n\n1. A Task Queue must be set when spawning a Workflow Execution:\n\n- [How to start a Workflow Execution using an SDK](/application-development/foundations#set-task-queue)\n- [How to start a Workflow Execution using tctl](/tctl/workflow/start#--taskqueue)\n\n2. A Task Queue name must be set when creating a Worker Entity and when running a Worker Process:\n\n- [How to develop a Worker Program](/application-development/foundations#run-worker-processes)\n\nNote that all Worker Entities listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker Entity polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. A Task Queue name can be provided when spawning an Activity Execution:\n\nThis is optional.\nAn Activity Execution inherits the Task Queue name from its Workflow Execution if one is not provided.\n\n- [How to start an Activity Execution](/application-development/foundations#start-activity-execution)\n\n4. A Task Queue name can be provided when spawning a Child Workflow Execution:\n\nThis is optional.\nA Child Workflow Execution inherits the Task Queue name from its Parent Workflow Execution if one is not provided.\n\n- [How to start a Child Workflow Execution](/application-development/features#child-workflows)\n\n## Sticky Execution\n\nA Sticky Execution is when a Worker Entity caches the Workflow Execution Event History and creates a dedicated Task Queue to listen on.\n\nA Sticky Execution occurs after a Worker Entity completes the first Workflow Task in the chain of Workflow Tasks for the Workflow Execution.\n\nThe Worker Entity caches the Workflow Execution Event History and begins polling the dedicated Task Queue for Workflow Tasks that contain updates, rather than the entire Event History.\n\nIf the Worker Entity does not pick up a Workflow Task from the dedicated Task Queue in an appropriate amount of time, the Cluster will resume Scheduling Workflow Tasks on the original Task Queue.\nAnother Worker Entity can then resume the Workflow Execution, and can set up its own Sticky Execution for future Workflow Tasks.\n\n- [How to set a `StickyScheduleToStartTimeout` on a Worker Entity in Go](/go/how-to-set-workeroptions-in-go/#stickyscheduletostarttimeout)\n\nSticky Executions are the default behavior of the Temporal Platform.\n\n## Task Routing\n\nTask Routing is simply when a Task Queue is paired with one or more Workers, primarily for Activity Task Executions.\n\nThis could also mean employing multiple Task Queues, each one paired with a Worker Process.\n\nTask Routing has many applicable use cases.\n\n### Flow control\n\nA Worker that consumes from a Task Queue asks for an Activity Task only when it has available capacity, so it is never overloaded by request spikes.\nIf Activity Tasks get created faster than Workers can process them, they are backlogged in the Task Queue.\n\n### Throttling\n\nThe rate at which each Activity Worker polls for and processes Activity Tasks is configurable per Worker.\nWorkers do not exceed this rate even if it has spare capacity.\nThere is also support for global Task Queue rate limiting.\nThis limit works across all Workers for the given Task Queue.\nIt is frequently used to limit load on a downstream service that an Activity calls into.\n\n### Specific environments\n\nIn some cases, you might need to execute Activities in a dedicated environment.\nTo send Activity Tasks to this environment, use a dedicated Task Queue.\n\n#### Route Activity Tasks to a specific host\n\nIn some use cases, such as file processing or machine learning model training, an Activity Task must be routed to a specific Worker Process or Worker Entity.\n\nFor example, suppose that you have a Workflow with the following three separate Activities:\n\n- Download a file.\n- Process the file in some way.\n- Upload a file to another location.\n\nThe first Activity, to download the file, could occur on any Worker on any host.\nHowever, the second and third Activities must be executed by a Worker on the same host where the first Activity downloaded the file.\n\nIn a real-life scenario, you might have many Worker Processes scaled over many hosts.\nYou would need to develop your Temporal Application to route Tasks to specific Worker Processes when needed.\n\nCode samples:\n\n- [Go file processing example](https://github.com/temporalio/samples-go/tree/master/fileprocessing)\n- [Java file processing example](https://github.com/temporalio/samples-java/tree/master/src/main/java/io/temporal/samples/fileprocessing)\n- [PHP file processing example](https://github.com/temporalio/samples-php/tree/master/app/src/FileProcessing)\n\n#### Sessions\n\nSome SDKs provide a Session API that provides a straightforward way to ensure that Activity Tasks are executed with the same Worker without requiring you to manually specify Task Queue names.\nIt also includes features like **concurrent session limitations** and **worker failure detection**.\n\n- [How to create Worker Sessions in Go](/go/how-to-create-a-worker-session-in-go)\n\n#### Route Activity Tasks to a specific process\n\nSome Activities load large datasets and cache them in the process.\nThe Activities that rely on those datasets should be routed to the same process.\n\nIn this case, a unique Task Queue would exist for each Worker Process involved.\n\n#### Workers with different capabilities\n\nSome Workers might exist on GPU boxes versus non-GPU boxes.\nIn this case, each type of box would have its own Task Queue and a Workflow can pick one to send Activity Tasks.\n\n### Multiple priorities\n\nIf your use case involves more than one priority, you can create one Task Queue per priority, with a Worker pool per priority.\n\n### Versioning\n\nTask Routing is the simplest way to version your code.\n\nIf you have a new backward-incompatible Activity Definition, start by using a different Task Queue.\n\n"},{"file_name":"temporal.md","id":"temporal","file_dir":"/","title":"Temporal","sidebar_label":"Temporal","description":"The Temporal Platform explained.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"concepts/what-is-temporal","node":{"file_name":"what-is-temporal.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-temporal.md","id":"concepts/what-is-temporal","title":"What is Temporal?","description":"Temporalis a scalable and reliable runtime for Reentrant Processes calledTemporalWorkflow Executions.","label":"Temporal","tags":["term","explanation"],"markdown_content":"Temporalis a scalable and reliable runtime for Reentrant Processes called[TemporalWorkflow Executions](/workflows#workflow-execution).\n\n<!-- TODO content more appropriate for blog\n:::note [Temporal's tenth rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule)\n\nAny sufficiently complex distributed system contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of temporal.io.\n\n:::\n-->\n\n![The Temporal System](/diagrams/temporal-system-simple.svg)","is_empty":false}},{"type":"h2","id":"concepts/what-is-the-temporal-platform","node":{"file_name":"what-is-the-temporal-platform.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-the-temporal-platform.md","id":"concepts/what-is-the-temporal-platform","title":"What is the Temporal Platform?","description":"The Temporal Platform consists of a Temporal Cluster and Worker Processes.","label":"Temporal Platform","tags":["term","explanation"],"markdown_content":"The Temporal Platform consists of a [Temporal Cluster](/clusters#) and [Worker Processes](/workers#worker-process).\nTogether these components create a runtime for Workflow Executions.\n\n![The Temporal Platform (runtime)](/diagrams/temporal-platform-simple.svg)\n\nThe Temporal Cluster is open source and can be operated by you.\nThe Temporal Cloud is a set of Clusters operated by us.\n\nWorker Processes are hosted by you and execute your code.\nThey communicate with a Temporal Cluster via gRPC.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-temporal-application","node":{"file_name":"what-is-a-temporal-application.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-temporal-application.md","id":"concepts/what-is-a-temporal-application","title":"What is a Temporal Application","description":"A Temporal Application is a set of Workflow Executions.","label":"Temporal Application","tags":["term","explanation"],"markdown_content":"A Temporal Application is a set of [Temporal Workflow Executions](/workflows#workflow-execution).\nEach Temporal Workflow Execution has exclusive access to its local state, executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions and the environment via message passing.\n\nA Temporal Application can consist of millions to billions of Workflow Executions.\nWorkflow Executions are lightweight components.\nA Workflow Execution consumes few compute resources; in fact, if a Workflow Execution is suspended, such as when it is in a waiting state, the Workflow Execution consumes no compute resources at all.\n\n**Reentrant Process**\n\nA Temporal Workflow Execution is a Reentrant Process. A Reentrant Process isresumable,recoverable, andreactive.\n\n- Resumable: Ability of a process to continue execution after execution was suspended on an _awaitable_.\n- Recoverable: Ability of a process to continue execution after execution was suspended on a _failure_.\n- Reactive: Ability of a process to react to external events.\n\nTherefore, aTemporal Workflow Execution executes a[Temporal Workflow Definition](/workflows#workflow-definition), also called aTemporal Workflow Function,your application code,exactly onceandto completionwhether your code executes for seconds or years, in the presence of arbitrary load and arbitrary failures.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-temporal-sdk","node":{"file_name":"what-is-a-temporal-sdk.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-temporal-sdk.md","id":"concepts/what-is-a-temporal-sdk","title":"What is a Temporal SDK?","description":"A Temporal SDK is a language-specific library that offers APIs to construct and use a Temporal Client to communicate with a Temporal Cluster, develop Workflow Definitions, and develop Worker Programs.","label":"Temporal SDK","tags":["term","explanation"],"markdown_content":"A Temporal SDK is a language-specific library that offers APIs to do the following:\n\n1. Construct and use a [Temporal Client](#temporal-client)\n2. Develop [Workflow Definitions](/workflows#workflow-definition)\n3. Develop [Worker Programs](/workers#worker-program)\n\nA Temporal SDK enables you to write your application code using the full power of the programming language, while the Temporal Platform handles the durability, reliability, and scalability of the application.\n\nTemporal currently offers the following SDKs:\n\n- [Get started with the Go SDK](/application-development/foundations/?lang=go#add-your-sdk)\n- [Get started with the Java SDK](/application-development/foundations/?lang=java#add-your-sdk)\n- [Get started with the PHP SDK](/application-development/foundations/?lang=php)\n- [Get started with the Python SDK](/application-development/foundations/?lang=python#add-your-sdk)\n- [How to use the TypeScript SDK](/application-development/foundations/?lang=typescript#add-your-sdk)\n\nEach SDK emits metrics which can be ingested into monitoring platforms.\nSee the [SDK metrics reference](/references/sdk-metrics) for a complete list.\n\n### Auth\n\nTemporal offers methods of authenticating and authorizing client API calls within our SDKs.\n\n### SDKs in development\n\nThe following SDKs are in alpha/pre-alpha development stages, but are not yet supported in the application development guide:\n\n- [.NET](https://github.com/temporalio/sdk-dotnet)\n- [Rust](https://github.com/temporalio/sdk-core)\n- [Ruby](https://github.com/temporalio/sdk-ruby)\n\n### Third-party SDKs\n\nThe following third-party SDKs exist but are not supported in the [Application development guide](/application-development):\n\n- [Scala](https://github.com/vitaliihonta/zio-temporal) from [@vitaliihonta](https://github.com/vitaliihonta)\n- [Ruby](https://github.com/coinbase/temporal-ruby) from [@coinbase](https://github.com/coinbase)","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-temporal-client","node":{"file_name":"what-is-a-temporal-client.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-temporal-client.md","id":"concepts/what-is-a-temporal-client","title":"What is a Temporal Client","description":"TODO","label":"Temporal Client","tags":["term","explanation"],"markdown_content":"A Temporal Client is available in each SDK and provides a set of APIs to communicate with a [Temporal Cluster](/clusters#).\n\nThe most common operations that a Temporal Client enables you to perform are the following:\n\n- Get the result of Workflow Execution.\n- List Workflow Executions.\n- Query a Workflow Execution.\n- Signal a Workflow Execution.\n- Start a Workflow Execution.","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"temporal","local_ref":"","node_id":"concepts/what-is-temporal"},{"file_dir":"/","guide_id":"temporal","local_ref":"temporal-platform","node_id":"concepts/what-is-the-temporal-platform"},{"file_dir":"/","guide_id":"temporal","local_ref":"temporal-application","node_id":"concepts/what-is-a-temporal-application"},{"file_dir":"/","guide_id":"temporal","local_ref":"temporal-sdk","node_id":"concepts/what-is-a-temporal-sdk"},{"file_dir":"/","guide_id":"temporal","local_ref":"temporal-client","node_id":"concepts/what-is-a-temporal-client"}],"markdown_content":"---\nid: temporal\ntitle: Temporal\nsidebar_label: Temporal\ndescription: The Temporal Platform explained.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nThe Temporal Platform explained.\n\nTemporalis a scalable and reliable runtime for Reentrant Processes called[TemporalWorkflow Executions](/workflows#workflow-execution).\n\n<!-- TODO content more appropriate for blog\n:::note [Temporal's tenth rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule)\n\nAny sufficiently complex distributed system contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of temporal.io.\n\n:::\n-->\n\n![The Temporal System](/diagrams/temporal-system-simple.svg)\n\n## Temporal Platform\n\nThe Temporal Platform consists of a [Temporal Cluster](/clusters#) and [Worker Processes](/workers#worker-process).\nTogether these components create a runtime for Workflow Executions.\n\n![The Temporal Platform (runtime)](/diagrams/temporal-platform-simple.svg)\n\nThe Temporal Cluster is open source and can be operated by you.\nThe Temporal Cloud is a set of Clusters operated by us.\n\nWorker Processes are hosted by you and execute your code.\nThey communicate with a Temporal Cluster via gRPC.\n\n## Temporal Application\n\nA Temporal Application is a set of [Temporal Workflow Executions](/workflows#workflow-execution).\nEach Temporal Workflow Execution has exclusive access to its local state, executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions and the environment via message passing.\n\nA Temporal Application can consist of millions to billions of Workflow Executions.\nWorkflow Executions are lightweight components.\nA Workflow Execution consumes few compute resources; in fact, if a Workflow Execution is suspended, such as when it is in a waiting state, the Workflow Execution consumes no compute resources at all.\n\n**Reentrant Process**\n\nA Temporal Workflow Execution is a Reentrant Process. A Reentrant Process isresumable,recoverable, andreactive.\n\n- Resumable: Ability of a process to continue execution after execution was suspended on an _awaitable_.\n- Recoverable: Ability of a process to continue execution after execution was suspended on a _failure_.\n- Reactive: Ability of a process to react to external events.\n\nTherefore, aTemporal Workflow Execution executes a[Temporal Workflow Definition](/workflows#workflow-definition), also called aTemporal Workflow Function,your application code,exactly onceandto completionwhether your code executes for seconds or years, in the presence of arbitrary load and arbitrary failures.\n\n## Temporal SDK\n\nA Temporal SDK is a language-specific library that offers APIs to do the following:\n\n1. Construct and use a [Temporal Client](#temporal-client)\n2. Develop [Workflow Definitions](/workflows#workflow-definition)\n3. Develop [Worker Programs](/workers#worker-program)\n\nA Temporal SDK enables you to write your application code using the full power of the programming language, while the Temporal Platform handles the durability, reliability, and scalability of the application.\n\nTemporal currently offers the following SDKs:\n\n- [Get started with the Go SDK](/application-development/foundations/?lang=go#add-your-sdk)\n- [Get started with the Java SDK](/application-development/foundations/?lang=java#add-your-sdk)\n- [Get started with the PHP SDK](/application-development/foundations/?lang=php)\n- [Get started with the Python SDK](/application-development/foundations/?lang=python#add-your-sdk)\n- [How to use the TypeScript SDK](/application-development/foundations/?lang=typescript#add-your-sdk)\n\nEach SDK emits metrics which can be ingested into monitoring platforms.\nSee the [SDK metrics reference](/references/sdk-metrics) for a complete list.\n\n### Auth\n\nTemporal offers methods of authenticating and authorizing client API calls within our SDKs.\n\n### SDKs in development\n\nThe following SDKs are in alpha/pre-alpha development stages, but are not yet supported in the application development guide:\n\n- [.NET](https://github.com/temporalio/sdk-dotnet)\n- [Rust](https://github.com/temporalio/sdk-core)\n- [Ruby](https://github.com/temporalio/sdk-ruby)\n\n### Third-party SDKs\n\nThe following third-party SDKs exist but are not supported in the [Application development guide](/application-development):\n\n- [Scala](https://github.com/vitaliihonta/zio-temporal) from [@vitaliihonta](https://github.com/vitaliihonta)\n- [Ruby](https://github.com/coinbase/temporal-ruby) from [@coinbase](https://github.com/coinbase)\n\n### Temporal Client\n\nA Temporal Client is available in each SDK and provides a set of APIs to communicate with a [Temporal Cluster](/clusters#).\n\nThe most common operations that a Temporal Client enables you to perform are the following:\n\n- Get the result of Workflow Execution.\n- List Workflow Executions.\n- Query a Workflow Execution.\n- Signal a Workflow Execution.\n- Start a Workflow Execution.\n\n"},{"file_name":"visibility.md","id":"visibility","file_dir":"/","title":"Visibility","sidebar_label":"Visibility","description":"This guide provides a comprehensive overview of Temporal Visibility.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"concepts/what-is-visibility","node":{"file_name":"what-is-visibility.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-visibility.md","id":"concepts/what-is-visibility","title":"What is Visibility?","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["term"],"markdown_content":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","is_empty":false}},{"type":"h2","id":"concepts/what-is-standard-visibility","node":{"file_name":"what-is-standard-visibility.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-standard-visibility.md","id":"concepts/what-is-standard-visibility","title":"What is Standard Visibility?","description":"Standard Visibility, within the Temporal Platform, is the subsystem and APIs that list Workflow Executions by a predefined set of filters.","label":"Standard Visibility","tags":["term","explanation","filtered-lists","visibility"],"markdown_content":"Standard Visibility, within the Temporal Platform, is the subsystem and APIs that list Workflow Executions by a predefined set of filters.\n\nOpen Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, or Run Id.\n\nClosed Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, Run Id, or Execution Status (Completed, Failed, Timed Out, Terminated, Canceled, or Continued-As-New).","is_empty":false}},{"type":"h2","id":"concepts/what-is-advanced-visibility","node":{"file_name":"what-is-advanced-visibility.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-advanced-visibility.md","id":"concepts/what-is-advanced-visibility","title":"What is Advanced Visibility?","description":"Advanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through an SQL-like query syntax.","label":"Advanced Visibility","tags":["term","explanation","filtered-lists","visibility"],"markdown_content":"Advanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through a custom SQL-like [List Filter](#list-filter).\n\nTo use Advanced Visibility, your Temporal Cluster must be [integrated with Elasticsearch](/cluster-deployment-guide#elasticsearch).\nWe highly recommend operating a Temporal Cluster with Elasticsearch for any use case that spawns more than just a few Workflow Executions.\nElasticsearch takes on the Visibility request load, relieving potential performance issues.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-list-filter","node":{"file_name":"what-is-a-list-filter.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-list-filter.md","id":"concepts/what-is-a-list-filter","title":"What is a List Filter?","description":"A List Filter is the SQL-like string that is provided as the parameter to an Advanced Visibility List API.","label":"List Filter","tags":["term","explanation","filtered-lists","visibility"],"markdown_content":"A List Filter is the SQL-like string that is provided as the parameter to an [Advanced Visibility](#advanced-visibility) List API.\n\n- [How to use a List Filter using tctl](/tctl/workflow/list/#--query)\n\nThe following is an example List Filter:\n\n```\nWorkflowType = \"main.YourWorkflowDefinition\" and ExecutionStatus != \"Running\" and (StartTime > \"2021-06-07T16:46:34.236-08:00\" or CloseTime > \"2021-06-07T16:46:34-08:00\") order by StartTime desc\n```\n\n[More example List Filters](#example-list-filters)\n\nA List Filter contains [Search Attribute](#search-attribute) names, Search Attribute values, and Operators.\n\n- The following operators are supported in List Filters:\n\n  - **=, !=, >, >=, <, <=**\n  - **AND, OR, ()**\n  - **BETWEEN ... AND**\n  - **IN**\n  - **ORDER BY**\n\n- A List Filter applies to a single Namespace.\n\n- The range of a List Filter timestamp (StartTime, CloseTime, ExecutionTime) cannot exceed 9223372036854775807 (that is, maxInt64 - 1001).\n\n- A List Filter that uses a time range has a resolution of 1 ms on Elasticsearch 6 and 1 ns on Elasticsearch 7.\n\n- List Filter Search Attribute names are case sensitive.\n\n- An Advanced List Filter API may take longer than expected if it is retrieving a large number of Workflow Executions (more than 10 million).\n\n- A `ListWorkflow` API supports pagination.\n  Use the page token in the following call to retrieve the next page; continue until the page token is `null`/`nil`.\n\n- To efficiently count the number of Workflow Executions, use the `CountWorkflow` API.\n\n#### Example List Filters\n\n```sql\nWorkflowId = '<workflow-id>'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or WorkflowId = '<another-workflow-id>'\n```\n\n```sql\nWorkflowId = '<workflow-id>' order by StartTime desc\n```\n\n```sql\nWorkflowId = '<workflow-id>' and ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' and StartTime > '2021-08-22T15:04:05+00:00'\n```\n\n```sql\nExecutionTime between '2021-08-22T15:04:05+00:00' and '2021-08-28T15:04:05+00:00'\n```\n\n```sql\nExecutionTime < '2021-08-28T15:04:05+00:00' or ExecutionTime > '2021-08-22T15:04:05+00:00'\n```\n\n```sql\norder by ExecutionTime\n```\n\n```sql\norder by StartTime desc, CloseTime asc\n```\n\n```sql\norder by CustomIntField asc\n```","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-search-attribute","node":{"file_name":"what-is-a-search-attribute.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-search-attribute.md","id":"concepts/what-is-a-search-attribute","title":"What is a Search Attribute?","description":"A Search Attribute is an indexed name used in List Filters to filter a list of Workflow Executions that have the Search Attribute in their metadata.","label":"Search Attribute","tags":["term","explanation","filtered-lists","visibility"],"markdown_content":"A Search Attribute is an indexed field used in a [List Filter](#list-filter) to filter a list of [Workflow Executions](/workflows#workflow-execution) that have the Search Attribute in their metadata.\n\nIf a [Temporal Cluster](/clusters#) does not have [Elasticsearch integrated](/cluster-deployment-guide#elasticsearch), but a Workflow Execution is spawned and tagged with Search Attributes, no errors occur.\nHowever, you won't be able to use [Advanced Visibility](#advanced-visibility) List APIs and List Filters to find and list the Workflow Execution.\n\nWhen using [Continue-As-New](/workflows#continue-as-new) or a [Temporal Cron Job](/workflows#temporal-cron-job), Search Attributes are carried over to the new Workflow Run by default.\n\n#### Search Attributes maximums\n\nDefault total maximum number of Search Attribute **keys** per Temporal Cluster is 100.\n\n<!-- TODO - [How to configure maximum number of Search Attribute keys per Cluster](#) -->\n\nDefault single Search Attribute **value** size limit is 2 KB.\n\n<!-- TODO - [How to configure Search Attribute value size limit](#) -->\n\nTotal Search Attribute size: 40 KB\n\n<!-- TODO - [How to configure total Search Attribute size limite](#) -->\n\n<!-- temp keeping for reference\nThis is configurable with [`SearchAttributesNumberOfKeysLimit`, `SearchAttributesTotalSizeLimit` and `SearchAttributesSizeOfValueLimit`](https://github.com/temporalio/temporal/blob/v1.7.0/service/history/configs/config.go#L440-L442), if you know what you are doing.\n-->\n\n#### Default Search Attributes\n\nA Temporal Cluster that is integrated with Elasticsearch has a set of default Search Attributes already available.\nThese Search Attributes are created when the initial index is created.\n\n| NAME                  | TYPE     | DEFINITION                                                                                                                                                                   |\n| --------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| WorkflowType          | Keyword  | The type of Workflow.                                                                                                                                                        |\n| WorkflowId            | Keyword  | Identifies the Workflow Execution.                                                                                                                                           |\n| ExecutionStatus       | Keyword  | The current state of the Workflow Execution.                                                                                                                                 |\n| StartTime             | Datetime | The time at which the Workflow Execution started.                                                                                                                            |\n| CloseTime             | Datetime | The time at which the Workflow Execution completed.                                                                                                                          |\n| ExecutionTime         | Datetime | Same as StartTime for the most cases but different for cron Workflows and retried Workflows. For them it is the time at which the Workflow Execution actually begin running. |\n| RunId                 | Keyword  | Identifies the current Workflow Execution Run.                                                                                                                               |\n| ExecutionDuration     | Int      | The time needed to run the Workflow Execution. Available only for closed Workflows.                                                                                          |\n| HistoryLength         | Int      | The number of events in the history of Workflow Execution. Available only for closed Workflows.                                                                              |\n| StateTransitionCount  | Int      | The number of times that Workflow Execution has persisted its state. Available only for closed Workflows.                                                                    |\n| TaskQueue             | Keyword  | Task Queue used by Workflow Execution.                                                                                                                                       |\n| TemporalChangeVersion | Keyword  | If workflow versioning is enabled, list of change/version pairs will be stored here.                                                                                         |\n| BinaryChecksums       | Keyword  | List of binary Ids of Workers that run the Workflow Execution.                                                                                                               |\n| BatcherNamespace      | Keyword  | Used by internal batcher to indicate the Namespace where batch operation was applied to.                                                                                     |\n| BatcherUser           | Keyword  | Used by internal batcher to indicate the user who started the batch operation.                                                                                               |\n\n- All default Search Attributes are reserved and read-only.\n  (You cannot create a custom one with the same name or alter the existing one.)\n\n- ExecutionStatus values correspond to Workflow Execution Statuses: Running, Completed, Failed, Canceled, Terminated, ContinuedAsNew, TimedOut.\n\n- StartTime, CloseTime, and ExecutionTime are stored as dates but are supported by queries that use either EpochTime in nanoseconds or a string in [RFC3339Nano format](https://pkg.go.dev/time#pkg-constants) (such as \"2006-01-02T15:04:05.999999999Z07:00\").\n\n- ExecutionDuration is stored in nanoseconds but is supported by queries that use integers in nanoseconds, [Golang duration format](https://pkg.go.dev/time#ParseDuration), or \"hh:mm:ss\" format.\n\n- CloseTime, HistoryLength, StateTransitionCount, and ExecutionDuration are present only in a Closed Workflow Execution.\n\n- ExecutionTime can differ from StartTime in retry and cron use cases.\n\n#### Custom Search Attributes\n\nCustom Search Attributes can be [added to a Temporal Cluster only by using `tctl`](/tctl/admin/cluster/add-search-attributes).\nAdding a Search Attribute makes it available to use with Workflow Executions within that Cluster.\n\nThere is no hard limit on the number of attributes you can add.\nHowever, we recommend enforcing the following limits:\n\n- Number of Search Attributes: 100 per Workflow\n- Size of each value: 2 KB per value\n- Total size of names and values: 40 KB per Workflow\n\n:::note\n\nDue to Elasticsearch limitations, you can only add Search Attributes.\nIt is not possible to rename Search Attributes or remove them from the index schema.\n\n:::\n\nThe [temporalio/auto-setup](https://hub.docker.com/r/temporalio/auto-setup) Docker image uses a pre-defined set of custom Search Attributes that are handy for testing.\nTheir names indicate their types:\n\n- CustomBoolField\n- CustomDatetimeField\n- CustomDoubleField\n- CustomIntField\n- CustomKeywordField\n- CustomTextField\n\n#### Types\n\nSearch Attributes must be one of the following types:\n\n- Bool\n- Datetime\n- Double\n- Int\n- Keyword\n- Text\n\nNote:\n\n- **Double** is backed up by `scaled_float` Elasticsearch type with scale factor 10000 (4 decimal digits).\n- **Datetime** is backed up by `date` type with milliseconds precision in Elasticsearch 6 and `date_nanos` type with nanoseconds precision in Elasticsearch 7.\n- **Int** is 64-bit integer (`long` Elasticsearch type).\n- **Keyword** and **Text** types are concepts taken from Elasticsearch. Each word in a **Text** is considered a searchable keyword.\n  For a UUID, that can be problematic because Elasticsearch indexes each portion of the UUID separately.\n  To have the whole string considered as a searchable keyword, use the **Keyword** type.\n  For example, if the key `ProductId` has the value of `2dd29ab7-2dd8-4668-83e0-89cae261cfb1`:\n  - As a **Keyword** it would be matched only by `ProductId = \"2dd29ab7-2dd8-4668-83e0-89cae261cfb1`.\n  - As a **Text** it would be matched by `ProductId = 2dd8`, which could cause unwanted matches.\n- The **Text** type cannot be used in the \"Order By\" clause.\n\n- [How to view Search Attributes using tctl](/tctl/cluster/get-search-attributes)\n\n#### Search Attributes as Workflow Execution metadata\n\nTo actually have results from the use of a [List Filter](#list-filter), Search Attributes must be added to a Workflow Execution as metadata.\nHow to do this entirely depends on the method by which you spawn the Workflow Execution:\n\n- [How to set Search Attributes as Workflow Execution metadata in Go](/go/startworkflowoptions-reference/#searchattributes)","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"visibility","local_ref":"","node_id":"concepts/what-is-visibility"},{"file_dir":"/","guide_id":"visibility","local_ref":"standard-visibility","node_id":"concepts/what-is-standard-visibility"},{"file_dir":"/","guide_id":"visibility","local_ref":"advanced-visibility","node_id":"concepts/what-is-advanced-visibility"},{"file_dir":"/","guide_id":"visibility","local_ref":"list-filter","node_id":"concepts/what-is-a-list-filter"},{"file_dir":"/","guide_id":"visibility","local_ref":"search-attribute","node_id":"concepts/what-is-a-search-attribute"}],"markdown_content":"---\nid: visibility\ntitle: Visibility\nsidebar_label: Visibility\ndescription: This guide provides a comprehensive overview of Temporal Visibility.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nThis guide provides a comprehensive overview of Temporal Visibility.\n\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n\n## Standard Visibility\n\nStandard Visibility, within the Temporal Platform, is the subsystem and APIs that list Workflow Executions by a predefined set of filters.\n\nOpen Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, or Run Id.\n\nClosed Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, Run Id, or Execution Status (Completed, Failed, Timed Out, Terminated, Canceled, or Continued-As-New).\n\n## Advanced Visibility\n\nAdvanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through a custom SQL-like [List Filter](#list-filter).\n\nTo use Advanced Visibility, your Temporal Cluster must be [integrated with Elasticsearch](/cluster-deployment-guide#elasticsearch).\nWe highly recommend operating a Temporal Cluster with Elasticsearch for any use case that spawns more than just a few Workflow Executions.\nElasticsearch takes on the Visibility request load, relieving potential performance issues.\n\n## List Filter\n\nA List Filter is the SQL-like string that is provided as the parameter to an [Advanced Visibility](#advanced-visibility) List API.\n\n- [How to use a List Filter using tctl](/tctl/workflow/list/#--query)\n\nThe following is an example List Filter:\n\n```\nWorkflowType = \"main.YourWorkflowDefinition\" and ExecutionStatus != \"Running\" and (StartTime > \"2021-06-07T16:46:34.236-08:00\" or CloseTime > \"2021-06-07T16:46:34-08:00\") order by StartTime desc\n```\n\n[More example List Filters](#example-list-filters)\n\nA List Filter contains [Search Attribute](#search-attribute) names, Search Attribute values, and Operators.\n\n- The following operators are supported in List Filters:\n\n  - **=, !=, >, >=, <, <=**\n  - **AND, OR, ()**\n  - **BETWEEN ... AND**\n  - **IN**\n  - **ORDER BY**\n\n- A List Filter applies to a single Namespace.\n\n- The range of a List Filter timestamp (StartTime, CloseTime, ExecutionTime) cannot exceed 9223372036854775807 (that is, maxInt64 - 1001).\n\n- A List Filter that uses a time range has a resolution of 1 ms on Elasticsearch 6 and 1 ns on Elasticsearch 7.\n\n- List Filter Search Attribute names are case sensitive.\n\n- An Advanced List Filter API may take longer than expected if it is retrieving a large number of Workflow Executions (more than 10 million).\n\n- A `ListWorkflow` API supports pagination.\n  Use the page token in the following call to retrieve the next page; continue until the page token is `null`/`nil`.\n\n- To efficiently count the number of Workflow Executions, use the `CountWorkflow` API.\n\n#### Example List Filters\n\n```sql\nWorkflowId = '<workflow-id>'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or WorkflowId = '<another-workflow-id>'\n```\n\n```sql\nWorkflowId = '<workflow-id>' order by StartTime desc\n```\n\n```sql\nWorkflowId = '<workflow-id>' and ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' and StartTime > '2021-08-22T15:04:05+00:00'\n```\n\n```sql\nExecutionTime between '2021-08-22T15:04:05+00:00' and '2021-08-28T15:04:05+00:00'\n```\n\n```sql\nExecutionTime < '2021-08-28T15:04:05+00:00' or ExecutionTime > '2021-08-22T15:04:05+00:00'\n```\n\n```sql\norder by ExecutionTime\n```\n\n```sql\norder by StartTime desc, CloseTime asc\n```\n\n```sql\norder by CustomIntField asc\n```\n\n## Search Attribute\n\nA Search Attribute is an indexed field used in a [List Filter](#list-filter) to filter a list of [Workflow Executions](/workflows#workflow-execution) that have the Search Attribute in their metadata.\n\nIf a [Temporal Cluster](/clusters#) does not have [Elasticsearch integrated](/cluster-deployment-guide#elasticsearch), but a Workflow Execution is spawned and tagged with Search Attributes, no errors occur.\nHowever, you won't be able to use [Advanced Visibility](#advanced-visibility) List APIs and List Filters to find and list the Workflow Execution.\n\nWhen using [Continue-As-New](/workflows#continue-as-new) or a [Temporal Cron Job](/workflows#temporal-cron-job), Search Attributes are carried over to the new Workflow Run by default.\n\n#### Search Attributes maximums\n\nDefault total maximum number of Search Attribute **keys** per Temporal Cluster is 100.\n\n<!-- TODO - [How to configure maximum number of Search Attribute keys per Cluster](#) -->\n\nDefault single Search Attribute **value** size limit is 2 KB.\n\n<!-- TODO - [How to configure Search Attribute value size limit](#) -->\n\nTotal Search Attribute size: 40 KB\n\n<!-- TODO - [How to configure total Search Attribute size limite](#) -->\n\n<!-- temp keeping for reference\nThis is configurable with [`SearchAttributesNumberOfKeysLimit`, `SearchAttributesTotalSizeLimit` and `SearchAttributesSizeOfValueLimit`](https://github.com/temporalio/temporal/blob/v1.7.0/service/history/configs/config.go#L440-L442), if you know what you are doing.\n-->\n\n#### Default Search Attributes\n\nA Temporal Cluster that is integrated with Elasticsearch has a set of default Search Attributes already available.\nThese Search Attributes are created when the initial index is created.\n\n| NAME                  | TYPE     | DEFINITION                                                                                                                                                                   |\n| --------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| WorkflowType          | Keyword  | The type of Workflow.                                                                                                                                                        |\n| WorkflowId            | Keyword  | Identifies the Workflow Execution.                                                                                                                                           |\n| ExecutionStatus       | Keyword  | The current state of the Workflow Execution.                                                                                                                                 |\n| StartTime             | Datetime | The time at which the Workflow Execution started.                                                                                                                            |\n| CloseTime             | Datetime | The time at which the Workflow Execution completed.                                                                                                                          |\n| ExecutionTime         | Datetime | Same as StartTime for the most cases but different for cron Workflows and retried Workflows. For them it is the time at which the Workflow Execution actually begin running. |\n| RunId                 | Keyword  | Identifies the current Workflow Execution Run.                                                                                                                               |\n| ExecutionDuration     | Int      | The time needed to run the Workflow Execution. Available only for closed Workflows.                                                                                          |\n| HistoryLength         | Int      | The number of events in the history of Workflow Execution. Available only for closed Workflows.                                                                              |\n| StateTransitionCount  | Int      | The number of times that Workflow Execution has persisted its state. Available only for closed Workflows.                                                                    |\n| TaskQueue             | Keyword  | Task Queue used by Workflow Execution.                                                                                                                                       |\n| TemporalChangeVersion | Keyword  | If workflow versioning is enabled, list of change/version pairs will be stored here.                                                                                         |\n| BinaryChecksums       | Keyword  | List of binary Ids of Workers that run the Workflow Execution.                                                                                                               |\n| BatcherNamespace      | Keyword  | Used by internal batcher to indicate the Namespace where batch operation was applied to.                                                                                     |\n| BatcherUser           | Keyword  | Used by internal batcher to indicate the user who started the batch operation.                                                                                               |\n\n- All default Search Attributes are reserved and read-only.\n  (You cannot create a custom one with the same name or alter the existing one.)\n\n- ExecutionStatus values correspond to Workflow Execution Statuses: Running, Completed, Failed, Canceled, Terminated, ContinuedAsNew, TimedOut.\n\n- StartTime, CloseTime, and ExecutionTime are stored as dates but are supported by queries that use either EpochTime in nanoseconds or a string in [RFC3339Nano format](https://pkg.go.dev/time#pkg-constants) (such as \"2006-01-02T15:04:05.999999999Z07:00\").\n\n- ExecutionDuration is stored in nanoseconds but is supported by queries that use integers in nanoseconds, [Golang duration format](https://pkg.go.dev/time#ParseDuration), or \"hh:mm:ss\" format.\n\n- CloseTime, HistoryLength, StateTransitionCount, and ExecutionDuration are present only in a Closed Workflow Execution.\n\n- ExecutionTime can differ from StartTime in retry and cron use cases.\n\n#### Custom Search Attributes\n\nCustom Search Attributes can be [added to a Temporal Cluster only by using `tctl`](/tctl/admin/cluster/add-search-attributes).\nAdding a Search Attribute makes it available to use with Workflow Executions within that Cluster.\n\nThere is no hard limit on the number of attributes you can add.\nHowever, we recommend enforcing the following limits:\n\n- Number of Search Attributes: 100 per Workflow\n- Size of each value: 2 KB per value\n- Total size of names and values: 40 KB per Workflow\n\n:::note\n\nDue to Elasticsearch limitations, you can only add Search Attributes.\nIt is not possible to rename Search Attributes or remove them from the index schema.\n\n:::\n\nThe [temporalio/auto-setup](https://hub.docker.com/r/temporalio/auto-setup) Docker image uses a pre-defined set of custom Search Attributes that are handy for testing.\nTheir names indicate their types:\n\n- CustomBoolField\n- CustomDatetimeField\n- CustomDoubleField\n- CustomIntField\n- CustomKeywordField\n- CustomTextField\n\n#### Types\n\nSearch Attributes must be one of the following types:\n\n- Bool\n- Datetime\n- Double\n- Int\n- Keyword\n- Text\n\nNote:\n\n- **Double** is backed up by `scaled_float` Elasticsearch type with scale factor 10000 (4 decimal digits).\n- **Datetime** is backed up by `date` type with milliseconds precision in Elasticsearch 6 and `date_nanos` type with nanoseconds precision in Elasticsearch 7.\n- **Int** is 64-bit integer (`long` Elasticsearch type).\n- **Keyword** and **Text** types are concepts taken from Elasticsearch. Each word in a **Text** is considered a searchable keyword.\n  For a UUID, that can be problematic because Elasticsearch indexes each portion of the UUID separately.\n  To have the whole string considered as a searchable keyword, use the **Keyword** type.\n  For example, if the key `ProductId` has the value of `2dd29ab7-2dd8-4668-83e0-89cae261cfb1`:\n  - As a **Keyword** it would be matched only by `ProductId = \"2dd29ab7-2dd8-4668-83e0-89cae261cfb1`.\n  - As a **Text** it would be matched by `ProductId = 2dd8`, which could cause unwanted matches.\n- The **Text** type cannot be used in the \"Order By\" clause.\n\n- [How to view Search Attributes using tctl](/tctl/cluster/get-search-attributes)\n\n#### Search Attributes as Workflow Execution metadata\n\nTo actually have results from the use of a [List Filter](#list-filter), Search Attributes must be added to a Workflow Execution as metadata.\nHow to do this entirely depends on the method by which you spawn the Workflow Execution:\n\n- [How to set Search Attributes as Workflow Execution metadata in Go](/go/startworkflowoptions-reference/#searchattributes)\n\n"},{"file_name":"workers.md","id":"workers","file_dir":"/","title":"Workers","sidebar_label":"Workers","description":"This guide provides a comprehensive overview of Temporal Workers.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"concepts/what-is-a-worker","node":{"file_name":"what-is-a-worker.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-worker.md","id":"concepts/what-is-a-worker","title":"What is a Worker?","description":"In day-to-day conversations, the term Worker is used to denote both a Worker Program and a Worker Process. Temporal documentation aims to be explicit and differentiate between them.","label":"Worker","tags":["term","explanation"],"markdown_content":"In day-to-day conversations, the term Worker is used to denote either a [Worker Program](#worker-program), a [Worker Process](#worker-process), or a [Worker Entity](#worker-entity).\nTemporal documentation aims to be explicit and differentiate between them.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-worker-program","node":{"file_name":"what-is-a-worker-program.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-worker-program.md","id":"concepts/what-is-a-worker-program","title":"What is a Worker Program?","description":"A Worker Program is the static code that defines the constraints of the Worker Process, developed using the APIs of a Temporal SDK.","label":"Worker Program","tags":["term","explanation"],"markdown_content":"A Worker Program is the static code that defines the constraints of the Worker Process, developed using the APIs of a Temporal SDK.\n\n**Implementation guide:**\n\n- [How to develop a Worker Program](/application-development/foundations#run-worker-processes)","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-worker-entity","node":{"file_name":"what-is-a-worker-entity.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-worker-entity.md","id":"concepts/what-is-a-worker-entity","title":"What is a Worker Entity?","description":"A Worker Entity is the individual Worker within a Worker Process that listens to a specific Task Queue.","label":"Worker Entity","tags":["term","explanation"],"markdown_content":"A Worker Entity is the individual Worker within a Worker Process that listens to a specific Task Queue.\n\nA Worker Entity listens and polls on a single Task Queue.\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it may make progress of either a Workflow Execution or an Activity Execution.\n\n**Can a Worker handle more Workflow Executions than its cache size or number of supported threads?**\n\nYes it can.\nHowever, the trade off is added latency.\n\nWorkers are stateless, so any Workflow Execution in a blocked state can be safely removed from a Worker.\nLater on, it can be resurrected on the same or different Worker when the need arises (in the form of an external event).\nTherefore, a single Worker can handle millions of open Workflow Executions, assuming it can handle the update rate and that a slightly higher latency is not a concern.\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-worker-process","node":{"file_name":"what-is-a-worker-process.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-worker-process.md","id":"concepts/what-is-a-worker-process","title":"What is a Worker Process?","description":"A Worker Process is responsible for polling a Task Queue, dequeueing a Task, executing your code in response to a Task, and responding to the Temporal Server with the results.","label":"Worker Process","tags":["term","explanation"],"markdown_content":"![Component diagram of a Worker Process and the Temporal Server](/diagrams/worker-and-server-component.svg)\n\nA Worker Process is responsible for polling a [Task Queue](/tasks#task-queue), dequeueing a [Task](/tasks#), executing your code in response to a Task, and responding to the [Temporal Cluster](/clusters#) with the results.\n\nMore formally, a Worker Process is any process that implements the Task Queue Protocol and the Task Execution Protocol.\n\n- A Worker Process is a Workflow Worker Process if the process implements the Workflow Task Queue Protocol and executes the Workflow Task Execution Protocol to make progress on a Workflow Execution.\n  A Workflow Worker Process can listen on an arbitrary number of Workflow Task Queues and can execute an arbitrary number of Workflow Tasks.\n- A Worker Process is an Activity Worker Process if the process implements the Activity Task Queue Protocol and executes the Activity Task Processing Protocol to make progress on an Activity Execution.\n  An Activity Worker Process can listen on an arbitrary number of Activity Task Queues and can execute an arbitrary number of Activity Tasks.\n\n**Worker Processes are external to a Temporal Cluster.**\nTemporal Application developers are responsible for developing [Worker Programs](#worker-program) and operating Worker Processes.\nSaid another way, the [Temporal Cluster](/clusters#) (including the Temporal Cloud) doesn't execute any of your code (Workflow & Activity Definitions) on Temporal Cluster machines. The Cluster is solely responsible for orchestrating state transitions and providing Tasks to the next available Worker Entity.\n\nWhile data transferred in Event Histories is [secured by mTLS](/server/security/#encryption-of-network-traffic), by default, it is still readable at rest in the Temporal Cluster.\n\nTo solve this, Temporal SDKs offer a [Data Converter API](/concepts/what-is-a-data-converter) that you can use to customize the serialization of data going out of and coming back in to a Worker Entity, with the net effect of guaranteeing that the Temporal Cluster cannot read sensitive business data.\n\nIn many of our tutorials, we show you how to run both a Temporal Cluster and one Worker on the same machine for local development.\nHowever, a production-grade Temporal Application typically has a _fleet_ of Worker Processes, all running on hosts external to the Temporal Cluster.\nA Temporal Application can have as many Worker Processes as needed.\n\nA Worker Process can be both a Workflow Worker Process and an Activity Worker Process.\nMany SDKs support the ability to have multiple Worker Entities in a single Worker Process.\n(Worker entity creation and management differ between SDKs.)\nA single Worker Entity can listen to only a single Task Queue.\nBut if a Worker Process has multiple Worker Entities, the Worker Process could be listening to multiple Task Queues.\n\n![Entity relationship diagram (meta model) of Worker Processes, Task Queues, and Tasks](/diagrams/worker-and-server-entity-relationship.svg)\n\nWorker Processes executing Activity Tasks must have access to any resources needed to execute the actions that are defined in Activity Definitions, such as the following:\n\n- Network access for external API calls.\n- Credentials for infrastructure provisioning.\n- Specialized GPUs for machine learning utilities.\n\nThe Temporal Cluster itself has [internal workers](https://temporal.io/blog/workflow-engine-principles/#system-workflows-1910) for system Workflow Executions.\nHowever, these internal workers are not visible to the developer.","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"workers","local_ref":"","node_id":"concepts/what-is-a-worker"},{"file_dir":"/","guide_id":"workers","local_ref":"worker-program","node_id":"concepts/what-is-a-worker-program"},{"file_dir":"/","guide_id":"workers","local_ref":"worker-entity","node_id":"concepts/what-is-a-worker-entity"},{"file_dir":"/","guide_id":"workers","local_ref":"worker-process","node_id":"concepts/what-is-a-worker-process"}],"markdown_content":"---\nid: workers\ntitle: Workers\nsidebar_label: Workers\ndescription: This guide provides a comprehensive overview of Temporal Workers.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nThis guide provides a comprehensive overview of Temporal Workers.\n\nIn day-to-day conversations, the term Worker is used to denote either a [Worker Program](#worker-program), a [Worker Process](#worker-process), or a [Worker Entity](#worker-entity).\nTemporal documentation aims to be explicit and differentiate between them.\n\n## Worker Program\n\nA Worker Program is the static code that defines the constraints of the Worker Process, developed using the APIs of a Temporal SDK.\n\n**Implementation guide:**\n\n- [How to develop a Worker Program](/application-development/foundations#run-worker-processes)\n\n## Worker Entity\n\nA Worker Entity is the individual Worker within a Worker Process that listens to a specific Task Queue.\n\nA Worker Entity listens and polls on a single Task Queue.\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it may make progress of either a Workflow Execution or an Activity Execution.\n\n**Can a Worker handle more Workflow Executions than its cache size or number of supported threads?**\n\nYes it can.\nHowever, the trade off is added latency.\n\nWorkers are stateless, so any Workflow Execution in a blocked state can be safely removed from a Worker.\nLater on, it can be resurrected on the same or different Worker when the need arises (in the form of an external event).\nTherefore, a single Worker can handle millions of open Workflow Executions, assuming it can handle the update rate and that a slightly higher latency is not a concern.\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)\n\n## Worker Process\n\n![Component diagram of a Worker Process and the Temporal Server](/diagrams/worker-and-server-component.svg)\n\nA Worker Process is responsible for polling a [Task Queue](/tasks#task-queue), dequeueing a [Task](/tasks#), executing your code in response to a Task, and responding to the [Temporal Cluster](/clusters#) with the results.\n\nMore formally, a Worker Process is any process that implements the Task Queue Protocol and the Task Execution Protocol.\n\n- A Worker Process is a Workflow Worker Process if the process implements the Workflow Task Queue Protocol and executes the Workflow Task Execution Protocol to make progress on a Workflow Execution.\n  A Workflow Worker Process can listen on an arbitrary number of Workflow Task Queues and can execute an arbitrary number of Workflow Tasks.\n- A Worker Process is an Activity Worker Process if the process implements the Activity Task Queue Protocol and executes the Activity Task Processing Protocol to make progress on an Activity Execution.\n  An Activity Worker Process can listen on an arbitrary number of Activity Task Queues and can execute an arbitrary number of Activity Tasks.\n\n**Worker Processes are external to a Temporal Cluster.**\nTemporal Application developers are responsible for developing [Worker Programs](#worker-program) and operating Worker Processes.\nSaid another way, the [Temporal Cluster](/clusters#) (including the Temporal Cloud) doesn't execute any of your code (Workflow & Activity Definitions) on Temporal Cluster machines. The Cluster is solely responsible for orchestrating state transitions and providing Tasks to the next available Worker Entity.\n\nWhile data transferred in Event Histories is [secured by mTLS](/server/security/#encryption-of-network-traffic), by default, it is still readable at rest in the Temporal Cluster.\n\nTo solve this, Temporal SDKs offer a [Data Converter API](/concepts/what-is-a-data-converter) that you can use to customize the serialization of data going out of and coming back in to a Worker Entity, with the net effect of guaranteeing that the Temporal Cluster cannot read sensitive business data.\n\nIn many of our tutorials, we show you how to run both a Temporal Cluster and one Worker on the same machine for local development.\nHowever, a production-grade Temporal Application typically has a _fleet_ of Worker Processes, all running on hosts external to the Temporal Cluster.\nA Temporal Application can have as many Worker Processes as needed.\n\nA Worker Process can be both a Workflow Worker Process and an Activity Worker Process.\nMany SDKs support the ability to have multiple Worker Entities in a single Worker Process.\n(Worker entity creation and management differ between SDKs.)\nA single Worker Entity can listen to only a single Task Queue.\nBut if a Worker Process has multiple Worker Entities, the Worker Process could be listening to multiple Task Queues.\n\n![Entity relationship diagram (meta model) of Worker Processes, Task Queues, and Tasks](/diagrams/worker-and-server-entity-relationship.svg)\n\nWorker Processes executing Activity Tasks must have access to any resources needed to execute the actions that are defined in Activity Definitions, such as the following:\n\n- Network access for external API calls.\n- Credentials for infrastructure provisioning.\n- Specialized GPUs for machine learning utilities.\n\nThe Temporal Cluster itself has [internal workers](https://temporal.io/blog/workflow-engine-principles/#system-workflows-1910) for system Workflow Executions.\nHowever, these internal workers are not visible to the developer.\n\n"},{"file_name":"workflows.md","id":"workflows","file_dir":"/","title":"Workflows","sidebar_label":"Workflows","description":"This guide provides a comprehensive overview of Temporal Workflows.","use_description":true,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"concepts/what-is-a-workflow","node":{"file_name":"what-is-a-workflow.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow.md","id":"concepts/what-is-a-workflow","title":"What is a Workflow?","description":"In day-to-day conversations, the term \"Workflow\" frequently denotes either a Workflow Type, a Workflow Definition, or a Workflow Execution.","label":"Workflow","tags":["term","explanation"],"markdown_content":"In day-to-day conversations, the term _Workflow_ frequently denotes either a [Workflow Type](#workflow-type), a [Workflow Definition](#workflow-definition), or a [Workflow Execution](#workflow-execution).\nTemporal documentation aims to be explicit and differentiate between them.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-workflow-definition","node":{"file_name":"what-is-a-workflow-definition.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-definition.md","id":"concepts/what-is-a-workflow-definition","title":"What is a Workflow Definition?","description":"A Workflow Definition is the code that defines the constraints of a Workflow Execution.","label":"Workflow Definition","tags":["term","explanation"],"markdown_content":"A Workflow Definition is the code that defines the constraints of a Workflow Execution.\n\n- [How to develop a Workflow Definition](/application-development/foundations#develop-workflows)\n\nA Workflow Definition is often also referred to as a Workflow Function.\nIn Temporal's documentation, a Workflow Definition refers to the source for the instance of a Workflow Execution, while a Workflow Function refers to the source for the instance of a Workflow Function Execution.\n\nA Workflow Execution effectively executes once to completion, while a Workflow Function Execution occurs many times during the life of a Workflow Execution.\n\nWe strongly recommend that you write a Workflow Definition in a language that has a corresponding Temporal SDK.\n\n### Deterministic constraints\n\nA critical aspect of developing Workflow Definitions is ensuring they exhibit certain deterministic traits  that is, making sure that the same Commands are emitted in the same sequence, whenever a corresponding Workflow Function Execution (instance of the Function Definition) is re-executed.\n\nThe execution semantics of a Workflow Execution include the re-execution of a Workflow Function.\nThe use of Workflow APIs in the function is what generates [Commands](#command).\nCommands tell the Cluster which Events to create and add to the Workflow Execution's Event History.\nWhen a Workflow Function executes, the Commands that are emitted are compared with the existing Event History.\nIf a corresponding Event already exists within the Event History that maps to the generation of that Command in the same sequence, and some specific metadata of that Command matches with some specific metadata of the Event, then the Function Execution progresses.\n\nFor example, using an SDK's \"Execute Activity\" API generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nWhen this API is called upon re-execution, that Command is compared with the Event that is in the same location within the sequence.\nThe Event in the sequence must be an [ActivityTaskScheduled](/references/events/#activitytaskscheduled) Event, where the Activity name is the same as what is in the Command.\n\nIf a generated Command doesn't match what it needs to in the existing Event History, then the Workflow Execution returns a _non-deterministic_ error.\n\nThe following are the two reasons why a Command might be generated out of sequence or the wrong Command might be generated altogether:\n\n1. Code changes are made to a Workflow Definition that is in use by a running Workflow Execution.\n2. There is intrinsic non-deterministic logic (such as inline random branching).\n\n### Code changes can cause non-deterministic behavior\n\nThe Workflow Definition can change in very limited ways once there is a Workflow Execution depending on it.\nTo alleviate non-deterministic issues that arise from code changes, we recommend using [Workflow Versioning](#workflow-versioning).\n\nFor example, let's say we have a Workflow Definition that defines the following sequence:\n\n1. Start and wait on a Timer/sleep.\n2. Spawn and wait on an Activity Execution.\n3. Complete.\n\nWe start a Worker and spawn a Workflow Execution that uses that Workflow Definition.\nThe Worker would emit the [StartTimer](/references/commands/#starttimer) Command and the Workflow Execution would become suspended.\n\nBefore the Timer is up, we change the Workflow Definition to the following sequence:\n\n1. Spawn and wait on an Activity Execution.\n2. Start and wait on a Timer/sleep.\n3. Complete.\n\nWhen the Timer fires, the next Workflow Task will cause the Workflow Function to re-execute.\nThe first Command the Worker sees would be ScheduleActivityTask Command, which wouldn't match up to the expected [TimerStarted](/references/events/#timerstarted) Event.\n\nThe Workflow Execution would fail and return a non-deterministic error.\n\nThe following are examples of minor changes that would not result in non-determinism errors when re-executing a History which already contain the Events:\n\n- Changing the duration of a Timer.\n- Changing the arguments to:\n  - The Activity Options in a call to spawn an Activity Execution (local or nonlocal).\n  - The Child Workflow Options in a call to spawn a Child Workflow Execution.\n  - Call to Signal an External Workflow Execution.\n\n### Intrinsic non-deterministic logic\n\nIntrinsic non-determinism is when a Workflow Function Execution might emit a different sequence of Commands on re-execution, regardless of whether all the input parameters are the same.\n\nFor example, a Workflow Definition can not have inline logic that branches (emits a different Command sequence) based off a local time setting or a random number.\nIn the representative pseudocode below, the `local_clock()` function returns the local time, rather than Temporal-defined time:\n\n```text\nfn your_workflow() {\n  if local_clock().is_before(\"12pm\") {\n    await workflow.sleep(duration_until(\"12pm\"))\n  } else {\n    await your_afternoon_activity()\n  }\n}\n```\n\nEach Temporal SDK offers APIs that enable Workflow Definitions to have logic that gets and uses time, random numbers, and data from unreliable resources.\nWhen those APIs are used, the results are stored as part of the Event History, which means that a re-executed Workflow Function will issue the same sequence of Commands, even if there is branching involved.\n\nIn other words, all operations that do not purely mutate the Workflow Execution's state should occur through a Temporal SDK API.\n\n### Workflow Versioning\n\nThe Workflow Versioning feature enables the creation of logical branching inside a Workflow Definition based on a developer specified version identifier.\nThis feature is useful for Workflow Definition logic needs to be updated, but there are running Workflow Executions that currently depends on it.\nIt is important to note that a practical way to handle different versions of Workflow Definitions, without using the versioning API, is to run the different versions on separate Task Queues.\n\n- [How to version Workflow Definitions in Go](/go/versioning)\n- [How to version Workflow Definitions in Java](/java/versioning)\n- [How to version Workflow Definitions in TypeScript](/typescript/patching)\n\n### Handling unreliable Worker Processes\n\nYou do not handle Worker Process failure or restarts in a Workflow Definition.\n\nWorkflow Function Executions are completely oblivious to the Worker Process in terms of failures or downtime.\nThe Temporal Platform ensures that the state of a Workflow Execution is recovered and progress resumes if there is an outage of either Worker Processes or the Temporal Cluster itself.\nThe only reason a Workflow Execution might fail is due to the code throwing an error or exception, not because of underlying infrastructure outages.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-workflow-type","node":{"file_name":"what-is-a-workflow-type.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-type.md","id":"concepts/what-is-a-workflow-type","title":"What is a Workflow Type?","description":"A Workflow Type is a name that maps to a Workflow Definition.","label":"Workflow Type","tags":["term","explanation"],"markdown_content":"A Workflow Type is a name that maps to a Workflow Definition.\n\n- A single Workflow Type can be instantiated as multiple Workflow Executions.\n- A Workflow Type is scoped by a Task Queue.\n  It is acceptable to have the same Workflow Type name map to different Workflow definitions if they are using completely different Workers.\n\n![Workflow Type cardinality with Workflow Definitions and Workflow Executions](/diagrams/workflow-type-cardinality.svg)","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-workflow-execution","node":{"file_name":"what-is-a-workflow-execution.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-execution.md","id":"concepts/what-is-a-workflow-execution","title":"What is a Workflow Execution?","description":"A Temporal Workflow Execution is a durable, scalable, reliable, and reactive function execution. It is the main unit of execution of a Temporal Application.","label":"Workflow Execution","tags":["term","explanation"],"markdown_content":"A Temporal Workflow Execution is a durable, reliable, and scalable function execution.\nIt is the main unit of execution of a [Temporal Application](/temporal#temporal-application).\n\n- [How to start a Workflow Execution using an SDK](/application-development/foundations#start-workflow-execution)\n- [How to start a Workflow Execution using tctl](/tctl/workflow/start)\n\nEach Temporal Workflow Execution has exclusive access to its local state.\nIt executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions through [Signals](#signal) and the environment through [Activities](/activities#).\nWhile a single Workflow Execution has limits on size and throughput, a Temporal Application can consist of millions to billions of Workflow Executions.\n\n**Durability**\n\nDurability is the absence of an imposed time limit.\n\nA Workflow Execution is durable because it executes a Temporal Workflow Definition (also called a Temporal Workflow Function), your application code, effectively once and to completionwhether your code executes for seconds or years.\n\n**Reliability**\n\nReliability is responsiveness in the presence of failure.\n\nA Workflow Execution is reliable, because it is fully recoverable after a failure.\nThe Temporal Platform ensures the state of the Workflow Execution persists in the face of failures and outages and resumes execution from the latest state.\n\n**Scalability**\n\nScalability is responsiveness in the presence of load.\n\nA single Workflow Execution is limited in size and throughput but is scalable because it can [Continue-As-New](#continue-as-new) in response to load.\nA Temporal Application is scalable because the Temporal Platform is capable of supporting millions to billions of Workflow Executions executing concurrently, which is realized by the design and nature of the [Temporal Cluster](/clusters#) and [Worker Processes](/workers#worker-process).\n\n### Commands & awaitables\n\nA Workflow Execution does two things:\n\n1. Issue [Commands](#command).\n2. Wait on an Awaitables (often called Futures).\n\n![Command generation and waiting](/diagrams/workflow-execution-progession-simple.svg)\n\nCommands are issued and Awaitables are provided by the use of Workflow APIs in the [Workflow Definition](#workflow-definition).\n\nCommands are generated whenever the Workflow Function is executed.\nThe Worker Process supervises the Command generation and makes sure that it maps to the current Event History.\n(For more information, see [Deterministic constraints](/concepts/what-is-a-workflow-definition/#deterministic-constraints).)\nThe Worker Process batches the Commands and then suspends progress to send the Commands to the Cluster whenever the Workflow Function reaches a place where it can no longer progress without a result from an Awaitable.\n\nA Workflow Execution may only ever block progress on an Awaitable that is provided through a Temporal SDK API.\nAwaitables are provided when using APIs for the following:\n\n- Awaiting: Progress can block using explicit \"Await\" APIs.\n- Requesting cancellation of another Workflow Execution: Progress can block on confirmation that the other Workflow Execution is cancelled.\n- Sending a [Signal](#signal): Progress can block on confirmation that the Signal sent.\n- Spawning a [Child Workflow Execution](#child-workflow): Progress can block on confirmation that the Child Workflow Execution started, and on the result of the Child Workflow Execution.\n- Spawning an [Activity Execution](/activities#activity-execution): Progress can block on the result of the Activity Execution.\n- Starting a Timer: Progress can block until the Timer fires.\n\n### Status\n\nA Workflow Execution can be either Open or Closed.\n\n![Workflow Execution statuses](/diagrams/workflow-execution-statuses.svg)\n\n**Open**\n\n- Running: The only Open status for a Workflow Execution.\n  When the Workflow Execution is Running, it is either actively progressing or is waiting on something.\n\n**Closed**\n\nA Closed status means that the Workflow Execution cannot make further progress because of one of the following reasons:\n\n- Cancelled: The Workflow Execution successfully handled a cancellation request.\n- Completed: The Workflow Execution has completed successfully.\n- Continued-As-New: The Workflow Execution [Continued-As-New](#continue-as-new).\n- Failed: The Workflow Execution returned an error and failed.\n- Terminated: The Workflow Execution was terminated.\n- Timed Out: The Workflow Execution reached a timeout limit.\n\n### Workflow Execution Chain\n\nA Workflow Execution Chain is a sequence of Workflow Executions that share the same Workflow Id.\nEach link in the Chain is often called a Workflow Run.\nEach Workflow Run in the sequence is connected by one of the following:\n\n- [Continue-As-New](#continue-as-new)\n- [Retries](/retry-policies#)\n- [Temporal Cron Job](#temporal-cron-job)\n\nA Workflow Execution is uniquely identified by its [Namespace](/namespaces#), [Workflow Id](#workflow-id), and [Run Id](#run-id).\n\nThe [Workflow Execution Timeout](#workflow-execution-timeout) applies to a Workflow Execution Chain.\nThe [Workflow Run Timeout](#workflow-run-timeout) applies to a single Workflow Execution (Workflow Run).\n\n### Event loop\n\nA Workflow Execution is made up of a sequence of [Events](#event) called an [Event History](#event-history).\nEvents are created by the Temporal Cluster in response to either Commands or actions requested by a Temporal Client (such as a request to spawn a Workflow Execution).\n\n![Workflow Execution](/diagrams/workflow-execution-swim-lane-01.svg)\n\n### Time constraints\n\n**Is there a limit to how long Workflows can run?**\n\nNo, there is no time constraint on how long a Workflow Execution can be Running.\n\nHowever, Workflow Executions intended to run indefinitely should be written with some care.\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\nThere is a hard limit of 50,000 Events in a Workflow Execution Event History, as well as a hard limit of 50 MB in terms of size.\nThe Temporal Cluster logs a warning at every 10,000 Events.\nWhen the Event History reaches 50,000 Events or the size limit of 50 MB, the Workflow Execution is forcefully terminated.\n\nTo prevent _runaway_ Workflow Executions, you can use the Workflow Execution Timeout, the Workflow Run Timeout, or both.\nA Workflow Execution Timeout can be used to limit the duration of Workflow Execution Chain, and a Workflow Run Timeout can be used to limit the duration an individual Workflow Execution (Run).\n\nYou can use the [Continue-As-New](#continue-as-new) feature to close the current Workflow Execution and create a new Workflow Execution in a single atomic operation.\nThe Workflow Execution spawned from Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\nFor example, it may be reasonable to use Continue-As-New once per day for a long-running Workflow Execution that is generating a large Event History.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-command","node":{"file_name":"what-is-a-command.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-command.md","id":"concepts/what-is-a-command","title":"What is a Command?","description":"A Command is a requested action issued by a Worker to the Temporal Cluster after a Workflow Task Execution completes.","label":"Command","tags":["term","explanation"],"markdown_content":"A Command is a requested action issued by a [Worker](/workers#) to the [Temporal Cluster](/clusters#) after a [Workflow Task Execution](/tasks#workflow-task-execution) completes.\n\nThe action that the Cluster takes is recorded in the [Workflow Execution's](#workflow-execution) [Event History](#event-history) as an [Event](#event).\nThe Workflow Execution can await on some of the Events that come as a result from some of the Commands.\n\nCommands are generated by the use of Workflow APIs in your code. During a Workflow Task Execution there may be several Commands that are generated.\nThe Commands are batched and sent to the Cluster as part of the Workflow Task Execution completion request, after the Workflow Task has progressed as far as it can with the Workflow function.\nThere will always be [WorkflowTaskStarted](/references/events/#workflowtaskstarted) and [WorkflowTaskCompleted](/references/events/#workflowtaskcompleted) Events in the Event History when there is a Workflow Task Execution completion request.\n\n![Commands are generated by the use of Workflow APIs in your code](/diagrams/commands.svg)\n\nCommands are described in the [Command reference](/references/commands) and are defined in the [Temporal gRPC API](https://github.com/temporalio/api/blob/master/temporal/api/command/v1/message.proto).","is_empty":false}},{"type":"h3","id":"concepts/what-is-an-event","node":{"file_name":"what-is-an-event.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-event.md","id":"concepts/what-is-an-event","title":"What is an Event?","description":"Events are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution.","label":"Event","tags":["term","explanation"],"markdown_content":"Events are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution. Each Event corresponds to an `enum` that is defined in the [Server API](https://github.com/temporalio/api/blob/master/temporal/api/enums/v1/event_type.proto).\n\nAll Events are recorded in the [Event History](#event-history).\n\nA list of all possible Events that could appear in a Workflow Execution Event History is provided in the [Event reference](/references/events).","is_empty":false}},{"type":"h3","id":"concepts/what-is-an-event-history","node":{"file_name":"what-is-an-event-history.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-an-event-history.md","id":"concepts/what-is-an-event-history","title":"What is an Event History?","description":"An append log of Events that represents the full state a Workflow Execution.","label":"Event History","tags":["term","explanation"],"markdown_content":"An append-log of [Events](#event) for your application.\n\n- Event History is durably persisted by the Temporal service, enabling seamless recovery of your application state from crashes or failures.\n- It also serves as an audit log for debugging.\n\n**Event History limits**\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\nThere is a hard limit of 50,000 Events in a Workflow Execution Event History, as well as a hard limit of 50 MB in terms of size.\nThe Temporal Cluster logs a warning at every 10,000 Events.\nWhen the Event History reaches 50,000 Events or the size limit of 50 MB, the Workflow Execution is forcefully terminated.","is_empty":false}},{"type":"h4","id":"concepts/what-is-continue-as-new","node":{"file_name":"what-is-continue-as-new.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-continue-as-new.md","id":"concepts/what-is-continue-as-new","title":"What is Continue-As-New?","description":"Continue-As-New is the mechanism by which all relevant state is passed to a new Workflow Execution with a fresh Event History.","label":"Continue-As-New","tags":["term","explanation","continue-as-new"],"markdown_content":"Continue-As-New is a mechanism by which the latest relevant state is passed to a new Workflow Execution, with a fresh Event History.\n\nAs a precautionary measure, the Temporal Platform limits the total [Event History](#event-history) to 50,000 Events or 50 MB, and will warn you every 10,000 Events or 10 MB.\nTo prevent a Workflow Execution Event History from exceeding this limit and failing, use Continue-As-New to start a new Workflow Execution with a fresh Event History.\n\nAll values passed to a Workflow Execution through parameters or returned through a result value are recorded into the Event History.\nA Temporal Cluster stores the full Event History of a Workflow Execution for the duration of a Namespace's retention period.\nA Workflow Execution that periodically executes many Activities has the potential of hitting the size limit.\n\nA very large Event History can adversely affect the performance of a Workflow Execution.\nFor example, in the case of a Workflow Worker failure, the full Event History must be pulled from the Temporal Cluster and given to another Worker via a Workflow Task.\nIf the Event history is very large, it may take some time to load it.\n\nThe Continue-As-New feature enables developers to complete the current Workflow Execution and start a new one atomically.\n\nThe new Workflow Execution has the same Workflow Id, but a different Run Id, and has its own Event History.\n\nIn the case of [Temporal Cron Jobs](#temporal-cron-job), Continue-As-New is actually used internally for the same effect.\n\n- [How to Continue-As-New](/application-development/features#continue-as-new)","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-run-id","node":{"file_name":"what-is-a-run-id.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-run-id.md","id":"concepts/what-is-a-run-id","title":"What is a Run Id?","description":"A Run Id is a globally unique, platform-level identifier for a Workflow Execution.","label":"Run Id","tags":["term","explanation"],"markdown_content":"A Run Id is a globally unique, platform-level identifier for a [Workflow Execution](#workflow-execution).\n\nTemporal guarantees that only one Workflow Execution with a given [Workflow Id](#workflow-id) can be in an Open state at any given time.\nBut when a Workflow Execution reaches a Closed state, it is possible to have another Workflow Execution in an Open state with the same Workflow Id.\nFor example, a Temporal Cron Job is a chain of Workflow Executions that all have the same Workflow Id.\nEach Workflow Execution within the chain is considered a _Run_.\n\nA Run Id uniquely identifies a Workflow Execution even if it shares a Workflow Id with other Workflow Executions.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-workflow-id","node":{"file_name":"what-is-a-workflow-id.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-id.md","id":"concepts/what-is-a-workflow-id","title":"What is a Workflow Id?","description":"A Workflow Id is a customizable, application-level identifier for a Workflow Execution that is unique to an Open Workflow Execution within a Namespace.","label":"Workflow Id","tags":["term","explanation"],"markdown_content":"A Workflow Id is a customizable, application-level identifier for a [Workflow Execution](#workflow-execution) that is unique to an Open Workflow Execution within a [Namespace](/namespaces).\n\n- [How to set a Workflow Id](/application-development/foundations#workflow-id)\n\nA Workflow Id is meant to be a business-process identifier such as customer identifier or order identifier.\n\nA [Workflow Id Reuse Policy](#workflow-id-reuse-policy) can be used to manage whether a Workflow Id can be re-used.\nThe Temporal Platform guarantees uniqueness of the Workflow Id within a [Namespace](/namespaces#) based on the Workflow Id Reuse Policy.\n\nIt is not possible for a new Workflow Execution to spawn with the same Workflow Id as another Open Workflow Execution, regardless of the Workflow Id Reuse Policy.\nAn attempt to spawn a Workflow Execution with a Workflow Id that is the same as the Id of a currently Open Workflow Execution results in a `Workflow execution already started` error.\n\nA Workflow Execution can be uniquely identified across all Namespaces by its [Namespace](/namespaces#), Workflow Id, and [Run Id](#run-id).","is_empty":false}},{"type":"h4","id":"concepts/what-is-a-workflow-id-reuse-policy","node":{"file_name":"what-is-a-workflow-id-reuse-policy.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-id-reuse-policy.md","id":"concepts/what-is-a-workflow-id-reuse-policy","title":"What is a Workflow Id Reuse Policy?","description":"A Workflow Id Reuse Policy determines whether a Workflow Execution is allowed to spawn with a particular Workflow Id, if that Workflow Id has been used with a previous, and now Closed, Workflow Execution.","label":"Workflow Id Reuse Policy","tags":["term","explanation"],"markdown_content":"A Workflow Id Reuse Policy determines whether a Workflow Execution is allowed to spawn with a particular Workflow Id, if that Workflow Id has been used with a previous, and now Closed, Workflow Execution.\n\nIt is not possible for a new Workflow Execution to spawn with the same Workflow Id as another Open Workflow Execution.\nAn attempt to spawn a Workflow Execution with a Workflow Id that is the same as the Id of a currently Open Workflow Execution results in a `Workflow execution already started` error.\n\nA Workflow Id Reuse Policy has three possible values:\n\n- **Allow Duplicate** The Workflow Execution is allowed to exist regardless of the Closed status of a previous Workflow Execution with the same Workflow Id.\n  **This is the default policy, if one is not specified.**\n  Use this when it is OK to have a Workflow Execution with the same Workflow Id as a previous, but now Closed, Workflow Execution.\n- **Allow Duplicate Failed Only**: The Workflow Execution is allowed to exist only if a previous Workflow Execution with the same Workflow Id does not have a Completed status.\n  Use this policy when there is a need to re-execute a Failed, Timed Out, Terminated or Cancelled Workflow Execution and guarantee that the Completed Workflow Execution will not be re-executed.\n- **Reject Duplicate**: The Workflow Execution cannot exist if a previous Workflow Execution has the same Workflow Id, regardless of the Closed status.\n  Use this when there can only be one Workflow Execution per Workflow Id within a Namespace for the given retention period.\n\nA Workflow Id Reuse Policy applies only if a Closed Workflow Execution with the same Workflow Id exists within the Retention Period of the associated Namespace.\nFor example, if the Namespace's retention period is 30 days, a Workflow Id Reuse Policy can only compare the Workflow Id of the spawning Workflow Execution against the Closed Workflow Executions for the last 30 days.\n\nIf there is an attempt to spawn a Workflow Execution with a Workflow Id Reuse Policy that won't allow it the Server will prevent the Workflow Execution from spawning.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-workflow-execution-timeout","node":{"file_name":"what-is-a-workflow-execution-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-execution-timeout.md","id":"concepts/what-is-a-workflow-execution-timeout","title":"What is a Workflow Execution Timeout?","description":"A Workflow Execution Timeout is the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["term","explanation","timeouts"],"markdown_content":"A Workflow Execution Timeout is the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n\n- [How to set a Workflow Execution Timeout](/application-development/features#workflow-execution-timeout)\n\n![Workflow Execution Timeout period](/diagrams/workflow-execution-timeout.svg)\n\n**The default value is  (infinite).**\nIf this timeout is reached, the Workflow Execution changes to a Timed Out status.\nThis timeout is different from the [Workflow Run Timeout](#workflow-run-timeout).\nThis timeout is most commonly used for stopping the execution of a [Temporal Cron Job](#temporal-cron-job) after a certain amount of time has passed.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-workflow-run-timeout","node":{"file_name":"what-is-a-workflow-run-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-run-timeout.md","id":"concepts/what-is-a-workflow-run-timeout","title":"What is a Workflow Run Timeout?","description":"This is the maximum amount of time that a single Workflow Run is restricted to.","label":"Workflow Run Timeout","tags":["term","explanation","timeouts"],"markdown_content":"A Workflow Run Timeout is the maximum amount of time that a single Workflow Run is restricted to.\n\n- [How to set a Workflow Run Timeout](/go/startworkflowoptions-reference/#workflowruntimeout)\n\n![Workflow Run Timeout period](/diagrams/workflow-run-timeout.svg)\n\n**The default is set to the same value as the [Workflow Execution Timeout](#workflow-execution-timeout).**\nThis timeout is most commonly used to limit the execution time of a single [Temporal Cron Job Execution](#temporal-cron-job).\n\nIf the Workflow Run Timeout is reached, the Workflow Execution is Terminated.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-workflow-task-timeout","node":{"file_name":"what-is-a-workflow-task-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-workflow-task-timeout.md","id":"concepts/what-is-a-workflow-task-timeout","title":"What is a Workflow Task Timeout?","description":"A Workflow Task Timeout is the maximum amount of time that the Temporal Server will wait for a Worker to start processing a Workflow Task after the Task has been pulled from the Task Queue.","label":"Workflow Task Timeout","tags":["term","explanation","timeouts"],"markdown_content":"A Workflow Task Timeout is the maximum amount of time allowed for a [Worker](/workers#) to execute a [Workflow Task](/tasks#workflow-task) after the Worker has pulled that Workflow Task from the [Task Queue](/tasks#task-queue).\n\n![Workflow Task Timeout period](/diagrams/workflow-task-timeout.svg)\n\n**The default value is 10 seconds.**\nThis timeout is primarily available to recognize whether a Worker has gone down so that the Workflow Execution can be recovered on a different Worker.\nThe main reason for increasing the default value would be to accommodate a Workflow Execution that has a very long Workflow Execution History that could take longer than 10 seconds for the Worker to load.\n\n**Implementation guides:**\n\n- [How to set a Workflow Task Timeout](/go/startworkflowoptions-reference/#workflowtasktimeout)","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-signal","node":{"file_name":"what-is-a-signal.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-signal.md","id":"concepts/what-is-a-signal","title":"What is a Signal?","description":"A Signal is an asynchronous request to a Workflow Execution.","label":"Signal","tags":["term","signals","explanation"],"markdown_content":"A Signal is an asynchronous request to a [Workflow Execution](#workflow-execution).\n\n- [How to develop, send, and handle Signals in code](/application-development/features#signals)\n- [How to send a Signal using tctl](/tctl/workflow/signal)\n\nA Signal delivers data to a running Workflow Execution.\nIt cannot return data to the caller; to do so, use a [Query](#queries) instead.\nThe Workflow code that handles a Signal can mutate Workflow state.\nA Signal can be sent from a Temporal Client or a Workflow.\nWhen a Signal is sent, it is received by the Cluster and recorded as an Event to the Workflow Execution [Event History](#event-history).\nA successful response from the Cluster means that the Signal has been persisted and will be delivered at least once to the Workflow Execution.[^1]\nThe next scheduled Workflow Task will contain the Signal Event.\n\nA Signal must include a destination (Namespace and Workflow Id) and name.\nIt can include a list of arguments.\n\nSignal handlers are Workflow functions that listen for Signals by the Signal name.\nSignals are delivered in the order they are received by the Cluster.\nIf multiple deliveries of a Signal would be a problem for your Workflow, add idempotency logic to your Signal handler that checks for duplicates.\n\n[^1]: The Cluster usually deduplicates Signals, but does not guarantee deduplication: During shard migration, two Signal Events (and therefore two deliveries to the Workflow Execution) can be recorded for a single Signal because the deduping info is stored only in memory.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-query","node":{"file_name":"what-is-a-query.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-query.md","id":"concepts/what-is-a-query","title":"What is a Query?","description":"A Query is a synchronous operation that is used to report the state of a Workflow Execution.","label":"Query","tags":["term","queries","explanation"],"markdown_content":"A Query is a synchronous operation that is used to get the state of a [Workflow Execution](#workflow-execution).\nThe state of a running Workflow Execution is constantly changing.\nQueries are available to expose the internal Workflow Execution state to the external world.\n\n- [How to send a Query using tctl](/tctl/workflow/query)\n- [How to send and handle Queries with an SDK](/application-development/features#queries)\n\nQueries are sent from a Temporal Client to a Workflow Execution.\nThe API call is synchronous.\nThe Query is identified at both ends by a Query name.\nThe Workflow must have a Query handler that is developed to handle that Query and provide data that represents the state of the Workflow Execution.\n\nQueries are strongly consistent and are guaranteed to return the most recent state.\nThis means that the data reflects the state of all confirmed Events that came in before the Query was sent.\nAn Event is considered confirmed if the call creating the Event returned success.\nEvents that are created while the Query is outstanding may or may not be reflected in the Workflow state the Query result is based on.\n\nA Query can carry arguments to specify the data it is requesting.\nAnd each Workflow can expose data to multiple types of Queries.\n\nA Query must never mutate the state of the Workflow Executionthat is, Queries are _read-only_ and cannot contain any blocking code.\nThis means, for example, that Query handling logic cannot schedule Activity Executions.\n\nSending Queries to completed Workflow Executions is supported, though Query reject conditions can be configured per Query.\n\n#### Stack Trace Query\n\nIn many SDKs, the Temporal Client exposes a predefined `__stack_trace` Query that returns the stack trace of all the threads owned by that Workflow Execution.\nThis is a great way to troubleshoot a Workflow Execution in production.\nFor example, if a Workflow Execution has been stuck at a state for longer than an expected period of time, you can send a `__stack_trace` Query to return the current call stack.\nThe `__stack_trace` Query name does not require special handling in your Workflow code.","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-child-workflow-execution","node":{"file_name":"what-is-a-child-workflow-execution.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-child-workflow-execution.md","id":"concepts/what-is-a-child-workflow-execution","title":"What is a Child Workflow Execution?","description":"A Child Workflow Execution is a Workflow Execution that is spawned from within another Workflow.","label":"Child Workflow","tags":["term","explanation","child-workflow"],"markdown_content":"A Child Workflow Execution is a [Workflow Execution](#workflow-execution) that is spawned from within another Workflow.\n\n- [How to start a Child Workflow Execution](/application-development/features#child-workflows)\n\nA Workflow Execution can be both a Parent and a Child Workflow Execution because any Workflow can spawn another Workflow.\n\n![Parent & Child Workflow Execution entity relationship](/diagrams/parent-child-workflow-execution-relationship.svg)\n\nA Parent Workflow Execution must await on the Child Workflow Execution to spawn.\nThe Parent can optionally await on the result of the Child Workflow Execution.\nConsider the Child's [Parent Close Policy](#parent-close-policy) if the Parent does not await on the result of the Child, which includes any use of Continue-As-New by the Parent.\n\nWhen a Parent Workflow Execution reaches a Closed status, the Cluster propagates Cancellation Requests or Terminations to Child Workflow Executions depending on the Child's Parent Close Policy.\n\nIf a Child Workflow Execution uses Continue-As-New, from the Parent Workflow Execution's perspective the entire chain of Runs is treated as a single execution.\n\n![Parent & Child Workflow Execution entity relationship with Continue As New](/diagrams/parent-child-workflow-execution-with-continue-as-new.svg)\n\n### When to use Child Workflows\n\n**Consider Workflow Execution Event History size limits.**\n\nAn individual Workflow Execution has an [Event History](#event-history) size limit, which imposes a couple of considerations for using Child Workflows.\n\nOn one hand, because Child Workflow Executions have their own Event Histories, they are often used to partition large workloads into smaller chunks.\nFor example, a single Workflow Execution does not have enough space in its Event History to spawn 100,000 [Activity Executions](/activities#activity-execution).\nBut a Parent Workflow Execution can spawn 1,000 Child Workflow Executions that each spawn 1,000 Activity Executions to achieve a total of 1,000,000 Activity Executions.\n\nOn the other hand, because a Parent Workflow Execution Event History contains [Events](#event) that correspond to the status of the Child Workflow Execution, a single Parent should not spawn more than 1,000 Child Workflow Executions.\n\nIn general, however, Child Workflow Executions result in more overall Events recorded in Event Histories than Activities.\nBecause each entry in an Event History is a _cost_ in terms of compute resources, this could become a factor in very large workloads.\nTherefore, we recommend starting with a single Workflow implementation that uses Activities until there is a clear need for Child Workflows.\n\n**Consider each Child Workflow Execution as a separate service.**\n\nBecause a Child Workflow Execution can be processed by a completely separate set of [Workers](/workers#) than the Parent Workflow Execution, it can act as an entirely separate service.\nHowever, this also means that a Parent Workflow Execution and a Child Workflow Execution do not share any local state.\nAs all Workflow Executions, they can communicate only via asynchronous [Signals](#signal).\n\n**Consider that a single Child Workflow Execution can represent a single resource.**\n\nAs all Workflow Executions, a Child Workflow Execution can create a one to one mapping with a resource.\nFor example, a Workflow that manages host upgrades could spawn a Child Workflow Execution per host.","is_empty":false}},{"type":"h3","id":"concepts/what-is-a-parent-close-policy","node":{"file_name":"what-is-a-parent-close-policy.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-parent-close-policy.md","id":"concepts/what-is-a-parent-close-policy","title":"What is a Parent Close Policy?","description":"If a Workflow Execution is a Child Workflow Execution, a Parent Close Policy determines what happens to the Workflow Execution if its Parent Workflow Execution changes to a Closed status (Completed, Failed, Timed out).","label":"Parent Close Policy","tags":["term","explanation","child-workflow-executions"],"markdown_content":"A Parent Close Policy determines what happens to a [Child Workflow Execution](#child-workflow) if its Parent changes to a Closed status (Completed, Failed, or Timed out).\n\n- [How to set a Parent Close Policy](/application-development/features#parent-close-policy)\n\nThere are three possible values:\n\n- **Abandon**: the Child Workflow Execution is not affected.\n- **Request Cancel**: a Cancellation request is sent to the Child Workflow Execution.\n- **Terminate** (default): the Child Workflow Execution is forcefully Terminated.\n\n[`ParentClosePolicy`](https://github.com/temporalio/api/blob/c1f04d0856a3ba2995e92717607f83536b5a44f5/temporal/api/enums/v1/workflow.proto#L44) proto definition.\n\nEach Child Workflow Execution may have its own Parent Close Policy.\nThis policy applies only to Child Workflow Executions and has no effect otherwise.\n\n![Parent Close Policy entity relationship](/diagrams/parent-close-policy.svg)\n\nYou can set policies per child, which means you can opt out of propagating terminates / cancels on a per-child basis.\nThis is useful for starting Child Workflows asynchronously (see [relevant issue here](https://community.temporal.io/t/best-way-to-create-an-async-child-workflow/114) or the corresponding SDK docs).","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-temporal-cron-job","node":{"file_name":"what-is-a-temporal-cron-job.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-temporal-cron-job.md","id":"concepts/what-is-a-temporal-cron-job","title":"What is a Temporal Cron Job?","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Job","tags":["term","explanation"],"markdown_content":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\n![Temporal Cron Job timeline](/diagrams/temporal-cron-job.svg)\n\nA Temporal Cron Job is similar to a classic unix cron job.\nJust as a unix cron job accepts a command and a schedule on which to execute that command, a Cron Schedule can be provided with the call to spawn a Workflow Execution.\nIf a Cron Schedule is provided, the Temporal Server will spawn an execution for the associated Workflow Type per the schedule.\n\nEach Workflow Execution within the series is considered a Run.\n\n- Each Run receives the same input parameters as the initial Run.\n- Each Run inherits the same Workflow Options as the initial Run.\n\nThe Temporal Server spawns the first Workflow Execution in the chain of Runs immediately.\nHowever, it calculates and applies a backoff (`firstWorkflowTaskBackoff`) so that the first Workflow Task of the Workflow Execution does not get placed into a Task Queue until the scheduled time.\nAfter each Run Completes, Fails, or reaches the [Workflow Run Timeout](#workflow-run-timeout), the same thing happens: the next run will be created immediately with a new `firstWorkflowTaskBackoff` that is calculated based on the current Server time and the defined Cron Schedule.\n\nThe Temporal Server spawns the next Run only after the current Run has Completed, Failed, or has reached the Workflow Run Timeout.\nThis means that, if a Retry Policy has also been provided, and a Run Fails or reaches the Workflow Run Timeout, the Run will first be retried per the Retry Policy until the Run Completes or the Retry Policy has been exhausted.\nIf the next Run, per the Cron Schedule, is due to spawn while the current Run is still Open (including retries), the Server automatically starts the new Run after the current Run completes successfully.\nThe start time for this new Run and the Cron definitions are used to calculate the `firstWorkflowTaskBackoff` that is applied to the new Run.\n\nA [Workflow Execution Timeout](#workflow-execution-timeout) is used to limit how long a Workflow can be executing (have an Open status), including retries and any usage of Continue As New.\nThe Cron Schedule runs until the Workflow Execution Timeout is reached or you terminate the Workflow.\n\n![Temporal Cron Job Run Failure with a Retry Policy](/diagrams/temporal-cron-job-failure-with-retry.svg)\n\n### Cron Schedules\n\nCron Schedules are interpreted in UTC time by default.\n\nThe Cron Schedule is provided as a string and must follow one of two specifications:\n\n**Classic specification**\n\nThis is what the \"classic\" specification looks like:\n\n```\n minute (0 - 59)\n  hour (0 - 23)\n   day of the month (1 - 31)\n    month (1 - 12)\n     day of the week (0 - 6) (Sunday to Saturday)\n    \n    \n* * * * *\n```\n\nFor example, `15 8 * * *` causes a Workflow Execution to spawn daily at 8:15 AM UTC.\nUse the [crontab guru site](https://crontab.guru/) to test your cron expressions.\n\n### `robfig` predefined schedules and intervals\n\nYou can also pass any of the [predefined schedules](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Predefined_schedules) or [intervals](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Intervals) described in the [`robfig/cron` documentation](https://pkg.go.dev/github.com/robfig/cron/v3).\n\n```\n| Schedules              | Description                                | Equivalent To |\n| ---------------------- | ------------------------------------------ | ------------- |\n| @yearly (or @annually) | Run once a year, midnight, Jan. 1st        | 0 0 1 1 *     |\n| @monthly               | Run once a month, midnight, first of month | 0 0 1 * *     |\n| @weekly                | Run once a week, midnight between Sat/Sun  | 0 0 * * 0     |\n| @daily (or @midnight)  | Run once a day, midnight                   | 0 0 * * *     |\n| @hourly                | Run once an hour, beginning of hour        | 0 * * * *     |\n```\n\nFor example, \"@weekly\" causes a Workflow Execution to spawn once a week at midnight between Saturday and Sunday.\n\nIntervals just take a string that can be accepted by [time.ParseDuration](http://golang.org/pkg/time/#ParseDuration).\n\n```\n@every <duration>\n```\n\n### Time zones\n\n_This feature only applies in Temporal 1.15 and up_\n\nYou can change the time zone that a Cron Schedule is interpreted in by prefixing the specification with `CRON_TZ=America/New_York ` (or your [desired time zone from tz](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)). `CRON_TZ=America/New_York 15 8 * * *` therefore spawns a Workflow Execution every day at 8:15 AM New York time, subject to caveats listed below.\n\nConsider that using time zones in production introduces a surprising amount of complexity and failure modes!\n**If at all possible, we recommend specifying Cron Schedules in UTC (the default)**.\n\nIf you need to use time zones, here are a few edge cases to keep in mind:\n\n- **Beware Daylight Saving Time**: If a Temporal Cron Job is scheduled around the time when daylight saving time (DST) begins or ends (for example, `30 2 * * *`), **it might run zero, one, or two times in a day**! The Cron library that we use does not do any special handling of DST transitions. Avoid schedules that include times that fall within DST transition periods.\n  - For example, in the US, DST begins at 2 AM. When you \"fall back,\" the clock goes `1:59  1:00  1:01  1:59  2:00  2:01 AM` and any Cron jobs that fall in that 1 AM hour are fired again. The inverse happens when clocks \"spring forward\" for DST, and Cron jobs that fall in the 2 AM hour are skipped.\n  - In other time zones like Chile and Iran, DST \"spring forward\" is at midnight. 11:59 PM is followed by 1 AM, which means `00:00:00` never happens.\n- **Self Hosting note**: If you manage your own Temporal Cluster, you are responsible for ensuring that it has access to current `tzdata` files. The official Docker images are built with [tzdata](https://docs.w3cub.com/go/time/tzdata/index) installed (provided by Alpine Linux), but ultimately you should be aware of how tzdata is deployed and updated in your infrastructure.\n- **Updating Temporal**: If you use the official Docker images, note that an upgrade of the Temporal Cluster may include an update to the tzdata files, which may change the meaning of your Cron Schedule. You should be aware of upcoming changes to the definitions of the time zones you use, particularly around daylight saving time start/end dates.\n- **Absolute Time Fixed at Start**: The absolute start time of the next Run is computed and stored in the database when the previous Run completes, and is not recomputed. This means that if you have a Cron Schedule that runs very infrequently, and the definition of the time zone changes between one Run and the next, the Run might happen at the wrong time. For example, `CRON_TZ=America/Los_Angeles 0 12 11 11 *` means \"noon in Los Angeles on November 11\" (normally not in DST). If at some point the government makes any changes (for example, move the end of DST one week later, or stay on permanent DST year-round), the meaning of that specification changes. In that first year, the Run happens at the wrong time, because it was computed using the older definition.\n\n### How to stop a Temporal Cron Job\n\nA Temporal Cron Job does not stop spawning Runs until it has been Terminated or until the [Workflow Execution Timeout](#workflow-execution-timeout) is reached.\n\nA Cancellation Request affects only the current Run.\n\nUse the Workflow Id in any requests to Cancel or Terminate.\n\n**Implementation guides:**\n\n- [How to set a Cron Schedule in Go](/go/startworkflowoptions-reference/#cronschedule)\n- [How to set a Cron Schedule in Java](/java/reference-workflowoptions/#cronschedule)\n- [How to set a Cron Schedule in PHP](/php/distributed-cron)\n- [How to set a Cron Schedule in Typescript](/typescript/clients)","is_empty":false}},{"type":"h2","id":"concepts/what-is-a-schedule","node":{"file_name":"what-is-a-schedule.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/concepts/what-is-a-schedule.md","id":"concepts/what-is-a-schedule","title":"What is a Schedule","description":"A Schedule enables the scheduling of Workflow Executions.","label":"Schedule","tags":["term","explanation"],"markdown_content":"A Schedule contains instructions for starting a [Workflow Execution](#workflow-execution) at specific times.\nSchedules provide a more flexible and user-friendly approach than [Temporal Cron Jobs](#temporal-cron-job).\n\n- [How to enable Schedules](#how-to-enable-schedules)\n- [How to operate Schedules using tctl](/tctl/schedule/)\n\nA Schedule has identity, and is independent of a Workflow Execution.\nThis differs from a Temporal Cron Job, which relies on a cron schedule as a property of the Workflow Execution.\n\n### Action\n\nThe Action of a Schedule is where the Workflow Execution properties are established, such as Workflow Type, Task Queue, parameters, and timeouts.\n\nWorkflow Executions started by a Schedule have the following additional properties:\n\n- The Action's timestamp is appended to the Workflow Id.\n- The `TemporalScheduledStartTime` [Search Attribute](/visibility#search-attribute) is added to the Workflow Execution.\n  The Action's timestamp is the value.\n- The `TemporalScheduledById` Search Attribute is added to the Workflow Execution.\n  The Schedule Id is the value.\n\n### Spec\n\nThere are two ways to express a Schedule Spec:\n\n- A simple interval, like \"every 30 minutes\" (measured from the Unix epoch, and optionally including a phase offset).\n- A calendar-based expression, similar to the \"cron expressions\" supported by lots of software, including the older Temporal Cron feature.\n\nCalendar expressions are given as separate named fields.\n\nFor example, in tctl they can be provided as JSON:\n\n```json\n{\n  \"year\": \"2022\",\n  \"month\": \"Jan,Apr,Jul,Oct\",\n  \"dayOfMonth\": \"1,15\",\n  \"hour\": \"11-14\"\n}\n```\n\nThe following calendar fields are available:\n\n- `year`\n- `month`\n- `dayOfMonth`\n- `dayOfWeek`\n- `hour`\n- `minute`\n- `second`\n\nEach field may contain a comma-separated list of ranges (or `*`), and each range may include a skip value following a slash.\n\nFor `month`, names of months may be used instead of integers (case-insensitive, abbreviations permitted).\nFor `dayOfWeek`, day-of-week names may be used.\n\nOther Spec features:\n\n**Multiple intervals/calendar expressions:** A Spec can have combinations of multiple intervals and/or calendar expressions to define a specific Schedule.\n\n**Time bounds:** Provide an absolute start or end time (or both) with a Spec to ensure that no actions are taken before the start time or after the end time.\n\n**Exclusions:** A Spec can contain exclusions in the form of zero or more calendar expressions.\nThis can be used to express scheduling like \"each Monday at noon except for holidays.\nYou'll have to provide your own set of exclusions and include it in each schedule; there are no pre-defined sets.\n(This feature isn't currently exposed in tctl or the Temporal Web UI.)\n\n**Jitter:** If given, a random offset between zero and the maximum jitter is added to each Action time (but bounded by the time until the next scheduled Action).\n\n**Time zones:** By default, calendar-based expressions are interpreted in UTC.\nTemporal recommends using UTC to avoid various surprising properties of time zones.\nIf you don't want to use UTC, you can provide the name of a time zone.\nThe time zone definition is loaded on the Temporal Server Worker Service from either disk or the fallback embedded in the binary.\n\nFor more operational control, embed the contents of the time zone database file in the Schedule Spec itself.\n(Note: this isn't currently exposed in tctl or the web UI.)\n\n### Pause\n\nA Schedule can be Paused.\nWhen a Schedule is Paused, the Spec has no effect.\nHowever, you can still force manual actions by using the [tctl schedule trigger](/tctl/schedule/trigger) command.\n\nTo assist communication among developers and operators, a notes field can be updated on pause or resume to store an explanation for the current state.\n\n### Backfill\n\nA Schedule can be Backfilled.\nWhen a Schedule is Backfilled, all the Actions that would have been taken over a specified time period are taken now (in parallel if the `AllowAll` [Overlap Policy](#overlap-policy) is used; sequentially if `BufferAll` is used).\nYou might use this to fill in runs from a time period when the Schedule was paused due to an external condition that's now resolved, or a period before the Schedule was created.\n\n### Limit number of Actions\n\nA Schedule can be limited to a certain number of scheduled Actions (that is, not trigger immediately).\nAfter that it will act as if it were paused.\n\n### Policies\n\nA Schedule supports a set of Policies that enable customizing behavior.\n\n#### Overlap Policy\n\nThe Overlap Policy controls what happens when it is time to start a Workflow Execution but a previously started Workflow Execution is still running.\nThe following options are available:\n\n- `Skip`: **Default**.\n  Nothing happens; the Workflow Execution is not started.\n- `BufferOne`: Starts the Workflow Execution as soon as the current one completes.\n  The buffer is limited to one.\n  If another Workflow Execution is supposed to start, but one is already in the buffer, only the one in the buffer eventually starts.\n- `BufferAll`: Allows an unlimited number of Workflows to buffer.\n  They are started sequentially.\n- `CancelOther`: Cancels the running Workflow Execution, and then starts the new one after the old one completes cancellation.\n- `TerminateOther`: Terminates the running Workflow Execution and starts the new one immediately.\n- `AllowAll` Starts any number of concurrent Workflow Executions.\n  With this policy (and only this policy), more than one Workflow Execution, started by the Schedule, can run simultaneously.\n\n#### Catchup Window\n\nThe Temporal Cluster might be down or unavailable at the time when a Schedule should take an Action.\nWhen it comes back up, the Catchup Window controls which missed Actions should be taken at that point.\nThe default is one minute, which means that the Schedule attempts to take any Actions that wouldn't be more than one minute late.\nAn outage that lasts longer than the Catchup Window could lead to missed Actions.\n(But you can always [Backfill](#backfill).)\n\n#### Pause-on-failure\n\nIf this policy is set, a Workflow Execution started by a Schedule that ends with a failure or timeout (but not Cancellation or Termination) causes the Schedule to automatically pause.\n\nNote that with the `AllowAll` Overlap Policy, this pause might not apply to the next Workflow Execution, because the next Workflow Execution might have started before the failed one finished.\nIt applies only to Workflow Executions that were scheduled to start after the failed one finished.\n\n### Last completion result\n\nA Workflow started by a Schedule can obtain the completion result from the most recent successful run.\n(How you do this depends on the SDK you're using.)\n\nFor overlap policies that don't allow overlap, the most recent successful run is straightforward to define.\nFor the `AllowAll` policy, it refers to the run that completed most recently, at the time that the run in question is started.\nConsider the following overlapping runs:\n\n```\ntime -------------------------------------------->\n A     |----------------------|\n B               |-------|\n C                          |---------------|\n D                                |--------------T\n```\n\nIf D asks for the last completion result at time T, it gets the result of A.\nNot B, even though B started more recently, because A completed later.\nAnd not C, even though C completed after A, because the result for D is captured when D is started, not when it's queried.\n\nFailures and timeouts do not affect the last completion result.\n\n### Last failure\n\nA Workflow started by a Schedule can obtain the details of the failure of the most recent run that ended at the time when the Workflow in question was started. Unlike last completion result, a _successful_ run _does_ reset the last failure.\n\n### How to enable Schedules\n\n:::info Experimental\n\nThe Scheduled Workflows feature is available in Temporal Server version 1.17.\nHowever the feature is in an experimental stage and is disabled by default.\n\nInternally, a Schedule is implemented as a Workflow.\nThese implementation Workflow Executions are visible to you as you navigate the Web UI and use tctl, though you should not interact with it directly.\n\nIn later versions the implementation Workflows will cease to be visible by default.\n\n:::\n\n**Requirements**\n\n- Temporal Server version 1.17 or later.\n- [Advanced Visibility](/visibility#advanced-visibility) optional.\n- The following dynamic config values:\n\n```yaml\nfrontend.enableSchedules:\n  - value: true\nworker.enableScheduler:\n  - value: true\n```\n\nIf you're familiar with Dynamic Config, you can also constrain these settings per Namespace as needed for your installation.","is_empty":false}}],"link_index":[{"file_dir":"/","guide_id":"workflows","local_ref":"","node_id":"concepts/what-is-a-workflow"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-definition","node_id":"concepts/what-is-a-workflow-definition"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-type","node_id":"concepts/what-is-a-workflow-type"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-execution","node_id":"concepts/what-is-a-workflow-execution"},{"file_dir":"/","guide_id":"workflows","local_ref":"command","node_id":"concepts/what-is-a-command"},{"file_dir":"/","guide_id":"workflows","local_ref":"event","node_id":"concepts/what-is-an-event"},{"file_dir":"/","guide_id":"workflows","local_ref":"event-history","node_id":"concepts/what-is-an-event-history"},{"file_dir":"/","guide_id":"workflows","local_ref":"continue-as-new","node_id":"concepts/what-is-continue-as-new"},{"file_dir":"/","guide_id":"workflows","local_ref":"run-id","node_id":"concepts/what-is-a-run-id"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-id","node_id":"concepts/what-is-a-workflow-id"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-id-reuse-policy","node_id":"concepts/what-is-a-workflow-id-reuse-policy"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-execution-timeout","node_id":"concepts/what-is-a-workflow-execution-timeout"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-run-timeout","node_id":"concepts/what-is-a-workflow-run-timeout"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-task-timeout","node_id":"concepts/what-is-a-workflow-task-timeout"},{"file_dir":"/","guide_id":"workflows","local_ref":"signal","node_id":"concepts/what-is-a-signal"},{"file_dir":"/","guide_id":"workflows","local_ref":"query","node_id":"concepts/what-is-a-query"},{"file_dir":"/","guide_id":"workflows","local_ref":"child-workflow","node_id":"concepts/what-is-a-child-workflow-execution"},{"file_dir":"/","guide_id":"workflows","local_ref":"parent-close-policy","node_id":"concepts/what-is-a-parent-close-policy"},{"file_dir":"/","guide_id":"workflows","local_ref":"temporal-cron-job","node_id":"concepts/what-is-a-temporal-cron-job"},{"file_dir":"/","guide_id":"workflows","local_ref":"schedule","node_id":"concepts/what-is-a-schedule"}],"markdown_content":"---\nid: workflows\ntitle: Workflows\nsidebar_label: Workflows\ndescription: This guide provides a comprehensive overview of Temporal Workflows.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nThis guide provides a comprehensive overview of Temporal Workflows.\n\nIn day-to-day conversations, the term _Workflow_ frequently denotes either a [Workflow Type](#workflow-type), a [Workflow Definition](#workflow-definition), or a [Workflow Execution](#workflow-execution).\nTemporal documentation aims to be explicit and differentiate between them.\n\n## Workflow Definition\n\nA Workflow Definition is the code that defines the constraints of a Workflow Execution.\n\n- [How to develop a Workflow Definition](/application-development/foundations#develop-workflows)\n\nA Workflow Definition is often also referred to as a Workflow Function.\nIn Temporal's documentation, a Workflow Definition refers to the source for the instance of a Workflow Execution, while a Workflow Function refers to the source for the instance of a Workflow Function Execution.\n\nA Workflow Execution effectively executes once to completion, while a Workflow Function Execution occurs many times during the life of a Workflow Execution.\n\nWe strongly recommend that you write a Workflow Definition in a language that has a corresponding Temporal SDK.\n\n### Deterministic constraints\n\nA critical aspect of developing Workflow Definitions is ensuring they exhibit certain deterministic traits  that is, making sure that the same Commands are emitted in the same sequence, whenever a corresponding Workflow Function Execution (instance of the Function Definition) is re-executed.\n\nThe execution semantics of a Workflow Execution include the re-execution of a Workflow Function.\nThe use of Workflow APIs in the function is what generates [Commands](#command).\nCommands tell the Cluster which Events to create and add to the Workflow Execution's Event History.\nWhen a Workflow Function executes, the Commands that are emitted are compared with the existing Event History.\nIf a corresponding Event already exists within the Event History that maps to the generation of that Command in the same sequence, and some specific metadata of that Command matches with some specific metadata of the Event, then the Function Execution progresses.\n\nFor example, using an SDK's \"Execute Activity\" API generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nWhen this API is called upon re-execution, that Command is compared with the Event that is in the same location within the sequence.\nThe Event in the sequence must be an [ActivityTaskScheduled](/references/events/#activitytaskscheduled) Event, where the Activity name is the same as what is in the Command.\n\nIf a generated Command doesn't match what it needs to in the existing Event History, then the Workflow Execution returns a _non-deterministic_ error.\n\nThe following are the two reasons why a Command might be generated out of sequence or the wrong Command might be generated altogether:\n\n1. Code changes are made to a Workflow Definition that is in use by a running Workflow Execution.\n2. There is intrinsic non-deterministic logic (such as inline random branching).\n\n### Code changes can cause non-deterministic behavior\n\nThe Workflow Definition can change in very limited ways once there is a Workflow Execution depending on it.\nTo alleviate non-deterministic issues that arise from code changes, we recommend using [Workflow Versioning](#workflow-versioning).\n\nFor example, let's say we have a Workflow Definition that defines the following sequence:\n\n1. Start and wait on a Timer/sleep.\n2. Spawn and wait on an Activity Execution.\n3. Complete.\n\nWe start a Worker and spawn a Workflow Execution that uses that Workflow Definition.\nThe Worker would emit the [StartTimer](/references/commands/#starttimer) Command and the Workflow Execution would become suspended.\n\nBefore the Timer is up, we change the Workflow Definition to the following sequence:\n\n1. Spawn and wait on an Activity Execution.\n2. Start and wait on a Timer/sleep.\n3. Complete.\n\nWhen the Timer fires, the next Workflow Task will cause the Workflow Function to re-execute.\nThe first Command the Worker sees would be ScheduleActivityTask Command, which wouldn't match up to the expected [TimerStarted](/references/events/#timerstarted) Event.\n\nThe Workflow Execution would fail and return a non-deterministic error.\n\nThe following are examples of minor changes that would not result in non-determinism errors when re-executing a History which already contain the Events:\n\n- Changing the duration of a Timer.\n- Changing the arguments to:\n  - The Activity Options in a call to spawn an Activity Execution (local or nonlocal).\n  - The Child Workflow Options in a call to spawn a Child Workflow Execution.\n  - Call to Signal an External Workflow Execution.\n\n### Intrinsic non-deterministic logic\n\nIntrinsic non-determinism is when a Workflow Function Execution might emit a different sequence of Commands on re-execution, regardless of whether all the input parameters are the same.\n\nFor example, a Workflow Definition can not have inline logic that branches (emits a different Command sequence) based off a local time setting or a random number.\nIn the representative pseudocode below, the `local_clock()` function returns the local time, rather than Temporal-defined time:\n\n```text\nfn your_workflow() {\n  if local_clock().is_before(\"12pm\") {\n    await workflow.sleep(duration_until(\"12pm\"))\n  } else {\n    await your_afternoon_activity()\n  }\n}\n```\n\nEach Temporal SDK offers APIs that enable Workflow Definitions to have logic that gets and uses time, random numbers, and data from unreliable resources.\nWhen those APIs are used, the results are stored as part of the Event History, which means that a re-executed Workflow Function will issue the same sequence of Commands, even if there is branching involved.\n\nIn other words, all operations that do not purely mutate the Workflow Execution's state should occur through a Temporal SDK API.\n\n### Workflow Versioning\n\nThe Workflow Versioning feature enables the creation of logical branching inside a Workflow Definition based on a developer specified version identifier.\nThis feature is useful for Workflow Definition logic needs to be updated, but there are running Workflow Executions that currently depends on it.\nIt is important to note that a practical way to handle different versions of Workflow Definitions, without using the versioning API, is to run the different versions on separate Task Queues.\n\n- [How to version Workflow Definitions in Go](/go/versioning)\n- [How to version Workflow Definitions in Java](/java/versioning)\n- [How to version Workflow Definitions in TypeScript](/typescript/patching)\n\n### Handling unreliable Worker Processes\n\nYou do not handle Worker Process failure or restarts in a Workflow Definition.\n\nWorkflow Function Executions are completely oblivious to the Worker Process in terms of failures or downtime.\nThe Temporal Platform ensures that the state of a Workflow Execution is recovered and progress resumes if there is an outage of either Worker Processes or the Temporal Cluster itself.\nThe only reason a Workflow Execution might fail is due to the code throwing an error or exception, not because of underlying infrastructure outages.\n\n### Workflow Type\n\nA Workflow Type is a name that maps to a Workflow Definition.\n\n- A single Workflow Type can be instantiated as multiple Workflow Executions.\n- A Workflow Type is scoped by a Task Queue.\n  It is acceptable to have the same Workflow Type name map to different Workflow definitions if they are using completely different Workers.\n\n![Workflow Type cardinality with Workflow Definitions and Workflow Executions](/diagrams/workflow-type-cardinality.svg)\n\n## Workflow Execution\n\nA Temporal Workflow Execution is a durable, reliable, and scalable function execution.\nIt is the main unit of execution of a [Temporal Application](/temporal#temporal-application).\n\n- [How to start a Workflow Execution using an SDK](/application-development/foundations#start-workflow-execution)\n- [How to start a Workflow Execution using tctl](/tctl/workflow/start)\n\nEach Temporal Workflow Execution has exclusive access to its local state.\nIt executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions through [Signals](#signal) and the environment through [Activities](/activities#).\nWhile a single Workflow Execution has limits on size and throughput, a Temporal Application can consist of millions to billions of Workflow Executions.\n\n**Durability**\n\nDurability is the absence of an imposed time limit.\n\nA Workflow Execution is durable because it executes a Temporal Workflow Definition (also called a Temporal Workflow Function), your application code, effectively once and to completionwhether your code executes for seconds or years.\n\n**Reliability**\n\nReliability is responsiveness in the presence of failure.\n\nA Workflow Execution is reliable, because it is fully recoverable after a failure.\nThe Temporal Platform ensures the state of the Workflow Execution persists in the face of failures and outages and resumes execution from the latest state.\n\n**Scalability**\n\nScalability is responsiveness in the presence of load.\n\nA single Workflow Execution is limited in size and throughput but is scalable because it can [Continue-As-New](#continue-as-new) in response to load.\nA Temporal Application is scalable because the Temporal Platform is capable of supporting millions to billions of Workflow Executions executing concurrently, which is realized by the design and nature of the [Temporal Cluster](/clusters#) and [Worker Processes](/workers#worker-process).\n\n### Commands & awaitables\n\nA Workflow Execution does two things:\n\n1. Issue [Commands](#command).\n2. Wait on an Awaitables (often called Futures).\n\n![Command generation and waiting](/diagrams/workflow-execution-progession-simple.svg)\n\nCommands are issued and Awaitables are provided by the use of Workflow APIs in the [Workflow Definition](#workflow-definition).\n\nCommands are generated whenever the Workflow Function is executed.\nThe Worker Process supervises the Command generation and makes sure that it maps to the current Event History.\n(For more information, see [Deterministic constraints](/concepts/what-is-a-workflow-definition/#deterministic-constraints).)\nThe Worker Process batches the Commands and then suspends progress to send the Commands to the Cluster whenever the Workflow Function reaches a place where it can no longer progress without a result from an Awaitable.\n\nA Workflow Execution may only ever block progress on an Awaitable that is provided through a Temporal SDK API.\nAwaitables are provided when using APIs for the following:\n\n- Awaiting: Progress can block using explicit \"Await\" APIs.\n- Requesting cancellation of another Workflow Execution: Progress can block on confirmation that the other Workflow Execution is cancelled.\n- Sending a [Signal](#signal): Progress can block on confirmation that the Signal sent.\n- Spawning a [Child Workflow Execution](#child-workflow): Progress can block on confirmation that the Child Workflow Execution started, and on the result of the Child Workflow Execution.\n- Spawning an [Activity Execution](/activities#activity-execution): Progress can block on the result of the Activity Execution.\n- Starting a Timer: Progress can block until the Timer fires.\n\n### Status\n\nA Workflow Execution can be either Open or Closed.\n\n![Workflow Execution statuses](/diagrams/workflow-execution-statuses.svg)\n\n**Open**\n\n- Running: The only Open status for a Workflow Execution.\n  When the Workflow Execution is Running, it is either actively progressing or is waiting on something.\n\n**Closed**\n\nA Closed status means that the Workflow Execution cannot make further progress because of one of the following reasons:\n\n- Cancelled: The Workflow Execution successfully handled a cancellation request.\n- Completed: The Workflow Execution has completed successfully.\n- Continued-As-New: The Workflow Execution [Continued-As-New](#continue-as-new).\n- Failed: The Workflow Execution returned an error and failed.\n- Terminated: The Workflow Execution was terminated.\n- Timed Out: The Workflow Execution reached a timeout limit.\n\n### Workflow Execution Chain\n\nA Workflow Execution Chain is a sequence of Workflow Executions that share the same Workflow Id.\nEach link in the Chain is often called a Workflow Run.\nEach Workflow Run in the sequence is connected by one of the following:\n\n- [Continue-As-New](#continue-as-new)\n- [Retries](/retry-policies#)\n- [Temporal Cron Job](#temporal-cron-job)\n\nA Workflow Execution is uniquely identified by its [Namespace](/namespaces#), [Workflow Id](#workflow-id), and [Run Id](#run-id).\n\nThe [Workflow Execution Timeout](#workflow-execution-timeout) applies to a Workflow Execution Chain.\nThe [Workflow Run Timeout](#workflow-run-timeout) applies to a single Workflow Execution (Workflow Run).\n\n### Event loop\n\nA Workflow Execution is made up of a sequence of [Events](#event) called an [Event History](#event-history).\nEvents are created by the Temporal Cluster in response to either Commands or actions requested by a Temporal Client (such as a request to spawn a Workflow Execution).\n\n![Workflow Execution](/diagrams/workflow-execution-swim-lane-01.svg)\n\n### Time constraints\n\n**Is there a limit to how long Workflows can run?**\n\nNo, there is no time constraint on how long a Workflow Execution can be Running.\n\nHowever, Workflow Executions intended to run indefinitely should be written with some care.\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\nThere is a hard limit of 50,000 Events in a Workflow Execution Event History, as well as a hard limit of 50 MB in terms of size.\nThe Temporal Cluster logs a warning at every 10,000 Events.\nWhen the Event History reaches 50,000 Events or the size limit of 50 MB, the Workflow Execution is forcefully terminated.\n\nTo prevent _runaway_ Workflow Executions, you can use the Workflow Execution Timeout, the Workflow Run Timeout, or both.\nA Workflow Execution Timeout can be used to limit the duration of Workflow Execution Chain, and a Workflow Run Timeout can be used to limit the duration an individual Workflow Execution (Run).\n\nYou can use the [Continue-As-New](#continue-as-new) feature to close the current Workflow Execution and create a new Workflow Execution in a single atomic operation.\nThe Workflow Execution spawned from Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\nFor example, it may be reasonable to use Continue-As-New once per day for a long-running Workflow Execution that is generating a large Event History.\n\n### Command\n\nA Command is a requested action issued by a [Worker](/workers#) to the [Temporal Cluster](/clusters#) after a [Workflow Task Execution](/tasks#workflow-task-execution) completes.\n\nThe action that the Cluster takes is recorded in the [Workflow Execution's](#workflow-execution) [Event History](#event-history) as an [Event](#event).\nThe Workflow Execution can await on some of the Events that come as a result from some of the Commands.\n\nCommands are generated by the use of Workflow APIs in your code. During a Workflow Task Execution there may be several Commands that are generated.\nThe Commands are batched and sent to the Cluster as part of the Workflow Task Execution completion request, after the Workflow Task has progressed as far as it can with the Workflow function.\nThere will always be [WorkflowTaskStarted](/references/events/#workflowtaskstarted) and [WorkflowTaskCompleted](/references/events/#workflowtaskcompleted) Events in the Event History when there is a Workflow Task Execution completion request.\n\n![Commands are generated by the use of Workflow APIs in your code](/diagrams/commands.svg)\n\nCommands are described in the [Command reference](/references/commands) and are defined in the [Temporal gRPC API](https://github.com/temporalio/api/blob/master/temporal/api/command/v1/message.proto).\n\n### Event\n\nEvents are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution. Each Event corresponds to an `enum` that is defined in the [Server API](https://github.com/temporalio/api/blob/master/temporal/api/enums/v1/event_type.proto).\n\nAll Events are recorded in the [Event History](#event-history).\n\nA list of all possible Events that could appear in a Workflow Execution Event History is provided in the [Event reference](/references/events).\n\n### Event History\n\nAn append-log of [Events](#event) for your application.\n\n- Event History is durably persisted by the Temporal service, enabling seamless recovery of your application state from crashes or failures.\n- It also serves as an audit log for debugging.\n\n**Event History limits**\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\nThere is a hard limit of 50,000 Events in a Workflow Execution Event History, as well as a hard limit of 50 MB in terms of size.\nThe Temporal Cluster logs a warning at every 10,000 Events.\nWhen the Event History reaches 50,000 Events or the size limit of 50 MB, the Workflow Execution is forcefully terminated.\n\n#### Continue-As-New\n\nContinue-As-New is a mechanism by which the latest relevant state is passed to a new Workflow Execution, with a fresh Event History.\n\nAs a precautionary measure, the Temporal Platform limits the total [Event History](#event-history) to 50,000 Events or 50 MB, and will warn you every 10,000 Events or 10 MB.\nTo prevent a Workflow Execution Event History from exceeding this limit and failing, use Continue-As-New to start a new Workflow Execution with a fresh Event History.\n\nAll values passed to a Workflow Execution through parameters or returned through a result value are recorded into the Event History.\nA Temporal Cluster stores the full Event History of a Workflow Execution for the duration of a Namespace's retention period.\nA Workflow Execution that periodically executes many Activities has the potential of hitting the size limit.\n\nA very large Event History can adversely affect the performance of a Workflow Execution.\nFor example, in the case of a Workflow Worker failure, the full Event History must be pulled from the Temporal Cluster and given to another Worker via a Workflow Task.\nIf the Event history is very large, it may take some time to load it.\n\nThe Continue-As-New feature enables developers to complete the current Workflow Execution and start a new one atomically.\n\nThe new Workflow Execution has the same Workflow Id, but a different Run Id, and has its own Event History.\n\nIn the case of [Temporal Cron Jobs](#temporal-cron-job), Continue-As-New is actually used internally for the same effect.\n\n- [How to Continue-As-New](/application-development/features#continue-as-new)\n\n### Run Id\n\nA Run Id is a globally unique, platform-level identifier for a [Workflow Execution](#workflow-execution).\n\nTemporal guarantees that only one Workflow Execution with a given [Workflow Id](#workflow-id) can be in an Open state at any given time.\nBut when a Workflow Execution reaches a Closed state, it is possible to have another Workflow Execution in an Open state with the same Workflow Id.\nFor example, a Temporal Cron Job is a chain of Workflow Executions that all have the same Workflow Id.\nEach Workflow Execution within the chain is considered a _Run_.\n\nA Run Id uniquely identifies a Workflow Execution even if it shares a Workflow Id with other Workflow Executions.\n\n### Workflow Id\n\nA Workflow Id is a customizable, application-level identifier for a [Workflow Execution](#workflow-execution) that is unique to an Open Workflow Execution within a [Namespace](/namespaces).\n\n- [How to set a Workflow Id](/application-development/foundations#workflow-id)\n\nA Workflow Id is meant to be a business-process identifier such as customer identifier or order identifier.\n\nA [Workflow Id Reuse Policy](#workflow-id-reuse-policy) can be used to manage whether a Workflow Id can be re-used.\nThe Temporal Platform guarantees uniqueness of the Workflow Id within a [Namespace](/namespaces#) based on the Workflow Id Reuse Policy.\n\nIt is not possible for a new Workflow Execution to spawn with the same Workflow Id as another Open Workflow Execution, regardless of the Workflow Id Reuse Policy.\nAn attempt to spawn a Workflow Execution with a Workflow Id that is the same as the Id of a currently Open Workflow Execution results in a `Workflow execution already started` error.\n\nA Workflow Execution can be uniquely identified across all Namespaces by its [Namespace](/namespaces#), Workflow Id, and [Run Id](#run-id).\n\n#### Workflow Id Reuse Policy\n\nA Workflow Id Reuse Policy determines whether a Workflow Execution is allowed to spawn with a particular Workflow Id, if that Workflow Id has been used with a previous, and now Closed, Workflow Execution.\n\nIt is not possible for a new Workflow Execution to spawn with the same Workflow Id as another Open Workflow Execution.\nAn attempt to spawn a Workflow Execution with a Workflow Id that is the same as the Id of a currently Open Workflow Execution results in a `Workflow execution already started` error.\n\nA Workflow Id Reuse Policy has three possible values:\n\n- **Allow Duplicate** The Workflow Execution is allowed to exist regardless of the Closed status of a previous Workflow Execution with the same Workflow Id.\n  **This is the default policy, if one is not specified.**\n  Use this when it is OK to have a Workflow Execution with the same Workflow Id as a previous, but now Closed, Workflow Execution.\n- **Allow Duplicate Failed Only**: The Workflow Execution is allowed to exist only if a previous Workflow Execution with the same Workflow Id does not have a Completed status.\n  Use this policy when there is a need to re-execute a Failed, Timed Out, Terminated or Cancelled Workflow Execution and guarantee that the Completed Workflow Execution will not be re-executed.\n- **Reject Duplicate**: The Workflow Execution cannot exist if a previous Workflow Execution has the same Workflow Id, regardless of the Closed status.\n  Use this when there can only be one Workflow Execution per Workflow Id within a Namespace for the given retention period.\n\nA Workflow Id Reuse Policy applies only if a Closed Workflow Execution with the same Workflow Id exists within the Retention Period of the associated Namespace.\nFor example, if the Namespace's retention period is 30 days, a Workflow Id Reuse Policy can only compare the Workflow Id of the spawning Workflow Execution against the Closed Workflow Executions for the last 30 days.\n\nIf there is an attempt to spawn a Workflow Execution with a Workflow Id Reuse Policy that won't allow it the Server will prevent the Workflow Execution from spawning.\n\n### Workflow Execution Timeout\n\nA Workflow Execution Timeout is the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n\n- [How to set a Workflow Execution Timeout](/application-development/features#workflow-execution-timeout)\n\n![Workflow Execution Timeout period](/diagrams/workflow-execution-timeout.svg)\n\n**The default value is  (infinite).**\nIf this timeout is reached, the Workflow Execution changes to a Timed Out status.\nThis timeout is different from the [Workflow Run Timeout](#workflow-run-timeout).\nThis timeout is most commonly used for stopping the execution of a [Temporal Cron Job](#temporal-cron-job) after a certain amount of time has passed.\n\n### Workflow Run Timeout\n\nA Workflow Run Timeout is the maximum amount of time that a single Workflow Run is restricted to.\n\n- [How to set a Workflow Run Timeout](/go/startworkflowoptions-reference/#workflowruntimeout)\n\n![Workflow Run Timeout period](/diagrams/workflow-run-timeout.svg)\n\n**The default is set to the same value as the [Workflow Execution Timeout](#workflow-execution-timeout).**\nThis timeout is most commonly used to limit the execution time of a single [Temporal Cron Job Execution](#temporal-cron-job).\n\nIf the Workflow Run Timeout is reached, the Workflow Execution is Terminated.\n\n### Workflow Task Timeout\n\nA Workflow Task Timeout is the maximum amount of time allowed for a [Worker](/workers#) to execute a [Workflow Task](/tasks#workflow-task) after the Worker has pulled that Workflow Task from the [Task Queue](/tasks#task-queue).\n\n![Workflow Task Timeout period](/diagrams/workflow-task-timeout.svg)\n\n**The default value is 10 seconds.**\nThis timeout is primarily available to recognize whether a Worker has gone down so that the Workflow Execution can be recovered on a different Worker.\nThe main reason for increasing the default value would be to accommodate a Workflow Execution that has a very long Workflow Execution History that could take longer than 10 seconds for the Worker to load.\n\n**Implementation guides:**\n\n- [How to set a Workflow Task Timeout](/go/startworkflowoptions-reference/#workflowtasktimeout)\n\n## Signal\n\nA Signal is an asynchronous request to a [Workflow Execution](#workflow-execution).\n\n- [How to develop, send, and handle Signals in code](/application-development/features#signals)\n- [How to send a Signal using tctl](/tctl/workflow/signal)\n\nA Signal delivers data to a running Workflow Execution.\nIt cannot return data to the caller; to do so, use a [Query](#queries) instead.\nThe Workflow code that handles a Signal can mutate Workflow state.\nA Signal can be sent from a Temporal Client or a Workflow.\nWhen a Signal is sent, it is received by the Cluster and recorded as an Event to the Workflow Execution [Event History](#event-history).\nA successful response from the Cluster means that the Signal has been persisted and will be delivered at least once to the Workflow Execution.[^1]\nThe next scheduled Workflow Task will contain the Signal Event.\n\nA Signal must include a destination (Namespace and Workflow Id) and name.\nIt can include a list of arguments.\n\nSignal handlers are Workflow functions that listen for Signals by the Signal name.\nSignals are delivered in the order they are received by the Cluster.\nIf multiple deliveries of a Signal would be a problem for your Workflow, add idempotency logic to your Signal handler that checks for duplicates.\n\n[^1]: The Cluster usually deduplicates Signals, but does not guarantee deduplication: During shard migration, two Signal Events (and therefore two deliveries to the Workflow Execution) can be recorded for a single Signal because the deduping info is stored only in memory.\n\n## Query\n\nA Query is a synchronous operation that is used to get the state of a [Workflow Execution](#workflow-execution).\nThe state of a running Workflow Execution is constantly changing.\nQueries are available to expose the internal Workflow Execution state to the external world.\n\n- [How to send a Query using tctl](/tctl/workflow/query)\n- [How to send and handle Queries with an SDK](/application-development/features#queries)\n\nQueries are sent from a Temporal Client to a Workflow Execution.\nThe API call is synchronous.\nThe Query is identified at both ends by a Query name.\nThe Workflow must have a Query handler that is developed to handle that Query and provide data that represents the state of the Workflow Execution.\n\nQueries are strongly consistent and are guaranteed to return the most recent state.\nThis means that the data reflects the state of all confirmed Events that came in before the Query was sent.\nAn Event is considered confirmed if the call creating the Event returned success.\nEvents that are created while the Query is outstanding may or may not be reflected in the Workflow state the Query result is based on.\n\nA Query can carry arguments to specify the data it is requesting.\nAnd each Workflow can expose data to multiple types of Queries.\n\nA Query must never mutate the state of the Workflow Executionthat is, Queries are _read-only_ and cannot contain any blocking code.\nThis means, for example, that Query handling logic cannot schedule Activity Executions.\n\nSending Queries to completed Workflow Executions is supported, though Query reject conditions can be configured per Query.\n\n#### Stack Trace Query\n\nIn many SDKs, the Temporal Client exposes a predefined `__stack_trace` Query that returns the stack trace of all the threads owned by that Workflow Execution.\nThis is a great way to troubleshoot a Workflow Execution in production.\nFor example, if a Workflow Execution has been stuck at a state for longer than an expected period of time, you can send a `__stack_trace` Query to return the current call stack.\nThe `__stack_trace` Query name does not require special handling in your Workflow code.\n\n## Child Workflow\n\nA Child Workflow Execution is a [Workflow Execution](#workflow-execution) that is spawned from within another Workflow.\n\n- [How to start a Child Workflow Execution](/application-development/features#child-workflows)\n\nA Workflow Execution can be both a Parent and a Child Workflow Execution because any Workflow can spawn another Workflow.\n\n![Parent & Child Workflow Execution entity relationship](/diagrams/parent-child-workflow-execution-relationship.svg)\n\nA Parent Workflow Execution must await on the Child Workflow Execution to spawn.\nThe Parent can optionally await on the result of the Child Workflow Execution.\nConsider the Child's [Parent Close Policy](#parent-close-policy) if the Parent does not await on the result of the Child, which includes any use of Continue-As-New by the Parent.\n\nWhen a Parent Workflow Execution reaches a Closed status, the Cluster propagates Cancellation Requests or Terminations to Child Workflow Executions depending on the Child's Parent Close Policy.\n\nIf a Child Workflow Execution uses Continue-As-New, from the Parent Workflow Execution's perspective the entire chain of Runs is treated as a single execution.\n\n![Parent & Child Workflow Execution entity relationship with Continue As New](/diagrams/parent-child-workflow-execution-with-continue-as-new.svg)\n\n### When to use Child Workflows\n\n**Consider Workflow Execution Event History size limits.**\n\nAn individual Workflow Execution has an [Event History](#event-history) size limit, which imposes a couple of considerations for using Child Workflows.\n\nOn one hand, because Child Workflow Executions have their own Event Histories, they are often used to partition large workloads into smaller chunks.\nFor example, a single Workflow Execution does not have enough space in its Event History to spawn 100,000 [Activity Executions](/activities#activity-execution).\nBut a Parent Workflow Execution can spawn 1,000 Child Workflow Executions that each spawn 1,000 Activity Executions to achieve a total of 1,000,000 Activity Executions.\n\nOn the other hand, because a Parent Workflow Execution Event History contains [Events](#event) that correspond to the status of the Child Workflow Execution, a single Parent should not spawn more than 1,000 Child Workflow Executions.\n\nIn general, however, Child Workflow Executions result in more overall Events recorded in Event Histories than Activities.\nBecause each entry in an Event History is a _cost_ in terms of compute resources, this could become a factor in very large workloads.\nTherefore, we recommend starting with a single Workflow implementation that uses Activities until there is a clear need for Child Workflows.\n\n**Consider each Child Workflow Execution as a separate service.**\n\nBecause a Child Workflow Execution can be processed by a completely separate set of [Workers](/workers#) than the Parent Workflow Execution, it can act as an entirely separate service.\nHowever, this also means that a Parent Workflow Execution and a Child Workflow Execution do not share any local state.\nAs all Workflow Executions, they can communicate only via asynchronous [Signals](#signal).\n\n**Consider that a single Child Workflow Execution can represent a single resource.**\n\nAs all Workflow Executions, a Child Workflow Execution can create a one to one mapping with a resource.\nFor example, a Workflow that manages host upgrades could spawn a Child Workflow Execution per host.\n\n### Parent Close Policy\n\nA Parent Close Policy determines what happens to a [Child Workflow Execution](#child-workflow) if its Parent changes to a Closed status (Completed, Failed, or Timed out).\n\n- [How to set a Parent Close Policy](/application-development/features#parent-close-policy)\n\nThere are three possible values:\n\n- **Abandon**: the Child Workflow Execution is not affected.\n- **Request Cancel**: a Cancellation request is sent to the Child Workflow Execution.\n- **Terminate** (default): the Child Workflow Execution is forcefully Terminated.\n\n[`ParentClosePolicy`](https://github.com/temporalio/api/blob/c1f04d0856a3ba2995e92717607f83536b5a44f5/temporal/api/enums/v1/workflow.proto#L44) proto definition.\n\nEach Child Workflow Execution may have its own Parent Close Policy.\nThis policy applies only to Child Workflow Executions and has no effect otherwise.\n\n![Parent Close Policy entity relationship](/diagrams/parent-close-policy.svg)\n\nYou can set policies per child, which means you can opt out of propagating terminates / cancels on a per-child basis.\nThis is useful for starting Child Workflows asynchronously (see [relevant issue here](https://community.temporal.io/t/best-way-to-create-an-async-child-workflow/114) or the corresponding SDK docs).\n\n## Temporal Cron Job\n\nA Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\n![Temporal Cron Job timeline](/diagrams/temporal-cron-job.svg)\n\nA Temporal Cron Job is similar to a classic unix cron job.\nJust as a unix cron job accepts a command and a schedule on which to execute that command, a Cron Schedule can be provided with the call to spawn a Workflow Execution.\nIf a Cron Schedule is provided, the Temporal Server will spawn an execution for the associated Workflow Type per the schedule.\n\nEach Workflow Execution within the series is considered a Run.\n\n- Each Run receives the same input parameters as the initial Run.\n- Each Run inherits the same Workflow Options as the initial Run.\n\nThe Temporal Server spawns the first Workflow Execution in the chain of Runs immediately.\nHowever, it calculates and applies a backoff (`firstWorkflowTaskBackoff`) so that the first Workflow Task of the Workflow Execution does not get placed into a Task Queue until the scheduled time.\nAfter each Run Completes, Fails, or reaches the [Workflow Run Timeout](#workflow-run-timeout), the same thing happens: the next run will be created immediately with a new `firstWorkflowTaskBackoff` that is calculated based on the current Server time and the defined Cron Schedule.\n\nThe Temporal Server spawns the next Run only after the current Run has Completed, Failed, or has reached the Workflow Run Timeout.\nThis means that, if a Retry Policy has also been provided, and a Run Fails or reaches the Workflow Run Timeout, the Run will first be retried per the Retry Policy until the Run Completes or the Retry Policy has been exhausted.\nIf the next Run, per the Cron Schedule, is due to spawn while the current Run is still Open (including retries), the Server automatically starts the new Run after the current Run completes successfully.\nThe start time for this new Run and the Cron definitions are used to calculate the `firstWorkflowTaskBackoff` that is applied to the new Run.\n\nA [Workflow Execution Timeout](#workflow-execution-timeout) is used to limit how long a Workflow can be executing (have an Open status), including retries and any usage of Continue As New.\nThe Cron Schedule runs until the Workflow Execution Timeout is reached or you terminate the Workflow.\n\n![Temporal Cron Job Run Failure with a Retry Policy](/diagrams/temporal-cron-job-failure-with-retry.svg)\n\n### Cron Schedules\n\nCron Schedules are interpreted in UTC time by default.\n\nThe Cron Schedule is provided as a string and must follow one of two specifications:\n\n**Classic specification**\n\nThis is what the \"classic\" specification looks like:\n\n```\n minute (0 - 59)\n  hour (0 - 23)\n   day of the month (1 - 31)\n    month (1 - 12)\n     day of the week (0 - 6) (Sunday to Saturday)\n    \n    \n* * * * *\n```\n\nFor example, `15 8 * * *` causes a Workflow Execution to spawn daily at 8:15 AM UTC.\nUse the [crontab guru site](https://crontab.guru/) to test your cron expressions.\n\n### `robfig` predefined schedules and intervals\n\nYou can also pass any of the [predefined schedules](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Predefined_schedules) or [intervals](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Intervals) described in the [`robfig/cron` documentation](https://pkg.go.dev/github.com/robfig/cron/v3).\n\n```\n| Schedules              | Description                                | Equivalent To |\n| ---------------------- | ------------------------------------------ | ------------- |\n| @yearly (or @annually) | Run once a year, midnight, Jan. 1st        | 0 0 1 1 *     |\n| @monthly               | Run once a month, midnight, first of month | 0 0 1 * *     |\n| @weekly                | Run once a week, midnight between Sat/Sun  | 0 0 * * 0     |\n| @daily (or @midnight)  | Run once a day, midnight                   | 0 0 * * *     |\n| @hourly                | Run once an hour, beginning of hour        | 0 * * * *     |\n```\n\nFor example, \"@weekly\" causes a Workflow Execution to spawn once a week at midnight between Saturday and Sunday.\n\nIntervals just take a string that can be accepted by [time.ParseDuration](http://golang.org/pkg/time/#ParseDuration).\n\n```\n@every <duration>\n```\n\n### Time zones\n\n_This feature only applies in Temporal 1.15 and up_\n\nYou can change the time zone that a Cron Schedule is interpreted in by prefixing the specification with `CRON_TZ=America/New_York ` (or your [desired time zone from tz](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)). `CRON_TZ=America/New_York 15 8 * * *` therefore spawns a Workflow Execution every day at 8:15 AM New York time, subject to caveats listed below.\n\nConsider that using time zones in production introduces a surprising amount of complexity and failure modes!\n**If at all possible, we recommend specifying Cron Schedules in UTC (the default)**.\n\nIf you need to use time zones, here are a few edge cases to keep in mind:\n\n- **Beware Daylight Saving Time**: If a Temporal Cron Job is scheduled around the time when daylight saving time (DST) begins or ends (for example, `30 2 * * *`), **it might run zero, one, or two times in a day**! The Cron library that we use does not do any special handling of DST transitions. Avoid schedules that include times that fall within DST transition periods.\n  - For example, in the US, DST begins at 2 AM. When you \"fall back,\" the clock goes `1:59  1:00  1:01  1:59  2:00  2:01 AM` and any Cron jobs that fall in that 1 AM hour are fired again. The inverse happens when clocks \"spring forward\" for DST, and Cron jobs that fall in the 2 AM hour are skipped.\n  - In other time zones like Chile and Iran, DST \"spring forward\" is at midnight. 11:59 PM is followed by 1 AM, which means `00:00:00` never happens.\n- **Self Hosting note**: If you manage your own Temporal Cluster, you are responsible for ensuring that it has access to current `tzdata` files. The official Docker images are built with [tzdata](https://docs.w3cub.com/go/time/tzdata/index) installed (provided by Alpine Linux), but ultimately you should be aware of how tzdata is deployed and updated in your infrastructure.\n- **Updating Temporal**: If you use the official Docker images, note that an upgrade of the Temporal Cluster may include an update to the tzdata files, which may change the meaning of your Cron Schedule. You should be aware of upcoming changes to the definitions of the time zones you use, particularly around daylight saving time start/end dates.\n- **Absolute Time Fixed at Start**: The absolute start time of the next Run is computed and stored in the database when the previous Run completes, and is not recomputed. This means that if you have a Cron Schedule that runs very infrequently, and the definition of the time zone changes between one Run and the next, the Run might happen at the wrong time. For example, `CRON_TZ=America/Los_Angeles 0 12 11 11 *` means \"noon in Los Angeles on November 11\" (normally not in DST). If at some point the government makes any changes (for example, move the end of DST one week later, or stay on permanent DST year-round), the meaning of that specification changes. In that first year, the Run happens at the wrong time, because it was computed using the older definition.\n\n### How to stop a Temporal Cron Job\n\nA Temporal Cron Job does not stop spawning Runs until it has been Terminated or until the [Workflow Execution Timeout](#workflow-execution-timeout) is reached.\n\nA Cancellation Request affects only the current Run.\n\nUse the Workflow Id in any requests to Cancel or Terminate.\n\n**Implementation guides:**\n\n- [How to set a Cron Schedule in Go](/go/startworkflowoptions-reference/#cronschedule)\n- [How to set a Cron Schedule in Java](/java/reference-workflowoptions/#cronschedule)\n- [How to set a Cron Schedule in PHP](/php/distributed-cron)\n- [How to set a Cron Schedule in Typescript](/typescript/clients)\n\n## Schedule\n\nA Schedule contains instructions for starting a [Workflow Execution](#workflow-execution) at specific times.\nSchedules provide a more flexible and user-friendly approach than [Temporal Cron Jobs](#temporal-cron-job).\n\n- [How to enable Schedules](#how-to-enable-schedules)\n- [How to operate Schedules using tctl](/tctl/schedule/)\n\nA Schedule has identity, and is independent of a Workflow Execution.\nThis differs from a Temporal Cron Job, which relies on a cron schedule as a property of the Workflow Execution.\n\n### Action\n\nThe Action of a Schedule is where the Workflow Execution properties are established, such as Workflow Type, Task Queue, parameters, and timeouts.\n\nWorkflow Executions started by a Schedule have the following additional properties:\n\n- The Action's timestamp is appended to the Workflow Id.\n- The `TemporalScheduledStartTime` [Search Attribute](/visibility#search-attribute) is added to the Workflow Execution.\n  The Action's timestamp is the value.\n- The `TemporalScheduledById` Search Attribute is added to the Workflow Execution.\n  The Schedule Id is the value.\n\n### Spec\n\nThere are two ways to express a Schedule Spec:\n\n- A simple interval, like \"every 30 minutes\" (measured from the Unix epoch, and optionally including a phase offset).\n- A calendar-based expression, similar to the \"cron expressions\" supported by lots of software, including the older Temporal Cron feature.\n\nCalendar expressions are given as separate named fields.\n\nFor example, in tctl they can be provided as JSON:\n\n```json\n{\n  \"year\": \"2022\",\n  \"month\": \"Jan,Apr,Jul,Oct\",\n  \"dayOfMonth\": \"1,15\",\n  \"hour\": \"11-14\"\n}\n```\n\nThe following calendar fields are available:\n\n- `year`\n- `month`\n- `dayOfMonth`\n- `dayOfWeek`\n- `hour`\n- `minute`\n- `second`\n\nEach field may contain a comma-separated list of ranges (or `*`), and each range may include a skip value following a slash.\n\nFor `month`, names of months may be used instead of integers (case-insensitive, abbreviations permitted).\nFor `dayOfWeek`, day-of-week names may be used.\n\nOther Spec features:\n\n**Multiple intervals/calendar expressions:** A Spec can have combinations of multiple intervals and/or calendar expressions to define a specific Schedule.\n\n**Time bounds:** Provide an absolute start or end time (or both) with a Spec to ensure that no actions are taken before the start time or after the end time.\n\n**Exclusions:** A Spec can contain exclusions in the form of zero or more calendar expressions.\nThis can be used to express scheduling like \"each Monday at noon except for holidays.\nYou'll have to provide your own set of exclusions and include it in each schedule; there are no pre-defined sets.\n(This feature isn't currently exposed in tctl or the Temporal Web UI.)\n\n**Jitter:** If given, a random offset between zero and the maximum jitter is added to each Action time (but bounded by the time until the next scheduled Action).\n\n**Time zones:** By default, calendar-based expressions are interpreted in UTC.\nTemporal recommends using UTC to avoid various surprising properties of time zones.\nIf you don't want to use UTC, you can provide the name of a time zone.\nThe time zone definition is loaded on the Temporal Server Worker Service from either disk or the fallback embedded in the binary.\n\nFor more operational control, embed the contents of the time zone database file in the Schedule Spec itself.\n(Note: this isn't currently exposed in tctl or the web UI.)\n\n### Pause\n\nA Schedule can be Paused.\nWhen a Schedule is Paused, the Spec has no effect.\nHowever, you can still force manual actions by using the [tctl schedule trigger](/tctl/schedule/trigger) command.\n\nTo assist communication among developers and operators, a notes field can be updated on pause or resume to store an explanation for the current state.\n\n### Backfill\n\nA Schedule can be Backfilled.\nWhen a Schedule is Backfilled, all the Actions that would have been taken over a specified time period are taken now (in parallel if the `AllowAll` [Overlap Policy](#overlap-policy) is used; sequentially if `BufferAll` is used).\nYou might use this to fill in runs from a time period when the Schedule was paused due to an external condition that's now resolved, or a period before the Schedule was created.\n\n### Limit number of Actions\n\nA Schedule can be limited to a certain number of scheduled Actions (that is, not trigger immediately).\nAfter that it will act as if it were paused.\n\n### Policies\n\nA Schedule supports a set of Policies that enable customizing behavior.\n\n#### Overlap Policy\n\nThe Overlap Policy controls what happens when it is time to start a Workflow Execution but a previously started Workflow Execution is still running.\nThe following options are available:\n\n- `Skip`: **Default**.\n  Nothing happens; the Workflow Execution is not started.\n- `BufferOne`: Starts the Workflow Execution as soon as the current one completes.\n  The buffer is limited to one.\n  If another Workflow Execution is supposed to start, but one is already in the buffer, only the one in the buffer eventually starts.\n- `BufferAll`: Allows an unlimited number of Workflows to buffer.\n  They are started sequentially.\n- `CancelOther`: Cancels the running Workflow Execution, and then starts the new one after the old one completes cancellation.\n- `TerminateOther`: Terminates the running Workflow Execution and starts the new one immediately.\n- `AllowAll` Starts any number of concurrent Workflow Executions.\n  With this policy (and only this policy), more than one Workflow Execution, started by the Schedule, can run simultaneously.\n\n#### Catchup Window\n\nThe Temporal Cluster might be down or unavailable at the time when a Schedule should take an Action.\nWhen it comes back up, the Catchup Window controls which missed Actions should be taken at that point.\nThe default is one minute, which means that the Schedule attempts to take any Actions that wouldn't be more than one minute late.\nAn outage that lasts longer than the Catchup Window could lead to missed Actions.\n(But you can always [Backfill](#backfill).)\n\n#### Pause-on-failure\n\nIf this policy is set, a Workflow Execution started by a Schedule that ends with a failure or timeout (but not Cancellation or Termination) causes the Schedule to automatically pause.\n\nNote that with the `AllowAll` Overlap Policy, this pause might not apply to the next Workflow Execution, because the next Workflow Execution might have started before the failed one finished.\nIt applies only to Workflow Executions that were scheduled to start after the failed one finished.\n\n### Last completion result\n\nA Workflow started by a Schedule can obtain the completion result from the most recent successful run.\n(How you do this depends on the SDK you're using.)\n\nFor overlap policies that don't allow overlap, the most recent successful run is straightforward to define.\nFor the `AllowAll` policy, it refers to the run that completed most recently, at the time that the run in question is started.\nConsider the following overlapping runs:\n\n```\ntime -------------------------------------------->\n A     |----------------------|\n B               |-------|\n C                          |---------------|\n D                                |--------------T\n```\n\nIf D asks for the last completion result at time T, it gets the result of A.\nNot B, even though B started more recently, because A completed later.\nAnd not C, even though C completed after A, because the result for D is captured when D is started, not when it's queried.\n\nFailures and timeouts do not affect the last completion result.\n\n### Last failure\n\nA Workflow started by a Schedule can obtain the details of the failure of the most recent run that ended at the time when the Workflow in question was started. Unlike last completion result, a _successful_ run _does_ reset the last failure.\n\n### How to enable Schedules\n\n:::info Experimental\n\nThe Scheduled Workflows feature is available in Temporal Server version 1.17.\nHowever the feature is in an experimental stage and is disabled by default.\n\nInternally, a Schedule is implemented as a Workflow.\nThese implementation Workflow Executions are visible to you as you navigate the Web UI and use tctl, though you should not interact with it directly.\n\nIn later versions the implementation Workflows will cease to be visible by default.\n\n:::\n\n**Requirements**\n\n- Temporal Server version 1.17 or later.\n- [Advanced Visibility](/visibility#advanced-visibility) optional.\n- The following dynamic config values:\n\n```yaml\nfrontend.enableSchedules:\n  - value: true\nworker.enableScheduler:\n  - value: true\n```\n\nIf you're familiar with Dynamic Config, you can also constrain these settings per Namespace as needed for your installation.\n\n"},{"file_name":"how-to-get-started-with-temporal-cloud.md","id":"how-to-get-started-with-temporal-cloud","file_dir":"cloud","title":"How to get started with Temporal Cloud","sidebar_label":"Get started","description":"Create an account, issue certificates, create a Namespace, invite users, and connect.","use_description":false,"toc_max_heading_level":4,"add_tabs_support":false,"sections":[{"type":"p","id":"cloud-context/get-started-intro","node":{"file_name":"get-started-intro.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/get-started-intro.md","id":"cloud-context/get-started-intro","title":"Get started with Temporal Cloud","description":"Create an account, issue certificates, create a Namespace, invite users, and connect.","label":"Get started","tags":["guide-context"],"markdown_content":":::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\n<!--- Onboarding guide for Temporal Cloud --->\n\nYou received email from Temporal that welcomes you to your new Temporal account.\nYour email address is now the first [Global Admin](/cloud/#account-level-roles) for your account.\n\nTo get started with Temporal Cloud, follow these onboarding steps:\n\n<!--- 1. [Create an account.](#create-an-account-in-temporal-cloud) --->\n\n1. [Issue CA certificates](#issue-ca-certificates).\n1. [Create a Namespace](#create-a-namespace).\n1. [Invite users](#invite-users).\n1. [Connect Temporal Clients and Worker Processes](#connect-temporal-clients-and-worker-processes).","is_empty":false}},{"type":"h2","id":"cloud-context/get-started-certificates","node":{"file_name":"get-started-certificates.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/get-started-certificates.md","id":"cloud-context/get-started-certificates","title":"Get started - Certificates","description":"Learn requirements for CA certificates","label":"Issue CA certificates","tags":["guide-context"],"markdown_content":"You must provide your own certificates to access Temporal Cloud.\nFor certificate requirements, see the following:\n\n- [Requirements for CA certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements)\n- [Issue root CA and end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#issue-certificates)","is_empty":false}},{"type":"h2","id":"cloud-context/get-started-namespace","node":{"file_name":"get-started-namespace.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/get-started-namespace.md","id":"cloud-context/get-started-namespace","title":"Get started - Namespaces","description":"Gather required information and use Temporal Cloud UI or tcld.","label":"Create a Namespace","tags":["guide-context"],"markdown_content":"If you don't already have a Namespace (or want to create another), see the following:\n\n[Create a Namespace in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud/#create-a-namespace-in-temporal-cloud)","is_empty":false}},{"type":"h2","id":"cloud-context/users-invite","node":{"file_name":"users-invite.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/users-invite.md","id":"cloud-context/users-invite","title":"Invite users","description":"Assign Roles and Namespace permissions, and send invites","label":"Invite users","tags":["guide-context"],"markdown_content":":::caution\n\nAccess to Temporal Cloud is authorized via single sign-on (SSO), currently limited to Google OAuth.\nThe email addresses of all users who need access to Temporal Cloud must be registered with Google.\n\nIf an email address is not associated with a Google Account, the user must follow the instructions in the [Use an existing email address](https://support.google.com/accounts/answer/27441?hl=en#existingemail) section of [Create a Google Account](https://support.google.com/accounts/answer/27441).\n\n**Important:** Do _not_ create a Gmail account when creating a Google Account.\n\n:::\n\nWhen you create a user in Temporal Cloud, the prospective user receives an email invitation.\nBefore accepting the invitation, the user must be logged in to Google using the email address that received the invitation.\nThe user must then click **Accept Invite** in the message.\nAttempting to log in to Temporal Cloud without first accepting the invite doesn't work.\n\n### Roles and permissions\n\nEach user in Temporal Cloud is assigned a Role.\nEach user can be assigned permissions for individual Namespaces.\n\n- [Account-level Roles](/cloud/#account-level-roles)\n- [Namespace-level permissions](/cloud/#namespace-level-permissions)\n\n<!--- How to invite users in Temporal Cloud using Web UI --->\n\n### Invite users using Web UI\n\n1. In Temporal Web UI, click **Settings** in the lower-left portion of the window.\n1. On the **Settings** page, click **Create Users** in the upper-right portion of the window.\n1. On the **Create Users** page in the **Email Addresses** box, type or paste one or more email addresses.\n1. In **Account-Level Role**, select a [Role](/cloud/#account-level-roles).\n   The Role applies to all users whose email addresses appear in **Email Addresses**.\n1. If the account has any Namespaces, they are listed under **Grant access to Namespaces**.\n   To add a permission, select the checkbox next to a Namespace, and then select a [permission](/cloud/#namespace-level-permissions).\n   Repeat as needed.\n1. When all permissions are assigned, click **Send Invite**.\n\nTemporal sends an email message to each user.\nTo join Temporal Cloud, a user must click **Accept Invite** in the message.","is_empty":false}},{"type":"h2","id":"cloud-context/get-started-connect","node":{"file_name":"get-started-connect.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/get-started-connect.md","id":"cloud-context/get-started-connect","title":"Get started - Connect","description":"Connect Temporal Clients and Worker Processes to Temporal Cloud.","label":"Connect Temporal Clients and Worker Processes","tags":["guide-context"],"markdown_content":"Connecting your [Temporal Clients](/temporal#temporal-client) and [Worker Processes](/workers#worker-process) to Temporal Cloud is similar to connecting them to your own [Temporal Cluster](/clusters).\nThe primary difference is the requirement to provide client certificates and private keys.\n\n- [Connect a Temporal Client](/application-development/foundations#connect-to-a-cluster)\n- [Connect a Worker Process](/application-development/foundations#run-worker-processes)","is_empty":false}}],"link_index":[{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"","node_id":"cloud-context/get-started-intro"},{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"issue-ca-certificates","node_id":"cloud-context/get-started-certificates"},{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"create-a-namespace","node_id":"cloud-context/get-started-namespace"},{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"invite-users","node_id":"cloud-context/users-invite"},{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"connect-temporal-clients-and-worker-processes","node_id":"cloud-context/get-started-connect"}],"markdown_content":"---\nid: how-to-get-started-with-temporal-cloud\ntitle: How to get started with Temporal Cloud\nsidebar_label: Get started\ndescription: Create an account, issue certificates, create a Namespace, invite users, and connect.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\n:::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\n<!--- Onboarding guide for Temporal Cloud --->\n\nYou received email from Temporal that welcomes you to your new Temporal account.\nYour email address is now the first [Global Admin](/cloud/#account-level-roles) for your account.\n\nTo get started with Temporal Cloud, follow these onboarding steps:\n\n<!--- 1. [Create an account.](#create-an-account-in-temporal-cloud) --->\n\n1. [Issue CA certificates](#issue-ca-certificates).\n1. [Create a Namespace](#create-a-namespace).\n1. [Invite users](#invite-users).\n1. [Connect Temporal Clients and Worker Processes](#connect-temporal-clients-and-worker-processes).\n\n## Issue CA certificates\n\nYou must provide your own certificates to access Temporal Cloud.\nFor certificate requirements, see the following:\n\n- [Requirements for CA certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements)\n- [Issue root CA and end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#issue-certificates)\n\n## Create a Namespace\n\nIf you don't already have a Namespace (or want to create another), see the following:\n\n[Create a Namespace in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud/#create-a-namespace-in-temporal-cloud)\n\n## Invite users\n\n:::caution\n\nAccess to Temporal Cloud is authorized via single sign-on (SSO), currently limited to Google OAuth.\nThe email addresses of all users who need access to Temporal Cloud must be registered with Google.\n\nIf an email address is not associated with a Google Account, the user must follow the instructions in the [Use an existing email address](https://support.google.com/accounts/answer/27441?hl=en#existingemail) section of [Create a Google Account](https://support.google.com/accounts/answer/27441).\n\n**Important:** Do _not_ create a Gmail account when creating a Google Account.\n\n:::\n\nWhen you create a user in Temporal Cloud, the prospective user receives an email invitation.\nBefore accepting the invitation, the user must be logged in to Google using the email address that received the invitation.\nThe user must then click **Accept Invite** in the message.\nAttempting to log in to Temporal Cloud without first accepting the invite doesn't work.\n\n### Roles and permissions\n\nEach user in Temporal Cloud is assigned a Role.\nEach user can be assigned permissions for individual Namespaces.\n\n- [Account-level Roles](/cloud/#account-level-roles)\n- [Namespace-level permissions](/cloud/#namespace-level-permissions)\n\n<!--- How to invite users in Temporal Cloud using Web UI --->\n\n### Invite users using Web UI\n\n1. In Temporal Web UI, click **Settings** in the lower-left portion of the window.\n1. On the **Settings** page, click **Create Users** in the upper-right portion of the window.\n1. On the **Create Users** page in the **Email Addresses** box, type or paste one or more email addresses.\n1. In **Account-Level Role**, select a [Role](/cloud/#account-level-roles).\n   The Role applies to all users whose email addresses appear in **Email Addresses**.\n1. If the account has any Namespaces, they are listed under **Grant access to Namespaces**.\n   To add a permission, select the checkbox next to a Namespace, and then select a [permission](/cloud/#namespace-level-permissions).\n   Repeat as needed.\n1. When all permissions are assigned, click **Send Invite**.\n\nTemporal sends an email message to each user.\nTo join Temporal Cloud, a user must click **Accept Invite** in the message.\n\n## Connect Temporal Clients and Worker Processes\n\nConnecting your [Temporal Clients](/temporal#temporal-client) and [Worker Processes](/workers#worker-process) to Temporal Cloud is similar to connecting them to your own [Temporal Cluster](/clusters).\nThe primary difference is the requirement to provide client certificates and private keys.\n\n- [Connect a Temporal Client](/application-development/foundations#connect-to-a-cluster)\n- [Connect a Worker Process](/application-development/foundations#run-worker-processes)\n\n"},{"file_name":"how-to-manage-certificates-in-temporal-cloud.md","id":"how-to-manage-certificates-in-temporal-cloud","file_dir":"cloud","title":"How to manage certificates in Temporal Cloud","sidebar_label":"Manage certificates","description":"Create certificates and use them to control access to Namespaces.","use_description":false,"toc_max_heading_level":4,"add_tabs_support":false,"sections":[{"type":"p","id":"cloud-context/certificates-intro","node":{"file_name":"certificates-intro.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/certificates-intro.md","id":"cloud-context/certificates-intro","title":"How to manage certificates in Temporal Cloud","description":"Access to Temporal Cloud requires a certificate from you.","label":"Manage certificates","tags":["how-to"],"markdown_content":":::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\nAccess to Temporal Cloud is secured with the mutual Transport Layer Security (mTLS) protocol.\nThis protocol requires a CA certificate from you.\n\nThe benefits of using a CA certificate include the following:\n\n- You can use your CA to issue client certificates to comply with your security policies for certificate expiration and rotation.\n  Client certificates can be issued and rotated without having to configure or update CA certificates shared with Temporal.\n- Temporal does not need to receive certificate private keys.\n  When you configure access to Temporal Cloud, no exchange of secrets is required.","is_empty":false}},{"type":"h2","id":"cloud-context/certificates-requirements","node":{"file_name":"certificates-requirements.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/certificates-requirements.md","id":"cloud-context/certificates-requirements","title":"Requirements for CA certificates in Temporal Cloud","description":"Certificates provided to Temporal for your Namespaces must meet certain requirements.","label":"Certificate requirements","tags":["how-to"],"markdown_content":"Certificates provided to Temporal for your [Namespaces](/namespaces) _must_ meet the following requirements.\n\n### CA certificates\n\nCA certificates _must_ meet the following criteria:\n\n- The certificates must be X.509v3.\n- Each certificate in the bundle must be either a root certificate or issued by another certificate in the bundle.\n- Each certificate in the bundle must include `CA: true`.\n- A certificate cannot be a well-known CA (such as DigiCert or Let's Encrypt) _unless_ the user also specifies certificate filters.\n- The signing algorithm must include SHA-256 or stronger.\n  SHA-1 and MD5 signing algorithms are rejected.\n\n### End-entity certificates\n\nAn end-entity (leaf) certificate _must_ meet the following criteria:\n\n- The certificate must be X.509v3.\n- Basic constraints must include `CA: false`.\n- The key usage must include Digital Signature.\n- The signing algorithm must include SHA-256 or stronger.\n  SHA-1 and MD5 signing algorithms are rejected.\n\nWhen a client presents an end-entity certificate, and the whole certificate chain is constructed, each certificate in the chain (from end-entity to the root) must have a unique Distinguished Name.\n\n:::caution\n\nDistinguished Names are _not_ case sensitive; that is, uppercase letters (such as ABC) and lowercase letters (such as abc) are equivalent.\n\n:::","is_empty":false}},{"type":"h2","id":"cloud-context/certificates-issue","node":{"file_name":"certificates-issue.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/certificates-issue.md","id":"cloud-context/certificates-issue","title":"How to issue root CA and end-entity certificates","description":"You can issue root CA and end-entity certificates in two ways.","label":"Issue certificates","tags":["how-to"],"markdown_content":"Temporal Cloud authenticates a client connection by validating the client certificate against one or more CA certificates that are configured for the specified Namespace.\n\n### Option 1: You already have certificate management infrastructure\n\nIf your existing certificate management infrastructure supports issuing CA and end-entity certificates, it satisfies the requirements.\nWhen you configure the client SDK, you must present a complete certificate chain up to the CA certificate given to Temporal.\n\n### Option 2: You have no certificate management infrastructure\n\nIf you don't have existing certificate management infrastructure, you can issue the CA and client certificates by using tools such as OpenSSL.\n\nWe also provide a tool that issues one root CA and the required end-entity certificate to use on the client SDK.\nThe tool can issue multiple end-entity certificates.\nWe've kept this tool minimal because it is a demonstration tool; **it is _not_ meant to be used in production.**\n\nYou can use this tool in two ways:\n\n- Follow the instructions for the [temporalio/client-certificate-generation](https://hub.docker.com/r/temporalio/client-certificate-generation) image in Docker Hub.\n  This procedure is the easiest because it's independent of your operating system.\n- Follow the README instructions in the [client-only](https://github.com/temporalio/samples-server/tree/main/tls/client-only) directory in our `temporalio/samples-server` repository in GitHub.\n\n:::info\n\nThe maximum number of CA certificates in a certificate bundle is 16. The payload size of a certificate bundle (before base64-encoding) is 32 KB.\n\n:::","is_empty":false}},{"type":"h2","id":"cloud-context/certificates-authorization","node":{"file_name":"certificates-authorization.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/certificates-authorization.md","id":"cloud-context/certificates-authorization","title":"How to control authorization for Temporal Cloud Namespaces","description":"Temporal Cloud requires full CA chains, so you can achieve authorization in two ways.","label":"Control authorization","tags":["how-to"],"markdown_content":"Because Temporal Cloud uses mTLS for authorization, we recommend that an end-entity certificate be scoped to a specific Namespace.\nTemporal Cloud requires full CA chains, so you can achieve authorization in two ways.\n\n### Option 1: Issue a separate root certificate for each Namespace\n\nEach certificate must belong to a chain up to the root CA certificate.\nTemporal uses the root CA certificate as the trusted authority for access to your Namespaces.\n\n1. Ensure that your certificates meet the [certificate requirements](#certificate-requirements).\n1. [Add client CA certificates to a Cloud Namespace](/cloud/tcld/namespace/accepted-client-ca/add).\n\n### Option 2: Use the same root certificate for all Namespaces but create a separate certificate filter for each Namespace\n\n[How to manage certificate filters in Temporal Cloud](#manage-certificate-filters-in-temporal-cloud)","is_empty":false}},{"type":"h2","id":"cloud-context/certificates-namespace","node":{"file_name":"certificates-namespace.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/certificates-namespace.md","id":"cloud-context/certificates-namespace","title":"How to add, update, and remove certificates in a Temporal Cloud Namespace","description":"To manage certificates for TemporalCloud Namespaces, use the `tcld namespace accepted-client-ca` commands.","label":"Manage certificates","tags":["how-to"],"markdown_content":"To manage certificates for Temporal Cloud Namespaces, use the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/) commands.","is_empty":false}},{"type":"h2","id":"cloud-context/certificates-filters","node":{"file_name":"certificates-filters.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/certificates-filters.md","id":"cloud-context/certificates-filters","title":"How to manage certificate filters in Temporal Cloud","description":"To limit access to specific CA certificates, you can create certificate filters.","label":"Manage certificate filters","tags":["how-to"],"markdown_content":"To limit access to specific [end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud), you can create certificate filters.\nEach filter contains values for one or more of the following fields:\n\n- commonName (CN)\n- organization (O)\n- organizationalUnit (OU)\n- subjectAlternativeName (SAN)\n\nCorresponding fields in the client certificate must match every specified value in the filter.\n\nThe values for the fields are case-insensitive.\nIf no wildcard is used, each specified value must match its field exactly.\n\nTo match a substring, place a single `*` wildcard at the beginning or end (but not both) of a value.\nYou cannot use a `*` wildcard by itself.\n\nYou can create a maximum of 25 certificate filters in a Namespace.\n\nIf you provide a well-known CA certificate, you cannot clear a certificate filter.\nA well-known CA certificate is one that is typically included in the certificate store of an operating system.\n\n**Examples**\n\nIn the following example, only the CN field of the certificate's subject is checked, and it must be exactly `code.example.com`.\nThe other fields are not checked.\n\n```json\nAuthorizedClientCertificate {\n  CN : \"code.example.com\"\n}\n```\n\nIn the following example, the CN field must be `stage.example.com` and the O field must be `Example Code Inc.`\n\n```json\nAuthorizedClientCertificate {\n  CN : \"stage.example.com\"\n  O : \"Example Code Inc.\"\n}\n```\n\nWhen using a `*` wildcard, the following values are valid:\n\n- `*.example.com` matches `code.example.com` and `text.example.com`.\n- `Example Code*` matches `Example code` and `Example Code Inc`.\n\nThe following values are not valid:\n\n- `.example.*`\n- `code.*.com`\n- `*`\n\n<!--- How to manage certificate filters in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage certificate filters using Temporal Cloud UI\n\nThis functionality is in development.\n\n<!--- How to manage certificate filters in Temporal Cloud using tcld --->\n\n### Manage certificate filters using tcld\n\nTo set or clear certificate filters, use the following [tcld](/cloud/tcld) commands:\n\n- [tcld namespace certificate-filters import](/cloud/tcld/namespace/certificate-filters/import)\n- [tcld namespace certificate-filters clear](/cloud/tcld/namespace/certificate-filters/clear)\n\nTo view the current certificate filters, use the [tcld namespace certificate-filters export](/cloud/tcld/namespace/certificate-filters/export) command.","is_empty":false}}],"link_index":[{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"","node_id":"cloud-context/certificates-intro"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"certificate-requirements","node_id":"cloud-context/certificates-requirements"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"issue-certificates","node_id":"cloud-context/certificates-issue"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"control-authorization","node_id":"cloud-context/certificates-authorization"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"manage-certificates","node_id":"cloud-context/certificates-namespace"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"manage-certificate-filters","node_id":"cloud-context/certificates-filters"}],"markdown_content":"---\nid: how-to-manage-certificates-in-temporal-cloud\ntitle: How to manage certificates in Temporal Cloud\nsidebar_label: Manage certificates\ndescription: Create certificates and use them to control access to Namespaces.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\n:::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\nAccess to Temporal Cloud is secured with the mutual Transport Layer Security (mTLS) protocol.\nThis protocol requires a CA certificate from you.\n\nThe benefits of using a CA certificate include the following:\n\n- You can use your CA to issue client certificates to comply with your security policies for certificate expiration and rotation.\n  Client certificates can be issued and rotated without having to configure or update CA certificates shared with Temporal.\n- Temporal does not need to receive certificate private keys.\n  When you configure access to Temporal Cloud, no exchange of secrets is required.\n\n## Certificate requirements\n\nCertificates provided to Temporal for your [Namespaces](/namespaces) _must_ meet the following requirements.\n\n### CA certificates\n\nCA certificates _must_ meet the following criteria:\n\n- The certificates must be X.509v3.\n- Each certificate in the bundle must be either a root certificate or issued by another certificate in the bundle.\n- Each certificate in the bundle must include `CA: true`.\n- A certificate cannot be a well-known CA (such as DigiCert or Let's Encrypt) _unless_ the user also specifies certificate filters.\n- The signing algorithm must include SHA-256 or stronger.\n  SHA-1 and MD5 signing algorithms are rejected.\n\n### End-entity certificates\n\nAn end-entity (leaf) certificate _must_ meet the following criteria:\n\n- The certificate must be X.509v3.\n- Basic constraints must include `CA: false`.\n- The key usage must include Digital Signature.\n- The signing algorithm must include SHA-256 or stronger.\n  SHA-1 and MD5 signing algorithms are rejected.\n\nWhen a client presents an end-entity certificate, and the whole certificate chain is constructed, each certificate in the chain (from end-entity to the root) must have a unique Distinguished Name.\n\n:::caution\n\nDistinguished Names are _not_ case sensitive; that is, uppercase letters (such as ABC) and lowercase letters (such as abc) are equivalent.\n\n:::\n\n## Issue certificates\n\nTemporal Cloud authenticates a client connection by validating the client certificate against one or more CA certificates that are configured for the specified Namespace.\n\n### Option 1: You already have certificate management infrastructure\n\nIf your existing certificate management infrastructure supports issuing CA and end-entity certificates, it satisfies the requirements.\nWhen you configure the client SDK, you must present a complete certificate chain up to the CA certificate given to Temporal.\n\n### Option 2: You have no certificate management infrastructure\n\nIf you don't have existing certificate management infrastructure, you can issue the CA and client certificates by using tools such as OpenSSL.\n\nWe also provide a tool that issues one root CA and the required end-entity certificate to use on the client SDK.\nThe tool can issue multiple end-entity certificates.\nWe've kept this tool minimal because it is a demonstration tool; **it is _not_ meant to be used in production.**\n\nYou can use this tool in two ways:\n\n- Follow the instructions for the [temporalio/client-certificate-generation](https://hub.docker.com/r/temporalio/client-certificate-generation) image in Docker Hub.\n  This procedure is the easiest because it's independent of your operating system.\n- Follow the README instructions in the [client-only](https://github.com/temporalio/samples-server/tree/main/tls/client-only) directory in our `temporalio/samples-server` repository in GitHub.\n\n:::info\n\nThe maximum number of CA certificates in a certificate bundle is 16. The payload size of a certificate bundle (before base64-encoding) is 32 KB.\n\n:::\n\n## Control authorization\n\nBecause Temporal Cloud uses mTLS for authorization, we recommend that an end-entity certificate be scoped to a specific Namespace.\nTemporal Cloud requires full CA chains, so you can achieve authorization in two ways.\n\n### Option 1: Issue a separate root certificate for each Namespace\n\nEach certificate must belong to a chain up to the root CA certificate.\nTemporal uses the root CA certificate as the trusted authority for access to your Namespaces.\n\n1. Ensure that your certificates meet the [certificate requirements](#certificate-requirements).\n1. [Add client CA certificates to a Cloud Namespace](/cloud/tcld/namespace/accepted-client-ca/add).\n\n### Option 2: Use the same root certificate for all Namespaces but create a separate certificate filter for each Namespace\n\n[How to manage certificate filters in Temporal Cloud](#manage-certificate-filters-in-temporal-cloud)\n\n## Manage certificates\n\nTo manage certificates for Temporal Cloud Namespaces, use the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/) commands.\n\n## Manage certificate filters\n\nTo limit access to specific [end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud), you can create certificate filters.\nEach filter contains values for one or more of the following fields:\n\n- commonName (CN)\n- organization (O)\n- organizationalUnit (OU)\n- subjectAlternativeName (SAN)\n\nCorresponding fields in the client certificate must match every specified value in the filter.\n\nThe values for the fields are case-insensitive.\nIf no wildcard is used, each specified value must match its field exactly.\n\nTo match a substring, place a single `*` wildcard at the beginning or end (but not both) of a value.\nYou cannot use a `*` wildcard by itself.\n\nYou can create a maximum of 25 certificate filters in a Namespace.\n\nIf you provide a well-known CA certificate, you cannot clear a certificate filter.\nA well-known CA certificate is one that is typically included in the certificate store of an operating system.\n\n**Examples**\n\nIn the following example, only the CN field of the certificate's subject is checked, and it must be exactly `code.example.com`.\nThe other fields are not checked.\n\n```json\nAuthorizedClientCertificate {\n  CN : \"code.example.com\"\n}\n```\n\nIn the following example, the CN field must be `stage.example.com` and the O field must be `Example Code Inc.`\n\n```json\nAuthorizedClientCertificate {\n  CN : \"stage.example.com\"\n  O : \"Example Code Inc.\"\n}\n```\n\nWhen using a `*` wildcard, the following values are valid:\n\n- `*.example.com` matches `code.example.com` and `text.example.com`.\n- `Example Code*` matches `Example code` and `Example Code Inc`.\n\nThe following values are not valid:\n\n- `.example.*`\n- `code.*.com`\n- `*`\n\n<!--- How to manage certificate filters in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage certificate filters using Temporal Cloud UI\n\nThis functionality is in development.\n\n<!--- How to manage certificate filters in Temporal Cloud using tcld --->\n\n### Manage certificate filters using tcld\n\nTo set or clear certificate filters, use the following [tcld](/cloud/tcld) commands:\n\n- [tcld namespace certificate-filters import](/cloud/tcld/namespace/certificate-filters/import)\n- [tcld namespace certificate-filters clear](/cloud/tcld/namespace/certificate-filters/clear)\n\nTo view the current certificate filters, use the [tcld namespace certificate-filters export](/cloud/tcld/namespace/certificate-filters/export) command.\n\n"},{"file_name":"how-to-manage-namespaces-in-temporal-cloud.md","id":"how-to-manage-namespaces-in-temporal-cloud","file_dir":"cloud","title":"How to manage Namespaces in Temporal Cloud","sidebar_label":"Manage Namespaces","description":"Create Namespaces, use Namespace endpoints for access, and obtain Namespace information.","use_description":false,"toc_max_heading_level":4,"add_tabs_support":false,"sections":[{"type":"p","id":"cloud-context/namespaces-intro","node":{"file_name":"namespaces-intro.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/namespaces-intro.md","id":"cloud-context/namespaces-intro","title":"How to manage Namespaces in Temporal Cloud","description":"You can create and manage Namespaces from your Temporal Cloud UI.","label":"Manage Namespaces","tags":["how-to"],"markdown_content":":::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\n- [Create a Namespace](#create-a-namespace-in-temporal-cloud)\n- [Access a Namespace](#access-a-namespace-in-temporal-cloud)\n- [Manage Namesapce](#manage-existing-namespaces-in-temporal-cloud)","is_empty":false}},{"type":"h2","id":"cloud-context/namespaces-create","node":{"file_name":"namespaces-create.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/namespaces-create.md","id":"cloud-context/namespaces-create","title":"How to create a Namespace in Temporal Cloud","description":"To create a Namespace in Temporal Cloud, use either Temporal Cloud UI or tcld.","label":"Create a Namespace","tags":["how-to"],"markdown_content":":::info\n\nThe user who creates a [Namespace](/namespaces) is automatically granted [Namespace Admin](/cloud/#namespace-level-permissions) permission for that Namespace.\n\n:::\n\n<!--- What information do I need to create a Namespace in Temporal Cloud? --->\n\n### Information needed to create a Namespace\n\nTo create a Namespace in Temporal Cloud, gather the following information:\n\n- [Namespace Name](/cloud/#cloud-namespace) and region\n- [Retention period](/clusters/#retention-period) for [Event History](/workflows#event-history) of closed [Workflow Executions](/workflows#workflow-executions)\n- [CA certificate](/cloud/how-to-manage-certificates-in-temporal-cloud#requirements-for-client-certificates) for the Namespace\n- [Permissions](/cloud/#namespace-level-permissions) for each user\n\n<!--- How to create a Namespace in Temporal Cloud using Temporal Cloud UI --->\n\n### Create a Namespace using Temporal Cloud UI\n\n1. Gather the information listed earlier in [Information needed to create a Namespace](#information-needed-to-create-a-namespace).\n1. Go to the Temporal Cloud UI and log in.\n1. On the left side of the window, click **Namespaces**.\n1. On the **Namespaces** page, click **Create Namespace** in the upper-right portion of the window.\n1. On the **Create Namespace** page in **Name**, enter the Namespace Name.\n1. In **Region**, select the region in which to host this Namespace.\n1. In **Retention Period**, specify a value from 1 to 30 days.\n   When choosing this value, consider your needs for Event History versus the cost of maintaining that Event History.\n   Typically, a development Namespace has a short retention period and a production Namespace has a longer retention period.\n   (If you need to change this value later, contact Temporal Support.)\n1. In **Certificate**, paste the CA certificate for this Namespace.\n1. Click **Create Namespace**.\n\n<!--- How to create a Namespace in Temporal Cloud using tcld --->\n\n### Create a Namespace using tcld\n\nThis functionality is in development.","is_empty":false}},{"type":"h2","id":"cloud-context/namespaces-access","node":{"file_name":"namespaces-access.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/namespaces-access.md","id":"cloud-context/namespaces-access","title":"How to access a Namespace in Temporal Cloud","description":"You can access a Namespace in Temporal Cloud via gRPC and HTTPS endpoints.","label":"Access Namespaces","tags":["how-to"],"markdown_content":"<!--- How to access a Namespace in Temporal Cloud --->\n\nEach Namespace in Temporal Cloud has two unique endpoints, both of which include the [Namespace Id](/cloud/#cloud-namespace-id).\n\n- For programmatic access, a gRPC endpoint in the form `<NamespaceId>.tmprl.cloud`; for example, `accounting-production.f45a2.tmprl.cloud:7233`.\n- For accessing Temporal Web UI, an HTTPS endpoint in the form `web.<namespaceId>.tmprl.cloud`; for example, `https://web.accounting-production.f45a2.tmprl.cloud`.","is_empty":false}},{"type":"h2","id":"cloud-context/namespaces-manage","node":{"file_name":"namespaces-manage.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/cloud-context/namespaces-manage.md","id":"cloud-context/namespaces-manage","title":"How to manage Namespaces in Temporal Cloud","description":"To manage Namespaces in Temporal Cloud, use either Temporal Cloud UI or tcld.","label":"Manage Namespaces","tags":["how-to"],"markdown_content":"<!--- How to manage Namespaces in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage Namespaces in Temporal Cloud using Temporal Cloud UI\n\nThis functionality is in development.\n\n<!--- How to manage Namespaces in Temporal Cloud using tcld --->\n\n### Manage Namespaces in Temporal Cloud using tcld\n\nTo list Namespaces and get information about them, use the following [tcld](/cloud/tcld/) commands:\n\n- [tcld namespace list](/cloud/tcld/namespace/list)\n- [tcld namespace get](/cloud/tcld/namespace/get)\n\nTo manage certificates, use the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/) commands.\nFor more information, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud).\n\nTo manage certificate filters, use the [tcld namespace certificate-filters](/cloud/tcld/namespace/certificate-filters/) commands.\nFor more information, see [How to manage certificate filters in Temporal Cloud](/cloud/#manage-certificate-filters-in-temporal-cloud).","is_empty":false}}],"link_index":[{"file_dir":"cloud","guide_id":"how-to-manage-namespaces-in-temporal-cloud","local_ref":"","node_id":"cloud-context/namespaces-intro"},{"file_dir":"cloud","guide_id":"how-to-manage-namespaces-in-temporal-cloud","local_ref":"create-a-namespace","node_id":"cloud-context/namespaces-create"},{"file_dir":"cloud","guide_id":"how-to-manage-namespaces-in-temporal-cloud","local_ref":"access-namespaces","node_id":"cloud-context/namespaces-access"},{"file_dir":"cloud","guide_id":"how-to-manage-namespaces-in-temporal-cloud","local_ref":"manage-namespaces","node_id":"cloud-context/namespaces-manage"}],"markdown_content":"---\nid: how-to-manage-namespaces-in-temporal-cloud\ntitle: How to manage Namespaces in Temporal Cloud\nsidebar_label: Manage Namespaces\ndescription: Create Namespaces, use Namespace endpoints for access, and obtain Namespace information.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\n:::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\n- [Create a Namespace](#create-a-namespace-in-temporal-cloud)\n- [Access a Namespace](#access-a-namespace-in-temporal-cloud)\n- [Manage Namesapce](#manage-existing-namespaces-in-temporal-cloud)\n\n## Create a Namespace\n\n:::info\n\nThe user who creates a [Namespace](/namespaces) is automatically granted [Namespace Admin](/cloud/#namespace-level-permissions) permission for that Namespace.\n\n:::\n\n<!--- What information do I need to create a Namespace in Temporal Cloud? --->\n\n### Information needed to create a Namespace\n\nTo create a Namespace in Temporal Cloud, gather the following information:\n\n- [Namespace Name](/cloud/#cloud-namespace) and region\n- [Retention period](/clusters/#retention-period) for [Event History](/workflows#event-history) of closed [Workflow Executions](/workflows#workflow-executions)\n- [CA certificate](/cloud/how-to-manage-certificates-in-temporal-cloud#requirements-for-client-certificates) for the Namespace\n- [Permissions](/cloud/#namespace-level-permissions) for each user\n\n<!--- How to create a Namespace in Temporal Cloud using Temporal Cloud UI --->\n\n### Create a Namespace using Temporal Cloud UI\n\n1. Gather the information listed earlier in [Information needed to create a Namespace](#information-needed-to-create-a-namespace).\n1. Go to the Temporal Cloud UI and log in.\n1. On the left side of the window, click **Namespaces**.\n1. On the **Namespaces** page, click **Create Namespace** in the upper-right portion of the window.\n1. On the **Create Namespace** page in **Name**, enter the Namespace Name.\n1. In **Region**, select the region in which to host this Namespace.\n1. In **Retention Period**, specify a value from 1 to 30 days.\n   When choosing this value, consider your needs for Event History versus the cost of maintaining that Event History.\n   Typically, a development Namespace has a short retention period and a production Namespace has a longer retention period.\n   (If you need to change this value later, contact Temporal Support.)\n1. In **Certificate**, paste the CA certificate for this Namespace.\n1. Click **Create Namespace**.\n\n<!--- How to create a Namespace in Temporal Cloud using tcld --->\n\n### Create a Namespace using tcld\n\nThis functionality is in development.\n\n## Access Namespaces\n\n<!--- How to access a Namespace in Temporal Cloud --->\n\nEach Namespace in Temporal Cloud has two unique endpoints, both of which include the [Namespace Id](/cloud/#cloud-namespace-id).\n\n- For programmatic access, a gRPC endpoint in the form `<NamespaceId>.tmprl.cloud`; for example, `accounting-production.f45a2.tmprl.cloud:7233`.\n- For accessing Temporal Web UI, an HTTPS endpoint in the form `web.<namespaceId>.tmprl.cloud`; for example, `https://web.accounting-production.f45a2.tmprl.cloud`.\n\n## Manage Namespaces\n\n<!--- How to manage Namespaces in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage Namespaces in Temporal Cloud using Temporal Cloud UI\n\nThis functionality is in development.\n\n<!--- How to manage Namespaces in Temporal Cloud using tcld --->\n\n### Manage Namespaces in Temporal Cloud using tcld\n\nTo list Namespaces and get information about them, use the following [tcld](/cloud/tcld/) commands:\n\n- [tcld namespace list](/cloud/tcld/namespace/list)\n- [tcld namespace get](/cloud/tcld/namespace/get)\n\nTo manage certificates, use the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/) commands.\nFor more information, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud).\n\nTo manage certificate filters, use the [tcld namespace certificate-filters](/cloud/tcld/namespace/certificate-filters/) commands.\nFor more information, see [How to manage certificate filters in Temporal Cloud](/cloud/#manage-certificate-filters-in-temporal-cloud).\n\n"},{"file_name":"features.md","file_dir":"application-development","id":"features","title":"Application development - Features","sidebar_label":"Features","description":"The Features section of the Temporal Application development guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.","use_description":false,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"app-dev-context/features","node":{"file_name":"features.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/features.md","id":"app-dev-context/features","title":"How to use Workflow and Activity features","description":"The Features section of the Temporal Application development guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.","label":"Features","tags":["guide-context"],"markdown_content":"The Features section of the Temporal Application development guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Application development guide, it could be in [older docs for SDKs](/sdks).\n\n:::\n\nIn this section you can find the following:\n\n- [How to develop Signals](#signals)\n- [How to develop Queries](#queries)\n- [How to start a Child Workflow Execution](#child-workflows)\n- [How to start a Temporal Cron Job](#cron-jobs)\n- [How to use Continue-As-New](#continue-as-new)\n- [How to set Workflow timeouts & retries](#workflow-timeouts--retries)\n- [How to set Activity timeouts & retries](#activity-timeouts--retries)\n- [How to Heartbeat an Activity](#activity-heartbeats)\n- [How to Asynchronously complete an Activity](#async-activity-completion)","is_empty":false}},{"type":"h2","id":"app-dev-context/signals","node":{"file_name":"signals.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/signals.md","id":"app-dev-context/signals","title":"How to develop with Signals","description":"A Signal is a message sent to a running Workflow Execution","label":"Signals","tags":["guide-context"],"markdown_content":"A [Signal](/workflows#signal) is a message sent to a running Workflow Execution.\n\nSignals are defined in your code and handled in your Workflow Definition.\nSignals can be sent to Workflow Executions from a Temporal Client or from another Workflow Execution.","is_empty":false}},{"type":"h3","id":"app-dev-context/define-signal","node":{"file_name":"define-signal.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/define-signal.md","id":"app-dev-context/define-signal","title":"How to define a Signal","description":"A Signal has a name and can have arguments.","label":"Define Signal","tags":["guide-context"],"markdown_content":"A Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter/).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-define-a-signal-in-go","node":{"file_name":"how-to-define-a-signal-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-define-a-signal-in-go.md","id":"go/how-to-define-a-signal-in-go","title":"How to define a Signal in Go","description":"Structs should be used to define Signals and carry data.","label":"Define Signal","tags":["go","developer-guide"],"markdown_content":"Structs should be used to define Signals and carry data, as long as the struct is [serializable via the Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#CompositeDataConverter.ToPayload).\nThe `Receive()` method on the Data Converter decodes the data into the Struct within the Workflow.\nOnly public fields are serializable.\n\n```go\nMySignal struct {\n\tMessage string // serializable\n\tmessage string // not serializable\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-define-a-signal-in-java","node":{"file_name":"how-to-define-a-signal-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-define-a-signal-in-java.md","id":"java/how-to-define-a-signal-in-java","title":"How to define Signals in Java","description":"Define a Signal method with `@SignalMethod` annotation in the Workflow interface.","label":"Define Signal","tags":["java","developer-guide"],"markdown_content":"The `@SignalMethod` annotation indicates that the method is used to handle and react to external Signals.\n\n```java\n @SignalMethod\n    void mySignal(String signalName);\n```\n\nThe method can have parameters that contain the Signal payload and must be serializable by the default Jackson JSON Payload Converter.\n\n```java\nvoid mySignal(String signalName, Object... args);\n```\n\nThis method does not return a value and must have a `void` return type.\n\nThings to consider when defining Signals:\n\n- Use Workflow object constructors and initialization blocks to initialize the internal data structures if possible.\n- Signals might be received by a Workflow before the Workflow method is executed.\n  When implementing Signals in scenarios where this can occur, assume that no parts of Workflow code ran.\n  In some cases, Signal method implementation might require some initialization to be performed by the Workflow method code firstfor example, when the Signal processing depends on, and is defined by the Workflow input.\n  In this case, you can use a flag to determine whether the Workflow method is already triggered; if not, persist the Signal data into a collection for delayed processing by the Workflow method.","is_empty":false}},{"lang":"php","id":"php/how-to-define-a-signal-in-php","node":{"file_name":"how-to-define-a-signal-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-define-a-signal-in-php.md","id":"php/how-to-define-a-signal-in-php","title":"How to define a Signal in PHP","label":"Define a Signal","markdown_content":"Workflows can answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow type defaults to `\"FileProcessingWorkflow\"`.","is_empty":false}},{"lang":"python","id":"python/how-to-define-a-signal-in-python","node":{"file_name":"how-to-define-a-signal-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-define-a-signal-in-python.md","id":"python/how-to-define-a-signal-in-python","title":"How to define a Signal in Python","description":"Define a Signal","label":"Define a Signal","tags":["developer-guide","sdk","python"],"markdown_content":"To define a Signal, set the Signal decorator [`@workflow.signal`](https://python.temporal.io/temporalio.workflow.html#signal) on the Signal function inside your Workflow.\n\n```python\n@workflow.signal\ndef your_signal(self, value: str) -> None:\n    self._signal = value\n```\n\nThe [`@workflow.signal`](https://python.temporal.io/temporalio.workflow.html#signal) decorator defines a method as a Signal. Signals can be asynchronous or synchronous methods and can be inherited; however, if a method is overridden, the override must also be decorated.\n\n**Dynamic Signals**\n\nYou can use `@workflow.signal(dynamic=True)`, which means all other unhandled Signals fall through to this.\n\nYour method parameters must be `self`, a string signal name, and a `*args` variable argument parameter.\n\nFor example:\n\n```python\n@workflow.signal(dynamic=True)\ndef signal_dynamic(self, name: str, *args: Any) -> None:\n    self._last_event = f\"signal_dynamic {name}: {args[0]}\"\n```\n\n**Customize name**\n\nNon-dynamic methods can only have positional arguments. Temporal suggests taking a single argument that is an\nobject or data class of fields that can be added to as needed.\n\nReturn values from Signal methods are ignored.\n\nYou can have a name parameter to customize the Signal's name, otherwise it defaults to the unqualified method `__name__`.\n\nThe following example sets a custom Signal name.\n\n```python\n@workflow.signal(name=\"Custom-Name\")\ndef signal(self, arg: str) -> None:\n    self._last_event = f\"signal: {arg}\"\n```\n\n:::note\n\nYou can either set the `name` or the `dynamic` parameter in a Signal's decorator, but not both.\n\n:::","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-define-a-signal-in-typescript","node":{"file_name":"how-to-define-a-signal-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-define-a-signal-in-typescript.md","id":"typescript/how-to-define-a-signal-in-typescript","title":"How to define a Signal in TypeScript","description":"Define Signal","label":"Define Signal","tags":["developer-guide","sdk","typescript"],"markdown_content":"[`defineSignal`](https://typescript.temporal.io/api/namespaces/workflow/#definesignal)\n\n```ts\nimport {defineSignal} from \"@temporalio/workflow\";\n\ninterface JoinInput {\n  userId: string;\n  groupId: string;\n}\n\nexport const joinSignal = defineSignal<[JoinInput]>(\"join\");\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/handle-signal","node":{"file_name":"handle-signal.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/handle-signal.md","id":"app-dev-context/handle-signal","title":"How to handle a Signal","description":"Workflows listen for Signals by the Signal's name.","label":"Handle Signal","tags":["guide-context"],"markdown_content":"Workflows listen for Signals by the Signal's name.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-handle-a-signal-in-go","node":{"file_name":"how-to-handle-a-signal-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-handle-a-signal-in-go.md","id":"go/how-to-handle-a-signal-in-go","title":"How to handle a Signal in Go","description":"Use the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.","label":"Handle Signal","tags":["go","how-to"],"markdown_content":"Use the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.\nGet a new [`Selector`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Selector) and pass it the Signal Channel and a callback function to handle the payload.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  // ...\n  var signal MySignal\n  signalChan := workflow.GetSignalChannel(ctx, \"your-signal-name\")\n  selector := workflow.NewSelector(ctx)\n  selector.AddReceive(signalChan, func(channel workflow.ReceiveChannel, more bool) {\n      channel.Receive(ctx, &signal)\n      // ...\n  })\n  selector.Select(ctx)\n  if len(signal.Message) > 0 && signal.Message != \"SOME_VALUE\" {\n      return errors.New(\"signal\")\n  }\n  // ...\n}\n```\n\nIn the example above, the Workflow code uses `workflow.GetSignalChannel` to open a `workflow.Channel` for the Signal type (identified by the Signal name).\nWe then use a [`workflow.Selector`](/go/selectors) and the `AddReceive()` to wait on a Signal from this channel.\nThe `more` bool in the callback function indicates that channel is not closed and more deliveries are possible.\n\nBefore completing the Workflow or using [Continue-As-New](/application-development/features#continue-as-new), make sure to do an asynchronous drain on the Signal channel.\nOtherwise, the Signals will be lost.","is_empty":false}},{"lang":"java","id":"java/how-to-handle-a-signal-in-a-workflow-in-java","node":{"file_name":"how-to-handle-a-signal-in-a-workflow-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-handle-a-signal-in-a-workflow-in-java.md","id":"java/how-to-handle-a-signal-in-a-workflow-in-java","title":"How to handle Signals in an Workflow in Java","description":"Use the `@SignalMethod` annotation to handle Signals within the Workflow interface.","label":"Handle Signals","tags":["java","developer-guide"],"markdown_content":"Use the `@SignalMethod` annotation to handle Signals in the Workflow interface.\n\nThe Signal type defaults to the name of the method. In the following example, the Signal type defaults to `retryNow`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod\n   void retryNow();\n}\n```\n\nTo overwrite this default naming and assign a custom Signal type, use the `@SignalMethod` annotation with the `name` parameter.\nIn the following example, the Signal type is set to `retrysignal`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod(name = \"retrysignal\")\n   void retryNow();\n}\n```\n\nA Workflow interface can define any number of methods annotated with `@SignalMethod`, but the method names or the `name` parameters for each must be unique.\n\nIn the following example, we define a Signal method `updateGreeting` to update the greeting in the Workflow.\nWe set a `Workflow.await` in the Workflow implementation to block the current Workflow Execution until the provided unblock condition is evaluated to `true`.\nIn this case, the unblocking condition is evaluated to `true` when the Signal to update the greeting is received.\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n}\n```\n\n```java\npublic class HelloWorldImpl implements HelloWorld {\n    private final Logger workflowLogger = Workflow.getLogger(HelloWorldImpl.class);\n    private String greeting;\n\n    @Override\n    public void sayHello(String name) {\n        int count = 0;\n        while (!\"Bye\".equals(greeting)) {\n            String oldGreeting = greeting;\n            Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n        }\n        workflowLogger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n        this.greeting = greeting;\n    }\n}\n```\n\nThis Workflow completes when the Signal updates the greeting to `Bye`.\n\n**Dynamic Signal Handler**\nYou can also implement Signal handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicSignalListener` in the Workflow implementation code.\n\n```java\n      Workflow.registerListener(\n        (DynamicSignalHandler)\n            (signalName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Signals sent to the Workflow without a defined handler will be delivered to the `DynamicSignalHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicSignalHandler` can be implemented in both regular and dynamic Workflow implementations.","is_empty":false}},{"lang":"php","id":"php/how-to-handle-a-signal-in-a-workflow-in-php","node":{"file_name":"how-to-handle-a-signal-in-a-workflow-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-handle-a-signal-in-a-workflow-in-php.md","id":"php/how-to-handle-a-signal-in-a-workflow-in-php","title":"How to handle Signals in an Workflow in PHP","description":"Use the `#[SignalMethod]` annotation to handle Signals within the Workflow interface.","label":"Handle Signals","tags":["php","developer-guide"],"markdown_content":"Use the `#[SignalMethod]` annotation to handle Signals in the Workflow interface:\n\n```php\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private bool $value;\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        yield Workflow::await(fn()=> $this->value);\n        return 'OK';\n    }\n\n    #[Workflow\\SignalMethod]\n    public function setValue(bool $value)\n    {\n        $this->value = $value;\n    }\n}\n```\n\nIn the example above the workflow updates the protected value. Main workflow coroutine waits for such value to change using\n`Workflow::await()` function.","is_empty":false}},{"lang":"python","id":"python/how-to-handle-a-signal-in-a-workflow-in-python","node":{"file_name":"how-to-handle-a-signal-in-a-workflow-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-handle-a-signal-in-a-workflow-in-python.md","id":"python/how-to-handle-a-signal-in-a-workflow-in-python","title":"How to handle a Signal in a Workflow","description":"Handle a Signal in a Workflow","label":"Handle a Signal in a Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"To send a Signal to the Workflow, use the [`signal`](https://python.temporal.io/temporalio.client.workflowhandle#signal) method from the [`WorkflowHandle`](https://python.temporal.io/temporalio.client.workflowhandle) class.\n\n```python\nawait handle.signal(\"some signal\")\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-handle-a-signal-in-typescript","node":{"file_name":"how-to-handle-a-signal-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-handle-a-signal-in-typescript.md","id":"typescript/how-to-handle-a-signal-in-typescript","title":"How to handle a Signal in TypeScript","description":"Handle Signal","label":"Handle Signal","tags":["developer-guide","sdk","typescript"],"markdown_content":"[`setHandler`](https://typescript.temporal.io/api/namespaces/workflow/#sethandler)\n\n```ts\nimport {setHandler} from \"@temporalio/workflow\";\n\nexport async function yourWorkflow() {\n  const groups = new Map<string, Set<string>>();\n\n  setHandler(joinSignal, ({userId, groupId}: JoinInput) => {\n    const group = groups.get(groupId);\n    if (group) {\n      group.add(userId);\n    } else {\n      groups.set(groupId, new Set([userId]));\n    }\n  });\n}\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/send-signal-from-client","node":{"file_name":"send-signal-from-client.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/send-signal-from-client.md","id":"app-dev-context/send-signal-from-client","title":"How to send a Signal from a Temporal Client","description":"When a Signal is sent successfully from the Temporal Client, the WorkflowExecutionSignaled Event appears in the Event History of the Workflow that receives the Signal.","label":"Send Signal from Client","tags":["guide-context"],"markdown_content":"When a Signal is sent successfully from the Temporal Client, the [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Event History of the Workflow that receives the Signal.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-send-a-signal-from-a-client-in-go","node":{"file_name":"how-to-send-a-signal-from-a-client-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-send-a-signal-from-a-client-in-go.md","id":"go/how-to-send-a-signal-from-a-client-in-go","title":"How to send a Signal from a Temporal Client in Go","description":"Use the `SignalWorkflow()` method on an instance of the Go SDK Temporal Client to send a Signal to a Workflow Execution.","label":"Send Signal from Client","tags":["go","how-to"],"markdown_content":"Use the `SignalWorkflow()` method on an instance of the [Go SDK Temporal Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) to send a [Signal](/workflows#signal) to a [Workflow Execution](/workflows#workflow-execution).\n\nPass in both the [Workflow Id](/workflows#workflow-id) and [Run Id](/workflows#run-id) to uniquely identify the Workflow Execution.\nIf only the Workflow Id is supplied (provide an empty string as the Run Id param), the Workflow Execution that is Running receives the Signal.\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWorkflow(context.Background(), \"your-workflow-id\", runID, \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n// ...\n```\n\nPossible errors:\n\n- `serviceerror.NotFound`\n- `serviceerror.Internal`\n- `serviceerror.Unavailable`","is_empty":false}},{"lang":"java","id":"java/how-to-send-a-signal-from-a-client-in-java","node":{"file_name":"how-to-send-a-signal-from-a-client-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-send-a-signal-from-a-client-in-java.md","id":"java/how-to-send-a-signal-from-a-client-in-java","title":"How to send a Signal from a Client in Java","description":"To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.","label":"Send Signal from Client","tags":["java","developer-guide"],"markdown_content":"To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.\n\nIn the following Client code example, we start the Workflow `greetCustomer` and call the Signal method `addCustomer` that is handled in the Workflow.\n\n```java\n// create a typed Workflow stub for GreetingsWorkflow\nGreetingsWorkflow workflow = client.newWorkflowStub(GreetingsWorkflow.class,\n        WorkflowOptions.newBuilder()\n                // set the Task Queue\n                .setTaskQueue(taskQueue)\n                // Workflow Id is recommended but not required\n                .setWorkflowId(workflowId)\n                .build());\n\n// start the Workflow\nWorkflowClient.start(workflow::greetCustomer);\n// send a Signal to the Workflow\nCustomer customer = new Customer(\"John\", \"Spanish\", \"john@john.com\");\nworkflow.addCustomer(customer); //addCustomer is the Signal method defined in the greetCustomer Workflow.\n```\n\nSee [Handle Signals](#handle-signal) for details on how to handle Signals in a Workflow.","is_empty":false}},{"lang":"php","id":"php/how-to-send-a-signal-from-a-client-in-php","node":{"file_name":"how-to-send-a-signal-from-a-client-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-send-a-signal-from-a-client-in-php.md","id":"php/how-to-send-a-signal-from-a-client-in-php","title":"How to send a Signal from a Client in PHP","description":"To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `#[SignalMethod]` in the Workflow interface, from the Client code.","label":"Send Signal from Client","tags":["php","developer-guide"],"markdown_content":"To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `#[SignalMethod]` in the Workflow interface, from the Client code.\n\nTo send signal to workflow use `WorkflowClient`->`newWorkflowStub` or `WorkflowClient`->`newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient`->`newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with workflow id to send\nsignals to already running workflows.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n\nSee [Handle Signals](#handle-signal) for details on how to handle Signals in a Workflow.","is_empty":false}},{"lang":"python","id":"none"},{"lang":"typescript","id":"typescript/how-to-send-a-signal-from-a-client-in-typescript","node":{"file_name":"how-to-send-a-signal-from-a-client-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-send-a-signal-from-a-client-in-typescript.md","id":"typescript/how-to-send-a-signal-from-a-client-in-typescript","title":"How to send a Signal from a Client in TypeScript","description":"Send a Signal from Client","label":"Send a Signal from Client","tags":["developer-guide","sdk","typescript"],"markdown_content":"[`WorkflowHandle.signal`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#signal)\n\n```typescript\nimport {WorkflowClient} from \"@temporalio/client\";\nimport {joinSignal} from \"./workflows\";\n\nconst client = new WorkflowClient();\n\nconst handle = client.getHandle(\"workflow-id-123\");\n\nawait handle.signal(joinSignal, {userId: \"user-1\", groupId: \"group-1\"});\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/send-signal-from-workflow","node":{"file_name":"send-signal-from-workflow.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/send-signal-from-workflow.md","id":"app-dev-context/send-signal-from-workflow","title":"How to send a Signal from a Workflow","description":"A Workflow can send a Signal to another Workflow, in which case it's called an External Signal","label":"Send Signal from Workflow","tags":["guide-context"],"markdown_content":"A Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.\n\nWhen an External Signal is sent:\n\n- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.\n- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-send-a-signal-from-a-workflow-in-go","node":{"file_name":"how-to-send-a-signal-from-a-workflow-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-send-a-signal-from-a-workflow-in-go.md","id":"go/how-to-send-a-signal-from-a-workflow-in-go","title":"How to send a Signal from a Workflow in Go","description":"A Signal can be sent from within a Workflow to a different Workflow Execution using the `SignalExternalWorkflow` API from the `go.temporal.io/sdk/workflow` package.","label":"Send Signal from Workflow","tags":["go","how-to"],"markdown_content":"A Signal can be sent from within a Workflow to a different Workflow Execution using the [`SignalExternalWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SignalExternalWorkflow) API from the `go.temporal.io/sdk/workflow` package.\n\n```go\n// ...\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  //...\n  signal := MySignal {\n    Message: \"Some important data\",\n  }\n  err :=  workflow.SignalExternalWorkflow(ctx, \"some-workflow-id\", \"\", \"your-signal-name\", signal).Get(ctx, nil)\n  if err != nil {\n    // ...\n  }\n// ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-send-a-signal-from-a-workflow-in-java","node":{"file_name":"how-to-send-a-signal-from-a-workflow-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-send-a-signal-from-a-workflow-in-java.md","id":"java/how-to-send-a-signal-from-a-workflow-in-java","title":"How to send a Signal from a Workflow in Java","description":"To send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow.","label":"Send Signal from Workflow","tags":["java","developer-guide"],"markdown_content":"To send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow.\n\nThe following example shows how to use an untyped `ExternalWorkflowStub` in the Workflow implementation to send a Signal to another Workflow.\n\n```java\n    public String sendGreeting(String name) {\n\n        // initiate ExternalWorkflowStub to call another Workflow by its Id \"ReplyWF\"\n        ExternalWorkflowStub callRespondWorkflow = Workflow.newUntypedExternalWorkflowStub(\"ReplyWF\");\n\n        String responseTrigger = activity.greeting(\"Hello\", name);\n\n        // send a Signal from this sendGreeting Workflow to the other Workflow\n        // by calling the Signal method name \"getGreetCall\" defined in that Workflow.\n        callRespondWorkflow.signal(\"getGreetCall\", responseTrigger);\n\n        return responseTrigger;\n```","is_empty":false}},{"lang":"php","id":"php/how-to-send-a-signal-from-a-workflow-in-php","node":{"file_name":"how-to-send-a-signal-from-a-workflow-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-send-a-signal-from-a-workflow-in-php.md","id":"php/how-to-send-a-signal-from-a-workflow-in-php","title":"How to send Signal a Workflow in PHP","label":"Signal a Workflow","markdown_content":"To send signal to a Workflow use `WorkflowClient`->`newWorkflowStub` or `WorkflowClient`->`newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient`->`newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with Workflow Id to send\nSignals to a running Workflow.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-send-a-signal-from-a-workflow-in-typescript","node":{"file_name":"how-to-send-a-signal-from-a-workflow-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-send-a-signal-from-a-workflow-in-typescript.md","id":"typescript/how-to-send-a-signal-from-a-workflow-in-typescript","title":"How to send a Signal from Workflow in TypeScript","description":"Send a Signal from Workflow","label":"Send a Signal from Workflow","tags":["developer-guide","sdk","typescript"],"markdown_content":"[`getExternalWorkflowHandle`](https://typescript.temporal.io/api/namespaces/workflow#getexternalworkflowhandle)\n\n```typescript\nimport {getExternalWorkflowHandle} from \"@temporalio/workflow\";\nimport {joinSignal} from \"./other-workflow\";\n\nexport async function yourWorkflowThatSignals() {\n  const handle = getExternalWorkflowHandle(\"workflow-id-123\");\n  await handle.signal(joinSignal, {userId: \"user-1\", groupId: \"group-1\"});\n}\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/signal-with-start","node":{"file_name":"signal-with-start.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/signal-with-start.md","id":"app-dev-context/signal-with-start","title":"How to Signal-With-Start","description":"Signal-With-Start is used from the Client","label":"Signal-With-Start","tags":["guide-context"],"markdown_content":"Signal-With-Start is used from the Client.\nIt takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.\n\nIf there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-send-a-signal-with-start-in-go","node":{"file_name":"how-to-send-a-signal-with-start-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-send-a-signal-with-start-in-go.md","id":"go/how-to-send-a-signal-with-start-in-go","title":"How to send a Signal-With-Start in Go","description":"Use the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.","label":"Signal-With-Start","tags":["go","how-to"],"markdown_content":"Use the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.\n\nBecause the Workflow Execution might not exist, this API does not take a Run ID as a parameter\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWithStartWorkflow(context.Background(), \"your-workflow-id\", \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-send-a-signal-with-start-in-java","node":{"file_name":"how-to-send-a-signal-with-start-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-send-a-signal-with-start-in-java.md","id":"java/how-to-send-a-signal-with-start-in-java","title":"How to send a Signal-with-Start in Java","description":"To send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart` with a `WorkflowStub` in the Client code.","label":"Signal with Start","tags":["java","developer-guide"],"markdown_content":"To send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart` with a `WorkflowStub` in the Client code.\nThis method ensures that if the Workflow Execution is in a closed state, a new Workflow Execution is spawned and the Signal is delivered to the running Workflow Execution.\n\nNote that when the `SignalwithStart` spawns a new Workflow Execution, the Signal is delivered before the call to your `@WorkflowMethod`.\nThis means that the Signal handler in your Workflow interface code will execute before the `@WorkfowMethod`.\nYou must ensure that your code logic can deal with this.\n\nIn the following example, the Client code uses `SignalwithStart` to send the Signal `setCustomer` to the `UntypedWorkflowStub` named `GreetingWorkflow`.\nIf the `GreetingWorkflow` Workflow Execution is not running, the `SignalwithStart` starts the Workflow Execution.\n\n```java\n...\npublic static void signalWithStart() {\n        // WorkflowStub is a client-side stub to a single Workflow instance\n        WorkflowStub untypedWorkflowStub = client.newUntypedWorkflowStub(\"GreetingWorkflow\",\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(workflowId)\n                .setTaskQueue(taskQueue)\n                .build());\n\n        untypedWorkflowStub.signalWithStart(\"setCustomer\", new Object[] {customer2}, new Object[] {customer1});\n\n        printWorkflowStatus();\n\n        try {\n            String greeting = untypedWorkflowStub.getResult(String.class);\n            printWorkflowStatus();\n            System.out.println(\"Greeting: \" + greeting);\n        } catch(WorkflowFailedException e) {\n            System.out.println(\"Workflow failed: \" + e.getCause().getMessage());\n            printWorkflowStatus();\n        }\n    }\n...\n```\n\nThe following example shows the Workflow interface for the `GreetingWorkflow` called in the previous example.\n\n```java\n...\n@WorkflowInterface\npublic interface GreetingWorkflow {\n    @WorkflowMethod\n    String greet(Customer customer);\n\n    @SignalMethod\n    void setCustomer(Customer customer);\n\n    @QueryMethod\n    Customer getCustomer();\n...\n}\n```\n\nNote that the Signal handler `setCustomer` is executed before the `@WorkflowMethod` `greet` is called.","is_empty":false}},{"lang":"php","id":"php/how-to-send-a-signal-with-start-in-php","node":{"file_name":"how-to-send-a-signal-with-start-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-send-a-signal-with-start-in-php.md","id":"php/how-to-send-a-signal-with-start-in-php","title":"How to send Signal-With-Start in PHP","label":"Signal-With-Start","markdown_content":"In cases where you may not know if a Workflow is running, and want to send a Signal to it, use `startwithSignal`.\nIf a running Workflow exists, the `startwithSignal` API sends the Signal.\nIf there is no running Workflow, the API starts a new Workflow Run and delivers the Signal to it.\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->startWithSignal(\n    $workflow,\n    'setValue',\n    [true], // signal arguments\n    [] // start arguments\n);\n```","is_empty":false}},{"lang":"python","id":"python/how-to-send-a-signal-with-start-in-python","node":{"file_name":"how-to-send-a-signal-with-start-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-send-a-signal-with-start-in-python.md","id":"python/how-to-send-a-signal-with-start-in-python","title":"How to send a Signal-With-Start in Python","description":"Signal-With-Start","label":"Signal-With-Start","tags":["developer-guide","sdk","python"],"markdown_content":"To send a Signal-With-Start in Python, use the [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) method and pass the `start_signal` argument with the name of your Signal, instead of using a traditional Workflow start.\n\n```python\nasync def main():\n    client = await Client.connect(\"localhost:7233\", namespace=\"your-namespace\")\n\n    handle = await client.start_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n        start_signal=\"your-signal-name\",\n    )\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-send-a-signal-with-start-in-typescript","node":{"file_name":"how-to-send-a-signal-with-start-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-send-a-signal-with-start-in-typescript.md","id":"typescript/how-to-send-a-signal-with-start-in-typescript","title":"How to send a Signal with Start in TypeScript","description":"Send a Signal with Start","label":"Send a Signal with Start","tags":["developer-guide","sdk","typescript"],"markdown_content":"[`WorkflowClient.signalWithStart`](https://typescript.temporal.io/api/classes/client.WorkflowClient#signalwithstart)\n\n```typescript\nimport {WorkflowClient} from \"@temporalio/client\";\nimport {yourWorkflow, joinSignal} from \"./workflows\";\n\nconst client = new WorkflowClient();\n\nawait client.signalWithStart(yourWorkflow, {\n  workflowId: \"workflow-id-123\",\n  args: [{foo: 1}],\n  signal: joinSignal,\n  signalArgs: [{userId: \"user-1\", groupId: \"group-1\"}],\n});\n```","is_empty":false}}]},{"type":"h2","id":"app-dev-context/queries","node":{"file_name":"queries.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/queries.md","id":"app-dev-context/queries","title":"How to develop with Queries","description":"A Query is a synchronous operation that is used to get the state of a Workflow Execution.","label":"Queries","tags":["guide-context"],"markdown_content":"A [Query](/workflows#query) is a synchronous operation that is used to get the state of a Workflow Execution.","is_empty":false}},{"type":"h3","id":"app-dev-context/define-query","node":{"file_name":"define-query.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/define-query.md","id":"app-dev-context/define-query","title":"How to define a Query","description":"A Query has a name and can have arguments.","label":"Define Query","tags":["guide-context"],"markdown_content":"A Query has a name and can have arguments.\n\n- The name, also called a Query type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter/).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-define-a-query-type-in-go","node":{"file_name":"how-to-define-a-query-type-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-define-a-query-type-in-go.md","id":"go/how-to-define-a-query-type-in-go","title":"How to define a Query Type in Go","description":"A Query type, also called a Query name, is a `string` value.","label":"Query type","tags":["go","how-to"],"markdown_content":"In Go, a Query type, also called a Query name, is a `string` value.\n\n```go\nqueryType := \"your_query_name\"\n```","is_empty":false}},{"lang":"java","id":"java/how-to-define-a-query-in-java","node":{"file_name":"how-to-define-a-query-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-define-a-query-in-java.md","id":"java/how-to-define-a-query-in-java","title":"How to define a Query in Java","description":"Create a Query handler using the `@QueryMethod` annotation in the Workflow interface.","label":"Define Query","tags":["java","developer-guide"],"markdown_content":"To define a Query, define the method name and the result type of the Query.\n\n```java\nquery(String queryType, Class<R> resultClass, Type resultType, Object... args);\n\n  /* @param queryType name of the Query handler. Usually it is a method name.\n   * @param resultClass class of the Query result type\n   * @param args optional Query arguments\n   * @param <R> type of the Query result\n  */\n```\n\nQuery methods can take in any number of input parameters which can be used to limit the data that is returned.\n\nUse the Query method names to send and receive Queries.\n\nQuery methods must never change any Workflow state including starting Activities or blocking threads in any way.","is_empty":false}},{"lang":"php","id":"php/how-to-define-a-query-in-php","node":{"file_name":"how-to-define-a-query-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-define-a-query-in-php.md","id":"php/how-to-define-a-query-in-php","title":"How to define a Query in PHP","label":"Define a Query","markdown_content":"Workflows can answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow type defaults to `\"FileProcessingWorkflow\"`.","is_empty":false}},{"lang":"python","id":"python/how-to-define-a-query-in-python","node":{"file_name":"how-to-define-a-query-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-define-a-query-in-python.md","id":"python/how-to-define-a-query-in-python","title":"How to define a Query in Python","description":"Define a Query","label":"Define a Query","tags":["developer-guide","sdk","python"],"markdown_content":"To define a Query, set the Query decorator [`@workflow.query`](https://python.temporal.io/temporalio.workflow.html#query) on the Query function inside your Workflow.\n\n```python\n@workflow.query\nasync def current_greeting(self) -> str:\n    return self._current_greeting\n```\n\nThe [`@workflow.query`](https://python.temporal.io/temporalio.workflow.html#query) decorator defines a method as a Query. Queries can be asynchronous or synchronous methods and can be inherited; however, if a method is overridden, the override must also be decorated. Queries should return a value.\n\n**Dynamic Queries**\n\nYou can use `@workflow.query(dynamic=True)`, which means all other unhandled Query's fall through to this.\n\nFor example:\n\n```python\n@workflow.query(dynamic=True)\ndef query_dynamic(self, name: str, *args: Any) -> str:\n    return f\"query_dynamic {name}: {args[0]}\"\n```\n\n**Customize names**\n\nYou can have a name parameter to customize the Query's name, otherwise it defaults to the unqualified method `__name__`.\n\nThe following example sets a custom Query name.\n\n```python\n@workflow.query(name=\"Custom-Name\")\ndef query(self, arg: str) -> None:\n    self._last_event = f\"query: {arg}\"\n```\n\n:::note\n\nYou can either set the `name` or the `dynamic` parameter in a Query's decorator, but not both.\n\n:::","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h3","id":"app-dev-context/handle-query","node":{"file_name":"handle-query.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/handle-query.md","id":"app-dev-context/handle-query","title":"How to handle a Query","description":"Queries are handled by your Workflow.","label":"Handle Query","tags":["guide-context"],"markdown_content":"Queries are handled by your Workflow.\n\nDont include any logic that causes [Command](/workflows#command) generation within a Query handler (such as executing Activities).\nIncluding such logic causes unexpected behavior.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-handle-a-query-in-a-workflow-in-go","node":{"file_name":"how-to-handle-a-query-in-a-workflow-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-handle-a-query-in-a-workflow-in-go.md","id":"go/how-to-handle-a-query-in-a-workflow-in-go","title":"How to handle a Query in a Workflow in Go","description":"Use the `SetQueryHandler` API to set a Query Handler that listens for a Query by name.","label":"Handling Queries","tags":["go","how-to"],"markdown_content":"Use the `SetQueryHandler` API from the `go.temporal.io/sdk/workflow` package to set a Query Handler that listens for a Query by name.\n\nThe handler must be a function that returns two values:\n\n1. A serializable result\n2. An error\n\nThe handler function can receive any number of input parameters, but all input parameters must be serializable.\nThe following sample code sets up a Query Handler that handles the `current_state` Query type:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n  currentState := \"started\" // This could be any serializable struct.\n  queryType := \"current_state\"\n  err := workflow.SetQueryHandler(ctx, queryType, func() (string, error) {\n    return currentState, nil\n  })\n  if err != nil {\n    currentState = \"failed to register query handler\"\n    return err\n  }\n  // Your normal Workflow code begins here, and you update the currentState as the code makes progress.\n  currentState = \"waiting timer\"\n  err = NewTimer(ctx, time.Hour).Get(ctx, nil)\n  if err != nil {\n    currentState = \"timer failed\"\n    return err\n  }\n  currentState = \"waiting activity\"\n  ctx = WithActivityOptions(ctx, yourActivityOptions)\n  err = ExecuteActivity(ctx, YourActivity, \"your_input\").Get(ctx, nil)\n  if err != nil {\n    currentState = \"activity failed\"\n    return err\n  }\n  currentState = \"done\"\n  return nil\n}\n```\n\nFor example, suppose your query handler function takes two parameters:\n\n```go\nerr := workflow.SetQueryHandler(ctx, \"current_state\", func(prefix string, suffix string) (string, error) {\n    return prefix + currentState + suffix, nil\n})\n```","is_empty":false}},{"lang":"java","id":"java/how-to-handle-a-query-in-a-workflow-in-java","node":{"file_name":"how-to-handle-a-query-in-a-workflow-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-handle-a-query-in-a-workflow-in-java.md","id":"java/how-to-handle-a-query-in-a-workflow-in-java","title":"How to handle a Query in a Workflow in Java","description":"To handle a Query in a Workflow, define a Query handler method using the `@QueryMethod` annotation in the Workflow interface.","label":"Handle Query","tags":["java","developer-guide"],"markdown_content":"To handle a Query in the Workflow, create a Query handler using the `@QueryMethod` annotation in the Workflow interface and define it in the Workflow implementation.\n\nThe `@QueryMethod` annotation indicates that the method is used to handle a Query that is sent to the Workflow Execution.\nThe method can have parameters that can be used to filter data that the Query returns.\nBecause the method returns a value, it must have a return type that is not `void`.\n\nThe Query name defaults to the name of the method.\nIn the following example, the Query name defaults to `getStatus`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod\n   String getStatus();\n}\n```\n\nTo overwrite this default naming and assign a custom Query name, use the `@QueryMethod` annotation with the `name` parameter. In the following example, the Query name is set to \"history\".\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod(name = \"history\")\n   String getStatus();\n}\n```\n\nA Workflow Definition interface can define multiple methods annotated with `@QueryMethod`, but the method names or the `name` parameters for each must be unique.\n\nThe following Workflow interface has a Query method `getCount()` to handle Queries to this Workflow.\n\n```java\n  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @QueryMethod\n    int getCount();\n  }\n```\n\nThe following example is the Workflow implementation with the Query method defined in the `HelloWorld` Workflow interface from the previous example.\n\n```java\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = \"Hello\";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!\"Bye\".equals(greeting)) {\n        logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n```\n\n**Dynamic Query Handler**\nYou can also implement Query handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicQueryListener` in the Workflow implementation code.\n\n```java\n      Workflow.registerListener(\n        (DynamicQueryHandler)\n            (queryName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Queries sent to the Workflow without a defined handler will be delivered to the `DynamicQueryHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicQueryHandler` can be implemented in both regular and dynamic Workflow implementations.","is_empty":false}},{"lang":"php","id":"php/how-to-handle-a-query-in-a-workflow-in-php","node":{"file_name":"how-to-handle-a-query-in-a-workflow-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-handle-a-query-in-a-workflow-in-php.md","id":"php/how-to-handle-a-query-in-a-workflow-in-php","title":"How to handle a Query in PHP","label":"Handle a Query","markdown_content":"You can add custom Query types to handle Queries such as Querying the current state of a\nWorkflow, or Querying how many Activities the Workflow has completed. To do this, you need to set\nup a Query handler using method attribute `QueryMethod` or `Workflow::registerQueryHandler`.\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\QueryMethod]\n    public function getValue()\n    {\n        return 42;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // workflow code\n    }\n\n}\n```\n\nThe handler function can receive any number of input parameters, but all input parameters must be\nserializable. The following sample code sets up a Query handler that handles the Query type of\n`currentState`:\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private string $currentState;\n\n    #[Workflow\\QueryMethod('current_state')]\n    public function getCurrentState(): string\n    {\n        return $this->currentState;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // Your normal Workflow code begins here, and you update the currentState\n        // as the code makes progress.\n        $this->currentState = 'waiting timer';\n        try{\n            yield Workflow::timer(DateInterval::createFromDateString('1 hour'));\n        } catch (\\Throwable $e) {\n            $this->currentState = 'timer failed';\n            throw $e;\n        }\n\n        $yourActivity = Workflow::newActivityStub(\n            YourActivityInterface::class,\n            ActivityOptions::new()->withScheduleToStartTimeout(60)\n        );\n\n        $this->currentState = 'waiting activity';\n        try{\n            yield $yourActivity->doSomething('some input');\n        } catch (\\Throwable $e) {\n            $this->currentState = 'activity failed';\n            throw $e;\n        }\n\n        $this->currentState = 'done';\n\n        return null;\n    }\n}\n```\n\nYou can also issue a Query from code using the `QueryWorkflow()` API on a Temporal Client object.\n\nUse `WorkflowStub` to Query Workflow instances from your Client code (can be applied to both running and closed Workflows):\n\n```php\n$workflow = $workflowClient->newWorkflowStub(\n    YourWorkflow::class,\n    WorkflowOptions::new()\n);\n\n$workflowClient->start($workflow);\n\nvar_dump($workflow->getCurrentState());\nsleep(60);\nvar_dump($workflow->getCurrentState());\n```","is_empty":false}},{"lang":"python","id":"python/how-to-handle-a-query-in-a-workflow-in-python","node":{"file_name":"how-to-handle-a-query-in-a-workflow-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-handle-a-query-in-a-workflow-in-python.md","id":"python/how-to-handle-a-query-in-a-workflow-in-python","title":"How to handle a Query in a Workflow","description":"Handle a Query in a Workflow","label":"Handle a Query in a Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"To send a Query from to the Workflow, use the [`query`](https://python.temporal.io/temporalio.client.workflowhandle#query) method from the [`WorkflowHandle`](https://python.temporal.io/temporalio.client.workflowhandle) class.\n\n```python\nawait handle.query(\"some query\")\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-handle-a-query-in-a-workflow-in-typescript","node":{"file_name":"how-to-handle-a-query-in-a-workflow-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-handle-a-query-in-a-workflow-in-typescript.md","id":"typescript/how-to-handle-a-query-in-a-workflow-in-typescript","title":"How to handle a Query in a Workflow in TypeScript","description":"To handle a Query in a Workflow, define a Query handler method using the `handle.query(query, ...args)` annotation in the Workflow interface.","label":"Handle Query","tags":["typescript","developer-guide"],"markdown_content":"Query Handlers can return values inside a Workflow in TypeScript.\n\nYou make a Query with `handle.query(query, ...args)`. A Query needs a return value, but can also take arguments.\n\n```typescript\nimport * as wf from \"@temporalio/workflow\";\n\nexport const unblockSignal = wf.defineSignal(\"unblock\");\nexport const isBlockedQuery = wf.defineQuery<boolean>(\"isBlocked\");\n\nexport async function unblockOrCancel(): Promise<void> {\n  let isBlocked = true;\n  wf.setHandler(unblockSignal, () => void (isBlocked = false));\n  wf.setHandler(isBlockedQuery, () => isBlocked);\n  console.log(\"Blocked\");\n  try {\n    await wf.condition(() => !isBlocked);\n    console.log(\"Unblocked\");\n  } catch (err) {\n    if (err instanceof wf.CancelledFailure) {\n      console.log(\"Cancelled\");\n    }\n    throw err;\n  }\n}\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/send-query","node":{"file_name":"send-query.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/send-query.md","id":"app-dev-context/send-query","title":"How to send a Query","description":"Queries are sent from a Temporal Client.","label":"Send Query","tags":["guide-context"],"markdown_content":"Queries are sent from a Temporal Client.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-send-a-query-to-a-workflow-execution-in-go","node":{"file_name":"how-to-send-a-query-to-a-workflow-execution-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-send-a-query-to-a-workflow-execution-in-go.md","id":"go/how-to-send-a-query-to-a-workflow-execution-in-go","title":"How to send a Query to a Workflow Execution in Go","description":"Use the `QueryWorkflow()` API to send a Query to a Workflow in Go.","label":"Sending Queries","tags":["go","how-to"],"markdown_content":"Use the `QueryWorkflow()` API or the `QueryWorkflowWithOptions` API on the Temporal Client to send a Query to a Workflow Execution.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType)\nif err != nil {\n  // ...\n}\n// ...\n```\n\nYou can pass an arbitrary number of arguments to the `QueryWorkflow()` function.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType, \"foo\", \"baz\")\nif err != nil {\n  // ...\n}\n// ...\n```\n\nThe `QueryWorkflowWithOptions()` API provides similar functionality, but with the ability to set additional configurations through [QueryWorkflowWithOptionsRequest](https://pkg.go.dev/go.temporal.io/sdk/client#QueryWorkflowWithOptionsRequest).\nWhen using this API, you will also receive a structured response of type [QueryWorkflowWithOptionsResponse](https://pkg.go.dev/go.temporal.io/sdk/client#QueryWorkflowWithOptionsResponse).\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflowWithOptions(context.Background(), &client.QueryWorkflowWithOptionsRequest{\n    WorkflowID: workflowID,\n    RunID: runID,\n    QueryType: queryType,\n    Args: args,\n})\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-send-a-query-to-a-workflow-in-java","node":{"file_name":"how-to-send-a-query-to-a-workflow-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-send-a-query-to-a-workflow-in-java.md","id":"java/how-to-send-a-query-to-a-workflow-in-java","title":"How to send a Query in Java","description":"To send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.","label":"Send Query","tags":["java","developer-guide"],"markdown_content":"To send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.\n\nFor example, the following Client code calls a Query method `queryGreeting()` defined in the `GreetingWorkflow` Workflow interface.\n\n```java\n // Create our workflow options\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder()\n        .setWorkflowId(WORKFLOW_ID)\n        .setTaskQueue(TASK_QUEUE).build();\n\n    // Create the Temporal client stub. It is used to start our workflow execution.\n    GreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);\n\n    // Start our workflow asynchronously to not use another thread to query.\n    WorkflowClient.start(workflow::createGreeting, \"World\");\n\n    // Query the Workflow to get the current value of greeting and print it.\n    System.out.println(workflow.queryGreeting());\n```","is_empty":false}},{"lang":"php","id":"none"},{"lang":"typescript","id":"none"}]},{"type":"h2","id":"app-dev-context/workflow-timeouts-and-retries","node":{"file_name":"workflow-timeouts-and-retries.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/workflow-timeouts-and-retries.md","id":"app-dev-context/workflow-timeouts-and-retries","title":"Workflow timeouts and retries","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts & retries","tags":["guide-context"],"markdown_content":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.","is_empty":false}},{"type":"h3","id":"app-dev-context/workflow-execution-timeout","node":{"file_name":"workflow-execution-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/workflow-execution-timeout.md","id":"app-dev-context/workflow-execution-timeout","title":"How to set a Workflow Execution Timeout","description":"Use the Workflow Execution Timeout to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["guide-context"],"markdown_content":"Use the [Workflow Execution Timeout](/workflows#workflow-execution-timeout) to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-workflow-execution-timeout-in-go","node":{"file_name":"how-to-set-a-workflow-execution-timeout-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-workflow-execution-timeout-in-go.md","id":"go/how-to-set-a-workflow-execution-timeout-in-go","title":"How to set a Workflow Execution Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Execution Timeout","tags":["go","how-to"],"markdown_content":"Create an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  WorkflowExecutionTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-workflow-execution-timeout-in-java","node":{"file_name":"how-to-set-a-workflow-execution-timeout-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-workflow-execution-timeout-in-java.md","id":"java/how-to-set-a-workflow-execution-timeout-in-java","title":"How to set a Workflow Execution Timeout in Java","description":"Set the Workflow Execution Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowExecutionTimeout`.","label":"Workflow Execution Timeout","tags":["java","how-to","developer-guide"],"markdown_content":"Set the [Workflow Execution Timeout](/workflows#workflow-execution-timeout) with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowExecutionTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Execution Timeout duration\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                .build());\n```","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-workflow-execution-timeout-in-php","node":{"file_name":"how-to-set-a-workflow-execution-timeout-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-workflow-execution-timeout-in-php.md","id":"php/how-to-set-a-workflow-execution-timeout-in-php","title":"How to set Workflow Execution Timeout in PHP","label":"Workflow Execution Timeout","markdown_content":"The following code example creates a new Workflow and sets the Workflow ID. Then it sets the Workflow ID resuse policy and the Workflow Execution Timeout to 2 minutes.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    DynamicSleepWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(DynamicSleepWorkflow::WORKFLOW_ID)\n        ->withWorkflowIdReusePolicy(WorkflowIdReusePolicy::WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(2))\n);\n```","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h3","id":"app-dev-context/workflow-run-timeout","node":{"file_name":"workflow-run-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/workflow-run-timeout.md","id":"app-dev-context/workflow-run-timeout","title":"How to set a Workflow Run Timeout","description":"Use the Workflow Run Timeout to restrict the maximum amount of time that a single Workflow Run can last.","label":"Workflow Run Timeout","tags":["guide-context"],"markdown_content":"Use the [Workflow Run Timeout](/workflows#workflow-run-timeout) to restrict the maximum amount of time that a single [Workflow Run](/concepts/what-is-a-workflow-execution/#workflow-execution-chain) can last.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-workflow-run-timeout-in-go","node":{"file_name":"how-to-set-a-workflow-run-timeout-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-workflow-run-timeout-in-go.md","id":"go/how-to-set-a-workflow-run-timeout-in-go","title":"How to set a Workflow Run Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Run Timeout","tags":["go","how-to"],"markdown_content":"Create an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Same as [`WorkflowExecutionTimeout`](#workflowexecutiontimeout)\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowRunTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-workflow-run-timeout-in-java","node":{"file_name":"how-to-set-a-workflow-run-timeout-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-workflow-run-timeout-in-java.md","id":"java/how-to-set-a-workflow-run-timeout-in-java","title":"How to set a Workflow Run Timeout in Java","description":"Set the Workflow Run Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowRunTimeout`.","label":"Workflow Run Timeout","tags":["java","how-to","developer-guide"],"markdown_content":"Set the Workflow Run Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowRunTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Same as [WorkflowExecutionTimeout](#workflow-execution-timeout).\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Run Timeout duration\n                .setWorkflowRunTimeout(Duration.ofSeconds(10))\n                .build());\n```","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-workflow-run-timeout-in-php","node":{"file_name":"how-to-set-a-workflow-run-timeout-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-workflow-run-timeout-in-php.md","id":"php/how-to-set-a-workflow-run-timeout-in-php","title":"How to set Workflow Run Timeout in PHP","label":"Workflow Run Timeout","markdown_content":"`WorkflowRunTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n);\n```","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h3","id":"app-dev-context/workflow-task-timeout","node":{"file_name":"workflow-task-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/workflow-task-timeout.md","id":"app-dev-context/workflow-task-timeout","title":"How to set a Workflow Task Timeout","description":"Use the Workflow Task Timeout to restrict the maximum amount of time that a Worker can execute a Workflow Task.","label":"Workflow Task Timeout","tags":["guide-context"],"markdown_content":"Use the [Workflow Task Timeout](/workflows#workflow-task-timeout) to restrict the maximum amount of time that a Worker can execute a [Workflow Task](/tasks#workflow-task).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-workflow-task-timeout-in-go","node":{"file_name":"how-to-set-a-workflow-task-timeout-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-workflow-task-timeout-in-go.md","id":"go/how-to-set-a-workflow-task-timeout-in-go","title":"How to set a Workflow Task Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Task Timeout","tags":["go","how-to"],"markdown_content":"Create an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: `time.Seconds * 10`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowTaskTimeout: time.Second * 10,\n  //...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-workflow-task-timeout-in-java","node":{"file_name":"how-to-set-a-workflow-task-timeout-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-workflow-task-timeout-in-java.md","id":"java/how-to-set-a-workflow-task-timeout-in-java","title":"How to set a Workflow Task Timeout in Java","description":"Set the Workflow Task Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowTaskTimeout`.","label":"Workflow Task Timeout","tags":["java","how-to","developer-guide"],"markdown_content":"Set the Workflow Task Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowTaskTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: 10 seconds.\n- Values: Maximum accepted value is 60 seconds.\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Task Timeout duration\n                .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                .build());\n```","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-workflow-task-timeout-in-php","node":{"file_name":"how-to-set-a-workflow-task-timeout-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-workflow-task-timeout-in-php.md","id":"php/how-to-set-a-workflow-task-timeout-in-php","title":"How to set Workflow Task Timeout in PHP","label":"Workflow Task Timeout","markdown_content":"`WorkflowTaskTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowTaskTimeout(CarbonInterval::minute(1))\n);\n```","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h3","id":"app-dev-context/workflow-retry-policy","node":{"file_name":"workflow-retry-policy.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/workflow-retry-policy.md","id":"app-dev-context/workflow-retry-policy","title":"How to set a Workflow Retry Policy","description":"Use a Retry Policy to retry a Workflow Execution in the event of a failure.","label":"Workflow Retry Policy","tags":["guide-context"],"markdown_content":"Use a [Retry Policy](/retry-policies#) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-workflow-retry-policy-in-go","node":{"file_name":"how-to-set-a-workflow-retry-policy-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-workflow-retry-policy-in-go.md","id":"go/how-to-set-a-workflow-retry-policy-in-go","title":"How to set a Workflow Retry Policy in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `RetryPolicy` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Retry Policy","tags":["go","how-to"],"markdown_content":"Create an instance of a [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy) from the `go.temporal.io/sdk/temporal` package and provide it as the value to the `RetryPolicy` field of the instance of `StartWorkflowOptions`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default: None\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\nworkflowOptions := client.StartWorkflowOptions{\n  RetryPolicy: retrypolicy,\n  // ...\n}\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-workflow-retry-options-in-java","node":{"file_name":"how-to-set-workflow-retry-options-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-workflow-retry-options-in-java.md","id":"java/how-to-set-workflow-retry-options-in-java","title":"How to set Workflow Retry Options in Java","description":"Set Workflow Retry Options in the `WorkflowStub` instance using `WorkflowOptions.Builder.setWorkflowRetryOptions`.","label":"Workflow Retry Options","tags":["java","how-to","developer-guide"],"markdown_content":"Set Workflow Retry Options in the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance using [`WorkflowOptions.Builder.setWorkflowRetryOptions`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: `Null` which means no retries will be attempted.\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Retry Options\n                .setRetryOptions(RetryOptions.newBuilder()\n                .build());\n```","is_empty":false}},{"lang":"php","id":"php/how-to-set-workflow-retry-options-in-php","node":{"file_name":"how-to-set-workflow-retry-options-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-workflow-retry-options-in-php.md","id":"php/how-to-set-workflow-retry-options-in-php","title":"How to set Workflow Retry Options in PHP","description":"A Retry Policy can be configured with an instance of the `RetryOptions` object.","label":"Workflow Retry Options","tags":["php","how-to","developer-guide"],"markdown_content":"A Retry Policy can be configured with an instance of the `RetryOptions` object.\nTo enable retries for a Workflow, you need to provide a Retry Policy object via `ChildWorkflowOptions`\nfor child Workflows or via `WorkflowOptions` for top-level Workflows.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()->withRetryOptions(\n        RetryOptions::new()->withInitialInterval(120)\n      )\n);\n```\n\nFor more detailed information about `RetryOptions` object see [retries](/php/retries) for more details.","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h2","id":"app-dev-context/activity-timeouts-and-retries","node":{"file_name":"activity-timeouts-and-retries.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/activity-timeouts-and-retries.md","id":"app-dev-context/activity-timeouts-and-retries","title":"How to set Activity timeouts and retries","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts and retries","tags":["guide-context"],"markdown_content":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.","is_empty":false}},{"type":"h3","id":"app-dev-context/schedule-to-close","node":{"file_name":"schedule-to-close.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/schedule-to-close.md","id":"app-dev-context/schedule-to-close","title":"How to set a Schedule-To-Close Timeout","description":"Use the Schedule-To-Close Timeout to limit the maximum duration of an Activity Execution.","label":"Schedule-To-Close Timeout","tags":["guide-context"],"markdown_content":"Use the [Schedule-To-Close Timeout](/activities#schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/activities#activity-execution).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-schedule-to-close-timeout-in-go","node":{"file_name":"how-to-set-a-schedule-to-close-timeout-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-schedule-to-close-timeout-in-go.md","id":"go/how-to-set-a-schedule-to-close-timeout-in-go","title":"How to set a Schedule-To-Close Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Schedule-To-Close Timeout","tags":["go","how-to"],"markdown_content":"To set a [Schedule-To-Close Timeout](/activities#schedule-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `time.Duration`\n- Default:  (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-schedule-to-close-timeout-in-java","node":{"file_name":"how-to-set-a-schedule-to-close-timeout-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-schedule-to-close-timeout-in-java.md","id":"java/how-to-set-a-schedule-to-close-timeout-in-java","title":"How to set a Schedule-To-Close Timeout in Java","description":"To set a Schedule-To-Close Timeout, use `ActivityOptions.newBuilder.setScheduleToCloseTimeout`].","label":"Schedule-To-Close Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"To set a [Schedule-To-Close Timeout](/activities#schedule-to-close-timeout), use [`ActivityOptions.newBuilder.setScheduleToCloseTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `Duration`\n- Default: Unlimited.\n  Note that if `WorkflowRunTimeout` and/or `WorkflowExecutionTimeout` are defined in the Workflow, all Activity retries will stop when either or both of these timeouts are reached.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                      \"GetCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                          .build()))\n                      .build();\n  ```","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-schedule-to-close-timeout-in-php","node":{"file_name":"how-to-set-a-schedule-to-close-timeout-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-schedule-to-close-timeout-in-php.md","id":"php/how-to-set-a-schedule-to-close-timeout-in-php","title":"How to set Schedule-to-Close Timeout in PHP","label":"Schedule-to-Start Timeout","markdown_content":"Because Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(2))\n);\n```","is_empty":false}},{"lang":"python","id":"python/how-to-set-a-schedule-to-close-timeout-in-python","node":{"file_name":"how-to-set-a-schedule-to-close-timeout-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-set-a-schedule-to-close-timeout-in-python.md","id":"python/how-to-set-a-schedule-to-close-timeout-in-python","title":"How to set a schedule to close timeout in Python","description":"Set a schedule to close timeout","label":"Set a schedule to close timeout","tags":["developer-guide","sdk","python"],"markdown_content":"Activity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code example sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_close_timeout` to 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-set-a-schedule-to-close-timeout-in-typescript","node":{"file_name":"how-to-set-a-schedule-to-close-timeout-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-set-a-schedule-to-close-timeout-in-typescript.md","id":"typescript/how-to-set-a-schedule-to-close-timeout-in-typescript","title":"How to set a Schedule to Close Timeout in TypeScript","description":"Set a Schedule to Close Timeout","label":"Set a Schedule to Close Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"When you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault:  (infinity  no limit)\n\nIn this example, you can set the `scheduleToCloseTimeout` to 5 m.\n\n```typescript\n// Sample of typical options you can set\nconst {greet} = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: \"5m\",\n  retry: {\n    // default retry policy if not specified\n    initialInterval: \"1s\",\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/start-to-close","node":{"file_name":"start-to-close.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/start-to-close.md","id":"app-dev-context/start-to-close","title":"How to set a Start-To-Close Timeout","description":"Use the Start-To-Close Timeout to limit the maximum duration of a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["guide-context"],"markdown_content":"Use the [Start-To-Close Timeout](/activities#start-to-close-timeout) to limit the maximum duration of a single [Activity Task Execution](/tasks#activity-task-execution).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-start-to-close-timeout-in-go","node":{"file_name":"how-to-set-a-start-to-close-timeout-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-start-to-close-timeout-in-go.md","id":"go/how-to-set-a-start-to-close-timeout-in-go","title":"How to set a Start-To-Close Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Start-To-Close Timeout","tags":["go","how-to"],"markdown_content":"To set a [Start-To-Close Timeout](/activities#start-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `time.Duration`\n- Default: Same as the `ScheduleToCloseTimeout`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  StartToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-start-to-close-timeout-in-java","node":{"file_name":"how-to-set-a-start-to-close-timeout-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-start-to-close-timeout-in-java.md","id":"java/how-to-set-a-start-to-close-timeout-in-java","title":"How to set a Start-To-Close Timeout in Java","description":"To set a Start-To-Close Timeout, use `ActivityOptions.newBuilder.setStartToCloseTimeout`].","label":"Start-To-Close Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"To set a [Start-To-Close Timeout](/activities#start-to-close-timeout), use [`ActivityOptions.newBuilder.setStartToCloseTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `Duration`\n- Default: Defaults to [`ScheduleToCloseTimeout`](#scheduletoclosetimeout) value\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n              ActivityOptions.newBuilder()\n                      .setStartToCloseTimeout(Duration.ofSeconds(2))\n                      .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // Set Activity Execution timeout (single run)\n                                            .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-start-to-close-timeout-in-php","node":{"file_name":"how-to-set-a-start-to-close-timeout-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-start-to-close-timeout-in-php.md","id":"php/how-to-set-a-start-to-close-timeout-in-php","title":"How to set Start-to-Close Timeout in PHP","label":"Start-to-Close Timeout","markdown_content":"Because Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `StartToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(CarbonInterval::seconds(2))\n);\n```","is_empty":false}},{"lang":"python","id":"python/how-to-set-a-start-to-close-timeout-in-python","node":{"file_name":"how-to-set-a-start-to-close-timeout-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-set-a-start-to-close-timeout-in-python.md","id":"python/how-to-set-a-start-to-close-timeout-in-python","title":"How to set a start to close timeout in Python","description":"Set a start to close timeout","label":"Set a start to close timeout","tags":["developer-guide","sdk","python"],"markdown_content":"Activity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\n```python\nstart_to_close_timeout = timedelta(seconds=5)\n```\n\nThe following code example executes an Activity with a `start_to_close_timeout` of 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=5)\n        )\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-set-a-start-to-close-timeout-in-typescript","node":{"file_name":"how-to-set-a-start-to-close-timeout-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-set-a-start-to-close-timeout-in-typescript.md","id":"typescript/how-to-set-a-start-to-close-timeout-in-typescript","title":"How to set a Start to Close Timeout in TypeScript","description":"Set a Start to Close Timeout","label":"Set a Start to Close Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"When you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault:  (infinity  no limit)\n\nIn this example, you can set the `startToCloseTimeout` to 30 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst {greet} = proxyActivities<typeof activities>({\n  startToCloseTimeout: \"30s\", // recommended\n  retry: {\n    // default retry policy if not specified\n    initialInterval: \"1s\",\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/schedule-to-start","node":{"file_name":"schedule-to-start.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/schedule-to-start.md","id":"app-dev-context/schedule-to-start","title":"How to set a Schedule-To-Start Timeout","description":"Use the Schedule-To-Start Timeout to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","label":"Schedule-To-Start Timeout","tags":["guide-context"],"markdown_content":"Use the [Schedule-To-Start Timeout](/activities#schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-schedule-to-start-timeout-in-go","node":{"file_name":"how-to-set-a-schedule-to-start-timeout-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-schedule-to-start-timeout-in-go.md","id":"go/how-to-set-a-schedule-to-start-timeout-in-go","title":"How to set a Schedule-To-Start Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Schedule-To-Close Timeout","tags":["go","how-to"],"markdown_content":"To set a [Schedule-To-Start Timeout](/activities#schedule-to-start-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: `time.Duration`\n- Default:  (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-schedule-to-start-timeout-in-java","node":{"file_name":"how-to-set-a-schedule-to-start-timeout-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-schedule-to-start-timeout-in-java.md","id":"java/how-to-set-a-schedule-to-start-timeout-in-java","title":"How to set a Schedule-To-Start Timeout in Java","description":"To set a Schedule-To-Start Timeout, use `ActivityOptions.newBuilder.setScheduleToStartTimeout`].","label":"Schedule-To-Start Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"To set a [Schedule-To-Start Timeout](/activities#schedule-to-start-timeout), use [`ActivityOptions.newBuilder.setScheduleToStartTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: Unlimited. This timeout is non-retryable.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                          // required when setting Activity options.\n                          .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n             WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"GetCustomerGreeting\",\n                                ActivityOptions.newBuilder()\n                                    .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                    .build()))\n                      .build();\n  ```","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-schedule-to-start-timeout-in-php","node":{"file_name":"how-to-set-a-schedule-to-start-timeout-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-schedule-to-start-timeout-in-php.md","id":"php/how-to-set-a-schedule-to-start-timeout-in-php","title":"How to set Schedule-to-Start Timeout in PHP","label":"Schedule-to-Start Timeout","markdown_content":"Because Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToStartTimeout` set to 10 seconds.\n\n```php\n// Creating a stub for the activity.\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()\n                ->withScheduleToStartTimeout(CarbonInterval::seconds(10))\n        );\n```","is_empty":false}},{"lang":"python","id":"python/how-to-set-a-schedule-to-start-timeout-in-python","node":{"file_name":"how-to-set-a-schedule-to-start-timeout-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-set-a-schedule-to-start-timeout-in-python.md","id":"python/how-to-set-a-schedule-to-start-timeout-in-python","title":"How to set a schedule to start timeout in Python","description":"Set a schedule to start timeout","label":"Set a schedule to start timeout","tags":["developer-guide","sdk","python"],"markdown_content":"Activity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_start_timeout` to 1 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            name,\n            schedule_to_close_timeout=5000,\n            schedule_to_start_timeout=1000,\n        )\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-set-a-schedule-to-start-timeout-in-typescript","node":{"file_name":"how-to-set-a-schedule-to-start-timeout-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-set-a-schedule-to-start-timeout-in-typescript.md","id":"typescript/how-to-set-a-schedule-to-start-timeout-in-typescript","title":"How to set a Schedule to Start Timeout in TypeScript","description":"Set a Schedule to Start Timeout","label":"Set a Schedule to Start Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"When you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault:  (infinity  no limit)\n\nIn this example, you can set the `scheduleToStartTimeout` to 60 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst {greet} = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: \"5m\",\n  scheduleToStartTimeout: \"60s\",\n  retry: {\n    // default retry policy if not specified\n    initialInterval: \"1s\",\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/activity-retry-policy","node":{"file_name":"activity-retry-policy.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/activity-retry-policy.md","id":"app-dev-context/activity-retry-policy","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity Retry Policy","tags":["guide-context"],"markdown_content":"Activity Executions are automatically associated with a default [Retry Policy](/retry-policies#) if a custom one is not provided.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-an-activity-retry-policy-in-go","node":{"file_name":"how-to-set-an-activity-retry-policy-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-an-activity-retry-policy-in-go.md","id":"go/how-to-set-an-activity-retry-policy-in-go","title":"How to set an Activity Retry Policy in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Retry Policy","tags":["go","how-to"],"markdown_content":"To set a [RetryPolicy](/retry-policies#), Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default:\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100, // 100 * InitialInterval\n  MaximumAttempts: 0, // Unlimited\n  NonRetryableErrorTypes: []string, // empty\n}\n```\n\nProviding a Retry Policy here is a customization, and overwrites individual Field defaults.\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\n\nactivityoptions := workflow.ActivityOptions{\n  RetryPolicy: retrypolicy,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-activity-retry-options-in-java","node":{"file_name":"how-to-set-activity-retry-options-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-activity-retry-options-in-java.md","id":"java/how-to-set-activity-retry-options-in-java","title":"How to set Activity Retry Options in Java","description":"To set a Heartbeat Timeout, use `ActivityOptions.newBuilder.setHeartbeatTimeout`].","label":"Activity Retry Options","tags":["Java","how-to","developer-guide"],"markdown_content":"To set [Retry Options](/retry-policies#), use [`ActivityOptions.newBuilder.setRetryOptions()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: Server-defined Activity Retry policy.\n\n- With `ActivityStub`\n\n  ```java\n  private final ActivityOptions options =\n      ActivityOptions.newBuilder()\n          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n          // required when setting Activity options.\n          .setStartToCloseTimeout(Duration.ofSeconds(5))\n          .setRetryOptions(\n              RetryOptions.newBuilder()\n                  .setInitialInterval(Duration.ofSeconds(1))\n                  .setMaximumInterval(Duration.ofSeconds(10))\n                  .build())\n          .build();\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                // required when setting Activity options.\n                                .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                .setRetryOptions(\n                                      RetryOptions.newBuilder()\n                                          .setDoNotRetry(NullPointerException.class.getName())\n                                          .build())\n                                .build()))\n                .build();\n  ```","is_empty":false}},{"lang":"php","id":"php/how-to-set-activity-retry-options-in-php","node":{"file_name":"how-to-set-activity-retry-options-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-activity-retry-options-in-php.md","id":"php/how-to-set-activity-retry-options-in-php","title":"How to set Activity Retry Options in PHP","label":"Activity Retry Options","markdown_content":"To enable Activity Retry, set `{@link RetryOptions}` on `{@link ActivityOptions}`.\nThe follow example creates a new Activity with the given options.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(10))\n        ->withRetryOptions(\n            RetryOptions::new()\n                ->withInitialInterval(CarbonInterval::seconds(1))\n                ->withMaximumAttempts(5)\n                ->withNonRetryableExceptions([\\InvalidArgumentException::class])\n        )\n);\n}\n```\n\nFor an executable code sample, see [ActivityRetry sample](https://github.com/temporalio/samples-php/tree/master/app/src/ActivityRetry) in the PHP samples repository.","is_empty":false}},{"lang":"python","id":"python/how-to-set-an-activity-retry-policy-in-python","node":{"file_name":"how-to-set-an-activity-retry-policy-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-set-an-activity-retry-policy-in-python.md","id":"python/how-to-set-an-activity-retry-policy-in-python","title":"How to set an Activity Retry Policy in Python","description":"Create an instance of an Activity Retry Policy in Python.","label":"Retry Policy","tags":["python","how-to"],"markdown_content":"To create an Activity Retry Policy in Python, set the [RetryPolicy](https://python.temporal.io/temporalio.common.retrypolicy) class within the [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) or [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) function.\n\nThe following example sets the maximum interval to 2 seconds.\n\n```python\nworkflow.execute_activity(\n    your_activity,\n    name,\n    start_to_close_timeout=timedelta(seconds=10),\n    retry_policy=RetryPolicy(maximum_interval=timedelta(seconds=2)),\n)\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-set-an-activity-retry-policy-in-typescript","node":{"file_name":"how-to-set-an-activity-retry-policy-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-set-an-activity-retry-policy-in-typescript.md","id":"typescript/how-to-set-an-activity-retry-policy-in-typescript","title":"How to set an Activity Retry Policy in TypeScript","description":"Set an Activity Retry Policy","label":"Set an Activity Retry Policy","markdown_content":"To set Activity Retry Policies in TypeScript, pass [`ActivityOptions.retry`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#retry) to [`proxyActivities`](https://typescript.temporal.io/api/namespaces/workflow/#proxyactivities).\n\n```typescript\n// Sample of typical options you can set\nconst {yourActivity} = proxyActivities<typeof activities>({\n  // ...\n  retry: {\n    // default retry policy if not specified\n    initialInterval: \"1s\",\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/activity-retry-simulator","node":{"file_name":"activity-retry-simulator.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/activity-retry-simulator.md","id":"app-dev-context/activity-retry-simulator","title":"How to visualize an Activity Retry Policy with timeouts","description":"Use this tool to visualize total Activity Execution times and experiment with various Activity timeouts and Retry Policies.","label":"Activity retry simulator","tags":["guide-context"],"markdown_content":"Use this tool to visualize total Activity Execution times and experiment with different Activity timeouts and Retry Policies.\n\nThe simulator is based on a common Activity use-case, which is to call a third party HTTP API and return the results.\nSee the example code snippets below.\n\nUse the Activity Retries settings to configure how long the API request takes to succeed or fail.\nThere is an option to generate scenarios.\nThe _Task Time in Queue_ simulates the time the Activity Task might be waiting in the Task Queue.\n\nUse the Activity Timeouts and Retry Policy settings to see how they impact the success or failure of an Activity Execution.\n\nimport RetrySimulator from '/docs/components/RetrySimulator/RetrySimulator';\n\n<RetrySimulator />","is_empty":false}},{"type":"h2","id":"app-dev-context/activity-heartbeats","node":{"file_name":"activity-heartbeats.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/activity-heartbeats.md","id":"app-dev-context/activity-heartbeats","title":"How to Heartbeat an Activity","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.","label":"Activity Heartbeats","tags":["guide-context"],"markdown_content":"An [Activity Heartbeat](/activities#activity-heartbeat) is a ping from the [Worker Process](/workers#worker-process) that is executing the Activity to the [Temporal Cluster](/clusters#).\nEach Heartbeat informs the Temporal Cluster that the [Activity Execution](/activities#activity-execution) is making progress and the Worker has not crashed.\nIf the Cluster does not receive a Heartbeat within a [Heartbeat Timeout](/activities#heartbeat-timeout) time period, the Activity will be considered failed and another [Activity Task Execution](/tasks#activity-task-execution) may be scheduled according to the Retry Policy.\n\nHeartbeats may not always be sent to the Clusterthey may be [throttled](/concepts/what-is-an-activity-heartbeat#throttling) by the Worker.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\nHeartbeats can contain a `details` field describing the Activity's current progress.\nIf an Activity gets retried, the Activity can access the `details` from the last Heartbeat that was sent to the Cluster.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-heartbeat-an-activity-in-go","node":{"file_name":"how-to-heartbeat-an-activity-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-heartbeat-an-activity-in-go.md","id":"go/how-to-heartbeat-an-activity-in-go","title":"How to Heartbeat an Activity in Go","description":"Use, the `RecordHeartbeat` API to report that the execution is alive and progressing.","label":"Activity Heartbeats","tags":["go","developer-guide"],"markdown_content":"To [Heartbeat](/activities#activity-heartbeat) in an Activity in Go, use the `RecordHeartbeat` API.\n\n```go\nimport (\n    // ...\n    \"go.temporal.io/sdk/workflow\"\n    // ...\n)\n\nfunc YourActivityDefinition(ctx, YourActivityDefinitionParam) (YourActivityDefinitionResult, error) {\n    // ...\n    activity.RecordHeartbeat(ctx, details)\n    // ...\n}\n```\n\nWhen an Activity Task Execution times out due to a missed Heartbeat, the last value of the `details` variable above is returned to the calling Workflow in the `details` field of `TimeoutError` with `TimeoutType` set to `Heartbeat`.\n\nYou can also Heartbeat an Activity from an external source:\n\n```go\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n// Record heartbeat.\nerr := temporalClient.RecordActivityHeartbeat(ctx, taskToken, details)\n```\n\nThe parameters of the `RecordActivityHeartbeat` function are:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `details`: The serializable payload containing progress information.\n\nIf an Activity Execution Heartbeats its progress before it failed, the retry attempt will have access to the progress information, so that the Activity Execution can resume from the failed state.\nHere's an example of how this can be implemented:\n\n```go\nfunc SampleActivity(ctx context.Context, inputArg InputParams) error {\n    startIdx := inputArg.StartIndex\n    if activity.HasHeartbeatDetails(ctx) {\n        // Recover from finished progress.\n        var finishedIndex int\n        if err := activity.GetHeartbeatDetails(ctx, &finishedIndex); err == nil {\n            startIdx = finishedIndex + 1 // Start from next one.\n        }\n    }\n\n    // Normal Activity logic...\n    for i:=startIdx; i<inputArg.EndIdx; i++ {\n        // Code for processing item i goes here...\n        activity.RecordHeartbeat(ctx, i) // Report progress.\n    }\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-heartbeat-an-activity-in-java","node":{"file_name":"how-to-heartbeat-an-activity-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-heartbeat-an-activity-in-java.md","id":"java/how-to-heartbeat-an-activity-in-java","title":"How to Heartbeat an Activity in Java","description":"To inform the Temporal service that the Activity is still alive, use `Activity.getExecutionContext().heartbeat()` in the Activity implementation code.","label":"Activity Heartbeat","tags":["java","developer-guide"],"markdown_content":"To Heartbeat an Activity Execution in Java, use the `Activity.getExecutionContext().heartbeat()` Class method.\n\n```java\npublic class YourActivityDefinitionImpl implements YourActivityDefinition {\n\n  @Override\n  public String yourActivityMethod(YourActivityMethodParam param) {\n    // ...\n    Activity.getExecutionContext().heartbeat(details);\n    // ...\n  }\n  // ...\n}\n```\n\nThe method takes an optional argument, the `details` variable above that represents latest progress of the Activity Execution.\nThis method can take a variety of types such as an exception object, custom object, or string.\n\nIf the Activity Execution times out, the last Heartbeat `details` are included in the thrown `ActivityTimeoutException`, which can be caught by the calling Workflow.\nThe Workflow can then use the `details` information to pass to the next Activity invocation if needed.\n\nIn the case of Activity retries, the last Heartbeat's `details` are available and can be extracted from the last failed attempt by using `Activity.getExecutionContext().getHeartbeatDetails(Class<V> detailsClass)`","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-heartbeat-for-an-activity-in-php","node":{"file_name":"how-to-set-a-heartbeat-for-an-activity-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-heartbeat-for-an-activity-in-php.md","id":"php/how-to-set-a-heartbeat-for-an-activity-in-php","title":"How to set a Heartbeat for an Activity in PHP","label":"Heartbeat an Activity","markdown_content":"Some Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```","is_empty":false}},{"lang":"python","id":"python/how-to-heartbeat-an-activity-in-python","node":{"file_name":"how-to-heartbeat-an-activity-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-heartbeat-an-activity-in-python.md","id":"python/how-to-heartbeat-an-activity-in-python","title":"How to heartbeat an Activity in Python","description":"Heartbeat an Activity","label":"Heartbeat an Activity","tags":["developer-guide","sdk","python"],"markdown_content":"To Heartbeat an Activity Execution in Python, use the [`heartbeat()`](https://python.temporal.io/temporalio.activity.html#heartbeat) API.\n\n```python\n@activity.defn\nasync def your_activity_definition() -> str:\n    activity.heartbeat(\"heartbeat details!\")\n```\n\nIn addition to obtaining cancellation information, Heartbeats also support detail data that persists on the server for retrieval during Activity retry.\nIf an Activity calls `heartbeat(123, 456)` and then fails and is retried, `heartbeat_details` returns an iterable containing `123` and `456` on the next Run.","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-heartbeat-an-activity-in-typescript","node":{"file_name":"how-to-heartbeat-an-activity-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-heartbeat-an-activity-in-typescript.md","id":"typescript/how-to-heartbeat-an-activity-in-typescript","title":"How to Heartbeat an Activity in TypeScript","description":"Heartbeat Activities to track their progress and get details of the Activity Execution.","label":"Activity Heartbeat","tags":["developer-guide","sdk","typescript"],"markdown_content":"Long-running Activities should Heartbeat their progress back to the Workflow for earlier detection of stalled Activities (with [Heartbeat Timeout](/activities#heartbeat-timeout)) and resuming stalled Activities from checkpoints (with Heartbeat details).\n\nTo set Activity Heartbeat, use `Context.current().heartbeat()` in your Activity implementation, and set `heartbeatTimeout` in your Workflow.\n\n```ts\n// activity implementation\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  for (let progress = 1; progress <= 1000; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    // record activity heartbeat\n    Context.current().heartbeat();\n  }\n}\n\n//...\n\n// workflow code calling activity\nconst {example} = proxyActivities<typeof activities>({\n  startToCloseTimeout: \"1 hour\",\n  heartbeatTimeout: \"10s\",\n});\n```\n\nIn the previous example, setting the Heartbeat informs the Temporal Server of the Activity's progress at regular intervals.\nIf the Activity stalls or the Activity Worker becomes unavailable, the absence of Heartbeats prompts the Temporal Server to retry the Activity immediately, without waiting for `startToCloseTimeout` to complete.\n\nYou can also add `heartbeatDetails` as a checkpoint to collect data about failures during the execution, and use it to resume the Activity from that point.\n\nThe following example extends the previous sample to include a `heartbeatDetails` checkpoint.\n\n```ts\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  const startingPoint = Context.current().info.heartbeatDetails || 1; // allow for resuming from heartbeat\n  for (let progress = startingPoint; progress <= 100; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    Context.current().heartbeat(progress);\n  }\n}\n```\n\nIn this example, when the `heartbeatTimeout` is reached and the Activity is retried, the Activity Worker picks up the execution from where the previous attempt left off.","is_empty":false}}]},{"type":"h4","id":"app-dev-context/heartbeat-timeout","node":{"file_name":"heartbeat-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/heartbeat-timeout.md","id":"app-dev-context/heartbeat-timeout","title":"How to set a Heartbeat Timeout","description":"A Heartbeat Timeout works in conjunction with Activity Heartbeats.","label":"Heartbeat Timeout","tags":["guide-context"],"markdown_content":"A [Heartbeat Timeout](/activities#heartbeat-timeout) works in conjunction with [Activity Heartbeats](/activities#activity-heartbeat).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-heartbeat-timeout-in-go","node":{"file_name":"how-to-set-a-heartbeat-timeout-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-heartbeat-timeout-in-go.md","id":"go/how-to-set-a-heartbeat-timeout-in-go","title":"How to set a Heartbeat Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `HeartbeatTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Retry Policy","tags":["go","how-to"],"markdown_content":"To set a [Heartbeat Timeout](/activities#heartbeat-timeout), Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  HeartbeatTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-heartbeat-timeout-in-java","node":{"file_name":"how-to-set-a-heartbeat-timeout-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-heartbeat-timeout-in-java.md","id":"java/how-to-set-a-heartbeat-timeout-in-java","title":"How to set a Heartbeat Timeout in Java","description":"To set a Heartbeat Timeout, use `ActivityOptions.newBuilder.setHeartbeatTimeout`].","label":"Heartbeat Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"To set a [Heartbeat Timeout](/activities#heartbeat-timeout), use [`ActivityOptions.newBuilder.setHeartbeatTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: None\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  private final GreetingActivities activities =\n      Workflow.newActivityStub(\n          GreetingActivities.class,\n          ActivityOptions.newBuilder()\n              // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n              // required when setting Activity options.\n              .setStartToCloseTimeout(Duration.ofSeconds(5))\n              .setHeartbeatTimeout(Duration.ofSeconds(2))\n              .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                          // required when setting Activity options.\n                                            .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                            .setHeartbeatTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-heartbeat-timeout-in-php","node":{"file_name":"how-to-set-a-heartbeat-timeout-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-heartbeat-timeout-in-php.md","id":"php/how-to-set-a-heartbeat-timeout-in-php","title":"How to set a Heartbeat Timeout in PHP","label":"Heartbeat Timeout","markdown_content":"Some Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```","is_empty":false}},{"lang":"python","id":"python/how-to-set-a-heartbeat-timeout-in-python","node":{"file_name":"how-to-set-a-heartbeat-timeout-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-set-a-heartbeat-timeout-in-python.md","id":"python/how-to-set-a-heartbeat-timeout-in-python","title":"How to set a Heartbeat Timeout in Python","description":"Set a Heartbeat Timeout","label":"Set a Heartbeat Timeout","tags":["developer-guide","sdk","python"],"markdown_content":"[`heartbeat_timeout`](https://python.temporal.io/temporalio.worker.startactivityinput#heartbeat_timeout) is a class variable for the [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) function used to set the maximum time between Activity Heartbeats.\n\n```python\nworkflow.start_activity(\n    activity=\"your-activity\",\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n```python\nworkflow.execute_activity(\n    activity=\"your-activity\",\n    name,\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-set-a-heartbeat-timeout-in-typescript","node":{"file_name":"how-to-set-a-heartbeat-timeout-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-set-a-heartbeat-timeout-in-typescript.md","id":"typescript/how-to-set-a-heartbeat-timeout-in-typescript","title":"How to set a Heartbeat Timeout in TypeScript","description":"Set a Heartbeat Timeout","label":"Set a Heartbeat Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"To set a Heartbeat Timeout, use [`ActivityOptions.heartbeatTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#heartbeattimeout). If the Activity takes longer than that between heartbeats, the Activity is failed.\n\n```typescript\n// Creating a proxy for the activity.\nconst {longRunningActivity} = proxyActivities<typeof activities>({\n  // translates to 300000 ms\n  scheduleToCloseTimeout: \"5m\",\n  // translates to 30000 ms\n  startToCloseTimeout: \"30s\",\n  // equivalent to '10 seconds'\n  heartbeatTimeout: 10000,\n});\n```","is_empty":false}}]},{"type":"h2","id":"app-dev-context/async-activity-completion","node":{"file_name":"async-activity-completion.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/async-activity-completion.md","id":"app-dev-context/async-activity-completion","title":"How to asynchronously complete an Activity","description":"Asynchronous Activity Completion enables the Activity Function to return without the Activity Execution completing.","label":"Asynchronous Activity Completion","tags":["guide-context"],"markdown_content":"[Asynchronous Activity Completion](/activities#asynchronous-activity-completion) enables the Activity Function to return without the Activity Execution completing.\n\nThere are three steps to follow:\n\n1. The Activity provides the external system with identifying information needed to complete the Activity Execution.\n   Identifying information can be a [Task Token](/activities#task-token), or a combination of Namespace, Workflow Id, and Activity Id.\n2. The Activity Function completes in a way that identifies it as waiting to be completed by an external system.\n3. The Temporal Client is used to Heartbeat and complete the Activity.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-asynchronously-complete-an-activity-in-go","node":{"file_name":"how-to-asynchronously-complete-an-activity-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-asynchronously-complete-an-activity-in-go.md","id":"go/how-to-asynchronously-complete-an-activity-in-go","title":"How to asynchronously complete an Activity in Go","description":"todo","label":"Asynchronous Activity Completion","tags":["how-to","go"],"markdown_content":"1. Provide the external system with the a Task Token to complete the Activity Execution.\n   To do this, use the `GetInfo()` API from the `go.temporal.io/sdk/activity` package.\n\n```go\n// Retrieve the Activity information needed to asynchronously complete the Activity.\nactivityInfo := activity.GetInfo(ctx)\ntaskToken := activityInfo.TaskToken\n// Send the taskToken to the external service that will complete the Activity.\n```\n\n2. Return an `activity.ErrResultPending` error to indicate that the Activity is completing asynchronously.\n\n```go\nreturn \"\", activity.ErrResultPending\n```\n\n3. Use the Temporal Client to complete the Activity using the Task Token.\n\n```go\n// Instantiate a Temporal service client.\n// The same client can be used to complete or fail any number of Activities.\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n\n// Complete the Activity.\ntemporalClient.CompleteActivity(context.Background(), taskToken, result, nil)\n```\n\nFollowing are the parameters of the `CompleteActivity` function:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `result`: The return value to record for the Activity. The type of this value must match the type\n  of the return value declared by the Activity function.\n- `err`: The error code to return if the Activity terminates with an error.\n\nIf `error` is not null, the value of the `result` field is ignored.\n\nTo fail the Activity, you would do the following:\n\n```go\n// Fail the Activity.\nclient.CompleteActivity(context.Background(), taskToken, nil, err)\n```","is_empty":false}},{"lang":"java","id":"none"},{"lang":"php","id":"php/how-to-set-asynchronous-activity-completion-in-php","node":{"file_name":"how-to-set-asynchronous-activity-completion-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-asynchronous-activity-completion-in-php.md","id":"php/how-to-set-asynchronous-activity-completion-in-php","title":"How to set asynchronous Activity completion in PHP","label":"Asynchronous Activity completion","markdown_content":"Sometimes Workflows need to perform certain operations in parallel.\n\nInvoking activity stub without the use of `yield` will return the Activity result promise which can be resolved at later moment.\nCalling `yield` on promise blocks until a result is available.\n\n> Activity promise also exposes `then` method to construct promise chains.\n> Read more about Promises [here](https://github.com/reactphp/promise).\n\nAlternatively you can explicitly wrap your code (including `yield` constucts) using `Workflow::async` which will execute nested code in parallel with main Workflow code.\nCall `yeild` on Promise returned by `Workflow::async` to merge execution result back to primary Workflow method.\n\n```php\npublic function greet(string $name): \\Generator\n{\n    // Workflow::async runs it's activities and child workflows in a separate coroutine. Use keyword yield to merge\n    // it back to parent process.\n\n    $first = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Bye', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    $second = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hola', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Chao', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    // blocks until $first and $second complete\n    return (yield $first) . \"\\n\" . (yield $second);\n}\n```\n\n**Async completion**\n\nThere are certain scenarios when moving on from an Activity upon completion of its function is not possible or desirable.\nFor example, you might have an application that requires user input to complete the Activity.\nYou could implement the Activity with a polling mechanism, but a simpler and less resource-intensive implementation is to asynchronously complete a Temporal Activity.\n\nThere are two parts to implementing an asynchronously completed Activity:\n\n1. The Activity provides the information necessary for completion from an external system and notifies the Temporal service that it is waiting for that outside callback.\n2. The external service calls the Temporal service to complete the Activity.\n\nThe following example demonstrates the first part:\n\n<!--SNIPSTART samples-php-async-activity-completion-activity-class-->\n<!--SNIPEND-->\n\nThe following code demonstrates how to complete the Activity successfully using `WorkflowClient`:\n\n<!--SNIPSTART samples-php-async-activity-completion-completebytoken-->\n<!--SNIPEND-->\n\nTo fail the Activity, you would do the following:\n\n```php\n// Fail the Activity.\n$activityClient->completeExceptionallyByToken($taskToken, new \\Error(\"activity failed\"));\n```","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h2","id":"app-dev-context/child-workflows","node":{"file_name":"child-workflows.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/child-workflows.md","id":"app-dev-context/child-workflows","title":"How to start a Child Workflow Execution","description":"A Child Workflow Execution is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.","label":"Child Workflows","tags":["guide-context"],"markdown_content":"A [Child Workflow Execution](/workflows#child-workflow) is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.\n\nWhen using a Child Workflow API, Child Workflow related Events ([StartChildWorkflowExecutionInitiated](/references/events#startchildworkflowexecutioninitiated), [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted), [ChildWorkflowExecutionCompleted](/references/events#childworkflowexecutioncompleted), etc...) are logged in the Workflow Execution Event History.\n\nAlways block progress until the [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted) Event is logged to the Event History to ensure the Child Workflow Execution has started.\nAfter that, Child Workflow Executions may be abandoned using the default _Abandon_ [Parent Close Policy](/workflows#parent-close-policy) set in the Child Workflow Options.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-spawn-a-child-workflow-execution-in-go","node":{"file_name":"how-to-spawn-a-child-workflow-execution-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-spawn-a-child-workflow-execution-in-go.md","id":"go/how-to-spawn-a-child-workflow-execution-in-go","title":"How to spawn a Child Workflow Execution in Go","description":"Use the `ExecuteChildWorkflow`, available from the `go.temporal.io/sdk/workflow` package, to spawn a Child Workflow Execution in Go.","label":"Child Workflow Execution","tags":["developer-guide","go"],"markdown_content":"To spawn a [Child Workflow Execution](/workflows#child-workflow) in Go, use the [`ExecuteChildWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ExecuteChildWorkflow) API, which is available from the `go.temporal.io/sdk/workflow` package.\n\nThe `ExecuteChildWorkflow` call requires an instance of [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context), with an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions) applied to it, the Workflow Type, and any parameters that should be passed to the Child Workflow Execution.\n\n`workflow.ChildWorkflowOptions` contain the same fields as `client.StartWorkflowOptions`.\nWorkflow Option fields automatically inherit their values from the Parent Workflow Options if they are not explicitly set.\nIf a custom `WorkflowID` is not set, one is generated when the Child Workflow Execution is spawned.\nUse the [`WithChildOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithChildOptions) API to apply Child Workflow Options to the instance of `workflow.Context`.\n\nThe `ExecuteChildWorkflow` call returns an instance of a [`ChildWorkflowFuture`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowFuture).\n\nCall the `.Get()` method on the instance of `ChildWorkflowFuture` to wait for the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{}\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  var result ChildResp\n  err := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{}).Get(ctx, &result)\n  if err != nil {\n    // ...\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\nTo asynchronously spawn a Child Workflow Execution, the Child Workflow must have an \"Abandon\" Parent Close Policy set in the Child Workflow Options.\nAdditionally, the Parent Workflow Execution must wait for the \"ChildWorkflowExecutionStarted\" event to appear in its event history before it completes.\n\nIf the Parent makes the `ExecuteChildWorkflow` call and then immediately completes, the Child Workflow Execution will not spawn.\n\nTo be sure that the Child Workflow Execution has started, first call the `GetChildWorkflowExecution` method on the instance of the `ChildWorkflowFuture`, which will return a different Future.\nThen call the `Get()` method on that Future, which is what will wait until the Child Workflow Execution has spawned.\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // Wait for the Child Workflow Execution to spawn\n  var childWE workflow.Execution\n  if err := childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE); err != nil {\n     return err\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-spawn-a-child-workflow-execution-in-java","node":{"file_name":"how-to-spawn-a-child-workflow-execution-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-spawn-a-child-workflow-execution-in-java.md","id":"java/how-to-spawn-a-child-workflow-execution-in-java","title":"How to spawn a Child Workflow Execution in Java","description":"The first call to the Child Workflow stub can be synchronous or asynchronous using `Async.function(Functions.Func)` or `Async.procedure(Functions.Proc)`, and must always be to a method annotated with `@WorkflowMethod`.","label":"Child Workflow Execution","tags":["java","developer-guide"],"markdown_content":"The first call to the Child Workflow stub must always be its Workflow method (method annotated with `@WorkflowMethod`).\nSimilar to Activities, invoking Child Workflow methods can be made synchronous or asynchronous by using `Async#function` or `Async#procedure`.\nThe synchronous call blocks until a Child Workflow method completes.\nThe asynchronous call returns a `Promise` which can be used to wait for the completion of the Child Workflow method, as in the following example:\n\n```java\nGreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\nPromise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n// ...\ngreeting.get()\n```\n\nTo execute an untyped Child Workflow asynchronously, call `executeAsync` on the `ChildWorkflowStub`, as shown in the following example.\n\n```java\n//...\nChildWorkflowStub childUntyped =\n    Workflow.newUntypedChildWorkflowStub(\n        \"GreetingChild\", // your workflow type\n        ChildWorkflowOptions.newBuilder().setWorkflowId(\"childWorkflow\").build());\n\nPromise<String> greeting =\n    childUntyped.executeAsync(String.class, String.class, \"Hello\", name);\nString result = greeting.get();\n//...\n```\n\nThe following examples show how to spawn a Child Workflow:\n\n- Spawn a Child Workflow from a Workflow:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n  @WorkflowMethod\n  String composeGreeting(String greeting, String name);\n  }\n  // Child Workflow implementation not shown\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n  @Override\n  public String getGreeting(String name) {\n      GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n      // This is a blocking call that returns only after child has completed.\n      return child.composeGreeting(\"Hello\", name );\n  }\n  }\n  ```\n\n- Spawn two Child Workflows (with the same type) in parallel:\n\n  ```java\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n\n          // Workflows are stateful, so a new stub must be created for each new child.\n          GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting1 = Async.function(child1::composeGreeting, \"Hello\", name);\n\n          // Both children will run concurrently.\n          GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting2 = Async.function(child2::composeGreeting, \"Bye\", name);\n\n          // Do something else here.\n          ...\n          return \"First: \" + greeting1.get() + \", second: \" + greeting2.get();\n      }\n  }\n  ```\n\n- Send a Signal to a Child Workflow from the parent:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n      @WorkflowMethod\n      String composeGreeting(String greeting, String name);\n\n      @SignalMethod\n      void updateName(String name);\n  }\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n          GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n          child.updateName(\"Temporal\");\n          return greeting.get();\n      }\n  }\n  ```\n\n- Sending a Query to Child Workflows from within the parent Workflow code is not supported. However, you can send a Query to Child Workflows from Activities using `WorkflowClient`.\n\nRelated reads:\n\n- [How to set a Child Workflow Options in Java](/java/how-to-set-child-workflow-options-in-java)\n\n- [How to develop a Workflow Definition in Java](/application-development/foundations#develop-workflows)\n\n- Java Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>","is_empty":false}},{"lang":"php","id":"php/how-to-spawn-a-child-workflow-execution-in-php","node":{"file_name":"how-to-spawn-a-child-workflow-execution-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-spawn-a-child-workflow-execution-in-php.md","id":"php/how-to-spawn-a-child-workflow-execution-in-php","title":"How to spawn a Child Workflow Execution in PHP","label":"Child Workflow Execution","markdown_content":"Besides Activities, a Workflow can also start other Workflows.\n\n`Workflow::executeChildWorkflow` and `Workflow::newChildWorkflowStub` enables the scheduling of other Workflows from within a Workflow's implementation.\nThe parent Workflow has the ability to monitor and impact the lifecycle of the child Workflow, similar to the way it does for an Activity that it invoked.\n\n```php\n// Use one stub per child workflow run\n$child = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    ChildWorkflowOptions::new()\n        // Do not specify WorkflowId if you want Temporal to generate a unique Id\n        // for the child execution.\n        ->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW')\n        ->withExecutionStartToCloseTimeout(DateInterval::createFromDateString('30 minutes'))\n);\n\n// This is a non blocking call that returns immediately.\n// Use yield $child->workflowMethod(name) to call synchronously.\n$promise = $child->workflowMethod('value');\n\n// Do something else here.\ntry{\n    $value = yield $promise;\n} catch(TemporalException $e) {\n    $logger->error('child workflow failed');\n    throw $e;\n}\n```\n\nLet's take a look at each component of this call.\n\nBefore calling `$child->workflowMethod()`, you must configure `ChildWorkflowOptions` for the invocation.\nThese options customize various execution timeouts, and are passed into the workflow stub defined by the `Workflow::newChildWorkflowStub`.\nOnce stub created you can invoke its Workflow method based on attribute `WorkflowMethod`.\n\nThe method call returns immediately and returns a `Promise`.\nThis allows you to execute more code without having to wait for the scheduled Workflow to complete.\n\nWhen you are ready to process the results of the Workflow, call the `yield $promise` method on the returned promise object.\n\nWhen a parent Workflow is cancelled by the user, the child Workflow can be cancelled or abandoned based on a configurable child policy.\n\nYou can also skip the stub part of child workflow initiation and use `Workflow::executeChildWorkflow` directly:\n\n```php\n// Use one stub per child workflow run\n$childResult = yield Workflow::executeChildWorkflow(\n    'ChildWorkflowName',\n    ['args'],\n    ChildWorkflowOptions::new()->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW'),\n    Type::TYPE_STRING // optional: defines the return type\n);\n```","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h4","id":"app-dev-context/parent-close-policy","node":{"file_name":"parent-close-policy.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/parent-close-policy.md","id":"app-dev-context/parent-close-policy","title":"How to set a Parent Close Policy","description":"A Parent Close Policy determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).","label":"Parent Close Policy","tags":["guide-context"],"markdown_content":"A [Parent Close Policy](/workflows#parent-close-policy) determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-parent-close-policy-in-go","node":{"file_name":"how-to-set-a-parent-close-policy-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-parent-close-policy-in-go.md","id":"go/how-to-set-a-parent-close-policy-in-go","title":"How to set a Parent Close Policy in Go","description":"Create an instance of `ChildWorkflowOptions` from the `go.temporal.io/sdk/workflow` package, set the `ParentClosePolicy` field, apply the options to the instance of `workflow.Context`, and pass the context to the `ExecuteChildWorkflow` call.","label":"Parent Close Policy","tags":["go","how-to"],"markdown_content":"In Go, a Parent Close Policy is set on the `ParentClosePolicy` field of an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions).\nThe possible values can be obtained from the [`go.temporal.io/api/enums/v1`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy) package.\n\n- `PARENT_CLOSE_POLICY_ABANDON`\n- `PARENT_CLOSE_POLICY_TERMINATE`\n- `PARENT_CLOSE_POLICY_REQUEST_CANCEL`\n\nThe Child Workflow Options are then applied to the instance of `workflow.Context` by using the `WithChildOptions` API, which is then passed to the `ExecuteChildWorkflow()` call.\n\n- Type: [`ParentClosePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy)\n- Default: `PARENT_CLOSE_POLICY_ABANDON`\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n  // ...\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    // ...\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // ...\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-parent-close-policy-in-java","node":{"file_name":"how-to-set-a-parent-close-policy-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-parent-close-policy-in-java.md","id":"java/how-to-set-a-parent-close-policy-in-java","title":"How to set Parent Close Policy in Java","description":"Set `Parent Close Policy` on an instance of `ChildWorkflowOptions` using `ChildWorkflowOptions.newBuilder().setParentClosePolicy`.","label":"Parent Close Policy","tags":["java","developer-guide","how-to"],"markdown_content":"Set [Parent Close Policy](/workflows#parent-close-policy) on an instance of `ChildWorkflowOptions` using [`ChildWorkflowOptions.newBuilder().setParentClosePolicy`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/ChildWorkflowOptions.Builder.html).\n\n- Type: `ChildWorkflowOptions.Builder`\n- Default: None.\n\n```java\n   public void parentWorkflow() {\n       ChildWorkflowOptions options =\n          ChildWorkflowOptions.newBuilder()\n              .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)\n              .build();\n       MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, options);\n       Async.procedure(child::<workflowMethod>, <args>...);\n       Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(child);\n       // Wait for child to start\n       childExecution.get()\n  }\n```\n\nIn this example, we are:\n\n1. Setting `ChildWorkflowOptions.ParentClosePolicy` to `ABANDON` when creating a Child Workflow stub.\n2. Starting Child Workflow Execution asynchronously using `Async.function` or `Async.procedure`.\n3. Calling `Workflow.getWorkflowExecution()` on the child stub.\n4. Waiting for the `Promise` returned by `getWorkflowExecution` to complete.\n   This indicates whether the Child Workflow started successfully (or failed).\n5. Completing parent Workflow Execution asynchronously.\n\nSteps 3 and 4 are needed to ensure that a Child Workflow Execution starts before the parent closes.\nIf the parent initiates a Child Workflow Execution and then completes immediately after, the Child Workflow will never execute.","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-parent-close-policy-in-php","node":{"file_name":"how-to-set-a-parent-close-policy-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-parent-close-policy-in-php.md","id":"php/how-to-set-a-parent-close-policy-in-php","title":"How to set a Parent Close Policy in PHP","description":"Create an instance of `ChildWorkflowOptions` and use `withParentClosePolicy()` method to apply the options to a new child workflow object.","label":"Parent Close Policy","tags":["php","developer-guide","how-to"],"markdown_content":"In PHP, a [Parent Close Policy](/workflows#parent-close-policy) is set via the `ChildWorkflowOptions` object and `withParentClosePolicy()` method.\nThe possible values can be obtained from the [`ParentClosePolicy`](https://github.com/temporalio/sdk-php/blob/master/src/Workflow/ParentClosePolicy.php) class.\n\n- `POLICY_TERMINATE`\n- `POLICY_ABANDON`\n- `POLICY_REQUEST_CANCEL`\n\nThen `ChildWorkflowOptions` object is used to create a new child workflow object:\n\n```php\n$child = Workflow::newUntypedChildWorkflowStub(\n    'child-workflow',\n    ChildWorkflowOptions::new()\n        ->withParentClosePolicy(ParentClosePolicy::POLICY_ABANDON)\n);\n\nyield $child->start();\n```\n\nIn the snippet above we:\n\n1. Create a new untyped child workflow stub with `Workflow::newUntypedChildWorkflowStub`.\n2. Provide `ChildWorkflowOptions` object with Parent Close Policy set to `ParentClosePolicy::POLICY_ABANDON`.\n3. Start Child Workflow Execution asynchronously using `yield` and method `start()`.\n\nWe need `yield` here to ensure that a Child Workflow Execution starts before the parent closes.","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h2","id":"app-dev-context/continue-as-new","node":{"file_name":"continue-as-new.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/continue-as-new.md","id":"app-dev-context/continue-as-new","title":"How to Continue-As-New","description":"Continue-As-New enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.","label":"Continue-As-New","tags":["guide-context"],"markdown_content":"[Continue-As-New](/workflows#continue-as-new) enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.\nThe Workflow Execution spawned from the use of Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-continue-as-new-in-go","node":{"file_name":"how-to-continue-as-new-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-continue-as-new-in-go.md","id":"go/how-to-continue-as-new-in-go","title":"How to Continue-As-New-in-Go","description":"To cause a Workflow Execution to Continue-As-New, the Workflow function should return the result of the `NewContinueAsNewError()` API available from the `go.temporal.io/sdk/workflow` package.","label":"Continue-As-New","tags":["go","developer-guide"],"markdown_content":"To cause a Workflow Execution to [Continue-As-New](/workflows#continue-as-new), the Workflow function should return the result of the [`NewContinueAsNewError()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#NewContinueAsNewError) API available from the `go.temporal.io/sdk/workflow` package.\n\n```go\nfunc SimpleWorkflow(ctx workflow.Context, value string) error {\n    ...\n    return workflow.NewContinueAsNewError(ctx, SimpleWorkflow, value)\n}\n```\n\nTo check whether a Workflow Execution was spawned as a result of Continue-As-New, you can check if `workflow.GetInfo(ctx).ContinuedExecutionRunID` is not nil.\n\n**Notes**\n\n- To prevent Signal loss, be sure to perform an asynchronous drain on the Signal channel.\n  Failure to do so can result in buffered Signals being ignored and lost.\n- Make sure that the previous Workflow and the Continue-As-New Workflow are referenced by the same alias.\n  Failure to do so can cause the Workflow to Continue-As-New on an entirely different Workflow.","is_empty":false}},{"lang":"java","id":"java/how-to-continue-as-new-in-java","node":{"file_name":"how-to-continue-as-new-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-continue-as-new-in-java.md","id":"java/how-to-continue-as-new-in-java","title":"How to Continue-As-New in Java","description":"To cause a Workflow to Continue-As-New, use `Workflow.continueAsNew()`.","label":"Continue-As-New","tags":["java","developer-guide"],"markdown_content":"Temporal SDK allows you to use [Continue-As-New](/workflows#continue-as-new) in various ways.\n\nTo continue execution of the same Workflow that is currently running, use:\n\n```java\nWorkflow.continueAsNew(input1, ...);\n```\n\nTo continue execution of a currently running Workflow as a completely different Workflow type, use `Workflow.newContinueAsNewStub()`.\nFor example, in a Workflow class called `YourWorkflow`, we can create a Workflow stub with a different type, and call its Workflow method to continue execution as that type:\n\n```java\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class);\nconinueAsNew.greet(input);\n```\n\nTo provide `ContinueAsNewOptions` options in `Workflow.newContinueAsNewStub()` use:\n\n```java\nContinueAsNewOptions options = ContinueAsNewOptions.newBuilder()\n        .setTaskQueue(\"newTaskQueueName\")\n        .build();\n\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class, options);\n// ...\ncontinueAsNew.greet(input);\n```\n\nProviding these options allows you to continue Workflow Execution as a new Workflow run, with a different Workflow Type, and on a different Task Queue.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>","is_empty":false}},{"lang":"php","id":"php/how-to-continue-as-new-in-php","node":{"file_name":"how-to-continue-as-new-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-continue-as-new-in-php.md","id":"php/how-to-continue-as-new-in-php","title":"How to Continue-As-New in PHP","label":"Continue-As-New","markdown_content":"Workflows that need to rerun periodically could naively be implemented as a big **while** loop with a sleep where the entire logic of the Workflow is inside the body of the **while** loop.\nThe problem with this approach is that the history for that Workflow will keep growing to a point where it reaches the maximum size enforced by the service.\n\n**ContinueAsNew** is the low level construct that enables implementing such Workflows without the risk of failures down the road.\nThe operation atomically completes the current execution and starts a new execution of the Workflow with the same **Workflow Id**.\nThe new execution will not carry over any history from the old execution.\n\nTo trigger this behavior, use `Workflow::continueAsNew` or `Workflow::newContinueAsNewStub` method:\n\n```php\n#[Workflow\\WorkflowMethod]\npublic function periodic(string $name, int $value = 0)\n{\n    for ($i = 0; $i < 100; $i++) {\n        // do something\n        $value++;\n    }\n\n    // maintain $value counter between runs\n    return Workflow::newContinueAsNewStub(self::class)->periodic($name, $value);\n}\n```","is_empty":false}},{"lang":"python","id":"python/how-to-continue-as-new-in-python","node":{"file_name":"how-to-continue-as-new-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-continue-as-new-in-python.md","id":"python/how-to-continue-as-new-in-python","title":"How to Continue-As-New in Python","description":"Continue-As-New","label":"Continue-As-New","tags":["developer-guide","sdk","python"],"markdown_content":"To Continue-As-New in Python, call the [`continue_as_new()`](https://python.temporal.io/temporalio.workflow.html#continue_as_new) function from inside your Workflow, which will stop the Workflow immediately and Continue-As-New.\n\n```python\nworkflow.continue_as_new(\"your-workflow-name\")\n```","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h2","id":"app-dev-context/cron-jobs","node":{"file_name":"cron-jobs.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/cron-jobs.md","id":"app-dev-context/cron-jobs","title":"How to use Temporal Cron Jobs","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Jobs","tags":["guide-context"],"markdown_content":"A [Temporal Cron Job](/workflows#temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-cron-schedule-in-go","node":{"file_name":"how-to-set-a-cron-schedule-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-cron-schedule-in-go.md","id":"go/how-to-set-a-cron-schedule-in-go","title":"How to set a Cron Schedule in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `CronSchedule` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Cron Schedule","tags":["go","how-to"],"markdown_content":"Create an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `CronSchedule` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-cron-schedule-in-java","node":{"file_name":"how-to-set-a-cron-schedule-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-cron-schedule-in-java.md","id":"java/how-to-set-a-cron-schedule-in-java","title":"How to set a Cron Schedule in Java","description":"Set the Cron Schedule with the `WorkflowStub` instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`","label":"Cron Schedule","tags":["java","how-to","developer-guide"],"markdown_content":"Set the Cron Schedule with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\nSetting `setCronSchedule` changes the Workflow Execution into a Temporal Cron Job.\nThe default timezone for a Cron is UTC.\n\n- Type: `String`\n- Default: None\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    YourWorker.yourclient.newWorkflowStub(\n        YourWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(YourWorker.TASK_QUEUE)\n                // Set Cron Schedule\n                .setCronSchedule(\"* * * * *\")\n                .build());\n```\n\nFor more details, see the [Cron Sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/hello/HelloCron.java)","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-cron-schedule-in-php","node":{"file_name":"how-to-set-a-cron-schedule-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-cron-schedule-in-php.md","id":"php/how-to-set-a-cron-schedule-in-php","title":"How to set a CRON schedule in PHP","label":"Activity Execution","markdown_content":"Set your Cron Schedule with `CronSchedule('* * * * *')`.\n\nThe following example sets a Cron Schedule in PHP:\n\n```php\n  $workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()\n          ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n          ->withCronSchedule('* * * * *')\n          // Execution timeout limits total time. Cron will stop executing after this timeout.\n          ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n          // Run timeout limits duration of a single workflow invocation.\n          ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n  );\n\n  $output->writeln(\"Starting <comment>CronWorkflow</comment>... \");\n\n  try {\n      $run = $this->workflowClient->start($workflow, 'Antony');\n      // ...\n  }\n```\n\nSetting `withCronSchedule` turns the Workflow Execution into a Temporal Cron Job.\nFor more information, see the [PHP samples](https://github.com/temporalio/samples-php/tree/master/app/src/Cron) for example code or the PHP SDK `WorkflowOptions` [source code](https://github.com/temporalio/sdk-php/blob/master/src/Client/WorkflowOptions.php).","is_empty":false}},{"lang":"python","id":"python/how-to-set-a-cron-schedule-in-python","node":{"file_name":"how-to-set-a-cron-schedule-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-set-a-cron-schedule-in-python.md","id":"python/how-to-set-a-cron-schedule-in-python","title":"How to set a Cron Schedule in Python","description":"Set a Cron Scheduler in Python","label":"Cron Schedule","tags":["python","how-to"],"markdown_content":"You can set each Workflow to repeat on a schedule with the `cron_schedule` option from either the [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) asynchronous methods:\n\n```python\nawait client.start_workflow(\n    \"your_workflow_name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    cron_schedule=\"* * * * *\",\n)\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-set-a-cron-job-in-typescript","node":{"file_name":"how-to-set-a-cron-job-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-set-a-cron-job-in-typescript.md","id":"typescript/how-to-set-a-cron-job-in-typescript","title":"How to set a cron job in TypeScript","description":"Set a cron job","label":"Set a cron job","tags":["developer-guide","sdk","typescript"],"markdown_content":"You can set each Workflow to repeat on a schedule with the `cronSchedule` option:\n\n```typescript\nconst handle = await client.start(scheduledWorkflow, {\n  // ...\n  cronSchedule: \"* * * * *\", // start every minute\n});\n```","is_empty":false}}]},{"type":"h2","id":"app-dev-context/environment-variables","node":{"file_name":"environment-variables.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/environment-variables.md","id":"app-dev-context/environment-variables","title":"How to read and pass environment variables","description":"Environment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.","label":"Environment variables","tags":["guide-context"],"markdown_content":"Environment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.\nThey can't be used normally with Workflow code, as that would be [nondeterministic](workflows#intrinsic-non-deterministic-logic) (if the environment variables changed between Workflow replays, the code that used them would behave differently).\n\nMost of the time, you can provide environment variables in your Activity function; however, if you need them in your Workflow functions, you can use the following options:\n\n- Provide environment variables as arguments when starting the Workflow.\n- Call a Local Activity at the beginning of the Workflow that returns environment variables.\n\nIn either case, the environment variables will appear in Event History, so you may want to use an [encryption Data Converter](/concepts/what-is-a-data-converter/#encryption).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"none"},{"lang":"java","id":"none"},{"lang":"php","id":"none"},{"lang":"typescript","id":"typescript/how-to-use-environment-variables-in-typescript","node":{"file_name":"how-to-use-environment-variables-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-use-environment-variables-in-typescript.md","id":"typescript/how-to-use-environment-variables-in-typescript","title":"How to use environment variables in TypeScript","description":"Use Environment Variables","label":"Use Environment Variables","tags":["developer-guide","sdk","typescript"],"markdown_content":"**Using in Activity code**\n\n```ts\nasync function runWorker(): Promise<void> {\n  const activities = createActivities({apiKey: process.env.MAILGUN_API_KEY});\n\n  const worker = await Worker.create({\n    taskQueue: \"example\",\n    activities,\n    workflowsPath: require.resolve(\"./workflows\"),\n  });\n  await worker.run();\n}\n\nconst createActivities = (envVars: {apiKey: string}) => ({\n  async sendNotificationEmail(): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: \"post\",\n      params: {to, from, subject, html},\n      auth: {\n        username: \"api\",\n        password: envVars.apiKey,\n      },\n    });\n  },\n});\n```\n\n**Getting into Workflow**\n\nIf we needed environment variables in our Workflow, here's how we'd use a Local Activity:\n\n```ts\nconst worker = await Worker.create({\n  taskQueue: \"example\",\n  activities: createActivities(process.env),\n  workflowsPath: require.resolve(\"./workflows\"),\n});\n\ntype EnvVars = Record<string, string>;\n\nconst createActivities = (envVars: EnvVars) => ({\n  async getEnvVars(): Promise<EnvVars> {\n    return envVars;\n  },\n  async sendNotificationEmail(apiKey: string): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: \"post\",\n      params: {to, from, subject, html},\n      auth: {\n        username: \"api\",\n        password: apiKey,\n      },\n    });\n  },\n});\n```\n\n```ts\nconst {getEnvVars} = proxyLocalActivities({\n  startToCloseTimeout: \"1m\",\n});\n\nconst {sendNotificationEmail} = proxyActivities({\n  startToCloseTimeout: \"1m\",\n});\n\nasync function yourWorkflow() {\n  const envVars = await getEnvVars();\n  if (!envVars.apiKey) {\n    throw new Error(\"missing env var apiKey\");\n  }\n  await sendNotificationEmail(envVars.apiKey);\n}\n```","is_empty":false}}]}],"link_index":[{"file_dir":"application-development","guide_id":"features","local_ref":"","node_id":"app-dev-context/features"},{"file_dir":"application-development","guide_id":"features","local_ref":"signals","node_id":"app-dev-context/signals"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"app-dev-context/define-signal"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"go/how-to-define-a-signal-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"java/how-to-define-a-signal-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"php/how-to-define-a-signal-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"python/how-to-define-a-signal-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"typescript/how-to-define-a-signal-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"app-dev-context/handle-signal"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"go/how-to-handle-a-signal-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"java/how-to-handle-a-signal-in-a-workflow-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"php/how-to-handle-a-signal-in-a-workflow-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"python/how-to-handle-a-signal-in-a-workflow-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"typescript/how-to-handle-a-signal-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"app-dev-context/send-signal-from-client"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"go/how-to-send-a-signal-from-a-client-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"java/how-to-send-a-signal-from-a-client-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"php/how-to-send-a-signal-from-a-client-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"typescript/how-to-send-a-signal-from-a-client-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"app-dev-context/send-signal-from-workflow"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"go/how-to-send-a-signal-from-a-workflow-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"java/how-to-send-a-signal-from-a-workflow-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"php/how-to-send-a-signal-from-a-workflow-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"typescript/how-to-send-a-signal-from-a-workflow-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"app-dev-context/signal-with-start"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"go/how-to-send-a-signal-with-start-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"java/how-to-send-a-signal-with-start-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"php/how-to-send-a-signal-with-start-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"python/how-to-send-a-signal-with-start-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"typescript/how-to-send-a-signal-with-start-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"queries","node_id":"app-dev-context/queries"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"app-dev-context/define-query"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"go/how-to-define-a-query-type-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"java/how-to-define-a-query-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"php/how-to-define-a-query-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"python/how-to-define-a-query-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"app-dev-context/handle-query"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"go/how-to-handle-a-query-in-a-workflow-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"java/how-to-handle-a-query-in-a-workflow-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"php/how-to-handle-a-query-in-a-workflow-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"python/how-to-handle-a-query-in-a-workflow-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"typescript/how-to-handle-a-query-in-a-workflow-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-query","node_id":"app-dev-context/send-query"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-query","node_id":"go/how-to-send-a-query-to-a-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-query","node_id":"java/how-to-send-a-query-to-a-workflow-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-timeouts-&-retries","node_id":"app-dev-context/workflow-timeouts-and-retries"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-execution-timeout","node_id":"app-dev-context/workflow-execution-timeout"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-execution-timeout","node_id":"go/how-to-set-a-workflow-execution-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-execution-timeout","node_id":"java/how-to-set-a-workflow-execution-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-execution-timeout","node_id":"php/how-to-set-a-workflow-execution-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-run-timeout","node_id":"app-dev-context/workflow-run-timeout"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-run-timeout","node_id":"go/how-to-set-a-workflow-run-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-run-timeout","node_id":"java/how-to-set-a-workflow-run-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-run-timeout","node_id":"php/how-to-set-a-workflow-run-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-task-timeout","node_id":"app-dev-context/workflow-task-timeout"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-task-timeout","node_id":"go/how-to-set-a-workflow-task-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-task-timeout","node_id":"java/how-to-set-a-workflow-task-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-task-timeout","node_id":"php/how-to-set-a-workflow-task-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-retry-policy","node_id":"app-dev-context/workflow-retry-policy"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-retry-policy","node_id":"go/how-to-set-a-workflow-retry-policy-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-retry-policy","node_id":"java/how-to-set-workflow-retry-options-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-retry-policy","node_id":"php/how-to-set-workflow-retry-options-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-timeouts-and-retries","node_id":"app-dev-context/activity-timeouts-and-retries"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"app-dev-context/schedule-to-close"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"go/how-to-set-a-schedule-to-close-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"java/how-to-set-a-schedule-to-close-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"php/how-to-set-a-schedule-to-close-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"python/how-to-set-a-schedule-to-close-timeout-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"typescript/how-to-set-a-schedule-to-close-timeout-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"app-dev-context/start-to-close"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"go/how-to-set-a-start-to-close-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"java/how-to-set-a-start-to-close-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"php/how-to-set-a-start-to-close-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"python/how-to-set-a-start-to-close-timeout-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"typescript/how-to-set-a-start-to-close-timeout-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"app-dev-context/schedule-to-start"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"go/how-to-set-a-schedule-to-start-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"java/how-to-set-a-schedule-to-start-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"php/how-to-set-a-schedule-to-start-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"python/how-to-set-a-schedule-to-start-timeout-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"typescript/how-to-set-a-schedule-to-start-timeout-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"app-dev-context/activity-retry-policy"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"go/how-to-set-an-activity-retry-policy-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"java/how-to-set-activity-retry-options-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"php/how-to-set-activity-retry-options-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"python/how-to-set-an-activity-retry-policy-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"typescript/how-to-set-an-activity-retry-policy-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-simulator","node_id":"app-dev-context/activity-retry-simulator"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"app-dev-context/activity-heartbeats"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"go/how-to-heartbeat-an-activity-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"java/how-to-heartbeat-an-activity-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"php/how-to-set-a-heartbeat-for-an-activity-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"python/how-to-heartbeat-an-activity-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"typescript/how-to-heartbeat-an-activity-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"app-dev-context/heartbeat-timeout"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"go/how-to-set-a-heartbeat-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"java/how-to-set-a-heartbeat-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"php/how-to-set-a-heartbeat-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"python/how-to-set-a-heartbeat-timeout-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"typescript/how-to-set-a-heartbeat-timeout-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"asynchronous-activity-completion","node_id":"app-dev-context/async-activity-completion"},{"file_dir":"application-development","guide_id":"features","local_ref":"asynchronous-activity-completion","node_id":"go/how-to-asynchronously-complete-an-activity-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"asynchronous-activity-completion","node_id":"php/how-to-set-asynchronous-activity-completion-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"child-workflows","node_id":"app-dev-context/child-workflows"},{"file_dir":"application-development","guide_id":"features","local_ref":"child-workflows","node_id":"go/how-to-spawn-a-child-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"child-workflows","node_id":"java/how-to-spawn-a-child-workflow-execution-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"child-workflows","node_id":"php/how-to-spawn-a-child-workflow-execution-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"parent-close-policy","node_id":"app-dev-context/parent-close-policy"},{"file_dir":"application-development","guide_id":"features","local_ref":"parent-close-policy","node_id":"go/how-to-set-a-parent-close-policy-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"parent-close-policy","node_id":"java/how-to-set-a-parent-close-policy-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"parent-close-policy","node_id":"php/how-to-set-a-parent-close-policy-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"app-dev-context/continue-as-new"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"go/how-to-continue-as-new-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"java/how-to-continue-as-new-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"php/how-to-continue-as-new-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"python/how-to-continue-as-new-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"app-dev-context/cron-jobs"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"go/how-to-set-a-cron-schedule-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"java/how-to-set-a-cron-schedule-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"php/how-to-set-a-cron-schedule-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"python/how-to-set-a-cron-schedule-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"typescript/how-to-set-a-cron-job-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"environment-variables","node_id":"app-dev-context/environment-variables"},{"file_dir":"application-development","guide_id":"features","local_ref":"environment-variables","node_id":"typescript/how-to-use-environment-variables-in-typescript"}],"markdown_content":"---\nid: features\ntitle: Application development - Features\nsidebar_label: Features\ndescription: The Features section of the Temporal Application development guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nThe Features section of the Temporal Application development guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Application development guide, it could be in [older docs for SDKs](/sdks).\n\n:::\n\nIn this section you can find the following:\n\n- [How to develop Signals](#signals)\n- [How to develop Queries](#queries)\n- [How to start a Child Workflow Execution](#child-workflows)\n- [How to start a Temporal Cron Job](#cron-jobs)\n- [How to use Continue-As-New](#continue-as-new)\n- [How to set Workflow timeouts & retries](#workflow-timeouts--retries)\n- [How to set Activity timeouts & retries](#activity-timeouts--retries)\n- [How to Heartbeat an Activity](#activity-heartbeats)\n- [How to Asynchronously complete an Activity](#async-activity-completion)\n\n## Signals\n\nA [Signal](/workflows#signal) is a message sent to a running Workflow Execution.\n\nSignals are defined in your code and handled in your Workflow Definition.\nSignals can be sent to Workflow Executions from a Temporal Client or from another Workflow Execution.\n\n### Define Signal\n\nA Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter/).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nStructs should be used to define Signals and carry data, as long as the struct is [serializable via the Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#CompositeDataConverter.ToPayload).\nThe `Receive()` method on the Data Converter decodes the data into the Struct within the Workflow.\nOnly public fields are serializable.\n\n```go\nMySignal struct {\n\tMessage string // serializable\n\tmessage string // not serializable\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nThe `@SignalMethod` annotation indicates that the method is used to handle and react to external Signals.\n\n```java\n @SignalMethod\n    void mySignal(String signalName);\n```\n\nThe method can have parameters that contain the Signal payload and must be serializable by the default Jackson JSON Payload Converter.\n\n```java\nvoid mySignal(String signalName, Object... args);\n```\n\nThis method does not return a value and must have a `void` return type.\n\nThings to consider when defining Signals:\n\n- Use Workflow object constructors and initialization blocks to initialize the internal data structures if possible.\n- Signals might be received by a Workflow before the Workflow method is executed.\n  When implementing Signals in scenarios where this can occur, assume that no parts of Workflow code ran.\n  In some cases, Signal method implementation might require some initialization to be performed by the Workflow method code firstfor example, when the Signal processing depends on, and is defined by the Workflow input.\n  In this case, you can use a flag to determine whether the Workflow method is already triggered; if not, persist the Signal data into a collection for delayed processing by the Workflow method.\n\n</TabItem>\n<TabItem value=\"php\">\n\nWorkflows can answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow type defaults to `\"FileProcessingWorkflow\"`.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo define a Signal, set the Signal decorator [`@workflow.signal`](https://python.temporal.io/temporalio.workflow.html#signal) on the Signal function inside your Workflow.\n\n```python\n@workflow.signal\ndef your_signal(self, value: str) -> None:\n    self._signal = value\n```\n\nThe [`@workflow.signal`](https://python.temporal.io/temporalio.workflow.html#signal) decorator defines a method as a Signal. Signals can be asynchronous or synchronous methods and can be inherited; however, if a method is overridden, the override must also be decorated.\n\n**Dynamic Signals**\n\nYou can use `@workflow.signal(dynamic=True)`, which means all other unhandled Signals fall through to this.\n\nYour method parameters must be `self`, a string signal name, and a `*args` variable argument parameter.\n\nFor example:\n\n```python\n@workflow.signal(dynamic=True)\ndef signal_dynamic(self, name: str, *args: Any) -> None:\n    self._last_event = f\"signal_dynamic {name}: {args[0]}\"\n```\n\n**Customize name**\n\nNon-dynamic methods can only have positional arguments. Temporal suggests taking a single argument that is an\nobject or data class of fields that can be added to as needed.\n\nReturn values from Signal methods are ignored.\n\nYou can have a name parameter to customize the Signal's name, otherwise it defaults to the unqualified method `__name__`.\n\nThe following example sets a custom Signal name.\n\n```python\n@workflow.signal(name=\"Custom-Name\")\ndef signal(self, arg: str) -> None:\n    self._last_event = f\"signal: {arg}\"\n```\n\n:::note\n\nYou can either set the `name` or the `dynamic` parameter in a Signal's decorator, but not both.\n\n:::\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n[`defineSignal`](https://typescript.temporal.io/api/namespaces/workflow/#definesignal)\n\n```ts\nimport {defineSignal} from \"@temporalio/workflow\";\n\ninterface JoinInput {\n  userId: string;\n  groupId: string;\n}\n\nexport const joinSignal = defineSignal<[JoinInput]>(\"join\");\n```\n\n</TabItem>\n</Tabs>\n\n### Handle Signal\n\nWorkflows listen for Signals by the Signal's name.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nUse the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.\nGet a new [`Selector`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Selector) and pass it the Signal Channel and a callback function to handle the payload.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  // ...\n  var signal MySignal\n  signalChan := workflow.GetSignalChannel(ctx, \"your-signal-name\")\n  selector := workflow.NewSelector(ctx)\n  selector.AddReceive(signalChan, func(channel workflow.ReceiveChannel, more bool) {\n      channel.Receive(ctx, &signal)\n      // ...\n  })\n  selector.Select(ctx)\n  if len(signal.Message) > 0 && signal.Message != \"SOME_VALUE\" {\n      return errors.New(\"signal\")\n  }\n  // ...\n}\n```\n\nIn the example above, the Workflow code uses `workflow.GetSignalChannel` to open a `workflow.Channel` for the Signal type (identified by the Signal name).\nWe then use a [`workflow.Selector`](/go/selectors) and the `AddReceive()` to wait on a Signal from this channel.\nThe `more` bool in the callback function indicates that channel is not closed and more deliveries are possible.\n\nBefore completing the Workflow or using [Continue-As-New](/application-development/features#continue-as-new), make sure to do an asynchronous drain on the Signal channel.\nOtherwise, the Signals will be lost.\n\n</TabItem>\n<TabItem value=\"java\">\n\nUse the `@SignalMethod` annotation to handle Signals in the Workflow interface.\n\nThe Signal type defaults to the name of the method. In the following example, the Signal type defaults to `retryNow`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod\n   void retryNow();\n}\n```\n\nTo overwrite this default naming and assign a custom Signal type, use the `@SignalMethod` annotation with the `name` parameter.\nIn the following example, the Signal type is set to `retrysignal`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod(name = \"retrysignal\")\n   void retryNow();\n}\n```\n\nA Workflow interface can define any number of methods annotated with `@SignalMethod`, but the method names or the `name` parameters for each must be unique.\n\nIn the following example, we define a Signal method `updateGreeting` to update the greeting in the Workflow.\nWe set a `Workflow.await` in the Workflow implementation to block the current Workflow Execution until the provided unblock condition is evaluated to `true`.\nIn this case, the unblocking condition is evaluated to `true` when the Signal to update the greeting is received.\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n}\n```\n\n```java\npublic class HelloWorldImpl implements HelloWorld {\n    private final Logger workflowLogger = Workflow.getLogger(HelloWorldImpl.class);\n    private String greeting;\n\n    @Override\n    public void sayHello(String name) {\n        int count = 0;\n        while (!\"Bye\".equals(greeting)) {\n            String oldGreeting = greeting;\n            Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n        }\n        workflowLogger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n        this.greeting = greeting;\n    }\n}\n```\n\nThis Workflow completes when the Signal updates the greeting to `Bye`.\n\n**Dynamic Signal Handler**\nYou can also implement Signal handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicSignalListener` in the Workflow implementation code.\n\n```java\n      Workflow.registerListener(\n        (DynamicSignalHandler)\n            (signalName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Signals sent to the Workflow without a defined handler will be delivered to the `DynamicSignalHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicSignalHandler` can be implemented in both regular and dynamic Workflow implementations.\n\n</TabItem>\n<TabItem value=\"php\">\n\nUse the `#[SignalMethod]` annotation to handle Signals in the Workflow interface:\n\n```php\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private bool $value;\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        yield Workflow::await(fn()=> $this->value);\n        return 'OK';\n    }\n\n    #[Workflow\\SignalMethod]\n    public function setValue(bool $value)\n    {\n        $this->value = $value;\n    }\n}\n```\n\nIn the example above the workflow updates the protected value. Main workflow coroutine waits for such value to change using\n`Workflow::await()` function.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo send a Signal to the Workflow, use the [`signal`](https://python.temporal.io/temporalio.client.workflowhandle#signal) method from the [`WorkflowHandle`](https://python.temporal.io/temporalio.client.workflowhandle) class.\n\n```python\nawait handle.signal(\"some signal\")\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n[`setHandler`](https://typescript.temporal.io/api/namespaces/workflow/#sethandler)\n\n```ts\nimport {setHandler} from \"@temporalio/workflow\";\n\nexport async function yourWorkflow() {\n  const groups = new Map<string, Set<string>>();\n\n  setHandler(joinSignal, ({userId, groupId}: JoinInput) => {\n    const group = groups.get(groupId);\n    if (group) {\n      group.add(userId);\n    } else {\n      groups.set(groupId, new Set([userId]));\n    }\n  });\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Send Signal from Client\n\nWhen a Signal is sent successfully from the Temporal Client, the [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Event History of the Workflow that receives the Signal.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nUse the `SignalWorkflow()` method on an instance of the [Go SDK Temporal Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) to send a [Signal](/workflows#signal) to a [Workflow Execution](/workflows#workflow-execution).\n\nPass in both the [Workflow Id](/workflows#workflow-id) and [Run Id](/workflows#run-id) to uniquely identify the Workflow Execution.\nIf only the Workflow Id is supplied (provide an empty string as the Run Id param), the Workflow Execution that is Running receives the Signal.\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWorkflow(context.Background(), \"your-workflow-id\", runID, \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n// ...\n```\n\nPossible errors:\n\n- `serviceerror.NotFound`\n- `serviceerror.Internal`\n- `serviceerror.Unavailable`\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.\n\nIn the following Client code example, we start the Workflow `greetCustomer` and call the Signal method `addCustomer` that is handled in the Workflow.\n\n```java\n// create a typed Workflow stub for GreetingsWorkflow\nGreetingsWorkflow workflow = client.newWorkflowStub(GreetingsWorkflow.class,\n        WorkflowOptions.newBuilder()\n                // set the Task Queue\n                .setTaskQueue(taskQueue)\n                // Workflow Id is recommended but not required\n                .setWorkflowId(workflowId)\n                .build());\n\n// start the Workflow\nWorkflowClient.start(workflow::greetCustomer);\n// send a Signal to the Workflow\nCustomer customer = new Customer(\"John\", \"Spanish\", \"john@john.com\");\nworkflow.addCustomer(customer); //addCustomer is the Signal method defined in the greetCustomer Workflow.\n```\n\nSee [Handle Signals](#handle-signal) for details on how to handle Signals in a Workflow.\n\n</TabItem>\n<TabItem value=\"php\">\n\nTo send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `#[SignalMethod]` in the Workflow interface, from the Client code.\n\nTo send signal to workflow use `WorkflowClient`->`newWorkflowStub` or `WorkflowClient`->`newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient`->`newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with workflow id to send\nsignals to already running workflows.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n\nSee [Handle Signals](#handle-signal) for details on how to handle Signals in a Workflow.\n\n</TabItem>\n<TabItem value=\"python\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n[`WorkflowHandle.signal`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#signal)\n\n```typescript\nimport {WorkflowClient} from \"@temporalio/client\";\nimport {joinSignal} from \"./workflows\";\n\nconst client = new WorkflowClient();\n\nconst handle = client.getHandle(\"workflow-id-123\");\n\nawait handle.signal(joinSignal, {userId: \"user-1\", groupId: \"group-1\"});\n```\n\n</TabItem>\n</Tabs>\n\n### Send Signal from Workflow\n\nA Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.\n\nWhen an External Signal is sent:\n\n- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.\n- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nA Signal can be sent from within a Workflow to a different Workflow Execution using the [`SignalExternalWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SignalExternalWorkflow) API from the `go.temporal.io/sdk/workflow` package.\n\n```go\n// ...\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  //...\n  signal := MySignal {\n    Message: \"Some important data\",\n  }\n  err :=  workflow.SignalExternalWorkflow(ctx, \"some-workflow-id\", \"\", \"your-signal-name\", signal).Get(ctx, nil)\n  if err != nil {\n    // ...\n  }\n// ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow.\n\nThe following example shows how to use an untyped `ExternalWorkflowStub` in the Workflow implementation to send a Signal to another Workflow.\n\n```java\n    public String sendGreeting(String name) {\n\n        // initiate ExternalWorkflowStub to call another Workflow by its Id \"ReplyWF\"\n        ExternalWorkflowStub callRespondWorkflow = Workflow.newUntypedExternalWorkflowStub(\"ReplyWF\");\n\n        String responseTrigger = activity.greeting(\"Hello\", name);\n\n        // send a Signal from this sendGreeting Workflow to the other Workflow\n        // by calling the Signal method name \"getGreetCall\" defined in that Workflow.\n        callRespondWorkflow.signal(\"getGreetCall\", responseTrigger);\n\n        return responseTrigger;\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\nTo send signal to a Workflow use `WorkflowClient`->`newWorkflowStub` or `WorkflowClient`->`newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient`->`newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with Workflow Id to send\nSignals to a running Workflow.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n[`getExternalWorkflowHandle`](https://typescript.temporal.io/api/namespaces/workflow#getexternalworkflowhandle)\n\n```typescript\nimport {getExternalWorkflowHandle} from \"@temporalio/workflow\";\nimport {joinSignal} from \"./other-workflow\";\n\nexport async function yourWorkflowThatSignals() {\n  const handle = getExternalWorkflowHandle(\"workflow-id-123\");\n  await handle.signal(joinSignal, {userId: \"user-1\", groupId: \"group-1\"});\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Signal-With-Start\n\nSignal-With-Start is used from the Client.\nIt takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.\n\nIf there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nUse the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.\n\nBecause the Workflow Execution might not exist, this API does not take a Run ID as a parameter\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWithStartWorkflow(context.Background(), \"your-workflow-id\", \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart` with a `WorkflowStub` in the Client code.\nThis method ensures that if the Workflow Execution is in a closed state, a new Workflow Execution is spawned and the Signal is delivered to the running Workflow Execution.\n\nNote that when the `SignalwithStart` spawns a new Workflow Execution, the Signal is delivered before the call to your `@WorkflowMethod`.\nThis means that the Signal handler in your Workflow interface code will execute before the `@WorkfowMethod`.\nYou must ensure that your code logic can deal with this.\n\nIn the following example, the Client code uses `SignalwithStart` to send the Signal `setCustomer` to the `UntypedWorkflowStub` named `GreetingWorkflow`.\nIf the `GreetingWorkflow` Workflow Execution is not running, the `SignalwithStart` starts the Workflow Execution.\n\n```java\n...\npublic static void signalWithStart() {\n        // WorkflowStub is a client-side stub to a single Workflow instance\n        WorkflowStub untypedWorkflowStub = client.newUntypedWorkflowStub(\"GreetingWorkflow\",\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(workflowId)\n                .setTaskQueue(taskQueue)\n                .build());\n\n        untypedWorkflowStub.signalWithStart(\"setCustomer\", new Object[] {customer2}, new Object[] {customer1});\n\n        printWorkflowStatus();\n\n        try {\n            String greeting = untypedWorkflowStub.getResult(String.class);\n            printWorkflowStatus();\n            System.out.println(\"Greeting: \" + greeting);\n        } catch(WorkflowFailedException e) {\n            System.out.println(\"Workflow failed: \" + e.getCause().getMessage());\n            printWorkflowStatus();\n        }\n    }\n...\n```\n\nThe following example shows the Workflow interface for the `GreetingWorkflow` called in the previous example.\n\n```java\n...\n@WorkflowInterface\npublic interface GreetingWorkflow {\n    @WorkflowMethod\n    String greet(Customer customer);\n\n    @SignalMethod\n    void setCustomer(Customer customer);\n\n    @QueryMethod\n    Customer getCustomer();\n...\n}\n```\n\nNote that the Signal handler `setCustomer` is executed before the `@WorkflowMethod` `greet` is called.\n\n</TabItem>\n<TabItem value=\"php\">\n\nIn cases where you may not know if a Workflow is running, and want to send a Signal to it, use `startwithSignal`.\nIf a running Workflow exists, the `startwithSignal` API sends the Signal.\nIf there is no running Workflow, the API starts a new Workflow Run and delivers the Signal to it.\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->startWithSignal(\n    $workflow,\n    'setValue',\n    [true], // signal arguments\n    [] // start arguments\n);\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo send a Signal-With-Start in Python, use the [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) method and pass the `start_signal` argument with the name of your Signal, instead of using a traditional Workflow start.\n\n```python\nasync def main():\n    client = await Client.connect(\"localhost:7233\", namespace=\"your-namespace\")\n\n    handle = await client.start_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n        start_signal=\"your-signal-name\",\n    )\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n[`WorkflowClient.signalWithStart`](https://typescript.temporal.io/api/classes/client.WorkflowClient#signalwithstart)\n\n```typescript\nimport {WorkflowClient} from \"@temporalio/client\";\nimport {yourWorkflow, joinSignal} from \"./workflows\";\n\nconst client = new WorkflowClient();\n\nawait client.signalWithStart(yourWorkflow, {\n  workflowId: \"workflow-id-123\",\n  args: [{foo: 1}],\n  signal: joinSignal,\n  signalArgs: [{userId: \"user-1\", groupId: \"group-1\"}],\n});\n```\n\n</TabItem>\n</Tabs>\n\n## Queries\n\nA [Query](/workflows#query) is a synchronous operation that is used to get the state of a Workflow Execution.\n\n### Define Query\n\nA Query has a name and can have arguments.\n\n- The name, also called a Query type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter/).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nIn Go, a Query type, also called a Query name, is a `string` value.\n\n```go\nqueryType := \"your_query_name\"\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo define a Query, define the method name and the result type of the Query.\n\n```java\nquery(String queryType, Class<R> resultClass, Type resultType, Object... args);\n\n  /* @param queryType name of the Query handler. Usually it is a method name.\n   * @param resultClass class of the Query result type\n   * @param args optional Query arguments\n   * @param <R> type of the Query result\n  */\n```\n\nQuery methods can take in any number of input parameters which can be used to limit the data that is returned.\n\nUse the Query method names to send and receive Queries.\n\nQuery methods must never change any Workflow state including starting Activities or blocking threads in any way.\n\n</TabItem>\n<TabItem value=\"php\">\n\nWorkflows can answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow type defaults to `\"FileProcessingWorkflow\"`.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo define a Query, set the Query decorator [`@workflow.query`](https://python.temporal.io/temporalio.workflow.html#query) on the Query function inside your Workflow.\n\n```python\n@workflow.query\nasync def current_greeting(self) -> str:\n    return self._current_greeting\n```\n\nThe [`@workflow.query`](https://python.temporal.io/temporalio.workflow.html#query) decorator defines a method as a Query. Queries can be asynchronous or synchronous methods and can be inherited; however, if a method is overridden, the override must also be decorated. Queries should return a value.\n\n**Dynamic Queries**\n\nYou can use `@workflow.query(dynamic=True)`, which means all other unhandled Query's fall through to this.\n\nFor example:\n\n```python\n@workflow.query(dynamic=True)\ndef query_dynamic(self, name: str, *args: Any) -> str:\n    return f\"query_dynamic {name}: {args[0]}\"\n```\n\n**Customize names**\n\nYou can have a name parameter to customize the Query's name, otherwise it defaults to the unqualified method `__name__`.\n\nThe following example sets a custom Query name.\n\n```python\n@workflow.query(name=\"Custom-Name\")\ndef query(self, arg: str) -> None:\n    self._last_event = f\"query: {arg}\"\n```\n\n:::note\n\nYou can either set the `name` or the `dynamic` parameter in a Query's decorator, but not both.\n\n:::\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n### Handle Query\n\nQueries are handled by your Workflow.\n\nDont include any logic that causes [Command](/workflows#command) generation within a Query handler (such as executing Activities).\nIncluding such logic causes unexpected behavior.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nUse the `SetQueryHandler` API from the `go.temporal.io/sdk/workflow` package to set a Query Handler that listens for a Query by name.\n\nThe handler must be a function that returns two values:\n\n1. A serializable result\n2. An error\n\nThe handler function can receive any number of input parameters, but all input parameters must be serializable.\nThe following sample code sets up a Query Handler that handles the `current_state` Query type:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n  currentState := \"started\" // This could be any serializable struct.\n  queryType := \"current_state\"\n  err := workflow.SetQueryHandler(ctx, queryType, func() (string, error) {\n    return currentState, nil\n  })\n  if err != nil {\n    currentState = \"failed to register query handler\"\n    return err\n  }\n  // Your normal Workflow code begins here, and you update the currentState as the code makes progress.\n  currentState = \"waiting timer\"\n  err = NewTimer(ctx, time.Hour).Get(ctx, nil)\n  if err != nil {\n    currentState = \"timer failed\"\n    return err\n  }\n  currentState = \"waiting activity\"\n  ctx = WithActivityOptions(ctx, yourActivityOptions)\n  err = ExecuteActivity(ctx, YourActivity, \"your_input\").Get(ctx, nil)\n  if err != nil {\n    currentState = \"activity failed\"\n    return err\n  }\n  currentState = \"done\"\n  return nil\n}\n```\n\nFor example, suppose your query handler function takes two parameters:\n\n```go\nerr := workflow.SetQueryHandler(ctx, \"current_state\", func(prefix string, suffix string) (string, error) {\n    return prefix + currentState + suffix, nil\n})\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo handle a Query in the Workflow, create a Query handler using the `@QueryMethod` annotation in the Workflow interface and define it in the Workflow implementation.\n\nThe `@QueryMethod` annotation indicates that the method is used to handle a Query that is sent to the Workflow Execution.\nThe method can have parameters that can be used to filter data that the Query returns.\nBecause the method returns a value, it must have a return type that is not `void`.\n\nThe Query name defaults to the name of the method.\nIn the following example, the Query name defaults to `getStatus`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod\n   String getStatus();\n}\n```\n\nTo overwrite this default naming and assign a custom Query name, use the `@QueryMethod` annotation with the `name` parameter. In the following example, the Query name is set to \"history\".\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod(name = \"history\")\n   String getStatus();\n}\n```\n\nA Workflow Definition interface can define multiple methods annotated with `@QueryMethod`, but the method names or the `name` parameters for each must be unique.\n\nThe following Workflow interface has a Query method `getCount()` to handle Queries to this Workflow.\n\n```java\n  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @QueryMethod\n    int getCount();\n  }\n```\n\nThe following example is the Workflow implementation with the Query method defined in the `HelloWorld` Workflow interface from the previous example.\n\n```java\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = \"Hello\";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!\"Bye\".equals(greeting)) {\n        logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n```\n\n**Dynamic Query Handler**\nYou can also implement Query handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicQueryListener` in the Workflow implementation code.\n\n```java\n      Workflow.registerListener(\n        (DynamicQueryHandler)\n            (queryName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Queries sent to the Workflow without a defined handler will be delivered to the `DynamicQueryHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicQueryHandler` can be implemented in both regular and dynamic Workflow implementations.\n\n</TabItem>\n<TabItem value=\"php\">\n\nYou can add custom Query types to handle Queries such as Querying the current state of a\nWorkflow, or Querying how many Activities the Workflow has completed. To do this, you need to set\nup a Query handler using method attribute `QueryMethod` or `Workflow::registerQueryHandler`.\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\QueryMethod]\n    public function getValue()\n    {\n        return 42;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // workflow code\n    }\n\n}\n```\n\nThe handler function can receive any number of input parameters, but all input parameters must be\nserializable. The following sample code sets up a Query handler that handles the Query type of\n`currentState`:\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private string $currentState;\n\n    #[Workflow\\QueryMethod('current_state')]\n    public function getCurrentState(): string\n    {\n        return $this->currentState;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // Your normal Workflow code begins here, and you update the currentState\n        // as the code makes progress.\n        $this->currentState = 'waiting timer';\n        try{\n            yield Workflow::timer(DateInterval::createFromDateString('1 hour'));\n        } catch (\\Throwable $e) {\n            $this->currentState = 'timer failed';\n            throw $e;\n        }\n\n        $yourActivity = Workflow::newActivityStub(\n            YourActivityInterface::class,\n            ActivityOptions::new()->withScheduleToStartTimeout(60)\n        );\n\n        $this->currentState = 'waiting activity';\n        try{\n            yield $yourActivity->doSomething('some input');\n        } catch (\\Throwable $e) {\n            $this->currentState = 'activity failed';\n            throw $e;\n        }\n\n        $this->currentState = 'done';\n\n        return null;\n    }\n}\n```\n\nYou can also issue a Query from code using the `QueryWorkflow()` API on a Temporal Client object.\n\nUse `WorkflowStub` to Query Workflow instances from your Client code (can be applied to both running and closed Workflows):\n\n```php\n$workflow = $workflowClient->newWorkflowStub(\n    YourWorkflow::class,\n    WorkflowOptions::new()\n);\n\n$workflowClient->start($workflow);\n\nvar_dump($workflow->getCurrentState());\nsleep(60);\nvar_dump($workflow->getCurrentState());\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo send a Query from to the Workflow, use the [`query`](https://python.temporal.io/temporalio.client.workflowhandle#query) method from the [`WorkflowHandle`](https://python.temporal.io/temporalio.client.workflowhandle) class.\n\n```python\nawait handle.query(\"some query\")\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nQuery Handlers can return values inside a Workflow in TypeScript.\n\nYou make a Query with `handle.query(query, ...args)`. A Query needs a return value, but can also take arguments.\n\n```typescript\nimport * as wf from \"@temporalio/workflow\";\n\nexport const unblockSignal = wf.defineSignal(\"unblock\");\nexport const isBlockedQuery = wf.defineQuery<boolean>(\"isBlocked\");\n\nexport async function unblockOrCancel(): Promise<void> {\n  let isBlocked = true;\n  wf.setHandler(unblockSignal, () => void (isBlocked = false));\n  wf.setHandler(isBlockedQuery, () => isBlocked);\n  console.log(\"Blocked\");\n  try {\n    await wf.condition(() => !isBlocked);\n    console.log(\"Unblocked\");\n  } catch (err) {\n    if (err instanceof wf.CancelledFailure) {\n      console.log(\"Cancelled\");\n    }\n    throw err;\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Send Query\n\nQueries are sent from a Temporal Client.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nUse the `QueryWorkflow()` API or the `QueryWorkflowWithOptions` API on the Temporal Client to send a Query to a Workflow Execution.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType)\nif err != nil {\n  // ...\n}\n// ...\n```\n\nYou can pass an arbitrary number of arguments to the `QueryWorkflow()` function.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType, \"foo\", \"baz\")\nif err != nil {\n  // ...\n}\n// ...\n```\n\nThe `QueryWorkflowWithOptions()` API provides similar functionality, but with the ability to set additional configurations through [QueryWorkflowWithOptionsRequest](https://pkg.go.dev/go.temporal.io/sdk/client#QueryWorkflowWithOptionsRequest).\nWhen using this API, you will also receive a structured response of type [QueryWorkflowWithOptionsResponse](https://pkg.go.dev/go.temporal.io/sdk/client#QueryWorkflowWithOptionsResponse).\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflowWithOptions(context.Background(), &client.QueryWorkflowWithOptionsRequest{\n    WorkflowID: workflowID,\n    RunID: runID,\n    QueryType: queryType,\n    Args: args,\n})\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.\n\nFor example, the following Client code calls a Query method `queryGreeting()` defined in the `GreetingWorkflow` Workflow interface.\n\n```java\n // Create our workflow options\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder()\n        .setWorkflowId(WORKFLOW_ID)\n        .setTaskQueue(TASK_QUEUE).build();\n\n    // Create the Temporal client stub. It is used to start our workflow execution.\n    GreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);\n\n    // Start our workflow asynchronously to not use another thread to query.\n    WorkflowClient.start(workflow::createGreeting, \"World\");\n\n    // Query the Workflow to get the current value of greeting and print it.\n    System.out.println(workflow.queryGreeting());\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n## Workflow timeouts & retries\n\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\n### Workflow Execution Timeout\n\nUse the [Workflow Execution Timeout](/workflows#workflow-execution-timeout) to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  WorkflowExecutionTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nSet the [Workflow Execution Timeout](/workflows#workflow-execution-timeout) with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowExecutionTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Execution Timeout duration\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                .build());\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\nThe following code example creates a new Workflow and sets the Workflow ID. Then it sets the Workflow ID resuse policy and the Workflow Execution Timeout to 2 minutes.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    DynamicSleepWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(DynamicSleepWorkflow::WORKFLOW_ID)\n        ->withWorkflowIdReusePolicy(WorkflowIdReusePolicy::WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(2))\n);\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n### Workflow Run Timeout\n\nUse the [Workflow Run Timeout](/workflows#workflow-run-timeout) to restrict the maximum amount of time that a single [Workflow Run](/concepts/what-is-a-workflow-execution/#workflow-execution-chain) can last.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Same as [`WorkflowExecutionTimeout`](#workflowexecutiontimeout)\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowRunTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nSet the Workflow Run Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowRunTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Same as [WorkflowExecutionTimeout](#workflow-execution-timeout).\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Run Timeout duration\n                .setWorkflowRunTimeout(Duration.ofSeconds(10))\n                .build());\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\n`WorkflowRunTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n);\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n### Workflow Task Timeout\n\nUse the [Workflow Task Timeout](/workflows#workflow-task-timeout) to restrict the maximum amount of time that a Worker can execute a [Workflow Task](/tasks#workflow-task).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: `time.Seconds * 10`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowTaskTimeout: time.Second * 10,\n  //...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nSet the Workflow Task Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowTaskTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: 10 seconds.\n- Values: Maximum accepted value is 60 seconds.\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Task Timeout duration\n                .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                .build());\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\n`WorkflowTaskTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowTaskTimeout(CarbonInterval::minute(1))\n);\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n### Workflow Retry Policy\n\nUse a [Retry Policy](/retry-policies#) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nCreate an instance of a [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy) from the `go.temporal.io/sdk/temporal` package and provide it as the value to the `RetryPolicy` field of the instance of `StartWorkflowOptions`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default: None\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\nworkflowOptions := client.StartWorkflowOptions{\n  RetryPolicy: retrypolicy,\n  // ...\n}\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nSet Workflow Retry Options in the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance using [`WorkflowOptions.Builder.setWorkflowRetryOptions`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: `Null` which means no retries will be attempted.\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Retry Options\n                .setRetryOptions(RetryOptions.newBuilder()\n                .build());\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\nA Retry Policy can be configured with an instance of the `RetryOptions` object.\nTo enable retries for a Workflow, you need to provide a Retry Policy object via `ChildWorkflowOptions`\nfor child Workflows or via `WorkflowOptions` for top-level Workflows.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()->withRetryOptions(\n        RetryOptions::new()->withInitialInterval(120)\n      )\n);\n```\n\nFor more detailed information about `RetryOptions` object see [retries](/php/retries) for more details.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n## Activity timeouts and retries\n\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\n### Schedule-To-Close Timeout\n\nUse the [Schedule-To-Close Timeout](/activities#schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/activities#activity-execution).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo set a [Schedule-To-Close Timeout](/activities#schedule-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `time.Duration`\n- Default:  (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo set a [Schedule-To-Close Timeout](/activities#schedule-to-close-timeout), use [`ActivityOptions.newBuilder.setScheduleToCloseTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `Duration`\n- Default: Unlimited.\n  Note that if `WorkflowRunTimeout` and/or `WorkflowExecutionTimeout` are defined in the Workflow, all Activity retries will stop when either or both of these timeouts are reached.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                      \"GetCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                          .build()))\n                      .build();\n  ```\n\n</TabItem>\n<TabItem value=\"php\">\n\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(2))\n);\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code example sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_close_timeout` to 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault:  (infinity  no limit)\n\nIn this example, you can set the `scheduleToCloseTimeout` to 5 m.\n\n```typescript\n// Sample of typical options you can set\nconst {greet} = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: \"5m\",\n  retry: {\n    // default retry policy if not specified\n    initialInterval: \"1s\",\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n\n</TabItem>\n</Tabs>\n\n### Start-To-Close Timeout\n\nUse the [Start-To-Close Timeout](/activities#start-to-close-timeout) to limit the maximum duration of a single [Activity Task Execution](/tasks#activity-task-execution).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo set a [Start-To-Close Timeout](/activities#start-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `time.Duration`\n- Default: Same as the `ScheduleToCloseTimeout`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  StartToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo set a [Start-To-Close Timeout](/activities#start-to-close-timeout), use [`ActivityOptions.newBuilder.setStartToCloseTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `Duration`\n- Default: Defaults to [`ScheduleToCloseTimeout`](#scheduletoclosetimeout) value\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n              ActivityOptions.newBuilder()\n                      .setStartToCloseTimeout(Duration.ofSeconds(2))\n                      .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // Set Activity Execution timeout (single run)\n                                            .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n\n</TabItem>\n<TabItem value=\"php\">\n\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `StartToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(CarbonInterval::seconds(2))\n);\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\n```python\nstart_to_close_timeout = timedelta(seconds=5)\n```\n\nThe following code example executes an Activity with a `start_to_close_timeout` of 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault:  (infinity  no limit)\n\nIn this example, you can set the `startToCloseTimeout` to 30 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst {greet} = proxyActivities<typeof activities>({\n  startToCloseTimeout: \"30s\", // recommended\n  retry: {\n    // default retry policy if not specified\n    initialInterval: \"1s\",\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n\n</TabItem>\n</Tabs>\n\n### Schedule-To-Start Timeout\n\nUse the [Schedule-To-Start Timeout](/activities#schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo set a [Schedule-To-Start Timeout](/activities#schedule-to-start-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: `time.Duration`\n- Default:  (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo set a [Schedule-To-Start Timeout](/activities#schedule-to-start-timeout), use [`ActivityOptions.newBuilder.setScheduleToStartTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: Unlimited. This timeout is non-retryable.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                          // required when setting Activity options.\n                          .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n             WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"GetCustomerGreeting\",\n                                ActivityOptions.newBuilder()\n                                    .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                    .build()))\n                      .build();\n  ```\n\n</TabItem>\n<TabItem value=\"php\">\n\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToStartTimeout` set to 10 seconds.\n\n```php\n// Creating a stub for the activity.\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()\n                ->withScheduleToStartTimeout(CarbonInterval::seconds(10))\n        );\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_start_timeout` to 1 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            name,\n            schedule_to_close_timeout=5000,\n            schedule_to_start_timeout=1000,\n        )\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault:  (infinity  no limit)\n\nIn this example, you can set the `scheduleToStartTimeout` to 60 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst {greet} = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: \"5m\",\n  scheduleToStartTimeout: \"60s\",\n  retry: {\n    // default retry policy if not specified\n    initialInterval: \"1s\",\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n\n</TabItem>\n</Tabs>\n\n### Activity Retry Policy\n\nActivity Executions are automatically associated with a default [Retry Policy](/retry-policies#) if a custom one is not provided.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo set a [RetryPolicy](/retry-policies#), Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default:\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100, // 100 * InitialInterval\n  MaximumAttempts: 0, // Unlimited\n  NonRetryableErrorTypes: []string, // empty\n}\n```\n\nProviding a Retry Policy here is a customization, and overwrites individual Field defaults.\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\n\nactivityoptions := workflow.ActivityOptions{\n  RetryPolicy: retrypolicy,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo set [Retry Options](/retry-policies#), use [`ActivityOptions.newBuilder.setRetryOptions()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: Server-defined Activity Retry policy.\n\n- With `ActivityStub`\n\n  ```java\n  private final ActivityOptions options =\n      ActivityOptions.newBuilder()\n          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n          // required when setting Activity options.\n          .setStartToCloseTimeout(Duration.ofSeconds(5))\n          .setRetryOptions(\n              RetryOptions.newBuilder()\n                  .setInitialInterval(Duration.ofSeconds(1))\n                  .setMaximumInterval(Duration.ofSeconds(10))\n                  .build())\n          .build();\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                // required when setting Activity options.\n                                .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                .setRetryOptions(\n                                      RetryOptions.newBuilder()\n                                          .setDoNotRetry(NullPointerException.class.getName())\n                                          .build())\n                                .build()))\n                .build();\n  ```\n\n</TabItem>\n<TabItem value=\"php\">\n\nTo enable Activity Retry, set `{@link RetryOptions}` on `{@link ActivityOptions}`.\nThe follow example creates a new Activity with the given options.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(10))\n        ->withRetryOptions(\n            RetryOptions::new()\n                ->withInitialInterval(CarbonInterval::seconds(1))\n                ->withMaximumAttempts(5)\n                ->withNonRetryableExceptions([\\InvalidArgumentException::class])\n        )\n);\n}\n```\n\nFor an executable code sample, see [ActivityRetry sample](https://github.com/temporalio/samples-php/tree/master/app/src/ActivityRetry) in the PHP samples repository.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo create an Activity Retry Policy in Python, set the [RetryPolicy](https://python.temporal.io/temporalio.common.retrypolicy) class within the [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) or [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) function.\n\nThe following example sets the maximum interval to 2 seconds.\n\n```python\nworkflow.execute_activity(\n    your_activity,\n    name,\n    start_to_close_timeout=timedelta(seconds=10),\n    retry_policy=RetryPolicy(maximum_interval=timedelta(seconds=2)),\n)\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nTo set Activity Retry Policies in TypeScript, pass [`ActivityOptions.retry`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#retry) to [`proxyActivities`](https://typescript.temporal.io/api/namespaces/workflow/#proxyactivities).\n\n```typescript\n// Sample of typical options you can set\nconst {yourActivity} = proxyActivities<typeof activities>({\n  // ...\n  retry: {\n    // default retry policy if not specified\n    initialInterval: \"1s\",\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n\n</TabItem>\n</Tabs>\n\n### Activity retry simulator\n\nUse this tool to visualize total Activity Execution times and experiment with different Activity timeouts and Retry Policies.\n\nThe simulator is based on a common Activity use-case, which is to call a third party HTTP API and return the results.\nSee the example code snippets below.\n\nUse the Activity Retries settings to configure how long the API request takes to succeed or fail.\nThere is an option to generate scenarios.\nThe _Task Time in Queue_ simulates the time the Activity Task might be waiting in the Task Queue.\n\nUse the Activity Timeouts and Retry Policy settings to see how they impact the success or failure of an Activity Execution.\n\nimport RetrySimulator from '/docs/components/RetrySimulator/RetrySimulator';\n\n<RetrySimulator />\n\n## Activity Heartbeats\n\nAn [Activity Heartbeat](/activities#activity-heartbeat) is a ping from the [Worker Process](/workers#worker-process) that is executing the Activity to the [Temporal Cluster](/clusters#).\nEach Heartbeat informs the Temporal Cluster that the [Activity Execution](/activities#activity-execution) is making progress and the Worker has not crashed.\nIf the Cluster does not receive a Heartbeat within a [Heartbeat Timeout](/activities#heartbeat-timeout) time period, the Activity will be considered failed and another [Activity Task Execution](/tasks#activity-task-execution) may be scheduled according to the Retry Policy.\n\nHeartbeats may not always be sent to the Clusterthey may be [throttled](/concepts/what-is-an-activity-heartbeat#throttling) by the Worker.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\nHeartbeats can contain a `details` field describing the Activity's current progress.\nIf an Activity gets retried, the Activity can access the `details` from the last Heartbeat that was sent to the Cluster.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo [Heartbeat](/activities#activity-heartbeat) in an Activity in Go, use the `RecordHeartbeat` API.\n\n```go\nimport (\n    // ...\n    \"go.temporal.io/sdk/workflow\"\n    // ...\n)\n\nfunc YourActivityDefinition(ctx, YourActivityDefinitionParam) (YourActivityDefinitionResult, error) {\n    // ...\n    activity.RecordHeartbeat(ctx, details)\n    // ...\n}\n```\n\nWhen an Activity Task Execution times out due to a missed Heartbeat, the last value of the `details` variable above is returned to the calling Workflow in the `details` field of `TimeoutError` with `TimeoutType` set to `Heartbeat`.\n\nYou can also Heartbeat an Activity from an external source:\n\n```go\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n// Record heartbeat.\nerr := temporalClient.RecordActivityHeartbeat(ctx, taskToken, details)\n```\n\nThe parameters of the `RecordActivityHeartbeat` function are:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `details`: The serializable payload containing progress information.\n\nIf an Activity Execution Heartbeats its progress before it failed, the retry attempt will have access to the progress information, so that the Activity Execution can resume from the failed state.\nHere's an example of how this can be implemented:\n\n```go\nfunc SampleActivity(ctx context.Context, inputArg InputParams) error {\n    startIdx := inputArg.StartIndex\n    if activity.HasHeartbeatDetails(ctx) {\n        // Recover from finished progress.\n        var finishedIndex int\n        if err := activity.GetHeartbeatDetails(ctx, &finishedIndex); err == nil {\n            startIdx = finishedIndex + 1 // Start from next one.\n        }\n    }\n\n    // Normal Activity logic...\n    for i:=startIdx; i<inputArg.EndIdx; i++ {\n        // Code for processing item i goes here...\n        activity.RecordHeartbeat(ctx, i) // Report progress.\n    }\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo Heartbeat an Activity Execution in Java, use the `Activity.getExecutionContext().heartbeat()` Class method.\n\n```java\npublic class YourActivityDefinitionImpl implements YourActivityDefinition {\n\n  @Override\n  public String yourActivityMethod(YourActivityMethodParam param) {\n    // ...\n    Activity.getExecutionContext().heartbeat(details);\n    // ...\n  }\n  // ...\n}\n```\n\nThe method takes an optional argument, the `details` variable above that represents latest progress of the Activity Execution.\nThis method can take a variety of types such as an exception object, custom object, or string.\n\nIf the Activity Execution times out, the last Heartbeat `details` are included in the thrown `ActivityTimeoutException`, which can be caught by the calling Workflow.\nThe Workflow can then use the `details` information to pass to the next Activity invocation if needed.\n\nIn the case of Activity retries, the last Heartbeat's `details` are available and can be extracted from the last failed attempt by using `Activity.getExecutionContext().getHeartbeatDetails(Class<V> detailsClass)`\n\n</TabItem>\n<TabItem value=\"php\">\n\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo Heartbeat an Activity Execution in Python, use the [`heartbeat()`](https://python.temporal.io/temporalio.activity.html#heartbeat) API.\n\n```python\n@activity.defn\nasync def your_activity_definition() -> str:\n    activity.heartbeat(\"heartbeat details!\")\n```\n\nIn addition to obtaining cancellation information, Heartbeats also support detail data that persists on the server for retrieval during Activity retry.\nIf an Activity calls `heartbeat(123, 456)` and then fails and is retried, `heartbeat_details` returns an iterable containing `123` and `456` on the next Run.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nLong-running Activities should Heartbeat their progress back to the Workflow for earlier detection of stalled Activities (with [Heartbeat Timeout](/activities#heartbeat-timeout)) and resuming stalled Activities from checkpoints (with Heartbeat details).\n\nTo set Activity Heartbeat, use `Context.current().heartbeat()` in your Activity implementation, and set `heartbeatTimeout` in your Workflow.\n\n```ts\n// activity implementation\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  for (let progress = 1; progress <= 1000; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    // record activity heartbeat\n    Context.current().heartbeat();\n  }\n}\n\n//...\n\n// workflow code calling activity\nconst {example} = proxyActivities<typeof activities>({\n  startToCloseTimeout: \"1 hour\",\n  heartbeatTimeout: \"10s\",\n});\n```\n\nIn the previous example, setting the Heartbeat informs the Temporal Server of the Activity's progress at regular intervals.\nIf the Activity stalls or the Activity Worker becomes unavailable, the absence of Heartbeats prompts the Temporal Server to retry the Activity immediately, without waiting for `startToCloseTimeout` to complete.\n\nYou can also add `heartbeatDetails` as a checkpoint to collect data about failures during the execution, and use it to resume the Activity from that point.\n\nThe following example extends the previous sample to include a `heartbeatDetails` checkpoint.\n\n```ts\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  const startingPoint = Context.current().info.heartbeatDetails || 1; // allow for resuming from heartbeat\n  for (let progress = startingPoint; progress <= 100; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    Context.current().heartbeat(progress);\n  }\n}\n```\n\nIn this example, when the `heartbeatTimeout` is reached and the Activity is retried, the Activity Worker picks up the execution from where the previous attempt left off.\n\n</TabItem>\n</Tabs>\n\n#### Heartbeat Timeout\n\nA [Heartbeat Timeout](/activities#heartbeat-timeout) works in conjunction with [Activity Heartbeats](/activities#activity-heartbeat).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo set a [Heartbeat Timeout](/activities#heartbeat-timeout), Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  HeartbeatTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo set a [Heartbeat Timeout](/activities#heartbeat-timeout), use [`ActivityOptions.newBuilder.setHeartbeatTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: None\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  private final GreetingActivities activities =\n      Workflow.newActivityStub(\n          GreetingActivities.class,\n          ActivityOptions.newBuilder()\n              // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n              // required when setting Activity options.\n              .setStartToCloseTimeout(Duration.ofSeconds(5))\n              .setHeartbeatTimeout(Duration.ofSeconds(2))\n              .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                          // required when setting Activity options.\n                                            .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                            .setHeartbeatTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n\n</TabItem>\n<TabItem value=\"php\">\n\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\n[`heartbeat_timeout`](https://python.temporal.io/temporalio.worker.startactivityinput#heartbeat_timeout) is a class variable for the [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) function used to set the maximum time between Activity Heartbeats.\n\n```python\nworkflow.start_activity(\n    activity=\"your-activity\",\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n```python\nworkflow.execute_activity(\n    activity=\"your-activity\",\n    name,\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nTo set a Heartbeat Timeout, use [`ActivityOptions.heartbeatTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#heartbeattimeout). If the Activity takes longer than that between heartbeats, the Activity is failed.\n\n```typescript\n// Creating a proxy for the activity.\nconst {longRunningActivity} = proxyActivities<typeof activities>({\n  // translates to 300000 ms\n  scheduleToCloseTimeout: \"5m\",\n  // translates to 30000 ms\n  startToCloseTimeout: \"30s\",\n  // equivalent to '10 seconds'\n  heartbeatTimeout: 10000,\n});\n```\n\n</TabItem>\n</Tabs>\n\n## Asynchronous Activity Completion\n\n[Asynchronous Activity Completion](/activities#asynchronous-activity-completion) enables the Activity Function to return without the Activity Execution completing.\n\nThere are three steps to follow:\n\n1. The Activity provides the external system with identifying information needed to complete the Activity Execution.\n   Identifying information can be a [Task Token](/activities#task-token), or a combination of Namespace, Workflow Id, and Activity Id.\n2. The Activity Function completes in a way that identifies it as waiting to be completed by an external system.\n3. The Temporal Client is used to Heartbeat and complete the Activity.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\n1. Provide the external system with the a Task Token to complete the Activity Execution.\n   To do this, use the `GetInfo()` API from the `go.temporal.io/sdk/activity` package.\n\n```go\n// Retrieve the Activity information needed to asynchronously complete the Activity.\nactivityInfo := activity.GetInfo(ctx)\ntaskToken := activityInfo.TaskToken\n// Send the taskToken to the external service that will complete the Activity.\n```\n\n2. Return an `activity.ErrResultPending` error to indicate that the Activity is completing asynchronously.\n\n```go\nreturn \"\", activity.ErrResultPending\n```\n\n3. Use the Temporal Client to complete the Activity using the Task Token.\n\n```go\n// Instantiate a Temporal service client.\n// The same client can be used to complete or fail any number of Activities.\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n\n// Complete the Activity.\ntemporalClient.CompleteActivity(context.Background(), taskToken, result, nil)\n```\n\nFollowing are the parameters of the `CompleteActivity` function:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `result`: The return value to record for the Activity. The type of this value must match the type\n  of the return value declared by the Activity function.\n- `err`: The error code to return if the Activity terminates with an error.\n\nIf `error` is not null, the value of the `result` field is ignored.\n\nTo fail the Activity, you would do the following:\n\n```go\n// Fail the Activity.\nclient.CompleteActivity(context.Background(), taskToken, nil, err)\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nSometimes Workflows need to perform certain operations in parallel.\n\nInvoking activity stub without the use of `yield` will return the Activity result promise which can be resolved at later moment.\nCalling `yield` on promise blocks until a result is available.\n\n> Activity promise also exposes `then` method to construct promise chains.\n> Read more about Promises [here](https://github.com/reactphp/promise).\n\nAlternatively you can explicitly wrap your code (including `yield` constucts) using `Workflow::async` which will execute nested code in parallel with main Workflow code.\nCall `yeild` on Promise returned by `Workflow::async` to merge execution result back to primary Workflow method.\n\n```php\npublic function greet(string $name): \\Generator\n{\n    // Workflow::async runs it's activities and child workflows in a separate coroutine. Use keyword yield to merge\n    // it back to parent process.\n\n    $first = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Bye', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    $second = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hola', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Chao', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    // blocks until $first and $second complete\n    return (yield $first) . \"\\n\" . (yield $second);\n}\n```\n\n**Async completion**\n\nThere are certain scenarios when moving on from an Activity upon completion of its function is not possible or desirable.\nFor example, you might have an application that requires user input to complete the Activity.\nYou could implement the Activity with a polling mechanism, but a simpler and less resource-intensive implementation is to asynchronously complete a Temporal Activity.\n\nThere are two parts to implementing an asynchronously completed Activity:\n\n1. The Activity provides the information necessary for completion from an external system and notifies the Temporal service that it is waiting for that outside callback.\n2. The external service calls the Temporal service to complete the Activity.\n\nThe following example demonstrates the first part:\n\n<!--SNIPSTART samples-php-async-activity-completion-activity-class-->\n<!--SNIPEND-->\n\nThe following code demonstrates how to complete the Activity successfully using `WorkflowClient`:\n\n<!--SNIPSTART samples-php-async-activity-completion-completebytoken-->\n<!--SNIPEND-->\n\nTo fail the Activity, you would do the following:\n\n```php\n// Fail the Activity.\n$activityClient->completeExceptionallyByToken($taskToken, new \\Error(\"activity failed\"));\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n## Child Workflows\n\nA [Child Workflow Execution](/workflows#child-workflow) is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.\n\nWhen using a Child Workflow API, Child Workflow related Events ([StartChildWorkflowExecutionInitiated](/references/events#startchildworkflowexecutioninitiated), [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted), [ChildWorkflowExecutionCompleted](/references/events#childworkflowexecutioncompleted), etc...) are logged in the Workflow Execution Event History.\n\nAlways block progress until the [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted) Event is logged to the Event History to ensure the Child Workflow Execution has started.\nAfter that, Child Workflow Executions may be abandoned using the default _Abandon_ [Parent Close Policy](/workflows#parent-close-policy) set in the Child Workflow Options.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo spawn a [Child Workflow Execution](/workflows#child-workflow) in Go, use the [`ExecuteChildWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ExecuteChildWorkflow) API, which is available from the `go.temporal.io/sdk/workflow` package.\n\nThe `ExecuteChildWorkflow` call requires an instance of [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context), with an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions) applied to it, the Workflow Type, and any parameters that should be passed to the Child Workflow Execution.\n\n`workflow.ChildWorkflowOptions` contain the same fields as `client.StartWorkflowOptions`.\nWorkflow Option fields automatically inherit their values from the Parent Workflow Options if they are not explicitly set.\nIf a custom `WorkflowID` is not set, one is generated when the Child Workflow Execution is spawned.\nUse the [`WithChildOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithChildOptions) API to apply Child Workflow Options to the instance of `workflow.Context`.\n\nThe `ExecuteChildWorkflow` call returns an instance of a [`ChildWorkflowFuture`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowFuture).\n\nCall the `.Get()` method on the instance of `ChildWorkflowFuture` to wait for the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{}\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  var result ChildResp\n  err := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{}).Get(ctx, &result)\n  if err != nil {\n    // ...\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\nTo asynchronously spawn a Child Workflow Execution, the Child Workflow must have an \"Abandon\" Parent Close Policy set in the Child Workflow Options.\nAdditionally, the Parent Workflow Execution must wait for the \"ChildWorkflowExecutionStarted\" event to appear in its event history before it completes.\n\nIf the Parent makes the `ExecuteChildWorkflow` call and then immediately completes, the Child Workflow Execution will not spawn.\n\nTo be sure that the Child Workflow Execution has started, first call the `GetChildWorkflowExecution` method on the instance of the `ChildWorkflowFuture`, which will return a different Future.\nThen call the `Get()` method on that Future, which is what will wait until the Child Workflow Execution has spawned.\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // Wait for the Child Workflow Execution to spawn\n  var childWE workflow.Execution\n  if err := childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE); err != nil {\n     return err\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nThe first call to the Child Workflow stub must always be its Workflow method (method annotated with `@WorkflowMethod`).\nSimilar to Activities, invoking Child Workflow methods can be made synchronous or asynchronous by using `Async#function` or `Async#procedure`.\nThe synchronous call blocks until a Child Workflow method completes.\nThe asynchronous call returns a `Promise` which can be used to wait for the completion of the Child Workflow method, as in the following example:\n\n```java\nGreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\nPromise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n// ...\ngreeting.get()\n```\n\nTo execute an untyped Child Workflow asynchronously, call `executeAsync` on the `ChildWorkflowStub`, as shown in the following example.\n\n```java\n//...\nChildWorkflowStub childUntyped =\n    Workflow.newUntypedChildWorkflowStub(\n        \"GreetingChild\", // your workflow type\n        ChildWorkflowOptions.newBuilder().setWorkflowId(\"childWorkflow\").build());\n\nPromise<String> greeting =\n    childUntyped.executeAsync(String.class, String.class, \"Hello\", name);\nString result = greeting.get();\n//...\n```\n\nThe following examples show how to spawn a Child Workflow:\n\n- Spawn a Child Workflow from a Workflow:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n  @WorkflowMethod\n  String composeGreeting(String greeting, String name);\n  }\n  // Child Workflow implementation not shown\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n  @Override\n  public String getGreeting(String name) {\n      GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n      // This is a blocking call that returns only after child has completed.\n      return child.composeGreeting(\"Hello\", name );\n  }\n  }\n  ```\n\n- Spawn two Child Workflows (with the same type) in parallel:\n\n  ```java\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n\n          // Workflows are stateful, so a new stub must be created for each new child.\n          GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting1 = Async.function(child1::composeGreeting, \"Hello\", name);\n\n          // Both children will run concurrently.\n          GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting2 = Async.function(child2::composeGreeting, \"Bye\", name);\n\n          // Do something else here.\n          ...\n          return \"First: \" + greeting1.get() + \", second: \" + greeting2.get();\n      }\n  }\n  ```\n\n- Send a Signal to a Child Workflow from the parent:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n      @WorkflowMethod\n      String composeGreeting(String greeting, String name);\n\n      @SignalMethod\n      void updateName(String name);\n  }\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n          GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n          child.updateName(\"Temporal\");\n          return greeting.get();\n      }\n  }\n  ```\n\n- Sending a Query to Child Workflows from within the parent Workflow code is not supported. However, you can send a Query to Child Workflows from Activities using `WorkflowClient`.\n\nRelated reads:\n\n- [How to set a Child Workflow Options in Java](/java/how-to-set-child-workflow-options-in-java)\n\n- [How to develop a Workflow Definition in Java](/application-development/foundations#develop-workflows)\n\n- Java Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n\n</TabItem>\n<TabItem value=\"php\">\n\nBesides Activities, a Workflow can also start other Workflows.\n\n`Workflow::executeChildWorkflow` and `Workflow::newChildWorkflowStub` enables the scheduling of other Workflows from within a Workflow's implementation.\nThe parent Workflow has the ability to monitor and impact the lifecycle of the child Workflow, similar to the way it does for an Activity that it invoked.\n\n```php\n// Use one stub per child workflow run\n$child = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    ChildWorkflowOptions::new()\n        // Do not specify WorkflowId if you want Temporal to generate a unique Id\n        // for the child execution.\n        ->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW')\n        ->withExecutionStartToCloseTimeout(DateInterval::createFromDateString('30 minutes'))\n);\n\n// This is a non blocking call that returns immediately.\n// Use yield $child->workflowMethod(name) to call synchronously.\n$promise = $child->workflowMethod('value');\n\n// Do something else here.\ntry{\n    $value = yield $promise;\n} catch(TemporalException $e) {\n    $logger->error('child workflow failed');\n    throw $e;\n}\n```\n\nLet's take a look at each component of this call.\n\nBefore calling `$child->workflowMethod()`, you must configure `ChildWorkflowOptions` for the invocation.\nThese options customize various execution timeouts, and are passed into the workflow stub defined by the `Workflow::newChildWorkflowStub`.\nOnce stub created you can invoke its Workflow method based on attribute `WorkflowMethod`.\n\nThe method call returns immediately and returns a `Promise`.\nThis allows you to execute more code without having to wait for the scheduled Workflow to complete.\n\nWhen you are ready to process the results of the Workflow, call the `yield $promise` method on the returned promise object.\n\nWhen a parent Workflow is cancelled by the user, the child Workflow can be cancelled or abandoned based on a configurable child policy.\n\nYou can also skip the stub part of child workflow initiation and use `Workflow::executeChildWorkflow` directly:\n\n```php\n// Use one stub per child workflow run\n$childResult = yield Workflow::executeChildWorkflow(\n    'ChildWorkflowName',\n    ['args'],\n    ChildWorkflowOptions::new()->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW'),\n    Type::TYPE_STRING // optional: defines the return type\n);\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n#### Parent Close Policy\n\nA [Parent Close Policy](/workflows#parent-close-policy) determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nIn Go, a Parent Close Policy is set on the `ParentClosePolicy` field of an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions).\nThe possible values can be obtained from the [`go.temporal.io/api/enums/v1`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy) package.\n\n- `PARENT_CLOSE_POLICY_ABANDON`\n- `PARENT_CLOSE_POLICY_TERMINATE`\n- `PARENT_CLOSE_POLICY_REQUEST_CANCEL`\n\nThe Child Workflow Options are then applied to the instance of `workflow.Context` by using the `WithChildOptions` API, which is then passed to the `ExecuteChildWorkflow()` call.\n\n- Type: [`ParentClosePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy)\n- Default: `PARENT_CLOSE_POLICY_ABANDON`\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n  // ...\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    // ...\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // ...\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nSet [Parent Close Policy](/workflows#parent-close-policy) on an instance of `ChildWorkflowOptions` using [`ChildWorkflowOptions.newBuilder().setParentClosePolicy`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/ChildWorkflowOptions.Builder.html).\n\n- Type: `ChildWorkflowOptions.Builder`\n- Default: None.\n\n```java\n   public void parentWorkflow() {\n       ChildWorkflowOptions options =\n          ChildWorkflowOptions.newBuilder()\n              .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)\n              .build();\n       MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, options);\n       Async.procedure(child::<workflowMethod>, <args>...);\n       Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(child);\n       // Wait for child to start\n       childExecution.get()\n  }\n```\n\nIn this example, we are:\n\n1. Setting `ChildWorkflowOptions.ParentClosePolicy` to `ABANDON` when creating a Child Workflow stub.\n2. Starting Child Workflow Execution asynchronously using `Async.function` or `Async.procedure`.\n3. Calling `Workflow.getWorkflowExecution()` on the child stub.\n4. Waiting for the `Promise` returned by `getWorkflowExecution` to complete.\n   This indicates whether the Child Workflow started successfully (or failed).\n5. Completing parent Workflow Execution asynchronously.\n\nSteps 3 and 4 are needed to ensure that a Child Workflow Execution starts before the parent closes.\nIf the parent initiates a Child Workflow Execution and then completes immediately after, the Child Workflow will never execute.\n\n</TabItem>\n<TabItem value=\"php\">\n\nIn PHP, a [Parent Close Policy](/workflows#parent-close-policy) is set via the `ChildWorkflowOptions` object and `withParentClosePolicy()` method.\nThe possible values can be obtained from the [`ParentClosePolicy`](https://github.com/temporalio/sdk-php/blob/master/src/Workflow/ParentClosePolicy.php) class.\n\n- `POLICY_TERMINATE`\n- `POLICY_ABANDON`\n- `POLICY_REQUEST_CANCEL`\n\nThen `ChildWorkflowOptions` object is used to create a new child workflow object:\n\n```php\n$child = Workflow::newUntypedChildWorkflowStub(\n    'child-workflow',\n    ChildWorkflowOptions::new()\n        ->withParentClosePolicy(ParentClosePolicy::POLICY_ABANDON)\n);\n\nyield $child->start();\n```\n\nIn the snippet above we:\n\n1. Create a new untyped child workflow stub with `Workflow::newUntypedChildWorkflowStub`.\n2. Provide `ChildWorkflowOptions` object with Parent Close Policy set to `ParentClosePolicy::POLICY_ABANDON`.\n3. Start Child Workflow Execution asynchronously using `yield` and method `start()`.\n\nWe need `yield` here to ensure that a Child Workflow Execution starts before the parent closes.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n## Continue-As-New\n\n[Continue-As-New](/workflows#continue-as-new) enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.\nThe Workflow Execution spawned from the use of Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo cause a Workflow Execution to [Continue-As-New](/workflows#continue-as-new), the Workflow function should return the result of the [`NewContinueAsNewError()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#NewContinueAsNewError) API available from the `go.temporal.io/sdk/workflow` package.\n\n```go\nfunc SimpleWorkflow(ctx workflow.Context, value string) error {\n    ...\n    return workflow.NewContinueAsNewError(ctx, SimpleWorkflow, value)\n}\n```\n\nTo check whether a Workflow Execution was spawned as a result of Continue-As-New, you can check if `workflow.GetInfo(ctx).ContinuedExecutionRunID` is not nil.\n\n**Notes**\n\n- To prevent Signal loss, be sure to perform an asynchronous drain on the Signal channel.\n  Failure to do so can result in buffered Signals being ignored and lost.\n- Make sure that the previous Workflow and the Continue-As-New Workflow are referenced by the same alias.\n  Failure to do so can cause the Workflow to Continue-As-New on an entirely different Workflow.\n\n</TabItem>\n<TabItem value=\"java\">\n\nTemporal SDK allows you to use [Continue-As-New](/workflows#continue-as-new) in various ways.\n\nTo continue execution of the same Workflow that is currently running, use:\n\n```java\nWorkflow.continueAsNew(input1, ...);\n```\n\nTo continue execution of a currently running Workflow as a completely different Workflow type, use `Workflow.newContinueAsNewStub()`.\nFor example, in a Workflow class called `YourWorkflow`, we can create a Workflow stub with a different type, and call its Workflow method to continue execution as that type:\n\n```java\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class);\nconinueAsNew.greet(input);\n```\n\nTo provide `ContinueAsNewOptions` options in `Workflow.newContinueAsNewStub()` use:\n\n```java\nContinueAsNewOptions options = ContinueAsNewOptions.newBuilder()\n        .setTaskQueue(\"newTaskQueueName\")\n        .build();\n\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class, options);\n// ...\ncontinueAsNew.greet(input);\n```\n\nProviding these options allows you to continue Workflow Execution as a new Workflow run, with a different Workflow Type, and on a different Task Queue.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n\n</TabItem>\n<TabItem value=\"php\">\n\nWorkflows that need to rerun periodically could naively be implemented as a big **while** loop with a sleep where the entire logic of the Workflow is inside the body of the **while** loop.\nThe problem with this approach is that the history for that Workflow will keep growing to a point where it reaches the maximum size enforced by the service.\n\n**ContinueAsNew** is the low level construct that enables implementing such Workflows without the risk of failures down the road.\nThe operation atomically completes the current execution and starts a new execution of the Workflow with the same **Workflow Id**.\nThe new execution will not carry over any history from the old execution.\n\nTo trigger this behavior, use `Workflow::continueAsNew` or `Workflow::newContinueAsNewStub` method:\n\n```php\n#[Workflow\\WorkflowMethod]\npublic function periodic(string $name, int $value = 0)\n{\n    for ($i = 0; $i < 100; $i++) {\n        // do something\n        $value++;\n    }\n\n    // maintain $value counter between runs\n    return Workflow::newContinueAsNewStub(self::class)->periodic($name, $value);\n}\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo Continue-As-New in Python, call the [`continue_as_new()`](https://python.temporal.io/temporalio.workflow.html#continue_as_new) function from inside your Workflow, which will stop the Workflow immediately and Continue-As-New.\n\n```python\nworkflow.continue_as_new(\"your-workflow-name\")\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n## Temporal Cron Jobs\n\nA [Temporal Cron Job](/workflows#temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `CronSchedule` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nSet the Cron Schedule with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\nSetting `setCronSchedule` changes the Workflow Execution into a Temporal Cron Job.\nThe default timezone for a Cron is UTC.\n\n- Type: `String`\n- Default: None\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    YourWorker.yourclient.newWorkflowStub(\n        YourWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(YourWorker.TASK_QUEUE)\n                // Set Cron Schedule\n                .setCronSchedule(\"* * * * *\")\n                .build());\n```\n\nFor more details, see the [Cron Sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/hello/HelloCron.java)\n\n</TabItem>\n<TabItem value=\"php\">\n\nSet your Cron Schedule with `CronSchedule('* * * * *')`.\n\nThe following example sets a Cron Schedule in PHP:\n\n```php\n  $workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()\n          ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n          ->withCronSchedule('* * * * *')\n          // Execution timeout limits total time. Cron will stop executing after this timeout.\n          ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n          // Run timeout limits duration of a single workflow invocation.\n          ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n  );\n\n  $output->writeln(\"Starting <comment>CronWorkflow</comment>... \");\n\n  try {\n      $run = $this->workflowClient->start($workflow, 'Antony');\n      // ...\n  }\n```\n\nSetting `withCronSchedule` turns the Workflow Execution into a Temporal Cron Job.\nFor more information, see the [PHP samples](https://github.com/temporalio/samples-php/tree/master/app/src/Cron) for example code or the PHP SDK `WorkflowOptions` [source code](https://github.com/temporalio/sdk-php/blob/master/src/Client/WorkflowOptions.php).\n\n</TabItem>\n<TabItem value=\"python\">\n\nYou can set each Workflow to repeat on a schedule with the `cron_schedule` option from either the [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) asynchronous methods:\n\n```python\nawait client.start_workflow(\n    \"your_workflow_name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    cron_schedule=\"* * * * *\",\n)\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nYou can set each Workflow to repeat on a schedule with the `cronSchedule` option:\n\n```typescript\nconst handle = await client.start(scheduledWorkflow, {\n  // ...\n  cronSchedule: \"* * * * *\", // start every minute\n});\n```\n\n</TabItem>\n</Tabs>\n\n## Environment variables\n\nEnvironment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.\nThey can't be used normally with Workflow code, as that would be [nondeterministic](workflows#intrinsic-non-deterministic-logic) (if the environment variables changed between Workflow replays, the code that used them would behave differently).\n\nMost of the time, you can provide environment variables in your Activity function; however, if you need them in your Workflow functions, you can use the following options:\n\n- Provide environment variables as arguments when starting the Workflow.\n- Call a Local Activity at the beginning of the Workflow that returns environment variables.\n\nIn either case, the environment variables will appear in Event History, so you may want to use an [encryption Data Converter](/concepts/what-is-a-data-converter/#encryption).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n**Using in Activity code**\n\n```ts\nasync function runWorker(): Promise<void> {\n  const activities = createActivities({apiKey: process.env.MAILGUN_API_KEY});\n\n  const worker = await Worker.create({\n    taskQueue: \"example\",\n    activities,\n    workflowsPath: require.resolve(\"./workflows\"),\n  });\n  await worker.run();\n}\n\nconst createActivities = (envVars: {apiKey: string}) => ({\n  async sendNotificationEmail(): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: \"post\",\n      params: {to, from, subject, html},\n      auth: {\n        username: \"api\",\n        password: envVars.apiKey,\n      },\n    });\n  },\n});\n```\n\n**Getting into Workflow**\n\nIf we needed environment variables in our Workflow, here's how we'd use a Local Activity:\n\n```ts\nconst worker = await Worker.create({\n  taskQueue: \"example\",\n  activities: createActivities(process.env),\n  workflowsPath: require.resolve(\"./workflows\"),\n});\n\ntype EnvVars = Record<string, string>;\n\nconst createActivities = (envVars: EnvVars) => ({\n  async getEnvVars(): Promise<EnvVars> {\n    return envVars;\n  },\n  async sendNotificationEmail(apiKey: string): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: \"post\",\n      params: {to, from, subject, html},\n      auth: {\n        username: \"api\",\n        password: apiKey,\n      },\n    });\n  },\n});\n```\n\n```ts\nconst {getEnvVars} = proxyLocalActivities({\n  startToCloseTimeout: \"1m\",\n});\n\nconst {sendNotificationEmail} = proxyActivities({\n  startToCloseTimeout: \"1m\",\n});\n\nasync function yourWorkflow() {\n  const envVars = await getEnvVars();\n  if (!envVars.apiKey) {\n    throw new Error(\"missing env var apiKey\");\n  }\n  await sendNotificationEmail(envVars.apiKey);\n}\n```\n\n</TabItem>\n</Tabs>\n\n"},{"file_name":"foundations.md","id":"foundations","file_dir":"application-development","title":"Application development - Foundations","sidebar_label":"Foundations","description":"The Foundations section of the Temporal Application development guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application  that is, all the relevant steps to start a Workflow Execution that executes an Activity.","use_description":false,"toc_max_heading_level":4,"add_tabs_support":true,"sections":[{"type":"p","id":"app-dev-context/foundations","node":{"file_name":"foundations.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/foundations.md","id":"app-dev-context/foundations","title":"How to build a basic Temporal Application","description":"The Foundations section of the Temporal Application development guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Applicationthat is, all the relevant steps to start a Workflow Execution that executes an Activity.","label":"Foundations","tags":["guide-context"],"markdown_content":"The Foundations section of the Temporal Application development guide covers the minimum set of concepts and implementation details needed to build and run a [Temporal Application](/temporal#temporal-application)that is, all the relevant steps to start a [Workflow Execution](/workflows#workflow-execution) that executes an [Activity](/activities#activity-execution).\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Application development guide, it could be in [older docs for SDKs](/sdks).\n\n:::\n\nIn this section you can find the following:\n\n- [How to run a dev Cluster](#run-a-dev-cluster)\n- [How to add your SDK](#add-your-sdk)\n- [How to create a Temporal Client](#create-temporal-clients)\n- [How to develop a Workflow](#develop-workflows)\n- [How to develop an Activity](#develop-activities)\n- [How to start an Activity Execution](#start-activity-execution)\n- [How to run a Worker Process](#run-worker-processes)\n- [How to start a Workflow Execution](#start-workflow-execution)","is_empty":false}},{"type":"h2","id":"clusters/quick-install","node":{"file_name":"quick-install.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/clusters/quick-install.md","id":"clusters/quick-install","title":"How to quickly install a Temporal Cluster for testing and local development","description":"There are four ways to quickly install and run a Temporal Cluster.","label":"Run a dev Cluster","markdown_content":"The following sections list various methods of deploying your [Temporal Clusters](/clusters#) locally, so that you can use and interact with the [Temporal Client](/temporal#temporal-client) APIs and [tctl](/tctl) commands to test and develop applications.\n\n- [Temporalite](#temporalite): This distribution of Temporal runs as a single process with zero runtime dependencies.\n- [Docker](#docker-compose): Using Docker Compose simplifies developing your Temporal Application.\n- [Gitpod](#gitpod): One-click deployments are available for Go and TypeScript.\n\n**For information on deploying a [production environment](/server/production-deployment), see the [Temporal Cloud](/cloud) documentation.**\n\n### Temporalite\n\nTemporalite is a distribution of Temporal that runs as a single process with zero runtime dependencies.\nIt supports persistence to disk and in-memory mode through SQLite.\n\n**Prerequisites**\n\nTemporalite requires Go 1.18 or later.\n\n**Build and start Temporalite**\n\nThe following steps start and run a Temporal Cluster.\n\n1. Build from source by using `go install`.\n   ```bash\n   go install github.com/temporalio/temporalite/cmd/temporalite@latest\n   ```\n2. Start Temporalite by using the `start` command.\n   ```bash\n   temporalite start --namespace default\n   ```\n   Replace `default` with your [Namespace Name](/cloud/#temporal-cloud-namespace-name).\n\n**Results**: You should have Temporal Cluster running at `http://127.0.0.1:7233` and the Temporal Web UI at [`http://127.0.0.1:8233`](http://127.0.0.1:8233/namespaces/default/workflows).\n\n<!-- For macOS users, if you receive the `error setting up schema: stat /Users/<user_name>/Library/Application Support/temporalite/db:` error, then create the folders `temporalite/db` in your `Application Support` library. -->\n\n### Docker Compose\n\nUse Docker Compose and Temporal Cluster Docker images to quickly install and run a Temporal Cluster locally while developing Temporal Applications.\n\n**Prerequisites**\n\nInstall [Docker](https://docs.docker.com/engine/install) and [Docker Compose](https://docs.docker.com/compose/install).\n\n**Clone the repo and run Docker Compose**\n\nThe following steps start and run a Temporal Cluster using the default configuration.\n\n1. Clone the [temporalio/docker-compose](https://github.com/temporalio/docker-compose) repository.\n   ```bash\n   git clone https://github.com/temporalio/docker-compose.git\n   ```\n2. Change to the directory for the project.\n   ```bash\n   cd docker-compose\n   ```\n3. From your project directory, start your application.\n   ```bash\n   docker-compose up\n   ```\n\n**Results**: You should have Temporal Cluster running at `http://127.0.0.1:7233` and the Temporal Web UI at [`http://127.0.0.1:8080`](http://127.0.0.1:8080/namespaces/default/workflows).\n\nTo try other configurations (different dependencies and databases), or to try a custom Docker image, follow the [temporalio/docker-compose README](https://github.com/temporalio/docker-compose/blob/main/README.md).\n\n### Gitpod\n\nYou can run a Temporal Cluster and develop Temporal Applications in your browser using [Gitpod](https://gitpod.io/#https://github.com/temporalio/samples-typescript/).\n\nOne-click deployments are available for the [temporalio/samples-go](https://github.com/temporalio/samples-go) repo and the [temporalio/samples-typescript](https://github.com/temporalio/samples-typescript) repo.\n\nA one-click deployment starts a Temporal Cluster using a Temporal Cluster Docker image, starts a Worker Process, and starts one of the application's sample Workflows.\n\nA one-click deployment can take up to a full minute to get fully up and running.\nWhen it is running, you can customize the application samples.","is_empty":false}},{"type":"h2","id":"app-dev-context/add-sdk","node":{"file_name":"add-sdk.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/add-sdk.md","id":"app-dev-context/add-sdk","title":"How to add a Temporal SDK to your project","description":"A Temporal SDK provides a framework for Temporal Application development.","label":"Add your SDK","tags":["guide-context"],"markdown_content":"A [Temporal SDK](/temporal#temporal-sdk) provides a framework for [Temporal Application](/temporal#temporal-application) development.\n\nAn SDK provides you with the following:\n\n- A [Temporal Client](/temporal#temporal-client) to communicate with a [Temporal Cluster](/clusters#).\n- APIs to develop [Workflows](/workflows#).\n- APIs to create and manage [Worker Processes](/workers#).\n- APIs to author [Activities](/activities#activity-definition).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/index","node":{"file_name":"index.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/index.md","id":"go/index","title":"How to use the Temporal Go SDK","description":"Add the Temporal Go SDK to your project.","tags":["developer-guide","go"],"markdown_content":"[![Build Status](https://badge.buildkite.com/ce6df3b1a8b375270261ae70fb2d2756af298fef3a0dac4d20.svg?theme=github&branch=master)](https://buildkite.com/temporal/temporal-go-client) [![Coverage Status](https://coveralls.io/repos/github/temporalio/temporal-go-sdk/badge.svg?branch=master)](https://coveralls.io/github/temporalio/temporal-go-sdk?branch=master) [![Go reference](https://pkg.go.dev/badge/go.temporal.io/sdk)](https://pkg.go.dev/go.temporal.io/sdk)\n\nAdd the [Temporal Go SDK](https://github.com/temporalio/sdk-go) to your project:\n\n```bash\ngo get -u go.temporal.io/sdk@latest\n```\n\nOr clone the Go SDK repo to your preferred location:\n\n```bash\ngit clone git@github.com:temporalio/sdk-go.git\n```","is_empty":false}},{"lang":"java","id":"java/index","node":{"file_name":"index.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/index.md","id":"java/index","title":"How to use the Temporal Java SDK","description":"Add the Temporal Java SDK to your project.","label":"Java How-to","tags":["developer-guide","Java"],"markdown_content":"[![Build status](https://badge.buildkite.com/663f6d1be81be6700c28c242b35905f20b68c4fda7b2c7c4e3.svg?branch=master)](https://buildkite.com/temporal/java-sdk-public)\n\nAdd the [Temporal Java SDK](https://github.com/temporalio/sdk-java) to your project as a dependency:\n\n**[Apache Maven](https://maven.apache.org/)**:\n\n```maven\n<dependency>\n  <groupId>io.temporal</groupId>\n  <artifactId>temporal-sdk</artifactId>\n  <version>1.11.0</version>\n</dependency>\n```\n\n**[Gradle Groovy DSL](https://gradle.org/)**:\n\n```groovy\nimplementation 'io.temporal:temporal-sdk:1.11.0'\n```\n\n**Other**:\n\nAdditional scripts for each SDK version are available here: [https://search.maven.org/artifact/io.temporal/temporal-sdk](https://search.maven.org/artifact/io.temporal/temporal-sdk).\nSelect an SDK version to see available scripts.","is_empty":false}},{"lang":"php","id":"php/index","node":{"file_name":"index.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/index.md","id":"php/index","title":"How to use the Temporal PHP SDK","description":"Add the Temporal PHP SDK to your project.","tags":["developer-guide","php"],"markdown_content":"[![CI Status](https://github.com/temporalio/php-sdk/workflows/Unit/badge.svg)](https://github.com/temporalio/php-sdk/actions)\n[![Stable Release](https://poser.pugx.org/temporal/sdk/version)](https://packagist.org/packages/temporal/sdk)\n[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php?ref=badge_shield)\n\nThe Temporal PHP SDK is available as composer package and can be installed using the following command in a root of your project:\n\n```bash\ncomposer require temporal/sdk\n```\n\nThe Temporal PHP SDK requires the RoadRunner 2.0 application server and supervisor to run Activities and Workflows in a scalable way.\n\nInstall RoadRunner manually by downloading its binary from the [release page](https://github.com/roadrunner-server/roadrunner/releases/tag/v1.9.2).\n\nOr install RoadRunner through the CLI:\n\n```bash\ncomposer require spiral/roadrunner:v2.0 nyholm/psr7\n./vendor/bin/rr get-binary\n```","is_empty":false}},{"lang":"python","id":"python/index","node":{"file_name":"index.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/index.md","id":"python/index","title":"How to add the Temporal Python SDK","description":"Add the Temporal Python SDK to your project.","tags":["developer-guide","python"],"markdown_content":"[![Python 3.7+](https://img.shields.io/pypi/pyversions/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n[![PyPI](https://img.shields.io/pypi/v/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n\nTo install the latest version of the Temporal Python package, run the following command.\n\n```bash\npip install temporalio\n```","is_empty":false}},{"lang":"typescript","id":"typescript/index","node":{"file_name":"index.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/index.md","id":"typescript/index","title":"How to use the Temporal TypeScript SDK","description":"Add the Temporal TypeScript SDK to your project.","label":"Temporal TypeScript SDK","tags":["developer-guide","sdk","typescript"],"markdown_content":"[![NPM](https://img.shields.io/npm/v/temporalio.svg?style=for-the-badge)](https://www.npmjs.com/search?q=author%3Atemporal-sdk-team)\n\nThis project requires Node.js 14 or later.\n\n**Create a new project**\n\n```bash\nnpx @temporalio/create@latest ./your-app\n```\n\n**Add to an existing project**\n\n```bash\nnpm install @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity @temporalio/common\n```\n\n:::note\n\nThe TypeScript SDK is designed with TypeScript-first developer experience in mind, but it works equally well with JavaScript.\n\n:::","is_empty":false}}]},{"type":"h4","id":"app-dev-context/api-reference","node":{"file_name":"api-reference.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/api-reference.md","id":"app-dev-context/api-reference","title":"How to find an SDK API reference","description":"Each SDK has its own API reference. Select a programming language and follow the link to be taken to that reference page.","label":"API reference","tags":["guide-context"],"markdown_content":"Each SDK has its own API reference. Select a programming language and follow the link to be taken to that reference page.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/api-reference-go","node":{"file_name":"api-reference-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/api-reference-go.md","id":"go/api-reference-go","title":"API reference","label":"API reference","markdown_content":"The Temporal Go SDK API reference is published on [pkg.go.dev](https://pkg.go.dev/go.temporal.io/sdk).","is_empty":false}},{"lang":"java","id":"java/api-reference-java","node":{"file_name":"api-reference-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/api-reference-java.md","id":"java/api-reference-java","title":"API reference","label":"API reference","markdown_content":"The Temporal Java SDK API reference is published on [javadoc.io](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/index.html).","is_empty":false}},{"lang":"php","id":"none"},{"lang":"python","id":"python/api-reference-python","node":{"file_name":"api-reference-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/api-reference-python.md","id":"python/api-reference-python","title":"API reference","label":"API reference","markdown_content":"The Temporal Python SDK API reference is published on [python.temporal.io](https://python.temporal.io/index.html).","is_empty":false}},{"lang":"typescript","id":"typescript/api-reference-typescript","node":{"file_name":"api-reference-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/api-reference-typescript.md","id":"typescript/api-reference-typescript","title":"API reference","description":"The Temporal TypeScript SDK API reference is published on typescript.temporal.io.","label":"API reference","tags":["how-to","typescript"],"markdown_content":"The Temporal TypeScript SDK API reference is published on [typescript.temporal.io](https://typescript.temporal.io).","is_empty":false}}]},{"type":"h4","id":"app-dev-context/code-samples","node":{"file_name":"code-samples.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/code-samples.md","id":"app-dev-context/code-samples","title":"Where are SDK-specific code examples?","description":"You can find a complete list of executable code samples in Temporal's GitHub repository.","label":"Code samples","tags":["guide-context"],"markdown_content":"You can find a complete list of executable code samples in [Temporal's GitHub repository](https://github.com/temporalio?q=samples-&type=all&language=&sort=).\n\nAdditionally, several of the [Tutorials](https://learn.temporal.io) are backed by a fully executable template application.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/code-samples-go","node":{"file_name":"code-samples-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/code-samples-go.md","id":"go/code-samples-go","title":"Code samples","label":"Code samples","markdown_content":"- [Go Samples repo](https://github.com/temporalio/samples-go#samples-directory)\n- [Background Check application](https://github.com/temporalio/background-checks): Provides a non-trivial Temporal Application implementation in conjunction with [application documentaion](https://learn.temporal.io/examples/go/background-checks/).\n- [Hello world application template in Go](https://github.com/temporalio/hello-world-project-template-go): Provides a quick-start development app for users.\n  This sample works in conjunction with the [\"Hello World!\" from scratch tutorial in Go](https://learn.temporal.io/getting_started/go/hello_world_in_go/).\n- [Money transfer application template in Go](https://github.com/temporalio/money-transfer-project-template-go): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Go](https://learn.temporal.io/getting_started/go/first_program_in_go/).\n- [Subscription-style Workflow Definition in Go](https://github.com/temporalio/subscription-workflow-project-template-go): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n- [eCommerce application example in Go](https://github.com/temporalio/temporal-ecommerce): Showcases a per-user shopping cartstyle Workflow Definition that includes an API for adding and removing items from the cart as well as a web UI.\n  This application sample works in conjunction with the [eCommerce in Go tutorial](https://temporal.io/blog/build-an-ecommerce-app-with-temporal-part-1).","is_empty":false}},{"lang":"java","id":"java/code-samples-java","node":{"file_name":"code-samples-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/code-samples-java.md","id":"java/code-samples-java","title":"Code samples","label":"Code samples","markdown_content":"- [Java samples library](https://github.com/temporalio/samples-java)\n- [Hello world application template in Java](https://github.com/temporalio/hello-world-project-template-java): Provides a quick-start development app for users.\n  Works in conjunction with the [\"Hello World!\" from scratch tutorial in Java](https://learn.temporal.io/getting_started/java/hello_world_in_java/).\n- [Money transfer application template in Java](https://github.com/temporalio/money-transfer-project-template-java): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Java](https://learn.temporal.io/getting_started/java/first_program_in_java/).\n- [Subscription-style Workflow Definition in Java](https://github.com/temporalio/subscription-workflow-project-template-java): Demonstrates some of the patterns that could be implemented for a subscription-style business process.","is_empty":false}},{"lang":"php","id":"php/code-samples-php","node":{"file_name":"code-samples-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/code-samples-php.md","id":"php/code-samples-php","title":"Code samples","label":"Code samples","markdown_content":"- [PHP samples repo](https://github.com/temporalio/samples-php)\n\n- [Subscription-style Workflow Definition in PHP](https://github.com/temporalio/subscription-workflow-project-template-php): Demonstrates some of the patterns that could be implemented for a subscription-style business process.","is_empty":false}},{"lang":"python","id":"python/code-samples-python","node":{"file_name":"code-samples-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/code-samples-python.md","id":"python/code-samples-python","title":"Code samples","label":"Code samples","markdown_content":"- [Python samples library](https://github.com/temporalio/samples-python)","is_empty":false}},{"lang":"typescript","id":"typescript/code-samples-typescript","node":{"file_name":"code-samples-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/code-samples-typescript.md","id":"typescript/code-samples-typescript","title":"Code samples","description":"Use the TypeScript samples library stored on GitHub to demonstrate various capabilities of Temporal.","label":"Code samples","tags":["how-to","typescript"],"markdown_content":"Use the [TypeScript samples library](https://github.com/temporalio/samples-typescript) stored on GitHub to demonstrate various capabilities of Temporal.\n\n**Where can I find video demos?**\n\n[Temporal Go TypeScript YouTube playlist](https://www.youtube.com/playlist?list=PLl9kRkvFJrlTavecydpk9r6cF7qBmQJvb).","is_empty":false}}]},{"type":"h2","id":"app-dev-context/connect-to-a-cluster","node":{"file_name":"connect-to-a-cluster.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/connect-to-a-cluster.md","id":"app-dev-context/connect-to-a-cluster","title":"How to connect a Temporal Client to a Temporal Cluster","description":"When connecting a Temporal Client to a Temporal Cluster, you must provide the address and port number of the Temporal Cluster.","label":"Connect to a Cluster","tags":["guide-context"],"markdown_content":"A [Temporal Client](/temporal#temporal-client) enables you to communicate with a [Temporal Cluster](/clusters#).\nCommunications with a Temporal Cluster include, but aren't limited to, the following:\n\n- starting Workflow Executions\n- sending Signals to Workflow Executions\n- sending Queries to Workflow Executions\n- getting the results of a Workflow Execution\n- providing an Activity Task Token\n\n:::caution\n\nA Temporal Client cannot be initialized and used inside Workflow code.\nHowever, it is acceptable and common to use a Temporal Client inside an Activity to communicate with the Temporal Cluster.\n\n:::\n\nWhen you are running a Cluster locally (such as [temporalite](/clusters/quick-install#temporalite)), the number of connection options you must provide is minimal.\nMany SDKs default to the local host or IP address and port that temporalite and [Docker Compose](/clusters/quick-install#docker-compose) serve (`127.0.0.1:7233`).\n\nWhen you are connecting to a production Cluster (such as [Temporal Cloud](/cloud/index#)), you will likely need to provide additional connection and client options that might include, but aren't limited to, the following:\n\n- address and port\n- [Namespace](/namespaces#) (like a Temporal Cloud Namespace: `<Namespace_ID>.tmprl.cloud`)\n- mTLS CA certificate\n- mTLS private key\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter and intra network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-connect-to-a-cluster-in-go","node":{"file_name":"how-to-connect-to-a-cluster-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-connect-to-a-cluster-in-go.md","id":"go/how-to-connect-to-a-cluster-in-go","title":"How to connect to a Temporal Cluster in Go","description":"Connect a Temporal Client to a Cluster in the Go SDK.","label":"Connect a Temporal Client","tags":["developer-guide","sdk","go"],"markdown_content":"Use the [`Dial()`](https://pkg.go.dev/go.temporal.io/sdk/client#Dial) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to create a new [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nIf you don't provide [`HostPort`](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions), the Client defaults the address and port number to `127.0.0.1:7233`.\n\nSet a custom Namespace name in the Namespace field on an instance of the Client Options.\n\nUse the [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#ConnectionOptions) API to connect a Client with mTLS.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\nfunc main() {\n    cert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n    if err != nil {\n        return err\n    }\n    client, err := client.Dial(client.Options{\n        HostPort:  \"your-custom-namespace.tmprl.cloud:7233\",\n        Namespace: \"your-custom-namespace\",\n        ConnectionOptions: client.ConnectionOptions{\n            TLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n        },\n    }\n    defer temporalClient.Close()\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-create-a-temporal-client-in-java","node":{"file_name":"how-to-create-a-temporal-client-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-create-a-temporal-client-in-java.md","id":"java/how-to-create-a-temporal-client-in-java","title":"How to create a Temporal Client in Java","description":"To initialize a Workflow Client, create an instance of a `WorkflowClient`, create a client-side `WorkflowStub`, and then call a Workflow method (annotated with the `@WorkflowMethod` annotation).","label":"Temporal Client","tags":["java","developer-guide"],"markdown_content":"To initialize a Workflow Client, create an instance of a `WorkflowClient`, create a client-side `WorkflowStub`, and then call a Workflow method (annotated with `@WorkflowMethod`).\n\nTo start a Workflow Execution, your Temporal Server must be running, and your front-end service must be accepting gRPC calls.\n\nTo establish a connection with the front-end service, use `WorkflowServiceStubs`.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n```\n\nYou can provide `WorkflowServiceStubsOptions` to override the default values for the gRPC calls.\n\nFor example, the default front-end service gRPC address is set to `127.0.0.1:7233`, where `7233` is the default port for the Temporal Frontend Service.\n\nIf your server is running on a different host or port from the default, you can set it as shown in the following example.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newInstance(\n                    WorkflowServiceStubsOptions.newBuilder()\n                     .setTarget(TARGET_ENDPOINT)\n                            .build());\n\n```\n\nAfter the connection to the Temporal Frontend Service is established, create a Client for the service stub.\nThe Workflow Client helps with client-side APIs and is required by Workers.\n\nCreate an instance of a `WorkflowClient` for the Workflow service stub, and use `WorkflowClientOptions` to set options for the Workflow Client.\nThe following example shows how to create a `WorkflowClient` instance called \"client\" for the `WorkflowServiceStubs` \"service\" that we created in the previous example, and set `Namespace` option for the `WorkflowClient`.\n\n```java\nWorkflowClient client = WorkflowClient.newInstance(\n                service,\n                WorkflowClientOptions.newBuilder()\n                        .setNamespace(Abc)\n                    .build());\n\n```\n\nFor more information, see [WorkflowClientOptions](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClientOptions.Builder.html).\n\n`WorkflowService` and `WorkflowClient` creation is a heavyweight operation, and will be resource-intensive if created each time you start a Workflow or send a Signal to it.\nThe recommended way is to create them once and reuse where possible.\n\nWith the Client defined, you can start interacting with the Temporal Frontend Service.\n\nTo initialize a Workflow in the Client, create a `WorkflowStub`, and start the Workflow Execution with `WorkflowClient.start()`.\nStarting Workflows or sending Signals or Queries to Workflows from within a Client must be done using `WorkflowStubs`.\n\n```java\nWorkflowClient workflowClient =  WorkflowClient.newInstance(service, clientOptions);\n // Create a Workflow stub.\n YourWorkflow workflow = workflowClient.newWorkflowStub(YourWorkflow.class);\n // Start Workflow asynchronously and call its \"yourWFMethod\" Workflow method\n WorkflowClient.start(workflow::yourWFMethod);\n```\n\nFor more information, see the following:\n\n- [How to spawn a Workflow Execution in Java](#start-workflow-execution)","is_empty":false}},{"lang":"php","id":"php/how-to-create-a-temporal-client-in-php","node":{"file_name":"how-to-create-a-temporal-client-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-create-a-temporal-client-in-php.md","id":"php/how-to-create-a-temporal-client-in-php","title":"How to create a Temporal Client in PHP","label":"Temporal Client","markdown_content":"The following example represents a console command that starts a Workflow, prints its IDs, and then waits for its result:\n\n<!--SNIPSTART php-hello-client {\"enable_source_link\": true}-->\n<!--SNIPEND-->\n\nThe `WorkflowClientInterface` in the snippet is an entry point to get access to Workflow.\nUse an instance of `WorkflowClientInterface` to create, retrieve, or start a Workflow.\nHere we create an instance of `GreetingWorkflowInterface` with a Workflow Execution Timeout of one minute.\n\nThen we print some information and start the Workflow.","is_empty":false}},{"lang":"python","id":"python/how-to-connect-to-a-cluster-in-python","node":{"file_name":"how-to-connect-to-a-cluster-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-connect-to-a-cluster-in-python.md","id":"python/how-to-connect-to-a-cluster-in-python","title":"How to connect to a Temporal Cluster in Python","description":"Connect a Temporal Client to a Cluster in the Python SDK.","label":"Connect a Temporal Client","tags":["developer-guide","sdk","python"],"markdown_content":"Use [`connect()`](https://python.temporal.io/temporalio.client.client#connect) method on the [`Client`](https://python.temporal.io/temporalio.client.client) class to create and connect to a Temporal Client to the Temporal Cluster.\n\nSpecify the `target_host` parameter as a string and provide the [`tls` configuration](https://python.temporal.io/temporalio.service.tlsconfig) for connecting to a Temporal Cluster.\n\n```python\n    client = await Client.connect(\n        #  target_host for the Temporal Cloud\n        \"your-custom-namespace.tmprl.cloud:7233\",\n        # target_host for Temporalite\n        # \"127.0.0.1:7233\"\n        namespace=\"your-custom-namespace\",\n        tls=TLSConfig(\n            client_cert=client_cert,\n            client_private_key=client_private_key,\n            # domain=domain\n            # server_root_ca_cert=server_root_ca_cert,\n        ),\n    )\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-connect-to-a-cluster-in-typescript","node":{"file_name":"how-to-connect-to-a-cluster-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-connect-to-a-cluster-in-typescript.md","id":"typescript/how-to-connect-to-a-cluster-in-typescript","title":"How to connect to a Temporal Cluster in TypeScript","description":"Connect a Temporal Client to a Cluster in the TypeScript SDK.","label":"Connect a Temporal Client","tags":["developer-guide","sdk","typescript"],"markdown_content":"Declaring the `WorflowClient()` creates a new connection to the Temporal service.\n\nIf you omit the connection and just call the `new WorkflowClient()`, you create a default connection that works locally.\nHowever, always configure your connection and Namespace when [deploying to production](/typescript/security/#encryption-in-transit-with-mtls).\n\nUse the [`connectionOptions`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions) API available in the [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.WorkflowClient) package to create a new [`client`](https://typescript.temporal.io/api/namespaces/client/) to communicate with a Temporal Cluster.\n\nUse a new `WorflowClient()` with the requisite gRPC [`Connection`](https://typescript.temporal.io/api/classes/client.Connection#service) to connect to a Client and set your Namespace name.\n\nUse the [`connectionOptions`](https://typescript.temporal.io/api/interfaces/client.TLSConfig) API to connect a Client with mTLS.\n\n```typescript\nimport fs from \"fs-extra\";\nimport {Connection, WorkflowClient} from \"@temporalio/client\";\nimport path = from \"path\";\n\nasync function run() {\n  const cert = await fs.readFile(\"./path-to/your.pem\");\n  const key = await fs.readFile(\"./path-to/your.key\");\n\n  const connectionOptions = {\n    address: \"your-custom-namespace.tmprl.cloud:7233\",\n    tls: {\n      clientCertPair: {\n        crt: cert,\n        key: key,\n      },\n    // serverRootCACertificatePath: \"ca.cert\",\n    },\n  };\n  const connection = await Connection.connect(connectionOptions);\n\n  const client = new WorkflowClient({\n    connection,\n    // connects to 'default' namespace if not specified\n    namespace: \"your-custom-namespace\",\n  });\n\n    // . . .\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```","is_empty":false}}]},{"type":"h2","id":"app-dev-context/developing-workflows","node":{"file_name":"developing-workflows.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/developing-workflows.md","id":"app-dev-context/developing-workflows","title":"How to develop a basic Workflow","description":"Workflows are the fundamental unit of a Temporal Application, and it all starts with the development of a Workflow Definition.","label":"Develop Workflows","tags":["guide-context"],"markdown_content":"Workflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/workflows#workflow-definition).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-develop-a-workflow-definition-in-go","node":{"file_name":"how-to-develop-a-workflow-definition-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-develop-a-workflow-definition-in-go.md","id":"go/how-to-develop-a-workflow-definition-in-go","title":"How to develop a Workflow Definition in Go","description":"In the Temporal Go SDK programming model, a Workflow Definition is an exportable function.","label":"Workflow Definition","tags":["developer-guide","go"],"markdown_content":"In the Temporal Go SDK programming model, a [Workflow Definition](/workflows#workflow-definition) is an exportable function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context) error {\n  // ...\n  return nil\n}\n```\n\nIn Go, by default, the Workflow Type name is the same as the function name.","is_empty":false}},{"lang":"java","id":"java/how-to-develop-a-workflow-definition-in-java","node":{"file_name":"how-to-develop-a-workflow-definition-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-develop-a-workflow-definition-in-java.md","id":"java/how-to-develop-a-workflow-definition-in-java","title":"How to develop a Workflow Definition in Java","description":"In the Temporal Java SDK programming model, a Workflow is a class which implements a Workflow interface.","label":"Workflow Definition","tags":["java","developer-guide"],"markdown_content":"In the Temporal Java SDK programming model, a Workflow definition comprises a Workflow interface annotated with `@WorkflowInterface` and a Workflow implementation that implements the Workflow interface.\n\nThe Workflow interface is a Java interface and is annotated with `@WorkflowInterface`.\nEach Workflow interface must have only one method annotated with `@WorkflowMethod`.\nThe method name can be used to denote the Workflow Type.\n\n```java\n// Workflow interface\n@WorkflowInterface\npublic interface YourWorkflow {\n\n    @WorkflowMethod\n    String yourWFMethod(Arguments args);\n}\n```\n\nHowever, when using dynamic Workflows, do not specify a `@WorkflowMethod`, and implement the `DynamicWorkflow` directly in the Workflow implementation code.\n\nThe `@WorkflowMethod` identifies the method that is the starting point of the Workflow Execution.\nThe Workflow Execution completes when this method completes.\n\nYou can create interface inheritance hierarchies to reuse components across other Workflow interfaces.\nThe interface inheritance approach does not apply to `@WorkflowMethod` annotations.\n\nA Workflow implementation implements a Workflow interface.\n\n```java\n// Define the Workflow implementation which implements our getGreeting Workflow method.\n  public static class GreetingWorkflowImpl implements GreetingWorkflow {\n      ...\n    }\n  }\n```\n\nTo call Activities in your Workflow, call the Activity implementation.\n\nUse `ExternalWorkflowStub` to start or send Signals from within a Workflow to other running Workflow Executions.\n\nYou can also invoke other Workflows as Child Workflows with `Workflow.newChildWorkflowStub()` or `Workflow.newUntypedChildWorkflowStub()` within a Workflow Definition.\n\nUse [`DynamicWorkflow`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/DynamicWorkflow.html) to implement Workflow Types dynamically.\nRegister a Workflow implementation type that extends `DynamicWorkflow` to implement any Workflow Type that is not explicitly registered with the Worker.\n\nThe dynamic Workflow interface is implemented with the `execute` method. This method takes in `EncodedValues` that are inputs to the Workflow Execution.\nThese inputs can be specified by the Client when invoking the Workflow Execution.\n\n```java\npublic class MyDynamicWorkflow implements DynamicWorkflow {\n   @Override\n    public Object execute(EncodedValues args) {\n    }\n}\n```","is_empty":false}},{"lang":"php","id":"php/how-to-develop-a-workflow-definition-in-php","node":{"file_name":"how-to-develop-a-workflow-definition-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-develop-a-workflow-definition-in-php.md","id":"php/how-to-develop-a-workflow-definition-in-php","title":"Develop a Workflow Definition in PHP","label":"Workflow Definition","markdown_content":"In PHP, a Workflow is a class method. Classes must implement interfaces that are annotated with `#[WorkflowInterface]`. The method that is the Workflow must be annotated with `#[WorkflowMethod]`.\n\n```php\nuse Temporal\\Workflow\\YourWorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n}\n```","is_empty":false}},{"lang":"python","id":"python/how-to-develop-a-workflow-definition-in-python","node":{"file_name":"how-to-develop-a-workflow-definition-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-develop-a-workflow-definition-in-python.md","id":"python/how-to-develop-a-workflow-definition-in-python","title":"How to develop a Workflow definition in Python","description":"Develop a Workflow definition","label":"Develop a Workflow definition","tags":["developer-guide","sdk","python"],"markdown_content":"Workflows in Python are defined as classes.\n\nSpecify the [`@workflow.defn`](https://python.temporal.io/temporalio.workflow.html#defn) decorator on the Workflow class to register a Workflow class.\n\nUse the [`@workflow.run`](https://python.temporal.io/temporalio.workflow.html#run) to mark the entry point method to be invoked. This must be set on one asynchronous method defined on the same class as `@workflow.defn`. Run methods have positional parameters.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-develop-a-workflow-definition-in-typescript","node":{"file_name":"how-to-develop-a-workflow-definition-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-develop-a-workflow-definition-in-typescript.md","id":"typescript/how-to-develop-a-workflow-definition-in-typescript","title":"How to develop a Workflow Definition in TypeScript","description":"Develop a Workflow Definition","label":"Develop a Workflow Definition","tags":["developer-guide","sdk","typescript"],"markdown_content":"Workflow Definitions are _just functions_, which can store state and orchestrate Activity Functions.\nThe following code snippet uses `proxyActivities` to schedule a `greet` Activity in the system to say hello.\n\nA Workflow Definition can have multiple parameters; however, we recommend using a single object parameter.\n\n```typescript\ntype ExampleArgs = {\n  name: string;\n};\n\nexport async function example(args: ExampleArgs): Promise<{greeting: string}> {\n  const greeting = await greet(args.name);\n  return {greeting};\n}\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/workflow-parameters","node":{"file_name":"workflow-parameters.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/workflow-parameters.md","id":"app-dev-context/workflow-parameters","title":"How to define Workflow parameters","description":"Temporal Workflows may have any number of custom parameters.","label":"Workflow parameters","tags":["guide-context"],"markdown_content":"Temporal Workflows may have any number of custom parameters.\nHowever, it is strongly recommended that objects are used as parameters, so that the object's individual fields may be altered without breaking the signature of the Workflow.\nAll Workflow Definition parameters must be serializable.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-define-workflow-parameters-in-go","node":{"file_name":"how-to-define-workflow-parameters-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-define-workflow-parameters-in-go.md","id":"go/how-to-define-workflow-parameters-in-go","title":"How to define Workflow parameters in Go","description":"A Go-based Workflow Definition must accept `workflow.Context` and may support multiple custom parameters.","label":"Workflow parameters","tags":["go","how-to"],"markdown_content":"The first parameter of a Go-based Workflow Definition must be of the [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context) type, as it is used by the Temporal Go SDK to pass around Workflow Execution context, and virtually all the Go SDK APIs that are callable from the Workflow require it.\nIt is acquired from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package.\n\n```go\nimport (\n   \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param string) error {\n // ...\n}\n```\n\nThe `workflow.Context` entity operates similarly to the standard `context.Context` entity provided by Go.\nThe only difference between `workflow.Context` and `context.Context` is that the `Done()` function, provided by `workflow.Context`, returns `workflow.Channel` instead of the standard Go `chan`.\n\nThe second parameter, `string`, is a custom parameter that is passed to the Workflow when it is invoked.\nA Workflow Definition may support multiple custom parameters, or none.\nThese parameters can be regular type variables or safe pointers.\nHowever, the best practice is to pass a single parameter that is of a `struct` type, so there can be some backward compatibility if new parameters are added.\n\n```go\ntype YourWorkflowParam struct {\n WorkflowParamFieldOne string\n WorkflowParamFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n // ...\n}\n```\n\nAll Workflow Definition parameters must be serializable, regardless of whether pointers or regular type values are used.\nParameters cant be channels, functions, variadic, or unsafe pointers.","is_empty":false}},{"lang":"java","id":"java/how-to-define-workflow-parameters-in-java","node":{"file_name":"how-to-define-workflow-parameters-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-define-workflow-parameters-in-java.md","id":"java/how-to-define-workflow-parameters-in-java","title":"How to define Workflow Parameters in Java","description":"A method annotated with `@WorkflowMethod` can have any number of parameters.","label":"Workflow parameters","tags":["developer-guide","java"],"markdown_content":"A method annotated with `@WorkflowMethod` can have any number of parameters.\n\nWe recommend passing a single parameter that contains all the input fields to allow for adding fields in a backward-compatible manner.\n\nNote that all inputs should be serializable by the default Jackson JSON Payload Converter.\n\nYou can create a custom object and pass it to the Workflow method, as shown in the following example.\n\n```java\n//...\n@WorkflowInterface\npublic interface YourWorkflow {\n    @WorkflowMethod\n    String yourWFMethod(CustomObj customobj);\n// ...\n}\n```","is_empty":false}},{"lang":"php","id":"php/how-to-define-workflow-parameters-in-php","node":{"file_name":"how-to-define-workflow-parameters-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-define-workflow-parameters-in-java.md","id":"php/how-to-define-workflow-parameters-in-php","title":"How to define Workflow Parameters in PHP","description":"A method annotated with `#[WorkflowMethod]` can have any number of parameters.","label":"Workflow parameters","tags":["developer-guide","php"],"markdown_content":"A method annotated with `#[WorkflowMethod]` can have any number of parameters.\n\nWe recommend passing a single parameter that contains all the input fields to allow for adding fields in a backward-compatible manner.\n\nNote that all inputs should be serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\nYou can create a custom object and pass it to the Workflow method, as shown in the following example:\n\n```php\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n}\n```","is_empty":false}},{"lang":"python","id":"python/how-to-define-workflow-parameters-in-python","node":{"file_name":"how-to-define-workflow-parameters-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-define-workflow-parameters-in-python.md","id":"python/how-to-define-workflow-parameters-in-python","title":"How to define Workflow parameters","description":"Define Workflow parameters","label":"Define Workflow parameters","tags":["developer-guide","sdk","python"],"markdown_content":"Workflow parameters are the method parameters of the singular method decorated with `@workflow.run`.\nThese can be any data type Temporal can convert, including ['dataclasses'](https://docs.python.org/3/library/dataclasses.html) when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single `dataclass` parameter containing all input fields.\nFor example:\n\n```python\n@dataclass\nclass YourParams:\n    your_int_param: int\n    your_str_param: str\n\n\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, params: YourParams) -> None:\n        ...\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-define-workflow-parameters-in-typescript","node":{"file_name":"how-to-define-workflow-parameters-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-define-workflow-parameters-in-typescript.md","id":"typescript/how-to-define-workflow-parameters-in-typescript","title":"How to define Workflow parameters in TypeScript","description":"Define Workflow parameters","label":"Define Workflow parameters","tags":["developer-guide","sdk","typescript"],"markdown_content":"You can define and pass parameters in your Workflow. In this example, you define your arguments in your `client.ts` file and pass those parameters to `workflow.ts` through your Workflow function.\n\nStart a Workflow with the parameters that are in the `client.ts` file. In this example we set the `name` parameter to `Temporal` and `born` to `2019`. Then set the Task Queue and Workflow Id.\n\n`client.ts`\n\n```typescript\nimport { example } from './workflows';\n\n...\nawait client.start(example, {\n  args: [{ name: 'Temporal', born: 2019 }],\n  taskQueue: 'your-queue',\n  workflowId: 'business-meaningful-id',\n});\n```\n\nIn `workflows.ts` define the type of the parameter that the Workflow function takes in. The interface `ExampleParam` is a name we can now use to describe the requirement in the previous example. It still represents having the two properties called `name` and `born` that is of the type `string`. Then define a function that takes in a parameter of the type `ExampleParam` and return a `Promise<string>`. The `Promise` object represents the eventual completion, or failure, of `await client.start()` and its resulting value.\n\n```ts\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({name, born}: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/workflow-return-values","node":{"file_name":"workflow-return-values.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/workflow-return-values.md","id":"app-dev-context/workflow-return-values","title":"How to define Workflow return parameters","description":"Workflow return values must also be serializable.","label":"Workflow return values","tags":["guide-context"],"markdown_content":"Workflow return values must also be serializable.\nReturning results, returning errors, or throwing exceptions is fairly idiomatic in each language that is supported.\nHowever, Temporal APIs that must be used to get the result of a Workflow Execution will only ever receive one of either the result or the error.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-define-workflow-return-values-in-go","node":{"file_name":"how-to-define-workflow-return-values-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-define-workflow-return-values-in-go.md","id":"go/how-to-define-workflow-return-values-in-go","title":"How to define Workflow return values in Go","description":"A Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.","label":"Workflow return values","tags":["go","how-to"],"markdown_content":"A Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.\nAgain, the best practice here is to use a `struct` type to hold all custom values.\n\n```go\ntype YourWorkflowResponse struct{\n WorkflowResultFieldOne string\n WorkflowResultFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n if err != nil {\n   return \"\", err\n }\n responseVar := YourWorkflowResponse {\n   FieldOne: \"super\",\n   FieldTwo: 1,\n }\n return responseVar, nil\n}\n```\n\nA Workflow Definition written in Go can return both a custom value and an error.\nHowever, it's not possible to receive both a custom value and an error in the calling process, as is normal in Go.\nThe caller will receive either one or the other.\nReturning a non-nil `error` from a Workflow indicates that an error was encountered during its execution and the Workflow Execution should be terminated, and any custom return values will be ignored by the system.","is_empty":false}},{"lang":"java","id":"java/how-to-define-workflow-return-values-in-java","node":{"file_name":"how-to-define-workflow-return-values-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-define-workflow-return-values-in-java.md","id":"java/how-to-define-workflow-return-values-in-java","title":"How to define Workflow return values in Java","description":"Workflow method arguments and return values must be serializable and deserializable using the provided `DataConverter`.","label":"Workflow return values","tags":["developer-guide","java"],"markdown_content":"Workflow method arguments and return values must be serializable and deserializable using the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.11.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicWorkflow` can return type Object.\nEnsure that your Client can handle an Object type return or is able to convert the Object type response.\n\nRelated references:\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>","is_empty":false}},{"lang":"php","id":"php/how-to-define-workflow-return-values-in-php","node":{"file_name":"how-to-define-workflow-return-values-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-define-workflow-return-values-in-php.md","id":"php/how-to-define-workflow-return-values-in-php","title":"Define Workflow return values in PHP","label":"Workflow return values","markdown_content":"A Workflow method returns a Generator.\nTo properly typecast the Workflow's return value in the client code, use the `#[ReturnType()]` annotation.\n\n```php\n#[YourWorkflowInterface]\ninterface FileProcessingWorkflow {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n}\n```","is_empty":false}},{"lang":"python","id":"python/how-to-define-workflow-return-values-in-python","node":{"file_name":"how-to-define-workflow-return-values-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-define-workflow-return-values-in-python.md","id":"python/how-to-define-workflow-return-values-in-python","title":"How to define Workflow return values","description":"Define Workflow return values","label":"Define Workflow return values","tags":["developer-guide","sdk","python"],"markdown_content":"A Workflow Execution can return the results of a Workflow.\n\nTo return the results of a Workflow Execution, use either [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) asynchronous methods.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n\nresult = await handle.result()\n```\n\n`execute_workflow()` is a helper function for `start_workflow()` and `handle.result()`.\n\n```python\nhandle = await client.execute_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-define-workflow-return-values-in-typescript","node":{"file_name":"how-to-define-workflow-return-values-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-define-workflow-return-values-in-typescript.md","id":"typescript/how-to-define-workflow-return-values-in-typescript","title":"How to define Workflow return values in TypeScript","description":"Define Workflow return values","label":"Define Workflow return values","tags":["developer-guide","sdk","typescript"],"markdown_content":"To return a value of the Workflow function, use `Promise<something>`. The `Promise` is used to make asynchronous calls and comes with guarantees.\n\nThe following example uses a `Promise<string>` to eventually return a `name` and `born` parameter.\n\n```typescript\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({name, born}: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```","is_empty":false}}]},{"type":"h3","id":"app-dev-context/customize-workflow-type","node":{"file_name":"customize-workflow-type.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/customize-workflow-type.md","id":"app-dev-context/customize-workflow-type","title":"How to customize your Workflow Type","description":"You can set a custom name for your Workflow Type.","label":"Workflow Type","tags":["guide-context"],"markdown_content":"Workflows have a Type that are referred to as the Workflow name.\n\nThe following examples demonstrate how to set a custom name for your Workflow Type.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-customize-workflow-type-in-go","node":{"file_name":"how-to-customize-workflow-type-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-customize-workflow-type-in-go.md","id":"go/how-to-customize-workflow-type-in-go","title":"How to customize Workflow Type in Go","description":"To customize the Workflow Type set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.","label":"Customize Workflow Type","tags":["developer-guide","go"],"markdown_content":"To customize the Workflow Type, set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.\n\n- Type: `string`\n- Default: function name\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := workflow.RegisterOptions{\n  Name: \"YourWorkflowName\",\n  // ...\n}\nw.RegisterWorkflowWithOptions(YourWorkflowDefinition, registerOptions)\n// ...\n```","is_empty":false}},{"lang":"java","id":"java/how-to-customize-workflow-type-in-java","node":{"file_name":"how-to-customize-workflow-type-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-customize-workflow-type-in-java.md","id":"java/how-to-customize-workflow-type-in-java","title":"How to customize Workflow Type in Java","description":"The Workflow Type defaults to the short name of the Workflow interface, and can be customized with the `name` parameter.","label":"Customize Workflow Type","tags":["developer-guide","java"],"markdown_content":"The Workflow Type defaults to the short name of the Workflow interface.\nIn the following example, the Workflow Type defaults to `NotifyUserAccounts`.\n\n```java\n  @WorkflowInterface\n\n  public interface NotifyUserAccounts {\n    @WorkflowMethod\n    void notify(String[] accountIds);\n}\n```\n\nTo overwrite this default naming and assign a custom Workflow Type, use the `@WorkflowMethod` annotation with the `name` parameter.\nIn the following example, the Workflow Type is set to `Abc`.\n\n```java\n@WorkflowInterface\n\n  public interface NotifyUserAccounts {\n  @WorkflowMethod(name = \"Abc\")\n  void notify(String[] accountIds);\n  }\n```\n\nWhen you set the Workflow Type this way, the value of the `name` parameter does not have to start with an uppercase letter.","is_empty":false}},{"lang":"php","id":"none"},{"lang":"python","id":"python/how-to-customize-workflow-type-in-python","node":{"file_name":"how-to-customize-workflow-type-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-customize-workflow-type-in-python.md","id":"python/how-to-customize-workflow-type-in-python","title":"How to customize Workflow types in Python","description":"Customize Workflow types.","label":"Customize Workflow types","tags":["developer-guide","sdk","python"],"markdown_content":"You can customize the Workflow name with a custom name in the decorator argument. For example, `@workflow.defn(name=\"your-workflow-name\")`. If the name parameter is not specified, the Workflow name defaults to the function name.\n\n```python\n@workflow.defn(name=\"your-workflow-name\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-customize-workflow-type-in-typescript","node":{"file_name":"how-to-customize-workflow-type-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-customize-workflow-type-in-typescript.md","id":"typescript/how-to-customize-workflow-type-in-typescript","title":"How to customize Workflow Type in TypeScript","description":"Customize Workflow Type","label":"Customize Workflow Type","tags":["developer-guide","typescript"],"markdown_content":"The Workflow Type is the Workflow function name.\nIn the following example, the Type is `helloWorld`.\n\n<!--SNIPSTART typescript-workflow-type -->\n<!--SNIPEND-->","is_empty":false}}]},{"type":"h3","id":"app-dev-context/workflow-logic-requirements","node":{"file_name":"workflow-logic-requirements.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/workflow-logic-requirements.md","id":"app-dev-context/workflow-logic-requirements","title":"How develop Workflow logic","description":"Workflow logic is constrained by deterministic execution requirements.","label":"Workflow logic requirements","tags":["guide-context"],"markdown_content":"Workflow logic is constrained by [deterministic execution requirements](/concepts/what-is-a-workflow-definition/#deterministic-constraints).\nTherefore, each language is limited to the use of certain idiomatic techniques.\nHowever, each Temporal SDK provides a set of APIs that can be used inside your Workflow to interact with external (to the Workflow) application code.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-handle-workflow-logic-requirements-in-go","node":{"file_name":"how-to-handle-workflow-logic-requirements-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-handle-workflow-logic-requirements-in-go.md","id":"go/how-to-handle-workflow-logic-requirements-in-go","title":"How to handle Workflow logic requirements in Go","description":"todo","label":"Workflow logic requirements","tags":["go","how-to"],"markdown_content":"In Go, Workflow Definition code cannot directly do the following:\n\n- Iterate over maps using `range`, because with `range` the order of the map's iteration is randomized.\n  Instead you can collect the keys of the map, sort them, and then iterate over the sorted keys to access the map.\n  This technique provides deterministic results.\n  You can also use a Side Effect or an Activity to process the map instead.\n- Call an external API, conduct a file I/O operation, talk to another service, etc. (Use an Activity for these.)\n\nThe Temporal Go SDK has APIs to handle equivalent Go constructs:\n\n- `workflow.Now()` This is a replacement for `time.Now()`.\n- `workflow.Sleep()` This is a replacement for `time.Sleep()`.\n- `workflow.GetLogger()` This ensures that the provided logger does not duplicate logs during a replay.\n- `workflow.Go()` This is a replacement for the `go` statement.\n- `workflow.Channel` This is a replacement for the native `chan` type.\n  Temporal provides support for both buffered and unbuffered channels.\n- `workflow.Selector` This is a replacement for the `select` statement. Learn more on the [Go SDK Selectors](/go/selectors) page\n- `workflow.Context` This is a replacement for `context.Context`. Learn more on the [Go SDK Context Propagation](/go/tracing) page.","is_empty":false}},{"lang":"java","id":"java/how-to-handle-workflow-logic-requirements-in-java","node":{"file_name":"how-to-handle-workflow-logic-requirements-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-handle-workflow-logic-requirements-in-java.md","id":"java/how-to-handle-workflow-logic-requirements-in-java","title":"How to handle Workflow Logic Requirements in Java","description":"When defining Workflows using the Temporal Java SDK, the Workflow code must be written to execute effectively once and to completion.","label":"Workflow logic requirements","tags":["developer-guide","java"],"markdown_content":"When defining Workflows using the Temporal Java SDK, the Workflow code must be written to execute effectively once and to completion.\n\nThe following constraints apply when writing Workflow Definitions:\n\n- Do not use mutable global variables in your Workflow implementations.\n  This will ensure that multiple Workflow instances are fully isolated.\n- Your Workflow code must be deterministic.\n  Do not call non-deterministic functions (such as non-seeded random or `UUID.randomUUID()`) directly from the Workflow code.\n  The Temporal SDK provides specific API for calling non-deterministic code in your Workflows.\n- Do not use programming language constructs that rely on system time.\n  For example, only use `Workflow.currentTimeMillis()` to get the current time inside a Workflow.\n- Do not use native Java `Thread` or any other multi-threaded classes like `ThreadPoolExecutor`.\n  Use `Async.function` or `Async.procedure`, provided by the Temporal SDK, to execute code asynchronously.\n- Do not use synchronization, locks, or other standard Java blocking concurrency-related classes besides those provided by the Workflow class.\n  There is no need for explicit synchronization because multi-threaded code inside a Workflow is executed one thread at a time and under a global lock.\n  - Call `Workflow.sleep` instead of `Thread.sleep`.\n  - Use `Promise` and `CompletablePromise` instead of `Future` and `CompletableFuture`.\n  - Use `WorkflowQueue` instead of `BlockingQueue`.\n- Use `Workflow.getVersion` when making any changes to the Workflow code.\n  Without this, any deployment of updated Workflow code might break already running Workflows.\n- Do not access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n- Use `DynamicWorkflow` when you need a default Workflow that can handle all Workflow Types that are not registered with a Worker.\n  A single implementation can implement a Workflow Type which by definition is dynamically loaded from some external source.\n  All standard `WorkflowOptions` and determinism rules apply to Dynamic Workflow implementations.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>","is_empty":false}},{"lang":"php","id":"php/how-to-handle-workflow-logic-requirements-in-php","node":{"file_name":"how-to-handle-workflow-logic-requirements-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-handle-workflow-logic-requirements-in-php.md","id":"php/how-to-handle-workflow-logic-requirements-in-php","title":"How to handle Workflow logic requirements in PHP","label":"Activity Execution","markdown_content":"\\*\\*Temporal uses the [Microsoft Azure Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover the state of a Workflow object including its local variable values.\n\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nWhen replaying, side effects (such as Activity invocations) are ignored because they are already recorded in the Workflow event history.\nWhen writing Workflow logic, the replay is not visible, so the code should be written since it executes only once.\nThis design puts the following constraints on the Workflow implementation:\n\n- Do not use any mutable global variables because multiple instances of Workflows are executed in parallel.\n- Do not call any non-deterministic functions like non seeded random or `UUID` directly from the Workflow code.\n\nAlways do the following in the Workflow implementation code:\n\n- Dont perform any IO or service calls as they are not usually deterministic. Use Activities for this.\n- Only use `Workflow::now()` to get the current time inside a Workflow.\n- Call `yield Workflow::timer()` instead of `sleep()`.\n- Do not use any blocking SPL provided by PHP (i.e. `fopen`, `PDO`, etc) in **Workflow code**.\n- Use `yield Workflow::getVersion()` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already open Workflows.\n- Dont access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\nWorkflow method arguments and return values are serializable to a byte array using the provided [DataConverter](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html) interface.\nThe default implementation uses JSON serializer, but you can use any alternative serialization mechanism.\n\nMake sure to annotate your `WorkflowMethod` using `ReturnType` to specify concrete return type.\n\n> You can not use the default return type declaration as Workflow methods are generators.\n\nThe values passed to Workflows through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to Workflow workers with every event that the Workflow logic needs to process.\nA large execution history can thus adversely impact the performance of your Workflow.\nTherefore, be mindful of the amount of data that you transfer via Activity invocation parameters or return values.\nOtherwise, no additional limitations exist on Activity implementations.\\*\\*","is_empty":false}},{"lang":"python","id":"python/how-to-handle-workflow-logic-requirements-in-python","node":{"file_name":"how-to-handle-workflow-logic-requirements-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-handle-workflow-logic-requirements-in-python.md","id":"python/how-to-handle-workflow-logic-requirements-in-python","title":"How to handle Workflow logic requirements in Python","description":"Handle Workflow logic requirements","label":"Handle Workflow logic requirements","tags":["developer-guide","sdk","python"],"markdown_content":"Workflow code must be deterministic. This means:\n\n- no threading\n- no randomness\n- no external calls to processes\n- no network I/O\n- no global state mutation\n- no system date or time\n\nAll API safe for Workflows used in the [`temporalio.workflow`](https://python.temporal.io/temporalio.workflow.html) must run in the implicit [`asyncio` event loop](https://docs.python.org/3/library/asyncio-eventloop.html) and be _deterministic_.","is_empty":false}},{"lang":"typescript","id":"none"}]},{"type":"h2","id":"app-dev-context/developing-activities","node":{"file_name":"developing-activities.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/developing-activities.md","id":"app-dev-context/developing-activities","title":"How to develop a basic Activity","description":"One of the primary things that Workflows do is orchestrate the execution of Activities.","label":"Develop Activities","tags":["guide-context"],"markdown_content":"One of the primary things that Workflows do is orchestrate the execution of Activities.\nActivities are normal function/method executions that can interact with the world.\nFor the Workflow to be able to execute the Activity, we must define the [Activity Definition](/activities#activity-definition).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-develop-an-activity-definition-in-go","node":{"file_name":"how-to-develop-an-activity-definition-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-develop-an-activity-definition-in-go.md","id":"go/how-to-develop-an-activity-definition-in-go","title":"How to develop an Activity Definition in Go","description":"In the Temporal Go SDK programming model, an Activity Definition is an exportable function or `stuct` method.","label":"Activity Definition","tags":["developer-guide","go"],"markdown_content":"In the Temporal Go SDK programming model, an Activity Definition is an exportable function or a `struct` method.\n\n**Function**\n\n```go\n// basic function signature\nfunc YourActivityDefinition(ctx context.Context) error {\n // ...\n return nil\n}\n\n// with parameters and return values\nfunc SimpleActivity(ctx context.Context, value string) (string, error)\n```\n\n**Struct method**\n\n```go\ntype YourActivityStruct struct {\n ActivityFieldOne string\n ActivityFieldTwo int\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinition(ctx context.Context) error {\n // ...\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinitionTwo(ctx context.Context) error {\n // ...\n}\n```\n\nAn _Activity struct_ can have more than one method, with each method acting as a separate Activity Type.\nActivities written as struct methods can use shared struct variables, such as:\n\n- an application level DB pool\n- client connection to another service\n- reusable utilities\n- any other expensive resources that you only want to initialize once per process\n\nBecause this is such a common need, the rest of this guide shows Activities written as `struct` methods.","is_empty":false}},{"lang":"java","id":"java/how-to-develop-an-activity-definition-in-java","node":{"file_name":"how-to-develop-an-activity-definition-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-develop-an-activity-definition-in-java.md","id":"java/how-to-develop-an-activity-definition-in-java","title":"How to develop an Activity Definition in Java","description":"In the Temporal Java SDK programming model, Activities are classes which implement the Activity Interface.","label":"Activity Definition","tags":["java","developer-guide"],"markdown_content":"An [Activity Definition](/activities#) is a combination of the Temporal Java SDK [Activity](https://www.javadoc.io/static/io.temporal/temporal-sdk/0.19.0/io/temporal/activity/Activity.html) Class implementing a specially annotated interface.\n\nAn Activity interface is annotated with `@ActivityInterface` and an Activity implementation implements this Activity interface.\nTo handle Activity types that do not have an explicitly registered handler, you can directly implement a dynamic Activity.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    String composeGreeting(String greeting, String language);\n}\n```\n\nEach method defined in the Activity interface defines a separate Activity method.\nYou can annotate each method in the Activity interface with the `@ActivityMethod` annotation, but this is completely optional.\nThe following example uses the `@ActivityMethod` annotation for the method defined in the previous example.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nAn Activity implementation is a Java class that implements an Activity annotated interface.\n\n```java\n// Implementation for the GreetingActivities interface example from in the previous section\n static class GreetingActivitiesImpl implements GreetingActivities {\n    @Override\n    public String composeGreeting(String greeting, String name) {\n      return greeting + \" \" + name + \"!\";\n    }\n  }\n```\n\nUse `DynamicActivity` to implement any number of Activity types dynamically.\nWhen an Activity implementation that extends `DynamicActivity` is registered, it is called for any Activity type invocation that doesn't have an explicitly registered handler.\n\nThe dynamic Activity interface is implemented with the `execute` method, as shown in the following example.\n\n```java\n // Dynamic Activity implementation\n  public static class DynamicGreetingActivityImpl implements DynamicActivity {\n    @Override\n    public Object execute(EncodedValues args) {\n      String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n      return activityType\n          + \": \"\n          + args.get(0, String.class)\n          + \" \"\n          + args.get(1, String.class)\n          + \" from: \"\n          + args.get(2, String.class);\n    }\n  }\n```\n\nUse `Activity.getExecutionContext()` to get information about the Activity type that should be implemented dynamically.","is_empty":false}},{"lang":"php","id":"php/how-to-develop-an-activity-definition-in-php","node":{"file_name":"how-to-develop-an-activity-definition-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-develop-an-activity-definition-in-php.md","id":"php/how-to-develop-an-activity-definition-in-php","title":"Develop an Activity Definition in PHP","label":"Activity Definition","markdown_content":"Activities are defined as methods of a plain PHP interface annotated with `#[YourActivityInterface]`.\n(You can also use PHP 8 attributes in PHP 7.)\n\nFollowing is an example of an interface that defines four Activities:\n\n```php\n#[YourActivityInterface]\n// Defining an interface for the activities.\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName): void;\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName): void;\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName): void;\n}\n```\n\n**How to customize an Activity type**\n\nWe recommend to use a single value type argument for Activity methods.\nIn this way, adding new arguments as fields to the value type is a backward-compatible change.\n\nAn optional `#[ActivityMethod]` annotation can be used to override a default Activity name.\n\nYou can define your own prefix for all Activity names by adding the `prefix` option to the `YourActivityInterface` annotation.\n(The default prefix is empty.)\n\n```php\n#[YourActivityInterface(\"file_activities.\")]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName);\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName);\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName);\n}\n```\n\nThe `#[YourActivityInterface(\"file_activities.\")]` is an annotation that tells the PHP SDK to generate a class to implement the `FileProcessingActivities` interface. The functions define Activites that are used in the Workflow.","is_empty":false}},{"lang":"python","id":"python/how-to-develop-an-activity-definition-in-python","node":{"file_name":"how-to-develop-an-activity-definition-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-develop-an-activity-definition-in-python.md","id":"python/how-to-develop-an-activity-definition-in-python","title":"How to develop an Activity Definition in Python","description":"Develop an Activity Definition","label":"Develop an Activity Definition","tags":["developer-guide","sdk","python"],"markdown_content":"You can develop an Activity Definition by using the [`@activity.defn`](https://python.temporal.io/temporalio.activity.html#defn) decorator.\n\n```python\n@activity.defn\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\nYou can register the function as an Activity with a custom name through a decorator argument. For example, `@activity.defn(name=\"your-activity\")`.\n\n```python\n@activity.defn(name=\"your-activity\")\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n**Types of Activities**\n\nThe following lists the different types of _Activity callables_:\n\n- [Asynchronous Activities](#asynchronous-activities)\n- [Synchronous Activities](#synchronous-activities)\n\n:::note Positional arguments\n\nOnly positional arguments are supported by Activities.\n\n:::\n\n##### [Asynchronous Activities](#asynchronous-activities)\n\nAsynchronous Activities (recommended) are functions using `async def`. When using asynchronous Activities there aren't any additional Worker parameters needed.\n\nCancellation for asynchronous activities is done by means of the\n[`asyncio.Task.cancel`](https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel) operation. This means that `asyncio.CancelledError` will be raised (and can be caught, but it is not recommended).\n\nAn Activity must Heartbeat to receive cancellation.\n\n##### [Synchronous Activities](#synchronous-activities)\n\nThe [`activity_executor`](https://python.temporal.io/temporalio.worker.workerconfig#activity_exector) Worker parameter must be set with a [`concurrent.futures.Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor) instance to use for executing the Activities.\n\nCancellation for synchronous Activities is done in the background and the Activity must choose to listen for it and react appropriately.\n\nAn Activity must Heartbeat to receive cancellation.\n\n- ###### [Synchronous Multithreaded Activities](#synchronous-multithreaded-activities)\n\nMultithreaded Activities are functions that use `activity_executor` set to an instance of [`concurrent.futures.ThreadPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor).\n\nBesides `activity_executor`, no other additional Worker parameters are required for synchronous multithreaded Activities.\n\n- ###### [Synchronous Multiprocess/Other Activities](#synchronous-multiprocess)\n\nIf `activity_executor` is set to an instance of [`concurrent.futures.Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor) that is not `concurrent.futures.ThreadPoolExecutor`, then the synchronous activities are considered multiprocess/other activities.\n\nThese require special primitives for heartbeating and cancellation. The `shared_state_manager` Worker parameter must be set to an instance of [`worker.SharedStateManager`](https://python.temporal.io/temporalio.worker.sharedstatemanager). The most common implementation can be created by passing a [`multiprocessing.managers.SyncManager`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.SyncManager) (for example, as a result of [`multiprocessing.managers.Manager()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Manager)) to [`worker.SharedStateManager.create_from_multiprocessing()`](https://python.temporal.io/temporalio.worker.sharedstatemanager#create_from_multiprocessing).","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-develop-an-activity-definition-in-typescript","node":{"file_name":"how-to-develop-an-activity-definition-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-develop-an-activity-definition-in-typescript.md","id":"typescript/how-to-develop-an-activity-definition-in-typescript","title":"How to develop an Activity Definition in TypeScript","description":"Develop an Activity Definition","label":"Develop an Activity Definition","tags":["developer-guide","sdk","typescript"],"markdown_content":"- Activities execute in the standard Node.js environment.\n- Activities cannot be in the same file as Workflows and must be separately registered.\n- Activities may be retried repeatedly, so you may need to use idempotency keys for critical side effects.\n\nActivities are _just functions_. The following is an Activity that accepts a string parameter and returns a string.\n\n<!--SNIPSTART typescript-activity-fn -->\n<!--SNIPEND-->","is_empty":false}}]},{"type":"h3","id":"app-dev-context/activity-parameters","node":{"file_name":"activity-parameters.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/activity-parameters.md","id":"app-dev-context/activity-parameters","title":"How to develop Activity Parameters","description":"When it comes to your application datathat is, data that is serialized and encoded into a Payloadwe recommend that you use a single object as an argument that wraps the application data passed to Activities.","label":"Activity Parameters","tags":["guide-context"],"markdown_content":"There is no explicit limit to the total number of parameters that an [Activity Definition](/activities#activity-definition) may support.\nHowever, there is a limit of the total size of the data ends up encoded into a gRPC message Payload.\n\nA single argument is limited to a maximum size of 2 MB.\nAnd the total size of a gRPC message, which includes all the arguments, is limited to a maximum of 4 MB.\n\nAlso, keep in mind that all Payload data is recorded in the [Workflow Execution Event History](/workflows#event-history) and large Event Histories can affect Worker performance.\nThis is because the entire Event History could be transferred to a Worker Process with a [Workflow Task](/tasks#workflow-task).\n\n<!--TODO link to gRPC limit section when available -->\n\nSome SDKs require that you pass context objects, others do not.\nWhen it comes to your application datathat is, data that is serialized and encoded into a Payloadwe recommend that you use a single object as an argument that wraps the application data passed to Activities.\nThis is so that you can change what data is passed to the Activity without breaking a function or method signature.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-define-activity-parameters-in-go","node":{"file_name":"how-to-define-activity-parameters-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-define-activity-parameters-in-go.md","id":"go/how-to-define-activity-parameters-in-go","title":"How to define Activity Parameters in Go","description":"The only required parameter is `context.Context`, but Activities can support many custom parameters.","label":"Activity Parameters","tags":["developer-guide","go"],"markdown_content":"The first parameter of an Activity Definition is `context.Context`.\nThis parameter is optional for an Activity Definition, though it is recommended, especially if the Activity is expected to use other Go SDK APIs.\n\nAn Activity Definition can support as many other custom parameters as needed.\nHowever, all parameters must be serializable (parameters cant be channels, functions, variadic, or unsafe pointers), and it is recommended to pass a single struct that can be updated later.\n\n```go\ntype YourActivityParam struct {\n ActivityParamFieldOne string\n ActivityParamFieldTwo int\n}\n\ntype YourActivityStruct struct {\n // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-define-activity-parameters-in-java","node":{"file_name":"how-to-define-activity-parameters-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-define-activity-parameters-in-java.md","id":"java/how-to-define-activity-parameters-in-java","title":"How to define Activity paramters in Java","description":"An Activity interface can have any number of parameters.","label":"Activity parameters","tags":["developer-guide","java"],"markdown_content":"An Activity interface can have any number of parameters.\nAll inputs should be serializable by the default Jackson JSON Payload Converter.\n\nWhen implementing Activities, be mindful of the amount of data that you transfer using the Activity invocation parameters or return values as these are recorded in the Workflow Execution Events History.\nLarge Events Histories can adversely impact performance.\n\nYou can create a custom object, and pass it to the Activity interface, as shown in the following example.\n\n```java\n@ActivityInterface\npublic interface YourActivities {\n    String getCustomObject(CustomObj customobj);\n    void sendCustomObject(CustomObj customobj, String abc);\n}\n```\n\nThe `execute` method in the dynamic Activity interface implementation takes in `EncodedValues` that are inputs to the Activity Execution, as shown in the following example.\n\n```java\n // Dynamic Activity implementation\n  public static class DynamicActivityImpl implements DynamicActivity {\n    @Override\n    public Object execute(EncodedValues args) {\n      String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n      return activityType\n          + \": \"\n          + args.get(0, String.class)\n          + \" \"\n          + args.get(1, String.class)\n          + \" from: \"\n          + args.get(2, String.class);\n    }\n  }\n```\n\nFor more details, see [Dynamic Activity Reference](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/DynamicActivity.html).","is_empty":false}},{"lang":"php","id":"php/how-to-define-activity-parameters-in-php","node":{"file_name":"how-to-define-activity-parameters-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-define-activity-parameters-in-php.md","id":"php/how-to-define-activity-parameters-in-php","title":"Define Activity parameters in PHP","label":"Activity parameters","markdown_content":"Each method defines a single Activity type.\nA single Workflow can use more than one Activity interface and call more than one Activity method from the same interface.\n\nThe only requirement is that Activity method arguments and return values are serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.","is_empty":false}},{"lang":"python","id":"python/how-to-define-activity-parameters-in-python","node":{"file_name":"how-to-define-activity-parameters-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-define-activity-parameters-in-python.md","id":"python/how-to-define-activity-parameters-in-python","title":"How to define Activity Parameters in Python","description":"Activities can support many custom parameters.","label":"Activity Parameters","tags":["developer-guide","python"],"markdown_content":"Activity parameters are the function parameters of the function decorated with `@activity.defn`.\nThese can be any data type Temporal can convert, including ['dataclasses'](https://docs.python.org/3/library/dataclasses.html) when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single `dataclass` parameter containing all input fields.\nFor example:\n\n```python\n@dataclass\nclass YourParams:\n    your_int_param: int\n    your_str_param: str\n\n\n@activity.defn\nasync def your_activity(params: YourParams) -> None:\n    ...\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-define-activity-parameters-in-typescript","node":{"file_name":"how-to-define-activity-parameters-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-define-activity-parameters-in-typescript.md","id":"typescript/how-to-define-activity-parameters-in-typescript","title":"How to define Activity Parameters in TypeScript","description":"Activity Parameters.","label":"Activity Parameters","tags":["developer-guide","go"],"markdown_content":"This Activity takes a single name parameter of the type string.\n\n<!--SNIPSTART typescript-activity-fn -->\n<!--SNIPEND-->","is_empty":false}}]},{"type":"h3","id":"app-dev-context/activity-return-values","node":{"file_name":"activity-return-values.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/activity-return-values.md","id":"app-dev-context/activity-return-values","title":"How to define Activity return values","description":"All data returned from an Activity must be serializable.","label":"Activity return values","tags":["guide-context"],"markdown_content":"All data returned from an Activity must be serializable.\n\nThere is no explicit limit to the amount of data that can be returned by an Activity, but keep in mind that all return values are recorded in a [Workflow Execution Event History](/workflows#event-history).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-define-activity-return-values-in-go","node":{"file_name":"how-to-define-activity-return-values-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-define-activity-return-values-in-go.md","id":"go/how-to-define-activity-return-values-in-go","title":"How to define Activity return values in Go","description":"A Go-based Activity Definition can return either just an `error` or a `customValue, error` combination.","label":"Activity return values","tags":["developer-guide","go"],"markdown_content":"A Go-based Activity Definition can return either just an `error` or a `customValue, error` combination (same as a Workflow Definition).\nYou may wish to use a `struct` type to hold all custom values, just keep in mind they must all be serializable.\n\n```go\ntype YourActivityResult struct{\n  ActivityResultFieldOne string\n  ActivityResultFieldTwo int\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResult, error) {\n  // ...\n  result := YourActivityResult {\n    ActivityResultFieldOne: a.ActivityFieldOne,\n    ActivityResultFieldTwo: a.ActivityFieldTwo,\n  }\n  return result, nil\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-define-activity-return-values-in-java","node":{"file_name":"how-to-define-activity-return-values-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-define-activity-return-values-in-java.md","id":"java/how-to-define-activity-return-values-in-java","title":"How to define Activity return values in Java","description":"Activity return values must be serializable and deserializable by the provided `DataConverter`","label":"Activity return values","tags":["developer-guide","java"],"markdown_content":"Activity return values must be serializable and deserializable by the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.11.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicActivity` can return type Object.\nEnsure that your Workflow or Client can handle an Object type return or is able to convert the Object type response.\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>","is_empty":false}},{"lang":"php","id":"php/how-to-define-activity-return-values-in-php","node":{"file_name":"how-to-define-activity-return-values-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-define-activity-return-values-in-php.md","id":"php/how-to-define-activity-return-values-in-php","title":"How to define Activity return values in PHP","description":"Activity return values must be serializable and deserializable by the provided `DataConverter`","label":"Activity return values","tags":["developer-guide","php"],"markdown_content":"Return values must be serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\nThus, you can return both primitive types:\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): string\n    {\n        return $greeting . ' ' . $name;\n    }\n}\n```\n\nAnd objects:\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): Greeting\n    {\n        return new Greeting($greeting, $name);\n    }\n}\n```","is_empty":false}},{"lang":"python","id":"python/how-to-define-activity-return-values-in-python","node":{"file_name":"how-to-define-activity-return-values-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-define-activity-return-values-in-python.md","id":"python/how-to-define-activity-return-values-in-python","title":"How to define Activity return values in Python","description":"Activity return values","label":"Activity return values","tags":["developer-guide","python"],"markdown_content":"An ActivityExecution can return inputs and other Activity values.\n\nThe following example defines an Activity that takes a string as input and returns a string.\n\n```python\n@activity.defn\nasync def say_hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-define-activity-return-values-in-typescript","node":{"file_name":"how-to-define-activity-return-values-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-define-activity-return-values-in-typescript.md","id":"typescript/how-to-define-activity-return-values-in-typescript","title":"How to define Activity Return Values in TypeScript","description":"Define Activity Return Values","label":"Define Activity Return Values","tags":["developer-guide","sdk","typescript"],"markdown_content":"In TypeScript, the return value is always a Promise.\n\nIn the following example, `Promise<string>` is the return value.\n\n<!--SNIPSTART typescript-activity-fn -->\n<!--SNIPEND-->","is_empty":false}}]},{"type":"h3","id":"app-dev-context/customize-activity-type","node":{"file_name":"customize-activity-type.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/customize-activity-type.md","id":"app-dev-context/customize-activity-type","title":"How to customize your Activity Type","description":"You can set a custom name for your Activity Type.","label":"Customize Activity Type","tags":["guide-context"],"markdown_content":"You can set a custom name for your Activity Type.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-customize-activity-type-in-go","node":{"file_name":"how-to-customize-activity-type-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-customize-activity-type-in-go.md","id":"go/how-to-customize-activity-type-in-go","title":"How to customize Activity Type in Go","description":"To customize the Workflow Type set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.","label":"Customize Activity Type","tags":["developer-guide","go"],"markdown_content":"To customize the Activity Type, set the `Name` parameter with `RegisterOptions` when registering your Activity with a Worker.\n\n- Type: `string`\n- Default: function name\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  Name: \"YourActivityName\",\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```","is_empty":false}},{"lang":"java","id":"java/how-to-customize-activity-type-in-java","node":{"file_name":"how-to-customize-activity-type-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-customize-activity-type-in-java.md","id":"java/how-to-customize-activity-type-in-java","title":"How to customize Activity Type in Java","description":"The Activity Type defaults to method name with the first letter of the method name capitalized, and can be customized using `namePrefix()` or `{ActivityMethod.name()}` to ensure they are distinct.","label":"Customize Activity Type","tags":["developer-guide","java"],"markdown_content":"The Activity Type defaults to method name, with the first letter of the method name capitalized, and can be customized using `namePrefix()` or `{ActivityMethod.name()}` to ensure they are distinct.\n\nIn the following example, the Activity Type defaults to `ComposeGreeting`.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nTo overwrite this default naming and assign a custom Activity Type, use the `@ActivityMethod` annotation with the `name` parameter.\nIn the following example, the Activity Type is set to \"greet\".\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod(name = \"greet\")\n    String composeGreeting(String greeting, String language);\n}\n```\n\nYou can also define a prefix for all of your Activity Types using the `namePrefix` parameter with the `@ActivityInterface` annotation.\nThe following example shows a `namePrefix` parameter applied to the `@ActivityInterface`, and two Activity methods, of which one is defined using the `@ActivityMethod` annotation.\n\n```java\n@ActivityInterface(namePrefix = \"A_\")\nPublic interface GreetingActivities {\n    String sendGreeting(String input);\n\n  @ActivityMethod(name = \"abc\")\n  String composeGreeting(String greeting, String language);\n}\n```\n\nIn this example, the Activity type for the first method is set to `A_SendGreeting`.\nThe Activity type for the method annotated with `@ActivityMethod` is set to `A_abc`.","is_empty":false}},{"lang":"php","id":"none"},{"python":"Python","id":"python/how-to-customize-activity-type-in-python","node":{"file_name":"how-to-customize-activity-type-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-customize-activity-type-in-python.md","id":"python/how-to-customize-activity-type-in-python","title":"How to customize Activity Type in Python","description":"Customize your Activity Type.","label":"Customize Activity Type","tags":["developer-guide","sdk","python"],"markdown_content":"You can customize the Activity name with a custom name in the decorator argument. For example, `@activity.defn(name=\"your-activity\")`. If the name parameter is not specified, the Activity name defaults to the function name.\n\n```python\n@activity.defn(name=\"your-activity\")\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-customize-activity-type-in-typescript","node":{"file_name":"how-to-customize-activity-type-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-customize-activity-type-in-typescript.md","id":"typescript/how-to-customize-activity-type-in-typescript","title":"How to customize Activity Type in TypeScript","description":"Customize Activity Type","label":"Customize Activity Type","tags":["developer-guide","typescript"],"markdown_content":"In TypeScript, to customize an Activity Name set the function name to your desired name.\n\nIn the following example the Activity Name is `greet`.\n\n<!--SNIPSTART typescript-activity-fn -->\n<!--SNIPEND-->","is_empty":false}}]},{"type":"h2","id":"app-dev-context/spawning-activities","node":{"file_name":"spawning-activities.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/spawning-activities.md","id":"app-dev-context/spawning-activities","title":"How to start an Activity Execution","description":"Calls to spawn Activity Executions are written within a Workflow Definition.","label":"Activity Execution","tags":["guide-context"],"markdown_content":"Calls to spawn [Activity Executions](/activities#activity-execution) are written within a [Workflow Definition](/workflows#workflow-definition).\nThe call to spawn an Activity Execution generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nThis results in the set of three [Activity Task](/tasks#activity-task) related Events ([ActivityTaskScheduled](/references/events/#activitytaskscheduled), [ActivityTaskStarted](/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.\n\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the Execution history.\nThe entire Execution history is transferred from the Temporal service to Workflow Workers when a Workflow state needs to recover.\nA large Execution history can thus adversely impact the performance of your Workflow.\n\nTherefore, be mindful of the amount of data you transfer through Activity invocation parameters or Return Values.\nOtherwise, no additional limitations exist on Activity implementations.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-spawn-an-activity-execution-in-go","node":{"file_name":"how-to-spawn-an-activity-execution-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-spawn-an-activity-execution-in-go.md","id":"go/how-to-spawn-an-activity-execution-in-go","title":"How to spawn an Activity Execution in Go","description":"Use the `ExecuteActivity()` API call available from the `go.temporal.io/sdk/workflow` package.","label":"Activity Execution","tags":["developer-guide","go"],"markdown_content":"To spawn an [Activity Execution](/activities#activity-execution), use the [`ExecuteActivity()`](https://pkg.go.dev/go.temporal.io/workflow#ExecuteActivity) API call inside your Workflow Definition.\nThe API is available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/workflow) package.\n\nThe `ExecuteActivity()` API call requires an instance of `workflow.Context`, the Activity function name, and any variables to be passed to the Activity Execution.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n  yourActivityParam := YourActivityParam{\n    // ...\n  }\n  var activities *YourActivityStruct\n  future := workflow.ExecuteActivity(ctx, activities.YourActivityDefinition, yourActivityParam)\n  // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n  // ...\n}\n```\n\nThe Activity function name can be provided as a variable object (no quotations) or as a string.\n\n```go\n// ...\n  future := workflow.ExecuteActivity(ctx, \"YourActivityDefinition\", yourActivityParam)\n// ...\n```\n\nThe benefit of passing the actual function object is that the framework can validate the parameters against the Activity Definition.\n\nThe `ExecuteActivity` call returns a Future, which can be used to get the result of the Activity Execution.","is_empty":false}},{"lang":"java","id":"java/how-to-spawn-an-activity-execution-in-java","node":{"file_name":"how-to-spawn-an-activity-execution-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-spawn-an-activity-execution-in-java.md","id":"java/how-to-spawn-an-activity-execution-in-java","title":"How to spawn an Activity Execution in Java","description":"Invoke Activities using `Workflow.newActivityStub`(type-safe) or `Workflow.newUntypedActivityStub` (untyped) from within a Workflow.","label":"Activity Execution","tags":["java","developer-guide"],"markdown_content":"Activities are remote procedure calls that must be invoked from within a Workflow using `ActivityStub`.\nActivities are not executable on their own. You cannot start an Activity Execution by itself.\n\nNote that before an Activity Execution is invoked:\n\n- Activity options (either [`setStartToCloseTimeout`](/activities#start-to-close-timeout) or [`ScheduleToCloseTimeout`](/activities#schedule-to-close-timeout) are required) must be set for the Activity.\n  For details, see [Set Activity Options](/java/how-to-set-activityoptions-in-java) and [Activity Options reference](/java/reference-activityoptions).\n- The Activity must be registered with a Worker.\n  See [Worker Program](#run-worker-processes)\n- Activity code must be thread-safe.\n\nActivities should only be instantiated using stubs from within a Workflow.\nAn `ActivityStub` returns a client-side stub that implements an Activity interface.\nYou can invoke Activities using `Workflow.newActivityStub`(type-safe) or `Workflow.newUntypedActivityStub` (untyped).\n\nCalling a method on the Activity interface schedules the Activity invocation with the Temporal service, and generates an [`ActivityTaskScheduled` Event](/concepts/what-is-an-event#activitytaskscheduled).\n\nActivities can be invoked synchronously or asynchronously.\n\n**Invoking Activities Synchronously**\n\nIn the following example, we use the type-safe `Workflow.newActivityStub` within the \"FileProcessingWorkflow\" Workflow implementation to create a client-side stub of the `FileProcessingActivities` class. We also define `ActivityOptions` and set `setStartToCloseTimeout` option to one hour.\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) {\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    // ...\n}\n```\n\nA Workflow can have multiple Activity stubs. Each Activity stub can have its own `ActivityOptions` defined.\nThe following example shows a Workflow implementation with two typed Activity stubs.\n\n```java\npublic FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue1\")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue2\")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n```\n\nTo invoke Activities inside Workflows without referencing the interface it implements, use an untyped Activity stub `Workflow.newUntypedActivityStub`.\nThis is useful when the Activity type is not known at compile time, or to invoke Activities implemented in different programming languages.\n\n```java\n   // Workflow code\n    ActivityOptions activityOptions =\n        ActivityOptions.newBuilder()\n        .setStartToCloseTimeout(Duration.ofSeconds(3))\n        .setTaskQueue(\"simple-queue-node\")\n        .build();\n\n    ActivityStub activity = Workflow.newUntypedActivityStub(activityOptions);\n    activity.execute(\"ComposeGreeting\", String.class, \"Hello World\" , \"Spanish\");\n```\n\n**Invoking Activities Asynchronously**\n\nSometimes Workflows need to perform certain operations in parallel.\nThe Temporal Java SDK provides the `Async` class which includes static methods used to invoke any Activity asynchronously.\nThe calls return a result of type `Promise` which is similar to the Java `Future` and `CompletionStage`.\nWhen invoking Activities, use `Async.function` for Activities that return a result, and `Async.procedure` for Activities that return void.\n\nIn the following asynchronous Activity invocation, the method reference is passed to `Async.function` followed by Activity arguments.\n\n```java\nPromise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);\n```\n\nThe following example shows how to call two Activity methods, \"download\" and \"upload\", in parallel on multiple files.\n\n```java\n  public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n      // Download all files in parallel.\n      for (String sourceFilename : args.getSourceFilenames()) {\n        Promise<String> localName =\n            Async.function(activities::download, args.getSourceBucketName(), sourceFilename);\n        localNamePromises.add(localName);\n      }\n      List<String> localNames = new ArrayList<>();\n      for (Promise<String> localName : localNamePromises) {\n        localNames.add(localName.get());\n      }\n      processedNames = activities.processFiles(localNames);\n\n      // Upload all results in parallel.\n      List<Promise<Void>> uploadedList = new ArrayList<>();\n      for (String processedName : processedNames) {\n        Promise<Void> uploaded =\n            Async.procedure(\n                activities::upload,\n                args.getTargetBucketName(),\n                args.getTargetFilename(),\n                processedName);\n        uploadedList.add(uploaded);\n      }\n      // Wait for all uploads to complete.\n      Promise.allOf(uploadedList).get();\n    } finally {\n      for (Promise<String> localNamePromise : localNamePromises) {\n        // Skip files that haven't completed downloading.\n        if (localNamePromise.isCompleted()) {\n          activities.deleteLocalFile(localNamePromise.get());\n        }\n      }\n      if (processedNames != null) {\n        for (String processedName : processedNames) {\n          activities.deleteLocalFile(processedName);\n        }\n      }\n    }\n  }\n```\n\n**Activity Execution Context**\n\n`ActivityExecutionContext` is a context object passed to each Activity implementation by default.\nYou can access it in your Activity implementations via `Activity.getExecutionContext()`.\n\nIt provides getters to access information about the Workflow that invoked the Activity.\nNote that the Activity context information is stored in a thread-local variable.\nTherefore, calls to `getExecutionContext()` succeed only within the thread that invoked the Activity function.\n\nFollowing is an example of using the `ActivityExecutionContext`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n    ActivityInfo info = ctx.getInfo();\n\n    log.info(\"namespace=\" +  info.getActivityNamespace());\n    log.info(\"workflowId=\" + info.getWorkflowId());\n    log.info(\"runId=\" + info.getRunId());\n    log.info(\"activityId=\" + info.getActivityId());\n    log.info(\"activityTimeout=\" + info.getStartToCloseTimeout();\n\n    return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n  }\n    ...\n}\n```\n\nFor details on getting the results of an Activity Execution, see [Activity Execution Result](#get-activity-results).","is_empty":false}},{"lang":"php","id":"php/how-to-spawn-an-activity-execution-in-php","node":{"file_name":"how-to-spawn-an-activity-execution-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-spawn-an-activity-execution-in-php.md","id":"php/how-to-spawn-an-activity-execution-in-php","title":"How to spawn an Activity Execution in PHP","label":"Spawn an Activity Execution","markdown_content":"Activity implementation is an implementation of an Activity interface.\nThe following code example, uses a constructor that takes an Amazon S3 client and a local directory, and uploads a file to the S3 bucket.\nThen, the code uses a function to download a file from the S3 bucket passing a bucket name, remote name, and local name as arguments.\nFinally, it uses a function that takes a local file name as an argument and returns a string.\n\n```php\n// An implementation of an Activity interface.\nclass FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n    private S3Client $s3Client;\n\n    private string $localDirectory;\n\n    public function __construct(S3Client $s3Client, string $localDirectory) {\n        $this->s3Client = $s3Client;\n        $this->localDirectory = $localDirectory;\n    }\n\n    // Uploading a file to S3.\n    public function upload(string $bucketName, string $localName, string $targetName): void\n    {\n        $this->s3Client->putObject(\n            $bucketName,\n            $targetName,\n            fopen($this->localDirectory . $localName, 'rb+')\n        );\n    }\n\n// Downloading a file from S3.\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->s3Client->downloadObject(\n            $bucketName,\n            $remoteName,\n            fopen($this->localDirectory .$localName, 'wb+')\n        );\n    }\n\n// A function that takes a local file name as an argument and returns a string.\n    public function processFile(string $localName): string\n    {\n        // Implementation omitted for brevity.\n        return compressFile($this->localDirectory . $localName);\n    }\n\n    public function deleteLocalFile(string $fileName): void\n    {\n        unlink($this->localDirectory . $fileName);\n    }\n}\n```","is_empty":false}},{"lang":"python","id":"python/how-to-spawn-an-activity-execution-in-python","node":{"file_name":"how-to-spawn-an-activity-execution-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-spawn-an-activity-execution-in-python.md","id":"python/how-to-spawn-an-activity-execution-in-python","title":"How to spawn an Activity Execution in Python","description":"Use the `execute_activity()` operation from within your Workflow Definition.","label":"Activity Execution","tags":["developer-guide","python"],"markdown_content":"To spawn an Activity Execution, use the [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) operation from within your Workflow Definition.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`.\nIn most cases, use `execute_activity()` unless advanced task capabilities are needed.\n\nA single argument to the Activity is positional. Multiple arguments are not supported in the type-safe form of `start_activity()` or `execute_activity()` and must be supplied by the `args` keyword argument.","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-spawn-an-activity-execution-in-typescript","node":{"file_name":"how-to-spawn-an-activity-execution-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-spawn-an-activity-execution-in-typescript.md","id":"typescript/how-to-spawn-an-activity-execution-in-typescript","title":"How to spawn an Activity Execution in TypeScript","description":"Spawn an Activity Execution","label":"Spawn an Activity Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"To spawn an Activity Execution, you must retrieve the _Activity handle_ in your Workflow.\n\n```typescript\nimport {proxyActivities} from \"@temporalio/workflow\";\n// Only import the activity types\nimport type * as activities from \"./activities\";\n\nconst {greet} = proxyActivities<typeof activities>({\n  startToCloseTimeout: \"1 minute\",\n});\n\n// A workflow that calls an activity\nexport async function example(name: string): Promise<string> {\n  return await greet(name);\n}\n```\n\nThis imports the individual Activities and declares the type alias for each Activity.","is_empty":false}}]},{"type":"h3","id":"app-dev-context/required-activity-timeout","node":{"file_name":"required-activity-timeout.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/required-activity-timeout.md","id":"app-dev-context/required-activity-timeout","title":"How to set the required Activity Timeouts","description":"The only required value that needs to be set is either a Schedule-To-Close Timeout or a Start-To-Close Timeout","label":"Required timeout","tags":["guide-context"],"markdown_content":"Activity Execution semantics rely on several parameters.\nThe only required value that needs to be set is either a [Schedule-To-Close Timeout](/activities#start-to-close-timeout) or a [Start-To-Close Timeout](/activities#start-to-close-timeout).\nThese values are set in the Activity Options.","is_empty":false}},{"type":"h3","id":"app-dev-context/get-activity-results","node":{"file_name":"get-activity-results.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/get-activity-results.md","id":"app-dev-context/get-activity-results","title":"How to get the results of an Activity Execution","description":"The call to spawn an Activity Execution generates the ScheduleActivityTask Command and provides the Workflow with an Awaitable.","label":"Get Activity results","tags":["guide-context"],"markdown_content":"The call to spawn an [Activity Execution](/activities#activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-get-the-result-of-an-activity-execution-in-go","node":{"file_name":"how-to-get-the-result-of-an-activity-execution-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-get-the-result-of-an-activity-execution-in-go.md","id":"go/how-to-get-the-result-of-an-activity-execution-in-go","title":"How to get the result of an Activity Execution in Go","description":"Use the Future returned from the `ExecuteActivity` API call to retrieve the result.","label":"Activity Execution result","tags":["developer-guide","go"],"markdown_content":"The `ExecuteActivity` API call returns an instance of [`workflow.Future`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Futures) which has the following two methods:\n\n- `Get()`: Takes an instance of the `workflow.Context`, that was passed to the Activity Execution, and a pointer as parameters.\n  The variable associated with the pointer is populated with the Activity Execution result.\n  This call blocks until the results are available.\n- `IsReady()`: Returns `true` when the result of the Activity Execution is ready.\n\nCall the `Get()` method on the instance of `workflow.Future` to get the result of the Activity Execution.\nThe type of the result parameter must match the type of the return value declared by the Activity function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n var yourActivityResult YourActivityResult\n if err := future.Get(ctx, &yourActivityResult); err != nil {\n   // ...\n }\n // ...\n}\n```\n\nUse the `IsReady()` method first to make sure the `Get()` call doesn't cause the Workflow Execution to wait on the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n // ...\n if(future.IsReady()) {\n   var yourActivityResult YourActivityResult\n   if err := future.Get(ctx, &yourActivityResult); err != nil {\n     // ...\n   }\n }\n // ...\n}\n```\n\nIt is idiomatic to invoke multiple Activity Executions from within a Workflow.\nTherefore, it is also idiomatic to either block on the results of the Activity Executions or continue on to execute additional logic, checking for the Activity Execution results at a later time.","is_empty":false}},{"lang":"java","id":"java/how-to-get-the-result-of-an-activity-execution-in-java","node":{"file_name":"how-to-get-the-result-of-an-activity-execution-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-get-the-result-of-an-activity-execution-in-java.md","id":"java/how-to-get-the-result-of-an-activity-execution-in-java","title":"How to get the result of an Activity Execution","description":"To get the results of an asynchronously invoked Activity method, use the `Promise` `get` method to block until the Activity method result is available.","label":"Activity Execution Result","tags":["java","developer-guide"],"markdown_content":"To get the results of an asynchronously invoked Activity method, use the `Promise` `get` method to block until the Activity method result is available.\n\nSometimes an Activity Execution lifecycle goes beyond a synchronous method invocation.\nFor example, a request can be put in a queue and later a reply comes and is picked up by a different Worker process.\nThe whole request-reply interaction can be modeled as a single Activity.\n\nTo indicate that an Activity should not be completed upon its method return, call `ActivityExecutionContext.doNotCompleteOnReturn()` from the original Activity thread.\n\nThen later, when replies come, complete the Activity using the `ActivityCompletionClient`.\nTo correlate Activity invocation with completion use either a `TaskToken` or Workflow and Activity IDs.\n\nFollowing is an example of using `ActivityExecutionContext.doNotCompleteOnReturn()`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n\n    // Used to correlate reply\n    byte[] taskToken = ctx.getInfo().getTaskToken();\n\n    asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n    ctx.doNotCompleteOnReturn();\n\n    // Return value is ignored when doNotCompleteOnReturn was called.\n    return \"ignored\";\n  }\n  ...\n}\n```\n\nWhen the download is complete, the download service potentially can complete the Activity, or fail it from a different process, for example:\n\n```java\n  public <R> void completeActivity(byte[] taskToken, R result) {\n    completionClient.complete(taskToken, result);\n  }\n\n  public void failActivity(byte[] taskToken, Exception failure) {\n    completionClient.completeExceptionally(taskToken, failure);\n  }\n```","is_empty":false}},{"lang":"php","id":"php/how-to-get-the-result-of-an-activity-execution-in-php","node":{"file_name":"how-to-get-the-result-of-an-activity-execution-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-get-the-result-of-an-activity-execution-in-php.md","id":"php/how-to-get-the-result-of-an-activity-execution-in-php","title":"How to get the result of an Activity Execution in PHP","label":"Activity Execution","markdown_content":"`Workflow::newActivityStub`returns a client-side stub an implements an Activity interface. The client-side stub can be used within the Workflow code. It takes the Activity's type and`ActivityOptions` as arguments.\n\nCalling (via `yield`) a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if Activity execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\n```php\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    private $greetingActivity;\n\n    public function __construct()\n    {\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n        );\n    }\n\n    public function greet(string $name): \\Generator\n    {\n        // This is a blocking call that returns only after the activity has completed.\n        return yield $this->greetingActivity->composeGreeting('Hello', $name);\n    }\n}\n```\n\nIf different Activities need different options, like timeouts or a task queue, multiple client-side stubs can be created with different options.\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 minutes'))\n);\n```","is_empty":false}},{"lang":"python","id":"python/how-to-get-the-result-of-an-activity-execution-in-python","node":{"file_name":"how-to-get-the-result-of-an-activity-execution-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-get-the-result-of-an-activity-execution-in-python.md","id":"python/how-to-get-the-result-of-an-activity-execution-in-python","title":"How to get the result of an Activity Execution in Python","description":"Get the result of an Activity Execution","label":"Get the result of an Activity Execution","tags":["developer-guide","sdk","python"],"markdown_content":"Use [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) to start an Activity and return its handle, [`ActivityHandle`](https://python.temporal.io/temporalio.workflow.activityhandle). Use [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) to return the results.\n\nYou must provide either `schedule_to_close_timeout` or `start_to_close_timeout`.\n\n`execute_activity()` is a shortcut for `await start_activity()`. An asynchronous `execute_activity()` helper is provided which takes the same arguments as `start_activity()` and `await`s on the result. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-get-the-result-of-an-activity-execution-in-typescript","node":{"file_name":"how-to-get-the-result-of-an-activity-execution-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-get-the-result-of-an-activity-execution-in-typescript.md","id":"typescript/how-to-get-the-result-of-an-activity-execution-in-typescript","title":"How to get the result of an Activity Execution in TypeScript","description":"Get the result of an Activity Execution","label":"Get the result of an Activity Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"Since Activities are referenced by their string name, you can reference them dynamically to get the result of an Activity Execution.\n\n```typescript\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts[\"activity1\"]();\n\n  let result = await acts[activityName](...args);\n  return result;\n}\n```\n\nThe `proxyActivities()` returns an object that calls the Activities in the function. `acts[activityName]()` references the Activity using the Activity name, then it returns the results.","is_empty":false}}]},{"type":"h2","id":"app-dev-context/run-worker-processes","node":{"file_name":"run-worker-processes.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/run-worker-processes.md","id":"app-dev-context/run-worker-processes","title":"How to run Worker Processes","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run Worker Processes","tags":["guide-context"],"markdown_content":"The [Worker Process](/workers#worker-process) is where Workflow Functions and Activity Functions are executed.\n\n- Each [Worker Entity](/workers#worker-entity) in the Worker Process must register the exact Workflow Types and Activity Types it may execute.\n- Each Worker Entity must also associate itself with exactly one [Task Queue](/tasks#task-queue).\n- Each Worker Entity polling the same Task Queue must be registered with the same Workflow Types and Activity Types.\n\nA [Worker Entity](/workers#worker-entity) is the component within a Worker Process that listens to a specific Task Queue.\n\nAlthough multiple Worker Entities can be in a single Worker Process, a single Worker Entity Worker Process may be perfectly sufficient.\nFor more information, see the [Worker tuning guide](/application-development/worker-performance).\n\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it can make progress for either a Workflow Execution or an Activity Execution.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-develop-a-worker-in-go","node":{"file_name":"how-to-develop-a-worker-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-develop-a-worker-in-go.md","id":"go/how-to-develop-a-worker-in-go","title":"How to develop a Worker in Go","description":"Develop an instance of a Worker by calling `worker.New()`, available via the `go.temporal.io/sdk/worker` package.","label":"Develop Worker","tags":["developer-guide","go","workers"],"markdown_content":"Create an instance of [`Worker`](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) by calling [`worker.New()`](https://pkg.go.dev/go.temporal.io/sdk/worker#New), available through the `go.temporal.io/sdk/worker` package, and pass it the following parameters:\n\n1. An instance of the Temporal Go SDK `Client`.\n1. The name of the Task Queue that it will poll.\n1. An instance of [`worker.Options`](/go/how-to-set-workeroptions-in-go), which can be empty.\n\nThen, register the Workflow Types and the Activity Types that the Worker will be capable of executing.\n\nLastly, call either the `Start()` or the `Run()` method on the instance of the Worker.\nRun accepts an interrupt channel as a parameter, so that the Worker can be stopped in the terminal.\nOtherwise, the `Stop()` method must be called to stop the Worker.\n\n```go\npackage main\n\nimport (\n   \"go.temporal.io/sdk/client\"\n   \"go.temporal.io/sdk/worker\"\n)\n\nfunc main() {\n   c, err := client.Dial(client.Options{})\n   if err != nil {\n       // ...\n   }\n   defer c.Close()\n   w := worker.New(c, \"your-task-queue\", worker.Options{})\n   w.RegisterWorkflow(YourWorkflowDefinition)\n   w.RegisterActivity(YourActivityDefinition)\n   err = w.Run(worker.InterruptCh())\n   if err != nil\n       // ...\n   }\n // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n}\n\nfunc YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResponse, error) {\n // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-develop-a-worker-program-in-java","node":{"file_name":"how-to-develop-a-worker-program-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-develop-a-worker-program-in-java.md","id":"java/how-to-develop-a-worker-program-in-java","title":"How to develop a Worker Program in Java","description":"Use the `newWorker` method on an instance of a `WorkerFactory` to create a new Worker in Java.","tags":["developer-guide","java","workers"],"markdown_content":"Use the `newWorker` method on an instance of a [`WorkerFactory`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/worker/WorkerFactory.html) to create a new Worker in Java.\n\nA single Worker Entity can contain many Worker Objects.\nCall the `start()` method on the instance of the `WorkerFactory` to start all the Workers created in this process.\n\n```java\n// ...\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.serviceclient.WorkflowServiceStubs;\nimport io.temporal.worker.Worker;\nimport io.temporal.worker.WorkerFactory;\n\npublic class YourWorker {\n\n  public static void main(String[] args) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker yourWorker = factory.newWorker(\"your_task_queue\");\n\n    // Register Workflow\n    // and/or register Activities\n\n    factory.start();\n  }\n}\n```\n\nAfter creating the Worker entity, register all Workflow Types and all Activity Types that the Worker can execute.\nA Worker can be registered with just Workflows, just Activities, or both.\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)","is_empty":false}},{"lang":"php","id":"php/how-to-develop-a-worker-program-in-php","node":{"file_name":"how-to-develop-a-worker-program-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-develop-a-worker-program-in-php.md","id":"php/how-to-develop-a-worker-program-in-php","title":"How to develop a Worker Program in PHP","description":"Use the `newWorker()` method on an instance of a `WorkerFactory` to create a new Worker in PHP.","tags":["developer-guide","php","workers"],"markdown_content":"The [RoadRunner application server](https://roadrunner.dev/) will launch multiple Temporal PHP Worker processes based on provided `.rr.yaml` configuration.\n\nEach Worker might connect to one or multiple Task Queues.\nWorker poll _Temporal service_ for tasks, performs those tasks, and communicates task execution results back to the _Temporal service_.\n\nWorker code are developed, deployed, and operated by Temporal customers.\nTo create a worker use `Temporal\\WorkerFactory`:\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nuse Temporal\\WorkerFactory;\n\nini_set('display_errors', 'stderr');\ninclude \"vendor/autoload.php\";\n\n// factory initiates and runs task queue specific activity and workflow workers\n$factory = WorkerFactory::create();\n\n// Worker that listens on a Task Queue and hosts both workflow and activity implementations.\n$worker = $factory->newWorker();\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n\n// Activities are stateless and thread safe. So a shared instance is used.\n$worker->registerActivity(App\\DemoActivity::class);\n\n// In case an activity class requires some external dependencies provide a callback - factory\n// that creates or builds a new activity instance. The factory should be a callable which accepts\n// an instance of ReflectionClass with an activity class which should be created.\n$worker->registerActivity(App\\DemoActivity::class, fn(ReflectionClass $class) => $container->create($class->getName()));\n\n// start primary loop\n$factory->run();\n```\n\nYou can configure task queue name using first argument of `WorkerFactory`->`newWorker`:\n\n```php\n$worker = $factory->newWorker('your-task-queue');\n```\n\nAs mentioned above you can create as many Task Queue connections inside a single Worker Process as you need.\n\nTo configure additional WorkerOptions use `Temporal\\Worker\\WorkerOptions`:\n\n```php\nuse Temporal\\Worker\\WorkerOptions;\n\n$worker = $factory->newWorker(\n    'your-task-queue',\n    WorkerOptions::new()\n        ->withMaxConcurrentWorkflowTaskPollers(10)\n);\n```\n\nMake sure to point the Worker file in application server configuration:\n\n```yaml\nrpc:\n  listen: tcp://127.0.0.1:6001\n\nserver:\n  command: \"php worker.php\"\n\ntemporal:\n  address: \"temporal:7233\"\n  activities:\n    num_workers: 10\n```\n\n> You can serve HTTP endpoints using the same server setup.","is_empty":false}},{"lang":"python","id":"python/how-to-develop-a-worker-program-in-python","node":{"file_name":"how-to-develop-a-worker-program-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-develop-a-worker-program-in-python.md","id":"python/how-to-develop-a-worker-program-in-python","title":"How to develop a Worker Program in Python","description":"Create a new instance of a Worker.","label":"Worker Program","tags":["developer-guide","python","workers"],"markdown_content":"To develop a Worker, use the [`Worker()`](https://python.temporal.io/temporalio.worker.worker#__init__) constructor and add your Client, Task Queue, Workflows, and Activities as arguments.\n\nThe following code example creates a Worker that polls for tasks from the Task Queue and executes the Workflow.\n\n```python\nworker = Worker(\n    client,\n    task_queue=\"your-task-queue\",\n    workflows=[YourWorkflow],\n    activities=[your_activity],\n)\n```\n\nThe following code example shows a Worker hosting Workflows and Activities.\n\n```python\nasync def run_worker(stop_event: asyncio.Event):\n    # Create Client connected to server at the given address\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    # Run the worker until the event is set\n    worker = Worker(\n        client,\n        task_queue=\"your-task-queue\",\n        workflows=[YourWorkflow],\n        activities=[your_activity],\n    )\n    async with worker:\n        await stop_event.wait()\n```\n\nThe `asyncio.Event` that will be set when the Worker should stop.\nAlthough this example accepts a stop event and uses `async with`, you can also use [`run()`](https://python.temporal.io/temporalio.worker.Worker.html#run) and [`shutdown()`](https://python.temporal.io/temporalio.worker.Worker.html#shutdown).\nThe `shutdown()` operation waits on all Activities to complete, so if a long-running Activity does not at least respect cancellation, the shutdown might never complete.","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-develop-a-worker-program-in-typescript","node":{"file_name":"how-to-develop-a-worker-program-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-develop-a-worker-program-in-typescript.md","id":"typescript/how-to-develop-a-worker-program-in-typescript","title":"How to develop a Worker program in TypeScript","description":"Develop a Worker program","label":"Develop a Worker program","tags":["developer-guide","sdk","typescript"],"markdown_content":"Create a Worker with `Worker.create()` (which establishes the initial gRPC connection), then call `worker.run()` on it (to start polling the Task Queue).\n\nBelow is an example of starting a Worker that polls the Task Queue named `tutorial`.\n\n<!--SNIPSTART typescript-hello-worker {\"enable_source_link\": false}-->\n<!--SNIPEND-->\n\n`taskQueue` is the only required option, but you will also use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nA full example for Workers looks like this:\n\n```typescript\nimport {Worker, NativeConnection} from \"@temporalio/worker\";\nimport * as activities from \"./activities\";\n\nasync function run() {\n  const connection = await NativeConnection.connect({\n    // defaults port to 7233 if not specified\n    address: \"foo.bar.tmprl.cloud\",\n    tls: {\n      // set to true if TLS without mTLS\n      // See docs for other TLS options\n      clientCertPair: {\n        crt: clientCert,\n        key: clientKey,\n      },\n    },\n  });\n\n  const worker = await Worker.create({\n    connection,\n    namespace: \"foo.bar\", // as explained in Namespaces section\n    // ...\n  });\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\nSee below for more Worker options.\n\n**Workflow and Activity registration**\n\nWorkers bundle Workflow code and `node_modules` using Webpack v5 and execute them inside V8 isolates.\nActivities are directly required and run by Workers in the Node.js environment.\n\nWorkers are very flexible  you can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers in a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker. Not the path.\n- Workflow bundle:\n- Either specify a `workflowsPath` to your `workflows.ts` file to pass to Webpack, e.g., `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n- Or pass a prebuilt bundle to `workflowBundle` instead if you prefer to handle the bundling yourself.\n\n**Additional Worker Options**\n\nThis is a selected subset of options you are likely to use. Even more advanced options, particularly for performance tuning, are available in [the API reference](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions).\n\n| Options         | Description                                                                                                                           |\n| --------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| `dataConverter` | Encodes and decodes data entering and exiting a Temporal Server. Supports `undefined`, `UintBArray`, and JSON.                        |\n| `sinks`         | Allows injection of Workflow Sinks (Advanced feature: see [Logging docs](/typescript/logging))                                        |\n| `interceptors`  | A mapping of interceptor type to a list of factories or module paths (Advanced feature: see [Interceptors](/typescript/interceptors)) |\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)","is_empty":false}}]},{"type":"h3","id":"app-dev-context/registering-types","node":{"file_name":"registering-types.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/registering-types.md","id":"app-dev-context/registering-types","title":"How to register types","description":"How to register Workflow and Activity Types","label":"Register types","tags":["guide-context"],"markdown_content":"All Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it fails that Task.\nHowever, the failure of the Task does not cause the associated Workflow Execution to fail.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-register-types-with-a-worker-in-go","node":{"file_name":"how-to-register-types-with-a-worker-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-register-types-with-a-worker-in-go.md","id":"go/how-to-register-types-with-a-worker-in-go","title":"How to register types with a Worker in Go","description":"The `RegisterWorkflow()` and `RegisterActivity()` calls create an in-memory mapping between the Workflow Types and their implementations.","label":"Register Types","tags":["developer-guide","go","workers"],"markdown_content":"The `RegisterWorkflow()` and `RegisterActivity()` calls essentially create an in-memory mapping between the Workflow Types and their implementations, inside the Worker process.\n\n**Registering Activity `structs`**\n\nPer [Activity Definition](#develop-activities) best practices, you might have an Activity struct that has multiple methods and fields.\nWhen you use `RegisterActivity()` for an Activity struct, that Worker has access to all exported methods.\n\n**Registering multiple Types**\n\nTo register multiple Activity Types and/or Workflow Types with the Worker Entity, just make multiple Activity registration calls, but make sure each Type name is unique:\n\n```go\nw.registerActivity(ActivityA)\nw.registerActivity(ActivityB)\nw.registerActivity(ActivityC)\nw.registerWorkflow(WorkflowA)\nw.registerWorkflow(WorkflowB)\nw.registerWorkflow(WorkflowC)\n```","is_empty":false}},{"lang":"java","id":"java/how-to-register-types-with-a-worker-in-java","node":{"file_name":"how-to-register-types-with-a-worker-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-register-types-with-a-worker-in-java.md","id":"java/how-to-register-types-with-a-worker-in-java","title":"How to register types with a Worker in Java","description":"Use `worker.registerWorkflowImplementationTypes` to register Workflow type and `worker.registerActivitiesImplementations` to register Activity implementation with Workers.","label":"Register Types","tags":["developer-guide","java","workers"],"markdown_content":"Use `worker.registerWorkflowImplementationTypes` to register Workflow type and `worker.registerActivitiesImplementations` to register Activity implementation with Workers.\n\nFor Workflows, the Workflow Type is registered with a Worker.\nA Workflow Type can be registered only once per Worker entity.\nIf you define multiple Workflow implementations of the same type, you get an exception at the time of registration.\n\nFor Activities, Activity implementation instances are registered with a Worker because they are stateless and thread-safe.\nYou can pass any number of dependencies in the Activity implementation constructor, such as the database connections, services, etc.\n\nThe following example shows how to register a Workflow and an Activity with a Worker.\n\n```java\n    Worker worker = workerFactory.newWorker(\"your_task_queue\");\n    ...\n    // Register Workflow\n    worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n    // Register Activity\n    worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n```\n\nWhen you register a single instance of an Activity, you can have multiple instances of Workflow Executions calling the same Activity.\nActivity code must be thread-safe because the same instance of the Activity code is run for every Workflow Execution that calls it.\n\nFor `DynamicWorkflow`, only one Workflow implementation that extends `DynamicWorkflow` can be registered with a Worker.\nThe following example shows how to register the `DynamicWorkflow` and `DynamicActivity` implementation with a Worker.\n\n```java\n  public static void main(String[] arg) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker(TASK_QUEUE);\n\n    /* Register the Dynamic Workflow implementation with the Worker. Workflow implementations\n    ** must be known to the Worker at runtime to dispatch Workflow Tasks.\n    */\n    worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    // Start all the Workers that are in this process.\n    factory.start();\n\n    /* Create the Workflow stub. Note that the Workflow type is not explicitly registered with the Worker. */\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n    /**\n     * Register Dynamic Activity implementation with the Worker. Since Activities are stateless\n     * and thread-safe, we need to register a shared instance.\n    */\n    worker.registerActivitiesImplementations(new DynamicGreetingActivityImpl());\n\n    /* Start Workflow Execution and immmediately send Signal. Pass in the Workflow args and Signal args. */\n    workflow.signalWithStart(\"greetingSignal\", new Object[] {\"John\"}, new Object[] {\"Hello\"});\n\n    // Wait for the Workflow to finish getting the results.\n    String result = workflow.getResult(String.class);\n\n    System.out.println(result);\n\n    System.exit(0);\n  }\n}\n```\n\nYou can register multiple type-specific Workflow implementations alongside a single `DynamicWorkflow` implementation.\nYou can register only one Activity instance that implements `DynamicActivity` with a Worker.","is_empty":false}},{"lang":"php","id":"php/how-to-register-types-with-a-worker-in-php","node":{"file_name":"how-to-register-types-with-a-worker-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-register-types-with-a-worker-in-php.md","id":"php/how-to-register-types-with-a-worker-in-php","title":"How to register types with a Worker in PHP","description":"Use `registerWorkflowTypes()` to register Workflow type and `registerActivity()` to register Activity implementation with Workers.","label":"Register Types","tags":["developer-guide","php","workers"],"markdown_content":"Worker listens on a task queue and hosts both workflow and activity implementations:\n\n```php\n// Workflows are stateful. So you need a type to create instances:\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n// Activities are stateless and thread safe:\n$worker->registerActivity(App\\DemoActivity::class);\n```\n\nIn case an activity class requires some external dependencies provide a callback - factory\nthat creates or builds a new activity instance. The factory should be a callable which accepts\nan instance of ReflectionClass with an activity class which should be created.\n\n```php\n$worker->registerActivity(\n    App\\DemoActivity::class,\n    fn(ReflectionClass $class) => $container->create($class->getName())\n);\n```\n\nIf you want to clean up some resources after activity is done, you may register a finalizer. This callback is called\nafter each activity invocation:\n\n```php\n$worker->registerActivityFinalizer(fn() => $kernel->showtdown());\n```","is_empty":false}},{"lang":"python","id":"python/how-to-register-types-with-a-worker-in-python","node":{"file_name":"how-to-register-types-with-a-worker-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-register-types-with-a-worker-in-python.md","id":"python/how-to-register-types-with-a-worker-in-python","title":"How to register types with a Worker in Python","description":"Register types with a Worker","label":"Register types with a Worker","tags":["developer-guide","sdk","python"],"markdown_content":"When a `Worker` is created, it accepts a list of Workflows in the `workflows` parameter, a list of Activities in the `activities` parameter, or both.\n\n```python\nworker = Worker(\n    client,\n    task_queue=\"your-task-queue\",\n    workflows=[YourWorkflow1, YourWorkflow2],\n    activities=[your_activity_1, your_activity_2],\n)\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-register-types-with-a-worker-in-typescript","node":{"file_name":"how-to-register-types-with-a-worker-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-register-types-with-a-worker-in-typescript.md","id":"typescript/how-to-register-types-with-a-worker-in-typescript","title":"How to register types with a Worker in TypeScript","description":"Register types.","label":"Register Types","tags":["developer-guide","typescript","workers"],"markdown_content":"We recommend resolving on a directory to register each function within the directory.\n\n- Use [`workflowsPath`](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#workflowspath) for non-production build images.\n- Use [`workflowBundle`](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#workflowbundle) for production build images.\n\n<!--SNIPSTART typescript-worker-create -->\n<!--SNIPEND-->\n\nFor example, in most of our samples:\n\n- We use `ts-node`, which compiles TypeScript on the fly.\n- Our Workers bundle Workflow code at runtime.\n\nWe can improve our Worker's startup time by building code in advance.\n\n**Worker code**\n\nThe Worker code can be built and run with:\n\n```sh\nnpm run build\nnode lib/worker.js\n```\n\n**Workflow code**\n\nYou can programmatically bundle Workflow code on your own with [`bundleWorkflowCode`](/typescript/workers#prebuilt-workflow-bundles):\n\n```ts\nconst {code} = await bundleWorkflowCode({\n  workflowsPath: require.resolve(\"src/workflows\"),\n});\n\nawait writeFile(path.join(__dirname, \"workflow-bundle.js\"), code);\n```\n\nAnd then the bundle can be passed to the Worker:\n\n```ts\nconst worker = await Worker.create({\n  workflowBundle: {path: require.resolve(\"workflow-bundle.js\")},\n  activities,\n  taskQueue,\n});\n```\n\nYou can also bundle code on your own and pass it to the `workflowBundle`.\n\nWe can see this process working in the [production sample](https://github.com/temporalio/samples-typescript/tree/main/production):\n\n<!--SNIPSTART typescript-production-worker-->\n<!--SNIPEND-->","is_empty":false}}]},{"type":"h2","id":"app-dev-context/spawning-workflows","node":{"file_name":"spawning-workflows.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/spawning-workflows.md","id":"app-dev-context/spawning-workflows","title":"How to start a Workflow Execution","description":"Workflow Execution semantics rely on several parametersthat is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.","label":"Start Workflow Execution","tags":["guide-context"],"markdown_content":"[Workflow Execution](/workflows#workflow-execution) semantics rely on several parametersthat is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.\n\nIn the examples below, all Workflow Executions are started using a Temporal Client.\nTo spawn Workflow Executions from within another Workflow Execution, use either the [Child Workflow](#child-workflows) or External Workflow APIs.\n\nSee the [Customize Workflow Type](#customize-workflow-type) section to see how to customize the name of the Workflow Type.\n\nA request to spawn a Workflow Execution causes the Temporal Cluster to create the first Event ([WorkflowExecutionStarted](/references/events/#workflowexecutionstarted)) in the Workflow Execution Event History.\nThe Temporal Cluster then creates the first Workflow Task, resulting in the first [WorkflowTaskScheduled](/references/events/#workflowtaskscheduled) Event.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-spawn-a-workflow-execution-in-go","node":{"file_name":"how-to-spawn-a-workflow-execution-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-spawn-a-workflow-execution-in-go.md","id":"go/how-to-spawn-a-workflow-execution-in-go","title":"How to spawn a Workflow Execution in Go","description":"Use the `ExecuteWorkflow()` method on the Go SDK `Client`, which is available via `Dial()` in the `go.temporal.io/sdk/client` package.","label":"Workflow Execution","tags":["developer-guide","go"],"markdown_content":"To spawn a [Workflow Execution](/workflows#workflow-execution), use the `ExecuteWorkflow()` method on the Go SDK [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nThe `ExecuteWorkflow()` API call requires an instance of [`context.Context`](https://pkg.go.dev/context#Context), an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions), a Workflow Type name, and all variables to be passed to the Workflow Execution.\nThe `ExecuteWorkflow()` call returns a Future, which can be used to get the result of the Workflow Execution.\n\n```go\npackage main\n\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n  workflowOptions := client.StartWorkflowOptions{\n    // ...\n  }\n  workflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n  if err != nil {\n    // ...\n  }\n  // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n}\n```\n\nIf the invocation process has access to the function directly, then the Workflow Type name parameter can be passed as if the function name were a variable, without quotations.\n\n```go\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n```\n\nIf the invocation process does not have direct access to the statically defined Workflow Definition, for example, if the Workflow Definition is in an un-importable package, or it is written in a completely different language, then the Workflow Type can be provided as a `string`.\n\n```go\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, \"YourWorkflowDefinition\", param)\n```","is_empty":false}},{"lang":"java","id":"java/how-to-spawn-a-workflow-execution-in-java","node":{"file_name":"how-to-spawn-a-workflow-execution-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-spawn-a-workflow-execution-in-java.md","id":"java/how-to-spawn-a-workflow-execution-in-java","title":"How to spawn a Workflow Execution in Java","description":"Use `WorkflowStub` to start a Workflow Execution from within a Client, and `ExternalWorkflowStub` to start a different Workflow Execution from within a Workflow.","label":"Workflow Execution","tags":["java","developer-guide"],"markdown_content":"Use `WorkflowStub` to start a Workflow Execution from within a Client, and `ExternalWorkflowStub` to start a different Workflow Execution from within a Workflow.\n\nSee [`SignalwithStart`](/application-development/features#signal-with-start) to start a Workflow Execution to receive a Signal from within another Workflow.\n\n**Using `WorkflowStub`**\n\n`WorkflowStub` is a proxy generated by the `WorkflowClient`.\nEach time a new Workflow Execution is started, an instance of the Workflow implementation object is created.\nThen, one of the methods (depending on the Workflow Type of the instance) annotated with `@WorkflowMethod` can be invoked.\nAs soon as this method returns, the Workflow Execution is considered to be complete.\n\nYou can use a typed or untyped `WorkflowStub` in the client code.\n\n- Typed `WorkflowStub` are useful because they are type safe and allow you to invoke your Workflow methods such as `@WorkflowMethod`, `@QueryMethod`, and `@SignalMethod` directly.\n- An untyped `WorkflowStub` does not use the Workflow interface, and is not type safe. It is more flexible because it has methods from the `WorkflowStub` interface, such as `start`, `signalWithStart`, `getResults` (sync and async), `query`, `signal`, `cancel` and `terminate`.\n  Note that the Temporal Java SDK also provides typed `WorkflowStub` versions for these methods.\n  When using untyped `WorkflowStub`, we rely on the Workflow Type, Activity Type, Child Workflow Type, as well as Query and Signal names.\n  For details, see [Temporal Client](#connect-to-a-cluster).\n\nA Workflow Execution can be started either synchronously or asynchronously.\n\n- Synchronous invocation starts a Workflow and then waits for its completion. If the process that started the Workflow crashes or stops waiting, the Workflow continues executing.\n  Because Workflows are potentially long-running, and Client crashes happen, it is not very commonly found in production use.\n  The following example is a type-safe approach for starting a Workflow Execution synchronously.\n\n  ```java\n    NotifyUserAccounts workflow = client.newWorkflowStub(\n          NotifyUserAccounts.class,\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(\"notifyAccounts\")\n                  .setTaskQueue(taskQueue)\n                  .build()\n          );\n\n  // start the Workflow and wait for a result.\n    workflow.notify(new String[] { \"Account1\", \"Account2\", \"Account3\", \"Account4\", \"Account5\",\n                  \"Account6\", \"Account7\", \"Account8\", \"Account9\", \"Account10\"});\n      }\n  // notify(String[] accountIds) is a Workflow method defined in the Workflow Definition.\n  ```\n\n- Asynchronous start initiates a Workflow Execution and immediately returns to the caller. This is the most common way to start Workflows in production code.\n  The `WorkflowClient`<https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/client/WorkflowClient.java)> provides some static methods, such as `start`, `execute`, `signalWithStart` etc., that help with starting your Workflows asynchronously.\n\n  The following examples show how to start Workflow Executions asynchronously, with either typed or untyped `WorkflowStub`.\n\n  - **Typed WorkflowStub Example**\n\n    ```java\n    // create typed Workflow stub\n    FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n          WorkflowOptions.newBuilder()\n                  .setTaskQueue(taskQueue)\n                  .setWorkflowId(workflowId)\n                  .build());\n    // use WorkflowClient.execute to return future that contains Workflow result or failure, or\n    // use WorkflowClient.start to return WorkflowId and RunId of the started Workflow).\n    WorkflowClient.start(workflow::greetCustomer);\n    ```\n\n  - **Untyped WorkflowStub Example**\n\n    ```java\n    WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(workflowId)\n                  .setTaskQueue(taskQueue)\n                  .build());\n\n    // blocks until Workflow Execution has been started (not until it completes)\n    untyped.start(argument);\n    ```\n\nYou can call a Dynamic Workflow implementation using an untyped `WorkflowStub`.\nThe following example shows how to call the Dynamic Workflow implementation in the Client code.\n\n```java\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    /**\n      * Note that for this part of the client code, the dynamic Workflow implementation must\n      * be known to the Worker at runtime in order to dispatch Workflow tasks, and may be defined\n      * in the Worker definition as:*/\n    // worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    /* Create the Workflow stub to call the dynamic Workflow.\n    * Note that the Workflow type is not explicitly registered with the Worker.*/\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n```\n\n`DynamicWorkflow` can be used to invoke different Workflow Types.\nTo check what type is running when your Dynamic Workflow `execute` method runs, use `getWorkflowType()` in the implementation code.\n\n```java\nString type = Workflow.getInfo().getWorkflowType();\n```\n\nSee [Workflow Execution Result](#get-workflow-results) for details on how to get the results of the Workflow Execution.\n\n**Using `ExternalWorkflowStub`**\n\nUse `ExternalWorkflowStub` within a Workflow to invoke, and send Signals to, other Workflows by type.\n\nThis helps particularly for executing Workflows written in other language SDKs, as shown in the following example.\n\n```java\n@Override\n  public String yourWFMethod(String name) {\n      ExternalWorkflowStub callOtherWorkflow = Workflow.newUntypedExternalWorkflowStub(\"OtherWFId\");\n    }\n```\n\nSee the [Temporal Polyglot](https://github.com/tsurdilo/temporal-polyglot) code for examples of executing Workflows written in other language SDKs.\n\n**Recurring start**\n\nYou can start a Workflow Execution on a regular schedule by using [`setCronSchedule`](/java/reference-workflowoptions/#cronschedule) Workflow option in the Client code.","is_empty":false}},{"lang":"php","id":"php/how-to-spawn-a-workflow-execution-in-php","node":{"file_name":"how-to-spawn-a-workflow-execution-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-spawn-a-workflow-execution-in-php.md","id":"php/how-to-spawn-a-workflow-execution-in-php","title":"How to spawn a Workflow Execution in PHP","description":"Use the `Temporal\\Client\\WorkflowClient` to start a workflow both synchronously and asynchronously.","label":"Workflow Execution","tags":["developer-guide","php"],"markdown_content":"Workflows can be started both synchronously and asynchronously. You can use typed or untyped workflows stubs available\nvia `Temporal\\Client\\WorkflowClient`. To create workflow client:\n\n```php\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$workflowClient = WorkflowClient::create(ServiceClient::create('localhost:7233'));\n```\n\n**Synchronous start**\n\nA synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the\ninvocation process and will continue executing even if the waiting process crashes or stops.\n\nMake sure to acquire workflow interface or class name you want to start. For example:\n\n```php\n#[WorkflowInterface]\ninterface AccountTransferWorkflowInterface\n{\n    #[WorkflowMethod(name: \"MoneyTransfer\")]\n    #[ReturnType('int')]\n    public function transfer(\n        string $fromAccountId,\n        string $toAccountId,\n        string $referenceId,\n        int $amountCents\n    );\n}\n```\n\nTo start such workflow in sync mode:\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$result = $accountTransfer->transfer(\n    'fromID',\n    'toID',\n    'refID',\n    1000\n);\n```\n\n**Asynchronous start**\n\nAn asynchronous start initiates a Workflow execution and immediately returns to the caller without waiting for a result.\nThis is the most common way to start Workflows in a live environment.\n\nTo start a Workflow asynchronously pass workflow stub instance and start parameters into `WorkflowClient`->`start`\nmethod.\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$run = $this->workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n```\n\nOnce started you can receive workflow ID via `WorkflowRun` object returned by start method:\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getExecution()->getID());\n```\n\n**Recurring start**\n\nYou can start a Workflow Execution on a regular schedule with [the CronSchedule option](/php/distributed-cron).","is_empty":false}},{"lang":"python","id":"python/how-to-spawn-a-workflow-execution-in-python","node":{"file_name":"how-to-spawn-a-workflow-execution-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-spawn-a-workflow-execution-in-python.md","id":"python/how-to-spawn-a-workflow-execution-in-python","title":"How to spawn a Workflow Execution in Python","description":"Spawn a Workflow Execution","label":"Spawn a Workflow Execution","tags":["developer-guide","sdk","python"],"markdown_content":"To start a Workflow Execution in python, use either the [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) asynchronous methods in the Client.\n\nThe following code example starts a Workflow and returns its handle.\n\n```python\nasync def main():\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    handle = await client.start_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n```\n\nThe following code example starts a Workflow and waits for completion.\n\n```python\nasync def main():\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    handle = await client.execute_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-spawn-a-workflow-execution-in-typescript","node":{"file_name":"how-to-spawn-a-workflow-execution-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-spawn-a-workflow-execution-in-typescript.md","id":"typescript/how-to-spawn-a-workflow-execution-in-typescript","title":"How to spawn a Workflow Execution in TypeScript","description":"Spawn a Workflow Execution","label":"Spawn a Workflow Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"When you have a Workflow Client, you can schedule the start of a Workflow with `client.start()`, specifying `workflowId`, `taskQueue`, and `args` and returning a Workflow handle immediately after the Server acknowledges the receipt.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: \"your-workflow-id\",\n  taskQueue: \"your-task-queue\",\n  args: [\"argument01\", \"argument02\", \"argument03\"], // this is typechecked against workflowFn's args\n});\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nCalling `client.start()` and `client.execute()` send a command to Temporal Server to schedule a new Workflow Execution on the specified Task Queue. It does not actually start until a Worker that has a matching Workflow Type, polling that Task Queue, picks it up.\n\nYou can test this by executing a Workflow Client command without a matching Worker. Temporal Server records the command in Event History, but does not make progress with the Workflow Execution until a Worker starts polling with a matching Task Queue and Workflow Definition.\n\nWorkflow Execution run in a separate V8 isolate context in order to provide a [deterministic runtime](/typescript/determinism).","is_empty":false}}]},{"type":"h3","id":"app-dev-context/set-task-queue","node":{"file_name":"set-task-queue.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/set-task-queue.md","id":"app-dev-context/set-task-queue","title":"How to set a Workflow's Task Queue","description":"In most SDKs, the only Workflow Option that must be set is the name of the Task Queue.","label":"Set Task Queue","tags":["guide-context"],"markdown_content":"In most SDKs, the only Workflow Option that must be set is the name of the [Task Queue](/tasks#task-queue).\n\nFor any code to execute, a Worker Process must be running that contains a Worker Entity that is polling the same Task Queue name.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-workflow-task-queue-in-go","node":{"file_name":"how-to-set-a-workflow-task-queue-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-workflow-task-queue-in-go.md","id":"go/how-to-set-a-workflow-task-queue-in-go","title":"How to set the Task Queue for Workflow Execution in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Task Queue","tags":["go","how-to"],"markdown_content":"Create an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None, this is a required field to be set by the developer\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  TaskQueue: \"your-task-queue\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-workflow-task-queue-in-java","node":{"file_name":"how-to-set-a-workflow-task-queue-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-workflow-task-queue-in-java.md","id":"java/how-to-set-a-workflow-task-queue-in-java","title":"How to set the Task Queue for Workflow Execution in Java","description":"Set the Workflow Task Queue with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setTaskQueue`.","label":"Task Queue","tags":["java","how-to","developer-guide"],"markdown_content":"Set the Workflow Task Queue with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setTaskQueue`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                // Set the Task Queue\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-workflow-task-queue-in-php","node":{"file_name":"how-to-set-a-workflow-task-queue-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-workflow-task-queue-in-php.md","id":"php/how-to-set-a-workflow-task-queue-in-php","title":"How to set a Workflow Task Queue in PHP","label":"Task Queues","markdown_content":"In PHP, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```php\n// Create new Workflow Options and set the Task Queue\n$workflowOptions = WorkflowOptions::new()\n  ->withTaskQueue(\"Workflow-Task-Queue-1\")\n  // ...\n\n$yourWorkflow = $workflowClient->newWorkflowStub(\n  YourWorkflowInterface::class,\n  $workflowOptions\n);\n\n$result = $yourWorkflow->workflowMethod();\n\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```php\nuse Temporal\\WorkerFactory;\n\n// Create a Worker Factory\n$factory = WorkerFactory::create();\n\n// Set the Task Queue when creating the Worker\n$worker = $factory->newWorker(\"Workflow-Task-Queue-1\");\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(YourWorkflow::class);\n\n// start primary loop\n$factory->run();\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```php\nclass YourWorkflow implements YourWorkflowInterface\n{\n  private $yourActivity;\n\n  public function __construct()\n  {\n    // Create Activity options and set the Task Queue\n    $activityOptions = ActivityOptions::new()\n      ->withTaskQueue(\"Activity-Task-Queue-1\")\n      // ...\n\n    // Create a new Activity Stub and pass the options\n    $this->yourActivity = Workflow::newActivityStub(\n      YourActivityInterface::class,\n      $activityOptions\n    );\n  }\n\n  public function workflowMethod(): \\Generator\n  {\n    // Call the Activity\n    return yield $this->yourActivity->activityMethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```php\n//Create new Child Workflow Options and set the Task Queue\n$childWorkflowOptions = ChildWorkflowOptions::new()\n    ->withTaskQueue(\"Child-Workflow-Task-Queue-1\")\n    // ...\n\n// Create a new Child Workflow Stub and set the Task Queue\n$childWorkflow = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    $childWorkflowOptions\n);\n\n// Call the Child Workflow method\n$promise = $childWorkflow->workflowMethod();\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.","is_empty":false}},{"lang":"python","id":"python/how-to-set-a-workflow-task-queue-in-python","node":{"file_name":"how-to-set-a-workflow-task-queue-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-set-a-workflow-task-queue-in-python.md","id":"python/how-to-set-a-workflow-task-queue-in-python","title":"How to set the Task Queue for Workflow Execution in Python","description":"Task Queue","label":"Task Queue","tags":["python","how-to"],"markdown_content":"To set a Task Queue in Python, specify the `task_queue` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) methods.\n\n```python\nresult = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-set-a-workflow-task-queue-in-typescript","node":{"file_name":"how-to-set-a-workflow-task-queue-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-set-a-workflow-task-queue-in-typescript.md","id":"typescript/how-to-set-a-workflow-task-queue-in-typescript","title":"How to set a Workflow Task Queue in TypeScript","description":"Set a Workflow Task Queue","label":"Set a Workflow Task Queue","tags":["developer-guide","sdk","typescript"],"markdown_content":"A Task Queue is a dynamic queue in Temporal polled by one or more Workers.\n\nWorkers bundle Workflow code and node modules using Webpack v5 and execute them inside V8 isolates. Activities are directly required and run by Workers in the Node.js environment.\n\nWorkers are flexible. You can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers on a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker.\n- Workflow bundle, specify one of the following options:\n  - a `workflowsPath` to your `workflows.ts` file to pass to Webpack. For example, `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n  - Or pass a prebuilt bundle to `workflowBundle`, if you prefer to handle the bundling yourself.\n\n```ts\nimport {Worker} from \"@temporalio/worker\";\nimport * as activities from \"./activities\";\n\nasync function run() {\n  // Step 1: Register Workflows and Activities with the Worker and connect to\n  // the Temporal server.\n  const worker = await Worker.create({\n    workflowsPath: require.resolve(\"./workflows\"),\n    activities,\n    taskQueue: \"hello-world\",\n  });\n  // Worker connects to localhost by default and uses console.error for logging.\n  // Customize the Worker by passing more options to create():\n  // https://typescript.temporal.io/api/classes/worker.Worker\n  // If you need to configure server connection parameters, see docs:\n  // /typescript/security#encryption-in-transit-with-mtls\n\n  // Step 2: Start accepting tasks on the `tutorial` queue\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n`taskQueue` is the only required option; however, use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nWhen scheduling a Workflow, a `taskQueue` must be specified.\n\n```ts\nimport {Connection, WorkflowClient} from \"@temporalio/client\";\n// This is the code that is used to start a workflow.\nconst connection = await Connection.create();\nconst client = new WorkflowClient({connection});\nconst result = await client.execute(yourWorkflow, {\n  // required\n  taskQueue: \"your-task-queue\",\n  // required\n  workflowId: \"your-workflow-id\",\n});\n```\n\nWhen creating a Worker, you must pass the `taskQueue` option to the `Worker.create()` function.\n\n```ts\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: \"your-task-queue\",\n});\n```\n\nOptionally, in Workflow code, when calling an Activity, you can specify the Task Queue by passing the `taskQueue` option to `proxyActivities()`, `startChild()`, or `executeChild()`. If you do not specify a `taskQueue`, then the TypeScript SDK places Activity and Child Workflow Tasks in the same Task Queue as the Workflow Task Queue.","is_empty":false}}]},{"type":"h3","id":"app-dev-context/set-workflow-id","node":{"file_name":"set-workflow-id.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/set-workflow-id.md","id":"app-dev-context/set-workflow-id","title":"How to set a Workflow Id","description":"Although it is not required, we recommend providing your own Workflow Id that maps to a business process or business entity identifier, such as an order identifier or customer identifier.","label":"Workflow Id","tags":["guide-context"],"markdown_content":"Although it is not required, we recommend providing your own [Workflow Id](/workflows#workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-workflow-id-in-go","node":{"file_name":"how-to-set-a-workflow-id-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-workflow-id-in-go.md","id":"go/how-to-set-a-workflow-id-in-go","title":"How to set a custom Workflow Id in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Id","tags":["go","how-to"],"markdown_content":"Create an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: System generated UUID\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  ID: \"Your-Custom-Workflow-Id\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"java/how-to-set-a-workflow-id-in-java","node":{"file_name":"how-to-set-a-workflow-id-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-set-a-workflow-id-in-java.md","id":"java/how-to-set-a-workflow-id-in-java","title":"How to set a custom Workflow Id in Java","description":"Set the Workflow Id with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowId`.","label":"Workflow Id","tags":["Java","how-to","developer-guide"],"markdown_content":"Set the Workflow Id with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowId`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                // Set the Workflow Id\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```","is_empty":false}},{"lang":"php","id":"php/how-to-set-a-workflow-id-in-php","node":{"file_name":"how-to-set-a-workflow-id-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-set-a-workflow-id-in-php.md","id":"php/how-to-set-a-workflow-id-in-php","title":"How to set a Workflow Id in PHP","label":"Workflow Id","markdown_content":"The following code example grabs the `userID` as an input and uses it to start the Workflow. The `userID` is used as Workflow Id. You can use this to cancel your Workflow later.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(string $userID);\n}\n```\n\nThe following code example, uses the input parameter `userID` as the Workflow Id.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(\n        string $userID\n    );\n}\n```\n\nYou can also set the Workflow Id as a constant, for example:\n\n```php\n public const WORKFLOW_ID = Your-Workflow-Id\n```","is_empty":false}},{"lang":"python","id":"python/how-to-set-a-workflow-id-in-python","node":{"file_name":"how-to-set-a-workflow-id-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-set-a-workflow-id-in-python.md","id":"python/how-to-set-a-workflow-id-in-python","title":"How to set a Workflow Id in Python","description":"Set a Workflow Id","label":"Set a Workflow Id","tags":["developer-guide","sdk","python"],"markdown_content":"To set a Workflow Id in Python, specify the `id` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) methods.\n\nThe `id` argument should be a unique identifier for the Workflow Execution.\n\n```python\nresult = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-set-a-workflow-id-in-typescript","node":{"file_name":"how-to-set-a-workflow-id-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-set-a-workflow-id-in-typescript.md","id":"typescript/how-to-set-a-workflow-id-in-typescript","title":"How to set a Workflow Id in TypeScript","description":"Set a Workflow Id","label":"Set a Workflow Id","tags":["developer-guide","sdk","typescript"],"markdown_content":"Connect to a Client with `client.start()` and any arguments. Then specify your `taskQueue` and set your `workflowId` to a meaningful business identifier.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: \"yourWorkflowId\",\n  taskQueue: \"yourTaskQueue\",\n  args: [\"your\", \"arg\", \"uments\"],\n});\n```\n\nThis starts a new Client with the given Workflow Id, Task Queue name, and an argument.","is_empty":false}}]},{"type":"h3","id":"app-dev-context/get-workflow-results","node":{"file_name":"get-workflow-results.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/get-workflow-results.md","id":"app-dev-context/get-workflow-results","title":"How to get the results of a Workflow Execution","description":"If the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.","label":"Get Workflow results","tags":["guide-context"],"markdown_content":"If the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.\n\nThe Workflow Id, Run Id, and Namespace may be used to uniquely identify a Workflow Execution in the system and get its result.\n\nIt's possible to both block progress on the result (synchronous execution) or get the result at some other point in time (asynchronous execution).\n\nIn the Temporal Platform, it's also acceptable to use Queries as the preferred method for accessing the state and results of Workflow Executions.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-get-the-result-of-a-workflow-execution-in-go","node":{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-get-the-result-of-a-workflow-execution-in-go.md","id":"go/how-to-get-the-result-of-a-workflow-execution-in-go","title":"How to get the result of a Workflow Execution in Go","description":"Use the Future returned by `ExecuteWorkflow` API call to retrieve the result.","label":"Workflow Execution result","tags":["developer-guide","go"],"markdown_content":"The `ExecuteWorkflow` call returns an instance of [`WorkflowRun`](https://pkg.go.dev/go.temporal.io/sdk/client#WorkflowRun), which is the `workflowRun` variable in the following line.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, app.YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n // ...\n}\n```\n\nThe instance of `WorkflowRun` has the following three methods:\n\n- `GetWorkflowID()`: Returns the Workflow Id of the invoked Workflow Execution.\n- `GetRunID()`: Always returns the Run Id of the initial Run (See [Continue As New](#)) in the series of Runs that make up the full Workflow Execution.\n- `Get`: Takes a pointer as a parameter and populates the associated variable with the Workflow Execution result.\n\nTo wait on the result of Workflow Execution in the same process that invoked it, call `Get()` on the instance of `WorkflowRun` that is returned by the `ExecuteWorkflow()` call.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n}\n```\n\nHowever, the result of a Workflow Execution can be obtained from a completely different process.\nAll that is needed is the [Workflow Id](#).\n(A [Run Id](#) is optional if more than one closed Workflow Execution has the same Workflow Id.)\nThe result of the Workflow Execution is available for as long as the Workflow Execution Event History remains in the system.\n\n<!-- TODO (See [How long do Workflow Execution Histories persist](#)). -->\n\nCall the `GetWorkflow()` method on an instance of the Go SDK Client and pass it the Workflow Id used to spawn the Workflow Execution.\nThen call the `Get()` method on the instance of `WorkflowRun` that is returned, passing it a pointer to populate the result.\n\n```go\n // ...\n workflowID := \"Your-Custom-Workflow-Id\"\n workflowRun := c.GetWorkflow(context.Background, workflowID)\n\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n```\n\n**Get last completion result**\n\nIn the case of a [Temporal Cron Job](/workflows#temporal-cron-job), you might need to get the result of the previous Workflow Run and use it in the current Workflow Run.\n\nTo do this, use the [`HasLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#HasLastCompletionResult) and [`GetLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLastCompletionResult) APIs, available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package, directly in your Workflow code.\n\n```go\ntype CronResult struct {\n Count int\n}\n\nfunc YourCronWorkflowDefinition(ctx workflow.Context) (CronResult, error) {\n count := 1\n\n if workflow.HasLastCompletionResult(ctx) {\n   var lastResult CronResult\n   if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {\n     count = count + lastResult.Count\n   }\n }\n\n newResult := CronResult {\n   Count: count,\n }\n return newResult, nil\n}\n```\n\nThis will work even if one of the cron Workflow Runs fails.\nThe next Workflow Run gets the result of the last successfully Completed Workflow Run.","is_empty":false}},{"lang":"java","id":"java/how-to-get-the-result-of-a-workflow-execution-in-java","node":{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-get-the-result-of-a-workflow-execution-in-java.md","id":"java/how-to-get-the-result-of-a-workflow-execution-in-java","title":"How to get the result of a Workflow Execution in Java","description":"A synchronous Workflow Execution blocks your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure). An asynchronous Workflow Execution immediately returns a value to the caller.","label":"Workflow Execution Result","tags":["java","developer-guide"],"markdown_content":"A synchronous Workflow Execution blocks your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure).\n\nThe following example is a type-safe approach for getting the results of a synchronous Workflow Execution.\n\n```java\n FileProcessingWorkflow workflow = client.newWorkflowStub(\n                FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setWorkflowId(workflowId)\n                        .setTaskQueue(taskQueue)\n                        .build();\n\n// start sync and wait for results (or failure)\nString result = workflow.processfile(new Argument());\n```\n\nAn asynchronous Workflow Execution immediately returns a value to the caller.\n\nThe following examples show how to get the results of a Workflow Execution through typed and untyped `WorkflowStub`.\n\n- **Typed WorkflowStub Example**\n\n  ```java\n  // create typed Workflow stub\n  FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setTaskQueue(taskQueue)\n                        .setWorkflowId(workflowId)\n                        .build());\n  // use WorkflowClient.execute (if your Workflow takes in arguments) or WorkflowClient.start (for zero arguments)\n  WorkflowClient.start(workflow::greetCustomer);\n  ```\n\n- **Untyped WorkflowStub Example**\n\n  ```java\n  WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n                  WorkflowOptions.newBuilder()\n                          .setWorkflowId(workflowId)\n                          .setTaskQueue(taskQueue)\n                          .build());\n\n  // blocks until Workflow Execution has been started (not until it completes)\n  untyped.start(argument);\n  ```\n\nIf you need to wait for a Workflow Execution to complete after an asynchronous start, the most straightforward way is to call the blocking Workflow instance again.\n\nNote that if `WorkflowOptions.WorkflowIdReusePolicy` is not set to `AllowDuplicate`, then instead of throwing `DuplicateWorkflowException`, it reconnects to an existing Workflow and waits for its completion.\n\nThe following example shows how to do this from a different process than the one that started the Workflow Execution.\n\n```java\nYourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflow.yourMethod();\n```\n\nAnother way to connect to an existing Workflow and wait for its completion from another process, is to use `UntypedWorkflowStub`. For example:\n\n```java\nWorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = untyped.getResult(String.class);\n```\n\n**Get last (successful) completion result**\n\nFor a Temporal Cron Job, get the result of previous successful runs using `GetLastCompletionResult()`.\nThe method returns `null` if there is no previous completion.\nThe following example shows how to implement this in a Workflow.\n\n```java\npublic String cronWorkflow() {\n    String lastProcessedFileName = Workflow.getLastCompletionResult(String.class);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the Cron schedule runs failed.\nThe next schedule will still get the last successful result if it ever successfully completed at least once.\nFor example, for a daily cron Workflow, if the run succeeds on the first day and fails on the second day, then the third day run will get the result from first day's run using these APIs.","is_empty":false}},{"lang":"php","id":"php/how-to-get-the-result-of-a-workflow-execution-in-php","node":{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-get-the-result-of-a-workflow-execution-in-php.md","id":"php/how-to-get-the-result-of-a-workflow-execution-in-php","title":"How to get the result of an Workflow Execution in PHP","label":"Workflow Execution","markdown_content":"If you need to wait for the completion of a Workflow after an asynchronous start, make a blocking call to\nthe `WorkflowRun`->`getResult` method.\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getResult());\n```","is_empty":false}},{"lang":"python","id":"python/how-to-get-the-result-of-a-workflow-execution-in-python","node":{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-get-the-result-of-a-workflow-execution-in-python.md","id":"python/how-to-get-the-result-of-a-workflow-execution-in-python","title":"How to get the result of a Workflow Execution in python","description":"Workflow Execution result","label":"Workflow Execution result","tags":["developer-guide","python"],"markdown_content":"Use [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.client#get_workflow_handle) to return a Workflow handle.\nThen use the [`result`](https://python.temporal.io/temporalio.client.workflowhandle#result) method to await on the result of the Workflow.\n\n```python\nhandle = await client.start_workflow(\n    YourWorkflow.run, \"some arg\", id=\"your-workflow-id\", task_queue=\"your-task-queue\"\n)\n\n# Wait for result\nresult = await handle.result()\nprint(f\"Result: {result}\")\n```\n\nTo get a handle for an existing Workflow by its Id, you can use [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.client#get_workflow_handle), or use [`get_workflow_handle_for()`](https://python.temporal.io/temporalio.client.client#get_workflow_handle_for) for type safety.\n\nThen use [`describe()`](https://python.temporal.io/temporalio.client.workflowhandle#describe) to get the current status of the Workflow.\nIf the Workflow does not exist, this call fails.","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript","node":{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript.md","id":"typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript","title":"How to get the result of a Workflow execution in TypeScript","description":"Get the result of a Workflow execution","label":"Workflow result","tags":["developer-guide","sdk","typescript"],"markdown_content":"To return the results of a Workflow Execution:\n\n```typescript\nreturn (\n  \"Completed \" +\n  wf.workflowInfo().workflowId +\n  \", Total Charged: \" +\n  totalCharged\n);\n```\n\n`totalCharged` is just a function declared in your code. For a full example, see [subscription-workflow-project-template-typescript/src/workflows.ts](https://github.com/temporalio/subscription-workflow-project-template-typescript/blob/main/src/workflows.ts).\n\nA Workflow function may return a result. If it doesnt (in which case the return type is `Promise<void>`), the result will be `undefined`.\n\nIf you started a Workflow with `handle.start()`, you can choose to wait for the result anytime with `handle.result()`.\n\n```typescript\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nUsing a Workflow Handle isn't necessary with `client.execute()`.\n\nWorkflows that prematurely end will throw a `WorkflowFailedError` if you call `result()`.\n\nIf you call `result()` on a Workflow that prematurely ended for some reason, it throws a [`WorkflowFailedError` error](https://typescript.temporal.io/api/classes/client.workflowfailederror/) that reflects the reason. For that reason, it is recommended to catch that error.\n\n```typescript\nconst handle = client.getHandle(workflowId);\ntry {\n  const result = await handle.result();\n} catch (err) {\n  if (err instanceof WorkflowFailedError) {\n    throw new Error(\"Temporal workflow failed: \" + workflowId, {\n      cause: err,\n    });\n  } else {\n    throw new Error(\"error from Temporal workflow \" + workflowId, {\n      cause: err,\n    });\n  }\n}\n```","is_empty":false}}]}],"link_index":[{"file_dir":"application-development","guide_id":"foundations","local_ref":"","node_id":"app-dev-context/foundations"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-a-dev-cluster","node_id":"clusters/quick-install"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"app-dev-context/add-sdk"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"go/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"java/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"php/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"python/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"typescript/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"app-dev-context/api-reference"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"go/api-reference-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"java/api-reference-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"python/api-reference-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"typescript/api-reference-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"app-dev-context/code-samples"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"go/code-samples-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"java/code-samples-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"php/code-samples-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"python/code-samples-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"typescript/code-samples-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"app-dev-context/connect-to-a-cluster"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"go/how-to-connect-to-a-cluster-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"java/how-to-create-a-temporal-client-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"php/how-to-create-a-temporal-client-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"python/how-to-connect-to-a-cluster-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"typescript/how-to-connect-to-a-cluster-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"app-dev-context/developing-workflows"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"go/how-to-develop-a-workflow-definition-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"java/how-to-develop-a-workflow-definition-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"php/how-to-develop-a-workflow-definition-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"python/how-to-develop-a-workflow-definition-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"typescript/how-to-develop-a-workflow-definition-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"app-dev-context/workflow-parameters"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"go/how-to-define-workflow-parameters-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"java/how-to-define-workflow-parameters-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"php/how-to-define-workflow-parameters-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"python/how-to-define-workflow-parameters-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"typescript/how-to-define-workflow-parameters-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"app-dev-context/workflow-return-values"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"go/how-to-define-workflow-return-values-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"java/how-to-define-workflow-return-values-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"php/how-to-define-workflow-return-values-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"python/how-to-define-workflow-return-values-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"typescript/how-to-define-workflow-return-values-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"app-dev-context/customize-workflow-type"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"go/how-to-customize-workflow-type-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"java/how-to-customize-workflow-type-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"python/how-to-customize-workflow-type-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"typescript/how-to-customize-workflow-type-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"app-dev-context/workflow-logic-requirements"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"go/how-to-handle-workflow-logic-requirements-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"java/how-to-handle-workflow-logic-requirements-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"php/how-to-handle-workflow-logic-requirements-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"python/how-to-handle-workflow-logic-requirements-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"app-dev-context/developing-activities"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"go/how-to-develop-an-activity-definition-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"java/how-to-develop-an-activity-definition-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"php/how-to-develop-an-activity-definition-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"python/how-to-develop-an-activity-definition-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"typescript/how-to-develop-an-activity-definition-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"app-dev-context/activity-parameters"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"go/how-to-define-activity-parameters-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"java/how-to-define-activity-parameters-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"php/how-to-define-activity-parameters-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"python/how-to-define-activity-parameters-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"typescript/how-to-define-activity-parameters-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"app-dev-context/activity-return-values"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"go/how-to-define-activity-return-values-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"java/how-to-define-activity-return-values-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"php/how-to-define-activity-return-values-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"python/how-to-define-activity-return-values-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"typescript/how-to-define-activity-return-values-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"app-dev-context/customize-activity-type"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"go/how-to-customize-activity-type-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"java/how-to-customize-activity-type-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"python/how-to-customize-activity-type-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"typescript/how-to-customize-activity-type-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"app-dev-context/spawning-activities"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"go/how-to-spawn-an-activity-execution-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"java/how-to-spawn-an-activity-execution-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"php/how-to-spawn-an-activity-execution-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"python/how-to-spawn-an-activity-execution-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"typescript/how-to-spawn-an-activity-execution-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"required-timeout","node_id":"app-dev-context/required-activity-timeout"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"app-dev-context/get-activity-results"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"go/how-to-get-the-result-of-an-activity-execution-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"java/how-to-get-the-result-of-an-activity-execution-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"php/how-to-get-the-result-of-an-activity-execution-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"python/how-to-get-the-result-of-an-activity-execution-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"typescript/how-to-get-the-result-of-an-activity-execution-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"app-dev-context/run-worker-processes"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"go/how-to-develop-a-worker-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"java/how-to-develop-a-worker-program-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"php/how-to-develop-a-worker-program-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"python/how-to-develop-a-worker-program-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"typescript/how-to-develop-a-worker-program-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"app-dev-context/registering-types"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"go/how-to-register-types-with-a-worker-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"java/how-to-register-types-with-a-worker-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"php/how-to-register-types-with-a-worker-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"python/how-to-register-types-with-a-worker-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"typescript/how-to-register-types-with-a-worker-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"app-dev-context/spawning-workflows"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"go/how-to-spawn-a-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"java/how-to-spawn-a-workflow-execution-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"php/how-to-spawn-a-workflow-execution-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"python/how-to-spawn-a-workflow-execution-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"typescript/how-to-spawn-a-workflow-execution-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"app-dev-context/set-task-queue"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"go/how-to-set-a-workflow-task-queue-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"java/how-to-set-a-workflow-task-queue-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"php/how-to-set-a-workflow-task-queue-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"python/how-to-set-a-workflow-task-queue-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"typescript/how-to-set-a-workflow-task-queue-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"app-dev-context/set-workflow-id"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"go/how-to-set-a-workflow-id-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"java/how-to-set-a-workflow-id-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"php/how-to-set-a-workflow-id-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"python/how-to-set-a-workflow-id-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"typescript/how-to-set-a-workflow-id-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"app-dev-context/get-workflow-results"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"go/how-to-get-the-result-of-a-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"java/how-to-get-the-result-of-a-workflow-execution-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"php/how-to-get-the-result-of-a-workflow-execution-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"python/how-to-get-the-result-of-a-workflow-execution-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript"}],"markdown_content":"---\nid: foundations\ntitle: Application development - Foundations\nsidebar_label: Foundations\ndescription: The Foundations section of the Temporal Application development guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application  that is, all the relevant steps to start a Workflow Execution that executes an Activity.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nThe Foundations section of the Temporal Application development guide covers the minimum set of concepts and implementation details needed to build and run a [Temporal Application](/temporal#temporal-application)that is, all the relevant steps to start a [Workflow Execution](/workflows#workflow-execution) that executes an [Activity](/activities#activity-execution).\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Application development guide, it could be in [older docs for SDKs](/sdks).\n\n:::\n\nIn this section you can find the following:\n\n- [How to run a dev Cluster](#run-a-dev-cluster)\n- [How to add your SDK](#add-your-sdk)\n- [How to create a Temporal Client](#create-temporal-clients)\n- [How to develop a Workflow](#develop-workflows)\n- [How to develop an Activity](#develop-activities)\n- [How to start an Activity Execution](#start-activity-execution)\n- [How to run a Worker Process](#run-worker-processes)\n- [How to start a Workflow Execution](#start-workflow-execution)\n\n## Run a dev Cluster\n\nThe following sections list various methods of deploying your [Temporal Clusters](/clusters#) locally, so that you can use and interact with the [Temporal Client](/temporal#temporal-client) APIs and [tctl](/tctl) commands to test and develop applications.\n\n- [Temporalite](#temporalite): This distribution of Temporal runs as a single process with zero runtime dependencies.\n- [Docker](#docker-compose): Using Docker Compose simplifies developing your Temporal Application.\n- [Gitpod](#gitpod): One-click deployments are available for Go and TypeScript.\n\n**For information on deploying a [production environment](/server/production-deployment), see the [Temporal Cloud](/cloud) documentation.**\n\n### Temporalite\n\nTemporalite is a distribution of Temporal that runs as a single process with zero runtime dependencies.\nIt supports persistence to disk and in-memory mode through SQLite.\n\n**Prerequisites**\n\nTemporalite requires Go 1.18 or later.\n\n**Build and start Temporalite**\n\nThe following steps start and run a Temporal Cluster.\n\n1. Build from source by using `go install`.\n   ```bash\n   go install github.com/temporalio/temporalite/cmd/temporalite@latest\n   ```\n2. Start Temporalite by using the `start` command.\n   ```bash\n   temporalite start --namespace default\n   ```\n   Replace `default` with your [Namespace Name](/cloud/#temporal-cloud-namespace-name).\n\n**Results**: You should have Temporal Cluster running at `http://127.0.0.1:7233` and the Temporal Web UI at [`http://127.0.0.1:8233`](http://127.0.0.1:8233/namespaces/default/workflows).\n\n<!-- For macOS users, if you receive the `error setting up schema: stat /Users/<user_name>/Library/Application Support/temporalite/db:` error, then create the folders `temporalite/db` in your `Application Support` library. -->\n\n### Docker Compose\n\nUse Docker Compose and Temporal Cluster Docker images to quickly install and run a Temporal Cluster locally while developing Temporal Applications.\n\n**Prerequisites**\n\nInstall [Docker](https://docs.docker.com/engine/install) and [Docker Compose](https://docs.docker.com/compose/install).\n\n**Clone the repo and run Docker Compose**\n\nThe following steps start and run a Temporal Cluster using the default configuration.\n\n1. Clone the [temporalio/docker-compose](https://github.com/temporalio/docker-compose) repository.\n   ```bash\n   git clone https://github.com/temporalio/docker-compose.git\n   ```\n2. Change to the directory for the project.\n   ```bash\n   cd docker-compose\n   ```\n3. From your project directory, start your application.\n   ```bash\n   docker-compose up\n   ```\n\n**Results**: You should have Temporal Cluster running at `http://127.0.0.1:7233` and the Temporal Web UI at [`http://127.0.0.1:8080`](http://127.0.0.1:8080/namespaces/default/workflows).\n\nTo try other configurations (different dependencies and databases), or to try a custom Docker image, follow the [temporalio/docker-compose README](https://github.com/temporalio/docker-compose/blob/main/README.md).\n\n### Gitpod\n\nYou can run a Temporal Cluster and develop Temporal Applications in your browser using [Gitpod](https://gitpod.io/#https://github.com/temporalio/samples-typescript/).\n\nOne-click deployments are available for the [temporalio/samples-go](https://github.com/temporalio/samples-go) repo and the [temporalio/samples-typescript](https://github.com/temporalio/samples-typescript) repo.\n\nA one-click deployment starts a Temporal Cluster using a Temporal Cluster Docker image, starts a Worker Process, and starts one of the application's sample Workflows.\n\nA one-click deployment can take up to a full minute to get fully up and running.\nWhen it is running, you can customize the application samples.\n\n## Add your SDK\n\nA [Temporal SDK](/temporal#temporal-sdk) provides a framework for [Temporal Application](/temporal#temporal-application) development.\n\nAn SDK provides you with the following:\n\n- A [Temporal Client](/temporal#temporal-client) to communicate with a [Temporal Cluster](/clusters#).\n- APIs to develop [Workflows](/workflows#).\n- APIs to create and manage [Worker Processes](/workers#).\n- APIs to author [Activities](/activities#activity-definition).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\n[![Build Status](https://badge.buildkite.com/ce6df3b1a8b375270261ae70fb2d2756af298fef3a0dac4d20.svg?theme=github&branch=master)](https://buildkite.com/temporal/temporal-go-client) [![Coverage Status](https://coveralls.io/repos/github/temporalio/temporal-go-sdk/badge.svg?branch=master)](https://coveralls.io/github/temporalio/temporal-go-sdk?branch=master) [![Go reference](https://pkg.go.dev/badge/go.temporal.io/sdk)](https://pkg.go.dev/go.temporal.io/sdk)\n\nAdd the [Temporal Go SDK](https://github.com/temporalio/sdk-go) to your project:\n\n```bash\ngo get -u go.temporal.io/sdk@latest\n```\n\nOr clone the Go SDK repo to your preferred location:\n\n```bash\ngit clone git@github.com:temporalio/sdk-go.git\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\n[![Build status](https://badge.buildkite.com/663f6d1be81be6700c28c242b35905f20b68c4fda7b2c7c4e3.svg?branch=master)](https://buildkite.com/temporal/java-sdk-public)\n\nAdd the [Temporal Java SDK](https://github.com/temporalio/sdk-java) to your project as a dependency:\n\n**[Apache Maven](https://maven.apache.org/)**:\n\n```maven\n<dependency>\n  <groupId>io.temporal</groupId>\n  <artifactId>temporal-sdk</artifactId>\n  <version>1.11.0</version>\n</dependency>\n```\n\n**[Gradle Groovy DSL](https://gradle.org/)**:\n\n```groovy\nimplementation 'io.temporal:temporal-sdk:1.11.0'\n```\n\n**Other**:\n\nAdditional scripts for each SDK version are available here: [https://search.maven.org/artifact/io.temporal/temporal-sdk](https://search.maven.org/artifact/io.temporal/temporal-sdk).\nSelect an SDK version to see available scripts.\n\n</TabItem>\n<TabItem value=\"php\">\n\n[![CI Status](https://github.com/temporalio/php-sdk/workflows/Unit/badge.svg)](https://github.com/temporalio/php-sdk/actions)\n[![Stable Release](https://poser.pugx.org/temporal/sdk/version)](https://packagist.org/packages/temporal/sdk)\n[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php?ref=badge_shield)\n\nThe Temporal PHP SDK is available as composer package and can be installed using the following command in a root of your project:\n\n```bash\ncomposer require temporal/sdk\n```\n\nThe Temporal PHP SDK requires the RoadRunner 2.0 application server and supervisor to run Activities and Workflows in a scalable way.\n\nInstall RoadRunner manually by downloading its binary from the [release page](https://github.com/roadrunner-server/roadrunner/releases/tag/v1.9.2).\n\nOr install RoadRunner through the CLI:\n\n```bash\ncomposer require spiral/roadrunner:v2.0 nyholm/psr7\n./vendor/bin/rr get-binary\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\n[![Python 3.7+](https://img.shields.io/pypi/pyversions/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n[![PyPI](https://img.shields.io/pypi/v/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n\nTo install the latest version of the Temporal Python package, run the following command.\n\n```bash\npip install temporalio\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n[![NPM](https://img.shields.io/npm/v/temporalio.svg?style=for-the-badge)](https://www.npmjs.com/search?q=author%3Atemporal-sdk-team)\n\nThis project requires Node.js 14 or later.\n\n**Create a new project**\n\n```bash\nnpx @temporalio/create@latest ./your-app\n```\n\n**Add to an existing project**\n\n```bash\nnpm install @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity @temporalio/common\n```\n\n:::note\n\nThe TypeScript SDK is designed with TypeScript-first developer experience in mind, but it works equally well with JavaScript.\n\n:::\n\n</TabItem>\n</Tabs>\n\n#### API reference\n\nEach SDK has its own API reference. Select a programming language and follow the link to be taken to that reference page.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nThe Temporal Go SDK API reference is published on [pkg.go.dev](https://pkg.go.dev/go.temporal.io/sdk).\n\n</TabItem>\n<TabItem value=\"java\">\n\nThe Temporal Java SDK API reference is published on [javadoc.io](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/index.html).\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"python\">\n\nThe Temporal Python SDK API reference is published on [python.temporal.io](https://python.temporal.io/index.html).\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nThe Temporal TypeScript SDK API reference is published on [typescript.temporal.io](https://typescript.temporal.io).\n\n</TabItem>\n</Tabs>\n\n#### Code samples\n\nYou can find a complete list of executable code samples in [Temporal's GitHub repository](https://github.com/temporalio?q=samples-&type=all&language=&sort=).\n\nAdditionally, several of the [Tutorials](https://learn.temporal.io) are backed by a fully executable template application.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\n- [Go Samples repo](https://github.com/temporalio/samples-go#samples-directory)\n- [Background Check application](https://github.com/temporalio/background-checks): Provides a non-trivial Temporal Application implementation in conjunction with [application documentaion](https://learn.temporal.io/examples/go/background-checks/).\n- [Hello world application template in Go](https://github.com/temporalio/hello-world-project-template-go): Provides a quick-start development app for users.\n  This sample works in conjunction with the [\"Hello World!\" from scratch tutorial in Go](https://learn.temporal.io/getting_started/go/hello_world_in_go/).\n- [Money transfer application template in Go](https://github.com/temporalio/money-transfer-project-template-go): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Go](https://learn.temporal.io/getting_started/go/first_program_in_go/).\n- [Subscription-style Workflow Definition in Go](https://github.com/temporalio/subscription-workflow-project-template-go): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n- [eCommerce application example in Go](https://github.com/temporalio/temporal-ecommerce): Showcases a per-user shopping cartstyle Workflow Definition that includes an API for adding and removing items from the cart as well as a web UI.\n  This application sample works in conjunction with the [eCommerce in Go tutorial](https://temporal.io/blog/build-an-ecommerce-app-with-temporal-part-1).\n\n</TabItem>\n<TabItem value=\"java\">\n\n- [Java samples library](https://github.com/temporalio/samples-java)\n- [Hello world application template in Java](https://github.com/temporalio/hello-world-project-template-java): Provides a quick-start development app for users.\n  Works in conjunction with the [\"Hello World!\" from scratch tutorial in Java](https://learn.temporal.io/getting_started/java/hello_world_in_java/).\n- [Money transfer application template in Java](https://github.com/temporalio/money-transfer-project-template-java): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Java](https://learn.temporal.io/getting_started/java/first_program_in_java/).\n- [Subscription-style Workflow Definition in Java](https://github.com/temporalio/subscription-workflow-project-template-java): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n\n</TabItem>\n<TabItem value=\"php\">\n\n- [PHP samples repo](https://github.com/temporalio/samples-php)\n\n- [Subscription-style Workflow Definition in PHP](https://github.com/temporalio/subscription-workflow-project-template-php): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n\n</TabItem>\n<TabItem value=\"python\">\n\n- [Python samples library](https://github.com/temporalio/samples-python)\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nUse the [TypeScript samples library](https://github.com/temporalio/samples-typescript) stored on GitHub to demonstrate various capabilities of Temporal.\n\n**Where can I find video demos?**\n\n[Temporal Go TypeScript YouTube playlist](https://www.youtube.com/playlist?list=PLl9kRkvFJrlTavecydpk9r6cF7qBmQJvb).\n\n</TabItem>\n</Tabs>\n\n## Connect to a Cluster\n\nA [Temporal Client](/temporal#temporal-client) enables you to communicate with a [Temporal Cluster](/clusters#).\nCommunications with a Temporal Cluster include, but aren't limited to, the following:\n\n- starting Workflow Executions\n- sending Signals to Workflow Executions\n- sending Queries to Workflow Executions\n- getting the results of a Workflow Execution\n- providing an Activity Task Token\n\n:::caution\n\nA Temporal Client cannot be initialized and used inside Workflow code.\nHowever, it is acceptable and common to use a Temporal Client inside an Activity to communicate with the Temporal Cluster.\n\n:::\n\nWhen you are running a Cluster locally (such as [temporalite](/clusters/quick-install#temporalite)), the number of connection options you must provide is minimal.\nMany SDKs default to the local host or IP address and port that temporalite and [Docker Compose](/clusters/quick-install#docker-compose) serve (`127.0.0.1:7233`).\n\nWhen you are connecting to a production Cluster (such as [Temporal Cloud](/cloud/index#)), you will likely need to provide additional connection and client options that might include, but aren't limited to, the following:\n\n- address and port\n- [Namespace](/namespaces#) (like a Temporal Cloud Namespace: `<Namespace_ID>.tmprl.cloud`)\n- mTLS CA certificate\n- mTLS private key\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter and intra network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nUse the [`Dial()`](https://pkg.go.dev/go.temporal.io/sdk/client#Dial) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to create a new [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nIf you don't provide [`HostPort`](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions), the Client defaults the address and port number to `127.0.0.1:7233`.\n\nSet a custom Namespace name in the Namespace field on an instance of the Client Options.\n\nUse the [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#ConnectionOptions) API to connect a Client with mTLS.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\nfunc main() {\n    cert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n    if err != nil {\n        return err\n    }\n    client, err := client.Dial(client.Options{\n        HostPort:  \"your-custom-namespace.tmprl.cloud:7233\",\n        Namespace: \"your-custom-namespace\",\n        ConnectionOptions: client.ConnectionOptions{\n            TLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n        },\n    }\n    defer temporalClient.Close()\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo initialize a Workflow Client, create an instance of a `WorkflowClient`, create a client-side `WorkflowStub`, and then call a Workflow method (annotated with `@WorkflowMethod`).\n\nTo start a Workflow Execution, your Temporal Server must be running, and your front-end service must be accepting gRPC calls.\n\nTo establish a connection with the front-end service, use `WorkflowServiceStubs`.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n```\n\nYou can provide `WorkflowServiceStubsOptions` to override the default values for the gRPC calls.\n\nFor example, the default front-end service gRPC address is set to `127.0.0.1:7233`, where `7233` is the default port for the Temporal Frontend Service.\n\nIf your server is running on a different host or port from the default, you can set it as shown in the following example.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newInstance(\n                    WorkflowServiceStubsOptions.newBuilder()\n                     .setTarget(TARGET_ENDPOINT)\n                            .build());\n\n```\n\nAfter the connection to the Temporal Frontend Service is established, create a Client for the service stub.\nThe Workflow Client helps with client-side APIs and is required by Workers.\n\nCreate an instance of a `WorkflowClient` for the Workflow service stub, and use `WorkflowClientOptions` to set options for the Workflow Client.\nThe following example shows how to create a `WorkflowClient` instance called \"client\" for the `WorkflowServiceStubs` \"service\" that we created in the previous example, and set `Namespace` option for the `WorkflowClient`.\n\n```java\nWorkflowClient client = WorkflowClient.newInstance(\n                service,\n                WorkflowClientOptions.newBuilder()\n                        .setNamespace(Abc)\n                    .build());\n\n```\n\nFor more information, see [WorkflowClientOptions](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClientOptions.Builder.html).\n\n`WorkflowService` and `WorkflowClient` creation is a heavyweight operation, and will be resource-intensive if created each time you start a Workflow or send a Signal to it.\nThe recommended way is to create them once and reuse where possible.\n\nWith the Client defined, you can start interacting with the Temporal Frontend Service.\n\nTo initialize a Workflow in the Client, create a `WorkflowStub`, and start the Workflow Execution with `WorkflowClient.start()`.\nStarting Workflows or sending Signals or Queries to Workflows from within a Client must be done using `WorkflowStubs`.\n\n```java\nWorkflowClient workflowClient =  WorkflowClient.newInstance(service, clientOptions);\n // Create a Workflow stub.\n YourWorkflow workflow = workflowClient.newWorkflowStub(YourWorkflow.class);\n // Start Workflow asynchronously and call its \"yourWFMethod\" Workflow method\n WorkflowClient.start(workflow::yourWFMethod);\n```\n\nFor more information, see the following:\n\n- [How to spawn a Workflow Execution in Java](#start-workflow-execution)\n\n</TabItem>\n<TabItem value=\"php\">\n\nThe following example represents a console command that starts a Workflow, prints its IDs, and then waits for its result:\n\n<!--SNIPSTART php-hello-client {\"enable_source_link\": true}-->\n<!--SNIPEND-->\n\nThe `WorkflowClientInterface` in the snippet is an entry point to get access to Workflow.\nUse an instance of `WorkflowClientInterface` to create, retrieve, or start a Workflow.\nHere we create an instance of `GreetingWorkflowInterface` with a Workflow Execution Timeout of one minute.\n\nThen we print some information and start the Workflow.\n\n</TabItem>\n<TabItem value=\"python\">\n\nUse [`connect()`](https://python.temporal.io/temporalio.client.client#connect) method on the [`Client`](https://python.temporal.io/temporalio.client.client) class to create and connect to a Temporal Client to the Temporal Cluster.\n\nSpecify the `target_host` parameter as a string and provide the [`tls` configuration](https://python.temporal.io/temporalio.service.tlsconfig) for connecting to a Temporal Cluster.\n\n```python\n    client = await Client.connect(\n        #  target_host for the Temporal Cloud\n        \"your-custom-namespace.tmprl.cloud:7233\",\n        # target_host for Temporalite\n        # \"127.0.0.1:7233\"\n        namespace=\"your-custom-namespace\",\n        tls=TLSConfig(\n            client_cert=client_cert,\n            client_private_key=client_private_key,\n            # domain=domain\n            # server_root_ca_cert=server_root_ca_cert,\n        ),\n    )\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nDeclaring the `WorflowClient()` creates a new connection to the Temporal service.\n\nIf you omit the connection and just call the `new WorkflowClient()`, you create a default connection that works locally.\nHowever, always configure your connection and Namespace when [deploying to production](/typescript/security/#encryption-in-transit-with-mtls).\n\nUse the [`connectionOptions`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions) API available in the [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.WorkflowClient) package to create a new [`client`](https://typescript.temporal.io/api/namespaces/client/) to communicate with a Temporal Cluster.\n\nUse a new `WorflowClient()` with the requisite gRPC [`Connection`](https://typescript.temporal.io/api/classes/client.Connection#service) to connect to a Client and set your Namespace name.\n\nUse the [`connectionOptions`](https://typescript.temporal.io/api/interfaces/client.TLSConfig) API to connect a Client with mTLS.\n\n```typescript\nimport fs from \"fs-extra\";\nimport {Connection, WorkflowClient} from \"@temporalio/client\";\nimport path = from \"path\";\n\nasync function run() {\n  const cert = await fs.readFile(\"./path-to/your.pem\");\n  const key = await fs.readFile(\"./path-to/your.key\");\n\n  const connectionOptions = {\n    address: \"your-custom-namespace.tmprl.cloud:7233\",\n    tls: {\n      clientCertPair: {\n        crt: cert,\n        key: key,\n      },\n    // serverRootCACertificatePath: \"ca.cert\",\n    },\n  };\n  const connection = await Connection.connect(connectionOptions);\n\n  const client = new WorkflowClient({\n    connection,\n    // connects to 'default' namespace if not specified\n    namespace: \"your-custom-namespace\",\n  });\n\n    // . . .\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n</TabItem>\n</Tabs>\n\n## Develop Workflows\n\nWorkflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/workflows#workflow-definition).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nIn the Temporal Go SDK programming model, a [Workflow Definition](/workflows#workflow-definition) is an exportable function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context) error {\n  // ...\n  return nil\n}\n```\n\nIn Go, by default, the Workflow Type name is the same as the function name.\n\n</TabItem>\n<TabItem value=\"java\">\n\nIn the Temporal Java SDK programming model, a Workflow definition comprises a Workflow interface annotated with `@WorkflowInterface` and a Workflow implementation that implements the Workflow interface.\n\nThe Workflow interface is a Java interface and is annotated with `@WorkflowInterface`.\nEach Workflow interface must have only one method annotated with `@WorkflowMethod`.\nThe method name can be used to denote the Workflow Type.\n\n```java\n// Workflow interface\n@WorkflowInterface\npublic interface YourWorkflow {\n\n    @WorkflowMethod\n    String yourWFMethod(Arguments args);\n}\n```\n\nHowever, when using dynamic Workflows, do not specify a `@WorkflowMethod`, and implement the `DynamicWorkflow` directly in the Workflow implementation code.\n\nThe `@WorkflowMethod` identifies the method that is the starting point of the Workflow Execution.\nThe Workflow Execution completes when this method completes.\n\nYou can create interface inheritance hierarchies to reuse components across other Workflow interfaces.\nThe interface inheritance approach does not apply to `@WorkflowMethod` annotations.\n\nA Workflow implementation implements a Workflow interface.\n\n```java\n// Define the Workflow implementation which implements our getGreeting Workflow method.\n  public static class GreetingWorkflowImpl implements GreetingWorkflow {\n      ...\n    }\n  }\n```\n\nTo call Activities in your Workflow, call the Activity implementation.\n\nUse `ExternalWorkflowStub` to start or send Signals from within a Workflow to other running Workflow Executions.\n\nYou can also invoke other Workflows as Child Workflows with `Workflow.newChildWorkflowStub()` or `Workflow.newUntypedChildWorkflowStub()` within a Workflow Definition.\n\nUse [`DynamicWorkflow`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/DynamicWorkflow.html) to implement Workflow Types dynamically.\nRegister a Workflow implementation type that extends `DynamicWorkflow` to implement any Workflow Type that is not explicitly registered with the Worker.\n\nThe dynamic Workflow interface is implemented with the `execute` method. This method takes in `EncodedValues` that are inputs to the Workflow Execution.\nThese inputs can be specified by the Client when invoking the Workflow Execution.\n\n```java\npublic class MyDynamicWorkflow implements DynamicWorkflow {\n   @Override\n    public Object execute(EncodedValues args) {\n    }\n}\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\nIn PHP, a Workflow is a class method. Classes must implement interfaces that are annotated with `#[WorkflowInterface]`. The method that is the Workflow must be annotated with `#[WorkflowMethod]`.\n\n```php\nuse Temporal\\Workflow\\YourWorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n}\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nWorkflows in Python are defined as classes.\n\nSpecify the [`@workflow.defn`](https://python.temporal.io/temporalio.workflow.html#defn) decorator on the Workflow class to register a Workflow class.\n\nUse the [`@workflow.run`](https://python.temporal.io/temporalio.workflow.html#run) to mark the entry point method to be invoked. This must be set on one asynchronous method defined on the same class as `@workflow.defn`. Run methods have positional parameters.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nWorkflow Definitions are _just functions_, which can store state and orchestrate Activity Functions.\nThe following code snippet uses `proxyActivities` to schedule a `greet` Activity in the system to say hello.\n\nA Workflow Definition can have multiple parameters; however, we recommend using a single object parameter.\n\n```typescript\ntype ExampleArgs = {\n  name: string;\n};\n\nexport async function example(args: ExampleArgs): Promise<{greeting: string}> {\n  const greeting = await greet(args.name);\n  return {greeting};\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Workflow parameters\n\nTemporal Workflows may have any number of custom parameters.\nHowever, it is strongly recommended that objects are used as parameters, so that the object's individual fields may be altered without breaking the signature of the Workflow.\nAll Workflow Definition parameters must be serializable.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nThe first parameter of a Go-based Workflow Definition must be of the [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context) type, as it is used by the Temporal Go SDK to pass around Workflow Execution context, and virtually all the Go SDK APIs that are callable from the Workflow require it.\nIt is acquired from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package.\n\n```go\nimport (\n   \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param string) error {\n // ...\n}\n```\n\nThe `workflow.Context` entity operates similarly to the standard `context.Context` entity provided by Go.\nThe only difference between `workflow.Context` and `context.Context` is that the `Done()` function, provided by `workflow.Context`, returns `workflow.Channel` instead of the standard Go `chan`.\n\nThe second parameter, `string`, is a custom parameter that is passed to the Workflow when it is invoked.\nA Workflow Definition may support multiple custom parameters, or none.\nThese parameters can be regular type variables or safe pointers.\nHowever, the best practice is to pass a single parameter that is of a `struct` type, so there can be some backward compatibility if new parameters are added.\n\n```go\ntype YourWorkflowParam struct {\n WorkflowParamFieldOne string\n WorkflowParamFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n // ...\n}\n```\n\nAll Workflow Definition parameters must be serializable, regardless of whether pointers or regular type values are used.\nParameters cant be channels, functions, variadic, or unsafe pointers.\n\n</TabItem>\n<TabItem value=\"java\">\n\nA method annotated with `@WorkflowMethod` can have any number of parameters.\n\nWe recommend passing a single parameter that contains all the input fields to allow for adding fields in a backward-compatible manner.\n\nNote that all inputs should be serializable by the default Jackson JSON Payload Converter.\n\nYou can create a custom object and pass it to the Workflow method, as shown in the following example.\n\n```java\n//...\n@WorkflowInterface\npublic interface YourWorkflow {\n    @WorkflowMethod\n    String yourWFMethod(CustomObj customobj);\n// ...\n}\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\nA method annotated with `#[WorkflowMethod]` can have any number of parameters.\n\nWe recommend passing a single parameter that contains all the input fields to allow for adding fields in a backward-compatible manner.\n\nNote that all inputs should be serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\nYou can create a custom object and pass it to the Workflow method, as shown in the following example:\n\n```php\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n}\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nWorkflow parameters are the method parameters of the singular method decorated with `@workflow.run`.\nThese can be any data type Temporal can convert, including ['dataclasses'](https://docs.python.org/3/library/dataclasses.html) when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single `dataclass` parameter containing all input fields.\nFor example:\n\n```python\n@dataclass\nclass YourParams:\n    your_int_param: int\n    your_str_param: str\n\n\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, params: YourParams) -> None:\n        ...\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nYou can define and pass parameters in your Workflow. In this example, you define your arguments in your `client.ts` file and pass those parameters to `workflow.ts` through your Workflow function.\n\nStart a Workflow with the parameters that are in the `client.ts` file. In this example we set the `name` parameter to `Temporal` and `born` to `2019`. Then set the Task Queue and Workflow Id.\n\n`client.ts`\n\n```typescript\nimport { example } from './workflows';\n\n...\nawait client.start(example, {\n  args: [{ name: 'Temporal', born: 2019 }],\n  taskQueue: 'your-queue',\n  workflowId: 'business-meaningful-id',\n});\n```\n\nIn `workflows.ts` define the type of the parameter that the Workflow function takes in. The interface `ExampleParam` is a name we can now use to describe the requirement in the previous example. It still represents having the two properties called `name` and `born` that is of the type `string`. Then define a function that takes in a parameter of the type `ExampleParam` and return a `Promise<string>`. The `Promise` object represents the eventual completion, or failure, of `await client.start()` and its resulting value.\n\n```ts\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({name, born}: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Workflow return values\n\nWorkflow return values must also be serializable.\nReturning results, returning errors, or throwing exceptions is fairly idiomatic in each language that is supported.\nHowever, Temporal APIs that must be used to get the result of a Workflow Execution will only ever receive one of either the result or the error.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nA Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.\nAgain, the best practice here is to use a `struct` type to hold all custom values.\n\n```go\ntype YourWorkflowResponse struct{\n WorkflowResultFieldOne string\n WorkflowResultFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n if err != nil {\n   return \"\", err\n }\n responseVar := YourWorkflowResponse {\n   FieldOne: \"super\",\n   FieldTwo: 1,\n }\n return responseVar, nil\n}\n```\n\nA Workflow Definition written in Go can return both a custom value and an error.\nHowever, it's not possible to receive both a custom value and an error in the calling process, as is normal in Go.\nThe caller will receive either one or the other.\nReturning a non-nil `error` from a Workflow indicates that an error was encountered during its execution and the Workflow Execution should be terminated, and any custom return values will be ignored by the system.\n\n</TabItem>\n<TabItem value=\"java\">\n\nWorkflow method arguments and return values must be serializable and deserializable using the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.11.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicWorkflow` can return type Object.\nEnsure that your Client can handle an Object type return or is able to convert the Object type response.\n\nRelated references:\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>\n\n</TabItem>\n<TabItem value=\"php\">\n\nA Workflow method returns a Generator.\nTo properly typecast the Workflow's return value in the client code, use the `#[ReturnType()]` annotation.\n\n```php\n#[YourWorkflowInterface]\ninterface FileProcessingWorkflow {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n}\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nA Workflow Execution can return the results of a Workflow.\n\nTo return the results of a Workflow Execution, use either [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) asynchronous methods.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n\nresult = await handle.result()\n```\n\n`execute_workflow()` is a helper function for `start_workflow()` and `handle.result()`.\n\n```python\nhandle = await client.execute_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nTo return a value of the Workflow function, use `Promise<something>`. The `Promise` is used to make asynchronous calls and comes with guarantees.\n\nThe following example uses a `Promise<string>` to eventually return a `name` and `born` parameter.\n\n```typescript\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({name, born}: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Workflow Type\n\nWorkflows have a Type that are referred to as the Workflow name.\n\nThe following examples demonstrate how to set a custom name for your Workflow Type.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo customize the Workflow Type, set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.\n\n- Type: `string`\n- Default: function name\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := workflow.RegisterOptions{\n  Name: \"YourWorkflowName\",\n  // ...\n}\nw.RegisterWorkflowWithOptions(YourWorkflowDefinition, registerOptions)\n// ...\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nThe Workflow Type defaults to the short name of the Workflow interface.\nIn the following example, the Workflow Type defaults to `NotifyUserAccounts`.\n\n```java\n  @WorkflowInterface\n\n  public interface NotifyUserAccounts {\n    @WorkflowMethod\n    void notify(String[] accountIds);\n}\n```\n\nTo overwrite this default naming and assign a custom Workflow Type, use the `@WorkflowMethod` annotation with the `name` parameter.\nIn the following example, the Workflow Type is set to `Abc`.\n\n```java\n@WorkflowInterface\n\n  public interface NotifyUserAccounts {\n  @WorkflowMethod(name = \"Abc\")\n  void notify(String[] accountIds);\n  }\n```\n\nWhen you set the Workflow Type this way, the value of the `name` parameter does not have to start with an uppercase letter.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"python\">\n\nYou can customize the Workflow name with a custom name in the decorator argument. For example, `@workflow.defn(name=\"your-workflow-name\")`. If the name parameter is not specified, the Workflow name defaults to the function name.\n\n```python\n@workflow.defn(name=\"your-workflow-name\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nThe Workflow Type is the Workflow function name.\nIn the following example, the Type is `helloWorld`.\n\n<!--SNIPSTART typescript-workflow-type -->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\n### Workflow logic requirements\n\nWorkflow logic is constrained by [deterministic execution requirements](/concepts/what-is-a-workflow-definition/#deterministic-constraints).\nTherefore, each language is limited to the use of certain idiomatic techniques.\nHowever, each Temporal SDK provides a set of APIs that can be used inside your Workflow to interact with external (to the Workflow) application code.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nIn Go, Workflow Definition code cannot directly do the following:\n\n- Iterate over maps using `range`, because with `range` the order of the map's iteration is randomized.\n  Instead you can collect the keys of the map, sort them, and then iterate over the sorted keys to access the map.\n  This technique provides deterministic results.\n  You can also use a Side Effect or an Activity to process the map instead.\n- Call an external API, conduct a file I/O operation, talk to another service, etc. (Use an Activity for these.)\n\nThe Temporal Go SDK has APIs to handle equivalent Go constructs:\n\n- `workflow.Now()` This is a replacement for `time.Now()`.\n- `workflow.Sleep()` This is a replacement for `time.Sleep()`.\n- `workflow.GetLogger()` This ensures that the provided logger does not duplicate logs during a replay.\n- `workflow.Go()` This is a replacement for the `go` statement.\n- `workflow.Channel` This is a replacement for the native `chan` type.\n  Temporal provides support for both buffered and unbuffered channels.\n- `workflow.Selector` This is a replacement for the `select` statement. Learn more on the [Go SDK Selectors](/go/selectors) page\n- `workflow.Context` This is a replacement for `context.Context`. Learn more on the [Go SDK Context Propagation](/go/tracing) page.\n\n</TabItem>\n<TabItem value=\"java\">\n\nWhen defining Workflows using the Temporal Java SDK, the Workflow code must be written to execute effectively once and to completion.\n\nThe following constraints apply when writing Workflow Definitions:\n\n- Do not use mutable global variables in your Workflow implementations.\n  This will ensure that multiple Workflow instances are fully isolated.\n- Your Workflow code must be deterministic.\n  Do not call non-deterministic functions (such as non-seeded random or `UUID.randomUUID()`) directly from the Workflow code.\n  The Temporal SDK provides specific API for calling non-deterministic code in your Workflows.\n- Do not use programming language constructs that rely on system time.\n  For example, only use `Workflow.currentTimeMillis()` to get the current time inside a Workflow.\n- Do not use native Java `Thread` or any other multi-threaded classes like `ThreadPoolExecutor`.\n  Use `Async.function` or `Async.procedure`, provided by the Temporal SDK, to execute code asynchronously.\n- Do not use synchronization, locks, or other standard Java blocking concurrency-related classes besides those provided by the Workflow class.\n  There is no need for explicit synchronization because multi-threaded code inside a Workflow is executed one thread at a time and under a global lock.\n  - Call `Workflow.sleep` instead of `Thread.sleep`.\n  - Use `Promise` and `CompletablePromise` instead of `Future` and `CompletableFuture`.\n  - Use `WorkflowQueue` instead of `BlockingQueue`.\n- Use `Workflow.getVersion` when making any changes to the Workflow code.\n  Without this, any deployment of updated Workflow code might break already running Workflows.\n- Do not access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n- Use `DynamicWorkflow` when you need a default Workflow that can handle all Workflow Types that are not registered with a Worker.\n  A single implementation can implement a Workflow Type which by definition is dynamically loaded from some external source.\n  All standard `WorkflowOptions` and determinism rules apply to Dynamic Workflow implementations.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n\n</TabItem>\n<TabItem value=\"php\">\n\n\\*\\*Temporal uses the [Microsoft Azure Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover the state of a Workflow object including its local variable values.\n\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nWhen replaying, side effects (such as Activity invocations) are ignored because they are already recorded in the Workflow event history.\nWhen writing Workflow logic, the replay is not visible, so the code should be written since it executes only once.\nThis design puts the following constraints on the Workflow implementation:\n\n- Do not use any mutable global variables because multiple instances of Workflows are executed in parallel.\n- Do not call any non-deterministic functions like non seeded random or `UUID` directly from the Workflow code.\n\nAlways do the following in the Workflow implementation code:\n\n- Dont perform any IO or service calls as they are not usually deterministic. Use Activities for this.\n- Only use `Workflow::now()` to get the current time inside a Workflow.\n- Call `yield Workflow::timer()` instead of `sleep()`.\n- Do not use any blocking SPL provided by PHP (i.e. `fopen`, `PDO`, etc) in **Workflow code**.\n- Use `yield Workflow::getVersion()` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already open Workflows.\n- Dont access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\nWorkflow method arguments and return values are serializable to a byte array using the provided [DataConverter](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html) interface.\nThe default implementation uses JSON serializer, but you can use any alternative serialization mechanism.\n\nMake sure to annotate your `WorkflowMethod` using `ReturnType` to specify concrete return type.\n\n> You can not use the default return type declaration as Workflow methods are generators.\n\nThe values passed to Workflows through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to Workflow workers with every event that the Workflow logic needs to process.\nA large execution history can thus adversely impact the performance of your Workflow.\nTherefore, be mindful of the amount of data that you transfer via Activity invocation parameters or return values.\nOtherwise, no additional limitations exist on Activity implementations.\\*\\*\n\n</TabItem>\n<TabItem value=\"python\">\n\nWorkflow code must be deterministic. This means:\n\n- no threading\n- no randomness\n- no external calls to processes\n- no network I/O\n- no global state mutation\n- no system date or time\n\nAll API safe for Workflows used in the [`temporalio.workflow`](https://python.temporal.io/temporalio.workflow.html) must run in the implicit [`asyncio` event loop](https://docs.python.org/3/library/asyncio-eventloop.html) and be _deterministic_.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n## Develop Activities\n\nOne of the primary things that Workflows do is orchestrate the execution of Activities.\nActivities are normal function/method executions that can interact with the world.\nFor the Workflow to be able to execute the Activity, we must define the [Activity Definition](/activities#activity-definition).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nIn the Temporal Go SDK programming model, an Activity Definition is an exportable function or a `struct` method.\n\n**Function**\n\n```go\n// basic function signature\nfunc YourActivityDefinition(ctx context.Context) error {\n // ...\n return nil\n}\n\n// with parameters and return values\nfunc SimpleActivity(ctx context.Context, value string) (string, error)\n```\n\n**Struct method**\n\n```go\ntype YourActivityStruct struct {\n ActivityFieldOne string\n ActivityFieldTwo int\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinition(ctx context.Context) error {\n // ...\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinitionTwo(ctx context.Context) error {\n // ...\n}\n```\n\nAn _Activity struct_ can have more than one method, with each method acting as a separate Activity Type.\nActivities written as struct methods can use shared struct variables, such as:\n\n- an application level DB pool\n- client connection to another service\n- reusable utilities\n- any other expensive resources that you only want to initialize once per process\n\nBecause this is such a common need, the rest of this guide shows Activities written as `struct` methods.\n\n</TabItem>\n<TabItem value=\"java\">\n\nAn [Activity Definition](/activities#) is a combination of the Temporal Java SDK [Activity](https://www.javadoc.io/static/io.temporal/temporal-sdk/0.19.0/io/temporal/activity/Activity.html) Class implementing a specially annotated interface.\n\nAn Activity interface is annotated with `@ActivityInterface` and an Activity implementation implements this Activity interface.\nTo handle Activity types that do not have an explicitly registered handler, you can directly implement a dynamic Activity.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    String composeGreeting(String greeting, String language);\n}\n```\n\nEach method defined in the Activity interface defines a separate Activity method.\nYou can annotate each method in the Activity interface with the `@ActivityMethod` annotation, but this is completely optional.\nThe following example uses the `@ActivityMethod` annotation for the method defined in the previous example.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nAn Activity implementation is a Java class that implements an Activity annotated interface.\n\n```java\n// Implementation for the GreetingActivities interface example from in the previous section\n static class GreetingActivitiesImpl implements GreetingActivities {\n    @Override\n    public String composeGreeting(String greeting, String name) {\n      return greeting + \" \" + name + \"!\";\n    }\n  }\n```\n\nUse `DynamicActivity` to implement any number of Activity types dynamically.\nWhen an Activity implementation that extends `DynamicActivity` is registered, it is called for any Activity type invocation that doesn't have an explicitly registered handler.\n\nThe dynamic Activity interface is implemented with the `execute` method, as shown in the following example.\n\n```java\n // Dynamic Activity implementation\n  public static class DynamicGreetingActivityImpl implements DynamicActivity {\n    @Override\n    public Object execute(EncodedValues args) {\n      String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n      return activityType\n          + \": \"\n          + args.get(0, String.class)\n          + \" \"\n          + args.get(1, String.class)\n          + \" from: \"\n          + args.get(2, String.class);\n    }\n  }\n```\n\nUse `Activity.getExecutionContext()` to get information about the Activity type that should be implemented dynamically.\n\n</TabItem>\n<TabItem value=\"php\">\n\nActivities are defined as methods of a plain PHP interface annotated with `#[YourActivityInterface]`.\n(You can also use PHP 8 attributes in PHP 7.)\n\nFollowing is an example of an interface that defines four Activities:\n\n```php\n#[YourActivityInterface]\n// Defining an interface for the activities.\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName): void;\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName): void;\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName): void;\n}\n```\n\n**How to customize an Activity type**\n\nWe recommend to use a single value type argument for Activity methods.\nIn this way, adding new arguments as fields to the value type is a backward-compatible change.\n\nAn optional `#[ActivityMethod]` annotation can be used to override a default Activity name.\n\nYou can define your own prefix for all Activity names by adding the `prefix` option to the `YourActivityInterface` annotation.\n(The default prefix is empty.)\n\n```php\n#[YourActivityInterface(\"file_activities.\")]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName);\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName);\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName);\n}\n```\n\nThe `#[YourActivityInterface(\"file_activities.\")]` is an annotation that tells the PHP SDK to generate a class to implement the `FileProcessingActivities` interface. The functions define Activites that are used in the Workflow.\n\n</TabItem>\n<TabItem value=\"python\">\n\nYou can develop an Activity Definition by using the [`@activity.defn`](https://python.temporal.io/temporalio.activity.html#defn) decorator.\n\n```python\n@activity.defn\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\nYou can register the function as an Activity with a custom name through a decorator argument. For example, `@activity.defn(name=\"your-activity\")`.\n\n```python\n@activity.defn(name=\"your-activity\")\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n**Types of Activities**\n\nThe following lists the different types of _Activity callables_:\n\n- [Asynchronous Activities](#asynchronous-activities)\n- [Synchronous Activities](#synchronous-activities)\n\n:::note Positional arguments\n\nOnly positional arguments are supported by Activities.\n\n:::\n\n##### [Asynchronous Activities](#asynchronous-activities)\n\nAsynchronous Activities (recommended) are functions using `async def`. When using asynchronous Activities there aren't any additional Worker parameters needed.\n\nCancellation for asynchronous activities is done by means of the\n[`asyncio.Task.cancel`](https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel) operation. This means that `asyncio.CancelledError` will be raised (and can be caught, but it is not recommended).\n\nAn Activity must Heartbeat to receive cancellation.\n\n##### [Synchronous Activities](#synchronous-activities)\n\nThe [`activity_executor`](https://python.temporal.io/temporalio.worker.workerconfig#activity_exector) Worker parameter must be set with a [`concurrent.futures.Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor) instance to use for executing the Activities.\n\nCancellation for synchronous Activities is done in the background and the Activity must choose to listen for it and react appropriately.\n\nAn Activity must Heartbeat to receive cancellation.\n\n- ###### [Synchronous Multithreaded Activities](#synchronous-multithreaded-activities)\n\nMultithreaded Activities are functions that use `activity_executor` set to an instance of [`concurrent.futures.ThreadPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor).\n\nBesides `activity_executor`, no other additional Worker parameters are required for synchronous multithreaded Activities.\n\n- ###### [Synchronous Multiprocess/Other Activities](#synchronous-multiprocess)\n\nIf `activity_executor` is set to an instance of [`concurrent.futures.Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor) that is not `concurrent.futures.ThreadPoolExecutor`, then the synchronous activities are considered multiprocess/other activities.\n\nThese require special primitives for heartbeating and cancellation. The `shared_state_manager` Worker parameter must be set to an instance of [`worker.SharedStateManager`](https://python.temporal.io/temporalio.worker.sharedstatemanager). The most common implementation can be created by passing a [`multiprocessing.managers.SyncManager`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.SyncManager) (for example, as a result of [`multiprocessing.managers.Manager()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Manager)) to [`worker.SharedStateManager.create_from_multiprocessing()`](https://python.temporal.io/temporalio.worker.sharedstatemanager#create_from_multiprocessing).\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n- Activities execute in the standard Node.js environment.\n- Activities cannot be in the same file as Workflows and must be separately registered.\n- Activities may be retried repeatedly, so you may need to use idempotency keys for critical side effects.\n\nActivities are _just functions_. The following is an Activity that accepts a string parameter and returns a string.\n\n<!--SNIPSTART typescript-activity-fn -->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\n### Activity Parameters\n\nThere is no explicit limit to the total number of parameters that an [Activity Definition](/activities#activity-definition) may support.\nHowever, there is a limit of the total size of the data ends up encoded into a gRPC message Payload.\n\nA single argument is limited to a maximum size of 2 MB.\nAnd the total size of a gRPC message, which includes all the arguments, is limited to a maximum of 4 MB.\n\nAlso, keep in mind that all Payload data is recorded in the [Workflow Execution Event History](/workflows#event-history) and large Event Histories can affect Worker performance.\nThis is because the entire Event History could be transferred to a Worker Process with a [Workflow Task](/tasks#workflow-task).\n\n<!--TODO link to gRPC limit section when available -->\n\nSome SDKs require that you pass context objects, others do not.\nWhen it comes to your application datathat is, data that is serialized and encoded into a Payloadwe recommend that you use a single object as an argument that wraps the application data passed to Activities.\nThis is so that you can change what data is passed to the Activity without breaking a function or method signature.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nThe first parameter of an Activity Definition is `context.Context`.\nThis parameter is optional for an Activity Definition, though it is recommended, especially if the Activity is expected to use other Go SDK APIs.\n\nAn Activity Definition can support as many other custom parameters as needed.\nHowever, all parameters must be serializable (parameters cant be channels, functions, variadic, or unsafe pointers), and it is recommended to pass a single struct that can be updated later.\n\n```go\ntype YourActivityParam struct {\n ActivityParamFieldOne string\n ActivityParamFieldTwo int\n}\n\ntype YourActivityStruct struct {\n // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nAn Activity interface can have any number of parameters.\nAll inputs should be serializable by the default Jackson JSON Payload Converter.\n\nWhen implementing Activities, be mindful of the amount of data that you transfer using the Activity invocation parameters or return values as these are recorded in the Workflow Execution Events History.\nLarge Events Histories can adversely impact performance.\n\nYou can create a custom object, and pass it to the Activity interface, as shown in the following example.\n\n```java\n@ActivityInterface\npublic interface YourActivities {\n    String getCustomObject(CustomObj customobj);\n    void sendCustomObject(CustomObj customobj, String abc);\n}\n```\n\nThe `execute` method in the dynamic Activity interface implementation takes in `EncodedValues` that are inputs to the Activity Execution, as shown in the following example.\n\n```java\n // Dynamic Activity implementation\n  public static class DynamicActivityImpl implements DynamicActivity {\n    @Override\n    public Object execute(EncodedValues args) {\n      String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n      return activityType\n          + \": \"\n          + args.get(0, String.class)\n          + \" \"\n          + args.get(1, String.class)\n          + \" from: \"\n          + args.get(2, String.class);\n    }\n  }\n```\n\nFor more details, see [Dynamic Activity Reference](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/DynamicActivity.html).\n\n</TabItem>\n<TabItem value=\"php\">\n\nEach method defines a single Activity type.\nA single Workflow can use more than one Activity interface and call more than one Activity method from the same interface.\n\nThe only requirement is that Activity method arguments and return values are serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\n\n</TabItem>\n<TabItem value=\"python\">\n\nActivity parameters are the function parameters of the function decorated with `@activity.defn`.\nThese can be any data type Temporal can convert, including ['dataclasses'](https://docs.python.org/3/library/dataclasses.html) when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single `dataclass` parameter containing all input fields.\nFor example:\n\n```python\n@dataclass\nclass YourParams:\n    your_int_param: int\n    your_str_param: str\n\n\n@activity.defn\nasync def your_activity(params: YourParams) -> None:\n    ...\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nThis Activity takes a single name parameter of the type string.\n\n<!--SNIPSTART typescript-activity-fn -->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\n### Activity return values\n\nAll data returned from an Activity must be serializable.\n\nThere is no explicit limit to the amount of data that can be returned by an Activity, but keep in mind that all return values are recorded in a [Workflow Execution Event History](/workflows#event-history).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nA Go-based Activity Definition can return either just an `error` or a `customValue, error` combination (same as a Workflow Definition).\nYou may wish to use a `struct` type to hold all custom values, just keep in mind they must all be serializable.\n\n```go\ntype YourActivityResult struct{\n  ActivityResultFieldOne string\n  ActivityResultFieldTwo int\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResult, error) {\n  // ...\n  result := YourActivityResult {\n    ActivityResultFieldOne: a.ActivityFieldOne,\n    ActivityResultFieldTwo: a.ActivityFieldTwo,\n  }\n  return result, nil\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nActivity return values must be serializable and deserializable by the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.11.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicActivity` can return type Object.\nEnsure that your Workflow or Client can handle an Object type return or is able to convert the Object type response.\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>\n\n</TabItem>\n<TabItem value=\"php\">\n\nReturn values must be serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\nThus, you can return both primitive types:\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): string\n    {\n        return $greeting . ' ' . $name;\n    }\n}\n```\n\nAnd objects:\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): Greeting\n    {\n        return new Greeting($greeting, $name);\n    }\n}\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nAn ActivityExecution can return inputs and other Activity values.\n\nThe following example defines an Activity that takes a string as input and returns a string.\n\n```python\n@activity.defn\nasync def say_hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nIn TypeScript, the return value is always a Promise.\n\nIn the following example, `Promise<string>` is the return value.\n\n<!--SNIPSTART typescript-activity-fn -->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\n### Customize Activity Type\n\nYou can set a custom name for your Activity Type.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo customize the Activity Type, set the `Name` parameter with `RegisterOptions` when registering your Activity with a Worker.\n\n- Type: `string`\n- Default: function name\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  Name: \"YourActivityName\",\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nThe Activity Type defaults to method name, with the first letter of the method name capitalized, and can be customized using `namePrefix()` or `{ActivityMethod.name()}` to ensure they are distinct.\n\nIn the following example, the Activity Type defaults to `ComposeGreeting`.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nTo overwrite this default naming and assign a custom Activity Type, use the `@ActivityMethod` annotation with the `name` parameter.\nIn the following example, the Activity Type is set to \"greet\".\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod(name = \"greet\")\n    String composeGreeting(String greeting, String language);\n}\n```\n\nYou can also define a prefix for all of your Activity Types using the `namePrefix` parameter with the `@ActivityInterface` annotation.\nThe following example shows a `namePrefix` parameter applied to the `@ActivityInterface`, and two Activity methods, of which one is defined using the `@ActivityMethod` annotation.\n\n```java\n@ActivityInterface(namePrefix = \"A_\")\nPublic interface GreetingActivities {\n    String sendGreeting(String input);\n\n  @ActivityMethod(name = \"abc\")\n  String composeGreeting(String greeting, String language);\n}\n```\n\nIn this example, the Activity type for the first method is set to `A_SendGreeting`.\nThe Activity type for the method annotated with `@ActivityMethod` is set to `A_abc`.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"undefined\">\n\nYou can customize the Activity name with a custom name in the decorator argument. For example, `@activity.defn(name=\"your-activity\")`. If the name parameter is not specified, the Activity name defaults to the function name.\n\n```python\n@activity.defn(name=\"your-activity\")\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nIn TypeScript, to customize an Activity Name set the function name to your desired name.\n\nIn the following example the Activity Name is `greet`.\n\n<!--SNIPSTART typescript-activity-fn -->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\n## Activity Execution\n\nCalls to spawn [Activity Executions](/activities#activity-execution) are written within a [Workflow Definition](/workflows#workflow-definition).\nThe call to spawn an Activity Execution generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nThis results in the set of three [Activity Task](/tasks#activity-task) related Events ([ActivityTaskScheduled](/references/events/#activitytaskscheduled), [ActivityTaskStarted](/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.\n\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the Execution history.\nThe entire Execution history is transferred from the Temporal service to Workflow Workers when a Workflow state needs to recover.\nA large Execution history can thus adversely impact the performance of your Workflow.\n\nTherefore, be mindful of the amount of data you transfer through Activity invocation parameters or Return Values.\nOtherwise, no additional limitations exist on Activity implementations.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo spawn an [Activity Execution](/activities#activity-execution), use the [`ExecuteActivity()`](https://pkg.go.dev/go.temporal.io/workflow#ExecuteActivity) API call inside your Workflow Definition.\nThe API is available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/workflow) package.\n\nThe `ExecuteActivity()` API call requires an instance of `workflow.Context`, the Activity function name, and any variables to be passed to the Activity Execution.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n  yourActivityParam := YourActivityParam{\n    // ...\n  }\n  var activities *YourActivityStruct\n  future := workflow.ExecuteActivity(ctx, activities.YourActivityDefinition, yourActivityParam)\n  // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n  // ...\n}\n```\n\nThe Activity function name can be provided as a variable object (no quotations) or as a string.\n\n```go\n// ...\n  future := workflow.ExecuteActivity(ctx, \"YourActivityDefinition\", yourActivityParam)\n// ...\n```\n\nThe benefit of passing the actual function object is that the framework can validate the parameters against the Activity Definition.\n\nThe `ExecuteActivity` call returns a Future, which can be used to get the result of the Activity Execution.\n\n</TabItem>\n<TabItem value=\"java\">\n\nActivities are remote procedure calls that must be invoked from within a Workflow using `ActivityStub`.\nActivities are not executable on their own. You cannot start an Activity Execution by itself.\n\nNote that before an Activity Execution is invoked:\n\n- Activity options (either [`setStartToCloseTimeout`](/activities#start-to-close-timeout) or [`ScheduleToCloseTimeout`](/activities#schedule-to-close-timeout) are required) must be set for the Activity.\n  For details, see [Set Activity Options](/java/how-to-set-activityoptions-in-java) and [Activity Options reference](/java/reference-activityoptions).\n- The Activity must be registered with a Worker.\n  See [Worker Program](#run-worker-processes)\n- Activity code must be thread-safe.\n\nActivities should only be instantiated using stubs from within a Workflow.\nAn `ActivityStub` returns a client-side stub that implements an Activity interface.\nYou can invoke Activities using `Workflow.newActivityStub`(type-safe) or `Workflow.newUntypedActivityStub` (untyped).\n\nCalling a method on the Activity interface schedules the Activity invocation with the Temporal service, and generates an [`ActivityTaskScheduled` Event](/concepts/what-is-an-event#activitytaskscheduled).\n\nActivities can be invoked synchronously or asynchronously.\n\n**Invoking Activities Synchronously**\n\nIn the following example, we use the type-safe `Workflow.newActivityStub` within the \"FileProcessingWorkflow\" Workflow implementation to create a client-side stub of the `FileProcessingActivities` class. We also define `ActivityOptions` and set `setStartToCloseTimeout` option to one hour.\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) {\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    // ...\n}\n```\n\nA Workflow can have multiple Activity stubs. Each Activity stub can have its own `ActivityOptions` defined.\nThe following example shows a Workflow implementation with two typed Activity stubs.\n\n```java\npublic FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue1\")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue2\")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n```\n\nTo invoke Activities inside Workflows without referencing the interface it implements, use an untyped Activity stub `Workflow.newUntypedActivityStub`.\nThis is useful when the Activity type is not known at compile time, or to invoke Activities implemented in different programming languages.\n\n```java\n   // Workflow code\n    ActivityOptions activityOptions =\n        ActivityOptions.newBuilder()\n        .setStartToCloseTimeout(Duration.ofSeconds(3))\n        .setTaskQueue(\"simple-queue-node\")\n        .build();\n\n    ActivityStub activity = Workflow.newUntypedActivityStub(activityOptions);\n    activity.execute(\"ComposeGreeting\", String.class, \"Hello World\" , \"Spanish\");\n```\n\n**Invoking Activities Asynchronously**\n\nSometimes Workflows need to perform certain operations in parallel.\nThe Temporal Java SDK provides the `Async` class which includes static methods used to invoke any Activity asynchronously.\nThe calls return a result of type `Promise` which is similar to the Java `Future` and `CompletionStage`.\nWhen invoking Activities, use `Async.function` for Activities that return a result, and `Async.procedure` for Activities that return void.\n\nIn the following asynchronous Activity invocation, the method reference is passed to `Async.function` followed by Activity arguments.\n\n```java\nPromise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);\n```\n\nThe following example shows how to call two Activity methods, \"download\" and \"upload\", in parallel on multiple files.\n\n```java\n  public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n      // Download all files in parallel.\n      for (String sourceFilename : args.getSourceFilenames()) {\n        Promise<String> localName =\n            Async.function(activities::download, args.getSourceBucketName(), sourceFilename);\n        localNamePromises.add(localName);\n      }\n      List<String> localNames = new ArrayList<>();\n      for (Promise<String> localName : localNamePromises) {\n        localNames.add(localName.get());\n      }\n      processedNames = activities.processFiles(localNames);\n\n      // Upload all results in parallel.\n      List<Promise<Void>> uploadedList = new ArrayList<>();\n      for (String processedName : processedNames) {\n        Promise<Void> uploaded =\n            Async.procedure(\n                activities::upload,\n                args.getTargetBucketName(),\n                args.getTargetFilename(),\n                processedName);\n        uploadedList.add(uploaded);\n      }\n      // Wait for all uploads to complete.\n      Promise.allOf(uploadedList).get();\n    } finally {\n      for (Promise<String> localNamePromise : localNamePromises) {\n        // Skip files that haven't completed downloading.\n        if (localNamePromise.isCompleted()) {\n          activities.deleteLocalFile(localNamePromise.get());\n        }\n      }\n      if (processedNames != null) {\n        for (String processedName : processedNames) {\n          activities.deleteLocalFile(processedName);\n        }\n      }\n    }\n  }\n```\n\n**Activity Execution Context**\n\n`ActivityExecutionContext` is a context object passed to each Activity implementation by default.\nYou can access it in your Activity implementations via `Activity.getExecutionContext()`.\n\nIt provides getters to access information about the Workflow that invoked the Activity.\nNote that the Activity context information is stored in a thread-local variable.\nTherefore, calls to `getExecutionContext()` succeed only within the thread that invoked the Activity function.\n\nFollowing is an example of using the `ActivityExecutionContext`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n    ActivityInfo info = ctx.getInfo();\n\n    log.info(\"namespace=\" +  info.getActivityNamespace());\n    log.info(\"workflowId=\" + info.getWorkflowId());\n    log.info(\"runId=\" + info.getRunId());\n    log.info(\"activityId=\" + info.getActivityId());\n    log.info(\"activityTimeout=\" + info.getStartToCloseTimeout();\n\n    return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n  }\n    ...\n}\n```\n\nFor details on getting the results of an Activity Execution, see [Activity Execution Result](#get-activity-results).\n\n</TabItem>\n<TabItem value=\"php\">\n\nActivity implementation is an implementation of an Activity interface.\nThe following code example, uses a constructor that takes an Amazon S3 client and a local directory, and uploads a file to the S3 bucket.\nThen, the code uses a function to download a file from the S3 bucket passing a bucket name, remote name, and local name as arguments.\nFinally, it uses a function that takes a local file name as an argument and returns a string.\n\n```php\n// An implementation of an Activity interface.\nclass FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n    private S3Client $s3Client;\n\n    private string $localDirectory;\n\n    public function __construct(S3Client $s3Client, string $localDirectory) {\n        $this->s3Client = $s3Client;\n        $this->localDirectory = $localDirectory;\n    }\n\n    // Uploading a file to S3.\n    public function upload(string $bucketName, string $localName, string $targetName): void\n    {\n        $this->s3Client->putObject(\n            $bucketName,\n            $targetName,\n            fopen($this->localDirectory . $localName, 'rb+')\n        );\n    }\n\n// Downloading a file from S3.\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->s3Client->downloadObject(\n            $bucketName,\n            $remoteName,\n            fopen($this->localDirectory .$localName, 'wb+')\n        );\n    }\n\n// A function that takes a local file name as an argument and returns a string.\n    public function processFile(string $localName): string\n    {\n        // Implementation omitted for brevity.\n        return compressFile($this->localDirectory . $localName);\n    }\n\n    public function deleteLocalFile(string $fileName): void\n    {\n        unlink($this->localDirectory . $fileName);\n    }\n}\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo spawn an Activity Execution, use the [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) operation from within your Workflow Definition.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`.\nIn most cases, use `execute_activity()` unless advanced task capabilities are needed.\n\nA single argument to the Activity is positional. Multiple arguments are not supported in the type-safe form of `start_activity()` or `execute_activity()` and must be supplied by the `args` keyword argument.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nTo spawn an Activity Execution, you must retrieve the _Activity handle_ in your Workflow.\n\n```typescript\nimport {proxyActivities} from \"@temporalio/workflow\";\n// Only import the activity types\nimport type * as activities from \"./activities\";\n\nconst {greet} = proxyActivities<typeof activities>({\n  startToCloseTimeout: \"1 minute\",\n});\n\n// A workflow that calls an activity\nexport async function example(name: string): Promise<string> {\n  return await greet(name);\n}\n```\n\nThis imports the individual Activities and declares the type alias for each Activity.\n\n</TabItem>\n</Tabs>\n\n### Required timeout\n\nActivity Execution semantics rely on several parameters.\nThe only required value that needs to be set is either a [Schedule-To-Close Timeout](/activities#start-to-close-timeout) or a [Start-To-Close Timeout](/activities#start-to-close-timeout).\nThese values are set in the Activity Options.\n\n### Get Activity results\n\nThe call to spawn an [Activity Execution](/activities#activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nThe `ExecuteActivity` API call returns an instance of [`workflow.Future`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Futures) which has the following two methods:\n\n- `Get()`: Takes an instance of the `workflow.Context`, that was passed to the Activity Execution, and a pointer as parameters.\n  The variable associated with the pointer is populated with the Activity Execution result.\n  This call blocks until the results are available.\n- `IsReady()`: Returns `true` when the result of the Activity Execution is ready.\n\nCall the `Get()` method on the instance of `workflow.Future` to get the result of the Activity Execution.\nThe type of the result parameter must match the type of the return value declared by the Activity function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n var yourActivityResult YourActivityResult\n if err := future.Get(ctx, &yourActivityResult); err != nil {\n   // ...\n }\n // ...\n}\n```\n\nUse the `IsReady()` method first to make sure the `Get()` call doesn't cause the Workflow Execution to wait on the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n // ...\n if(future.IsReady()) {\n   var yourActivityResult YourActivityResult\n   if err := future.Get(ctx, &yourActivityResult); err != nil {\n     // ...\n   }\n }\n // ...\n}\n```\n\nIt is idiomatic to invoke multiple Activity Executions from within a Workflow.\nTherefore, it is also idiomatic to either block on the results of the Activity Executions or continue on to execute additional logic, checking for the Activity Execution results at a later time.\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo get the results of an asynchronously invoked Activity method, use the `Promise` `get` method to block until the Activity method result is available.\n\nSometimes an Activity Execution lifecycle goes beyond a synchronous method invocation.\nFor example, a request can be put in a queue and later a reply comes and is picked up by a different Worker process.\nThe whole request-reply interaction can be modeled as a single Activity.\n\nTo indicate that an Activity should not be completed upon its method return, call `ActivityExecutionContext.doNotCompleteOnReturn()` from the original Activity thread.\n\nThen later, when replies come, complete the Activity using the `ActivityCompletionClient`.\nTo correlate Activity invocation with completion use either a `TaskToken` or Workflow and Activity IDs.\n\nFollowing is an example of using `ActivityExecutionContext.doNotCompleteOnReturn()`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n\n    // Used to correlate reply\n    byte[] taskToken = ctx.getInfo().getTaskToken();\n\n    asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n    ctx.doNotCompleteOnReturn();\n\n    // Return value is ignored when doNotCompleteOnReturn was called.\n    return \"ignored\";\n  }\n  ...\n}\n```\n\nWhen the download is complete, the download service potentially can complete the Activity, or fail it from a different process, for example:\n\n```java\n  public <R> void completeActivity(byte[] taskToken, R result) {\n    completionClient.complete(taskToken, result);\n  }\n\n  public void failActivity(byte[] taskToken, Exception failure) {\n    completionClient.completeExceptionally(taskToken, failure);\n  }\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\n`Workflow::newActivityStub`returns a client-side stub an implements an Activity interface. The client-side stub can be used within the Workflow code. It takes the Activity's type and`ActivityOptions` as arguments.\n\nCalling (via `yield`) a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if Activity execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\n```php\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    private $greetingActivity;\n\n    public function __construct()\n    {\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n        );\n    }\n\n    public function greet(string $name): \\Generator\n    {\n        // This is a blocking call that returns only after the activity has completed.\n        return yield $this->greetingActivity->composeGreeting('Hello', $name);\n    }\n}\n```\n\nIf different Activities need different options, like timeouts or a task queue, multiple client-side stubs can be created with different options.\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 minutes'))\n);\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nUse [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) to start an Activity and return its handle, [`ActivityHandle`](https://python.temporal.io/temporalio.workflow.activityhandle). Use [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) to return the results.\n\nYou must provide either `schedule_to_close_timeout` or `start_to_close_timeout`.\n\n`execute_activity()` is a shortcut for `await start_activity()`. An asynchronous `execute_activity()` helper is provided which takes the same arguments as `start_activity()` and `await`s on the result. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nSince Activities are referenced by their string name, you can reference them dynamically to get the result of an Activity Execution.\n\n```typescript\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts[\"activity1\"]();\n\n  let result = await acts[activityName](...args);\n  return result;\n}\n```\n\nThe `proxyActivities()` returns an object that calls the Activities in the function. `acts[activityName]()` references the Activity using the Activity name, then it returns the results.\n\n</TabItem>\n</Tabs>\n\n## Run Worker Processes\n\nThe [Worker Process](/workers#worker-process) is where Workflow Functions and Activity Functions are executed.\n\n- Each [Worker Entity](/workers#worker-entity) in the Worker Process must register the exact Workflow Types and Activity Types it may execute.\n- Each Worker Entity must also associate itself with exactly one [Task Queue](/tasks#task-queue).\n- Each Worker Entity polling the same Task Queue must be registered with the same Workflow Types and Activity Types.\n\nA [Worker Entity](/workers#worker-entity) is the component within a Worker Process that listens to a specific Task Queue.\n\nAlthough multiple Worker Entities can be in a single Worker Process, a single Worker Entity Worker Process may be perfectly sufficient.\nFor more information, see the [Worker tuning guide](/application-development/worker-performance).\n\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it can make progress for either a Workflow Execution or an Activity Execution.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nCreate an instance of [`Worker`](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) by calling [`worker.New()`](https://pkg.go.dev/go.temporal.io/sdk/worker#New), available through the `go.temporal.io/sdk/worker` package, and pass it the following parameters:\n\n1. An instance of the Temporal Go SDK `Client`.\n1. The name of the Task Queue that it will poll.\n1. An instance of [`worker.Options`](/go/how-to-set-workeroptions-in-go), which can be empty.\n\nThen, register the Workflow Types and the Activity Types that the Worker will be capable of executing.\n\nLastly, call either the `Start()` or the `Run()` method on the instance of the Worker.\nRun accepts an interrupt channel as a parameter, so that the Worker can be stopped in the terminal.\nOtherwise, the `Stop()` method must be called to stop the Worker.\n\n```go\npackage main\n\nimport (\n   \"go.temporal.io/sdk/client\"\n   \"go.temporal.io/sdk/worker\"\n)\n\nfunc main() {\n   c, err := client.Dial(client.Options{})\n   if err != nil {\n       // ...\n   }\n   defer c.Close()\n   w := worker.New(c, \"your-task-queue\", worker.Options{})\n   w.RegisterWorkflow(YourWorkflowDefinition)\n   w.RegisterActivity(YourActivityDefinition)\n   err = w.Run(worker.InterruptCh())\n   if err != nil\n       // ...\n   }\n // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n}\n\nfunc YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResponse, error) {\n // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nUse the `newWorker` method on an instance of a [`WorkerFactory`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/worker/WorkerFactory.html) to create a new Worker in Java.\n\nA single Worker Entity can contain many Worker Objects.\nCall the `start()` method on the instance of the `WorkerFactory` to start all the Workers created in this process.\n\n```java\n// ...\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.serviceclient.WorkflowServiceStubs;\nimport io.temporal.worker.Worker;\nimport io.temporal.worker.WorkerFactory;\n\npublic class YourWorker {\n\n  public static void main(String[] args) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker yourWorker = factory.newWorker(\"your_task_queue\");\n\n    // Register Workflow\n    // and/or register Activities\n\n    factory.start();\n  }\n}\n```\n\nAfter creating the Worker entity, register all Workflow Types and all Activity Types that the Worker can execute.\nA Worker can be registered with just Workflows, just Activities, or both.\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)\n\n</TabItem>\n<TabItem value=\"php\">\n\nThe [RoadRunner application server](https://roadrunner.dev/) will launch multiple Temporal PHP Worker processes based on provided `.rr.yaml` configuration.\n\nEach Worker might connect to one or multiple Task Queues.\nWorker poll _Temporal service_ for tasks, performs those tasks, and communicates task execution results back to the _Temporal service_.\n\nWorker code are developed, deployed, and operated by Temporal customers.\nTo create a worker use `Temporal\\WorkerFactory`:\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nuse Temporal\\WorkerFactory;\n\nini_set('display_errors', 'stderr');\ninclude \"vendor/autoload.php\";\n\n// factory initiates and runs task queue specific activity and workflow workers\n$factory = WorkerFactory::create();\n\n// Worker that listens on a Task Queue and hosts both workflow and activity implementations.\n$worker = $factory->newWorker();\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n\n// Activities are stateless and thread safe. So a shared instance is used.\n$worker->registerActivity(App\\DemoActivity::class);\n\n// In case an activity class requires some external dependencies provide a callback - factory\n// that creates or builds a new activity instance. The factory should be a callable which accepts\n// an instance of ReflectionClass with an activity class which should be created.\n$worker->registerActivity(App\\DemoActivity::class, fn(ReflectionClass $class) => $container->create($class->getName()));\n\n// start primary loop\n$factory->run();\n```\n\nYou can configure task queue name using first argument of `WorkerFactory`->`newWorker`:\n\n```php\n$worker = $factory->newWorker('your-task-queue');\n```\n\nAs mentioned above you can create as many Task Queue connections inside a single Worker Process as you need.\n\nTo configure additional WorkerOptions use `Temporal\\Worker\\WorkerOptions`:\n\n```php\nuse Temporal\\Worker\\WorkerOptions;\n\n$worker = $factory->newWorker(\n    'your-task-queue',\n    WorkerOptions::new()\n        ->withMaxConcurrentWorkflowTaskPollers(10)\n);\n```\n\nMake sure to point the Worker file in application server configuration:\n\n```yaml\nrpc:\n  listen: tcp://127.0.0.1:6001\n\nserver:\n  command: \"php worker.php\"\n\ntemporal:\n  address: \"temporal:7233\"\n  activities:\n    num_workers: 10\n```\n\n> You can serve HTTP endpoints using the same server setup.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo develop a Worker, use the [`Worker()`](https://python.temporal.io/temporalio.worker.worker#__init__) constructor and add your Client, Task Queue, Workflows, and Activities as arguments.\n\nThe following code example creates a Worker that polls for tasks from the Task Queue and executes the Workflow.\n\n```python\nworker = Worker(\n    client,\n    task_queue=\"your-task-queue\",\n    workflows=[YourWorkflow],\n    activities=[your_activity],\n)\n```\n\nThe following code example shows a Worker hosting Workflows and Activities.\n\n```python\nasync def run_worker(stop_event: asyncio.Event):\n    # Create Client connected to server at the given address\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    # Run the worker until the event is set\n    worker = Worker(\n        client,\n        task_queue=\"your-task-queue\",\n        workflows=[YourWorkflow],\n        activities=[your_activity],\n    )\n    async with worker:\n        await stop_event.wait()\n```\n\nThe `asyncio.Event` that will be set when the Worker should stop.\nAlthough this example accepts a stop event and uses `async with`, you can also use [`run()`](https://python.temporal.io/temporalio.worker.Worker.html#run) and [`shutdown()`](https://python.temporal.io/temporalio.worker.Worker.html#shutdown).\nThe `shutdown()` operation waits on all Activities to complete, so if a long-running Activity does not at least respect cancellation, the shutdown might never complete.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nCreate a Worker with `Worker.create()` (which establishes the initial gRPC connection), then call `worker.run()` on it (to start polling the Task Queue).\n\nBelow is an example of starting a Worker that polls the Task Queue named `tutorial`.\n\n<!--SNIPSTART typescript-hello-worker {\"enable_source_link\": false}-->\n<!--SNIPEND-->\n\n`taskQueue` is the only required option, but you will also use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nA full example for Workers looks like this:\n\n```typescript\nimport {Worker, NativeConnection} from \"@temporalio/worker\";\nimport * as activities from \"./activities\";\n\nasync function run() {\n  const connection = await NativeConnection.connect({\n    // defaults port to 7233 if not specified\n    address: \"foo.bar.tmprl.cloud\",\n    tls: {\n      // set to true if TLS without mTLS\n      // See docs for other TLS options\n      clientCertPair: {\n        crt: clientCert,\n        key: clientKey,\n      },\n    },\n  });\n\n  const worker = await Worker.create({\n    connection,\n    namespace: \"foo.bar\", // as explained in Namespaces section\n    // ...\n  });\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\nSee below for more Worker options.\n\n**Workflow and Activity registration**\n\nWorkers bundle Workflow code and `node_modules` using Webpack v5 and execute them inside V8 isolates.\nActivities are directly required and run by Workers in the Node.js environment.\n\nWorkers are very flexible  you can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers in a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker. Not the path.\n- Workflow bundle:\n- Either specify a `workflowsPath` to your `workflows.ts` file to pass to Webpack, e.g., `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n- Or pass a prebuilt bundle to `workflowBundle` instead if you prefer to handle the bundling yourself.\n\n**Additional Worker Options**\n\nThis is a selected subset of options you are likely to use. Even more advanced options, particularly for performance tuning, are available in [the API reference](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions).\n\n| Options         | Description                                                                                                                           |\n| --------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| `dataConverter` | Encodes and decodes data entering and exiting a Temporal Server. Supports `undefined`, `UintBArray`, and JSON.                        |\n| `sinks`         | Allows injection of Workflow Sinks (Advanced feature: see [Logging docs](/typescript/logging))                                        |\n| `interceptors`  | A mapping of interceptor type to a list of factories or module paths (Advanced feature: see [Interceptors](/typescript/interceptors)) |\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)\n\n</TabItem>\n</Tabs>\n\n### Register types\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it fails that Task.\nHowever, the failure of the Task does not cause the associated Workflow Execution to fail.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nThe `RegisterWorkflow()` and `RegisterActivity()` calls essentially create an in-memory mapping between the Workflow Types and their implementations, inside the Worker process.\n\n**Registering Activity `structs`**\n\nPer [Activity Definition](#develop-activities) best practices, you might have an Activity struct that has multiple methods and fields.\nWhen you use `RegisterActivity()` for an Activity struct, that Worker has access to all exported methods.\n\n**Registering multiple Types**\n\nTo register multiple Activity Types and/or Workflow Types with the Worker Entity, just make multiple Activity registration calls, but make sure each Type name is unique:\n\n```go\nw.registerActivity(ActivityA)\nw.registerActivity(ActivityB)\nw.registerActivity(ActivityC)\nw.registerWorkflow(WorkflowA)\nw.registerWorkflow(WorkflowB)\nw.registerWorkflow(WorkflowC)\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nUse `worker.registerWorkflowImplementationTypes` to register Workflow type and `worker.registerActivitiesImplementations` to register Activity implementation with Workers.\n\nFor Workflows, the Workflow Type is registered with a Worker.\nA Workflow Type can be registered only once per Worker entity.\nIf you define multiple Workflow implementations of the same type, you get an exception at the time of registration.\n\nFor Activities, Activity implementation instances are registered with a Worker because they are stateless and thread-safe.\nYou can pass any number of dependencies in the Activity implementation constructor, such as the database connections, services, etc.\n\nThe following example shows how to register a Workflow and an Activity with a Worker.\n\n```java\n    Worker worker = workerFactory.newWorker(\"your_task_queue\");\n    ...\n    // Register Workflow\n    worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n    // Register Activity\n    worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n```\n\nWhen you register a single instance of an Activity, you can have multiple instances of Workflow Executions calling the same Activity.\nActivity code must be thread-safe because the same instance of the Activity code is run for every Workflow Execution that calls it.\n\nFor `DynamicWorkflow`, only one Workflow implementation that extends `DynamicWorkflow` can be registered with a Worker.\nThe following example shows how to register the `DynamicWorkflow` and `DynamicActivity` implementation with a Worker.\n\n```java\n  public static void main(String[] arg) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker(TASK_QUEUE);\n\n    /* Register the Dynamic Workflow implementation with the Worker. Workflow implementations\n    ** must be known to the Worker at runtime to dispatch Workflow Tasks.\n    */\n    worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    // Start all the Workers that are in this process.\n    factory.start();\n\n    /* Create the Workflow stub. Note that the Workflow type is not explicitly registered with the Worker. */\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n    /**\n     * Register Dynamic Activity implementation with the Worker. Since Activities are stateless\n     * and thread-safe, we need to register a shared instance.\n    */\n    worker.registerActivitiesImplementations(new DynamicGreetingActivityImpl());\n\n    /* Start Workflow Execution and immmediately send Signal. Pass in the Workflow args and Signal args. */\n    workflow.signalWithStart(\"greetingSignal\", new Object[] {\"John\"}, new Object[] {\"Hello\"});\n\n    // Wait for the Workflow to finish getting the results.\n    String result = workflow.getResult(String.class);\n\n    System.out.println(result);\n\n    System.exit(0);\n  }\n}\n```\n\nYou can register multiple type-specific Workflow implementations alongside a single `DynamicWorkflow` implementation.\nYou can register only one Activity instance that implements `DynamicActivity` with a Worker.\n\n</TabItem>\n<TabItem value=\"php\">\n\nWorker listens on a task queue and hosts both workflow and activity implementations:\n\n```php\n// Workflows are stateful. So you need a type to create instances:\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n// Activities are stateless and thread safe:\n$worker->registerActivity(App\\DemoActivity::class);\n```\n\nIn case an activity class requires some external dependencies provide a callback - factory\nthat creates or builds a new activity instance. The factory should be a callable which accepts\nan instance of ReflectionClass with an activity class which should be created.\n\n```php\n$worker->registerActivity(\n    App\\DemoActivity::class,\n    fn(ReflectionClass $class) => $container->create($class->getName())\n);\n```\n\nIf you want to clean up some resources after activity is done, you may register a finalizer. This callback is called\nafter each activity invocation:\n\n```php\n$worker->registerActivityFinalizer(fn() => $kernel->showtdown());\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nWhen a `Worker` is created, it accepts a list of Workflows in the `workflows` parameter, a list of Activities in the `activities` parameter, or both.\n\n```python\nworker = Worker(\n    client,\n    task_queue=\"your-task-queue\",\n    workflows=[YourWorkflow1, YourWorkflow2],\n    activities=[your_activity_1, your_activity_2],\n)\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nWe recommend resolving on a directory to register each function within the directory.\n\n- Use [`workflowsPath`](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#workflowspath) for non-production build images.\n- Use [`workflowBundle`](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#workflowbundle) for production build images.\n\n<!--SNIPSTART typescript-worker-create -->\n<!--SNIPEND-->\n\nFor example, in most of our samples:\n\n- We use `ts-node`, which compiles TypeScript on the fly.\n- Our Workers bundle Workflow code at runtime.\n\nWe can improve our Worker's startup time by building code in advance.\n\n**Worker code**\n\nThe Worker code can be built and run with:\n\n```sh\nnpm run build\nnode lib/worker.js\n```\n\n**Workflow code**\n\nYou can programmatically bundle Workflow code on your own with [`bundleWorkflowCode`](/typescript/workers#prebuilt-workflow-bundles):\n\n```ts\nconst {code} = await bundleWorkflowCode({\n  workflowsPath: require.resolve(\"src/workflows\"),\n});\n\nawait writeFile(path.join(__dirname, \"workflow-bundle.js\"), code);\n```\n\nAnd then the bundle can be passed to the Worker:\n\n```ts\nconst worker = await Worker.create({\n  workflowBundle: {path: require.resolve(\"workflow-bundle.js\")},\n  activities,\n  taskQueue,\n});\n```\n\nYou can also bundle code on your own and pass it to the `workflowBundle`.\n\nWe can see this process working in the [production sample](https://github.com/temporalio/samples-typescript/tree/main/production):\n\n<!--SNIPSTART typescript-production-worker-->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\n## Start Workflow Execution\n\n[Workflow Execution](/workflows#workflow-execution) semantics rely on several parametersthat is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.\n\nIn the examples below, all Workflow Executions are started using a Temporal Client.\nTo spawn Workflow Executions from within another Workflow Execution, use either the [Child Workflow](#child-workflows) or External Workflow APIs.\n\nSee the [Customize Workflow Type](#customize-workflow-type) section to see how to customize the name of the Workflow Type.\n\nA request to spawn a Workflow Execution causes the Temporal Cluster to create the first Event ([WorkflowExecutionStarted](/references/events/#workflowexecutionstarted)) in the Workflow Execution Event History.\nThe Temporal Cluster then creates the first Workflow Task, resulting in the first [WorkflowTaskScheduled](/references/events/#workflowtaskscheduled) Event.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo spawn a [Workflow Execution](/workflows#workflow-execution), use the `ExecuteWorkflow()` method on the Go SDK [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nThe `ExecuteWorkflow()` API call requires an instance of [`context.Context`](https://pkg.go.dev/context#Context), an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions), a Workflow Type name, and all variables to be passed to the Workflow Execution.\nThe `ExecuteWorkflow()` call returns a Future, which can be used to get the result of the Workflow Execution.\n\n```go\npackage main\n\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n  workflowOptions := client.StartWorkflowOptions{\n    // ...\n  }\n  workflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n  if err != nil {\n    // ...\n  }\n  // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n}\n```\n\nIf the invocation process has access to the function directly, then the Workflow Type name parameter can be passed as if the function name were a variable, without quotations.\n\n```go\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n```\n\nIf the invocation process does not have direct access to the statically defined Workflow Definition, for example, if the Workflow Definition is in an un-importable package, or it is written in a completely different language, then the Workflow Type can be provided as a `string`.\n\n```go\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, \"YourWorkflowDefinition\", param)\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nUse `WorkflowStub` to start a Workflow Execution from within a Client, and `ExternalWorkflowStub` to start a different Workflow Execution from within a Workflow.\n\nSee [`SignalwithStart`](/application-development/features#signal-with-start) to start a Workflow Execution to receive a Signal from within another Workflow.\n\n**Using `WorkflowStub`**\n\n`WorkflowStub` is a proxy generated by the `WorkflowClient`.\nEach time a new Workflow Execution is started, an instance of the Workflow implementation object is created.\nThen, one of the methods (depending on the Workflow Type of the instance) annotated with `@WorkflowMethod` can be invoked.\nAs soon as this method returns, the Workflow Execution is considered to be complete.\n\nYou can use a typed or untyped `WorkflowStub` in the client code.\n\n- Typed `WorkflowStub` are useful because they are type safe and allow you to invoke your Workflow methods such as `@WorkflowMethod`, `@QueryMethod`, and `@SignalMethod` directly.\n- An untyped `WorkflowStub` does not use the Workflow interface, and is not type safe. It is more flexible because it has methods from the `WorkflowStub` interface, such as `start`, `signalWithStart`, `getResults` (sync and async), `query`, `signal`, `cancel` and `terminate`.\n  Note that the Temporal Java SDK also provides typed `WorkflowStub` versions for these methods.\n  When using untyped `WorkflowStub`, we rely on the Workflow Type, Activity Type, Child Workflow Type, as well as Query and Signal names.\n  For details, see [Temporal Client](#connect-to-a-cluster).\n\nA Workflow Execution can be started either synchronously or asynchronously.\n\n- Synchronous invocation starts a Workflow and then waits for its completion. If the process that started the Workflow crashes or stops waiting, the Workflow continues executing.\n  Because Workflows are potentially long-running, and Client crashes happen, it is not very commonly found in production use.\n  The following example is a type-safe approach for starting a Workflow Execution synchronously.\n\n  ```java\n    NotifyUserAccounts workflow = client.newWorkflowStub(\n          NotifyUserAccounts.class,\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(\"notifyAccounts\")\n                  .setTaskQueue(taskQueue)\n                  .build()\n          );\n\n  // start the Workflow and wait for a result.\n    workflow.notify(new String[] { \"Account1\", \"Account2\", \"Account3\", \"Account4\", \"Account5\",\n                  \"Account6\", \"Account7\", \"Account8\", \"Account9\", \"Account10\"});\n      }\n  // notify(String[] accountIds) is a Workflow method defined in the Workflow Definition.\n  ```\n\n- Asynchronous start initiates a Workflow Execution and immediately returns to the caller. This is the most common way to start Workflows in production code.\n  The `WorkflowClient`<https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/client/WorkflowClient.java)> provides some static methods, such as `start`, `execute`, `signalWithStart` etc., that help with starting your Workflows asynchronously.\n\n  The following examples show how to start Workflow Executions asynchronously, with either typed or untyped `WorkflowStub`.\n\n  - **Typed WorkflowStub Example**\n\n    ```java\n    // create typed Workflow stub\n    FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n          WorkflowOptions.newBuilder()\n                  .setTaskQueue(taskQueue)\n                  .setWorkflowId(workflowId)\n                  .build());\n    // use WorkflowClient.execute to return future that contains Workflow result or failure, or\n    // use WorkflowClient.start to return WorkflowId and RunId of the started Workflow).\n    WorkflowClient.start(workflow::greetCustomer);\n    ```\n\n  - **Untyped WorkflowStub Example**\n\n    ```java\n    WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(workflowId)\n                  .setTaskQueue(taskQueue)\n                  .build());\n\n    // blocks until Workflow Execution has been started (not until it completes)\n    untyped.start(argument);\n    ```\n\nYou can call a Dynamic Workflow implementation using an untyped `WorkflowStub`.\nThe following example shows how to call the Dynamic Workflow implementation in the Client code.\n\n```java\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    /**\n      * Note that for this part of the client code, the dynamic Workflow implementation must\n      * be known to the Worker at runtime in order to dispatch Workflow tasks, and may be defined\n      * in the Worker definition as:*/\n    // worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    /* Create the Workflow stub to call the dynamic Workflow.\n    * Note that the Workflow type is not explicitly registered with the Worker.*/\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n```\n\n`DynamicWorkflow` can be used to invoke different Workflow Types.\nTo check what type is running when your Dynamic Workflow `execute` method runs, use `getWorkflowType()` in the implementation code.\n\n```java\nString type = Workflow.getInfo().getWorkflowType();\n```\n\nSee [Workflow Execution Result](#get-workflow-results) for details on how to get the results of the Workflow Execution.\n\n**Using `ExternalWorkflowStub`**\n\nUse `ExternalWorkflowStub` within a Workflow to invoke, and send Signals to, other Workflows by type.\n\nThis helps particularly for executing Workflows written in other language SDKs, as shown in the following example.\n\n```java\n@Override\n  public String yourWFMethod(String name) {\n      ExternalWorkflowStub callOtherWorkflow = Workflow.newUntypedExternalWorkflowStub(\"OtherWFId\");\n    }\n```\n\nSee the [Temporal Polyglot](https://github.com/tsurdilo/temporal-polyglot) code for examples of executing Workflows written in other language SDKs.\n\n**Recurring start**\n\nYou can start a Workflow Execution on a regular schedule by using [`setCronSchedule`](/java/reference-workflowoptions/#cronschedule) Workflow option in the Client code.\n\n</TabItem>\n<TabItem value=\"php\">\n\nWorkflows can be started both synchronously and asynchronously. You can use typed or untyped workflows stubs available\nvia `Temporal\\Client\\WorkflowClient`. To create workflow client:\n\n```php\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$workflowClient = WorkflowClient::create(ServiceClient::create('localhost:7233'));\n```\n\n**Synchronous start**\n\nA synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the\ninvocation process and will continue executing even if the waiting process crashes or stops.\n\nMake sure to acquire workflow interface or class name you want to start. For example:\n\n```php\n#[WorkflowInterface]\ninterface AccountTransferWorkflowInterface\n{\n    #[WorkflowMethod(name: \"MoneyTransfer\")]\n    #[ReturnType('int')]\n    public function transfer(\n        string $fromAccountId,\n        string $toAccountId,\n        string $referenceId,\n        int $amountCents\n    );\n}\n```\n\nTo start such workflow in sync mode:\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$result = $accountTransfer->transfer(\n    'fromID',\n    'toID',\n    'refID',\n    1000\n);\n```\n\n**Asynchronous start**\n\nAn asynchronous start initiates a Workflow execution and immediately returns to the caller without waiting for a result.\nThis is the most common way to start Workflows in a live environment.\n\nTo start a Workflow asynchronously pass workflow stub instance and start parameters into `WorkflowClient`->`start`\nmethod.\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$run = $this->workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n```\n\nOnce started you can receive workflow ID via `WorkflowRun` object returned by start method:\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getExecution()->getID());\n```\n\n**Recurring start**\n\nYou can start a Workflow Execution on a regular schedule with [the CronSchedule option](/php/distributed-cron).\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo start a Workflow Execution in python, use either the [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) asynchronous methods in the Client.\n\nThe following code example starts a Workflow and returns its handle.\n\n```python\nasync def main():\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    handle = await client.start_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n```\n\nThe following code example starts a Workflow and waits for completion.\n\n```python\nasync def main():\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    handle = await client.execute_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nWhen you have a Workflow Client, you can schedule the start of a Workflow with `client.start()`, specifying `workflowId`, `taskQueue`, and `args` and returning a Workflow handle immediately after the Server acknowledges the receipt.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: \"your-workflow-id\",\n  taskQueue: \"your-task-queue\",\n  args: [\"argument01\", \"argument02\", \"argument03\"], // this is typechecked against workflowFn's args\n});\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nCalling `client.start()` and `client.execute()` send a command to Temporal Server to schedule a new Workflow Execution on the specified Task Queue. It does not actually start until a Worker that has a matching Workflow Type, polling that Task Queue, picks it up.\n\nYou can test this by executing a Workflow Client command without a matching Worker. Temporal Server records the command in Event History, but does not make progress with the Workflow Execution until a Worker starts polling with a matching Task Queue and Workflow Definition.\n\nWorkflow Execution run in a separate V8 isolate context in order to provide a [deterministic runtime](/typescript/determinism).\n\n</TabItem>\n</Tabs>\n\n### Set Task Queue\n\nIn most SDKs, the only Workflow Option that must be set is the name of the [Task Queue](/tasks#task-queue).\n\nFor any code to execute, a Worker Process must be running that contains a Worker Entity that is polling the same Task Queue name.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None, this is a required field to be set by the developer\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  TaskQueue: \"your-task-queue\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nSet the Workflow Task Queue with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setTaskQueue`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                // Set the Task Queue\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\nIn PHP, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```php\n// Create new Workflow Options and set the Task Queue\n$workflowOptions = WorkflowOptions::new()\n  ->withTaskQueue(\"Workflow-Task-Queue-1\")\n  // ...\n\n$yourWorkflow = $workflowClient->newWorkflowStub(\n  YourWorkflowInterface::class,\n  $workflowOptions\n);\n\n$result = $yourWorkflow->workflowMethod();\n\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```php\nuse Temporal\\WorkerFactory;\n\n// Create a Worker Factory\n$factory = WorkerFactory::create();\n\n// Set the Task Queue when creating the Worker\n$worker = $factory->newWorker(\"Workflow-Task-Queue-1\");\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(YourWorkflow::class);\n\n// start primary loop\n$factory->run();\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```php\nclass YourWorkflow implements YourWorkflowInterface\n{\n  private $yourActivity;\n\n  public function __construct()\n  {\n    // Create Activity options and set the Task Queue\n    $activityOptions = ActivityOptions::new()\n      ->withTaskQueue(\"Activity-Task-Queue-1\")\n      // ...\n\n    // Create a new Activity Stub and pass the options\n    $this->yourActivity = Workflow::newActivityStub(\n      YourActivityInterface::class,\n      $activityOptions\n    );\n  }\n\n  public function workflowMethod(): \\Generator\n  {\n    // Call the Activity\n    return yield $this->yourActivity->activityMethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```php\n//Create new Child Workflow Options and set the Task Queue\n$childWorkflowOptions = ChildWorkflowOptions::new()\n    ->withTaskQueue(\"Child-Workflow-Task-Queue-1\")\n    // ...\n\n// Create a new Child Workflow Stub and set the Task Queue\n$childWorkflow = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    $childWorkflowOptions\n);\n\n// Call the Child Workflow method\n$promise = $childWorkflow->workflowMethod();\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo set a Task Queue in Python, specify the `task_queue` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) methods.\n\n```python\nresult = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nA Task Queue is a dynamic queue in Temporal polled by one or more Workers.\n\nWorkers bundle Workflow code and node modules using Webpack v5 and execute them inside V8 isolates. Activities are directly required and run by Workers in the Node.js environment.\n\nWorkers are flexible. You can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers on a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker.\n- Workflow bundle, specify one of the following options:\n  - a `workflowsPath` to your `workflows.ts` file to pass to Webpack. For example, `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n  - Or pass a prebuilt bundle to `workflowBundle`, if you prefer to handle the bundling yourself.\n\n```ts\nimport {Worker} from \"@temporalio/worker\";\nimport * as activities from \"./activities\";\n\nasync function run() {\n  // Step 1: Register Workflows and Activities with the Worker and connect to\n  // the Temporal server.\n  const worker = await Worker.create({\n    workflowsPath: require.resolve(\"./workflows\"),\n    activities,\n    taskQueue: \"hello-world\",\n  });\n  // Worker connects to localhost by default and uses console.error for logging.\n  // Customize the Worker by passing more options to create():\n  // https://typescript.temporal.io/api/classes/worker.Worker\n  // If you need to configure server connection parameters, see docs:\n  // /typescript/security#encryption-in-transit-with-mtls\n\n  // Step 2: Start accepting tasks on the `tutorial` queue\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n`taskQueue` is the only required option; however, use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nWhen scheduling a Workflow, a `taskQueue` must be specified.\n\n```ts\nimport {Connection, WorkflowClient} from \"@temporalio/client\";\n// This is the code that is used to start a workflow.\nconst connection = await Connection.create();\nconst client = new WorkflowClient({connection});\nconst result = await client.execute(yourWorkflow, {\n  // required\n  taskQueue: \"your-task-queue\",\n  // required\n  workflowId: \"your-workflow-id\",\n});\n```\n\nWhen creating a Worker, you must pass the `taskQueue` option to the `Worker.create()` function.\n\n```ts\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: \"your-task-queue\",\n});\n```\n\nOptionally, in Workflow code, when calling an Activity, you can specify the Task Queue by passing the `taskQueue` option to `proxyActivities()`, `startChild()`, or `executeChild()`. If you do not specify a `taskQueue`, then the TypeScript SDK places Activity and Child Workflow Tasks in the same Task Queue as the Workflow Task Queue.\n\n</TabItem>\n</Tabs>\n\n### Workflow Id\n\nAlthough it is not required, we recommend providing your own [Workflow Id](/workflows#workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: System generated UUID\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  ID: \"Your-Custom-Workflow-Id\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nSet the Workflow Id with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowId`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                // Set the Workflow Id\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n\n</TabItem>\n<TabItem value=\"php\">\n\nThe following code example grabs the `userID` as an input and uses it to start the Workflow. The `userID` is used as Workflow Id. You can use this to cancel your Workflow later.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(string $userID);\n}\n```\n\nThe following code example, uses the input parameter `userID` as the Workflow Id.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(\n        string $userID\n    );\n}\n```\n\nYou can also set the Workflow Id as a constant, for example:\n\n```php\n public const WORKFLOW_ID = Your-Workflow-Id\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo set a Workflow Id in Python, specify the `id` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) methods.\n\nThe `id` argument should be a unique identifier for the Workflow Execution.\n\n```python\nresult = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nConnect to a Client with `client.start()` and any arguments. Then specify your `taskQueue` and set your `workflowId` to a meaningful business identifier.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: \"yourWorkflowId\",\n  taskQueue: \"yourTaskQueue\",\n  args: [\"your\", \"arg\", \"uments\"],\n});\n```\n\nThis starts a new Client with the given Workflow Id, Task Queue name, and an argument.\n\n</TabItem>\n</Tabs>\n\n### Get Workflow results\n\nIf the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.\n\nThe Workflow Id, Run Id, and Namespace may be used to uniquely identify a Workflow Execution in the system and get its result.\n\nIt's possible to both block progress on the result (synchronous execution) or get the result at some other point in time (asynchronous execution).\n\nIn the Temporal Platform, it's also acceptable to use Queries as the preferred method for accessing the state and results of Workflow Executions.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nThe `ExecuteWorkflow` call returns an instance of [`WorkflowRun`](https://pkg.go.dev/go.temporal.io/sdk/client#WorkflowRun), which is the `workflowRun` variable in the following line.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, app.YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n // ...\n}\n```\n\nThe instance of `WorkflowRun` has the following three methods:\n\n- `GetWorkflowID()`: Returns the Workflow Id of the invoked Workflow Execution.\n- `GetRunID()`: Always returns the Run Id of the initial Run (See [Continue As New](#)) in the series of Runs that make up the full Workflow Execution.\n- `Get`: Takes a pointer as a parameter and populates the associated variable with the Workflow Execution result.\n\nTo wait on the result of Workflow Execution in the same process that invoked it, call `Get()` on the instance of `WorkflowRun` that is returned by the `ExecuteWorkflow()` call.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n}\n```\n\nHowever, the result of a Workflow Execution can be obtained from a completely different process.\nAll that is needed is the [Workflow Id](#).\n(A [Run Id](#) is optional if more than one closed Workflow Execution has the same Workflow Id.)\nThe result of the Workflow Execution is available for as long as the Workflow Execution Event History remains in the system.\n\n<!-- TODO (See [How long do Workflow Execution Histories persist](#)). -->\n\nCall the `GetWorkflow()` method on an instance of the Go SDK Client and pass it the Workflow Id used to spawn the Workflow Execution.\nThen call the `Get()` method on the instance of `WorkflowRun` that is returned, passing it a pointer to populate the result.\n\n```go\n // ...\n workflowID := \"Your-Custom-Workflow-Id\"\n workflowRun := c.GetWorkflow(context.Background, workflowID)\n\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n```\n\n**Get last completion result**\n\nIn the case of a [Temporal Cron Job](/workflows#temporal-cron-job), you might need to get the result of the previous Workflow Run and use it in the current Workflow Run.\n\nTo do this, use the [`HasLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#HasLastCompletionResult) and [`GetLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLastCompletionResult) APIs, available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package, directly in your Workflow code.\n\n```go\ntype CronResult struct {\n Count int\n}\n\nfunc YourCronWorkflowDefinition(ctx workflow.Context) (CronResult, error) {\n count := 1\n\n if workflow.HasLastCompletionResult(ctx) {\n   var lastResult CronResult\n   if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {\n     count = count + lastResult.Count\n   }\n }\n\n newResult := CronResult {\n   Count: count,\n }\n return newResult, nil\n}\n```\n\nThis will work even if one of the cron Workflow Runs fails.\nThe next Workflow Run gets the result of the last successfully Completed Workflow Run.\n\n</TabItem>\n<TabItem value=\"java\">\n\nA synchronous Workflow Execution blocks your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure).\n\nThe following example is a type-safe approach for getting the results of a synchronous Workflow Execution.\n\n```java\n FileProcessingWorkflow workflow = client.newWorkflowStub(\n                FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setWorkflowId(workflowId)\n                        .setTaskQueue(taskQueue)\n                        .build();\n\n// start sync and wait for results (or failure)\nString result = workflow.processfile(new Argument());\n```\n\nAn asynchronous Workflow Execution immediately returns a value to the caller.\n\nThe following examples show how to get the results of a Workflow Execution through typed and untyped `WorkflowStub`.\n\n- **Typed WorkflowStub Example**\n\n  ```java\n  // create typed Workflow stub\n  FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setTaskQueue(taskQueue)\n                        .setWorkflowId(workflowId)\n                        .build());\n  // use WorkflowClient.execute (if your Workflow takes in arguments) or WorkflowClient.start (for zero arguments)\n  WorkflowClient.start(workflow::greetCustomer);\n  ```\n\n- **Untyped WorkflowStub Example**\n\n  ```java\n  WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n                  WorkflowOptions.newBuilder()\n                          .setWorkflowId(workflowId)\n                          .setTaskQueue(taskQueue)\n                          .build());\n\n  // blocks until Workflow Execution has been started (not until it completes)\n  untyped.start(argument);\n  ```\n\nIf you need to wait for a Workflow Execution to complete after an asynchronous start, the most straightforward way is to call the blocking Workflow instance again.\n\nNote that if `WorkflowOptions.WorkflowIdReusePolicy` is not set to `AllowDuplicate`, then instead of throwing `DuplicateWorkflowException`, it reconnects to an existing Workflow and waits for its completion.\n\nThe following example shows how to do this from a different process than the one that started the Workflow Execution.\n\n```java\nYourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflow.yourMethod();\n```\n\nAnother way to connect to an existing Workflow and wait for its completion from another process, is to use `UntypedWorkflowStub`. For example:\n\n```java\nWorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = untyped.getResult(String.class);\n```\n\n**Get last (successful) completion result**\n\nFor a Temporal Cron Job, get the result of previous successful runs using `GetLastCompletionResult()`.\nThe method returns `null` if there is no previous completion.\nThe following example shows how to implement this in a Workflow.\n\n```java\npublic String cronWorkflow() {\n    String lastProcessedFileName = Workflow.getLastCompletionResult(String.class);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the Cron schedule runs failed.\nThe next schedule will still get the last successful result if it ever successfully completed at least once.\nFor example, for a daily cron Workflow, if the run succeeds on the first day and fails on the second day, then the third day run will get the result from first day's run using these APIs.\n\n</TabItem>\n<TabItem value=\"php\">\n\nIf you need to wait for the completion of a Workflow after an asynchronous start, make a blocking call to\nthe `WorkflowRun`->`getResult` method.\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getResult());\n```\n\n</TabItem>\n<TabItem value=\"python\">\n\nUse [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.client#get_workflow_handle) to return a Workflow handle.\nThen use the [`result`](https://python.temporal.io/temporalio.client.workflowhandle#result) method to await on the result of the Workflow.\n\n```python\nhandle = await client.start_workflow(\n    YourWorkflow.run, \"some arg\", id=\"your-workflow-id\", task_queue=\"your-task-queue\"\n)\n\n# Wait for result\nresult = await handle.result()\nprint(f\"Result: {result}\")\n```\n\nTo get a handle for an existing Workflow by its Id, you can use [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.client#get_workflow_handle), or use [`get_workflow_handle_for()`](https://python.temporal.io/temporalio.client.client#get_workflow_handle_for) for type safety.\n\nThen use [`describe()`](https://python.temporal.io/temporalio.client.workflowhandle#describe) to get the current status of the Workflow.\nIf the Workflow does not exist, this call fails.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nTo return the results of a Workflow Execution:\n\n```typescript\nreturn (\n  \"Completed \" +\n  wf.workflowInfo().workflowId +\n  \", Total Charged: \" +\n  totalCharged\n);\n```\n\n`totalCharged` is just a function declared in your code. For a full example, see [subscription-workflow-project-template-typescript/src/workflows.ts](https://github.com/temporalio/subscription-workflow-project-template-typescript/blob/main/src/workflows.ts).\n\nA Workflow function may return a result. If it doesnt (in which case the return type is `Promise<void>`), the result will be `undefined`.\n\nIf you started a Workflow with `handle.start()`, you can choose to wait for the result anytime with `handle.result()`.\n\n```typescript\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nUsing a Workflow Handle isn't necessary with `client.execute()`.\n\nWorkflows that prematurely end will throw a `WorkflowFailedError` if you call `result()`.\n\nIf you call `result()` on a Workflow that prematurely ended for some reason, it throws a [`WorkflowFailedError` error](https://typescript.temporal.io/api/classes/client.workflowfailederror/) that reflects the reason. For that reason, it is recommended to catch that error.\n\n```typescript\nconst handle = client.getHandle(workflowId);\ntry {\n  const result = await handle.result();\n} catch (err) {\n  if (err instanceof WorkflowFailedError) {\n    throw new Error(\"Temporal workflow failed: \" + workflowId, {\n      cause: err,\n    });\n  } else {\n    throw new Error(\"error from Temporal workflow \" + workflowId, {\n      cause: err,\n    });\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n"},{"file_name":"observability.md","id":"observability","file_dir":"application-development","title":"Application development - Observability","sidebar_label":"Observability","description":"The Observability section of the Temporal Application development guide covers the many ways to view the current state of your Temporal Application  that is, ways to view what Workflow Executions are tracked by the Platform and the state of any given Workflow Execution, either currently or at points of an execution.","use_description":false,"toc_max_heading_level":4,"add_tabs_support":false,"sections":[{"type":"p","id":"app-dev-context/observability","node":{"file_name":"observability.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/observability.md","id":"app-dev-context/observability","title":"How to use Temporal Observability features","description":"The observability section of the Temporal Application development guide covers the many ways to view the current state of your Temporal Applicationthat is, ways to view which Workflow Executions are tracked by the Temporal Platform and the state of any specified Workflow Execution, either currently or at points of an execution","label":"Observability","tags":["guide-context"],"markdown_content":"The observability section of the Temporal Application development guide covers the many ways to view the current state of your [Temporal Application](/temporal#temporal-application)that is, ways to view which [Workflow Executions](/workflows#workflow-execution) are tracked by the [Temporal Platform](/temporal#temporal-platform) and the state of any specified Workflow Execution, either currently or at points of an execution.\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Application development guide, it could be in [older docs for SDKs](/sdks).\n\n:::\n\nThis section covers features related to viewing the state of the application, including:\n\n- [Metrics](#metrics)\n- [Tracing](#tracing)\n- [Logging](#logging)\n- [Visibility](#visibility)\n- [Replays](#replays)","is_empty":false}},{"type":"h2","id":"app-dev-context/metrics","node":{"file_name":"metrics.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/metrics.md","id":"app-dev-context/metrics","title":"How to emit metrics","description":"Each Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.","label":"Metrics","tags":["guide-context"],"markdown_content":"Each Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.\nFor a complete list of metrics capable of being emitted, see the [SDK metrics reference](/references/sdk-metrics).\n\nMetrics can be scraped and stored in time series databases, such as:\n\n- [Prometheus](https://prometheus.io/docs/introduction/overview/)\n- [M3db](https://m3db.io/docs/)\n- [statsd](https://github.com/statsd/statsd)\n\nTemporal also provides a dashboard you can integrate with graphing services like [Grafana](https://grafana.com/docs/). For more information, see:\n\n- Temporal's implementation of the [Grafana dashboard](https://github.com/temporalio/dashboards)\n- [How to export metrics in Grafana](https://github.com/temporalio/helm-charts#exploring-metrics-via-grafana)","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-emit-metrics-in-go","node":{"file_name":"how-to-emit-metrics-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-emit-metrics-in-go.md","id":"go/how-to-emit-metrics-in-go","title":"How to emit metrics in Go","description":"Emit metrics","label":"Emit metrics","tags":["go","how-to"],"markdown_content":"To emit metrics from the Temporal Client in Go, create a [metrics handler](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler) from the [Client Options](https://pkg.go.dev/go.temporal.io/sdk@v1.15.0/internal#ClientOptions) and specify a listener address to be used by Prometheus.\n\n```go\nclient.Options{\n\t\tMetricsHandler: sdktally.NewMetricsHandler(newPrometheusScope(prometheus.Configuration{\n\t\t\tListenAddress: \"0.0.0.0:9090\",\n\t\t\tTimerType:     \"histogram\",\n\t\t}\n```\n\nThe Go SDK currently supports the [Tally](https://pkg.go.dev/go.temporal.io/sdk/contrib/tally) library; however, Tally offers [extensible custom metrics reporting](https://github.com/uber-go/tally#report-your-metrics), which is exposed through the [`WithCustomMetricsReporter`](/references/server-options#withcustommetricsreporter) API.\n\nFor more information, see the [Go sample for metrics](https://github.com/temporalio/samples-go/tree/main/metrics).","is_empty":false}},{"lang":"java","id":"java/how-to-emit-metrics-in-java","node":{"file_name":"how-to-emit-metrics-in-java.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/java/how-to-emit-metrics-in-java.md","id":"java/how-to-emit-metrics-in-java","title":"How to emit metrics in Java","description":"To emit metrics with the Java SDK, use `WorkflowServiceStubsOptions.Builder.setMetricsScope` to set the metrics scope in your Worker or Client code.","label":"Emit metrics","tags":["developer-guide","java"],"markdown_content":"To emit metrics with the Java SDK, use [`MicrometerClientStatsReporter`](https://github.com/temporalio/sdk-java/blob/55ee7894aec427d7e384c3519732bdd61119961a/src/main/java/io/temporal/common/reporter/MicrometerClientStatsReporter.java#L34) class to integrate with Micrometer MeterRegistry configured for your metrics backend.\n[Micrometer](https://micrometer.io/docs) is a popular Java framework that provides integration with Prometheus and other backends.\n\nThe following example shows how to use `MicrometerClientStatsReporter` to define the metrics scope and set it with the `WorkflowServiceStubsOptions`.\n\n```java\n//...\n   // see the Micrometer documentation for configuration details on other supported monitoring systems.\n   // in this example shows how to set up Prometheus registry and stats reported.\n   PrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\n   StatsReporter reporter = new MicrometerClientStatsReporter(registry);\n    // set up a new scope, report every 10 seconds\n     Scope scope = new RootScopeBuilder()\n             .reporter(reporter)\n             .reportEvery(com.uber.m3.util.Duration.ofSeconds(10));\n   // for Prometheus collection, expose a scrape endpoint.\n   //...\n   // add metrics scope to WorkflowServiceStub options\n   WorkflowServiceStubsOptions stubOptions =\n       WorkflowServiceStubsOptions.newBuilder().setMetricsScope(scope).build();\n//...\n```\n\nFor more details, see the [Java SDK Samples](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/metrics).\nFor details on configuring a Prometheus scrape endpoint with Micrometer, see <https://micrometer.io/docs/registry/prometheus#_configuring>.","is_empty":false}},{"lang":"php","id":"none"},{"lang":"typescript","id":"typescript/how-to-emit-metrics-typescript","node":{"file_name":"how-to-emit-metrics-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-emit-metrics-typescript.md","id":"typescript/how-to-emit-metrics-typescript","title":"How to emit metrics in TypeScript","description":"Emit metrics","label":"Emit metrics","tags":["developer-guide","sdk","typescript"],"markdown_content":"Workers can emit metrics and traces. There are a few [telemetry options](https://typescript.temporal.io/api/interfaces/worker.TelemetryOptions) that can be provided to [`Runtime.install`](https://typescript.temporal.io/api/classes/worker.runtime/#install). The common options are:\n\n- `metrics: { otel: { url } }`: The URL of a gRPC [OpenTelemetry collector](https://opentelemetry.io/docs/collector/).\n- `metrics: { prometheus: { bindAddress } }`: Address on the Worker host that will have metrics for [Prometheus](https://prometheus.io/) to scrape.\n\nTo set up tracing of Workflows and Activities, use our [opentelemetry-interceptors](/typescript/logging#opentelemetry-tracing) package.\n\n```typescript\n  telemetryOptions: {\n      metrics: {\n        prometheus: { bindAddress: '0.0.0.0:9464' },\n      },\n      logging: { forward: { level: 'DEBUG' } },\n    },\n```","is_empty":false}}]},{"type":"h2","id":"app-dev-context/tracing","node":{"file_name":"tracing.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/tracing.md","id":"app-dev-context/tracing","title":"How to setup Tracing","description":"Tracing allows you to view the call graph of a Workflow along with its Activities and any child Workflows.","label":"Tracing","tags":["guide-context"],"markdown_content":"Tracing allows you to view the call graph of a Workflow along with its Activities and any child Workflows.\n\nTemporal Web's tracing capabilities mainly track Activity Execution within a Temporal context. If you need custom tracing specific for your use case, you should make use of context propagation to add tracing logic accordingly.\n\nFor information about Workflow tracing, see [Tracing Temporal Workflows with DataDog](https://spiralscout.com/blog/tracing-temporal-workflow-with-datadog).\n\nFor information about how to configure exporters and instrument your code, see [Tracing Temporal Services with OTEL](https://github.com/temporalio/temporal/blob/master/develop/docs/tracing.md).","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-configure-tracing-in-go","node":{"file_name":"how-to-configure-tracing-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-configure-tracing-in-go.md","id":"go/how-to-configure-tracing-in-go","title":"How to configure tracing in Go","description":"Configure tracing","label":"Configure tracing","tags":["go","how-to"],"markdown_content":"The Go SDK provides support for distributed tracing through [OpenTracing](https://opentracing.io/).\nTracing allows you to view the call graph of a Workflow along with its Activities and any child Workflows.\n\nTracing can be configured by providing an [opentracing.Tracer](https://pkg.go.dev/github.com/opentracing/opentracing-go#Tracer)\nimplementation in [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions) during client instantiation.\n\nFor more details on how to configure and leverage tracing, see the [OpenTracing documentation](https://opentracing.io/docs/getting-started/).\n\nThe OpenTracing support has been validated using [Jaeger](https://www.jaegertracing.io/), but other implementations mentioned [here](https://opentracing.io/docs/supported-tracers/) should also work.\n\nTracing functionality utilizes generic context propagation provided by the Client.","is_empty":false}},{"lang":"java","id":"none"},{"lang":"php","id":"none"},{"lang":"typescript","id":"typescript/how-to-configure-tracing-in-typescript","node":{"file_name":"how-to-configure-tracing-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-configure-tracing-in-typescript.md","id":"typescript/how-to-configure-tracing-in-typescript","title":"How to configure tracing in TypeScript","description":"Configure tracing","label":"Configure tracing","tags":["developer-guide","sdk","typescript"],"markdown_content":"The [`interceptors-opentelemetry`](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry) sample shows how to use the SDK's built-in OpenTelemetry tracing to trace everything from starting a Workflow to Workflow Execution to running an Activity from that Workflow.\n\nThe built-in tracing uses protobuf message headers (like [this one](https://github.com/temporalio/api/blob/b2b8ae6592a8730dd5be6d90569d1aea84e1712f/temporal/api/workflowservice/v1/request_response.proto#L161) when starting a Workflow) to propagate the tracing information from the client to the Workflow and from the Workflow to its successors (when Continued As New), children, and Activities.\nAll of these executions are linked with a single trace identifier and have the proper `parent -> child` span relation.\n\nTracing is compatible between different Temporal SDKs as long as compatible [context propagators](https://opentelemetry.lightstep.com/core-concepts/context-propagation/) are used.\n\n**Context propagation**\n\nThe TypeScript SDK uses the global OpenTelemetry propagator.\n\nTo extend the default ([Trace Context](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#w3ctracecontextpropagator-propagator) and [Baggage](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#baggage-propagator) propagators) to also include the [Jaeger propagator](https://www.npmjs.com/package/@opentelemetry/propagator-jaeger), follow these steps:\n\n- `npm i @opentelemetry/propagator-jaeger`\n\n- At the top level of your Workflow code, add the following lines:\n\n  ```js\n  import {propagation} from \"@opentelemetry/api\";\n  import {\n    CompositePropagator,\n    W3CTraceContextPropagator,\n    W3CBaggagePropagator,\n  } from \"@opentelemetry/core\";\n  import {JaegerPropagator} from \"@opentelemetry/propagator-jaeger\";\n\n  propagation.setGlobalPropagator(\n    new CompositePropagator({\n      propagators: [\n        new W3CTraceContextPropagator(),\n        new W3CBaggagePropagator(),\n        new JaegerPropagator(),\n      ],\n    })\n  );\n  ```\n\nSimilarly, you can customize the OpenTelemetry `NodeSDK` propagators by following the instructions in the [Initialize the SDK](https://github.com/open-telemetry/opentelemetry-js/tree/main/experimental/packages/opentelemetry-sdk-node#initialize-the-sdk) section of the README.","is_empty":false}}]},{"type":"h2","id":"app-dev-context/logging","node":{"file_name":"logging.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/logging.md","id":"app-dev-context/logging","title":"How to log from a Workflow","description":"Send logs and errors to a logging service, so that when things go wrong, you can see what happened.","label":"Logging","tags":["guide-context"],"markdown_content":"Send logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nThe SDK core uses `WARN` for its default logging level.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-log-from-a-workflow-in-go","node":{"file_name":"how-to-log-from-a-workflow-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-log-from-a-workflow-in-go.md","id":"go/how-to-log-from-a-workflow-in-go","title":"How to log from a Workflow in TypeScript","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","go","log"],"markdown_content":"In Workflow Definitions you can use [`workflow.GetLogger(ctx)`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLogger) to write logs.\n\n```go\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"go.temporal.io/sdk/activity\"\n\t\"go.temporal.io/sdk/workflow\"\n)\n\n// Workflow is a standard workflow definition.\n// Note that the Workflow and Activity don't need to care that\n// their inputs/results are being compressed.\nfunc Workflow(ctx workflow.Context, name string) (string, error) {\n// ...\n\nworkflow.WithActivityOptions(ctx, ao)\n\n// Getting the logger from the context.\n\tlogger := workflow.GetLogger(ctx)\n// Logging a message with the key value pair `name` and `name`\n\tlogger.Info(\"Compressed Payloads workflow started\", \"name\", name)\n\n\tinfo := map[string]string{\n\t\t\"name\": name,\n\t}\n\n\n\tlogger.Info(\"Compressed Payloads workflow completed.\", \"result\", result)\n\n\treturn result, nil\n}\n```","is_empty":false}},{"lang":"java","id":"none"},{"lang":"php","id":"none"},{"lang":"python","id":"python/how-to-log-from-a-workflow-in-python","node":{"file_name":"how-to-log-from-a-workflow-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-log-from-a-workflow-in-python.md","id":"python/how-to-log-from-a-workflow-in-python","title":"How to log from a Workflow in Python","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"You can log from a Workflow using Python's standard library, by importing the logging module `import logging`.\n\nSet your logging configuration to a level you want to expose logs to.\nThe following example sets the logging information level to `INFO`.\n\n```python\nlogging.basicConfig(level=logging.INFO)\n```\n\nThen in your Workflow, set your [`logger`](https://python.temporal.io/temporalio.workflow.html#logger) and level on the Workflow. The following example logs the Workflow.\n\n```python\n@workflow.defn\nclass SayHelloWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        workflow.logger.info(f\"Running workflow with parameter {name}\")\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=10)\n        )\n```\n\nThe following is an example output:\n\n```\nINFO:temporalio.workflow:Running workflow with parameter Temporal ({'attempt': 1, 'your-custom-namespace': 'default', 'run_id': 'your-run-id', 'task_queue': 'your-task-queue', 'workflow_id': 'your-workflow-id', 'workflow_type': 'SayHelloWorkflow'})\n```\n\n:::note\n\nLogs are skipped during replay by default.\n\n:::","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-log-from-a-workflow-in-typescript","node":{"file_name":"how-to-log-from-a-workflow-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-log-from-a-workflow-in-typescript.md","id":"typescript/how-to-log-from-a-workflow-in-typescript","title":"How to log from a Workflow in TypeScript","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","typescript","log"],"markdown_content":"Logging from Workflows is tricky for two reasons:\n\n1. Workflows run in a sandboxed environment and cannot do any I/O.\n1. Workflow code might get replayed at any time, generating duplicate log messages.\n\nTo work around these limitations, we recommend using the Sinks feature in the TypeScript SDK.\nSinks enable one-way export of logs, metrics, and traces from the Workflow isolate to the Node.js environment.\n\n<!--\nWorkflows in Temporal may be replayed from the beginning of their history when resumed. In order for Temporal to recreate the exact state Workflow code was in, the code is required to be fully deterministic. To prevent breaking [determinism](/typescript/determinism), in the TypeScript SDK, Workflow code runs in an isolated execution environment and may not use any of the Node.js APIs or communicate directly with the outside world. -->\n\nSinks are written as objects with methods. Similar to Activities, they are declared in the Worker and then proxied in Workflow code, and it helps to share types between both.\n\n<details>\n  <summary>Comparing Sinks, Activities and Interceptors</summary>\n  \nSinks are similar to Activities in that they are both registered on the Worker and proxied into the Workflow.\nHowever, they differ from Activities in important ways:\n\n- Sink functions don't return any value back to the Workflow and cannot not be awaited.\n- Sink calls are not recorded in Workflow histories (no timeouts or retries).\n- Sink functions are _always_ run on the same Worker that runs the Workflow they are called from.\n\n</details>\n\n**Declaring the Sink Interface**\n\nExplicitly declaring a Sink's interface is optional, but is useful for ensuring type safety in subsequent steps:\n\n<!--SNIPSTART typescript-logger-sink-interface-->\n<!--SNIPEND-->\n\n**Implementing Sinks**\n\nImplementing Sinks is a two-step process.\n\nImplement and inject the Sink function into a Worker\n\n<!--SNIPSTART typescript-logger-sink-worker-->\n<!--SNIPEND-->\n\n- Sink function implementations are passed as an object into [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#sinks)\n- You can specify whether you want the injected function to be called during Workflow replay by setting the `callDuringReplay` boolean option.\n\n**Proxy and call a Sink function from a Workflow**\n\n<!--SNIPSTART typescript-logger-sink-workflow-->\n<!--SNIPEND-->\n\nSome important features of the [InjectedSinkFunction](https://typescript.temporal.io/api/interfaces/worker.InjectedSinkFunction) interface:\n\n- **Injected WorkflowInfo argument**: The first argument of a Sink function implementation is a [`workflowInfo` object](https://typescript.temporal.io/api/interfaces/workflow.workflowinfo/) that contains useful metadata.\n- **Limited arguments types**: The remaining Sink function arguments are copied between the sandbox and the Node.js environment using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n- **No return value**: To prevent breaking determinism, Sink functions cannot return values to the Workflow.\n\n**Advanced: Performance considerations and non-blocking Sinks**\n\nThe injected sink function contributes to the overall Workflow Task processing duration.\n\n- If you have a long-running sink function, such as one that tries to communicate with external services, you might start seeing Workflow Task timeouts.\n- The effect is multiplied when using `callDuringReplay: true` and replaying long Workflow histories because the Workflow Task timer starts when the first history page is delivered to the Worker.","is_empty":false}}]},{"type":"h3","id":"app-dev-context/custom-logging","node":{"file_name":"custom-logging.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/custom-logging.md","id":"app-dev-context/custom-logging","title":"How to provide a custom logger","description":"Use a custom logger for logging.","label":"Custom logger","tags":["guide-context"],"markdown_content":"Use a custom logger for logging.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-set-a-custom-logger-in-go","node":{"file_name":"how-to-set-a-custom-logger-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-set-a-custom-logger-in-go.md","id":"go/how-to-set-a-custom-logger-in-go","title":"How to set a custom logger in Go","description":"Set a custom logger","label":"Custom logger","tags":["go","how-to"],"markdown_content":"This field sets a custom Logger that is used for all logging actions of the instance of the Temporal Client.\n\nAlthough the Go SDK does not support most third-party logging solutions natively, [our friends at Banzai Cloud](https://github.com/sagikazarmark) built the adapter package [logur](https://github.com/logur/logur) which makes it possible to use third party loggers with minimal overhead.\nMost of the popular logging solutions have existing adapters in Logur, but you can find a full list [in the Logur Github project](https://github.com/logur?q=adapter-).\n\nHere is an example of using Logur to support [Logrus](https://github.com/sirupsen/logrus):\n\n```go\npackage main\nimport (\n  \"go.temporal.io/sdk/client\"\n\n\t\"github.com/sirupsen/logrus\"\n\tlogrusadapter \"logur.dev/adapter/logrus\"\n\t\"logur.dev/logur\"\n)\n\nfunc main() {\n  // ...\n  logger := logur.LoggerToKV(logrusadapter.New(logrus.New()))\n  clientOptions := client.Options{\n    Logger: logger,\n  }\n  temporalClient, err := client.Dial(clientOptions)\n  // ...\n}\n```","is_empty":false}},{"lang":"java","id":"none"},{"lang":"php","id":"none"},{"lang":"typescript","id":"typescript/how-to-set-a-custom-logger-in-typescript","node":{"file_name":"how-to-set-a-custom-logger-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-set-a-custom-logger-in-typescript.md","id":"typescript/how-to-set-a-custom-logger-in-typescript","title":"How to set a custom logger in TypeScript","description":"Set a custom logger","label":"Set a custom logger","tags":["developer-guide","sdk","typescript"],"markdown_content":"**Logging in Workers and Clients**\n\nThe Worker comes with a default logger which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThe following [log levels](https://typescript.temporal.io/api/namespaces/worker#loglevel) are listed in increasing order of severity.\n\n**Customizing the default logger**\n\nTemporal uses a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.defaultlogger/) that implements the basic interface:\n\n```ts\nimport {Runtime, DefaultLogger} from \"@temporalio/worker\";\n\nconst logger = new DefaultLogger(\"WARN\", ({level, message}) => {\n  console.log(`Custom logger: ${level}  ${message}`);\n});\nRuntime.install({logger});\n```\n\nThe previous code example sets the default logger to only log messages with level `WARN` and higher.\n\n**Accumulate logs for testing and reporting**\n\n```ts\nimport {DefaultLogger, LogEntry} from \"@temporalio/worker\";\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger(\"TRACE\", (entry) => logs.push(entry));\nlog.debug(\"hey\", {a: 1});\nlog.info(\"ho\");\nlog.warn(\"lets\", {a: 1});\nlog.error(\"go\");\n```\n\nA common logging use case is logging to a file to be picked up by a collector like the [Datadog Agent](https://docs.datadoghq.com/logs/log_collection/nodejs/?tab=winston30).\n\n```ts\nimport {Runtime} from \"@temporalio/worker\";\nimport winston from \"winston\";\n\nconst logger = winston.createLogger({\n  level: \"info\",\n  format: winston.format.json(),\n  transports: [new transports.File({filename: \"/path/to/worker.log\"})],\n});\nRuntime.install({logger});\n```","is_empty":false}}]},{"type":"h2","id":"app-dev-context/visibility","node":{"file_name":"visibility.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/visibility.md","id":"app-dev-context/visibility","title":"How to use Visibility APIs","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["guide-context"],"markdown_content":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","is_empty":false}},{"type":"h3","id":"app-dev-context/search-attributes","node":{"file_name":"search-attributes.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/search-attributes.md","id":"app-dev-context/search-attributes","title":"How to use Search Attributes","description":"Search Attributes enable complex List Filters to find the exact of Workflow Executions you are looking for.","label":"Search Attributes","tags":["guide-context"],"markdown_content":"The typical method of retrieving a Workflow Execution is by its Workflow Id.\n\nHowever, sometimes you'll want to retrieve one or more Workflow Executions based on another property. For example, imagine you want to get all Workflow Executions of a certain type that have failed within a time range, so that you can start new ones with the same arguments.\n\nYou can do this with [Search Attributes](/concepts/what-is-a-search-attribute/).\n\n- [**Default** Search Attributes](/concepts/what-is-a-search-attribute/#default-search-attributes) like `WorkflowType`, `StartTime` and `ExecutionStatus` are automatically added to Workflow Executions.\n- _Custom Search Attributes_ can contain their own domain-specific data (like `customerId` or `numItems`).\n  - A few [generic Custom Search Attributes](/concepts/what-is-a-search-attribute/#custom-search-attributes) like `CustomKeywordField` and `CustomIntField` are created by default in Temporal's [Docker Compose](/clusters/quick-install/#docker-compose).\n\nThe steps to using custom Search Attributes are:\n\n- Create a new Search Attribute in your Cluster [using `tctl`](/tctl/admin/cluster/add-search-attributes) or the Cloud UI.\n- Set the value of the Search Attribute for a Workflow Execution:\n  - On the Client by including it as an option when starting the Execution.\n  - In the Workflow by calling `UpsertSearchAttributes`.\n- Read the value of the Search Attribute:\n  - On the Client by calling `DescribeWorkflow`.\n  - In the Workflow by looking at `WorkflowInfo`.\n- Query Workflow Executions by the Search Attribute using a [List Filter](/concepts/what-is-a-list-filter/):\n  - [In `tctl`](/tctl/workflow/list/#--query).\n  - In code by calling `ListWorkflowExecutions`.\n\nHere is how to query Workflow Executions:","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-list-workflow-executions-using-the-client-in-go","node":{"file_name":"how-to-list-workflow-executions-using-the-client-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-list-workflow-executions-using-the-client-in-go.md","id":"go/how-to-list-workflow-executions-using-the-client-in-go","title":"How to list Workflow Executions using the Client in Go","description":"List Workflow Executions using the Client","label":"List Workflow Executions using the Client","tags":["developer-guide","go","client"],"markdown_content":"Use [`Client.ListWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/client#Client.ListWorkflow).","is_empty":false}},{"lang":"java","id":"none"},{"lang":"php","id":"none"},{"lang":"typescript","id":"typescript/how-to-list-workflow-executions-using-the-client-in-typescript","node":{"file_name":"how-to-list-workflow-executions-using-the-client-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-list-workflow-executions-using-the-client-in-typescript.md","id":"typescript/how-to-list-workflow-executions-using-the-client-in-typescript","title":"How to list Workflow Executions using the Client in TypeScript","description":"List Workflow Executions using the Client","label":"List Workflow Executions using the Client","tags":["developer-guide","typescript","client"],"markdown_content":"Use [`WorkflowService.listWorkflowExecutions`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#listworkflowexecutions):\n\n```typescript\nimport {Connection} from \"@temporalio/client\";\n\nconst connection = await Connection.connect();\nconst response = await connection.workflowService.listWorkflowExecutions({\n  query: `ExecutionStatus = \"Running\"`,\n});\n```\n\nwhere `query` is a [List Filter](/concepts/what-is-a-list-filter/).","is_empty":false}}]},{"type":"h3","id":"app-dev-context/set-custom-search-attributes","node":{"file_name":"set-custom-search-attributes.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/set-custom-search-attributes.md","id":"app-dev-context/set-custom-search-attributes","title":"How to set custom Search Attributes","description":"After you've created custom Search Attributes in your Cluster (using `tctl` or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.","label":"Custom Search Attributes","tags":["guide-context"],"markdown_content":"After you've created custom Search Attributes in your Cluster ([using `tctl`](/tctl/admin/cluster/add-search-attributes) or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go","node":{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go.md","id":"go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go","title":"How to add custom Search Attributes to Workflow Executions at start time in Go","description":"Add custom Search Attributes to Workflow Executions at start time","label":"Add custom Search Attributes to Workflow Executions at start time","tags":["developer-guide","go","client"],"markdown_content":"Provide key-value pairs in [`StartWorkflowOptions.SearchAttributes`](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions).\n\nSearch Attributes are represented as `map[string]interface{}`.\nThe values in the map must correspond to the [Search Attribute's value type](/concepts/what-is-a-search-attribute/#types):\n\n- Bool = `bool`\n- Datetime = `time.Time`\n- Double = `float64`\n- Int = `int64`\n- Keyword = `string`\n- Text = `string`\n\nIf you had custom Search Attributes `CustomerId` of type Keyword and `MiscData` of type Text, you would provide `string` values:\n\n```go\nfunc (c *Client) CallYourWorkflow(ctx context.Context, workflowID string, payload map[string]interface{}) error {\n    // ...\n    searchAttributes := map[string]interface{}{\n        \"CustomerId\": payload[\"customer\"],\n        \"MiscData\": payload[\"miscData\"]\n    }\n    options := client.StartWorkflowOptions{\n        SearchAttributes:   searchAttributes\n        // ...\n    }\n    we, err := c.Client.ExecuteWorkflow(ctx, options, app.YourWorkflow, payload)\n    // ...\n}\n```","is_empty":false}},{"lang":"java","id":"none"},{"lang":"php","id":"none"},{"lang":"python","id":"python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python","node":{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python.md","id":"python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python","title":"How to set custom Search Attributes in Python","description":"To set custom Search Attributes, use the `search_attributes` parameter of 'start_workflow()'.","label":"Set custom Search Attributes","tags":["developer-guide","sdk","python"],"markdown_content":"To set custom Search Attributes, use the `search_attributes` parameter of the ['start_workflow()'](https://python.temporal.io/temporalio.client.client#start_workflow) method.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    search_attributes={\"Your-Custom-Keyword-Field\": [\"value\"]},\n)\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript","node":{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript.md","id":"typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript","title":"How to add custom Search Attributes to Workflow Executions at start time in TypeScript","description":"Add custom Search Attributes to Workflow Executions at start time","label":"Add custom Search Attributes to Workflow Executions at start time","tags":["developer-guide","typescript","client"],"markdown_content":"Use [`WorkflowOptions.searchAttributes`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions#searchattributes).\n\n<!--SNIPSTART typescript-search-attributes-client-->\n<!--SNIPEND-->\n\nThe type of `searchAttributes` is `Record<string, string[] | number[] | boolean[] | Date[]>`.","is_empty":false}}]},{"type":"h3","id":"app-dev-context/upsert-custom-search-attributes","node":{"file_name":"upsert-custom-search-attributes.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/upsert-custom-search-attributes.md","id":"app-dev-context/upsert-custom-search-attributes","title":"How to upsert Search Attributes","description":"You can upsert Search Attributes to add or update Search Attributes from within Workflow code.","label":"Upsert Search Attributes","tags":["guide-context"],"markdown_content":"You can upsert Search Attributes to add or update Search Attributes from within Workflow code.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go","node":{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go.md","id":"go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go","title":"How to upsert custom Search Attributes to Workflow during Execution","label":"How to upsert custom Search Attributes to Workflow during Execution","tags":["developer-guide","go"],"markdown_content":"In advanced cases, you may want to dynamically update these attributes as the Workflow progresses.\n[UpsertSearchAttributes](https://pkg.go.dev/go.temporal.io/sdk/workflow#UpsertSearchAttributes) is used to add or update Search Attributes from within Workflow code.\n\n`UpsertSearchAttributes` will merge attributes to the existing map in the Workflow.\nConsider this example Workflow code:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n\n    attr1 := map[string]interface{}{\n        \"CustomIntField\": 1,\n        \"CustomBoolField\": true,\n    }\n    workflow.UpsertSearchAttributes(ctx, attr1)\n\n    attr2 := map[string]interface{}{\n        \"CustomIntField\": 2,\n        \"CustomKeywordField\": \"seattle\",\n    }\n    workflow.UpsertSearchAttributes(ctx, attr2)\n}\n```\n\nAfter the second call to `UpsertSearchAttributes`, the map will contain:\n\n```go\nmap[string]interface{}{\n    \"CustomIntField\": 2, // last update wins\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"seattle\",\n}\n```","is_empty":false}},{"lang":"java","id":"none"},{"lang":"php","id":"none"},{"lang":"python","id":"python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python","node":{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python.md","id":"python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python","title":"How to upsert custom Search Attributes","description":"To upsert custom Search Attributes, use [`upsert_search_attributes()`] and set it to an empty list.","label":"Upsert custom Search Attributes","tags":["developer-guide","sdk","python"],"markdown_content":"To upsert custom Search Attributes, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) function and set it to an empty list.\n\nThe keys are added to or replace the existing Search Attributes, similar to [`dict.update()`](https://docs.python.org/3/library/stdtypes.html#dict.update).\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": [\"new-value\"]})\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript","node":{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript.md","id":"typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript","title":"How to upsert custom Search Attributes to Workflow during Execution","label":"How to upsert custom Search Attributes to Workflow during Execution","tags":["developer-guide","typescript"],"markdown_content":"Inside a Workflow, we can read from [`WorkflowInfo.searchAttributes`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo#searchattributes) and call [`upsertSearchAttributes`](https://typescript.temporal.io/api/namespaces/workflow#upsertsearchattributes):\n\n<!--SNIPSTART typescript-search-attributes-workflow -->\n<!--SNIPEND-->","is_empty":false}}]},{"type":"h3","id":"app-dev-context/remove-search-attributes","node":{"file_name":"remove-search-attributes.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/remove-search-attributes.md","id":"app-dev-context/remove-search-attributes","title":"How to remove a Search Attribute from a Workflow","description":"To remove a Search Attribute that was previously set, set it to an empty array.","label":"Remove Search Attribute","tags":["guide-context"],"markdown_content":"To remove a Search Attribute that was previously set, set it to an empty array: `[]`.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-remove-search-attributes-from-a-workflow-in-go","node":{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-remove-search-attributes-from-a-workflow-in-go.md","id":"go/how-to-remove-search-attributes-from-a-workflow-in-go","title":"How to remove Search Attributes from a Workflow in Go","description":"How to remove Search Attributes from a Workflow","label":"How to remove Search Attributes from a Workflow","tags":["developer-guide","go"],"markdown_content":"**There is no support for removing a field.**\n\nHowever, to achieve a similar effect, set the field to some placeholder value.\nFor example, you could set `CustomKeywordField` to `impossibleVal`.\nThen searching `CustomKeywordField != 'impossibleVal'` will match Workflows with `CustomKeywordField` not equal to `impossibleVal`, which includes Workflows without the `CustomKeywordField` set.","is_empty":false}},{"lang":"java","id":"none"},{"lang":"php","id":"php/how-to-remove-search-attributes-from-a-workflow-in-php","node":{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-php.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/php/how-to-remove-search-attributes-from-a-workflow-in-php.md","id":"php/how-to-remove-search-attributes-from-a-workflow-in-php","title":"How to remove Search Attributes from a Workflow in PHP","label":"Remove Search Attributes","markdown_content":"To remove a Search Attribute that was previously set, set it to an empty array `[]`.","is_empty":false}},{"lang":"python","id":"python/how-to-remove-search-attributes-from-a-workflow-in-python","node":{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-remove-search-attributes-from-a-workflow-in-python.md","id":"python/how-to-remove-search-attributes-from-a-workflow-in-python","title":"How to remove Search Attributes in Python","description":"To remove a Search Attribute, use `upsert_search_attributes()` with an empty list as its value.","label":"Remove Search Attributes","tags":["developer-guide","sdk","python"],"markdown_content":"To remove a Search Attribute, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) function with an empty list as its value.\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": []})\n```","is_empty":false}},{"lang":"typescript","id":"typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript","node":{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-typescript.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript.md","id":"typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript","title":"How to remove Search Attributes from a Workflow in TypeScript","description":"How to remove Search Attributes from a Workflow","label":"Remove Search Attributes from a Workflow","tags":["developer-guide","typescript","client"],"markdown_content":"```typescript\nimport {upsertSearchAttributes} from \"@temporalio/workflow\";\n\nasync function yourWorkflow() {\n  upsertSearchAttributes({CustomIntField: [1, 2, 3]});\n\n  // ... later, to remove:\n  upsertSearchAttributes({CustomIntField: []});\n}\n```","is_empty":false}}]}],"link_index":[{"file_dir":"application-development","guide_id":"observability","local_ref":"","node_id":"app-dev-context/observability"},{"file_dir":"application-development","guide_id":"observability","local_ref":"metrics","node_id":"app-dev-context/metrics"},{"file_dir":"application-development","guide_id":"observability","local_ref":"metrics","node_id":"go/how-to-emit-metrics-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"metrics","node_id":"java/how-to-emit-metrics-in-java"},{"file_dir":"application-development","guide_id":"observability","local_ref":"metrics","node_id":"typescript/how-to-emit-metrics-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"tracing","node_id":"app-dev-context/tracing"},{"file_dir":"application-development","guide_id":"observability","local_ref":"tracing","node_id":"go/how-to-configure-tracing-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"tracing","node_id":"typescript/how-to-configure-tracing-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"logging","node_id":"app-dev-context/logging"},{"file_dir":"application-development","guide_id":"observability","local_ref":"logging","node_id":"go/how-to-log-from-a-workflow-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"logging","node_id":"python/how-to-log-from-a-workflow-in-python"},{"file_dir":"application-development","guide_id":"observability","local_ref":"logging","node_id":"typescript/how-to-log-from-a-workflow-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-logger","node_id":"app-dev-context/custom-logging"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-logger","node_id":"go/how-to-set-a-custom-logger-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-logger","node_id":"typescript/how-to-set-a-custom-logger-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"visibility","node_id":"app-dev-context/visibility"},{"file_dir":"application-development","guide_id":"observability","local_ref":"search-attributes","node_id":"app-dev-context/search-attributes"},{"file_dir":"application-development","guide_id":"observability","local_ref":"search-attributes","node_id":"go/how-to-list-workflow-executions-using-the-client-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"search-attributes","node_id":"typescript/how-to-list-workflow-executions-using-the-client-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-search-attributes","node_id":"app-dev-context/set-custom-search-attributes"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-search-attributes","node_id":"go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-search-attributes","node_id":"python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-search-attributes","node_id":"typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"upsert-search-attributes","node_id":"app-dev-context/upsert-custom-search-attributes"},{"file_dir":"application-development","guide_id":"observability","local_ref":"upsert-search-attributes","node_id":"go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"upsert-search-attributes","node_id":"python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python"},{"file_dir":"application-development","guide_id":"observability","local_ref":"upsert-search-attributes","node_id":"typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"app-dev-context/remove-search-attributes"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"go/how-to-remove-search-attributes-from-a-workflow-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"php/how-to-remove-search-attributes-from-a-workflow-in-php"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"python/how-to-remove-search-attributes-from-a-workflow-in-python"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript"}],"markdown_content":"---\nid: observability\ntitle: Application development - Observability\nsidebar_label: Observability\ndescription: The Observability section of the Temporal Application development guide covers the many ways to view the current state of your Temporal Application  that is, ways to view what Workflow Executions are tracked by the Platform and the state of any given Workflow Execution, either currently or at points of an execution.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nThe observability section of the Temporal Application development guide covers the many ways to view the current state of your [Temporal Application](/temporal#temporal-application)that is, ways to view which [Workflow Executions](/workflows#workflow-execution) are tracked by the [Temporal Platform](/temporal#temporal-platform) and the state of any specified Workflow Execution, either currently or at points of an execution.\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Application development guide, it could be in [older docs for SDKs](/sdks).\n\n:::\n\nThis section covers features related to viewing the state of the application, including:\n\n- [Metrics](#metrics)\n- [Tracing](#tracing)\n- [Logging](#logging)\n- [Visibility](#visibility)\n- [Replays](#replays)\n\n## Metrics\n\nEach Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.\nFor a complete list of metrics capable of being emitted, see the [SDK metrics reference](/references/sdk-metrics).\n\nMetrics can be scraped and stored in time series databases, such as:\n\n- [Prometheus](https://prometheus.io/docs/introduction/overview/)\n- [M3db](https://m3db.io/docs/)\n- [statsd](https://github.com/statsd/statsd)\n\nTemporal also provides a dashboard you can integrate with graphing services like [Grafana](https://grafana.com/docs/). For more information, see:\n\n- Temporal's implementation of the [Grafana dashboard](https://github.com/temporalio/dashboards)\n- [How to export metrics in Grafana](https://github.com/temporalio/helm-charts#exploring-metrics-via-grafana)\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nTo emit metrics from the Temporal Client in Go, create a [metrics handler](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler) from the [Client Options](https://pkg.go.dev/go.temporal.io/sdk@v1.15.0/internal#ClientOptions) and specify a listener address to be used by Prometheus.\n\n```go\nclient.Options{\n\t\tMetricsHandler: sdktally.NewMetricsHandler(newPrometheusScope(prometheus.Configuration{\n\t\t\tListenAddress: \"0.0.0.0:9090\",\n\t\t\tTimerType:     \"histogram\",\n\t\t}\n```\n\nThe Go SDK currently supports the [Tally](https://pkg.go.dev/go.temporal.io/sdk/contrib/tally) library; however, Tally offers [extensible custom metrics reporting](https://github.com/uber-go/tally#report-your-metrics), which is exposed through the [`WithCustomMetricsReporter`](/references/server-options#withcustommetricsreporter) API.\n\nFor more information, see the [Go sample for metrics](https://github.com/temporalio/samples-go/tree/main/metrics).\n\n</TabItem>\n<TabItem value=\"java\">\n\nTo emit metrics with the Java SDK, use [`MicrometerClientStatsReporter`](https://github.com/temporalio/sdk-java/blob/55ee7894aec427d7e384c3519732bdd61119961a/src/main/java/io/temporal/common/reporter/MicrometerClientStatsReporter.java#L34) class to integrate with Micrometer MeterRegistry configured for your metrics backend.\n[Micrometer](https://micrometer.io/docs) is a popular Java framework that provides integration with Prometheus and other backends.\n\nThe following example shows how to use `MicrometerClientStatsReporter` to define the metrics scope and set it with the `WorkflowServiceStubsOptions`.\n\n```java\n//...\n   // see the Micrometer documentation for configuration details on other supported monitoring systems.\n   // in this example shows how to set up Prometheus registry and stats reported.\n   PrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\n   StatsReporter reporter = new MicrometerClientStatsReporter(registry);\n    // set up a new scope, report every 10 seconds\n     Scope scope = new RootScopeBuilder()\n             .reporter(reporter)\n             .reportEvery(com.uber.m3.util.Duration.ofSeconds(10));\n   // for Prometheus collection, expose a scrape endpoint.\n   //...\n   // add metrics scope to WorkflowServiceStub options\n   WorkflowServiceStubsOptions stubOptions =\n       WorkflowServiceStubsOptions.newBuilder().setMetricsScope(scope).build();\n//...\n```\n\nFor more details, see the [Java SDK Samples](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/metrics).\nFor details on configuring a Prometheus scrape endpoint with Micrometer, see <https://micrometer.io/docs/registry/prometheus#_configuring>.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nWorkers can emit metrics and traces. There are a few [telemetry options](https://typescript.temporal.io/api/interfaces/worker.TelemetryOptions) that can be provided to [`Runtime.install`](https://typescript.temporal.io/api/classes/worker.runtime/#install). The common options are:\n\n- `metrics: { otel: { url } }`: The URL of a gRPC [OpenTelemetry collector](https://opentelemetry.io/docs/collector/).\n- `metrics: { prometheus: { bindAddress } }`: Address on the Worker host that will have metrics for [Prometheus](https://prometheus.io/) to scrape.\n\nTo set up tracing of Workflows and Activities, use our [opentelemetry-interceptors](/typescript/logging#opentelemetry-tracing) package.\n\n```typescript\n  telemetryOptions: {\n      metrics: {\n        prometheus: { bindAddress: '0.0.0.0:9464' },\n      },\n      logging: { forward: { level: 'DEBUG' } },\n    },\n```\n\n</TabItem>\n</Tabs>\n\n## Tracing\n\nTracing allows you to view the call graph of a Workflow along with its Activities and any child Workflows.\n\nTemporal Web's tracing capabilities mainly track Activity Execution within a Temporal context. If you need custom tracing specific for your use case, you should make use of context propagation to add tracing logic accordingly.\n\nFor information about Workflow tracing, see [Tracing Temporal Workflows with DataDog](https://spiralscout.com/blog/tracing-temporal-workflow-with-datadog).\n\nFor information about how to configure exporters and instrument your code, see [Tracing Temporal Services with OTEL](https://github.com/temporalio/temporal/blob/master/develop/docs/tracing.md).\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nThe Go SDK provides support for distributed tracing through [OpenTracing](https://opentracing.io/).\nTracing allows you to view the call graph of a Workflow along with its Activities and any child Workflows.\n\nTracing can be configured by providing an [opentracing.Tracer](https://pkg.go.dev/github.com/opentracing/opentracing-go#Tracer)\nimplementation in [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions) during client instantiation.\n\nFor more details on how to configure and leverage tracing, see the [OpenTracing documentation](https://opentracing.io/docs/getting-started/).\n\nThe OpenTracing support has been validated using [Jaeger](https://www.jaegertracing.io/), but other implementations mentioned [here](https://opentracing.io/docs/supported-tracers/) should also work.\n\nTracing functionality utilizes generic context propagation provided by the Client.\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nThe [`interceptors-opentelemetry`](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry) sample shows how to use the SDK's built-in OpenTelemetry tracing to trace everything from starting a Workflow to Workflow Execution to running an Activity from that Workflow.\n\nThe built-in tracing uses protobuf message headers (like [this one](https://github.com/temporalio/api/blob/b2b8ae6592a8730dd5be6d90569d1aea84e1712f/temporal/api/workflowservice/v1/request_response.proto#L161) when starting a Workflow) to propagate the tracing information from the client to the Workflow and from the Workflow to its successors (when Continued As New), children, and Activities.\nAll of these executions are linked with a single trace identifier and have the proper `parent -> child` span relation.\n\nTracing is compatible between different Temporal SDKs as long as compatible [context propagators](https://opentelemetry.lightstep.com/core-concepts/context-propagation/) are used.\n\n**Context propagation**\n\nThe TypeScript SDK uses the global OpenTelemetry propagator.\n\nTo extend the default ([Trace Context](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#w3ctracecontextpropagator-propagator) and [Baggage](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#baggage-propagator) propagators) to also include the [Jaeger propagator](https://www.npmjs.com/package/@opentelemetry/propagator-jaeger), follow these steps:\n\n- `npm i @opentelemetry/propagator-jaeger`\n\n- At the top level of your Workflow code, add the following lines:\n\n  ```js\n  import {propagation} from \"@opentelemetry/api\";\n  import {\n    CompositePropagator,\n    W3CTraceContextPropagator,\n    W3CBaggagePropagator,\n  } from \"@opentelemetry/core\";\n  import {JaegerPropagator} from \"@opentelemetry/propagator-jaeger\";\n\n  propagation.setGlobalPropagator(\n    new CompositePropagator({\n      propagators: [\n        new W3CTraceContextPropagator(),\n        new W3CBaggagePropagator(),\n        new JaegerPropagator(),\n      ],\n    })\n  );\n  ```\n\nSimilarly, you can customize the OpenTelemetry `NodeSDK` propagators by following the instructions in the [Initialize the SDK](https://github.com/open-telemetry/opentelemetry-js/tree/main/experimental/packages/opentelemetry-sdk-node#initialize-the-sdk) section of the README.\n\n</TabItem>\n</Tabs>\n\n## Logging\n\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nThe SDK core uses `WARN` for its default logging level.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nIn Workflow Definitions you can use [`workflow.GetLogger(ctx)`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLogger) to write logs.\n\n```go\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"go.temporal.io/sdk/activity\"\n\t\"go.temporal.io/sdk/workflow\"\n)\n\n// Workflow is a standard workflow definition.\n// Note that the Workflow and Activity don't need to care that\n// their inputs/results are being compressed.\nfunc Workflow(ctx workflow.Context, name string) (string, error) {\n// ...\n\nworkflow.WithActivityOptions(ctx, ao)\n\n// Getting the logger from the context.\n\tlogger := workflow.GetLogger(ctx)\n// Logging a message with the key value pair `name` and `name`\n\tlogger.Info(\"Compressed Payloads workflow started\", \"name\", name)\n\n\tinfo := map[string]string{\n\t\t\"name\": name,\n\t}\n\n\n\tlogger.Info(\"Compressed Payloads workflow completed.\", \"result\", result)\n\n\treturn result, nil\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"python\">\n\nYou can log from a Workflow using Python's standard library, by importing the logging module `import logging`.\n\nSet your logging configuration to a level you want to expose logs to.\nThe following example sets the logging information level to `INFO`.\n\n```python\nlogging.basicConfig(level=logging.INFO)\n```\n\nThen in your Workflow, set your [`logger`](https://python.temporal.io/temporalio.workflow.html#logger) and level on the Workflow. The following example logs the Workflow.\n\n```python\n@workflow.defn\nclass SayHelloWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        workflow.logger.info(f\"Running workflow with parameter {name}\")\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=10)\n        )\n```\n\nThe following is an example output:\n\n```\nINFO:temporalio.workflow:Running workflow with parameter Temporal ({'attempt': 1, 'your-custom-namespace': 'default', 'run_id': 'your-run-id', 'task_queue': 'your-task-queue', 'workflow_id': 'your-workflow-id', 'workflow_type': 'SayHelloWorkflow'})\n```\n\n:::note\n\nLogs are skipped during replay by default.\n\n:::\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nLogging from Workflows is tricky for two reasons:\n\n1. Workflows run in a sandboxed environment and cannot do any I/O.\n1. Workflow code might get replayed at any time, generating duplicate log messages.\n\nTo work around these limitations, we recommend using the Sinks feature in the TypeScript SDK.\nSinks enable one-way export of logs, metrics, and traces from the Workflow isolate to the Node.js environment.\n\n<!--\nWorkflows in Temporal may be replayed from the beginning of their history when resumed. In order for Temporal to recreate the exact state Workflow code was in, the code is required to be fully deterministic. To prevent breaking [determinism](/typescript/determinism), in the TypeScript SDK, Workflow code runs in an isolated execution environment and may not use any of the Node.js APIs or communicate directly with the outside world. -->\n\nSinks are written as objects with methods. Similar to Activities, they are declared in the Worker and then proxied in Workflow code, and it helps to share types between both.\n\n<details>\n  <summary>Comparing Sinks, Activities and Interceptors</summary>\n  \nSinks are similar to Activities in that they are both registered on the Worker and proxied into the Workflow.\nHowever, they differ from Activities in important ways:\n\n- Sink functions don't return any value back to the Workflow and cannot not be awaited.\n- Sink calls are not recorded in Workflow histories (no timeouts or retries).\n- Sink functions are _always_ run on the same Worker that runs the Workflow they are called from.\n\n</details>\n\n**Declaring the Sink Interface**\n\nExplicitly declaring a Sink's interface is optional, but is useful for ensuring type safety in subsequent steps:\n\n<!--SNIPSTART typescript-logger-sink-interface-->\n<!--SNIPEND-->\n\n**Implementing Sinks**\n\nImplementing Sinks is a two-step process.\n\nImplement and inject the Sink function into a Worker\n\n<!--SNIPSTART typescript-logger-sink-worker-->\n<!--SNIPEND-->\n\n- Sink function implementations are passed as an object into [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#sinks)\n- You can specify whether you want the injected function to be called during Workflow replay by setting the `callDuringReplay` boolean option.\n\n**Proxy and call a Sink function from a Workflow**\n\n<!--SNIPSTART typescript-logger-sink-workflow-->\n<!--SNIPEND-->\n\nSome important features of the [InjectedSinkFunction](https://typescript.temporal.io/api/interfaces/worker.InjectedSinkFunction) interface:\n\n- **Injected WorkflowInfo argument**: The first argument of a Sink function implementation is a [`workflowInfo` object](https://typescript.temporal.io/api/interfaces/workflow.workflowinfo/) that contains useful metadata.\n- **Limited arguments types**: The remaining Sink function arguments are copied between the sandbox and the Node.js environment using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n- **No return value**: To prevent breaking determinism, Sink functions cannot return values to the Workflow.\n\n**Advanced: Performance considerations and non-blocking Sinks**\n\nThe injected sink function contributes to the overall Workflow Task processing duration.\n\n- If you have a long-running sink function, such as one that tries to communicate with external services, you might start seeing Workflow Task timeouts.\n- The effect is multiplied when using `callDuringReplay: true` and replaying long Workflow histories because the Workflow Task timer starts when the first history page is delivered to the Worker.\n\n</TabItem>\n</Tabs>\n\n### Custom logger\n\nUse a custom logger for logging.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nThis field sets a custom Logger that is used for all logging actions of the instance of the Temporal Client.\n\nAlthough the Go SDK does not support most third-party logging solutions natively, [our friends at Banzai Cloud](https://github.com/sagikazarmark) built the adapter package [logur](https://github.com/logur/logur) which makes it possible to use third party loggers with minimal overhead.\nMost of the popular logging solutions have existing adapters in Logur, but you can find a full list [in the Logur Github project](https://github.com/logur?q=adapter-).\n\nHere is an example of using Logur to support [Logrus](https://github.com/sirupsen/logrus):\n\n```go\npackage main\nimport (\n  \"go.temporal.io/sdk/client\"\n\n\t\"github.com/sirupsen/logrus\"\n\tlogrusadapter \"logur.dev/adapter/logrus\"\n\t\"logur.dev/logur\"\n)\n\nfunc main() {\n  // ...\n  logger := logur.LoggerToKV(logrusadapter.New(logrus.New()))\n  clientOptions := client.Options{\n    Logger: logger,\n  }\n  temporalClient, err := client.Dial(clientOptions)\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n**Logging in Workers and Clients**\n\nThe Worker comes with a default logger which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThe following [log levels](https://typescript.temporal.io/api/namespaces/worker#loglevel) are listed in increasing order of severity.\n\n**Customizing the default logger**\n\nTemporal uses a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.defaultlogger/) that implements the basic interface:\n\n```ts\nimport {Runtime, DefaultLogger} from \"@temporalio/worker\";\n\nconst logger = new DefaultLogger(\"WARN\", ({level, message}) => {\n  console.log(`Custom logger: ${level}  ${message}`);\n});\nRuntime.install({logger});\n```\n\nThe previous code example sets the default logger to only log messages with level `WARN` and higher.\n\n**Accumulate logs for testing and reporting**\n\n```ts\nimport {DefaultLogger, LogEntry} from \"@temporalio/worker\";\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger(\"TRACE\", (entry) => logs.push(entry));\nlog.debug(\"hey\", {a: 1});\nlog.info(\"ho\");\nlog.warn(\"lets\", {a: 1});\nlog.error(\"go\");\n```\n\nA common logging use case is logging to a file to be picked up by a collector like the [Datadog Agent](https://docs.datadoghq.com/logs/log_collection/nodejs/?tab=winston30).\n\n```ts\nimport {Runtime} from \"@temporalio/worker\";\nimport winston from \"winston\";\n\nconst logger = winston.createLogger({\n  level: \"info\",\n  format: winston.format.json(),\n  transports: [new transports.File({filename: \"/path/to/worker.log\"})],\n});\nRuntime.install({logger});\n```\n\n</TabItem>\n</Tabs>\n\n## Visibility\n\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n\n### Search Attributes\n\nThe typical method of retrieving a Workflow Execution is by its Workflow Id.\n\nHowever, sometimes you'll want to retrieve one or more Workflow Executions based on another property. For example, imagine you want to get all Workflow Executions of a certain type that have failed within a time range, so that you can start new ones with the same arguments.\n\nYou can do this with [Search Attributes](/concepts/what-is-a-search-attribute/).\n\n- [**Default** Search Attributes](/concepts/what-is-a-search-attribute/#default-search-attributes) like `WorkflowType`, `StartTime` and `ExecutionStatus` are automatically added to Workflow Executions.\n- _Custom Search Attributes_ can contain their own domain-specific data (like `customerId` or `numItems`).\n  - A few [generic Custom Search Attributes](/concepts/what-is-a-search-attribute/#custom-search-attributes) like `CustomKeywordField` and `CustomIntField` are created by default in Temporal's [Docker Compose](/clusters/quick-install/#docker-compose).\n\nThe steps to using custom Search Attributes are:\n\n- Create a new Search Attribute in your Cluster [using `tctl`](/tctl/admin/cluster/add-search-attributes) or the Cloud UI.\n- Set the value of the Search Attribute for a Workflow Execution:\n  - On the Client by including it as an option when starting the Execution.\n  - In the Workflow by calling `UpsertSearchAttributes`.\n- Read the value of the Search Attribute:\n  - On the Client by calling `DescribeWorkflow`.\n  - In the Workflow by looking at `WorkflowInfo`.\n- Query Workflow Executions by the Search Attribute using a [List Filter](/concepts/what-is-a-list-filter/):\n  - [In `tctl`](/tctl/workflow/list/#--query).\n  - In code by calling `ListWorkflowExecutions`.\n\nHere is how to query Workflow Executions:\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nUse [`Client.ListWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/client#Client.ListWorkflow).\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nUse [`WorkflowService.listWorkflowExecutions`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#listworkflowexecutions):\n\n```typescript\nimport {Connection} from \"@temporalio/client\";\n\nconst connection = await Connection.connect();\nconst response = await connection.workflowService.listWorkflowExecutions({\n  query: `ExecutionStatus = \"Running\"`,\n});\n```\n\nwhere `query` is a [List Filter](/concepts/what-is-a-list-filter/).\n\n</TabItem>\n</Tabs>\n\n### Custom Search Attributes\n\nAfter you've created custom Search Attributes in your Cluster ([using `tctl`](/tctl/admin/cluster/add-search-attributes) or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nProvide key-value pairs in [`StartWorkflowOptions.SearchAttributes`](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions).\n\nSearch Attributes are represented as `map[string]interface{}`.\nThe values in the map must correspond to the [Search Attribute's value type](/concepts/what-is-a-search-attribute/#types):\n\n- Bool = `bool`\n- Datetime = `time.Time`\n- Double = `float64`\n- Int = `int64`\n- Keyword = `string`\n- Text = `string`\n\nIf you had custom Search Attributes `CustomerId` of type Keyword and `MiscData` of type Text, you would provide `string` values:\n\n```go\nfunc (c *Client) CallYourWorkflow(ctx context.Context, workflowID string, payload map[string]interface{}) error {\n    // ...\n    searchAttributes := map[string]interface{}{\n        \"CustomerId\": payload[\"customer\"],\n        \"MiscData\": payload[\"miscData\"]\n    }\n    options := client.StartWorkflowOptions{\n        SearchAttributes:   searchAttributes\n        // ...\n    }\n    we, err := c.Client.ExecuteWorkflow(ctx, options, app.YourWorkflow, payload)\n    // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo set custom Search Attributes, use the `search_attributes` parameter of the ['start_workflow()'](https://python.temporal.io/temporalio.client.client#start_workflow) method.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    search_attributes={\"Your-Custom-Keyword-Field\": [\"value\"]},\n)\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nUse [`WorkflowOptions.searchAttributes`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions#searchattributes).\n\n<!--SNIPSTART typescript-search-attributes-client-->\n<!--SNIPEND-->\n\nThe type of `searchAttributes` is `Record<string, string[] | number[] | boolean[] | Date[]>`.\n\n</TabItem>\n</Tabs>\n\n### Upsert Search Attributes\n\nYou can upsert Search Attributes to add or update Search Attributes from within Workflow code.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nIn advanced cases, you may want to dynamically update these attributes as the Workflow progresses.\n[UpsertSearchAttributes](https://pkg.go.dev/go.temporal.io/sdk/workflow#UpsertSearchAttributes) is used to add or update Search Attributes from within Workflow code.\n\n`UpsertSearchAttributes` will merge attributes to the existing map in the Workflow.\nConsider this example Workflow code:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n\n    attr1 := map[string]interface{}{\n        \"CustomIntField\": 1,\n        \"CustomBoolField\": true,\n    }\n    workflow.UpsertSearchAttributes(ctx, attr1)\n\n    attr2 := map[string]interface{}{\n        \"CustomIntField\": 2,\n        \"CustomKeywordField\": \"seattle\",\n    }\n    workflow.UpsertSearchAttributes(ctx, attr2)\n}\n```\n\nAfter the second call to `UpsertSearchAttributes`, the map will contain:\n\n```go\nmap[string]interface{}{\n    \"CustomIntField\": 2, // last update wins\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"seattle\",\n}\n```\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo upsert custom Search Attributes, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) function and set it to an empty list.\n\nThe keys are added to or replace the existing Search Attributes, similar to [`dict.update()`](https://docs.python.org/3/library/stdtypes.html#dict.update).\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": [\"new-value\"]})\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nInside a Workflow, we can read from [`WorkflowInfo.searchAttributes`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo#searchattributes) and call [`upsertSearchAttributes`](https://typescript.temporal.io/api/namespaces/workflow#upsertsearchattributes):\n\n<!--SNIPSTART typescript-search-attributes-workflow -->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\n### Remove Search Attribute\n\nTo remove a Search Attribute that was previously set, set it to an empty array: `[]`.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\n**There is no support for removing a field.**\n\nHowever, to achieve a similar effect, set the field to some placeholder value.\nFor example, you could set `CustomKeywordField` to `impossibleVal`.\nThen searching `CustomKeywordField != 'impossibleVal'` will match Workflows with `CustomKeywordField` not equal to `impossibleVal`, which includes Workflows without the `CustomKeywordField` set.\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nTo remove a Search Attribute that was previously set, set it to an empty array `[]`.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo remove a Search Attribute, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) function with an empty list as its value.\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": []})\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n```typescript\nimport {upsertSearchAttributes} from \"@temporalio/workflow\";\n\nasync function yourWorkflow() {\n  upsertSearchAttributes({CustomIntField: [1, 2, 3]});\n\n  // ... later, to remove:\n  upsertSearchAttributes({CustomIntField: []});\n}\n```\n\n</TabItem>\n</Tabs>\n\n"},{"file_name":"testing.md","id":"testing","file_dir":"application-development","title":"Application development - Testing","sidebar_label":"Testing","description":"The Testing section of the Temporal Application development guide covers the many ways to test the state of your Temporal Application; that is, ways to view which Workflow Executions are tracked by the Platform and the state of any given Workflow Execution, either currently or at points of an execution.","use_description":false,"toc_max_heading_level":4,"add_tabs_support":false,"sections":[{"type":"p","id":"app-dev-context/testing","node":{"file_name":"testing.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/testing.md","id":"app-dev-context/testing","title":"How to Test","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Testing","tags":["guide-context"],"markdown_content":"Temporal provides a framework to facilitate Workflow and integration testing.","is_empty":false}},{"type":"h2","id":"app-dev-context/replays","node":{"file_name":"replays.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/app-dev-context/replays.md","id":"app-dev-context/replays","title":"How to Replay a Workflow Execution","description":"Replay recreates the exact state of a Workflow Execution.","label":"Replay","tags":["guide-context"],"markdown_content":"Replay recreates the exact state of a Workflow Execution.\nYou can replay a Workflow from the beginning of its history when resumed.\n\nReplay allows code to resume only if it is compatible from a deterministic point of view.\n\nTo retrieve the Workflow History, use any of the following options and then pass the object to your SDK of choice.","is_empty":false}},{"type":"langtabs","langtabs":[{"lang":"go","id":"go/how-to-replay-a-workflow-execution-in-go","node":{"file_name":"how-to-replay-a-workflow-execution-in-go.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs/go/how-to-replay-a-workflow-execution-in-go.md","id":"go/how-to-replay-a-workflow-execution-in-go","title":"How to replay a Workflow Execution in Go","description":"Use the `WorkflowReplayer` API to replay an existing Workflow Execution from an Event History to replicate errors.","label":"WorkflowReplayer","tags":["go","how-to"],"markdown_content":"Use the [worker.WorflowReplayer](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowReplayer) to replay an existing Workflow Execution from its Event History to replicate errors.\n\nFor example, the following code retrieves the Event History of a Workflow:\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/api/enums/v1\"\n\t\"go.temporal.io/api/history/v1\"\n\t\"go.temporal.io/sdk/client\"\n)\n\nfunc GetWorkflowHistory(ctx context.Context, client client.Client, id, runID string) (*history.History, error) {\n\tvar hist history.History\n\titer := client.GetWorkflowHistory(ctx, id, runID, false, enums.HISTORY_EVENT_FILTER_TYPE_ALL_EVENT)\n\tfor iter.HasNext() {\n\t\tevent, err := iter.Next()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thist.Events = append(hist.Events, event)\n\t}\n\treturn &hist, nil\n}\n```\n\nThis history can then be used to _replay_.\nFor example, the following code creates a `WorkflowReplayer` and register the `YourWorkflow` Workflow function.\nThen it calls the `ReplayWorkflowHistory` to _replay_ the Event History and return an error code.\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n)\n\nfunc ReplayWorkflow(ctx context.Context, client client.Client, id, runID string) error {\n\thist, err := GetWorkflowHistory(ctx, client, id, runID)\n\tif err != nil {\n\t\treturn err\n\t}\n\treplayer := worker.NewWorkflowReplayer()\n\treplayer.RegisterWorkflow(YourWorkflow)\n\treturn replayer.ReplayWorkflowHistory(nil, hist)\n}\n```\n\nThe code above will cause the Worker to re-execute the Workflow's Workflow Function using the original Event History.\nIf a noticeably different code path was followed or some code caused a deadlock, it will be returned in the error code.\nReplaying a Workflow Execution locally is a good way to see exactly what code path was taken for given input and events.","is_empty":false}},{"lang":"java","id":"none"},{"lang":"php","id":"none"},{"lang":"python","id":"python/how-to-replay-a-workflow-execution-in-python","node":{"file_name":"how-to-replay-a-workflow-execution-in-python.md","file_path":"/Users/rachfop/app/little-python/type-samples/documentation/docs-src/python/how-to-replay-a-workflow-execution-in-python.md","id":"python/how-to-replay-a-workflow-execution-in-python","title":"How to replay a Workflow Execution in Python","description":"To replay a Workflow Execution, use the `replay_workflow()` method and pass a Workflow History as an argument.","label":"Replay a Workflow Execution","tags":["developer-guide","sdk","python"],"markdown_content":"To replay a Workflow Execution, use the [`replay_workflow()`](https://python.temporal.io/temporalio.worker.replayer#replay_workflow) method and pass a Workflow History as an argument.\n\nIn the following example, `history_json_str` references the Workflow History as a JSON string.\n\n```python\nasync def run_replayer(history_json_str: str):\n    replayer = Replayer(workflows=[YourWorkflow])\n    await replayer.replay_workflow(history_json_str)\n```\n\nIf the Workflow History is non-deterministic, `run_replayer()` raises an error.\n\n:::note\n\nIf the Workflow History is exported by [Temporal Web UI](/web-ui) or through [tctl](/tctl), you can pass the JSON file history object as a JSON string or as a Python dictionary through the `json.load()` function, which takes a file object and returns the JSON object.\n\n:::","is_empty":false}},{"lang":"typescript","id":"none"}]}],"link_index":[{"file_dir":"application-development","guide_id":"testing","local_ref":"","node_id":"app-dev-context/testing"},{"file_dir":"application-development","guide_id":"testing","local_ref":"replay","node_id":"app-dev-context/replays"},{"file_dir":"application-development","guide_id":"testing","local_ref":"replay","node_id":"go/how-to-replay-a-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"testing","local_ref":"replay","node_id":"python/how-to-replay-a-workflow-execution-in-python"}],"markdown_content":"---\nid: testing\ntitle: Application development - Testing\nsidebar_label: Testing\ndescription: The Testing section of the Temporal Application development guide covers the many ways to test the state of your Temporal Application; that is, ways to view which Workflow Executions are tracked by the Platform and the state of any given Workflow Execution, either currently or at points of an execution.\ntoc_max_heading_level: 4\n---\n\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nTemporal provides a framework to facilitate Workflow and integration testing.\n\n## Replay\n\nReplay recreates the exact state of a Workflow Execution.\nYou can replay a Workflow from the beginning of its history when resumed.\n\nReplay allows code to resume only if it is compatible from a deterministic point of view.\n\nTo retrieve the Workflow History, use any of the following options and then pass the object to your SDK of choice.\n\n<Tabs\ndefaultValue=\"go\"\ngroupId=\"site-lang\"\nvalues={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>\n\n<TabItem value=\"go\">\n\nUse the [worker.WorflowReplayer](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowReplayer) to replay an existing Workflow Execution from its Event History to replicate errors.\n\nFor example, the following code retrieves the Event History of a Workflow:\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/api/enums/v1\"\n\t\"go.temporal.io/api/history/v1\"\n\t\"go.temporal.io/sdk/client\"\n)\n\nfunc GetWorkflowHistory(ctx context.Context, client client.Client, id, runID string) (*history.History, error) {\n\tvar hist history.History\n\titer := client.GetWorkflowHistory(ctx, id, runID, false, enums.HISTORY_EVENT_FILTER_TYPE_ALL_EVENT)\n\tfor iter.HasNext() {\n\t\tevent, err := iter.Next()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thist.Events = append(hist.Events, event)\n\t}\n\treturn &hist, nil\n}\n```\n\nThis history can then be used to _replay_.\nFor example, the following code creates a `WorkflowReplayer` and register the `YourWorkflow` Workflow function.\nThen it calls the `ReplayWorkflowHistory` to _replay_ the Event History and return an error code.\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n)\n\nfunc ReplayWorkflow(ctx context.Context, client client.Client, id, runID string) error {\n\thist, err := GetWorkflowHistory(ctx, client, id, runID)\n\tif err != nil {\n\t\treturn err\n\t}\n\treplayer := worker.NewWorkflowReplayer()\n\treplayer.RegisterWorkflow(YourWorkflow)\n\treturn replayer.ReplayWorkflowHistory(nil, hist)\n}\n```\n\nThe code above will cause the Worker to re-execute the Workflow's Workflow Function using the original Event History.\nIf a noticeably different code path was followed or some code caused a deadlock, it will be returned in the error code.\nReplaying a Workflow Execution locally is a good way to see exactly what code path was taken for given input and events.\n\n</TabItem>\n<TabItem value=\"java\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"php\">\n\nContent is currently unavailable.\n\n</TabItem>\n<TabItem value=\"python\">\n\nTo replay a Workflow Execution, use the [`replay_workflow()`](https://python.temporal.io/temporalio.worker.replayer#replay_workflow) method and pass a Workflow History as an argument.\n\nIn the following example, `history_json_str` references the Workflow History as a JSON string.\n\n```python\nasync def run_replayer(history_json_str: str):\n    replayer = Replayer(workflows=[YourWorkflow])\n    await replayer.replay_workflow(history_json_str)\n```\n\nIf the Workflow History is non-deterministic, `run_replayer()` raises an error.\n\n:::note\n\nIf the Workflow History is exported by [Temporal Web UI](/web-ui) or through [tctl](/tctl), you can pass the JSON file history object as a JSON string or as a Python dictionary through the `json.load()` function, which takes a file object and returns the JSON object.\n\n:::\n\n</TabItem>\n<TabItem value=\"typescript\">\n\nContent is currently unavailable.\n\n</TabItem>\n</Tabs>\n\n"}],"full_index":[{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"","node_id":"cluster-ops-context/intro"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"elasticsearch","node_id":"clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"archival","node_id":"cluster-ops-context/archival"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"set-up-archival","node_id":"clusters/how-to-set-up-archival"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"custom-archiver","node_id":"clusters/how-to-create-a-custom-archiver"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"upgrade-server","node_id":"clusters/how-to-upgrade-the-temporal-server-version"},{"file_dir":"/","guide_id":"cluster-deployment-guide","local_ref":"set-up-multi-cluster-replication","node_id":"clusters/how-to-set-up-multi-cluster-replication"},{"file_dir":"/","guide_id":"web-ui","local_ref":"","node_id":"concepts/what-is-the-temporal-web-ui"},{"file_dir":"/","guide_id":"activities","local_ref":"","node_id":"concepts/what-is-an-activity"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-definition","node_id":"concepts/what-is-an-activity-definition"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-type","node_id":"concepts/what-is-an-activity-type"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-execution","node_id":"concepts/what-is-an-activity-execution"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-id","node_id":"concepts/what-is-an-activity-id"},{"file_dir":"/","guide_id":"activities","local_ref":"schedule-to-start-timeout","node_id":"concepts/what-is-a-schedule-to-start-timeout"},{"file_dir":"/","guide_id":"activities","local_ref":"start-to-close-timeout","node_id":"concepts/what-is-a-start-to-close-timeout"},{"file_dir":"/","guide_id":"activities","local_ref":"schedule-to-close-timeout","node_id":"concepts/what-is-a-schedule-to-close-timeout"},{"file_dir":"/","guide_id":"activities","local_ref":"activity-heartbeat","node_id":"concepts/what-is-an-activity-heartbeat"},{"file_dir":"/","guide_id":"activities","local_ref":"heartbeat-timeout","node_id":"concepts/what-is-a-heartbeat-timeout"},{"file_dir":"/","guide_id":"activities","local_ref":"asynchronous-activity-completion","node_id":"concepts/what-is-asynchronous-activity-completion"},{"file_dir":"/","guide_id":"activities","local_ref":"task-token","node_id":"concepts/what-is-a-task-token"},{"file_dir":"/","guide_id":"activities","local_ref":"local-activity","node_id":"concepts/what-is-a-local-activity"},{"file_dir":"cloud","guide_id":"index","local_ref":"","node_id":"concepts/what-is-temporal-cloud"},{"file_dir":"cloud","guide_id":"index","local_ref":"temporal-cloud-account-id","node_id":"concepts/what-is-a-cloud-account-id"},{"file_dir":"cloud","guide_id":"index","local_ref":"account-level-roles","node_id":"cloud-context/what-are-the-account-level-roles-for-users-in-temporal-cloud"},{"file_dir":"cloud","guide_id":"index","local_ref":"temporal-cloud-namespace-name","node_id":"concepts/what-is-a-cloud-namespace-name"},{"file_dir":"cloud","guide_id":"index","local_ref":"temporal-cloud-namespace-id","node_id":"concepts/what-is-a-cloud-namespace-id"},{"file_dir":"cloud","guide_id":"index","local_ref":"namespace-level-permissions","node_id":"cloud-context/what-are-the-namespace-level-permissions-for-users-in-temporal-cloud"},{"file_dir":"/","guide_id":"clusters","local_ref":"","node_id":"concepts/what-is-a-temporal-cluster"},{"file_dir":"/","guide_id":"clusters","local_ref":"temporal-server","node_id":"concepts/what-is-the-temporal-server"},{"file_dir":"/","guide_id":"clusters","local_ref":"retention-period","node_id":"concepts/what-is-a-retention-period"},{"file_dir":"/","guide_id":"clusters","local_ref":"archival","node_id":"concepts/what-is-archival"},{"file_dir":"/","guide_id":"clusters","local_ref":"multi-cluster-replication","node_id":"concepts/what-is-multi-cluster-replication"},{"file_dir":"/","guide_id":"clusters","local_ref":"plugins","node_id":"concept-context/cluster-plugins"},{"file_dir":"/","guide_id":"clusters","local_ref":"claim-mapper","node_id":"concepts/what-is-a-claimmapper-plugin"},{"file_dir":"/","guide_id":"clusters","local_ref":"authorizer-plugin","node_id":"concepts/what-is-an-authorizer-plugin"},{"file_dir":"/","guide_id":"namespaces","local_ref":"","node_id":"concepts/what-is-a-namespace"},{"file_dir":"/","guide_id":"namespaces","local_ref":"global-namespace","node_id":"concepts/what-is-a-global-namespace"},{"file_dir":"/","guide_id":"retry-policies","local_ref":"","node_id":"concepts/what-is-a-retry-policy"},{"file_dir":"/","guide_id":"tasks","local_ref":"","node_id":"concepts/what-is-a-task"},{"file_dir":"/","guide_id":"tasks","local_ref":"workflow-task","node_id":"concepts/what-is-a-workflow-task"},{"file_dir":"/","guide_id":"tasks","local_ref":"workflow-task-execution","node_id":"concepts/what-is-a-workflow-task-execution"},{"file_dir":"/","guide_id":"tasks","local_ref":"activity-task","node_id":"concepts/what-is-an-activity-task"},{"file_dir":"/","guide_id":"tasks","local_ref":"activity-task-execution","node_id":"concepts/what-is-an-activity-task-execution"},{"file_dir":"/","guide_id":"tasks","local_ref":"task-queue","node_id":"concepts/what-is-a-task-queue"},{"file_dir":"/","guide_id":"tasks","local_ref":"sticky-execution","node_id":"concepts/what-is-a-sticky-execution"},{"file_dir":"/","guide_id":"tasks","local_ref":"task-routing","node_id":"concepts/what-is-task-routing"},{"file_dir":"/","guide_id":"temporal","local_ref":"","node_id":"concepts/what-is-temporal"},{"file_dir":"/","guide_id":"temporal","local_ref":"temporal-platform","node_id":"concepts/what-is-the-temporal-platform"},{"file_dir":"/","guide_id":"temporal","local_ref":"temporal-application","node_id":"concepts/what-is-a-temporal-application"},{"file_dir":"/","guide_id":"temporal","local_ref":"temporal-sdk","node_id":"concepts/what-is-a-temporal-sdk"},{"file_dir":"/","guide_id":"temporal","local_ref":"temporal-client","node_id":"concepts/what-is-a-temporal-client"},{"file_dir":"/","guide_id":"visibility","local_ref":"","node_id":"concepts/what-is-visibility"},{"file_dir":"/","guide_id":"visibility","local_ref":"standard-visibility","node_id":"concepts/what-is-standard-visibility"},{"file_dir":"/","guide_id":"visibility","local_ref":"advanced-visibility","node_id":"concepts/what-is-advanced-visibility"},{"file_dir":"/","guide_id":"visibility","local_ref":"list-filter","node_id":"concepts/what-is-a-list-filter"},{"file_dir":"/","guide_id":"visibility","local_ref":"search-attribute","node_id":"concepts/what-is-a-search-attribute"},{"file_dir":"/","guide_id":"workers","local_ref":"","node_id":"concepts/what-is-a-worker"},{"file_dir":"/","guide_id":"workers","local_ref":"worker-program","node_id":"concepts/what-is-a-worker-program"},{"file_dir":"/","guide_id":"workers","local_ref":"worker-entity","node_id":"concepts/what-is-a-worker-entity"},{"file_dir":"/","guide_id":"workers","local_ref":"worker-process","node_id":"concepts/what-is-a-worker-process"},{"file_dir":"/","guide_id":"workflows","local_ref":"","node_id":"concepts/what-is-a-workflow"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-definition","node_id":"concepts/what-is-a-workflow-definition"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-type","node_id":"concepts/what-is-a-workflow-type"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-execution","node_id":"concepts/what-is-a-workflow-execution"},{"file_dir":"/","guide_id":"workflows","local_ref":"command","node_id":"concepts/what-is-a-command"},{"file_dir":"/","guide_id":"workflows","local_ref":"event","node_id":"concepts/what-is-an-event"},{"file_dir":"/","guide_id":"workflows","local_ref":"event-history","node_id":"concepts/what-is-an-event-history"},{"file_dir":"/","guide_id":"workflows","local_ref":"continue-as-new","node_id":"concepts/what-is-continue-as-new"},{"file_dir":"/","guide_id":"workflows","local_ref":"run-id","node_id":"concepts/what-is-a-run-id"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-id","node_id":"concepts/what-is-a-workflow-id"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-id-reuse-policy","node_id":"concepts/what-is-a-workflow-id-reuse-policy"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-execution-timeout","node_id":"concepts/what-is-a-workflow-execution-timeout"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-run-timeout","node_id":"concepts/what-is-a-workflow-run-timeout"},{"file_dir":"/","guide_id":"workflows","local_ref":"workflow-task-timeout","node_id":"concepts/what-is-a-workflow-task-timeout"},{"file_dir":"/","guide_id":"workflows","local_ref":"signal","node_id":"concepts/what-is-a-signal"},{"file_dir":"/","guide_id":"workflows","local_ref":"query","node_id":"concepts/what-is-a-query"},{"file_dir":"/","guide_id":"workflows","local_ref":"child-workflow","node_id":"concepts/what-is-a-child-workflow-execution"},{"file_dir":"/","guide_id":"workflows","local_ref":"parent-close-policy","node_id":"concepts/what-is-a-parent-close-policy"},{"file_dir":"/","guide_id":"workflows","local_ref":"temporal-cron-job","node_id":"concepts/what-is-a-temporal-cron-job"},{"file_dir":"/","guide_id":"workflows","local_ref":"schedule","node_id":"concepts/what-is-a-schedule"},{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"","node_id":"cloud-context/get-started-intro"},{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"issue-ca-certificates","node_id":"cloud-context/get-started-certificates"},{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"create-a-namespace","node_id":"cloud-context/get-started-namespace"},{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"invite-users","node_id":"cloud-context/users-invite"},{"file_dir":"cloud","guide_id":"how-to-get-started-with-temporal-cloud","local_ref":"connect-temporal-clients-and-worker-processes","node_id":"cloud-context/get-started-connect"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"","node_id":"cloud-context/certificates-intro"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"certificate-requirements","node_id":"cloud-context/certificates-requirements"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"issue-certificates","node_id":"cloud-context/certificates-issue"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"control-authorization","node_id":"cloud-context/certificates-authorization"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"manage-certificates","node_id":"cloud-context/certificates-namespace"},{"file_dir":"cloud","guide_id":"how-to-manage-certificates-in-temporal-cloud","local_ref":"manage-certificate-filters","node_id":"cloud-context/certificates-filters"},{"file_dir":"cloud","guide_id":"how-to-manage-namespaces-in-temporal-cloud","local_ref":"","node_id":"cloud-context/namespaces-intro"},{"file_dir":"cloud","guide_id":"how-to-manage-namespaces-in-temporal-cloud","local_ref":"create-a-namespace","node_id":"cloud-context/namespaces-create"},{"file_dir":"cloud","guide_id":"how-to-manage-namespaces-in-temporal-cloud","local_ref":"access-namespaces","node_id":"cloud-context/namespaces-access"},{"file_dir":"cloud","guide_id":"how-to-manage-namespaces-in-temporal-cloud","local_ref":"manage-namespaces","node_id":"cloud-context/namespaces-manage"},{"file_dir":"application-development","guide_id":"features","local_ref":"","node_id":"app-dev-context/features"},{"file_dir":"application-development","guide_id":"features","local_ref":"signals","node_id":"app-dev-context/signals"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"app-dev-context/define-signal"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"go/how-to-define-a-signal-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"java/how-to-define-a-signal-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"php/how-to-define-a-signal-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"python/how-to-define-a-signal-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-signal","node_id":"typescript/how-to-define-a-signal-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"app-dev-context/handle-signal"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"go/how-to-handle-a-signal-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"java/how-to-handle-a-signal-in-a-workflow-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"php/how-to-handle-a-signal-in-a-workflow-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"python/how-to-handle-a-signal-in-a-workflow-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-signal","node_id":"typescript/how-to-handle-a-signal-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"app-dev-context/send-signal-from-client"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"go/how-to-send-a-signal-from-a-client-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"java/how-to-send-a-signal-from-a-client-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"php/how-to-send-a-signal-from-a-client-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-client","node_id":"typescript/how-to-send-a-signal-from-a-client-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"app-dev-context/send-signal-from-workflow"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"go/how-to-send-a-signal-from-a-workflow-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"java/how-to-send-a-signal-from-a-workflow-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"php/how-to-send-a-signal-from-a-workflow-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-signal-from-workflow","node_id":"typescript/how-to-send-a-signal-from-a-workflow-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"app-dev-context/signal-with-start"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"go/how-to-send-a-signal-with-start-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"java/how-to-send-a-signal-with-start-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"php/how-to-send-a-signal-with-start-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"python/how-to-send-a-signal-with-start-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"signal-with-start","node_id":"typescript/how-to-send-a-signal-with-start-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"queries","node_id":"app-dev-context/queries"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"app-dev-context/define-query"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"go/how-to-define-a-query-type-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"java/how-to-define-a-query-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"php/how-to-define-a-query-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"define-query","node_id":"python/how-to-define-a-query-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"app-dev-context/handle-query"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"go/how-to-handle-a-query-in-a-workflow-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"java/how-to-handle-a-query-in-a-workflow-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"php/how-to-handle-a-query-in-a-workflow-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"python/how-to-handle-a-query-in-a-workflow-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"handle-query","node_id":"typescript/how-to-handle-a-query-in-a-workflow-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-query","node_id":"app-dev-context/send-query"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-query","node_id":"go/how-to-send-a-query-to-a-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"send-query","node_id":"java/how-to-send-a-query-to-a-workflow-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-timeouts-&-retries","node_id":"app-dev-context/workflow-timeouts-and-retries"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-execution-timeout","node_id":"app-dev-context/workflow-execution-timeout"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-execution-timeout","node_id":"go/how-to-set-a-workflow-execution-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-execution-timeout","node_id":"java/how-to-set-a-workflow-execution-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-execution-timeout","node_id":"php/how-to-set-a-workflow-execution-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-run-timeout","node_id":"app-dev-context/workflow-run-timeout"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-run-timeout","node_id":"go/how-to-set-a-workflow-run-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-run-timeout","node_id":"java/how-to-set-a-workflow-run-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-run-timeout","node_id":"php/how-to-set-a-workflow-run-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-task-timeout","node_id":"app-dev-context/workflow-task-timeout"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-task-timeout","node_id":"go/how-to-set-a-workflow-task-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-task-timeout","node_id":"java/how-to-set-a-workflow-task-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-task-timeout","node_id":"php/how-to-set-a-workflow-task-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-retry-policy","node_id":"app-dev-context/workflow-retry-policy"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-retry-policy","node_id":"go/how-to-set-a-workflow-retry-policy-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-retry-policy","node_id":"java/how-to-set-workflow-retry-options-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"workflow-retry-policy","node_id":"php/how-to-set-workflow-retry-options-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-timeouts-and-retries","node_id":"app-dev-context/activity-timeouts-and-retries"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"app-dev-context/schedule-to-close"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"go/how-to-set-a-schedule-to-close-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"java/how-to-set-a-schedule-to-close-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"php/how-to-set-a-schedule-to-close-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"python/how-to-set-a-schedule-to-close-timeout-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-close-timeout","node_id":"typescript/how-to-set-a-schedule-to-close-timeout-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"app-dev-context/start-to-close"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"go/how-to-set-a-start-to-close-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"java/how-to-set-a-start-to-close-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"php/how-to-set-a-start-to-close-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"python/how-to-set-a-start-to-close-timeout-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"start-to-close-timeout","node_id":"typescript/how-to-set-a-start-to-close-timeout-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"app-dev-context/schedule-to-start"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"go/how-to-set-a-schedule-to-start-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"java/how-to-set-a-schedule-to-start-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"php/how-to-set-a-schedule-to-start-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"python/how-to-set-a-schedule-to-start-timeout-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"schedule-to-start-timeout","node_id":"typescript/how-to-set-a-schedule-to-start-timeout-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"app-dev-context/activity-retry-policy"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"go/how-to-set-an-activity-retry-policy-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"java/how-to-set-activity-retry-options-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"php/how-to-set-activity-retry-options-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"python/how-to-set-an-activity-retry-policy-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-policy","node_id":"typescript/how-to-set-an-activity-retry-policy-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-retry-simulator","node_id":"app-dev-context/activity-retry-simulator"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"app-dev-context/activity-heartbeats"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"go/how-to-heartbeat-an-activity-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"java/how-to-heartbeat-an-activity-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"php/how-to-set-a-heartbeat-for-an-activity-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"python/how-to-heartbeat-an-activity-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"activity-heartbeats","node_id":"typescript/how-to-heartbeat-an-activity-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"app-dev-context/heartbeat-timeout"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"go/how-to-set-a-heartbeat-timeout-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"java/how-to-set-a-heartbeat-timeout-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"php/how-to-set-a-heartbeat-timeout-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"python/how-to-set-a-heartbeat-timeout-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"heartbeat-timeout","node_id":"typescript/how-to-set-a-heartbeat-timeout-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"asynchronous-activity-completion","node_id":"app-dev-context/async-activity-completion"},{"file_dir":"application-development","guide_id":"features","local_ref":"asynchronous-activity-completion","node_id":"go/how-to-asynchronously-complete-an-activity-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"asynchronous-activity-completion","node_id":"php/how-to-set-asynchronous-activity-completion-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"child-workflows","node_id":"app-dev-context/child-workflows"},{"file_dir":"application-development","guide_id":"features","local_ref":"child-workflows","node_id":"go/how-to-spawn-a-child-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"child-workflows","node_id":"java/how-to-spawn-a-child-workflow-execution-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"child-workflows","node_id":"php/how-to-spawn-a-child-workflow-execution-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"parent-close-policy","node_id":"app-dev-context/parent-close-policy"},{"file_dir":"application-development","guide_id":"features","local_ref":"parent-close-policy","node_id":"go/how-to-set-a-parent-close-policy-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"parent-close-policy","node_id":"java/how-to-set-a-parent-close-policy-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"parent-close-policy","node_id":"php/how-to-set-a-parent-close-policy-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"app-dev-context/continue-as-new"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"go/how-to-continue-as-new-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"java/how-to-continue-as-new-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"php/how-to-continue-as-new-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"continue-as-new","node_id":"python/how-to-continue-as-new-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"app-dev-context/cron-jobs"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"go/how-to-set-a-cron-schedule-in-go"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"java/how-to-set-a-cron-schedule-in-java"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"php/how-to-set-a-cron-schedule-in-php"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"python/how-to-set-a-cron-schedule-in-python"},{"file_dir":"application-development","guide_id":"features","local_ref":"temporal-cron-jobs","node_id":"typescript/how-to-set-a-cron-job-in-typescript"},{"file_dir":"application-development","guide_id":"features","local_ref":"environment-variables","node_id":"app-dev-context/environment-variables"},{"file_dir":"application-development","guide_id":"features","local_ref":"environment-variables","node_id":"typescript/how-to-use-environment-variables-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"","node_id":"app-dev-context/foundations"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-a-dev-cluster","node_id":"clusters/quick-install"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"app-dev-context/add-sdk"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"go/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"java/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"php/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"python/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"add-your-sdk","node_id":"typescript/index"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"app-dev-context/api-reference"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"go/api-reference-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"java/api-reference-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"python/api-reference-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"api-reference","node_id":"typescript/api-reference-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"app-dev-context/code-samples"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"go/code-samples-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"java/code-samples-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"php/code-samples-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"python/code-samples-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"code-samples","node_id":"typescript/code-samples-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"app-dev-context/connect-to-a-cluster"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"go/how-to-connect-to-a-cluster-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"java/how-to-create-a-temporal-client-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"php/how-to-create-a-temporal-client-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"python/how-to-connect-to-a-cluster-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"connect-to-a-cluster","node_id":"typescript/how-to-connect-to-a-cluster-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"app-dev-context/developing-workflows"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"go/how-to-develop-a-workflow-definition-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"java/how-to-develop-a-workflow-definition-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"php/how-to-develop-a-workflow-definition-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"python/how-to-develop-a-workflow-definition-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-workflows","node_id":"typescript/how-to-develop-a-workflow-definition-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"app-dev-context/workflow-parameters"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"go/how-to-define-workflow-parameters-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"java/how-to-define-workflow-parameters-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"php/how-to-define-workflow-parameters-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"python/how-to-define-workflow-parameters-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-parameters","node_id":"typescript/how-to-define-workflow-parameters-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"app-dev-context/workflow-return-values"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"go/how-to-define-workflow-return-values-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"java/how-to-define-workflow-return-values-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"php/how-to-define-workflow-return-values-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"python/how-to-define-workflow-return-values-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-return-values","node_id":"typescript/how-to-define-workflow-return-values-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"app-dev-context/customize-workflow-type"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"go/how-to-customize-workflow-type-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"java/how-to-customize-workflow-type-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"python/how-to-customize-workflow-type-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-type","node_id":"typescript/how-to-customize-workflow-type-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"app-dev-context/workflow-logic-requirements"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"go/how-to-handle-workflow-logic-requirements-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"java/how-to-handle-workflow-logic-requirements-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"php/how-to-handle-workflow-logic-requirements-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-logic-requirements","node_id":"python/how-to-handle-workflow-logic-requirements-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"app-dev-context/developing-activities"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"go/how-to-develop-an-activity-definition-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"java/how-to-develop-an-activity-definition-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"php/how-to-develop-an-activity-definition-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"python/how-to-develop-an-activity-definition-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"develop-activities","node_id":"typescript/how-to-develop-an-activity-definition-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"app-dev-context/activity-parameters"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"go/how-to-define-activity-parameters-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"java/how-to-define-activity-parameters-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"php/how-to-define-activity-parameters-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"python/how-to-define-activity-parameters-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-parameters","node_id":"typescript/how-to-define-activity-parameters-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"app-dev-context/activity-return-values"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"go/how-to-define-activity-return-values-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"java/how-to-define-activity-return-values-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"php/how-to-define-activity-return-values-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"python/how-to-define-activity-return-values-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-return-values","node_id":"typescript/how-to-define-activity-return-values-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"app-dev-context/customize-activity-type"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"go/how-to-customize-activity-type-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"java/how-to-customize-activity-type-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"python/how-to-customize-activity-type-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"customize-activity-type","node_id":"typescript/how-to-customize-activity-type-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"app-dev-context/spawning-activities"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"go/how-to-spawn-an-activity-execution-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"java/how-to-spawn-an-activity-execution-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"php/how-to-spawn-an-activity-execution-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"python/how-to-spawn-an-activity-execution-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"activity-execution","node_id":"typescript/how-to-spawn-an-activity-execution-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"required-timeout","node_id":"app-dev-context/required-activity-timeout"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"app-dev-context/get-activity-results"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"go/how-to-get-the-result-of-an-activity-execution-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"java/how-to-get-the-result-of-an-activity-execution-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"php/how-to-get-the-result-of-an-activity-execution-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"python/how-to-get-the-result-of-an-activity-execution-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-activity-results","node_id":"typescript/how-to-get-the-result-of-an-activity-execution-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"app-dev-context/run-worker-processes"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"go/how-to-develop-a-worker-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"java/how-to-develop-a-worker-program-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"php/how-to-develop-a-worker-program-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"python/how-to-develop-a-worker-program-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"run-worker-processes","node_id":"typescript/how-to-develop-a-worker-program-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"app-dev-context/registering-types"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"go/how-to-register-types-with-a-worker-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"java/how-to-register-types-with-a-worker-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"php/how-to-register-types-with-a-worker-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"python/how-to-register-types-with-a-worker-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"register-types","node_id":"typescript/how-to-register-types-with-a-worker-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"app-dev-context/spawning-workflows"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"go/how-to-spawn-a-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"java/how-to-spawn-a-workflow-execution-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"php/how-to-spawn-a-workflow-execution-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"python/how-to-spawn-a-workflow-execution-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"start-workflow-execution","node_id":"typescript/how-to-spawn-a-workflow-execution-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"app-dev-context/set-task-queue"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"go/how-to-set-a-workflow-task-queue-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"java/how-to-set-a-workflow-task-queue-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"php/how-to-set-a-workflow-task-queue-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"python/how-to-set-a-workflow-task-queue-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"set-task-queue","node_id":"typescript/how-to-set-a-workflow-task-queue-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"app-dev-context/set-workflow-id"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"go/how-to-set-a-workflow-id-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"java/how-to-set-a-workflow-id-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"php/how-to-set-a-workflow-id-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"python/how-to-set-a-workflow-id-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"workflow-id","node_id":"typescript/how-to-set-a-workflow-id-in-typescript"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"app-dev-context/get-workflow-results"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"go/how-to-get-the-result-of-a-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"java/how-to-get-the-result-of-a-workflow-execution-in-java"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"php/how-to-get-the-result-of-a-workflow-execution-in-php"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"python/how-to-get-the-result-of-a-workflow-execution-in-python"},{"file_dir":"application-development","guide_id":"foundations","local_ref":"get-workflow-results","node_id":"typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"","node_id":"app-dev-context/observability"},{"file_dir":"application-development","guide_id":"observability","local_ref":"metrics","node_id":"app-dev-context/metrics"},{"file_dir":"application-development","guide_id":"observability","local_ref":"metrics","node_id":"go/how-to-emit-metrics-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"metrics","node_id":"java/how-to-emit-metrics-in-java"},{"file_dir":"application-development","guide_id":"observability","local_ref":"metrics","node_id":"typescript/how-to-emit-metrics-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"tracing","node_id":"app-dev-context/tracing"},{"file_dir":"application-development","guide_id":"observability","local_ref":"tracing","node_id":"go/how-to-configure-tracing-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"tracing","node_id":"typescript/how-to-configure-tracing-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"logging","node_id":"app-dev-context/logging"},{"file_dir":"application-development","guide_id":"observability","local_ref":"logging","node_id":"go/how-to-log-from-a-workflow-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"logging","node_id":"python/how-to-log-from-a-workflow-in-python"},{"file_dir":"application-development","guide_id":"observability","local_ref":"logging","node_id":"typescript/how-to-log-from-a-workflow-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-logger","node_id":"app-dev-context/custom-logging"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-logger","node_id":"go/how-to-set-a-custom-logger-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-logger","node_id":"typescript/how-to-set-a-custom-logger-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"visibility","node_id":"app-dev-context/visibility"},{"file_dir":"application-development","guide_id":"observability","local_ref":"search-attributes","node_id":"app-dev-context/search-attributes"},{"file_dir":"application-development","guide_id":"observability","local_ref":"search-attributes","node_id":"go/how-to-list-workflow-executions-using-the-client-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"search-attributes","node_id":"typescript/how-to-list-workflow-executions-using-the-client-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-search-attributes","node_id":"app-dev-context/set-custom-search-attributes"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-search-attributes","node_id":"go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-search-attributes","node_id":"python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python"},{"file_dir":"application-development","guide_id":"observability","local_ref":"custom-search-attributes","node_id":"typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"upsert-search-attributes","node_id":"app-dev-context/upsert-custom-search-attributes"},{"file_dir":"application-development","guide_id":"observability","local_ref":"upsert-search-attributes","node_id":"go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"upsert-search-attributes","node_id":"python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python"},{"file_dir":"application-development","guide_id":"observability","local_ref":"upsert-search-attributes","node_id":"typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"app-dev-context/remove-search-attributes"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"go/how-to-remove-search-attributes-from-a-workflow-in-go"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"php/how-to-remove-search-attributes-from-a-workflow-in-php"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"python/how-to-remove-search-attributes-from-a-workflow-in-python"},{"file_dir":"application-development","guide_id":"observability","local_ref":"remove-search-attribute","node_id":"typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript"},{"file_dir":"application-development","guide_id":"testing","local_ref":"","node_id":"app-dev-context/testing"},{"file_dir":"application-development","guide_id":"testing","local_ref":"replay","node_id":"app-dev-context/replays"},{"file_dir":"application-development","guide_id":"testing","local_ref":"replay","node_id":"go/how-to-replay-a-workflow-execution-in-go"},{"file_dir":"application-development","guide_id":"testing","local_ref":"replay","node_id":"python/how-to-replay-a-workflow-execution-in-python"}]}

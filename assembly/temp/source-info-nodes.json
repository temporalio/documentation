[{"file_name":"audit-logging-supported-events.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/audit-logging-supported-events.md","id":"cloud-context/audit-logging-supported-events","title":"Which events are supported by Audit Logging?","description":"Audit Logging currently supports Admin Operation events.","label":"Supported events","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe first release of Audit Logging supports Admin Operation events.\n\n### Admin Operation events\n\nThe following list specifies both the supported events and the Temporal APIs that emit the logs.\n\n- Account\n  - Configure Audit Logging: `UpdateAccount`\n  - Configure observability: `UpdateAccount`\n- User\n  - Create user invitations: `InviteUsers`\n  - Delete users: `DeleteUser`\n  - Update user account-level Roles: `UpdateUser`\n  - Update user Namespace permissions: `UpdateUserNamespacePermissions`\n  - Log in user: `UserLogin`\n- Namespace\n  - Create Namespace: `CreateNamespace`\n  - Update Namespace: `UpdateNamespace`\n  - Delete Namespace: `DeleteNamespace`\n  - Add or update certificates or certificate filters: `UpdateNamespace`\n  - Add custom Search Attributes: `UpdateNamespace`\n  - Rename custom Search Attribute: `RenameCustomSearchAttribute`\n  - Request increase in Retention Period: `UpdateNamespace`\n\n### Audit Log format\n\nThe log sent to the Kinesis stream is JSON in the following format:\n\n```json\n{\n  \"emit_time\": // Time the operation was recorded\n  \"level\": // Level of the log entry, such as info, warning, or error\n  \"user_email\":  // Email address of the user who initiated the operation\n  \"operation\":  // Operation that was performed\n  \"details\":  // Details of the operation\n  \"status\": // Status, such as OK or error\n  \"category\":  // Category of the log entry: Admin or System\n  \"version\": // Version of the log entry, beginning with 0 and updated when a backfill or resend of the same log occurs\n  \"log_id\": // Unique ID of the log entry\n}\n```\n","is_empty":false},{"file_name":"audit-logging-supported-integrations.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/audit-logging-supported-integrations.md","id":"cloud-context/audit-logging-supported-integrations","title":"Which integrations are supported by Audit Logging?","description":"Audit Logging currently supports Amazon Kinesis.","label":"Supported integrations","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAudit Logging supports the [Amazon Kinesis](https://docs.aws.amazon.com/kinesis/) streaming-data platform.\nBy using [Amazon Kinesis Data Firehose](https://docs.aws.amazon.com/firehose/latest/dev/what-is-this-service.html), you can route Temporal Audit Logs in [Amazon Simple Storage Service](https://docs.aws.amazon.com/s3/) (S3).\nWe plan to release additional integrations.\n","is_empty":false},{"file_name":"certificates-authorization.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/certificates-authorization.md","id":"cloud-context/certificates-authorization","title":"How to control authorization for Temporal Cloud Namespaces","description":"Temporal Cloud requires full CA chains, so you can achieve authorization in two ways.","label":"Control authorization","tags":["guide-context"],"ssdi":[],"markdown_content":"\nBecause Temporal Cloud uses mTLS for authorization, we recommend that an end-entity certificate be scoped to a specific Namespace.\nTemporal Cloud requires full CA chains, so you can achieve authorization in two ways.\n\n### Option 1: Issue a separate root certificate for each Namespace\n\nEach certificate must belong to a chain up to the root CA certificate.\nTemporal uses the root CA certificate as the trusted authority for access to your Namespaces.\n\n1. Ensure that your certificates meet the [certificate requirements](#certificate-requirements).\n1. [Add client CA certificates to a Cloud Namespace](/cloud/tcld/namespace/accepted-client-ca/add).\n\n### Option 2: Use the same root certificate for all Namespaces but create a separate certificate filter for each Namespace\n\n[How to manage certificate filters in Temporal Cloud](#manage-certificate-filters)\n","is_empty":false},{"file_name":"certificates-filters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/certificates-filters.md","id":"cloud-context/certificates-filters","title":"How to manage certificate filters in Temporal Cloud","description":"To limit access to specific CA certificates, you can create certificate filters.","label":"Manage certificate filters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo limit access to specific [end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud), you can create certificate filters.\nEach filter contains values for one or more of the following fields:\n\n- commonName (CN)\n- organization (O)\n- organizationalUnit (OU)\n- subjectAlternativeName (SAN)\n\nCorresponding fields in the client certificate must match every specified value in the filter.\n\nThe values for the fields are case-insensitive.\nIf no wildcard is used, each specified value must match its field exactly.\n\nTo match a substring, place a single `*` wildcard at the beginning or end (but not both) of a value.\nYou cannot use a `*` wildcard by itself.\n\nYou can create a maximum of 25 certificate filters in a Namespace.\n\nIf you provide a well-known CA certificate, you cannot clear a certificate filter.\nA well-known CA certificate is one that is typically included in the certificate store of an operating system.\n\n**Examples**\n\nIn the following example, only the CN field of the certificate's subject is checked, and it must be exactly `code.example.com`.\nThe other fields are not checked.\n\n```json\nAuthorizedClientCertificate {\n  CN : \"code.example.com\"\n}\n```\n\nIn the following example, the CN field must be `stage.example.com` and the O field must be `Example Code Inc.`\n\n```json\nAuthorizedClientCertificate {\n  CN : \"stage.example.com\"\n  O : \"Example Code Inc.\"\n}\n```\n\nWhen using a `*` wildcard, the following values are valid:\n\n- `*.example.com` matches `code.example.com` and `text.example.com`.\n- `Example Code*` matches `Example code` and `Example Code Inc`.\n\nThe following values are not valid:\n\n- `.example.*`\n- `code.*.com`\n- `*`\n\n<!--- How to manage certificate filters in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage certificate filters using Temporal Cloud UI\n\nTo add or remove a certificate filter, follow these steps:\n\n1. On the left side of the window, click **Namespaces**.\n1. On the **Namespaces** page, click the name of the Namespace to manage.\n1. On the right side of the page for the selected Namespace, click **Edit**.\n1. On the **Edit** page, click **Certificate Filters**.\n   - To add a certificate filter, click **Add a Certificate Filter** and enter values in one or more fields.\n   - To remove a certificate filter, click the **×** in the upper-right corner of the filter details.\n1. To cancel your changes, click **Back to Namespace**. To save your changes, click **Save**.\n\n<!--- How to manage certificate filters in Temporal Cloud using tcld --->\n\n### Manage certificate filters using tcld\n\nTo set or clear certificate filters, use the following [tcld](/cloud/tcld) commands:\n\n- [tcld namespace certificate-filters import](/cloud/tcld/namespace/certificate-filters/import)\n- [tcld namespace certificate-filters clear](/cloud/tcld/namespace/certificate-filters/clear)\n\nTo view the current certificate filters, use the [tcld namespace certificate-filters export](/cloud/tcld/namespace/certificate-filters/export) command.\n","is_empty":false},{"file_name":"certificates-intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/certificates-intro.md","id":"cloud-context/certificates-intro","title":"How to manage certificates in Temporal Cloud","description":"Access to Temporal Cloud requires a certificate from you.","label":"Manage certificates","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAccess to [Temporal Cloud](https://temporal.io/cloud) is secured with the mutual Transport Layer Security (mTLS) protocol.\nThis protocol requires a CA certificate from you.\n\n[Worker Processes](/workers/#worker-process) use both CA certificates and private keys to connect to Temporal Cloud. Private keys remain in your control; Temporal Cloud requires no exchange of secrets.\n","is_empty":false},{"file_name":"certificates-issue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/certificates-issue.md","id":"cloud-context/certificates-issue","title":"How to issue root CA and end-entity certificates","description":"You can issue root CA and end-entity certificates in two ways.","label":"Issue certificates","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal Cloud authenticates a client connection by validating the client certificate against one or more CA certificates that are configured for the specified Namespace.\n\n### Option 1: You already have certificate management infrastructure\n\nIf you have existing certificate management infrastructure that supports issuing CA and end-entity certificates, it satisfies the requirements.\nWhen you configure the client SDK, you need to present a complete certificate chain up to the CA certificate given to Temporal.\n\n### Option 2: You don't have certificate management infrastructure\n\nIf you don't have an existing certificate management infrastructure, you can issue the CA and client certificates by using tools such as OpenSSL or open source tools like certstrap.\n\n#### Option 2a: Use certstrap\n\n[Certstrap](https://github.com/square/certstrap) is a popular and easy to use tool for issuing certificates.\n\nFollow these steps to issue a certificate for use with Temporal Cloud:\n\n1. Install certstrap by following the instructions in the [certstrap README](https://github.com/square/certstrap#getting-started).\n2. Set the Namespace Name as the common name for the certificate:\n\n<Tabs>\n  <TabItem value=\"macos\" label=\"MacOS\" default>\n\n```command\nexport NAMESPACE_NAME=your-namespace\n```\n\n</TabItem>\n  <TabItem value=\"windows\" label=\"Windows\">\n\n```command\nset NAMESPACE_NAME=your-namespace\n```\n\n</TabItem>\n</Tabs>\n\n3. Initialize a new certificate authority:\n\n```command\n./certstrap init --common-name \"My Cert Auth\"\n```\n\n4. Request a certificate with a common name equal to the Namespace Name:\n\n```command\n./certstrap request-cert --common-name ${NAMESPACE_NAME}\n```\n\n5. Sign the certificate request and generate the end-entity certificate:\n\n```command\n./certstrap sign ${NAMESPACE_NAME} --CA \"My Cert Auth\"\n```\n\n6. (optional) If you are using the Temporal Java SDK, you will need to convert the PKCS1 file format to PKCS8 file format.\n   Export the certificate and private key to a PKCS8 file:\n\n```command\nopenssl pkcs8 -topk8 -inform PEM -outform PEM -in <infile.key> -out <outfile.key> -nocrypt\n```\n\nYou can now use the generated client certificate with Temporal Cloud.\n\n#### Option 2b: Use Temporal's client certificate generation tool\n\nWe also provide a tool that issues one root CA and the required end-entity certificate to use on the client SDK.\nThe tool can issue multiple end-entity certificates.\nWe've kept this tool minimal because it is a demonstration tool; **it is _not_ meant to be used in production.**\n\nYou can use this tool in two ways:\n\n- Follow the instructions for the [temporalio/client-certificate-generation](https://hub.docker.com/r/temporalio/client-certificate-generation) image in Docker Hub.\n  This procedure is the easiest because it's independent of your operating system.\n- Follow the README instructions in the [client-only](https://github.com/temporalio/samples-server/tree/main/tls/client-only) directory in our `temporalio/samples-server` repository in GitHub.\n\n:::info\n\nThe maximum number of CA certificates in a certificate bundle is 16. The payload size of a certificate bundle (before base64-encoding) is 32 KB.\n\n:::\n","is_empty":false},{"file_name":"certificates-namespace.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/certificates-namespace.md","id":"cloud-context/certificates-namespace","title":"How to add, update, and remove certificates in a Temporal Cloud Namespace","description":"To manage certificates for Temporal Cloud Namespaces, use the `tcld namespace accepted-client-ca` commands.","label":"Manage certificates","tags":["guide-context"],"ssdi":[],"markdown_content":"\n:::note\n\nTo manage certificates for a Namespace, a user must have [Namespace Admin](/cloud/#namespace-level-permissions) permission for that Namespace.\n\n:::\n\nTo manage certificates for Temporal Cloud Namespaces, use the **Namespaces** page in Temporal Cloud UI or the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/index) commands.\n\nDon't let your certificates expire!\nAdd reminders to your calendar to issue new CA certificates well before the expiration dates of the existing ones.\n\nWhen updating CA certificates, it's important to follow a rollover process.\nDoing so enables your Namespace to serve both CA certificates for a period of time until traffic to your old CA certificate ceases.\n\nBe aware that the subject of the existing certificate and the subject of the new certificate must not be identical.\nOne way to meet this requirement is to add a version or a date to the common name (CN).\n\n<!--- How to update certificates in Temporal Cloud using Temporal Cloud UI --->\n\n### Update certificates using Temporal Cloud UI\n\n1. On the left side of the window, select **Namespaces**.\n\n1. Select the name of the Namespace to update.\n\n1. In the top-right portion of the page for the Namespace, select **Edit**.\n\n1. On the **Edit** page, select the **CA Certificates** card to expand it.\n\n1. In the certificates box, scroll to the end of the existing certificate (that is, past `-----END CERTIFICATE-----`).\n\n1. On the following new line, paste the entire PEM block of the new certificate.\n\n1. Select **Save**.\n\n1. Wait until all Workers are using the new certificate.\n\n1. Return to the **Edit** page of the Namespace and select the **CA Certificates** card.\n\n1. In the certificates box, delete the old certificate, leaving the new one in place.\n\n1. Select **Save**.\n\n<!--- How to update certificates in Temporal Cloud using tcld --->\n\n### Update certificates using tcld\n\n1. Create a single file that contains both your old and new CA certificate PEM blocks.\n   Just concatenate the PEM blocks on adjacent lines.\n\n   ```\n   -----BEGIN CERTIFICATE-----\n   ... old CA cert ...\n   -----END CERTIFICATE-----\n   -----BEGIN CERTIFICATE-----\n   ... new CA cert ...\n   -----END CERTIFICATE-----\n   ```\n\n1. Run the `tcld namespace accepted-client-ca set` command with the CA certificate bundle file.\n\n   ```bash\n   tcld namespace accepted-client-ca set --ca-certificate-file <path>\n   ```\n\n1. Monitor traffic to your old certificate until it ceases.\n\n1. Create another file that contains only the new CA certificate.\n\n1. Run the `tcld namespace accepted-client-ca set` command again with the updated CA certificate bundle file.\n","is_empty":false},{"file_name":"certificates-requirements.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/certificates-requirements.md","id":"cloud-context/certificates-requirements","title":"Requirements for CA certificates in Temporal Cloud","description":"Certificates provided to Temporal for your Namespaces must meet certain requirements.","label":"Certificate requirements","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCertificates provided to Temporal for your [Namespaces](/namespaces) _must_ meet the following requirements.\n\n### CA certificates\n\nCA certificates _must_ meet the following criteria:\n\n- The certificates must be X.509v3.\n- Each certificate in the bundle must be either a root certificate or issued by another certificate in the bundle.\n- Each certificate in the bundle must include `CA: true`.\n- A certificate cannot be a well-known CA (such as DigiCert or Let's Encrypt) _unless_ the user also specifies certificate filters.\n- The signing algorithm must be either RSA or ECDSA and must include SHA-256 or stronger message authentication.\n  SHA-1 and MD5 cannot be used.\n\n### End-entity certificates\n\nAn end-entity (leaf) certificate _must_ meet the following criteria:\n\n- The certificate must be X.509v3.\n- Basic constraints must include `CA: false`.\n- The key usage must include Digital Signature.\n- The signing algorithm must be either RSA or ECDSA and must include SHA-256 or stronger message authentication.\n  SHA-1 and MD5 cannot be used.\n\nWhen a client presents an end-entity certificate, and the whole certificate chain is constructed, each certificate in the chain (from end-entity to the root) must have a unique Distinguished Name.\n\n:::caution\n\nDistinguished Names are _not_ case sensitive; that is, uppercase letters (such as ABC) and lowercase letters (such as abc) are equivalent.\n\n:::\n","is_empty":false},{"file_name":"cloud-intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/cloud-intro.md","id":"cloud-context/cloud-intro","title":"Temporal Cloud documentation","description":"Temporal Cloud documentation, including explanations and usage.","label":"Temporal Cloud","tags":["explanation"],"ssdi":[],"markdown_content":"\n:::note Sign up for Temporal Cloud\n\nTo request a Temporal Cloud account, complete the [request form](https://pages.temporal.io/cloud-request-access).\n\n:::\n\n- [Get started with Temporal Cloud](/cloud/how-to-get-started-with-temporal-cloud)\n- [Manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud)\n- [Manage Namespaces in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud)\n- [tcld (Temporal Cloud command-line interface)](/cloud/tcld)\n- [Temporal Cloud release notes](/cloud/release-notes)\n","is_empty":false},{"file_name":"get-started-certificates.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/get-started-certificates.md","id":"cloud-context/get-started-certificates","title":"Get started - Certificates","description":"Learn requirements for CA certificates","label":"Issue CA certificates","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou must provide your own certificates to access Temporal Cloud.\nFor certificate requirements, see the following:\n\n- [Requirements for CA certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements)\n- [Issue root CA and end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#issue-certificates)\n","is_empty":false},{"file_name":"get-started-connect.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/get-started-connect.md","id":"cloud-context/get-started-connect","title":"Get started - Connect","description":"Connect Temporal Clients and Worker Processes to Temporal Cloud.","label":"Connect to Temporal Cloud","tags":["guide-context"],"ssdi":[],"markdown_content":"\nConnecting your [Temporal Clients](/concepts/what-is-a-temporal-client) and [Worker Processes](/concepts/what-is-a-worker-process) to Temporal Cloud is similar to connecting them to your own [Temporal Cluster](/clusters).\nThe primary difference is the requirement to provide client certificates and private keys.\n\n- [Connect to Temporal Cloud in Go](/go/connect-to-temporal-cloud)\n- [Connect to Temporal Cloud in Python](/python/connect-to-temporal-cloud)\n- [Connect to Temporal Cloud in TypeScript](/typescript/connect-to-temporal-cloud)\n\n- [Run a Temporal Cloud Worker in Go](/go/run-a-temporal-cloud-worker)\n- [Run a Temporal Cloud Worker in TypeScript](/typescript/run-a-temporal-cloud-worker)\n","is_empty":false},{"file_name":"get-started-intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/get-started-intro.md","id":"cloud-context/get-started-intro","title":"Get started with Temporal Cloud","description":"Create an account, issue certificates, create a Namespace, invite users, and connect.","label":"Get started","tags":["guide-context"],"ssdi":[],"markdown_content":"\n:::note Sign up for Temporal Cloud\n\nTo request a Temporal Cloud account, complete the [request form](https://pages.temporal.io/cloud-request-access).\n\n:::\n\n<!--- Onboarding guide for Temporal Cloud --->\n\nYou received email from Temporal that welcomes you to your new Temporal account.\nYour email address is now the first [Global Admin](/cloud/#account-level-roles) for your account.\n\nTo get started with Temporal Cloud, follow these onboarding steps:\n\n<!--- 1. [Create an account.](#create-an-account-in-temporal-cloud) --->\n\n1. [Issue CA certificates](#issue-ca-certificates).\n1. [Create a Namespace](#create-a-namespace).\n1. [Invite users](#invite-users).\n1. [Connect to Temporal Cloud](#connect-to-temporal-cloud).\n","is_empty":false},{"file_name":"get-started-namespace.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/get-started-namespace.md","id":"cloud-context/get-started-namespace","title":"Get started - Namespaces","description":"Gather required information and use Temporal Cloud UI or tcld.","label":"Create a Namespace","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf you don't already have a Namespace (or want to create another), see the following:\n\n[Create a Namespace in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud/#create-a-namespace-in-temporal-cloud)\n","is_empty":false},{"file_name":"how-to-configure-audit-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/how-to-configure-audit-logging.md","id":"cloud-context/how-to-configure-audit-logging","title":"How to configure Audit Logging","description":"To configure Audit Logging, set up Amazon Kinesis and create an Audit Log sink.","label":"Configure Audit Logging","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo set up Audit Logging, you must have an Amazon Web Services (AWS) account and set up Kinesis Data Streams.\n\n1. If you don't have an AWS account, follow the instructions from AWS in [Create and activate an AWS account](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/).\n2. To set up Kinesis Data Streams, open the [AWS Management Console](https://aws.amazon.com/console/), search for Kinesis, and start the setup process.\n\nBe aware that Kinesis has a rate limit of 1,000 messages per second and quotas for both the number of records written and the size of the records.\nFor more information, see [Why is my Kinesis data stream throttling?](https://aws.amazon.com/premiumsupport/knowledge-center/kinesis-data-stream-throttling/)\n\n### Create an Audit Log sink\n\n1. In the Temporal Cloud UI, select **Settings**.\n1. On the **Settings** page, select **Integrations**.\n1. In the **Audit Logging** card, select **Configure Audit Logs**.\n1. On the **Audit Logging** page, choose your **Access method** (either **Auto** or **Manual**).\n   - **Auto:** Configure the AWS CloudFormation stack in your AWS account from the Cloud UI.\n   - **Manual:** Use a generated AWS CloudFormation template to set up Kinesis manually.\n1. In **Kinesis ARN**, paste the Kinesis ARN from your AWS account.\n1. In **Role name**, provide a name for a new IAM Role.\n1. In **Select an AWS region**, select the appropriate region for your Kinesis stream.\n\nIf you chose the **Auto** access method, continue with the following steps:\n\n1. Select **Save and launch stack**.\n1. In **Stack name** in the AWS CloudFormation console, specify a name for the stack.\n1. In the lower-right corner of the page, select **Create stack**.\n\nIf you chose the **Manual** access method, continue with the following steps:\n\n1. Select **Save and download template**.\n1. Open the [AWS CloudFormation console](https://console.aws.amazon.com/cloudformation/).\n1. Select **Create Stack**.\n1. On the **Create stack** page, select **Template is ready** and **Update a template file**.\n1. Select **Choose file** and specify the template you generated in step 1.\n1. Select **Next** on this page and on the next two pages.\n1. On the **Review** page, select **Create stack**.\n","is_empty":false},{"file_name":"how-to-consume-an-audit-log.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/how-to-consume-an-audit-log.md","id":"cloud-context/how-to-consume-an-audit-log","title":"How to consume an Audit Log","description":"You must implement your own consumer of the Kinesis stream.","label":"Consume an Audit Log","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAfter you create an Audit Log sink, wait for the logs to flow into the Kinesis stream.\nYou should see the first logs 2–10 minutes after you configure the sink.\nSubsequent logs arrive every 2 minutes if any actions occurred during that 2-minute window.\n\n:::note\n\nYou must configure and implement your own consumer of the Kinesis stream.\nFor an example, see [Example of consuming an Audit Log](/#example-of-consuming-an-audit-log).\n\n:::\n\n### Example of an Audit Log\n\nThe following example shows the contents of an Audit Log.\n\n```json\n{\"emit_time\":\"2023-10-24T08:19:41Z\",\"level\":\"LOG_LEVEL_INFO\",\"user_email\":\"zhengbo@example.com\",\"operation\":\"UpdateAccount\",\"details\":{\"client_ca_fingerprints\":[\"5bb99d14fa602f7d39b7d048674a2251\"],\"search_attribute_update\":{},\"additional_message\":\"finished unary call with code OK\"},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\"}\n**********\n{\"emit_time\":\"2023-10-25T21:16:42Z\",\"level\":\"LOG_LEVEL_INFO\",\"user_email\":\"alex@example.com\",\"operation\":\"DeleteUser\",\"details\":{\"target_users\":[\"0b741c47-e093-47d1-9b74-f2359129f78f\"],\"search_attribute_update\":{},\"additional_message\":\"finished unary call with code OK\"},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\"}\n**********\n{\"emit_time\":\"2023-11-03T19:31:45Z\",\"level\":\"LOG_LEVEL_INFO\",\"user_email\":\"matt@example.com\",\"operation\":\"InviteUsers\",\"details\":{\"target_users\":[\"matt@example.net\"],\"search_attribute_update\":{},\"additional_message\":\"finished unary call with code OK\"},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\"}\n**********\n{\"emit_time\":\"2023-11-08T08:06:40Z\",\"level\":\"LOG_LEVEL_INFO\",\"user_email\":\"zhengbo@example.com\",\"operation\":\"UpdateUser\",\"details\":{\"target_users\":[\"zhengbo@example.net\"],\"search_attribute_update\":{},\"additional_message\":\"finished unary call with code OK\"},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\"}\n**********\n{\"emit_time\":\"2023-11-08T08:14:09Z\",\"level\":\"LOG_LEVEL_INFO\",\"user_email\":\"zhengbo@example.com\",\"operation\":\"UpdateNamespace\",\"details\":{\"namespace\":\"audit-log-test.example-dev\",\"client_ca_fingerprints\":[\"f186d0bd971ff7d52dc6cc9d9b6f7644\"],\"search_attribute_update\":{},\"additional_message\":\"finished unary call with code OK\"},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\"}\n**********\n{\"emit_time\":\"2023-11-08T09:20:22Z\",\"level\":\"LOG_LEVEL_INFO\",\"user_email\":\"zhengbo@example.com\",\"operation\":\"UpdateUserNamespacePermissions\",\"details\":{\"namespace\":\"audit-log-test.example-dev\",\"search_attribute_update\":{},\"additional_message\":\"finished unary call with code OK\"},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\"}\n**********\n```\n\n### Example of consuming an Audit Log\n\nThe following Go code is an example of consuming Audit Logs from a Kinesis stream and delivering them to an S3 bucket.\n\n```go\nfunc main() {\n   fmt.Println(\"print audit log from S3\")\n   cfg, err := config.LoadDefaultConfig(context.TODO(),\n      config.WithSharedConfigProfile(\"your_profile\"),\n   )\n   if err != nil {\n      fmt.Println(err)\n   }\n   s3Client := s3.NewFromConfig(cfg)\n   response, err := s3Client.GetObject(\n      context.Background(),\n      &s3.GetObjectInput{\n         Bucket: aws.String(\"your_bucket_name\"),\n         Key:    aws.String(\"your_s3_file_path\")})\n   if err != nil {\n      fmt.Println(err)\n   }\n   defer response.Body.Close()\n\n   content, err := io.ReadAll(response.Body)\n\n   fmt.Println(string(content))\n}\n```\n\nThe preceding code also prints the logs in the terminal.\nThe following is a sample result.\n\n```json\n{\n  \"emit_time\": \"2023-11-14T07:56:55Z\",\n  \"level\": \"LOG_LEVEL_INFO\",\n  \"user_email\": \"zhengbo@example.com\",\n  \"operation\": \"DeleteUser\",\n  \"details\": {\n    \"target_users\": [\"d7dca96f-adcc-417d-aafc-e8f5d2ba9fe1\"],\n    \"search_attribute_update\": {},\n    \"additional_message\": \"finished unary call with code OK\"\n  },\n  \"status\": \"OK\",\n  \"category\": \"LOG_CATEGORY_ADMIN\"\n}\n```\n","is_empty":false},{"file_name":"how-to-delete-an-audit-log-sink.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/how-to-delete-an-audit-log-sink.md","id":"cloud-context/how-to-delete-an-audit-log-sink","title":"How to delete an Audit Log sink","description":"On the Audit Logging page, choose Delete.","label":"Delete an Audit Log sink","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen you no longer need Audit Logging, you can delete the Audit Log sink.\n\n1. In the Temporal Cloud UI, select **Settings**.\n1. On the **Settings** page, select **Integrations**.\n1. In the **Audit Logging** card, select **Configure Audit Logs**.\n1. At the bottom of the **Audit Logging** page, choose **Delete**.\n\nAfter you confirm the deletion, the Audit Log Sink is removed from your account and logs stop flowing to your Kinesis stream.\n","is_empty":false},{"file_name":"how-to-monitor-temporal-cloud-metrics.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/how-to-monitor-temporal-cloud-metrics.md","id":"cloud-context/how-to-monitor-temporal-cloud-metrics","title":"How to monitor Temporal Cloud metrics","description":"Configure and track performance metrics for Temporal Cloud.","label":"Cloud metrics","tags":["how-to"],"ssdi":[],"markdown_content":"\nBeyond the [metrics](/references/sdk-metrics) provided by the Temporal SDKs, some key metrics exist only in Temporal Cloud.\nYou can use your own observability tool to query an endpoint and review Namespace metrics.\n\nTo ensure security of your metrics, a CA certificate dedicated to observability is required.\nOnly clients that use certificates signed by that CA, or that chain up to the CA, can query the metrics endpoint.\nFor more information about CA certificates in Temporal Cloud, see [Certificate requirements](https://docs.temporal.io/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements).\n\n<!--- How to configure a metrics endpoint in Temporal Cloud using Temporal Cloud UI --->\n\n## Configure a metrics endpoint using Temporal Cloud UI\n\n:::note\n\nTo view and manage third-party integration settings, your user account must have the Global Admin [Role](https://docs.temporal.io/cloud/#account-level-roles).\n\n:::\n\nTo assign a certificate and generate your metrics endpoint, follow these steps:\n\n1. In Temporal Cloud UI, click **Settings**.\n1. On the **Settings** page, click **Integrations**.\n1. In the **Observability** card, click **Configure Observability**.\n   (If observability is already configured, the **Edit** link appears instead.)\n1. In **Certificates**, paste a base64-encoded CA certificate PEM block.\n1. Click **Generate endpoint**.\n\nAfter the page refreshes, the new metrics endpoint appears below **Endpoint**, in the form `https://<account-id>.tmprl.cloud/prometheus`.\nUse the endpoint to configure your observability tool—for example, [Grafana](https://grafana.com/) with [this dashboard](https://github.com/temporalio/dashboards/blob/master/cloud/temporal_cloud.json).\nFor more information, see [Set up Grafana with Temporal Cloud](/kb/prometheus-grafana-setup-cloud).\n\nYou can also query via the [Prometheus HTTP API](https://prometheus.io/docs/prometheus/latest/querying/api/) at URLs like:\n\n```\nhttps://<account-id>.tmprl.cloud/prometheus/api/v1/query?query=temporal_cloud_v0_state_transition_count\n```\n\nFor example:\n\n```\n$ curl --cert client.pem --key client-key.pem \"https://<account-id>.tmprl.cloud/prometheus/api/v1/query?query=temporal_cloud_v0_state_transition_count\" | jq .\n{\n  \"status\": \"success\",\n  \"data\": {\n    \"resultType\": \"vector\",\n    \"result\": [\n      {\n        \"metric\": {\n          \"__name__\": \"temporal_cloud_v0_state_transition_count\",\n          \"__rollup__\": \"true\",\n          \"operation\": \"WorkflowContext\",\n          \"temporal_account\": \"a2dd6\",\n          \"temporal_namespace\": \"mynamespace.a2dd6\",\n          \"temporal_service_type\": \"history\"\n        },\n        \"value\": [\n          1672347471.2,\n          \"0\"\n        ]\n      },\n      ...\n}\n```\n\n<!--- How to configure a metrics endpoint in Temporal Cloud using tcld --->\n\n## Configure a metrics endpoint using tcld\n\nTo add a certificate to a metrics endpoint, use [`tcld account metrics accepted-client-ca add`](/cloud/tcld/account/metrics/accepted-client-ca/add).\n\nTo enable a metrics endpoint, use [`tcld account metrics enable`](/cloud/tcld/account/metrics/enable).\n\nTo disable a metrics endpoint, use [`tcld account metrics disable`](/cloud/tcld/account/metrics/disable).\n\n## Available performance metrics\n\nTemporal tracks the following metrics for your various Namespaces.\n\n- temporal_cloud_v0_frontend_service_error_count\n- temporal_cloud_v0_frontend_service_request_count\n- temporal_cloud_v0_poll_success_count\n- temporal_cloud_v0_poll_success_sync_count\n- temporal_cloud_v0_poll_timeout_count\n- temporal_cloud_v0_service_latency_bucket\n- temporal_cloud_v0_service_latency_count\n- temporal_cloud_v0_service_latency_sum\n- temporal_cloud_v0_state_transition_count\n- temporal_cloud_v0_total_action_count\n- temporal_cloud_v0_workflow_cancel_count\n- temporal_cloud_v0_workflow_continued_as_new_count\n- temporal_cloud_v0_workflow_failed_count\n- temporal_cloud_v0_workflow_success_count\n- temporal_cloud_v0_workflow_terminate_count\n- temporal_cloud_v0_workflow_timeout_count\n\nMetrics for all Namespaces in your account are available from the metrics endpoint.\nThe `temporal_namespace` label identifies the Namespace that is associated with each metric so that each user can build their own dashboard to meet their needs.\n\nMetrics lag real-time performance by approximately one minute.\n\nWe retain raw metrics for seven days.\n","is_empty":false},{"file_name":"how-to-troubleshoot-audit-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/how-to-troubleshoot-audit-logging.md","id":"cloud-context/how-to-troubleshoot-audit-logging","title":"How to troubleshoot Audit Logging","description":"Audit Logging status appears in the Cloud UI. Contact Temporal about issues with an Audit Log sink.","label":"Troubleshoot Audit Logging","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Audit Logging page of the Temporal Cloud UI provides the current status of an Audit Log sink.\n\n- If an error is detected, a summary of the error appears below the page title.\n- If the Audit Log sink is functioning normally, an **On** badge appears next to the page heading.\n\nAfter an Admin Operation is performed, users can see Audit Log messages flow through Kinesis.\n\nTemporal retains Audit Log information for up to 30 days.\nIf you experience an issue with an Audit Log sink, we can provide the missing audit information.\nOpen a support ticket to request assistance.\n","is_empty":false},{"file_name":"namespaces-access.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/namespaces-access.md","id":"cloud-context/namespaces-access","title":"How to access a Namespace in Temporal Cloud","description":"You can access a Namespace in Temporal Cloud via gRPC and HTTPS endpoints.","label":"Access Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\n<!--- How to access a Namespace in Temporal Cloud --->\n\nEach Namespace in Temporal Cloud has two unique endpoints, both of which include the [Namespace Id](/cloud/#cloud-namespace-id).\n\n- For programmatic access, a gRPC endpoint in the form `<NamespaceId>.tmprl.cloud`; for example, `accounting-production.f45a2.tmprl.cloud:7233`.\n- For accessing Temporal Web UI, an HTTPS endpoint in the form `web.<namespaceId>.tmprl.cloud`; for example, `https://web.accounting-production.f45a2.tmprl.cloud`.\n","is_empty":false},{"file_name":"namespaces-create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/namespaces-create.md","id":"cloud-context/namespaces-create","title":"How to create a Namespace in Temporal Cloud","description":"To create a Namespace in Temporal Cloud, use either Temporal Cloud UI or tcld.","label":"Create a Namespace","tags":["guide-context"],"ssdi":[],"markdown_content":"\n:::info\n\nThe user who creates a [Namespace](/namespaces) is automatically granted [Namespace Admin](/cloud/#namespace-level-permissions) permission for that Namespace.\n\nTo create a Namespace, a user must have the Developer or Global Admin account-level [Role](/cloud/#account-level-roles).\n\n:::\n\n:::tip\n\nBy default, each account has a quota of 10 Namespaces.\nIf you want to increase this limit, open a [support ticket](https://docs.temporal.io/cloud/how-to-create-a-ticket-for-temporal-support).\n\n:::\n\n<!--- What information do I need to create a Namespace in Temporal Cloud? --->\n\n### Information needed to create a Namespace\n\nTo create a Namespace in Temporal Cloud, gather the following information:\n\n- [Namespace Name](/cloud/#cloud-namespace) and region.\n- [Retention Period](/clusters/#retention-period) for the [Event History](/workflows#event-history) of closed [Workflow Executions](/workflows#workflow-execution).\n- [CA certificate](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements) for the Namespace.\n- [Codec Server endpoint](/production-readiness/develop#set-your-codec-server-endpoints-with-web-ui-and-cli) to show decoded payloads to users in the Event History for Workflow Executions in the Namespace. For details, see [Securing your data](/production-readiness/develop#securing-your-data).\n- [Permissions](/cloud/#namespace-level-permissions) for each user.\n\n<!--- How to create a Namespace in Temporal Cloud using Temporal Cloud UI --->\n\n### Create a Namespace using Temporal Cloud UI\n\n1. Gather the information listed earlier in [Information needed to create a Namespace](#information-needed-to-create-a-namespace).\n1. Go to the Temporal Cloud UI and log in.\n1. On the left side of the window, click **Namespaces**.\n1. On the **Namespaces** page, click **Create Namespace** in the upper-right portion of the window.\n1. On the **Create Namespace** page in **Name**, enter the Namespace Name.\n1. In **Region**, select the region in which to host this Namespace.\n1. In **Retention Period**, specify a value from 1 to 90 days.\n   When choosing this value, consider your needs for Event History versus the cost of maintaining that Event History.\n   Typically, a development Namespace has a short retention period and a production Namespace has a longer retention period.\n   (If you need to change this value later, contact [Temporal Support](https://docs.temporal.io/cloud/how-to-create-a-ticket-for-temporal-support).)\n1. In **Certificate**, paste the CA certificate for this Namespace.\n1. Optional: In **Codec Server**, enter the URL and port number of your Codec Server endpoint.\n   For details, see [Securing your data](/production-readiness/develop#securing-your-data).\n1. Click **Create Namespace**.\n\n<!--- How to create a Namespace in Temporal Cloud using tcld --->\n\n### Create a Namespace using tcld\n\nThis functionality is in development.\n","is_empty":false},{"file_name":"namespaces-delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/namespaces-delete.md","id":"cloud-context/namespaces-delete","title":"How to delete a Namespace in Temporal Cloud","description":"To delete a Namespace in Temporal Cloud, use either Temporal Cloud UI or tcld.","label":"Delete a Namespace","tags":["guide-context"],"ssdi":[],"markdown_content":"\n:::info\n\nTo delete a Namespace, a user must have Namespace Admin [permission](/cloud/#namespace-level-permissions) for that Namespace.\n\n:::\n\n### Delete a Namespace using Temporal Cloud UI\n\n1. Go to the Temporal Cloud UI and log in.\n1. On the left side of the window, select **Namespaces**.\n1. On the **Namespaces** page, select a Namespace Name.\n1. On the Namespace page, select **Edit** in the upper-right portion of the window.\n1. On the **Edit** Namespace page, select **Delete Namespace** in the upper-right portion of the window.\n1. In the **Delete Namespace** dialog, type `DELETE` to confirm the deletion of that Namespace.\n1. Select **Delete**.\n\n### Delete a Namespace using tcld\n\nThis functionality is in development.\n","is_empty":false},{"file_name":"namespaces-intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/namespaces-intro.md","id":"cloud-context/namespaces-intro","title":"How to manage Namespaces in Temporal Cloud","description":"You can create and manage Namespaces from your Temporal Cloud UI.","label":"Manage Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Namespace is a unit of isolation within the Temporal Platform.\n\n- [Create a Namespace](#create-a-namespace)\n- [Access a Namespace](#access-a-namespace)\n- [Manage Namespaces](#manage-namespaces)\n- [Delete a Namespace](#delete-a-namespace)\n","is_empty":false},{"file_name":"namespaces-manage.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/namespaces-manage.md","id":"cloud-context/namespaces-manage","title":"How to manage Namespaces in Temporal Cloud","description":"To manage Namespaces in Temporal Cloud, use either Temporal Cloud UI or tcld.","label":"Manage Namespaces","tags":["how-to"],"ssdi":[],"markdown_content":"\n<!--- How to manage Namespaces in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage Namespaces in Temporal Cloud using Temporal Cloud UI\n\nTo list Namespaces:\n\n- On the left side of the window, select **Namespaces**.\n\nTo edit a Namespace (including custom Search Attributes, certificates, certificate filters, Codec Server endpoint, permissions, and users), find the Namespace and do either of the following:\n\n- On the right end of the Namespace row, select the three vertical dots (⋮). Click **Edit**.\n- Select the Namespace name. In the top-right portion of the page, select **Edit**.\n\nOn the **Edit** page, you can do the following:\n\n- Add a [custom Search Attribute](/visibility#custom-search-attributes).\n- [Manage CA certificates](/cloud/how-to-manage-certificates-in-temporal-cloud).\n- [Manage certificate filters](/cloud/how-to-manage-certificates-in-temporal-cloud#manage-certificate-filters-using-temporal-cloud-ui).\n- Set [Codec Server endpoint](/production-readiness/develop#set-your-codec-server-endpoints-with-web-ui-and-cli) for all users on the Namespace.\n  Each user on the Namespace has the option to [override this setting](/production-readiness/develop#web-ui) in their browser.\n- Manage [Namespace-level permissions](/cloud/#namespace-level-permissions).\n- Add users.\n\nTo add a user to a Namespace, scroll to the bottom of the page and select **Add User**.\n\nAfter you make changes, select **Save** in the top-right or bottom-left portion of the page.\n\n<!--- How to manage Namespaces in Temporal Cloud using tcld --->\n\n### Manage Namespaces in Temporal Cloud using tcld\n\nTo list Namespaces and get information about them, use the following [tcld](/cloud/tcld/) commands:\n\n- [tcld namespace list](/cloud/tcld/namespace/list)\n- [tcld namespace get](/cloud/tcld/namespace/get)\n\nTo manage certificates, use the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/index) commands.\nFor more information, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud).\n\nTo manage certificate filters, use the [tcld namespace certificate-filters](/cloud/tcld/namespace/certificate-filters/index) commands.\nFor more information, see [How to manage certificate filters in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud#manage-certificate-filters).\n","is_empty":false},{"file_name":"pricing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/pricing.md","id":"cloud-context/pricing","title":"Temporal Cloud Pricing","description":"Temporal Cloud pricing information.","label":"Pricing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal Cloud is a consumption-based service; you pay only for what you need when you need it. Pricing is flexible, transparent, and predictable, so you know your costs and never pay for unused capacity.\n\nThis page introduces the elements of Temporal Cloud pricing so that you can estimate costs for your implementation. To gain a reliable estimate, [contact our team](https://pages.temporal.io/contact-us).\n\n## Temporal Actions\n\nActions are the fundamental consumption pricing unit in Temporal Cloud. An Action in Temporal occurs as part of an execution of your Workflow. Each time you execute a Temporal Workflow (a Workflow Execution), the associated Actions are collected and ultimately represent the state and progress of your Temporal Application.\n\nFor a deeper description of Actions, see [Action](/cloud#action). You can also [reach out to our team](https://pages.temporal.io/contact-us) to get more information or to help size your number of Actions.\n\nActions are collected and billed monthly for each Namespace. The base rate is $25 per one million Actions, and you are billed only for the prorated amount of Actions you use. If you use fewer than one million Actions per month, your bill for Actions will be less than $25 for that month.\n\n| **Actions per month** | **Cost per 1M (USD)** |\n| --------------------- | --------------------- |\n| Any number            | $25.00 (prorated)     |\n\nAlternatively, Temporal also offers a credit system. Credits provide an additional discount schedule for both billable Actions and storage. Credits do not expire. The following table outlines cost estimates and discount bands for the credits system. Please reach out to the team if you are interested in this option.\n\n| **Actions per month (millions)** | **Cost per 1M (USD)** | **Cost band**       | **Actions per second** |\n| -------------------------------- | --------------------- | ------------------- | ---------------------- |\n| 0 to 299                         | $23.25                | $0–$7,500           | ~115                   |\n| 300 to 1,499                     | $18.80                | $5,640–$28,200      | ~570                   |\n| 1,500 to 7,499                   | $14.10                | $21,150–$105,750    | ~2,860                 |\n| 7,500 to 29,999                  | $10.50                | $78,750–$315,000    | ~11,400                |\n| 30,000 to 149,999                | $7.90                 | $237,000–$1,185,000 | ~57,000                |\n| 150,000 or more                  | $5.90                 | Begins at $885,000  | n/a                    |\n\n## Storage\n\nAn execution of a particular Workflow could exist for a few seconds, a day, month, or even forever. Temporal collects the Event History during this time and dispatches work when necessary. In this context, a Workflow Execution has only two states, open (active) or closed.\n\nStorage costs are measured in gigabyte-hours (GBh) and include charges for active Workflows, \"running\" storage, and the long-term, \"retained\" storage of Event Histories of closed Workflows. These are measured per Namespace.\n\nRunning storage is a measure of the amount of storage used to store active Workflows. When the execution of a Workflow ends, Temporal Cloud stores Event History for a defined Retention Period, for historical use. This is retained storage. Typical uses include compliance, debugging, workload refresh, and business analytics. Both kinds of storage have fixed costs.\n\n| **Storage** | **Cost per GBh** |\n| ----------- | ---------------- |\n| Retained    | $0.00042         |\n| Running     | $0.042           |\n\nIf you purchase Temporal Cloud credits (as outlined earlier), running storage costs are tiered and measured in gigabyte-hours.\n\n| **Running storage** | **Cost per GBh** |\n| ------------------- | ---------------- |\n| Less than 10        | $0.042           |\n| 10 to 39            | $0.031           |\n| 40 to 119           | $0.023           |\n| 120 to 499          | $0.018           |\n| 500 to 1999         | $0.013           |\n| 2000 or more        | $0.010           |\n\n## Support\n\nWith a subscription to Temporal Cloud, you also gain access to our support organization of developer success engineers and solution architects. Our experts assist with a range of work streams from Workflow design reviews to setting up observability to break/fix support with an agreed-upon set of SLAs.\n\nThe members of the Temporal Developer Success team are engineers who are Temporal experts and open source contributors. They're backed by the main contributors to the open source Temporal project. They provide deep knowledge of how Temporal works and how you can optimize your deployment.\n\nThey also investigate your Workflows to optimize their environments and possibly reduce costs associated with Actions and storage. They ensure your instance is performance tuned and help with other ongoing maintenance, like upgrades of the Temporal software and maintenance of the platform.\n\nIf an issue occurs, the team provides support through our [support portal](/cloud/how-to-create-a-ticket-for-temporal-support), [community forum](https://community.temporal.io/), and (with Premium support) a dedicated Slack channel. Temporal offers two levels of support defined by their availability and SLAs.\n\n|                     | **Basic**                                                                                   | **Premium**                                                                            |\n| ------------------- | ------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |\n| Response times      | P0: 1 business hour<br/>P1: 4 business hours<br/>P2: 1 business day<br/>P3: 2 business days | P0: 30 minutes<br/>P1: 1 business hour<br/>P2: 4 business hours<br/>P3: 1 business day |\n| Pricing (per month) | Greater of $200 or 10% monthly usage                                                        | Greater of $2,000 or 10% monthly activity                                              |\n\nBusiness hours for Temporal Support are 0500–1700 Monday–Friday (Pacific Time).\nFor P0 issues, coverage is 24×7.\n\n## SSO and SAML\n\nWe offer single sign-on (SSO) integration using SAML at a monthly fixed fee based on the number of users registered in Temporal Cloud:\n\n| **Users** | **Cost per month** |\n| --------- | ------------------ |\n| 0 to 25   | $200               |\n| 26 to 50  | $300               |\n| 51+       | $500               |\n\n## Pricing estimates\n\nTemporal Cloud employs a consumption-based pricing model that's based on storage and execution, factors that vary from one Workflow to the next. You can estimate the cost of a specific Workflow by running it at a low volume and then using its storage and compute measurements to project your production-scale cost. Our team is happy to [help you estimate the cost](https://pages.temporal.io/contact-us) for your specific workloads.\n\n## Temporal pricing FAQ\n\nQ: What’s the minimum cost to run Temporal Cloud?\n\nA: The Temporal Cloud service is consumption based. You pay only for what you need with no minimum. Basic support has a minimum monthly fee of $200 per month.\n\nQ: How do I pay for Temporal Cloud?\n\nA: Temporal sends a monthly bill based on your consumption. You can pay this bill with a credit card, ACH, wire transfer, or Temporal Credits.\n\nQ: Can I purchase Temporal Cloud through my Amazon, Azure, or Google Cloud Platform marketplace?\n\nA: You can purchase Temporal Cloud credits in the AWS Marketplace. Please contact our team at sales@temporal.io to learn more about our private offer on the AWS Marketplace.\n","is_empty":false},{"file_name":"saml-finish.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/saml-finish.md","id":"cloud-context/saml-finish","title":"How to finish your SAML configuration","description":"To finish your SAML configuration, send us the sign-in URL, X.509 certificate, and IdP domains and then test your connection.","label":"Finish SAML configuration","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAfter you configure SAML with your IdP, we can finish the configuration on our side.\n[Create a support ticket](/cloud/how-to-create-a-ticket-for-temporal-support) that includes the following information:\n\n- The sign-in URL from your application\n- The X.509 SAML sign-in certificate\n- One or more IdP domains to map to the SAML connection\n\nGenerally, the provided IdP domain is the same as the domain for your email address.\nYou can provide multiple IdP domains.\n\nWhen you receive confirmation from us that we have finished configuration, log in to Temporal Cloud.\nThis time, though, enter your email address in **Enterprise identity** and select **Continue**.\nDo not select **Continue with Google** or **Continue with Microsoft**.\nYou will be redirected to the authentication page of your IdP.\n","is_empty":false},{"file_name":"saml-how-to-configure-with-azure-ad.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/saml-how-to-configure-with-azure-ad.md","id":"cloud-context/saml-how-to-configure-with-azure-ad","title":"How to configure SAML with Azure AD","description":"To use Azure AD as your SAML IdP, create an Azure AD Enterprise application.","label":"Configure SAML with Azure AD","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf you want to use the general Microsoft login mechanism, you don't need to set up SAML with Azure AD.\nJust select **Continue with Microsoft** on the Temporal Cloud sign-in page.\n\nTo use Azure AD as your SAML IdP, create an Azure AD Enterprise application.\n\n1. Sign in to the [Microsoft Azure AD portal](https://portal.azure.com/).\n1. On the home page, under **Manage Azure Active Directory**, select **View**.\n1. On the **Overview** page near the top, select **Add > Enterprise application**.\n1. On the **Browse Azure AD Gallery** page near the top, select **Create your own application**.\n1. In the **Create your own application** pane, provide a name for your application (such as `temporal-cloud`) and select **Integrate any other application you don't find in the gallery**.\n1. Select **Save**.\n1. In the **Getting Started** section, select **2. Set up single sign on**.\n1. On the **Single sign-on** page, select **SAML**.\n1. In the **Basic SAML Configuration** section of the **SAML-based Sign-on** page, select **Edit**.\n1. In **Identifier (Entity ID)**, enter the following entity identifier, including your Account Id where indicated:\n\n   ```bash\n   urn:auth0:prod-tmprl:ACCOUNT_ID-saml\n   ```\n\n   A correctly formed entity identifier looks like this:\n\n   ```bash\n   urn:auth0:prod-tmprl:f45a2-saml\n   ```\n\n1. In **Reply URL (Assertion Consumer Service URL)**, enter the following callback URL, including your Account Id where indicated:\n\n   ```bash\n   https://login.tmprl.cloud/login/callback?connection=ACCOUNT_ID-saml\n   ```\n\n   A correctly formed callback URL looks like this:\n\n   ```bash\n   https://login.tmprl.cloud/login/callback?connection=f45a2-saml\n   ```\n\n1. You can leave the other fields blank.\n   Near the top of the pane, select **Save**.\n1. In the **Attributes & Claims** section, select **Edit**.\n1. We require the user's full email address when connecting to Temporal.\n   In the **Required claim** section, set **emailaddress** and **name**.\n   Verify that **Unique User Identifier (NameID)** is set to `user.userprincipalname [nameid-format:emailAddress]`.\n1. Collect information that you need to send to us:\n   - In the **SAML Certificates** section of the **SAML-based Sign-on** page, select the download link for **Certificate (Base64)**.\n   - In the **Set up _APPLICATION_NAME_** section of the **SAML-based Sign-on** page, copy the value of **Login URL**.\n\nTo finish setting up Azure AD as your SAML IdP, see [Finish SAML configuration](#finish-saml-configuration).\n","is_empty":false},{"file_name":"saml-how-to-configure-with-okta.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/saml-how-to-configure-with-okta.md","id":"cloud-context/saml-how-to-configure-with-okta","title":"How to configure SAML with Okta","description":"To use Okta as your SAML IdP, configure a new Okta application integration.","label":"Configure SAML with Okta","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo use Okta as your SAML IdP, configure a new Okta application integration.\n\n1. Sign in to the [Okta Admin Console](https://www.okta.com/login/).\n1. In the left navigation pane, select **Applications > Applications**.\n1. On the **Applications** page, select **Create App Integration**.\n1. In the **Create a new app integration** dialog, select **SAML 2.0** and then select **Next**.\n1. On the **Create SAML Integration** page in the **General Settings** section, provide a name for your application (such as `temporal-cloud`) and then select **Next**.\n1. In the **Configure SAML** section in **Single sign on URL**, enter the following callback URL, including your Account Id where indicated:\n\n   ```bash\n   https://login.tmprl.cloud/login/callback?connection=ACCOUNT_ID-saml\n   ```\n\n   A correctly formed callback URL looks like this:\n\n   ```bash\n   https://login.tmprl.cloud/login/callback?connection=f45a2-saml\n   ```\n1. In **Audience URI (SP Entity ID)**, enter the following entity identifier, including your Account Id where indicated:\n\n   ```bash\n   urn:auth0:prod-tmprl:ACCOUNT_ID-saml\n   ```\n\n   A correctly formed entity identifier looks like this:\n\n   ```bash\n   urn:auth0:prod-tmprl:f45a2-saml\n   ```\n\n1. We require the user's full email address when connecting to Temporal.\n   - In **Name ID format**, select `EmailAddress`.\n   - In **Attribute Statements**, set **email** and **name**.\n1. Select **Next**.\n1. In the **Feedback** section, select **Finish**.\n1. On the **Applications** page, select the name of the application integration you just created.\n1. On the application integration page, select the **Sign On** tab.\n1. Under **SAML Setup**, select **View SAML setup instructions**.\n1. Collect information that you need to send to us:\n   - Copy the IdP settings.\n   - Download the active certificate.\n\nTo finish setting up Okta as your SAML IdP, see the next section, [Finish SAML configuration](#finish-saml-configuration).\n","is_empty":false},{"file_name":"saml-intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/saml-intro.md","id":"cloud-context/saml-intro","title":"How to manage SAML authentication with Temporal Cloud","description":"To authenticate users of your Temporal Cloud account, you can connect an IdP using SAML 2.0.","label":"Manage SAML","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo authenticate the users of your Temporal Cloud account, you can connect an identity provider (IdP) to your account by using Security Assertion Markup Language (SAML) 2.0.\n\n:::info\n\nEnabling this feature adds a charge to your account.\nFor more information, contact your account manager.\n\n:::\n\n## Integrate SAML with your Temporal Cloud account\n\n1. Locate your [Temporal Cloud Account Id](/concepts/what-is-a-cloud-account-id).\n   One way to do so is to sign in to Temporal Cloud and find your [Namespace Id](/concepts/what-is-a-cloud-namespace-id).\n   The Account Id is the five or six characters following the period (.), such as `f45a2`.\n   You will need the Account Id to construct your callback URL and your entity identifier.\n1. Configure SAML with your IdP by following one of these sets of instructions:\n   - [Microsoft Azure Active Directory (Azure AD)](#configure-saml-with-azure-ad)\n   - [Okta](#configure-saml-with-okta)\n1. [Share your connection information with us and test your connection.](#finish-saml-configuration)\n","is_empty":false},{"file_name":"upgrade-policy-for-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/upgrade-policy-for-temporal-cloud.md","id":"cloud-context/upgrade-policy-for-temporal-cloud","title":"What is the upgrade policy for Temporal Cloud?","description":"Basic upgrade policy for customers of Temporal Cloud","label":"Upgrade policy","ssdi":[],"markdown_content":"\nAll customers will automatically be upgraded to the latest minor version.\n\nMaintenance support, for major versions, will be provided for at least 18 months after a GA release, and there will be at least 6 months' notice before EOL/deprecating support.\n\nThis versioning policy is intended to serve as a minimum set of guidelines for customers who rely on us for their critical business operations.\nIf you have any further questions, please do not hesitate to reach out via community or customer channels.\n","is_empty":false},{"file_name":"users-invite.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/users-invite.md","id":"cloud-context/users-invite","title":"Invite users","description":"Assign Roles and Namespace permissions, and send invites","label":"Invite users","tags":["guide-context"],"ssdi":[],"markdown_content":"\n:::caution\n\nAccess to Temporal Cloud is authorized via single sign-on (SSO), currently limited to Google OAuth.\nThe email addresses of all users who need access to Temporal Cloud must be registered with Google.\n\nIf an email address is not associated with a Google Account, the user must follow the instructions in the [Use an existing email address](https://support.google.com/accounts/answer/27441?hl=en#existingemail) section of [Create a Google Account](https://support.google.com/accounts/answer/27441).\n\n**Important:** Do _not_ create a Gmail account when creating a Google Account.\n\n:::\n\nWhen you create a user in Temporal Cloud, the prospective user receives an email invitation.\nBefore accepting the invitation, the user must be logged in to Google using the email address that received the invitation.\nThe user must then click **Accept Invite** in the message.\nAttempting to log in to Temporal Cloud without first accepting the invite doesn't work.\n\n### Roles and permissions\n\nEach user in Temporal Cloud is assigned a Role.\nEach user can be assigned permissions for individual Namespaces.\n\n- [Account-level Roles](/cloud/#account-level-roles)\n- [Namespace-level permissions](/cloud/#namespace-level-permissions)\n\n<!--- How to invite users in Temporal Cloud using Web UI --->\n\n### Invite users using Web UI\n\n:::info\n\nTo invite users, a user must have the Global Admin account-level [Role](/cloud/#account-level-roles).\n\n:::\n\n1. In Temporal Web UI, click **Settings** in the lower-left portion of the window.\n1. On the **Settings** page, click **Create Users** in the upper-right portion of the window.\n1. On the **Create Users** page in the **Email Addresses** box, type or paste one or more email addresses.\n1. In **Account-Level Role**, select a [Role](/cloud/#account-level-roles).\n   The Role applies to all users whose email addresses appear in **Email Addresses**.\n1. If the account has any Namespaces, they are listed under **Grant access to Namespaces**.\n   To add a permission, select the checkbox next to a Namespace, and then select a [permission](/cloud/#namespace-level-permissions).\n   Repeat as needed.\n1. When all permissions are assigned, click **Send Invite**.\n\nTemporal sends an email message to each user.\nTo join Temporal Cloud, a user must click **Accept Invite** in the message.\n","is_empty":false},{"file_name":"what-are-the-account-level-roles-for-users-in-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/what-are-the-account-level-roles-for-users-in-temporal-cloud.md","id":"cloud-context/what-are-the-account-level-roles-for-users-in-temporal-cloud","title":"What are the account-level Roles for users in Temporal Cloud?","description":"Account-level Roles are Global Admin, Developer, and Read-Only.","label":"Account-level Roles","ssdi":[],"markdown_content":"\nWhen a Global Admin invites a user to join an account, the Global Admin selects one of the following Roles for that user:\n\n- **Global Admin**\n  - Has full administrative permissions across the account, including users and usage\n  - Has Namespace Admin [permissions](/cloud/#namespace-level-permissions) on all [Namespaces](/namespaces) in the account\n- **Developer**\n  - Can create and update Namespaces; has full control over [Workflows](/workflows)\n  - Has Namespace Admin permissions for each Namespace created by that user\n- **Read-Only:** Can only read information\n","is_empty":false},{"file_name":"what-are-the-namespace-level-permissions-for-users-in-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud-context/what-are-the-namespace-level-permissions-for-users-in-temporal-cloud.md","id":"cloud-context/what-are-the-namespace-level-permissions-for-users-in-temporal-cloud","title":"What are the Namespace-level permissions for users in Temporal Cloud?","description":"Namespace-level permissions are Namespace Admin, Write, and Read-Only.","label":"Namespace-level permissions","ssdi":[],"markdown_content":"\nA [Global Admin](/cloud/#account-level-roles) can assign permissions for any [Namespace](/namespaces) in an account.\nA Developer can assign permissions for a Namespace they create.\n\nFor a Namespace, a user can have one of the following permissions:\n\n- **Namespace Admin:** Can [create](/cloud/how-to-manage-namespaces-in-temporal-cloud#create-a-namespace) and [edit Namespaces](/cloud/how-to-manage-namespaces-in-temporal-cloud#manage-namespaces); can create, rename, update, and delete [Workflows](/workflows)\n- **Write:** Can create, rename, update, and delete Workflows within the Namespace\n- **Read-Only:** Can only read information from the Namespace\n","is_empty":false},{"file_name":"tcld/how-to-install-tcld.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/how-to-install-tcld.md","id":"cloud/tcld/how-to-install-tcld","title":"How to install tcld","description":"You can install tcld by using Homebrew or building from source.","label":"Install tcld","tags":["operation-guide","tcld"],"ssdi":[],"markdown_content":"\nYou can install [tcld](/cloud/tcld) in two ways.\n\n### Install tcld by using Homebrew\n\n```bash\nbrew install temporalio/brew/tcld\n```\n\n### Build tcld from source\n\n1. Verify that you have Go 1.18 or later installed.\n\n   ```bash\n   go version\n   ```\n\n   If Go 1.18 or later is not installed, follow the [Download and install](https://go.dev/doc/install) instructions on the Go website.\n\n1. Clone the tcld repository and run make.\n\n   ```bash\n   git clone https://github.com/temporalio/tcld.git\n   cd tcld\n   make\n   ```\n\n1. Copy the tcld executable to any directory that appears in the PATH environment variable, such as `/usr/local/bin`.\n\n   ```bash\n   cp tcld /usr/local/bin/tcld\n   ```\n\n1. Verify that tcld is installed.\n\n   ```bash\n   tcld version\n   ```\n","is_empty":false},{"file_name":"tcld/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/index.md","id":"cloud/tcld/index","title":"What is tcld?","description":"tcld is a command-line tool that you can use to interact with Temporal Cloud.","label":"tcld CLI","tags":["operation-guide","tcld"],"ssdi":[],"markdown_content":"\nThe Temporal Cloud CLI (tcld) is a command-line tool that you can use to interact with Temporal Cloud.\n\n- [How to install tcld](/cloud/tcld/how-to-install-tcld)\n\n### tcld commands\n\n- [tcld account](/cloud/tcld/account)\n- [tcld login](/cloud/tcld/login)\n- [tcld logout](/cloud/tcld/logout)\n- [tcld namespace](/cloud/tcld/namespace)\n- [tcld request](/cloud/tcld/request)\n- [tcld user](/cloud/tcld/user)\n- [tcld version](/cloud/tcld/version)\n\n### Global modifiers\n\n#### `--auto_confirm`\n\nAutomatically confirm all prompts.\n\nYou can specify the value for this modifier by setting the AUTO_CONFIRM environment variable.\nThe default value is `false`.\n","is_empty":false},{"file_name":"tcld/login.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/login.md","id":"cloud/tcld/login","title":"tcld login","description":"How to log in to Temporal Cloud using tcld.","label":"login","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld login` command logs in a user to Temporal Cloud.\n\nFollow instructions in the browser to log in to your Temporal account.\n\nAlias: `l`\n\n`tcld login`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/logout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/logout.md","id":"cloud/tcld/logout","title":"tcld logout","description":"How to log out of Temporal Cloud using tcld.","label":"logout","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld logout` command logs a user out of Temporal Cloud.\n\nAlias: `lo`\n\n`tcld logout`\n\nThe following modifier controls the behavior of the command.\n\n##### `--disable-pop-up`\n\nDisables a browser pop-up if set to `true`. The default value is `false`.\n","is_empty":false},{"file_name":"tcld/version.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/version.md","id":"cloud/tcld/version","title":"tcld version","description":"How to get version information about tcld.","label":"version","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld version` command gets version information about tcld.\n\nAlias: `v`\n\n`tcld version`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/user/delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/user/delete.md","id":"cloud/tcld/user/delete","title":"tcld user delete","description":"How to delete users in Temporal Cloud using tcld.","label":"delete","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld user delete` command deletes the specified user in Temporal Cloud.\nYou must set either `--user-email` or `--user-id` to specify the user to be deleted.\n\nAlias: `d`\n\nThe following modifiers control the behavior of the command.\n\n### `--user-email`\n\nSpecify the email address of the user to delete.\n\n**Example**\n\n```command\ntcld user delete --user-email <test@example.com>\n```\n\n### `--user-id`\n\nSpecify the user identifier of the user to delete.\n\n**Example**\n\n```command\ntcld user delete --user-id <test-user-id>\n```\n\n### `--request-id`\n\nThe request identifier to use for the asynchronous operation.\n\nIf not set, the server assigns an identifier.\n\nAlias: `-r`\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from.\nIf not specified, the latest version is used.\n\nAlias: `-v`\n","is_empty":false},{"file_name":"tcld/user/get.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/user/get.md","id":"cloud/tcld/user/get","title":"tcld user get","description":"How to get user information in Temporal Cloud using tcld.","label":"get","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld user get` command gets information about the specified user in Temporal Cloud.\nYou must set either `--user-email` or `--user-id`.\n\nAlias: `g`\n\nThe following modifiers control the behavior of the command.\n\n### `--user-email`\n\nSpecify the email address of the user to get information about.\n\n**Example**\n\n```command\ntcld user delete --user-email <test@example.com>\n```\n\n### `--user-id`\n\nSpecify the user identifier of the user to get information about.\n\n**Example**\n\n```command\ntcld user delete --user-id <test-user-id>\n```\n","is_empty":false},{"file_name":"tcld/user/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/user/index.md","id":"cloud/tcld/user/index","title":"tcld user","description":"How to manage users in Temporal Cloud using tcld.","label":"user","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld user` commands manage users in Temporal Cloud.\n\nAlias: `u`\n\n- [tcld user delete](/cloud/tcld/user/delete)\n- [tcld user get](/cloud/tcld/user/get)\n- [tcld user invite](/cloud/tcld/user/invite)\n- [tcld user list](/cloud/tcld/user/list)\n- [tcld user resend-invite](/cloud/tcld/user/resend-invite)\n- [tcld user set-account-role](/cloud/tcld/user/set-account-role)\n- [tcld user set-namespace-permissions](/cloud/tcld/user/set-namespace-permissions)\n","is_empty":false},{"file_name":"tcld/user/invite.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/user/invite.md","id":"cloud/tcld/user/invite","title":"tcld user invite","description":"How to invite users to join Temporal Cloud using tcld.","label":"invite","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace invite` command invites the specified user to join Temporal Cloud.\n\nAlias: `i`\n\nThe following modifiers control the behavior of the command.\n\n### `--user-email`\n\n_Required modifier_\n\nSpecify the email address of the user to be invited.\nYou can supply this modifier multiple times to invite multiple users in a single request.\n\nAlias: `-e`\n\n### `--account-role`\n\n_Required modifier_\n\nSpecify the [account-level Role](/cloud/#account-level-roles) for the invited user.\n\nAvailable account roles: `admin` | `developer` | `read`.\n\nAlias: `--ar`\n\n### `--namespace-permission`\n\nSpecify the [Namespace-level permissions](/cloud/#namespace-level-permissions) for the invited user.\nYou can supply this modifier multiple times to set multiple Namespace permissions in a single request.\n\nEach value must be in the format of `namespace=permission-type`.\n\nAvailable namespace permissions: `Admin` | `Write` | `Read`.\n\nAlias: `-p`\n\n### `--request-id`\n\nThe request identifier to use for the asynchronous operation.\n\nIf not set, the server assigns an identifier.\n\nAlias: `-r`\n\n```command\ntcld user invite --user-email <test@example.com> --account-role developer --namespace-permission ns1=Admin --namespace-permission ns2=Write --request-id <123456>\n```\n","is_empty":false},{"file_name":"tcld/user/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/user/list.md","id":"cloud/tcld/user/list","title":"tcld user list","description":"How to list users in Temporal Cloud using tcld.","label":"list","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld user list` command returns a paginated list of users in Temporal Cloud.\n\nAlias: `l`\n\n**Example**\n\n```command\ntcld user list\n```\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nList users that have permissions to the Namespace.\n\nAlias: `-n`\n\n**Example**\n\n```command\ntcld user list --namespace <namespace_id>\n```\n\n### `--page-token`\n\nPage token for paging list users request.\n\nAlias: `-p`\n\n### `--page-size`\n\nPage size for paging list users request.\n\nDefaults to 10.\n\nAlias: `-s`\n","is_empty":false},{"file_name":"tcld/user/resend-invite.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/user/resend-invite.md","id":"cloud/tcld/user/resend-invite","title":"tcld user resend-invite","description":"How to resend an invitation to a user in Temporal Cloud using tcld.","label":"resend-invite","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld user resend-invite` command resends an invitation to the specified user in Temporal Cloud.\nYou must set either `--user-email` or `--user-id` to specify the user to receive another invitation.\n\nAlias: `ri`\n\nThe following modifiers control the behavior of the command.\n\n### `--user-email`\n\nSpecify the email address of the user to resend an invitation to.\n\n**Example**\n\n```bash\ntcld user resend-invite --user-email <test@example.com>\n```\n\n### `--user-id`\n\nSpecify the user identifier of the user to resend an invitation to.\n\n**Example**\n\n```bash\ntcld user resend-invite --user-id <test-user-id>\n```\n\n### `--request-id`\n\nThe request identifier to use for the asynchronous operation.\n\nIf not set, the server assigns an identifier.\n\nAlias: `-r`\n","is_empty":false},{"file_name":"tcld/user/set-account-role.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/user/set-account-role.md","id":"cloud/tcld/user/set-account-role","title":"tcld user set-account-role","description":"How to set an account-level Role for a user in Temporal Cloud using tcld.","label":"set-account-role","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld user set-account-role` command sets an [account-level Role](/cloud/#account-level-roles) for the specified user in Temporal Cloud.\nYou must set either `--user-email` or `--user-id`.\n\nAlias: `ri`\n\nThe following modifiers control the behavior of the command.\n\n### `--account-role`\n\n_Required modifier_\n\nSpecify the account-level Role to assign to the user.\n\nAvailable account roles: `admin` | `developer` | `read`.\n\nAlias: `-ar`\n\n### `--user-email`\n\nSpecify the email address of the user to assign an account-level Role to.\n\nAlias: `-e`\n\n**Example**\n\n```command\ntcld user set-account-role --user-email <test@example.com> --account-role Developer\n```\n\n### `--user-id`\n\nSpecify the user identifier of the user to assign an account-level Role to.\n\nAlias: `--id`\n\n**Example**\n\n```command\ntcld user set-account-role --user-id <test-user-id> --account-role Developer\n```\n\n### `--request-id`\n\nThe request identifier to use for the asynchronous operation.\n\nIf not set, the server assigns an identifier.\n\nAlias: `-r`\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to update from.\nIf not specified, the latest version is used.\n\nAlias: `-v`\n","is_empty":false},{"file_name":"tcld/user/set-namespace-permissions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/user/set-namespace-permissions.md","id":"cloud/tcld/user/set-namespace-permissions","title":"tcld user set-namespace-permissions","description":"How to set Namespace-level permissions for a user in Temporal Cloud using tcld.","label":"set-namespace-permissions","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld user set-namespace-permissions` command sets [Namespace-level permissions](/cloud/#namespace-level-permissions) for a specified user in Temporal Cloud.\nYou must set either `--user-email` or `--user-id`.\n\nAlias: `snp`\n\nThe following modifiers control the behavior of the command.\n\n### `--user-email`\n\nSpecify the email address of the user to assign Namespace-level permissions to.\n\n**Example**\n\n```command\ntcld user set-namespace-permissions --user-email <test@example.com>\n```\n\n### `--user-id`\n\nSpecify the user identifier of the user to assign Namespace-level permissions to.\n\n**Example**\n\n```command\ntcld user set-namespace-permissions --user-id <test-user-id>\n```\n\n### `--request-id`\n\nThe request identifier to use to assign Namespace-level permissions to.\n\nIf not set, the server assigns an identifier.\n\nAlias: `-r`\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to assign Namespace-level permissions to.\nIf not specified, the latest version is used.\n\nAlias: `-v`\n\n### `--namespace-permission`\n\nSpecify the [Namespace-level permissions](/cloud/#namespace-level-permissions) for the invited user.\nYou can supply this modifier multiple times to set multiple Namespace permissions in a single request.\n\nEach value must be in the format of `namespace=permission-type`.\n\nAvailable namespace permissions: `Admin` | `Write` | `Read`.\n\nAlias: `-p`\n","is_empty":false},{"file_name":"tcld/request/get.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/request/get.md","id":"cloud/tcld/request/get","title":"tcld request get","description":"How to get the status of an asynchronous request in Temporal Cloud using tcld.","label":"get","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld request get` command gets the status of the specified request in Temporal Cloud.\n\n`tcld request get --request-id <request_id>`\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace get --namespace <namespace_id> --request-id <request_id>\n```\n\n### `--request`\n\n_Required modifier_\n\nSpecify a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace get --request-id <request_id>\n```\n","is_empty":false},{"file_name":"tcld/request/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/request/index.md","id":"cloud/tcld/request/index","title":"tcld request","description":"How to manage asynchronous requests in Temporal Cloud using tcld.","label":"request","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld request` commands manage asynchronous requests in Temporal Cloud.\n\nAlias: `r`\n\n- [tcld request get](/cloud/tcld/request/get)\n","is_empty":false},{"file_name":"tcld/namespace/create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/create.md","id":"cloud/tcld/namespace/create","title":"tcld namespace create","description":"How to create information about a Namespace in Temporal Cloud using tcld.","label":"create","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace create` command creates a Temporal [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `c`\n\n`tcld namespace create`\n\nThe following modifiers control the behavior of the command.\n\n### `--request-id`\n\nThe request identifier to use for the asynchronous operation.\nIf not set, the server assigns an identifier.\n\nAlias: `-r`\n\n### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nA base64-encoded CA certificate.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n### `--namespace`\n\n_Required modifier_\n\nSpecify the name of the Namespace to create.\n\nAlias: `-n`\n\n### `--region`\n\n_Required modifier_\n\nThe region to create the Namespace in.\n\nValid options: `ap-northeast-1` | `ap-southeast-1` | `ap-southeast-2` | `ca-central-1` | `eu-central-1` | `eu-west-1` | `eu-west-2` | `us-east-1` | `us-west-2`\n\nAlias: `--re`\n\n### `--retention-days`\n\nThe number of days that data about closed Workflow Executions will be retained (default: 30).\n\nAlias: `--rd`\n\n### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nA path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `--cf`\n\n### `--certificate-filter-file`\n\n_Required modifier unless `--certificate-filter-input` is specified_\n\nPath to a JSON file that defines the certificate filters to be applied to the Namespace.\nThe specified filters replace any existing filters.\n\nSample JSON: `{ \"filters\": [ { \"commonName\": \"test1\" } ] }`\n\nIf both `--certificate-filter-file` and `--certificate-filter-input` are specified, the command returns an error.\n\nAlias: `--cff`\n\n### `--certificate-filter-input`\n\n_Required modifier unless `--certificate-filter-file` is specified_\n\nA JSON string that defines the certificate filters to be applied to the Namespace.\nThe specified filters replace any existing filters.\n\nSample JSON: `{ \"filters\": [ { \"commonName\": \"test1\" } ] }`\n\nIf both `--certificate-filter-input` and `--certificate-filter-file` are specified, the command returns an error.\n\nAlias: `--cfi`\n\n### `--search-attribute`\n\n_Required modifier; can be specified more than once_\n\nA custom Search Attribute in the form `_name_=_type_`.\n\nValid values for _type_: `Bool` | `Datetime` | `Double` | `Int` | `Keyword` | `Text`\n\nAlias: `--sa`\n\n### `--user-namespace-permission`\n\n_Can be specified more than once_\n\nA [Namespace-level permission](/cloud/#namespace-level-permissions) for a user in the form `_email_=_permission_`.\n\nValid values for _permission_: `Admin` | `Write` | `Read`\n\nAlias: `-p`\n\n**Example**\n\n```bash\ntcld namespace create --namespace <namespace_id> --region us-west-2 --retention-days 60 --certificate-filter-input '{\"filters\": [{\"commonName\": \"test1\"}]}' --user-namespace-permission \"user@example.com=Admin\" --search-attribute \"customer_id=Int\" --search-attribute \"customer_name=Text\"\n```\n","is_empty":false},{"file_name":"tcld/namespace/delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/delete.md","id":"cloud/tcld/namespace/delete","title":"tcld namespace delete","description":"How to delete a Namespace in Temporal Cloud using tcld.","label":"delete","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace delete` command deletes the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `d`\n\n`tcld namespace delete`\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\n_Required modifier_\n\nSpecify the Namespace hosted on Temporal Cloud to be deleted.\n\nAlias: `-n`\n\n### `--request-id`\n\nThe request identifier to use for the asynchronous operation.\nIf not set, the server assigns an identifier.\n\nAlias: `-r`\n\n### `--resource-version`\n\nA resource version (ETag) to update from.\nIf not set, the CLI uses the latest.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace delete --namespace <namespace_id>\n```\n","is_empty":false},{"file_name":"tcld/namespace/get.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/get.md","id":"cloud/tcld/namespace/get","title":"tcld namespace get","description":"How to get information about a Namespace in Temporal Cloud using tcld.","label":"get","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace get` command gets information about the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `g`\n\n`tcld namespace get`\n\nThe following modifier controls the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace get --namespace <namespace_id>\n```\n","is_empty":false},{"file_name":"tcld/namespace/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/index.md","id":"cloud/tcld/namespace/index","title":"tcld namespace","description":"How to operate Namespaces in Temporal Cloud using tcld.","label":"namespace","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace` commands enable [Namespace](/concepts/what-is-a-namespace) operations in Temporal Cloud.\n\nAlias: `n`\n\n- [tcld namespace create](/cloud/tcld/namespace/create)\n- [tcld namespace delete](/cloud/tcld/namespace/delete)\n- [tcld namespace get](/cloud/tcld/namespace/get)\n- [tcld namespace list](/cloud/tcld/namespace/list)\n- [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/index)\n- [tcld namespace certificate-filters](/cloud/tcld/namespace/certificate-filters/index)\n- [tcld namespace search-attributes](/cloud/tcld/namespace/search-attributes/index)\n- [tcld namespace retention](/cloud/tcld/namespace/retention/index)\n","is_empty":false},{"file_name":"tcld/namespace/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/list.md","id":"cloud/tcld/namespace/list","title":"tcld namespace list","description":"How to list all Namespaces in Temporal Cloud using tcld.","label":"list","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace list` command lists all [Namespaces](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `l`\n\n`tcld namespace list`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/namespace/search-attributes/add.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/search-attributes/add.md","id":"cloud/tcld/namespace/search-attributes/add","title":"tcld namespace search-attributes add","description":"How to add custom Search Attributes to a Namespace in Temporal Cloud using tcld.","label":"add","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace search-attributes add` command adds custom [Search Attributes](/concepts/what-is-a-search-attribute) to a Namespace in Temporal Cloud.\n\n`tcld namespace search-attributes add --search-attribute <value>`\n\nAlias: `a`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --namespace <namespace_id> --search-attribute <value>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --request-id <request_id> --search-attribute <value>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --resource-version <etag> --search-attribute <value>\n```\n\n#### `--search-attribute`\n\n_Required modifier; can be specified more than once_\n\nSpecify a custom Search Attribute in the form \"_name_=_type_\". Valid values for _type_ are as follows:\n\n- Bool\n- Datetime\n- Double\n- Int\n- Keyword\n- Text\n\nAlias: `--sa`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --search-attribute \"YourSearchAttribute1=Text\" --search-attribute \"YourSearchAttribute2=Double\"\n```\n","is_empty":false},{"file_name":"tcld/namespace/search-attributes/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/search-attributes/index.md","id":"cloud/tcld/namespace/search-attributes/index","title":"tcld namespace search-attributes","description":"How to manage Search Attributes of a Namespace in Temporal Cloud using tcld.","label":"search-attributes","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace search-attributes` commands manage [Search Attributes](/concepts/what-is-a-search-attribute) of the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `sa`\n\n- [tcld namespace search-attributes add](/cloud/tcld/namespace/search-attributes/add)\n- [tcld namespace search-attributes rename](/cloud/tcld/namespace/search-attributes/rename)\n","is_empty":false},{"file_name":"tcld/namespace/search-attributes/rename.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/search-attributes/rename.md","id":"cloud/tcld/namespace/search-attributes/rename","title":"tcld namespace search-attributes rename","description":"How to rename an existing custom Search Attribute in Temporal Cloud using tcld.","label":"rename","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace search-attributes rename` command renames a custom [Search Attribute](/concepts/what-is-a-search-attribute) in Temporal Cloud.\n\n`tcld namespace search-attributes rename --existing-name <value> --new-name <value>`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --namespace <namespace_id> --existing-name <value> --new-name <value>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --request-id <request_id> --existing-name <value> --new-name <value>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --resource-version <etag> --existing-name <value> --new-name <value>\n```\n\n#### `--existing-name`\n\n_Required modifier_\n\nSpecify the name of an existing Search Attribute.\n\nAlias: `--en`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --existing-name <value> --new-name <value>\n```\n\n#### `--new-name`\n\n_Required modifier_\n\nSpecify a new name for the Search Attribute.\n\nAlias: `--nn`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --existing-name <value> --new-name <value>\n```\n","is_empty":false},{"file_name":"tcld/namespace/retention/get.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/retention/get.md","id":"cloud/tcld/namespace/retention/get","title":"tcld namespace retention get","description":"How to retrieve the length of time a closed Workflows will be preserved before deletion for a Namespace in Temporal Cloud using tcld.","label":"get","tags":["tcld"],"ssdi":[],"markdown_content":"\nRetrieve the length of time (in days) a closed Workflow will be preserved before deletion for the specified Namespace.\n\nAlias: `g`\n\nThe following modifier controls the behavior of the command.\n\n#### `--namespace`\n\n_Required modifier_\n\nSpecify a Namespace hosted on Temporal Cloud.\nIf not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace retention get --namespace <namespace_id>\n```\n","is_empty":false},{"file_name":"tcld/namespace/retention/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/retention/index.md","id":"cloud/tcld/namespace/retention/index","title":"tcld namespace retention","description":"How to manage the length of time a closed Workflow is preserved before deletion.","label":"retention","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace retention` commands manage the length of time (in days) a closed Workflow is preserved before deletion for a given Namespace in Temporal Cloud.\n\nAlias: `r`\n\n- [tcld namespace retention get](/cloud/tcld/namespace/retention/get)\n- [tcld namespace retention set](/cloud/tcld/namespace/retention/set)\n","is_empty":false},{"file_name":"tcld/namespace/retention/set.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/retention/set.md","id":"cloud/tcld/namespace/retention/set","title":"tcld namespace retention set","description":"How to set the length of time a closed Workflow will be preserved before deletion for a Namespace in Temporal Cloud using tcld.","label":"set","tags":["tcld"],"ssdi":[],"markdown_content":"\nSet the length of time (in days) a closed Workflow will be preserved before deletion for the specified Namespace.\n\nAlias: `s`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\n_Required modifier_\n\nSpecify a Namespace hosted on Temporal Cloud.\nIf not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n#### `--retention-days`\n\n_Required modifier_\n\nSpecify the number of days a closed Workflow will be preserved before deletion.\n\nAlias: `--rd`\n\n**Example**\n\n```bash\ntcld namespace retention set --namespace <namespace_id> --retention-days <retention_days>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/clear.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/certificate-filters/clear.md","id":"cloud/tcld/namespace/certificate-filters/clear","title":"tcld namespace certificate-filters clear","description":"How to clear all certificate filters from a Namespace in Temporal Cloud using tcld.","label":"clear","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace certificate-filters clear` command clears all certificate filters from a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n:::caution\n\nUsing this command allows _any_ client certificate that chains up to a configured CA certificate to connect to the Namespace.\n\n:::\n\n`tcld namespace certificate-filters clear`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters clear --namespace <namespace_id>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters clear --request-id <request_id>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters clear --resource-version <etag>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/export.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/certificate-filters/export.md","id":"cloud/tcld/namespace/certificate-filters/export","title":"tcld namespace certificate-filters export","description":"How to export certificate filters from a Namespace in Temporal Cloud using tcld.","label":"export","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace certificate-filters export` command exports existing certificate filters from a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace certificate-filters export --certificate-filter-file <path>`\n\nAlias: `exp`\n\nThe following modifiers control the behavior of the command.\n\n#### `--certificate-filter-file`\n\nSpecify a path to a JSON file where tcld can export the certificate filters.\n\nAliases: `--file`, `-f`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters export --certificate-filter-file <path>\n```\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --namespace <namespace_id> --certificate-filter-input <json>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --request-id <request_id> --certificate-filter-input <json>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --resource-version <etag> --certificate-filter-input <json>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/import.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/certificate-filters/import.md","id":"cloud/tcld/namespace/certificate-filters/import","title":"tcld namespace certificate-filters import","description":"How to set certificate filters for a Namespace in Temporal Cloud using tcld.","label":"import","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace certificate-filters import` command sets certificate filters for a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace certificate-filters import --certificate-filter-file <path>`\n\nAlias: `imp`\n\nA certificate filter can include any combination (and at least one) of the following:\n\n- `commonName`\n- `organization`\n- `organizationalUnit`\n- `subjectAlternativeName`\n\nThe following modifiers control the behavior of the command.\n\n#### `--certificate-filter-file`\n\n_Required modifier unless `--certificate-filter-input` is specified_\n\nSpecify a path to a JSON file that defines certificate filters to be applied to the Namespace, such as `{ \"filters\": [ { \"commonName\": \"test1\" } ] }`. The specified filters replace any existing filters.\n\nIf both `--certificate-filter-file` and `--certificate-filter-input` are specified, the command returns an error.\n\nAliases: `--file`, `-f`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --certificate-filter-file <path>\n```\n\n#### `--certificate-filter-input`\n\n_Required modifier unless `--certificate-filter-file` is specified_\n\nSpecify a JSON string that defines certificate filters to be applied to the Namespace, such as `{ \"filters\": [ { \"commonName\": \"test1\" } ] }`. The specified filters replace any existing filters.\n\nIf both `--certificate-filter-input` and `--certificate-filter-file` are specified, the command returns an error.\n\nAliases: `--input`, `-i`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --certificate-filter-input <json>\n```\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --namespace <namespace_id> --certificate-filter-input <json>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --request-id <request_id> --certificate-filter-input <json>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --resource-version <etag> --certificate-filter-input <json>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/certificate-filters/index.md","id":"cloud/tcld/namespace/certificate-filters/index","title":"tcld namespace certificate-filters","description":"How to manage certificate filters for a Namespace in Temporal Cloud using tcld.","label":"certificate-filters","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace certificate-filters` commands manage optional certificate filters for the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud. The Namespace can use certificate filters to authorize client certificates based on distinguished name (DN) fields.\n\nAlias: `cf`\n\n- [tcld namespace certificate-filters import](/cloud/tcld/namespace/certificate-filters/import)\n- [tcld namespace certificate-filters export](/cloud/tcld/namespace/certificate-filters/export)\n- [tcld namespace certificate-filters clear](/cloud/tcld/namespace/certificate-filters/clear)\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/add.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/add.md","id":"cloud/tcld/namespace/accepted-client-ca/add","title":"tcld namespace accepted-client-ca add","description":"How to add client CA certificates to a Namespace in Temporal Cloud using tcld.","label":"add","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace accepted-client-ca add` command adds client CA certificates to a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca add --ca-certificate <value>`\n\nAlias: `a`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --namespace <namespace_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/index.md","id":"cloud/tcld/namespace/accepted-client-ca/index","title":"tcld namespace accepted-client-ca","description":"How to manage the client CA certificates for a Namespace in Temporal Cloud using tcld.","label":"accepted-client-ca","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace accepted-client-ca` commands manage the client CA certificates of the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud. The certificates are used to verify client connections.\n\n:::important\n\nDo not use a CA certificate that is signed with an insecure signature algorithm, such as SHA-1.\nSuch signatures will be rejected.\nExisting CA certificates that use SHA-1 can stop working without warning.\n\nFor more information about the vulnerabilities of SHA-1, see [SHAttered](https://shattered.io/).\n\n:::\n\nAlias: `ca`\n\n- [tcld namespace accepted-client-ca add](/cloud/tcld/namespace/accepted-client-ca/add)\n- [tcld namespace accepted-client-ca list](/cloud/tcld/namespace/accepted-client-ca/list)\n- [tcld namespace accepted-client-ca set](/cloud/tcld/namespace/accepted-client-ca/set)\n- [tcld namespace accepted-client-ca remove](/cloud/tcld/namespace/accepted-client-ca/remove)\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/list.md","id":"cloud/tcld/namespace/accepted-client-ca/list","title":"tcld namespace accepted-client-ca list","description":"How to list the client CA certificates for a Namespace in Temporal Cloud using tcld.","label":"list","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace accepted-client-ca list` command lists the client CA certificates that are currently configured for a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca list`\n\nAlias: `l`\n\nThe following modifier controls the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca list --namespace <namespace_id>\n```\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/remove.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/remove.md","id":"cloud/tcld/namespace/accepted-client-ca/remove","title":"tcld namespace accepted-client-ca remove","description":"How to remove client CA certificates from a Namespace in Temporal Cloud using tcld.","label":"remove","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace accepted-client-ca remove` command removes client CA certificates from a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca remove --ca-certificate <value>`\n\nAlias: `r`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --namespace <namespace_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate-file` is specified_\n\nSpecify the base64-encoded string of a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate` and `--ca-certificate-file` are ignored.\n\nIf `--ca-certificate-file` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate-file` and `--ca-certificate` are ignored.\n\nIf `--ca-certificate` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --ca-certificate-file <path>\n```\n\n#### `--ca-certificate-fingerprint`\n\n_Required modifier unless `--ca-certificate` or `--ca-certificate-file` is specified_\n\nSpecify the fingerprint of a CA certificate.\n\nIf `--ca-certificate`, `--ca-certificate-file`, or both are also specified, they are ignored.\n\nAlias: `--fp`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --ca-certificate-fingerprint <fingerprint>\n```\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/set.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/set.md","id":"cloud/tcld/namespace/accepted-client-ca/set","title":"tcld namespace accepted-client-ca set","description":"How to set the client CA certificates for a Namespace in Temporal Cloud using tcld.","label":"set","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld namespace accepted-client-ca set` command sets the client CA certificates for a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca set --ca-certificate <value>`\n\nAlias: `s`\n\n<!--- How to rollover accepted client CA certificates in Temporal Cloud using tcld --->\n\nWhen updating CA certificates, it's important to follow a rollover process.\nDoing so enables your Namespace to serve both CA certificates for a period of time until traffic to your old CA certificate ceases.\n\n1. Create a single file that contains both your old and new CA certificate PEM blocks.\n   Just concatenate the PEM blocks on adjacent lines.\n\n   ```\n   -----BEGIN CERTIFICATE-----\n   ... old CA cert ...\n   -----END CERTIFICATE-----\n   -----BEGIN CERTIFICATE-----\n   ... new CA cert ...\n   -----END CERTIFICATE-----\n   ```\n\n1. Run the `tcld namespace accepted-client-ca set` command with the CA certificate bundle file.\n\n   ```bash\n   tcld namespace accepted-client-ca set --ca-certificate-file <path>\n   ```\n\n1. Monitor traffic to your old certificate until it ceases.\n\n1. Create another file that contains only the new CA certificate.\n\n1. Run the `tcld namespace accepted-client-ca set` command again with the updated CA certificate bundle file.\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --namespace <namespace_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"tcld/account/get.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/get.md","id":"cloud/tcld/account/get","title":"tcld account get","description":"How to get information about an account in Temporal Cloud using tcld.","label":"get","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account get` command gets information about the Temporal Cloud account you are logged into.\n\nAlias: `g`\n\n`tcld account get`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/account/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/index.md","id":"cloud/tcld/account/index","title":"tcld account","description":"How to manage accounts in Temporal Cloud using tcld.","label":"account","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account` commands manage accounts in Temporal Cloud.\n\nAlias: `a`\n\n- [tcld account get](/cloud/tcld/account/get)\n- [tcld account metrics](/cloud/tcld/account/metrics/index)\n","is_empty":false},{"file_name":"tcld/account/metrics/disable.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/metrics/disable.md","id":"cloud/tcld/account/metrics/disable","title":"tcld account metrics disable","description":"How to disable the metrics endpoint for a Temporal Cloud account using tcld.","label":"disable","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account metrics disable` command disables the metrics endpoint for the Temporal Cloud account that is currently logged in.\n\n`tcld account metrics disable`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/account/metrics/enable.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/metrics/enable.md","id":"cloud/tcld/account/metrics/enable","title":"tcld account metrics enable","description":"How to enable the metrics endpoint for a Temporal Cloud account using tcld.","label":"enable","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account metrics enable` command enables the metrics endpoint for the Temporal Cloud account that is currently logged in.\n\n:::info\n\nThe end-entity for the metrics endpoint _must_ be configured before the endpoint can be enabled. See the [tcld account metrics accepted-client-ca](/cloud/tcld/account/metrics/accepted-client-ca/index) commands.\n\n:::\n\n`tcld account metrics enable`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/account/metrics/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/metrics/index.md","id":"cloud/tcld/account/metrics/index","title":"tcld account metrics","description":"How to configure the metrics endpoint for a Temporal Cloud account using tcld.","label":"metrics","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account metrics` commands configure the metrics endpoint for the Temporal Cloud account that is currently logged in.\n\nAlias: `m`\n\n- [tcld account metrics enable](/cloud/tcld/account/metrics/enable)\n- [tcld account metrics disable](/cloud/tcld/account/metrics/disable)\n- [tcld account metrics accepted-client-ca](/cloud/tcld/account/metrics/accepted-client-ca/index)\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/add.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/add.md","id":"cloud/tcld/account/metrics/accepted-client-ca/add","title":"tcld account metrics accepted-client-ca add","description":"How to add end-entity certificates to the metrics endpoint of a Temporal Cloud account using tcld.","label":"add","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account metrics accepted-client-ca add` command adds end-entity certificates to the metrics endpoint of a Temporal Cloud account.\n\n:::info\n\nThe end-entity certificates for the metrics endpoint must chain up to the CA certificate used for the account. For more information, see [Certificate requirements](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements).\n\n:::\n\n`tcld account metrics accepted-client-ca add --ca-certificate <value>`\n\nAlias: `a`\n\nThe following modifiers control the behavior of the command.\n\n##### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca add --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n##### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca add --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca add --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca add --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/index.md","id":"cloud/tcld/account/metrics/accepted-client-ca/index","title":"tcld account metrics accepted-client-ca","description":"How to managed the end-entity certificates for the metrics endpoint of a Temporal Cloud account using tcld.","label":"accepted-client-ca","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account metrics accepted-client-ca` commands manage the end-entity certificates for the metrics endpoint of the Temporal Cloud account that is currently logged in.\n\n:::info\n\nThe end-entity certificates for the metrics endpoint must chain up to the CA certificate used for the account. For more information, see [Certificate requirements](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements).\n\n:::\n\nAlias: `ca`\n\n- [tcld account metrics accepted-client-ca add](/cloud/tcld/account/metrics/accepted-client-ca/add)\n- [tcld account metrics accepted-client-ca list](/cloud/tcld/account/metrics/accepted-client-ca/list)\n- [tcld account metrics accepted-client-ca set](/cloud/tcld/account/metrics/accepted-client-ca/set)\n- [tcld account metrics accepted-client-ca remove](/cloud/tcld/account/metrics/accepted-client-ca/remove)\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/list.md","id":"cloud/tcld/account/metrics/accepted-client-ca/list","title":"tcld account metrics accepted-client-ca list","description":"How to list the end-entity certificates for the metrics endpoint of a Temporal Cloud account using tcld.","label":"list","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account metrics accepted-client-ca list` command lists the end-entity certificates that are currently configured for the metrics endpoint of a Temporal Cloud account.\n\n`tcld account metrics accepted-client-ca list`\n\nAlias: `l`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/remove.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/remove.md","id":"cloud/tcld/account/metrics/accepted-client-ca/remove","title":"tcld account metrics accepted-client-ca remove","description":"How to remove end-entity certificates from the metrics endpoint of a Temporal Cloud account using tcld.","label":"remove","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account metrics accepted-client-ca remove` command removes end-entity certificates from the metrics endpoint of a Temporal Cloud account.\n\n`tcld account metrics accepted-client-ca remove --ca-certificate <value>`\n\nAlias: `r`\n\nThe following modifiers control the behavior of the command.\n\n##### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n##### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate` and `--ca-certificate-file` are ignored.\n\nIf `--ca-certificate-file` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate-file` and `--ca-certificate` are ignored.\n\nIf `--ca-certificate` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --ca-certificate-file <path>\n```\n\n##### `--ca-certificate-fingerprint`\n\n_Required modifier unless `--ca-certificate` or `--ca-certificate-file` is specified_\n\nSpecify the fingerprint of a CA certificate.\n\nIf `--ca-certificate`, `--ca-certificate-file`, or both are also specified, they are ignored.\n\nAlias: `--fp`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --ca-certificate-fingerprint <fingerprint>\n```\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/set.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/set.md","id":"cloud/tcld/account/metrics/accepted-client-ca/set","title":"tcld account metrics accepted-client-ca set","description":"How to set the end-entity certificates for the metrics endpoint of a Temporal Cloud account using tcld.","label":"set","tags":["tcld"],"ssdi":[],"markdown_content":"\nThe `tcld account metrics accepted-client-ca set` command sets the end-entity certificates for the metrics endpoint of a Temporal Cloud account.\n\n:::info\n\nThe end-entity certificates for the metrics endpoint must chain up to the CA certificate used for the account. For more information, see [Certificate requirements](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements).\n\n:::\n\n`tcld account metrics accepted-client-ca set --ca-certificate <value>`\n\nAlias: `s`\n\nThe following modifiers control the behavior of the command.\n\n##### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca set --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n##### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca set --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca set --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca set --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"archival.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cluster-ops-context/archival.md","id":"cluster-ops-context/archival","title":"How to use Archival","description":"Archival is a feature that automatically backs up Workflow Execution Event Histories and Visibility data from Temporal Cluster persistence to a custom blob store.","label":"Archival","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Archival](/concepts/what-is-archival) is a feature that automatically backs up Workflow Execution Event Histories and Visibility data from Temporal Cluster persistence to a custom blob store.\n","is_empty":false},{"file_name":"intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cluster-ops-context/intro.md","id":"cluster-ops-context/intro","title":"How to deploy a Temporal Cluster","description":"This guide is a work in progress","label":"Deploy a Temporal Cluster","tags":["guide-context"],"ssdi":[],"markdown_content":"\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete.\nInformation may change at any time.\n\nLegacy production deployment information is available [here](/kb/legacy-oss-prod-deploy)\n\n:::\n","is_empty":false},{"file_name":"manage-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cluster-ops-context/manage-custom-search-attributes.md","id":"cluster-ops-context/manage-custom-search-attributes","title":"Managing custom Search Attributes","description":"You can create custom Search Attributes. On a self-hosted Temporal Cluster, you can remove them; on Temporal Cloud, you can rename them.","label":"Custom Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo manage your custom Search Attributes on Temporal Cloud, use `tcld`.\nWith Temporal Cloud, you can create and rename custom Search Attributes.\n\nTo manage your custom Search Attributes on self-hosted Temporal Clusters, use `tctl`. With self-hosted Temporal Cluster, you can create and remove custom Search Attributes.\nNote that if you use [SQL databases](/clusters/how-to-set-up-visibility-in-a-temporal-cluster) with Temporal Server v1.20 and later, creating a custom Search Attribute creates a mapping with a database field name in the Visibility store `custom_search_attributes` table.\nRemoving a custom Search Attribute removes this mapping with the database field name but does not remove the data.\nIf you remove a custom Search Attribute and add a new one, the new custom Search Attribute might be mapped to the database field of the one that was recently removed.\nThis might cause unexpected results when you use the List API to retrieve results using the new custom Search Attribute.\nThese constraints do not apply if you use Elasticsearch.\n","is_empty":false},{"file_name":"how-to-create-a-custom-archiver.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-create-a-custom-archiver.md","id":"clusters/how-to-create-a-custom-archiver","title":"How to create a custom Archiver","description":"To archive data with a given provider, using the Archival feature, Temporal must have a corresponding Archiver component installed.","label":"Custom Archiver","tags":["how-to"],"ssdi":[],"markdown_content":"\nTo archive data with a given provider, using the [Archival](/concepts/what-is-archival) feature, Temporal must have a corresponding Archiver component installed.\nThe platform does not limit you to the existing providers.\nTo use a provider that is not currently supported, you can create your own Archiver.\n\n#### Create a new package\n\nThe first step is to create a new package for your implementation in [/common/archiver](https://github.com/temporalio/temporal/tree/master/common/archiver).\nCreate a directory in the archiver folder and arrange the structure to look like the following:\n\n```\ntemporal/common/archiver\n  - filestore/                      -- Filestore implementation\n  - provider/\n      - provider.go                 -- Provider of archiver instances\n  - yourImplementation/\n      - historyArchiver.go          -- HistoryArchiver implementation\n      - historyArchiver_test.go     -- Unit tests for HistoryArchiver\n      - visibilityArchiver.go       -- VisibilityArchiver implementations\n      - visibilityArchiver_test.go  -- Unit tests for VisibilityArchiver\n```\n\n#### Archiver interfaces\n\nNext, define objects that implement the [HistoryArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L80) and the [VisibilityArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L121) interfaces.\n\nThe objects should live in `historyArchiver.go` and `visibilityArchiver.go`, respectively.\n\n#### Update provider\n\nUpdate the `GetHistoryArchiver` and `GetVisibilityArchiver` methods of the `archiverProvider` object in the [/common/archiver/provider/provider.go](https://github.com/temporalio/temporal/blob/master/common/archiver/provider/provider.go) file so that it knows how to create an instance of your archiver.\n\n#### Add configs\n\nAdd configs for your archiver to the `config/development.yaml` file and then modify the [HistoryArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L376) and [VisibilityArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L393) structs in `/common/common/config.go` accordingly.\n\n#### Custom archiver FAQ\n\n**If my custom Archive method can automatically be retried by the caller, how can I record and access progress between retries?**\n\nHandle this situation by using `ArchiverOptions`.\nHere is an example:\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n    var progress progress\n    // Check if the feature for recording progress is enabled.\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.LoadProgress(ctx, & prevProgress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n\n    // Your archiver implementation...\n\n    // Record current progress\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.RecordProgress(ctx, progress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n}\n```\n\n**If my `Archive` method encounters an error that is non-retryable, how do I indicate to the caller that it should not retry?**\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n\n    err: = youArchiverImpl()\n\n    if nonRetryableErr(err) {\n        if featureCatalog.NonRetryableError != nil {\n            return featureCatalog.NonRetryableError() // when the caller gets this error type back it will not retry anymore.\n        }\n    }\n}\n```\n\n**How does my history archiver implementation read history?**\n\nThe archiver package provides a utility called [HistoryIterator](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) which is a wrapper of [ExecutionManager](https://github.com/temporalio/temporal/blob/master/common/persistence/dataInterfaces.go#L1014).\n`HistoryIterator` is more simple than the `HistoryManager`, which is available in the BootstrapContainer, so archiver implementations can choose to use it when reading Workflow histories.\nSee the [historyIterator.go](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) file for more details.\nUse the [filestore historyArchiver implementation](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) as an example.\n\n**Should my archiver define its own error types?**\n\nEach archiver is free to define and return its own errors.\nHowever, many common errors that exist between archivers are already defined in [common/archiver/constants.go](https://github.com/temporalio/temporal/blob/master/common/archiver/constants.go).\n\n**Is there a generic query syntax for the visibility archiver?**\n\nCurrently, no.\nBut this is something we plan to do in the future.\nAs for now, try to make your syntax similar to the one used by our advanced list Workflow API.\n\n- [s3store](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store#visibility-query-syntax)\n- [gcloud](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud#visibility-query-syntax)\n","is_empty":false},{"file_name":"how-to-create-custom-search-attribute-keys.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-create-custom-search-attribute-keys.md","id":"clusters/how-to-create-custom-search-attribute-keys","title":"How to create custom Search Attributes","description":"Add custom Search Attributes to your Visibility store using `tctl` for self-hosted Temporal Cluster, and `tcld` for Temporal Cloud.","label":"Create custom Search Attributes","tags":["operation-guide","filtered-lists","visibility"],"ssdi":[],"markdown_content":"\nAdd custom Search Attributes to your Visibility store using `tctl` for a self-hosted Temporal Cluster and `tcld` for Temporal Cloud.\n\nCreating a custom Search Attribute in your Visibility store makes it available to use in your Workflow metadata and [List Filters](/concepts/what-is-a-list-filter).\n\n**On Temporal Cloud**\n\nTo create custom Search Attributes on Temporal Cloud, use [`tcld namespace search-attributes add`](/cloud/tcld/namespace#search-attributes).\nFor example, to add a custom Search Attributes \"CustomSA\" to your Temporal Cloud Namespace \"YourNamespace\", run the following command.\n`tcld namespace search-attributes add --namespace YourNamespace --search-attribute \"CustomSA\"`\n\n**On self-hosted Temporal Cluster**\n\nIf you're self-hosting your Temporal Cluster, verify whether your [Visibility database](/clusters/how-to-set-up-visibility-in-a-temporal-cluster#supported-databases) version supports advanced Visibility features.\n\nTo create custom Search Attributes in your self-hosted Temporal Cluster Visibility store, use `tctl search-attribute create` with `--name` and `--type` modifiers.\n\nFor example, to create a Search Attribute called `CustomSA` of type `Keyword`, run the following command:\n\n`tctl search-attribute create --name CustomSA --type Keyword`\n\nNote that if you use a SQL database with advanced Visibility capabilities, you are required to specify a Namespace when creating a custom Search Attribute.\nFor example: `tctl --ns yournamespace search-attribute create --name CustomSA --type Keyword`\n\nYou can also create multiple custom Search Attributes when you set up your Visibility store.\n\nFor example, the [auto-setup.sh](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) script that is used to set up your local [docker-compose Temporal Cluster](https://github.com/temporalio/docker-compose) creates custom Search Attributes in the Visibility store, as shown in the following code snippet from the script (for SQL databases).\n\n```bash\nadd_custom_search_attributes() {\n    until temporal operator search-attribute list --namespace \"${DEFAULT_NAMESPACE}\"; do\n      echo \"Waiting for namespace cache to refresh...\"\n      sleep 1\n    done\n    echo \"Namespace cache refreshed.\"\n\n    echo \"Adding Custom*Field search attributes.\"\n\n    temporal operator search-attribute create --namespace \"${DEFAULT_NAMESPACE}\" --yes \\\n        --name CustomKeywordField --type Keyword \\\n        --name CustomStringField --type Text \\\n        --name CustomTextField --type Text \\\n        --name CustomIntField --type Int \\\n        --name CustomDatetimeField --type Datetime \\\n        --name CustomDoubleField --type Double \\\n        --name CustomBoolField --type Bool\n}\n```\n\nNote that this script has been updated for Temporal Server v1.20, which requires associating every custom Search Attribute with a Namespace when using a SQL database.\n\nFor Temporal Server v1.19 and earlier, or if using Elasticsearch for advanced Visibility, you can create custom Search Attributes without a Namespace association, as shown in the following example.\n\n```bash\nadd_custom_search_attributes() {\n       echo \"Adding Custom*Field search attributes.\"\n       tctl --auto_confirm admin cluster add-search-attributes \\\n           --name CustomKeywordField --type Keyword \\\n           --name CustomStringField --type Text \\\n           --name CustomTextField --type Text \\\n           --name CustomIntField --type Int \\\n           --name CustomDatetimeField --type Datetime \\\n           --name CustomDoubleField --type Double \\\n           --name CustomBoolField --type Bool\n }\n```\n\nWhen your Visibility store is set up and running, these custom Search Attributes are available to use in your Workflow code.\n","is_empty":false},{"file_name":"how-to-install-temporal-cli.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-install-temporal-cli.md","id":"clusters/how-to-install-temporal-cli","title":"How to install Temporal CLI and run a development server","label":"Run a development server","ssdi":[],"markdown_content":"\nThis section describes how to install the [Temporal CLI](/cli) and run a development Cluster.\nThe local development Cluster comes packaged with the [Temporal Web UI](/web-ui).\n\nFor information on deploying and running a production Cluster, see the [Cluster deployment guide](/cluster-deployment-guide), or sign up for [Temporal Cloud](/cloud) and let us run your production Cluster for you.\n\nTemporal CLI is a tool for interacting with a Temporal Cluster from the command line and it includes a distribution of the Temporal Server and Web UI.\nThis local development Cluster runs as a single process with zero runtime dependencies and it supports persistence to disk and in-memory mode through SQLite.\n\n**Install the Temporal CLI**\n\nChoose one of the following install methods to install the Temporal CLI.\n\n<Tabs>\n<TabItem value=\"macOS\" label=\"macOS\">\n\n- Install the Temporal CLI with Homebrew.\n\n  ```bash\n  brew install temporal\n  ```\n\n- Install the Temporal CLI with cURL.\n\n  ```bash\n  curl -sSf https://temporal.download/cli.sh | sh\n  ```\n\n- Install the Temporal CLI from CDN.\n  1. Select the platform and architecture needed.\n     - <a href=\"https://temporal.download/cli/archive/latest?platform=darwin&arch=amd64\">Download for Darwin amd64</a>\n     - <a href=\"https://temporal.download/cli/archive/latest?platform=darwin&arch=arm64\">Download for Darwin arm64</a>\n  2. Extract the downloaded archive.\n  3. Add the `temporal` binary to your PATH.\n\n</TabItem>\n<TabItem value=\"Linux\" label=\"Linux\">\n\n- Install the Temporal CLI with cURL.\n\n  ```bash\n  curl -sSf https://temporal.download/cli.sh | sh\n  ```\n\n- Install the Temporal CLI from CDN.\n  1. Select the platform and architecture needed.\n     - <a href=\"https://temporal.download/cli/archive/latest?platform=linux&arch=amd64\">Download for Linux amd64</a>\n     - <a href=\"https://temporal.download/cli/archive/latest?platform=linux&arch=arm64\">Download for Linux arm64</a>\n  2. Extract the downloaded archive.\n  3. Add the `temporal` binary to your PATH.\n\n</TabItem>\n<TabItem value=\"Windows\" label=\"Windows\">\n\n- Install the Temporal CLI from CDN.\n  1. Select the platform and architecture needed and download the binary.\n     - <a href=\"https://temporal.download/cli/archive/latest?platform=windows&arch=amd64\">Download for Windows amd64</a>\n     - <a href=\"https://temporal.download/cli/archive/latest?platform=windows&arch=arm64\">Download for Windows arm64</a>\n  2. Extract the downloaded archive.\n  3. Add the `temporal.exe` binary to your PATH.\n\n</TabItem>\n</Tabs>\n\n**Start the Temporal Development Server**\n\nStart the Temporal Development Server by using the `server start-dev` command.\n\n```bash\ntemporal server start-dev\n```\n\nThis command automatically starts the Web UI, creates the default [Namespace](/namespaces), and uses an in-memory database.\n\nThe Temporal Server should be available on `localhost:7233` and the Temporal Web UI should be accessible at [`http://localhost:8233`](http://localhost:8233/).\n\nThe server's startup configuration can be customized using command line options.\nFor a full list of options, run:\n\n```bash\ntemporal server start-dev --help\n```\n","is_empty":false},{"file_name":"how-to-integrate-elasticsearch-into-a-temporal-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster.md","id":"clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster","title":"How to integrate Elasticsearch into a Temporal Cluster","description":"To integrate Elasticsearch with your Temporal Cluster, edit the `persistence` section of your `development.yaml` configuration file and run the index schema setup commands.","label":"Elasticsearch","tags":["operation-guide","filtered-lists","visibility"],"ssdi":["Elasticsearch v8 is supported beginning with Temporal Server version 1.18.0.","Elasticsearch v7.10 is supported beginning with Temporal Server version 1.17.0.","Elasticsearch v6.8 is supported through Temporal Server version 1.17._x_.","Elasticsearch v6.8 and v7.10 are explicitly supported with AWS Elasticsearch."],"markdown_content":"\nYou can integrate Elasticsearch with your Temporal Cluster as your Visibility store.\nWe recommend using Elasticsearch for large-scale operations on the Temporal Cluster.\n\nTo integrate Elasticsearch with your Temporal Cluster, edit the `persistence` section of your `development.yaml` configuration file to add Elasticsearch as the `visibilityStore`, and run the index schema setup commands.\n\n<!-- :::note\n\nThe following steps are needed only if you have a \"plain\" [Temporal Server Docker image](https://hub.docker.com/r/temporalio/server).\n\nIf you operate a Temporal Cluster using our [Helm charts](https://github.com/temporalio/helm-charts) or\n[Docker Compose](https://github.com/temporalio/docker-compose), the Elasticsearch index schema and index are created automatically using the [auto-setup Docker image](https://hub.docker.com/r/temporalio/auto-setup).\n\n::: -->\n\n**Persistence configuration**\n\nSet your Elasticsearch Visibility store name in the `visibilityStore` parameter in your Persistence configuration, and then define the Visibility store configuration under `datastores`.\n\nThe following example shows how to set a Visibility store named `es-visibility` and define the datastore configuration in your Temporal Cluster configuration YAML.\n\n```yaml\npersistence:\n  ...\n  visibilityStore: es-visibility\n  datastores:\n    ...\n    es-visibility: # Define the Elasticsearch datastore connection information under the `es-visibility` key\n      elasticsearch:\n        version: \"v7\"\n        url:\n          scheme: \"http\"\n          host: \"127.0.0.1:9200\"\n        indices:\n          visibility: temporal_visibility_v1_dev\n```\n\n**Index schema and index**\n\nThe following example shows how the [auto-setup.sh](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) script sets up an Elasticsearch Visibility store.\n\n```bash\n#...\n# Elasticsearch\n: \"${ENABLE_ES:=false}\"\n: \"${ES_SCHEME:=http}\"\n: \"${ES_SEEDS:=}\"\n: \"${ES_PORT:=9200}\"\n: \"${ES_USER:=}\"\n: \"${ES_PWD:=}\"\n: \"${ES_VERSION:=v7}\"\n: \"${ES_VIS_INDEX:=temporal_visibility_v1}\"\n: \"${ES_SEC_VIS_INDEX:=}\"\n: \"${ES_SCHEMA_SETUP_TIMEOUT_IN_SECONDS:=0}\"\n#...\n# Validate your ES environment\n#...\n# Wait for ES to start\n#...\n# ES_SERVER is the URL of Elasticsearch server; for example, \"http://localhost:9200\".\nSETTINGS_URL=\"${ES_SERVER}/_cluster/settings\"\nSETTINGS_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/cluster_settings_${ES_VERSION}.json\nTEMPLATE_URL=\"${ES_SERVER}/_template/temporal_visibility_v1_template\"\nSCHEMA_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/index_template_${ES_VERSION}.json\nINDEX_URL=\"${ES_SERVER}/${ES_VIS_INDEX}\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SETTINGS_URL}\" -H \"Content-Type: application/json\" --data-binary \"@${SETTINGS_FILE}\" --write-out \"\\n\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${TEMPLATE_URL}\" -H 'Content-Type: application/json' --data-binary \"@${SCHEMA_FILE}\" --write-out \"\\n\"\ncurl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${INDEX_URL}\" --write-out \"\\n\"\n```\n\n**Elasticsearch privileges**\n\nEnsure that the following privileges are granted for the Elasticsearch Temporal index:\n\n- **Read**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `create`, `index`, `delete`, `read`\n- **Write**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `write`\n- **Custom Search Attributes**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `manage`\n  - [cluster privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-cluster): `monitor` or `manage`.\n","is_empty":false},{"file_name":"how-to-migrate-visibility-database.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-migrate-visibility-database.md","id":"clusters/how-to-migrate-visibility-database","title":"How to migrate Visibility database","description":"To migrate your Visibility database to another database, set up a secondary Visibility to enable Dual Visibility, and update the dynamic configuration in your Cluster to update the Visibility store read and write operations.","label":"Migrating Visibility database","tags":["operation-guide","filtered-lists","visibility"],"ssdi":["Supported beginning with Temporal Server v1.21."],"markdown_content":"\nTo migrate your Visibility database, [set up a secondary Visibility store](/cluster-deployment-guide#set-up-secondary-visibility-store) to enable [Dual Visibility](/concepts/what-is-dual-visibility), and update the dynamic configuration in your Cluster to update the read and write operations for the Visibility store.\n\nDual Visibility setup is optional but useful in gradually migrating your Visibility data to another database.\n\nBefore you begin, verify [supported databases and versions](/cluster-deployment-guide#supported-databases) for a Visibility store.\n\nThe following steps describe how to migrate your Visibility database.\n\nAfter you make any changes to your [Cluster configuration](/concepts/what-is-cluster-configuration), ensure that you restart your services.\n\n#### Set up secondary Visibility store\n\n1. In your Cluster configuration, [add a secondary Visibility store](/references/configuration#secondaryvisibilitystore) to your Visibility setup under the Persistence configuration.\n\n   Example: To migrate from Cassandra to Elasticsearch, add Elasticsearch as your secondary database and set it up.\n   For details, see [secondary Visibility database schema and setup](/cluster-deployment-guide#set-up-secondary-visibility-store).\n\n   ```yaml\n   persistence:\n   visibilityStore: cass-visibility\n   secondaryVisibilityStore: es-visibility\n   datastores:\n       cass-visibility:\n       cassandra:\n           hosts: \"127.0.0.1\"\n           keyspace: \"temporal_visibility\"\n       es-visibility:\n       elasticsearch:\n           version: \"v7\"\n           logLevel: \"error\"\n           url:\n           scheme: \"http\"\n           host: \"127.0.0.1:9200\"\n           indices:\n           visibility: temporal_visibility_v1_dev\n           closeIdleConnectionsInterval: 15s\n   ```\n\n1. Update the [dynamic configuration](/clusters#dynamic-configuration) keys on your self-hosted Temporal Cluster to enable write operations to the secondary store and disable read operations.\n   Example:\n\n   ```yaml\n   system.secondaryVisibilityWritingMode:\n   - value: \"dual\"\n   constraints: {}\n   system.enableReadFromSecondaryVisibility:\n   - value: false\n   constraints: {}\n   ```\n\nAt this point, Visibility data is read from the primary store, and all Visibility data is written to both the primary and secondary store.\nThis setting applies only to new Visibility data generated after Dual Visibility is enabled.\nIt does not migrate any existing data in the primary store to the secondary store.\n\nFor details on write options to the secondary store, see [Secondary Visibility dynamic configuration reference](/references/dynamic-configuration#secondary-visibility-settings).\n\n#### Run in dual mode\n\nWhen you enable a secondary store, only new Visibility data is written to both primary and secondary stores.\nThe primary store still holds the Workflow Execution data from before the secondary store was set up.\n\nRunning in dual mode lets you plan for closed and open Workflow Executions data from before the secondary store was set up in your self-hosted Temporal Cluster.\n\nExample:\n\n- To manage closed Workflow Executions data, run in dual mode until the Namespace [Retention Period](/clusters#retention-period) is reached.\n  After the Retention Period, Workflow Execution data is removed from the Persistence and Visibility stores.\n  If you want to keep the closed Workflow Executions data after the set Retention Period, you must set up [Archival](/cluster-deployment-guide#archival).\n- To manage data for all open Workflow Executions, run in dual mode until all the Workflow Executions started before enabling Dual Visibility mode are closed.\n  After the Workflow Executions are closed, verify the Retention Period and set up Archival if you need to keep the data beyond the Retention Period.\n\nYou can run your Visibility setup in dual mode for an indefinite period, or until you are ready to deprecate the primary store and move completely to the secondary store without losing data.\n\n#### Deprecate primary Visibility store\n\nWhen you are ready to deprecate your primary store, follow these steps.\n\n1. Update the dynamic configuration YAML to enable read operations from the secondary store.\n   Example:\n\n   ```yaml\n   system.secondaryVisibilityWritingMode:\n   - value: \"dual\"\n   constraints: {}\n   system.enableReadFromSecondaryVisibility:\n   - value: true\n   constraints: {}\n   ```\n\n   At this point, Visibility data is read from the secondary store only.\n   Verify whether data on the secondary store is correct.\n\n1. When the secondary store is vetted and ready to replace your current primary store, change your Cluster configuration to set the secondary store as your primary, and remove the dynamic configuration set in the previous steps.\n   Example:\n\n   ```yaml\n   persistence:\n   visibilityStore: es-visibility\n   datastores:\n       es-visibility:\n       elasticsearch:\n           version: \"v7\"\n           logLevel: \"error\"\n           url:\n           scheme: \"http\"\n           host: \"127.0.0.1:9200\"\n           indices:\n           visibility: temporal_visibility_v1_dev\n           closeIdleConnectionsInterval: 15s\n   ```\n","is_empty":false},{"file_name":"how-to-remove-a-custom-search-attribute-key.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-remove-a-custom-search-attribute-key.md","id":"clusters/how-to-remove-a-custom-search-attribute-key","title":"How to remove custom Search Attributes","description":"Remove custom Search Attributes from your self-hosted Temporal Cluster Visibility store using `tctl`.","label":"Remove custom Search Attributes","tags":["operation-guide","filtered-lists","visibility"],"ssdi":[],"markdown_content":"\nTo remove a Search Attribute key from your self-hosted Temporal Cluster Visibility store, use the command `tctl search-attribute remove`.\nRemoving Search Attributes is not supported on Temporal Cloud.\n\nFor example, if using Elasticsearch for advanced Visibility, to remove a custom Search Attribute called `CustomSA` of type Keyword use the following command:\n\n`tctl search-attribute remove --name CustomSA`\n\nWith Temporal Server v1.20, if using a SQL database for advanced Visibility, you need to specify the Namespace in your command, as shown in the following command:\n\n`tctl  --ns yournamespace search-attribute remove --name CustomSA`\n\nTo check whether the Search Attribute was removed, run `tctl search-attribute list` and check the list.\nIf you're on Temporal Server v1.20 and later, specify the Namespace from which you removed the Search Attribute.\nFor example, `tctl  --ns yournamespace search-attribute list`.\n\nNote that if you use [SQL databases](/clusters/how-to-set-up-visibility-in-a-temporal-cluster) with Temporal Server v1.20 and later, a new custom Search Attribute is mapped to a database field name in the Visibility store `custom_search_attributes` table.\nRemoving this custom Search Attribute removes the mapping with the database field name but does not remove the data.\nIf you remove a custom Search Attribute and add a new one, the new custom Search Attribute might be mapped to the database field of the one that was recently removed.\nThis might cause unexpected results when you use the List API to retrieve results using the new custom Search Attribute.\nThese constraints do not apply if you use Elasticsearch.\n","is_empty":false},{"file_name":"how-to-set-up-archival.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-set-up-archival.md","id":"clusters/how-to-set-up-archival","title":"How to set up Archival","description":"This guide covers Temporal's archiving capabilities and how to set up the Archival feature.","label":"Set up Archival","tags":["how-to"],"ssdi":[],"markdown_content":"\n[Archival](/concepts/what-is-archival) consists of the following elements:\n\n- **Configuration**: Archival is controlled by the [server configuration](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L81) (i.e. the `config/development.yaml` file).\n- **Provider**: Location where the data should be archived. Supported providers are S3, GCloud, and the local file system.\n- **URI**: Specifies which provider should be used. The system uses the URI schema and path to make the determination.\n\nTake the following steps to set up Archival:\n\n1. [Set up the provider](#providers) of your choice.\n2. [Configure Archival](#configuration).\n3. [Create a Namespace](#namespace-creation) that uses a valid URI and has Archival enabled.\n\n#### Providers\n\nTemporal directly supports several providers:\n\n- **Local file system**: The [filestore archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) is used to archive data in the file system of whatever host the Temporal server is running on. This provider is used mainly for local installations and testing and should not be relied on for production environments.\n- **Google Cloud**: The [gcloud archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud) is used to connect and archive data with [Google Cloud](https://cloud.google.com/storage).\n- **S3**: The [s3store archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store) is used to connect and archive data with [S3](https://aws.amazon.com/s3).\n- **Custom**: If you want to use a provider that is not currently supported, you can [create your own archiver](/clusters/how-to-create-a-custom-archiver) to support it.\n\nMake sure that you save the provider's storage location URI in a place where you can reference it later, because it is passed as a parameter when you [create a Namespace](#namespace-creation).\n\n#### Configuration\n\nArchival configuration is defined in the [`config/development.yaml`](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L93) file.\nLet's look at an example configuration:\n\n```yaml\n# Cluster level Archival config\narchival:\n  # Event History configuration\n  history:\n    # Archival is enabled at the cluster level\n    state: \"enabled\"\n    enableRead: true\n    # Namespaces can use either the local filestore provider or the Google Cloud provider\n    provider:\n      filestore:\n        fileMode: \"0666\"\n        dirMode: \"0766\"\n      gstorage:\n        credentialsPath: \"/tmp/gcloud/keyfile.json\"\n\n# Default values for a Namespace if none are provided at creation\nnamespaceDefaults:\n  # Archival defaults\n  archival:\n    # Event History defaults\n    history:\n      state: \"enabled\"\n      # New Namespaces will default to the local provider\n      URI: \"file:///tmp/temporal_archival/development\"\n```\n\nYou can disable Archival by setting `archival.history.state` and `namespaceDefaults.archival.history.state` to `\"disabled\"`.\n\nExample:\n\n```yaml\narchival:\n  history:\n    state: \"disabled\"\n\nnamespaceDefaults:\n  archival:\n    history:\n      state: \"disabled\"\n```\n\nThe following table showcases acceptable values for each configuration and what purpose they serve.\n\n| Config                                         | Acceptable values                                                                  | Description                                                                                                                  |\n| ---------------------------------------------- | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\n| `archival.history.state`                       | `enabled`, `disabled`                                                              | Must be `enabled` to use the Archival feature with any Namespace in the cluster.                                             |\n| `archival.history.enableRead`                  | `true`, `false`                                                                    | Must be `true` to read from the archived Event History.                                                                      |\n| `archival.history.provider`                    | Sub provider configs are `filestore`, `gstorage`, `s3`, or `your_custom_provider`. | Default config specifies `filestore`.                                                                                        |\n| `archival.history.provider.filestore.fileMode` | File permission string                                                             | File permissions of the archived files. We recommend using the default value of `\"0666\"` to avoid read/write issues.         |\n| `archival.history.provider.filestore.dirMode`  | File permission string                                                             | Directory permissions of the archive directory. We recommend using the default value of `\"0766\"` to avoid read/write issues. |\n| `namespaceDefaults.archival.history.state`     | `enabled`, `disabled`                                                              | Default state of the Archival feature whenever a new Namespace is created without specifying the Archival state.             |\n| `namespaceDefaults.archival.history.URI`       | Valid URI                                                                          | Must be a URI of the file store location and match a schema that correlates to a provider.                                   |\n\nAdditional resources: [Cluster configuration reference](/references/configuration).\n\n#### Namespace creation\n\nAlthough Archival is configured at the cluster level, it operates independently within each Namespace.\nIf an Archival URI is not specified when a Namespace is created, the Namespace uses the value of `defaultNamespace.archival.history.URI` from the `config/development.yaml` file.\nThe Archival URI cannot be changed after the Namespace is created.\nEach Namespace supports only a single Archival URI, but each Namespace can use a different URI.\nA Namespace can safely switch Archival between `enabled` and `disabled` states as long as Archival is enabled at the cluster level.\n\nArchival is supported in [Global Namespaces](/concepts/what-is-a-global-namespace) (Namespaces that span multiple clusters).\nWhen Archival is running in a Global Namespace, it first runs on the active cluster; later it runs on the standby cluster. Before archiving, a history check is done to see what has been previously archived.\n\n#### Test setup\n\nTo test Archival locally, start by running a Temporal server:\n\n```bash\n./temporal-server start\n```\n\nThen register a new Namespace with Archival enabled.\n\n```bash\n./tctl --ns samples-namespace namespace register --gd false --history_archival_state enabled --retention 3\n```\n\n:::note\n\nIf the retention period isn't set, it defaults to two days.\nThe minimum retention period is one day.\nThe maximum retention period is 30 days.\n\nSetting the retention period to 0 results in the error _A valid retention period is not set on request_.\n\n:::\n\nNext, run a sample Workflow such as the [helloworld temporal sample](https://github.com/temporalio/temporal-go-samples/tree/master/helloworld).\n\nWhen execution is finished, Archival occurs.\n\n#### Retrieve archives\n\nYou can retrieve archived Event Histories by copying the `workflowId` and `runId` of the completed Workflow from the log output and running the following command:\n\n```bash\n./tctl --ns samples-namespace wf show --wid <workflowId> --rid <runId>\n```\n","is_empty":false},{"file_name":"how-to-set-up-cassandra-visibility-store.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-set-up-cassandra-visibility-store.md","id":"clusters/how-to-set-up-cassandra-visibility-store","title":"How to set up Cassandra Visibility store","description":"You can set Cassandra as your Visibility store with any other supported Persistence databases.","label":"Cassandra","tags":["operation-guide","filtered-lists","visibility"],"ssdi":["Support for Cassandra as a Visibility database is deprecated beginning with Temporal Server v1.21. For updates, check the [Temporal Server release notes](https://github.com/temporalio/temporal/releases).","We recommend migrating from Cassandra to any of the other supported databases for Visibility."],"markdown_content":"\nYou can set Cassandra as your [Visibility store](/concepts/what-is-visibility).\nVerify [supported versions](/cluster-deployment-guide#supported-databases) before you proceed.\n\nAdvanced Visibility is not supported with Cassandra.\n\nTo enable advanced Visibility features, use any of the supported databases, such as MySQL, PostgreSQL, SQLite, or Elasticsearch, as your Visibility store.\nWe recommend using Elasticsearch for any Temporal Cluster setup that handles more than a few Workflow Executions because it supports the request load on the Visibility store and helps optimize performance.\n\nTo migrate from Cassandra to a supported SQL database, see [Migrating Visibility database](/cluster-deployment-guide#migrating-visibility-database).\n\n**Persistence configuration**\n\nSet your Cassandra Visibility store name in the `visibilityStore` parameter in your Persistence configuration, and then define the Visibility store configuration under `datastores`.\n\nThe following example shows how to set a Visibility store `cass-visibility` and define the datastore configuration in your Temporal Cluster configuration YAML.\n\n```yaml\n#...\npersistence:\n  #...\n  visibilityStore: cass-visibility\n  #...\n  datastores:\n    default:\n    #...\n    cass-visibility:\n      cassandra:\n        hosts: \"127.0.0.1\"\n        keyspace: \"temporal_visibility\"\n#...\n```\n\n**Database schema and setup**\n\nVisibility data is stored in a database table called `executions_visibility` that must be set up according to the schemas defined (by supported versions) in https://github.com/temporalio/temporal/tree/master/schema/cassandra/visibility.\n\nThe following example shows how the [auto-setup.sh](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) script sets up your Visibility store.\n\n```bash\n#...\n# set your Cassandra environment variables\n: \"${KEYSPACE:=temporal}\"\n: \"${VISIBILITY_KEYSPACE:=temporal_visibility}\"\n\n: \"${CASSANDRA_SEEDS:=}\"\n: \"${CASSANDRA_PORT:=9042}\"\n: \"${CASSANDRA_USER:=}\"\n: \"${CASSANDRA_PASSWORD:=}\"\n: \"${CASSANDRA_TLS_ENABLED:=}\"\n: \"${CASSANDRA_CERT:=}\"\n: \"${CASSANDRA_CERT_KEY:=}\"\n: \"${CASSANDRA_CA:=}\"\n: \"${CASSANDRA_REPLICATION_FACTOR:=1}\"\n#...\n# set connection details\n#...\n# set up Cassandra schema\nsetup_cassandra_schema() {\n  #...\n  # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/cassandra/visibility/versioned\n    if [[ ${SKIP_DB_CREATE} != true ]]; then\n        temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" create -k \"${VISIBILITY_KEYSPACE}\" --rf \"${CASSANDRA_REPLICATION_FACTOR}\"\n    fi\n    temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" -k \"${VISIBILITY_KEYSPACE}\" setup-schema -v 0.0\n    temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" -k \"${VISIBILITY_KEYSPACE}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n  #...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-up-dual-visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-set-up-dual-visibility.md","id":"clusters/how-to-set-up-dual-visibility","title":"How to set up Dual Visibility","description":"To enable Dual Visibility, set up a secondary Visibility store with your primary Visibility, and configure your Temporal Cluster to enable read and/or write operations on the secondary Visibility store.","label":"Dual Visibility","tags":["operation-guide","filtered-lists","visibility"],"ssdi":["Supported from Temporal Server v1.21 onwards."],"markdown_content":"\nTo enable [Dual Visibility](/concepts/what-is-dual-visibility), set up a secondary Visibility store with your primary Visibility store, and configure your Temporal Cluster to enable read and/or write operations on the secondary Visibility store.\n\nWith Dual Visibility, you can read from only one Visibility store at a time, but can configure your Temporal Cluster to write to primary only, secondary only, or to both primary and secondary stores.\n\n#### Set up secondary Visibility store\n\nSet the secondary store with the `secondaryVisibilityStore` configuration key in your Persistence configuration, and then define the secondary Visibility store configuration under `datastores`.\n\nYou can configure any of the [supported databases](/cluster-deployment-guide#supported-databases) as your secondary store.\n\nExamples:\n\nTo configure MySQL as a secondary store with Cassandra as your primary store, do the following.\n\n```yaml\npersistence:\n  visibilityStore: cass-visibility # This is your primary Visibility store\n  secondaryVisibilityStore: mysql-visibility # This is your secondary Visibility store\n  datastores:\n    cass-visibility:\n      cassandra:\n        hosts: \"127.0.0.1\"\n        keyspace: \"temporal_primary_visibility\"\n    mysql-visibility:\n      sql:\n        pluginName: \"mysql8\" # Verify supported versions. Use a version of SQL that supports advanced Visibility.\n        databaseName: \"temporal_secondary_visibility\"\n        connectAddr: \"127.0.0.1:3306\"\n        connectProtocol: \"tcp\"\n        user: \"temporal\"\n        password: \"temporal\"\n```\n\nTo configure Elasticsearch as both your primary and secondary store, use the configuration key `elasticsearch.indices.secondary_visibility`, as shown in the following example.\n\n```yaml\npersistence:\n  visibilityStore: es-visibility\n  datastores:\n    es-visibility:\n      elasticsearch:\n        version: \"v7\"\n        logLevel: \"error\"\n        url:\n          scheme: \"http\"\n          host: \"127.0.0.1:9200\"\n        indices:\n          visibility: temporal_visibility_v1\n          secondary_visibility: temporal_visibility_v1_new\n        closeIdleConnectionsInterval: 15s\n```\n\n#### Database schema and setup\n\nThe database schema and setup for a secondary store depends on the database you plan to use.\n\n- [MySQL](/cluster-deployment-guide#mysql)\n- [PostgresSQL](/cluster-deployment-guide#postgresql)\n- [SQLite](/cluster-deployment-guide#sqlite)\n- [Elasticsearch](/cluster-deployment-guide#elasticsearch)\n\nFor the Cassandra and MySQL configuration in the previous example, an example setup script would be as follows.\n\n```bash\n#...\n# set your Cassandra environment variables\n: \"${KEYSPACE:=temporal}\"\n: \"${VISIBILITY_KEYSPACE:=temporal_primary_visibility}\"\n\n: \"${CASSANDRA_SEEDS:=}\"\n: \"${CASSANDRA_PORT:=9042}\"\n: \"${CASSANDRA_USER:=}\"\n: \"${CASSANDRA_PASSWORD:=}\"\n: \"${CASSANDRA_TLS_ENABLED:=}\"\n: \"${CASSANDRA_CERT:=}\"\n: \"${CASSANDRA_CERT_KEY:=}\"\n: \"${CASSANDRA_CA:=}\"\n: \"${CASSANDRA_REPLICATION_FACTOR:=1}\"\n#...\n# set connection details\n#...\n# set up Cassandra schema\nsetup_cassandra_schema() {\n  #...\n  # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/cassandra/visibility/versioned\n    if [[ ${SKIP_DB_CREATE} != true ]]; then\n        temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" create -k \"${VISIBILITY_KEYSPACE}\" --rf \"${CASSANDRA_REPLICATION_FACTOR}\"\n    fi\n    temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" -k \"${VISIBILITY_KEYSPACE}\" setup-schema -v 0.0\n    temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" -k \"${VISIBILITY_KEYSPACE}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n  #...\n}\n#...\n# set your MySQL environment variables\n: \"${DBNAME:=temporal}\"\n: \"${VISIBILITY_DBNAME:=temporal_secondary_visibility}\"\n: \"${DB_PORT:=}\"\n: \"${MYSQL_SEEDS:=}\"\n: \"${MYSQL_USER:=}\"\n: \"${MYSQL_PWD:=}\"\n: \"${MYSQL_TX_ISOLATION_COMPAT:=false}\"\n\n#...\n# set connection details\n#...\n# set up MySQL schema\nsetup_mysql_schema() {\n    #...\n    # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/mysql/${MYSQL_VERSION_DIR}/visibility/versioned\n    if [[ ${SKIP_DB_CREATE} != true ]]; then\n        temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" create\n    fi\n    temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" setup-schema -v 0.0\n    temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n#...\n}\n```\n\nFor Elasticsearch as both primary and secondary Visibility store configuration in the previous example, an example setup script would be as follows.\n\n```bash\n#...\n# Elasticsearch\n: \"${ENABLE_ES:=false}\"\n: \"${ES_SCHEME:=http}\"\n: \"${ES_SEEDS:=}\"\n: \"${ES_PORT:=9200}\"\n: \"${ES_USER:=}\"\n: \"${ES_PWD:=}\"\n: \"${ES_VERSION:=v7}\"\n: \"${ES_VIS_INDEX:=temporal_visibility_v1_dev}\"\n: \"${ES_SEC_VIS_INDEX:=temporal_visibility_v1_new}\"\n: \"${ES_SCHEMA_SETUP_TIMEOUT_IN_SECONDS:=0}\"\n\n#...\n\n# Validate your ES environment\n#...\n# Wait for ES to start\n#...\n# Set up Elasticsearch index\nsetup_es_index() {\n    ES_SERVER=\"${ES_SCHEME}://${ES_SEEDS%%,*}:${ES_PORT}\"\n    # ES_SERVER is the URL of Elasticsearch server i.e. \"http://localhost:9200\".\n    SETTINGS_URL=\"${ES_SERVER}/_cluster/settings\"\n    SETTINGS_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/cluster_settings_${ES_VERSION}.json\n    TEMPLATE_URL=\"${ES_SERVER}/_template/temporal_visibility_v1_template\"\n    SCHEMA_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/index_template_${ES_VERSION}.json\n    INDEX_URL=\"${ES_SERVER}/${ES_VIS_INDEX}\"\n    curl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SETTINGS_URL}\" -H \"Content-Type: application/json\" --data-binary \"@${SETTINGS_FILE}\" --write-out \"\\n\"\n    curl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${TEMPLATE_URL}\" -H 'Content-Type: application/json' --data-binary \"@${SCHEMA_FILE}\" --write-out \"\\n\"\n    curl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${INDEX_URL}\" --write-out \"\\n\"\n    \n    # Checks for and sets up Elasticsearch as a secondary Visibility store\n    if [[ ! -z \"${ES_SEC_VIS_INDEX}\" ]]; then\n      SEC_INDEX_URL=\"${ES_SERVER}/${ES_SEC_VIS_INDEX}\"\n      curl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SEC_INDEX_URL}\" --write-out \"\\n\"\n    fi\n}\n```\n\n#### Update Cluster configuration\n\nWith the primary and secondary stores set, update the `system.secondaryVisibilityWritingMode` and `system.enableReadFromSecondaryVisibility` configuration keys in your self-hosted Cluster's dynamic configuration YAML file to enable read and/or write operations to the secondary Visibility store.\n\nFor example, to enable write operations to both primary and secondary stores, but disable reading from the secondary store, use the following.\n\n```yaml\nsystem.secondaryVisibilityWritingMode:\n - value: \"dual\"\n   constraints: {}\nsystem.enableReadFromSecondaryVisibility:\n - value: false\n   constraints: {}\n```\n\nFor details on the configuration options, see:\n\n- [Secondary Visibility dynamic configuration reference](/references/dynamic-configuration#secondary-visibility-settings)\n- [Migrating Visibility databases](/cluster-deployment-guide#migrating-visibility-database)\n","is_empty":false},{"file_name":"how-to-set-up-health-checks.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-set-up-health-checks.md","id":"clusters/how-to-set-up-health-checks","label":"Health checks","tags":["how-to","cluster"],"ssdi":[],"markdown_content":"\nThe [Frontend Service](/clusters#frontend-service) supports TCP or [gRPC](https://github.com/grpc/grpc/blob/875066b61e3b57af4bb1d6e36aabe95a4f6ba4f7/src/proto/grpc/health/v1/health.proto#L45) health checks on port 7233.\n\nIf you use [Nomad](https://www.nomadproject.io/) to manage your containers, the [check stanza](https://developer.hashicorp.com/nomad/docs/job-specification/check) would look like this for TCP:\n\n```\nservice {\n  check {\n    type     = \"tcp\"\n    port     = 7233\n    interval = \"10s\"\n    timeout  = \"2s\"\n  }\n```\n\nor like this for gRPC (requires Consul ≥ `1.0.5`):\n\n```\nservice {\n  check {\n    type         = \"grpc\"\n    port         = 7233\n    interval     = \"10s\"\n    timeout      = \"2s\"\n  }\n```\n","is_empty":false},{"file_name":"how-to-set-up-multi-cluster-replication.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-set-up-multi-cluster-replication.md","id":"clusters/how-to-set-up-multi-cluster-replication","title":"How to set up Multi-Cluster Replication","description":"Multi-Cluster Replication can be enabled by setting the appropriate values in the `clusterMetadata` section of your configuration file.","label":"Set up Multi-Cluster Replication","tags":["how-to","cluster"],"ssdi":[],"markdown_content":"\nThe [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication) feature asynchronously replicates Workflow Execution Event Histories from active Clusters to other passive Clusters, and can be enabled by setting the appropriate values in the `clusterMetadata` section of your configuration file.\n\n1. `enableGlobalNamespace` must be set to `true`.\n2. `failoverVersionIncrement` has to be equal across connected Clusters.\n3. `initialFailoverVersion` in each Cluster has to assign a different value.\n   No equal value is allowed across connected Clusters.\n\nAfter the above conditions are satisfied, you can start to configure a multi-cluster setup.\n\n#### Set up Multi-Cluster Replication prior to v1.14\n\nYou can set this up with [`clusterMetadata` configuration](/references/configuration#clustermetadata); however, this is meant to be only a conceptual guide rather than a detailed tutorial.\nPlease reach out to us if you need to set this up.\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\n#### Set up Multi-Cluster Replication in v1.14 and later\n\nYou still need to set up local cluster [`clusterMetadata` configuration](/references/configuration#clustermetadata)\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterB\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\nThen you can use the `tctl admin` tool to add cluster connections. All operations should be executed in both Clusters.\n\n```shell\n# Add cluster B connection into cluster A\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\"\n# Add cluster A connection into cluster B\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\"\n\n# Disable connections\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\" --enable_connection false\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\" --enable_connection false\n\n# Delete connections\ntctl -address 127.0.0.1:7233 admin cluster remove-remote-cluster --cluster \"clusterB\"\ntctl -address 127.0.0.1:8233 admin cluster remove-remote-cluster --cluster \"clusterA\"\n```\n","is_empty":false},{"file_name":"how-to-set-up-mysql-visibility-store.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-set-up-mysql-visibility-store.md","id":"clusters/how-to-set-up-mysql-visibility-store","title":"How to set up MySQL Visibility store","description":"You can set MySQL (v5.7 and later) as your Visibility store.","label":"MySQL","tags":["operation-guide","filtered-lists","visibility"],"ssdi":["MySQL v5.7 and later.","Support for MySQL v5.7 will be deprecated for all Temporal Server versions after v1.20.","With Temporal Server version 1.20 and later, advanced Visibility is available on MySQL v8.0.17 and later."],"markdown_content":"\nYou can set MySQL as your [Visibility store](/concepts/what-is-visibility).\nVerify [supported versions](/clusters/how-to-set-up-visibility-in-a-temporal-cluster#supported-databases) before you proceed.\n\nIf using MySQL v8.0.17 or later as your Visibility store with Temporal Server v1.20 and later, any [custom Search Attributes](/concepts/what-is-a-search-attribute#custom-search-attributes) that you create must be associated with a Namespace in that Cluster.\n\n**Persistence configuration**\n\nSet your MySQL Visibility store name in the `visibilityStore` parameter in your Persistence configuration, and then define the Visibility store configuration under `datastores`.\n\nThe following example shows how to set a Visibility store `mysql-visibility` and define the datastore configuration in your Temporal Cluster configuration YAML.\n\n```yaml\n#...\npersistence:\n  #...\n  visibilityStore: mysql-visibility\n  #...\n  datastores:\n    default:\n      #...\n    mysql-visibility:\n      sql:\n        pluginName: \"mysql8\" # For MySQL v8.0.17 and later. For earlier versions, use \"mysql\" plugin.\n        databaseName: \"temporal_visibility\"\n        connectAddr: \" \" # Remote address of this database; for example, 127.0.0.0:3306\n        connectProtocol: \" \" # Protocol example: tcp\n        user: \"username_for_auth\"\n        password: \"password_for_auth\"\n        maxConns: 2\n        maxIdleConns: 2\n        maxConnLifetime: \"1h\"\n#...\n```\n\nFor details on the configuration parameters and values, see [Cluster configuration](/references/configuration#sql).\n\nTo enable advanced Visibility features on your MySQL Visibility store, upgrade to MySQL v8.0.17 or later with Temporal Server v1.20 or later.\nSee [Upgrade Server](/clusters/how-to-upgrade-the-temporal-server-version) on how to upgrade your Temporal Server and database schemas.\n\nFor example configuration templates, see [MySQL Visibility store configuration](https://github.com/temporalio/temporal/blob/master/config/development-mysql.yaml).\n\n**Database schema and setup**\n\nVisibility data is stored in a database table called `executions_visibility` that must be set up according to the schemas defined (by supported versions):\n\n- [MySQL v5.7 and later](https://github.com/temporalio/temporal/tree/master/schema/mysql/v57/visibility)\n- [MySQL v8.0.17 and later](https://github.com/temporalio/temporal/tree/master/schema/mysql/v8/visibility)\n\nThe following example shows how the [auto-setup.sh](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) script sets up your Visibility store.\n\n```bash\n#...\n# set your MySQL environment variables\n: \"${DBNAME:=temporal}\"\n: \"${VISIBILITY_DBNAME:=temporal_visibility}\"\n: \"${DB_PORT:=}\"\n: \"${MYSQL_SEEDS:=}\"\n: \"${MYSQL_USER:=}\"\n: \"${MYSQL_PWD:=}\"\n: \"${MYSQL_TX_ISOLATION_COMPAT:=false}\"\n\n#...\n# set connection details\n#...\n# set up MySQL schema\nsetup_mysql_schema() {\n    #...\n    # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/mysql/${MYSQL_VERSION_DIR}/visibility/versioned\n    if [[ ${SKIP_DB_CREATE} != true ]]; then\n        temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" create\n    fi\n    temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" setup-schema -v 0.0\n    temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n#...\n}\n```\n\nNote that the script uses [temporal-sql-tool](https://github.com/temporalio/temporal/blob/3b982585bf0124839e697952df4bba01fe4d9543/tools/sql/main.go) to run the setup.\n","is_empty":false},{"file_name":"how-to-set-up-postgresql-visibility-store.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-set-up-postgresql-visibility-store.md","id":"clusters/how-to-set-up-postgresql-visibility-store","title":"How to set up PostgreSQL Visibility store","description":"You can set PostgreSQL as your Visibility store with any other supported Persistence databases.","label":"PostgreSQL","tags":["operation-guide","filtered-lists","visibility"],"ssdi":["PostgreSQL v9.6 and later.","With Temporal Cluster version 1.20 and later, advanced Visibility is available on PostgreSQL v12 and later.","Support for PostgreSQL v9.6 through v11 will be deprecated for all Temporal Server versions after v1.20; we recommend upgrading to PostgreSQL 12 or later."],"markdown_content":"\nYou can set PostgreSQL as your [Visibility store](/concepts/what-is-visibility).\nVerify [supported versions](/clusters/how-to-set-up-visibility-in-a-temporal-cluster#supported-databases) before you proceed.\n\nIf using PostgreSQL v12 or later as your Visibility store with Temporal Server v1.20 and later, any [custom Search Attributes](/concepts/what-is-a-search-attribute#custom-search-attributes) that you create must be associated with a Namespace in that Cluster.\n\n**Persistence configuration**\n\nSet your PostgreSQL Visibility store name in the `visibilityStore` parameter in your Persistence configuration, and then define the Visibility store configuration under `datastores`.\n\nThe following example shows how to set a Visibility store `postgres-visibility` and define the datastore configuration in your Temporal Cluster configuration YAML.\n\n```yaml\n#...\npersistence:\n  #...\n  visibilityStore: postgres-visibility\n  #...\n  datastores:\n    default:\n    #...\n    postgres-visibility:\n      sql:\n        pluginName: \"postgres12\" # For PostgreSQL v12 and later. For earlier versions, use \"postgres\" plugin.\n        databaseName: \"temporal_visibility\"\n        connectAddr: \" \" # remote address of this database; for example, 127.0.0.0:5432\n        connectProtocol: \" \" # protocol example: tcp\n        user: \"username_for_auth\"\n        password: \"password_for_auth\"\n        maxConns: 2\n        maxIdleConns: 2\n        maxConnLifetime: \"1h\"\n#...\n```\n\nTo enable advanced Visibility features on your PostgreSQL Visibility store, upgrade to PostgreSQL v12 or later with Temporal Server v1.20 or later.\nSee [Upgrade Server](/clusters/how-to-upgrade-the-temporal-server-version) for details on how to upgrade your Temporal Server and database schemas.\n\n**Database schema and setup**\n\nVisibility data is stored in a database table called `executions_visibility` that must be set up according to the schemas defined (by supported versions):\n\n- [PostgreSQL v12 and later](https://github.com/temporalio/temporal/tree/master/schema/postgresql/v12/visibility)\n- [PostgreSQL v9.6 and later](https://github.com/temporalio/temporal/tree/master/schema/postgresql/v96/visibility)\n\nThe following example shows how the [auto-setup.sh](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) script sets up your PostgreSQL Visibility store.\n\n```bash\n#...\n# set your PostgreSQL environment variables\n: \"${DBNAME:=temporal}\"\n: \"${VISIBILITY_DBNAME:=temporal_visibility}\"\n: \"${DB_PORT:=}\"\n: \"${POSTGRES_SEEDS:=}\"\n: \"${POSTGRES_USER:=}\"\n: \"${POSTGRES_PWD:=}\"\n\n#... set connection details\n# set up PostgreSQL schema\nsetup_postgres_schema() {\n    #...\n\n    # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/postgresql/${POSTGRES_VERSION_DIR}/visibility/versioned\n    if [[ ${VISIBILITY_DBNAME} != \"${POSTGRES_USER}\" && ${SKIP_DB_CREATE} != true ]]; then\n        temporal-sql-tool --plugin postgres --ep \"${POSTGRES_SEEDS}\" -u \"${POSTGRES_USER}\" -p \"${DB_PORT}\" --db \"${VISIBILITY_DBNAME}\" create\n    fi\n    temporal-sql-tool --plugin postgres --ep \"${POSTGRES_SEEDS}\" -u \"${POSTGRES_USER}\" -p \"${DB_PORT}\" --db \"${VISIBILITY_DBNAME}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n  #...\n}\n```\n\nNote that the script uses [temporal-sql-tool](https://github.com/temporalio/temporal/blob/3b982585bf0124839e697952df4bba01fe4d9543/tools/sql/main.go) to run the setup.\n","is_empty":false},{"file_name":"how-to-set-up-sqlite-visibility-store.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-set-up-sqlite-visibility-store.md","id":"clusters/how-to-set-up-sqlite-visibility-store","title":"How to set up SQLite Visibility store","description":"You can set SQLite as your Visibility store with any other supported Persistence databases.","label":"SQLite","tags":["operation-guide","filtered-lists","visibility"],"ssdi":["SQLite v3.31.0 and later."],"markdown_content":"\nYou can set SQLite as your [Visibility store](/concepts/what-is-visibility).\nVerify [supported versions](/clusters/how-to-set-up-visibility-in-a-temporal-cluster#supported-databases) before you proceed.\n\nTemporal supports only an in-memory database with SQLite; this means that the database is automatically created when Temporal Server starts and is destroyed when Temporal Server stops.\n\nYou can change the configuration to use a file-based database so that it is preserved when Temporal Server stops.\nHowever, if you use a file-based SQLite database, upgrading your database schema to enable advanced Visibility features is not supported; in this case, you must delete the database and create it again to upgrade.\n\nIf using SQLite v3.31.0 and later as your Visibility store with Temporal Server v1.20 and later, any [custom Search Attributes](/concepts/what-is-a-search-attribute#custom-search-attributes) that you create must be associated with a Namespace in that Cluster.\n\n**Persistence configuration**\n\nSet your SQLite Visibility store name in the `visibilityStore` parameter in your Persistence configuration, and then define the Visibility store configuration under `datastores`.\n\nThe following example shows how to set a Visibility store `sqlite-visibility` and define the datastore configuration in your Temporal Cluster configuration YAML.\n\n```yaml\npersistence:\n  # ...\n  visibilityStore: sqlite-visibility\n  # ...\n  datastores:\n    # ...\n    sqlite-visibility:\n      sql:\n        user: \"username_for_auth\"\n        password: \"password_for_auth\"\n        pluginName: \"sqlite\"\n        databaseName: \"default\"\n        connectAddr: \"localhost\"\n        connectProtocol: \"tcp\"\n        connectAttributes:\n          mode: \"memory\"\n          cache: \"private\"\n        maxConns: 1\n        maxIdleConns: 1\n        maxConnLifetime: \"1h\"\n        tls:\n          enabled: false\n          caFile: \"\"\n          certFile: \"\"\n          keyFile: \"\"\n          enableHostVerification: false\n          serverName: \"\"\n```\n\nSQLite (v3.31.0 and later) has advanced Visibility enabled by default.\n\n**Database schema and setup**\n\nVisibility data is stored in a database table called `executions_visibility` that must be set up according to the schemas defined (by supported versions) in https://github.com/temporalio/temporal/blob/master/schema/sqlite/v3/visibility/schema.sql.\n\nFor an example of setting up the SQLite schema, see [Temporalite](https://github.com/temporalio/temporalite/blob/main/server.go) setup.\n","is_empty":false},{"file_name":"how-to-set-up-visibility-in-a-temporal-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-set-up-visibility-in-a-temporal-cluster.md","id":"clusters/how-to-set-up-visibility-in-a-temporal-cluster","title":"How to set up Visibility in a Temporal Cluster","description":"Visibility storage is set up as a part of your Persistence store to enable listing and filtering details about Worklfow Executions that exist on your Temporal Cluster.","label":"Visibility store","tags":["operation-guide","filtered-lists","visibility"],"ssdi":[],"markdown_content":"\nA [Visibility](/concepts/what-is-visibility) store is set up as a part of your [Persistence store](/concepts/what-is-a-temporal-cluster#persistence) to enable listing and filtering details about Workflow Executions that exist on your Temporal Cluster.\n\nA Visibility store is required in a Temporal Cluster setup because it is used by Temporal Web UI and CLI to pull Workflow Execution data and enables features like batch operations on a group of Workflow Executions.\n\nWith the Visibility store, you can use [List Filters](/concepts/what-is-a-list-filter) with [Search Attributes](/concepts/what-is-a-search-attribute) to list and filter Workflow Executions that you want to review.\n\nSetting up [advanced Visibility](/concepts/what-is-advanced-visibility) enables access to creating and using multiple custom Search Attributes with your List Filters.\n\nFor details, see [Search Attributes](/concepts/what-is-a-search-attribute).\n\nNote that if you use MySQL, PostgreSQL, or SQLite as your Visibility store, Temporal Server version 1.20 and later supports advanced Visibility features on MySQL (version 8.0.17 and later), PostgreSQL (version 12 and later) and SQLite (v3.31.0 and later), in addition to Elasticsearch.\n\nTo enable advanced Visibility on your SQL databases, ensure that you do the following:\n\n- [Upgrade your Temporal Server](/clusters/how-to-upgrade-the-temporal-server-version) to version 1.20 or later.\n- [Update your database schemas](/clusters/how-to-upgrade-the-temporal-server-version#upgrade-mysql-or-postgresql-schema) for MySQL to version 8.0.17 (or later), PostgreSQL to version 12 (or later), or SQLite to v3.31.0 (or later).\n\nBeginning with Temporal Server v1.21, you can set up a secondary Visibility store in your Temporal Cluster to enable [Dual Visibility](/concepts/what-is-dual-visibility).\nThis is useful for migrating your Visibility store database.\n\n#### Supported databases\n\nThe following databases are supported as Visibility stores:\n\n- [MySQL](/clusters/how-to-set-up-mysql-visibility-store) v5.7 and later.\n  Use v8.0.17 (or later) with Temporal Server v1.20 or later for advanced Visibility capabilities.\n  Because standard Visibility is deprecated beginning with Temporal Server v1.21, support for older versions of MySQL will be dropped.\n- [PostgreSQL](/clusters/how-to-set-up-postgresql-visibility-store) v9.6 and later.\n  Use v12 (or later) with Temporal Server v1.20 or later for advanced Visibility capabilities.\n  Because standard Visibility is deprecated beginning with Temporal Server v1.21, support for older versions of PostgreSQL will be dropped.\n- [SQLite](/clusters/how-to-set-up-sqlite-visibility-store) v3.31.0 and later for advanced Visibility capabilities.\n- [Cassandra](/clusters/how-to-set-up-cassandra-visibility-store).\n  Support for Cassandra as a Visibility database is deprecated beginning with Temporal Server v1.21.\n- [Elasticsearch](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster) supported versions.\n  We recommend operating a Temporal Cluster with Elasticsearch as your Visibility store for any use case that spawns more than a few Workflow Executions.\n\nYou can use any combination of the supported databases for your Persistence and Visibility stores.\nFor updates, check [Server release notes](https://github.com/temporalio/temporal/releases).\n","is_empty":false},{"file_name":"how-to-upgrade-the-temporal-server-version.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/clusters/how-to-upgrade-the-temporal-server-version.md","id":"clusters/how-to-upgrade-the-temporal-server-version","title":"How to upgrade the Temporal Server version","description":"If a newer version of the Temporal Server is available, a notification appears in the Temporal Web UI.","label":"Upgrade Server","tags":["how-to"],"ssdi":[],"markdown_content":"\nIf a newer version of the [Temporal Server](/concepts/what-is-the-temporal-server) is available, a notification appears in the Temporal Web UI.\n\n:::info\n\nIf you are using a version that is older than 1.0.0, reach out to us at [community.temporal.io](http://community.temporal.io) to ask how to upgrade.\n\n:::\n\nFirst check to see if an upgrade to the database schema is required for the version you wish to upgrade to.\nIf a database schema upgrade is required, it will be called out directly in the [release notes](https://github.com/temporalio/temporal/releases).\nSome releases require changes to the schema, and some do not.\nWe ensure that any consecutive versions are compatible in terms of database schema upgrades, features, and system behavior; however there is no guarantee that there is compatibility between _any_ two non-consecutive versions.\n\nWhen upgrading your Temporal Server version, ensure that you upgrade sequentially.\nFor example, when upgrading from v1.n.x, always upgrade to v1.n+1.x (or the next available version) and so on until you get to the required version.\n\nThe Temporal Server upgrade updates or rewrites the old version data with the format introduced in the newer version.\nBecause Temporal Server guarantees backward compatibility between two consecutive minor versions, and because older versions of the code are eventually removed from the code base, skipping versions when upgrading might cause older formats to become unrecognizable.\nIf the old format of the data can't be read to be rewritten to the new format, the upgrades fail.\n\nCheck the [Temporal Server releases](https://github.com/temporalio/temporal/releases) and follow these releases in order.\nYou can skip patch versions; use the latest patch of a minor version when upgrading.\n\nAlso be aware that each upgrade requires the History Service to load all Shards and update the Shard metadata, so allow approximately 10 minutes on each version for these processes to complete before upgrading to the next version.\n\nUse one of the upgrade tools to upgrade your database schema to be compatible with the Temporal Server version being upgraded to.\n\nIf you are using a schema tools version prior to Temporal Server v1.8.0, we strongly recommend _never_ using the \"dryrun\" (`-y`, or `--dryrun`) options in any of your schema update commands.\nUsing this option might lead to potential loss of data, as when using it will create a new database and drop your\nexisting one.\nThis flag was removed in the 1.8.0 release.\n\n### Upgrade Cassandra schema\n\nIf you are using Cassandra for your Cluster's persistence, use the `temporal-cassandra-tool` to upgrade both the default Persistence and Visibility schemas.\n\n**Example default schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/temporal/versioned\n```\n\n**Example visibility schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal_visibility \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/visibility/versioned\n```\n\n### Upgrade PostgreSQL or MySQL schema\n\nIf you are using MySQL or PostgreSQL use the `temporal-sql-tool`, which works similarly to the `temporal-cassandra-tool`.\n\nRefer to this [Makefile](https://github.com/temporalio/temporal/blob/v1.4.1/Makefile#L367-L383) for context.\n\n#### PostgreSQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal update-schema -d ./schema/postgresql/v96/temporal/versioned\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal_visibility update-schema -d ./schema/postgresql/v96/visibility/versioned\n```\n\nIf you're upgrading PostgreSQL to v12 or later to enable advanced Visibility features with Temporal Server v1.20, upgrade your PostgreSQL version first, and then run `temporal-sql-tool` with the `postgres12` plugin, as shown in the following example:\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres12 --db temporal_visibility update-schema -d ./schema/postgresql/v12/visibility/versioned\n```\n\n#### MySQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal update-schema -d ./schema/mysql/v57/temporal/versioned/\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal_visibility update-schema -d ./schema/mysql/v57/visibility/versioned/\n```\n\nIf you're upgrading MySQL to v8.0.17 or later to enable advanced Visibility features with Temporal Server v1.20, upgrade your MySQL version first, and then run `temporal-sql-tool` with the `mysql8` plugin, as shown in the following example:\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl mysql8 --db temporal_visibility update-schema -d ./schema/mysql/v8/visibility/versioned.\n```\n\n### Roll-out technique\n\nWe recommend preparing a staging Cluster and then do the following to verify the upgrade is successful:\n\n1. Create some simulation load on the staging cluster.\n2. Upgrade the database schema in the staging cluster.\n3. Wait and observe for a few minutes to verify that there is no unstable behavior from both the server and the simulation load logic.\n4. Upgrade the server.\n5. Now do the same to the live environment cluster.\n","is_empty":false},{"file_name":"intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concept-context/intro.md","id":"concept-context/intro","title":"Temporal core concepts","description":"Temporal core concepts explained","label":"Temporal core concepts","tags":["guide-context"],"ssdi":[],"markdown_content":"\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete.\nInformation may change at any time.\n\n:::\n","is_empty":false},{"file_name":"what-is-a-child-workflow-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-child-workflow-execution.md","id":"concepts/what-is-a-child-workflow-execution","title":"What is a Child Workflow Execution?","description":"A Child Workflow Execution is a Workflow Execution that is spawned from within another Workflow.","label":"Child Workflow","tags":["term","explanation","child-workflow"],"ssdi":[],"markdown_content":"\nA Child Workflow Execution is a [Workflow Execution](/workflows#workflow-execution) that is spawned from within another Workflow.\n\n- [How to start a Child Workflow Execution using the Go SDK](/go/child-workflows)\n- [How to start a Child Workflow Execution using the Java SDK](/java/child-workflows)\n- [How to start a Child Workflow Execution using the PHP SDK](/php/child-workflows)\n- [How to start a Child Workflow Execution using the Python SDK](/python/child-workflows)\n- [How to start a Child Workflow Execution using the TypeScript SDK](/typescript/child-workflows)\n\nA Workflow Execution can be both a Parent and a Child Workflow Execution because any Workflow can spawn another Workflow.\n\n![Parent and Child Workflow Execution entity relationship](/diagrams/parent-child-workflow-execution-relationship.svg)\n\nA Parent Workflow Execution must await on the Child Workflow Execution to spawn.\nThe Parent can optionally await on the result of the Child Workflow Execution.\nConsider the Child's [Parent Close Policy](/concepts/what-is-a-parent-close-policy) if the Parent does not await on the result of the Child, which includes any use of Continue-As-New by the Parent.\n\nWhen a Parent Workflow Execution reaches a Closed status, the Cluster propagates Cancellation Requests or Terminations to Child Workflow Executions depending on the Child's Parent Close Policy.\n\nIf a Child Workflow Execution uses Continue-As-New, from the Parent Workflow Execution's perspective the entire chain of Runs is treated as a single execution.\n\n![Parent and Child Workflow Execution entity relationship with Continue As New](/diagrams/parent-child-workflow-execution-with-continue-as-new.svg)\n\n### When to use Child Workflows\n\n**Consider Workflow Execution Event History size limits.**\n\nAn individual Workflow Execution has an [Event History](/concepts/what-is-an-event-history) size limit, which imposes a couple of considerations for using Child Workflows.\n\nOn one hand, because Child Workflow Executions have their own Event Histories, they are often used to partition large workloads into smaller chunks.\nFor example, a single Workflow Execution does not have enough space in its Event History to spawn 100,000 [Activity Executions](/concepts/what-is-an-activity-execution).\nBut a Parent Workflow Execution can spawn 1,000 Child Workflow Executions that each spawn 1,000 Activity Executions to achieve a total of 1,000,000 Activity Executions.\n\nHowever, because a Parent Workflow Execution Event History contains [Events](/concepts/what-is-an-event) that correspond to the status of the Child Workflow Execution, a single Parent should not spawn more than 1,000 Child Workflow Executions.\n\nIn general, however, Child Workflow Executions result in more overall Events recorded in Event Histories than Activities.\nBecause each entry in an Event History is a _cost_ in terms of compute resources, this could become a factor in very large workloads.\nTherefore, we recommend starting with a single Workflow implementation that uses Activities until there is a clear need for Child Workflows.\n\n**Consider each Child Workflow Execution as a separate service.**\n\nBecause a Child Workflow Execution can be processed by a completely separate set of [Workers](/concepts/what-is-a-worker) than the Parent Workflow Execution, it can act as an entirely separate service.\nHowever, this also means that a Parent Workflow Execution and a Child Workflow Execution do not share any local state.\nAs all Workflow Executions, they can communicate only via asynchronous [Signals](/concepts/what-is-a-signal).\n\n**Consider that a single Child Workflow Execution can represent a single resource.**\n\nAs all Workflow Executions, a Child Workflow Execution can create a one to one mapping with a resource.\nFor example, a Workflow that manages host upgrades could spawn a Child Workflow Execution per host.\n\n### When to use a Child Workflow versus an Activity\n\nChild Workflow Executions and Activity Executions are both started from Workflows, so you might feel confused about when to use which.\nHere are some important differences:\n\n- A Child Workflow has access to all Workflow APIs but is subject to the same [deterministic constraints](/workflows#deterministic-constraints) as other Workflows.\n  An Activity has the inverse pros and cons—no access to Workflow APIs but no Workflow constraints.\n- A Child Workflow Execution can continue on if its Parent is canceled with a [Parent Close Policy](/concepts/what-is-a-parent-close-policy) of `ABANDON`.\n  An Activity Execution is _always_ canceled when its Workflow Execution is canceled.\n  (It can react to a cancellation Signal for cleanup.)\n  The decision is roughly analogous to spawning a child process in a terminal to do work versus doing work in the same process.\n- Temporal tracks all state changes within a Child Workflow Execution in Event History.\n  Only the input, output, and retry attempts of an Activity Execution is tracked.\n\nA Workflow models composite operations that consist of multiple Activities or other Child Workflows.\nAn Activity usually models a single operation on the external world.\n\nOur advice: **When in doubt, use an Activity.**\n","is_empty":false},{"file_name":"what-is-a-claimmapper-plugin.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-claimmapper-plugin.md","id":"concepts/what-is-a-claimmapper-plugin","title":"What is a ClaimMapper Plugin?","description":"The Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).","label":"Claim Mapper","tags":["term"],"ssdi":[],"markdown_content":"\nThe Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).\n\nThis process is achieved with the method `GetClaims`, which translates `AuthInfo` structs from the caller into `Claims` about the caller's roles within Temporal.\n\nA `Role` (within Temporal) is a bit mask that combines one or more of the role constants.\nIn the following example, the role is assigned constants that allow the caller to read and write information.\n\n```go\nrole := authorization.RoleReader | authorization.RoleWriter\n```\n\n`GetClaims` is customizable and can be modified with the `temporal.WithClaimMapper` server option.\nTemporal also offers a default JWT `ClaimMapper` for your use.\n\nA typical approach is for `ClaimMapper` to interpret custom `Claims` from a caller's JWT, such as membership in groups, and map them to Temporal roles for the user.\nThe subject information from the caller's mTLS certificate can also be a parameter in determining roles.\n\n#### `AuthInfo`\n\n`AuthInfo` is a struct that is passed to `GetClaims`. `AuthInfo` contains an authorization token extracted from the `authorization` header of the gRPC request.\n\n`AuthInfo` includes a pointer to the `pkix.Name` struct.\nThis struct contains an [x.509](https://www.ibm.com/docs/en/ibm-mq/7.5?topic=certificates-distinguished-names) Distinguished Name from the caller's mTLS certificate.\n\n#### `Claims`\n\n`Claims` is a struct that contains information about permission claims granted to the caller.\n\n`Authorizer` assumes that the caller has been properly authenticated, and trusts the `Claims` when making an authorization decision.\n\n#### Default JWT ClaimMapper\n\nTemporal offers a default JWT `ClaimMapper` that extracts the information needed to form Temporal `Claims`.\nThis plugin requires a public key to validate digital signatures.\n\nTo get an instance of the default JWT `ClaimMapper`, call `NewDefaultJWTClaimMapper` and provide it with the following:\n\n- a `TokenKeyProvider` instance\n- a `config.Authorization` pointer\n- a logger\n\nThe code for the default `ClaimMapper` can also be used to build a custom `ClaimMapper`.\n\n#### Token key provider\n\nA `TokenKeyProvider` obtains public keys from specified issuers' URIs that adhere to a specific format.\nThe default JWT `ClaimMapper` uses this component to obtain and refresh public keys over time.\n\nTemporal provides an `rsaTokenKeyProvider`.\nThis component dynamically obtains public keys that follow the [JWKS format](https://tools.ietf.org/html/rfc7517).\n`rsaTokenKeyProvider` uses only the `RSAKey` and `Close` methods.\n\n```go\nprovider := authorization.NewRSAKeyProvider(cfg)\n```\n\n:::note\n\n`KeySourceURIs` are the HTTP endpoints that return public keys of token issuers in the [JWKS format](https://tools.ietf.org/html/rfc7517).\n`RefreshInterval` defines how frequently keys should be refreshed.\nFor example, [Auth0](https://auth0.com/) exposes endpoints such as `https://YOUR_DOMAIN/.well-known/jwks.json`.\n\n:::\n\nBy default, \"permissions\" is used to name the `permissionsClaimName` value.\n\nConfigure the plugin with `config.Config.Global.Authorization.JWTKeyProvider`.\n\n#### JSON Web Token format\n\nThe default JWT `ClaimMapper` expects authorization tokens to be formatted as follows:\n\n```\nBearer <token>\n```\n\nThe Permissions Claim in the JWT Token is expected to be a collection of Individual Permission Claims.\nEach Individual Permission Claim must be formatted as follows:\n\n```\n<namespace> : <permission>\n```\n\nThese permissions are then converted into Temporal roles for the caller.\nThis can be one of Temporal's four values:\n\n- read\n- write\n- worker\n- admin\n\nMultiple permissions for the same Namespace are overridden by the `ClaimMapper`.\n\n##### Example of a payload for the default JWT ClaimMapper\n\n```\n{\n   \"permissions\":[\n      \"system:read\",\n      \"namespace1:write\"\n   ],\n   \"aud\":[\n      \"audience\"\n   ],\n   \"exp\":1630295722,\n   \"iss\":\"Issuer\"\n}\n```\n","is_empty":false},{"file_name":"what-is-a-cloud-account-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-cloud-account-id.md","id":"concepts/what-is-a-cloud-account-id","title":"What is a Temporal Cloud Account Id?","description":"A Temporal Cloud Account Id is a unique identifier for a customer.","label":"Temporal Cloud Account Id","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Temporal Cloud Account Id is a unique identifier for a customer for the entire time they use Temporal Cloud.\nTemporal Technologies assigns each Account Id, which is an opaque code of five or six alphanumeric characters, such as `f45a2`.\n","is_empty":false},{"file_name":"what-is-a-cloud-namespace-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-cloud-namespace-id.md","id":"concepts/what-is-a-cloud-namespace-id","title":"What is a Cloud Namespace Id?","description":"A Cloud Namespace Id is a globally unique identifier for a Namespace in Temporal Cloud.","label":"Temporal Cloud Namespace Id","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Cloud Namespace Id is a globally unique identifier for a [Namespace](/namespaces) in Temporal Cloud.\nA Namespace Id is formed by concatenating the following:\n\n1. A [Namespace Name](/concepts/what-is-a-cloud-namespace-name)\n1. A period (.)\n1. The [Account Id](/concepts/what-is-a-cloud-account-id) to which the Namespace belongs\n\nFor example, for the Account Id `f45a2` and Namespace Name `accounting-production`, the Namespace Id is `accounting-production.f45a2`.\n","is_empty":false},{"file_name":"what-is-a-cloud-namespace-name.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-cloud-namespace-name.md","id":"concepts/what-is-a-cloud-namespace-name","title":"What is a Cloud Namespace Name?","description":"A Cloud Namespace Name is a customer-supplied name for a Namespace in Temporal Cloud.","label":"Temporal Cloud Namespace Name","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Cloud Namespace Name is a customer-supplied name for a [Namespace](/namespaces) in Temporal Cloud.\nEach Namespace Name, such as `accounting-production`, is unique within the scope of a customer's account.\nIt cannot be changed after the Namespace is provisioned.\n\nEach Namespace Name must conform to the following rules:\n\n- A Namespace Name must contain at least 2 characters and no more than 34 characters.\n- A Namespace Name must begin with a letter, end with a letter or number, and contain only letters, numbers, and the hyphen (-) character.\n- Each hyphen (-) character must be immediately preceded _and_ followed by a letter or number; consecutive hyphens are not permitted.\n- All letters in a Namespace Name must be lowercase.\n","is_empty":false},{"file_name":"what-is-a-codec-server.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-codec-server.md","id":"concepts/what-is-a-codec-server","title":"What is a Codec Server?","description":"A Codec Server is an HTTP server that uses your custom Payload Codec to encode and decode your data remotely through endpoints.","label":"Codec Server","tags":["term"],"ssdi":[],"markdown_content":"\nA Codec Server is an HTTP/HTTPS server that uses a [custom Payload Codec](/production-readiness/develop#securing-your-data) to decode your data remotely through endpoints.\n\n![](/diagrams/tctl-diagram-codec-server.svg)\n\nA Codec Server follows the Temporal [Codec Server Protocol](https://github.com/temporalio/samples-go/tree/main/codec-server#codec-server-protocol).\nIt implements two endpoints:\n\n- `/encode`\n- `/decode`\n\nEach endpoint receives and responds with a JSON body that has a `payloads` property with an array of [Payloads](/concepts/what-is-a-payload).\nThe endpoints run the Payloads through a [Payload Codec](/concepts/what-is-a-data-converter#payload-codec) before returning them.\n\nMost SDKs provide example Codec Server implementation samples, listed here:\n\n- [Go](https://github.com/temporalio/samples-go/tree/main/codec-server)\n- [Java](https://github.com/temporalio/sdk-java/tree/master/temporal-remote-data-encoder)\n- [Python](https://github.com/temporalio/samples-python/blob/main/encryption/codec_server.py)\n- [TypeScript](https://github.com/temporalio/samples-typescript/blob/main/encryption/src/codec-server.ts)\n\n#### Usage\n\nWhen you apply custom encoding with encryption or compression on your Workflow data, it is stored in the encrypted/compressed format on the Temporal Server. For details on what data is encoded, see [Securing your data](/production-readiness/develop#securing-your-data).\n\nTo see decoded data when using the CLI or Web UI to perform some operations on a Workflow Execution, configure the Codec Server endpoint in the Web UI and CLI.\nWhen you configure the Codec Server endpoints, the CLI and Web UI send the encoded data to the Codec Server, and display the decoded data received from the Codec Server.\n\nFor details on creating your Codec Server, see [Codec Server Setup](/production-readiness/develop#codec-server-setup).\n\nAfter you start your Codec Server, [configure your Codec Server endpoints](/production-readiness/develop#set-your-codec-server-endpoints-with-web-ui-and-cli).\n\n<!-- You can set your Codec Server endpoints to encode data sent to the Temporal Server (see [Remote data encoding](/concepts/what-is-remote-data-encoding)).\nHowever, before you use a Codec Server to encode your data, ensure that you consider all the security implications of running codecs remotely.\nFor example, codecs that perform encryption might need to be secured to prevent decryption by untrusted callers. -->\n","is_empty":false},{"file_name":"what-is-a-command.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-command.md","id":"concepts/what-is-a-command","title":"What is a Command?","description":"A Command is a requested action issued by a Worker to the Temporal Cluster after a Workflow Task Execution completes.","label":"Command","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Command is a requested action issued by a [Worker](/concepts/what-is-a-worker) to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) after a [Workflow Task Execution](/concepts/what-is-a-workflow-task-execution) completes.\n\nThe action that the Cluster takes is recorded in the [Workflow Execution's](/workflows#workflow-execution) [Event History](/concepts/what-is-an-event-history) as an [Event](/concepts/what-is-an-event).\nThe Workflow Execution can await on some of the Events that come as a result from some of the Commands.\n\nCommands are generated by the use of Workflow APIs in your code. During a Workflow Task Execution there may be several Commands that are generated.\nThe Commands are batched and sent to the Cluster as part of the Workflow Task Execution completion request, after the Workflow Task has progressed as far as it can with the Workflow function.\nThere will always be [WorkflowTaskStarted](/references/events/#workflowtaskstarted) and [WorkflowTaskCompleted](/references/events/#workflowtaskcompleted) Events in the Event History when there is a Workflow Task Execution completion request.\n\n![Commands are generated by the use of Workflow APIs in your code](/diagrams/commands.svg)\n\nCommands are described in the [Command reference](/references/commands) and are defined in the [Temporal gRPC API](https://github.com/temporalio/api/blob/master/temporal/api/command/v1/message.proto).\n","is_empty":false},{"file_name":"what-is-a-custom-data-converter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-custom-data-converter.md","id":"concepts/what-is-a-custom-data-converter","title":"What is a custom Data Converter?","description":"A custom Data Converter extends the default Data Converter with custom logic for Payload conversion or Payload encryption.","label":"Custom Data Converter","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA custom Data Converter extends the default [Data Converter](/concepts/what-is-a-data-converter) with custom logic for [Payload](/concepts/what-is-a-payload) conversion or encoding.\n\nYou can create a custom Data Converter to alter formats (for example, using [MessagePack](https://msgpack.org/) instead of JSON) or add compression and encryption.\n\nYou can customize the default Data Converter behavior in two ways:\n\n- A Payload Converter serializes data, converting objects to bytes and back.\n  To convert custom objects or data types to [Payloads](/concepts/what-is-a-payload) and back, use a custom Payload Converter and set it on a Data Converter.\n- A Payload Codec encodes and decodes [Payloads](/concepts/what-is-a-payload), with bytes-to-bytes conversion.\n  To use custom encryption and/or compression logic, create a custom Payload Codec with your encryption/compression logic in the `encode` function and your decryption/decompression logic in the `decode` function.\n\nCustom Data Converters are not applied to all data; for example, [Search Attributes](/concepts/what-is-a-search-attribute) are simple values and persisted unencoded so they can be indexed for searching.\n\n<!--\nCommenting this bit for reference later; the Headers detail might change.\n- Search Attributes are simple values and are persisted unencoded so they can be indexed for searching.\n- Headers are not encoded by the SDK. (The one exception—when implemented—will be the SDK [running OTel baggage through custom codecs](https://github.com/temporalio/sdk-typescript/issues/514).) -->\n\nA customized Data Converter can have the following three components:\n\n- [Payload Converter](/concepts/what-is-a-payload-converter)\n- [Failure Converter](/concepts/what-is-a-failure-converter)\n- [Payload Codec](/concepts/what-is-a-payload-codec)\n\nFor details on how to implement custom Payload Converters in your SDK, see Custom Payload conversion for the following SDKs:\n\n- [How to implement custom Payload convesion in Go](/go/custom-payload-conversion)\n- [How to implement custom Payload conversion in Java](/java/custom-payload-conversion)\n\nFor details on how to implement custom encryption and compression in your SDK, see [Data Encryption](/production-readiness/develop#securing-your-data).\n","is_empty":false},{"file_name":"what-is-a-data-converter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-data-converter.md","id":"concepts/what-is-a-data-converter","title":"What is a Data Converter?","description":"A Data Converter is a Temporal SDK component that serializes and encodes data entering and exiting a Temporal Cluster.","label":"Data Converter","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Data Converter is a Temporal SDK component that serializes and encodes data entering and exiting a Temporal Cluster.\nIt is used by the Temporal SDK framework to serialize/deserialize data such as input and output of Activities and Workflows that need to be sent over the wire to the Temporal Cluster.\n\n![Data Converter encodes and decodes data](/diagrams/default-data-converter.svg)\n\nThe Data Converter encodes data from your application to a [Payload](/concepts/what-is-a-payload) before it is sent to the Temporal Cluster in the Client call.\nWhen the Temporal Server sends the encoded data back to the Worker, the Data Converter decodes it for processing within your application.\nThis technique ensures that all your sensitive data exists in its original format only on hosts that you control.\n\nThe main pieces of data that run through the Data Converter are arguments and return values:\n\n- The Client:\n  - Encodes Workflow, Signal, and Query arguments.\n  - Decodes Workflow and Query return values.\n- The Worker:\n  - Decodes Workflow, Signal, and Query arguments.\n  - Encodes Workflow and Query return values.\n  - Decodes and encodes Activity arguments and return values.\n\nEach piece of data (like a single argument or return value) is encoded as a [Payload](/concepts/what-is-a-payload) Protobuf message, which consists of binary data and key-value metadata.\n\nFor details, see the API references:\n\n- [Go](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter)\n- [Java](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html)\n- [Python](https://python.temporal.io/temporalio.converter.DataConverter.html)\n- [TypeScript](https://typescript.temporal.io/api/interfaces/common.DataConverter)\n","is_empty":false},{"file_name":"what-is-a-default-data-converter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-default-data-converter.md","id":"concepts/what-is-a-default-data-converter","title":"What is a default Data Converter?","description":"The default Data Converter is used by the Temporal SDK to convert objects into bytes using a series of Payload Converters.","label":"Default Data Converter","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nEach Temporal SDK includes and uses a default Data Converter.\nThe default Data Converter converts objects to bytes using a series of Payload Converters and supports binary, Protobufs, and JSON formats.\nIt encodes values in the following order:\n\n- Null\n- Byte array\n- Protobuf JSON\n- JSON\n\n<!-- commenting this out but include this in the TS how-to.\nIn SDKs that cannot determine parameter types at runtime (for example, TypeScript), Protobufs aren't included in the default converter.\nAlso, Chad: This is only true by default on converting from payloads, but not on converting to payloads. And we have documented how to fix it for converting from payloads: https://legacy-documentation-sdks.temporal.io/typescript/data-converters#protobufs.-->\n\nFor example:\n\n- If a value is an instance of a Protobuf message, it is encoded with [proto3 JSON](https://developers.google.com/protocol-buffers/docs/proto3#json).\n- If a value isn't null, binary, or a Protobuf, it is encoded as JSON.\n  If any part of it is not serializable as JSON, <!--(for example, a Date—see JSON data types)--> an error is thrown.\n","is_empty":false},{"file_name":"what-is-a-failure-converter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-failure-converter.md","id":"concepts/what-is-a-failure-converter","title":"What is a Failure Converter?","description":"A Failure Converter converts error objects to proto Failures and back.","label":"Failure Converter","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Failure Converter converts error objects to proto Failures and back.\nThe default Failure Converter copies error messages and stack traces as plain text.\n\nFor details, see the API references.\n\n- [Go](https://pkg.go.dev/go.temporal.io/sdk/converter#FailureConverter)\n- [Java](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/failure/FailureConverter.html)\n- [Python](https://python.temporal.io/temporalio.converter.FailureConverter.html)\n- [TypeScript](https://typescript.temporal.io/api/interfaces/common.FailureConverter)\n\nYou can make a custom Failure Converter, but if you use multiple SDKs, you must implement the same logic in each.\nCreating a custom Failure Converter is not yet supported in Java.\n\nFailure messages and stack traces are not encoded as codec-capable Payloads by default; you must explicitly enable encoding these common attributes on failures.\nIf your errors might contain sensitive information, you can encrypt the message and stack trace by configuring the default Failure Converter to use your encoded attributes, in which case it moves your `message` and `stack_trace` fields to a Payload that's run through your [codec](/concepts/what-is-a-payload-codec).\n","is_empty":false},{"file_name":"what-is-a-failure.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-failure.md","id":"concepts/what-is-a-failure","title":"What is a Failure?","description":"Temporal Failures are representations of various types of errors that occur in the system.","label":"Failure","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nTemporal Failures are representations (in the SDKs and Event History) of various types of errors that occur in the system.\n\n- KB article: [Temporal Failures](/kb/failures)\n\nFailure handling is an essential part of development.\nFor more information, including the difference between application-level and platform-level failures, see [Handling Failure From First Principles](https://dominik-tornow.medium.com/handling-failures-from-first-principles-1ed976b1b869).\nFor the practical application of those concepts in Temporal, see [Failure Handling in Practice](https://temporal.io/blog/failure-handling-in-practice).\n\nFor languages that throw (or raise) errors (or exceptions), throwing an error that is not a Temporal Failure from a Workflow fails the Workflow Task (and the Task will be retried until it succeeds), whereas throwing a Temporal Failure (or letting a Temporal Failure propagate from Temporal calls, like an [Activity Failure](/kb/failures#activity-failure) from an Activity call) fails the Workflow Execution.\nFor more information, see [Application Failure](/kb/failures#application-failure).\n","is_empty":false},{"file_name":"what-is-a-frontend-service.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-frontend-service.md","id":"concepts/what-is-a-frontend-service","title":"What is a Frontend Service?","description":"The Frontend Service is a stateless gateway service that exposes a strongly typed Proto API. The Frontend Service is responsible for rate limiting, authorizing, validating, and routing all inbound calls.","label":"Frontend Service","tags":["term"],"ssdi":[],"markdown_content":"\nThe Frontend Service is a stateless gateway service that exposes a strongly typed [Proto API](https://github.com/temporalio/api/blob/master/temporal/api/workflowservice/v1/service.proto).\nThe Frontend Service is responsible for rate limiting, authorizing, validating, and routing all inbound calls.\n\n![Frontend Service](/diagrams/temporal-frontend-service.svg)\n\nTypes of inbound calls include the following:\n\n- [Namespace](/concepts/what-is-a-namespace) CRUD\n- External events\n- Worker polls\n- [Visibility](/concepts/what-is-visibility) requests\n- [tctl](/tctl-v1) (the Temporal CLI) operations\n- Calls from a remote Cluster related to [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication)\n\nEvery inbound request related to a Workflow Execution must have a Workflow Id, which is hashed for routing purposes.\nThe Frontend Service has access to the hash rings that maintain service membership information, including how many nodes (instances of each service) are in the Cluster.\n\nInbound call rate limiting is applied per host and per namespace.\n\nThe Frontend Service talks to the Matching Service, History Service, Worker Service, the database, and Elasticsearch (if in use).\n\n- It uses the grpcPort 7233 to host the service handler.\n- It uses port 6933 for membership-related communication.\n\nPorts are configurable in the Cluster configuration.\n","is_empty":false},{"file_name":"what-is-a-global-namespace.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-global-namespace.md","id":"concepts/what-is-a-global-namespace","title":"What is a Global Namespace?","description":"A Global Namespace is a Namespace that exists across Clusters when Multi-Cluster Replication is set up.","label":"Global Namespace","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Global Namespace is a [Namespace](/concepts/what-is-a-namespace) that exists across Clusters when [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication) is set up.\n\n- [How to register a Global Namespace](/tctl-v1/namespace#register)\n- [How to change the active Cluster for a Global Namespace](/tctl-v1/namespace#update)\n\nThe Global Namespace feature enables Workflow Executions to progress through another Cluster in the event of a failover.\n\nA Global Namespace may be replicated to any number of Clusters, but is active in only one Cluster at any given time.\n\nFor a failover to be successful, Worker Processes must be polling for Tasks for the Global Namespace on all Clusters.\n\nA Global Namespace has a failover version.\nBecause a failover can be triggered from any Cluster, the failover version prevents certain conflicts from occurring if a failover is mistakenly triggered simultaneously on two Clusters.\n\nOnly the active Cluster dispatches [Tasks](/concepts/what-is-a-task); however, certain conflicts are possible.\nUnlike regular Namespaces, which provide at-most-once semantics for an Activity Execution, Global Namespaces can support only at-least-once semantics (see [Conflict resolution](/concepts/what-is-multi-cluster-replication#conflict-resolution)).\nWorker Processes on the standby Clusters are idle until a failover occurs and their Cluster becomes active.\n\nTemporal Application API calls made to a non-active Cluster are rejected with a **NamespaceNotActiveError** which contains the name of the current active Cluster.\nIt is the responsibility of the Temporal Application to call the Cluster that is currently active.\n","is_empty":false},{"file_name":"what-is-a-heartbeat-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-heartbeat-timeout.md","id":"concepts/what-is-a-heartbeat-timeout","title":"What is a Heartbeat Timeout?","description":"A Heartbeat Timeout is the maximum time between Activity Heartbeats.","label":"Heartbeat Timeout","tags":["term","explanation","timeouts"],"ssdi":[],"markdown_content":"\nA Heartbeat Timeout is the maximum time between [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n\n- [How to set a Heartbeat Timeout using the Go SDK](/go/heartbeat-timeout)\n- [How to set a Heartbeat Timeout using the Java SDK](/java/heartbeat-timeout)\n- [How to set a Heartbeat Timeout using the PHP SDK](/php/heartbeat-timeout)\n- [How to set a Heartbeat Timeout using the Python SDK](/python/heartbeat-timeout)\n- [How to set a Heartbeat Timeout using the TypeScript SDK](/typescript/heartbeat-timeout)\n\n![Heartbeat Timeout periods](/diagrams/heartbeat-timeout.svg)\n\nIf this timeout is reached, the Activity Task fails and a retry occurs if a [Retry Policy](/concepts/what-is-a-retry-policy) dictates it.\n","is_empty":false},{"file_name":"what-is-a-history-service.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-history-service.md","id":"concepts/what-is-a-history-service","title":"What is a History Service?","description":"The History Service is responsible for persisting Workflow Execution state and determining what to do next to progress the Workflow Execution through History Shards.","label":"History Service","tags":["term"],"ssdi":[],"markdown_content":"\nThe History Service is responsible for persisting Workflow Execution state and determining what to do next to progress the Workflow Execution by using [History Shards](/concepts/what-is-a-history-shard).\n\n![History Service](/diagrams/temporal-history-service.svg)\n\nThe total number of History Services can be between 1 and the total number of History Shards.\nAn individual History Service can support a large number of History Shards.\nTemporal recommends starting at a ratio of 1 History Service for every 500 History Shards.\n\nAlthough the total number of History Shards remains static for the life of the Cluster, the number of History Services can change.\n\nThe History Service talks to the Matching Service and the database.\n\n- It uses grpcPort 7234 to host the service handler.\n- It uses port 6934 for membership-related communication.\n\nPorts are configurable in the Cluster configuration.\n","is_empty":false},{"file_name":"what-is-a-history-shard.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-history-shard.md","id":"concepts/what-is-a-history-shard","title":"What is a History Shard?","description":"A History Shard is an important unit within a Temporal Cluster by which the scale of concurrent Workflow Execution throughput can be measured.","label":"History Shard","tags":["term"],"ssdi":[],"markdown_content":"\nA History Shard is an important unit within a Temporal Cluster by which the scale of concurrent Workflow Execution throughput can be measured.\n\nEach History Shard maps to a single persistence partition.\nA History Shard assumes that only one concurrent operation can be within a partition at a time.\nIn essence, the number of History Shards represents the number of concurrent database operations that can occur for a Cluster.\nThis means that the number of History Shards in a Temporal Cluster plays a significant role in the performance of your Temporal Application.\n\nBefore integrating a database, the total number of History Shards for the Temporal Cluster must be chosen and set in the Cluster's configuration (see [persistence](/references/configuration#persistence)).\nAfter the Shard count is configured and the database integrated, the total number of History Shards for the Cluster cannot be changed.\n\nIn theory, a Temporal Cluster can operate with an unlimited number of History Shards, but each History Shard adds compute overhead to the Cluster.\nTemporal Clusters have operated successfully using anywhere from 1 to 128K History Shards, with each Shard responsible for tens of thousands of Workflow Executions.\nOne Shard is useful only in small scale setups designed for testing, while 128k Shards is useful only in very large scale production environments.\nThe correct number of History Shards for any given Cluster depends entirely on the Temporal Application that it is supporting and the type of database.\n\nA History Shard is represented as a hashed integer.\nEach Workflow Execution is automatically assigned to a History Shard.\nThe assignment algorithm hashes Workflow Execution metadata such as Workflow Id and Namespace and uses that value to match a History Shard.\n\nEach History Shard maintains the Workflow Execution Event History, Workflow Execution mutable state, and the following internal Task Queues:\n\n- Internal Transfer Task Queue: Transfers internal tasks to the Matching Service.\n  Whenever a new Workflow Task needs to be scheduled, the History Service's Transfer Task Queue Processor transactionally dispatches it to the Matching Service.\n- Internal Timer Task Queue: Durably persists Timers.\n- Internal Replicator Task Queue: Asynchronously replicates Workflow Executions from active Clusters to other passive Clusters.\n  (Relies on the experimental Multi-Cluster feature.)\n- Internal Visibility Task Queue: Pushes data to the [Advanced Visibility](/concepts/what-is-advanced-visibility) index.\n","is_empty":false},{"file_name":"what-is-a-list-filter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-list-filter.md","id":"concepts/what-is-a-list-filter","title":"What is a List Filter?","description":"A List Filter is the SQL-like string that is provided as the parameter to an advanced Visibility List API.","label":"List Filter","tags":["term","explanation","filtered-lists","visibility"],"ssdi":[],"markdown_content":"\nA List Filter is the SQL-like string that is provided as the parameter to a [Visibility](/concepts/what-is-visibility) List API.\n\nA List Filter contains [Search Attribute](/concepts/what-is-a-search-attribute) names, Search Attribute values, and [operators](#supported-operators) to pull a filtered list of Workflow Executions from the Visibility store.\n\nList Filter [Search Attribute](/concepts/what-is-a-search-attribute) names are case sensitive, and each List Filter is scoped by a single [Namespace](/concepts/what-is-a-namespace).\n\nA List Filter that uses a time range has a resolution of 1 ns on [Elasticsearch](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster) and 1 µs for [SQL databases](/clusters/how-to-set-up-visibility-in-a-temporal-cluster).\n\n### Supported operators\n\nA List Filter contains [Search Attribute](/concepts/what-is-a-search-attribute) names, Search Attribute values, and the following supported operators:\n\n- **=, !=, >, >=, <, <=**\n- **AND, OR, ()**\n- **BETWEEN ... AND**\n- **IN**\n\n<!-- - **ORDER BY** -->\n\n<!-- The **ORDER BY** operator is supported only when Elasticsearch is used as the Visibility store.\n\nThe **ORDER BY** operator is currently not supported in Temporal Cloud.\n\nCustom Search Attributes of the `Text` type cannot be used in **ORDER BY** clauses. -->\n\n### Partial string match\n\nThe `=` operator works like **CONTAINS** to find Workflows with Search Attributes that contain a specific word.\n\n<!-- note: advanced vis features will be supported in SQL upon the release of v1.20.-->\n\nFor example, if you have a custom Search Attribute named `Description` of `Text` type with the value of \"The quick brown fox jumps over the lazy dog\", searching for `Description='quick'` or `Description='fox'` will successfully return the Workflow.\nHowever, partial word searches such as `Description='qui'` or `Description='laz'` will not return the Workflow.\nThis is because [Elasticsearch's tokenizer](https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-tokenizer.html) is configured to return complete words as tokens.\n\n### Efficient API usage\n\nAn Advanced List Filter API may take longer to respond if it is retrieving a large number of Workflow Executions (over 10,000).\n\nWith Temporal Server v1.20 and later, you can use the `CountWorkflow` API to efficiently count the number of [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\nPaginate the results with the `ListWorkflow` API by using the page token to retrieve the next page; continue until the page token is `null`/`nil`.\n\n#### List Filter examples\n\nThe following is a List Filter set with [`tctl`](/tctl-v1/workflow/list):\n\n```\nWorkflowType = \"main.YourWorkflowDefinition\" and ExecutionStatus != \"Running\" and (StartTime > \"2021-06-07T16:46:34.236-08:00\" or CloseTime > \"2021-06-07T16:46:34-08:00\")\n```\n\nWhen used, a list of Workflows that meet the following conditions are returned:\n\n- The Workflow Type is set to `main.YourWorkflowDefinition`.\n- The Workflow isn't running.\n- The Workflow either started after \"2021-06-07T16:46:34.236-08:00\" or closed after \"2021-06-07T16:46:34-08:00\".\n\nMore List Filter examples have been provided below.\n\n```sql\nWorkflowId = '<workflow-id>'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or WorkflowId = '<another-workflow-id>'\n```\n\n```sql\nWorkflowId IN ('<workflow-id>', '<another-workflow-id>')\n```\n\n<!-- ```sql\nWorkflowId = '<workflow-id>' order by StartTime desc\n``` -->\n\n```sql\nWorkflowId = '<workflow-id>' and ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' and StartTime > '2021-08-22T15:04:05+00:00'\n```\n\n```sql\nExecutionTime between '2021-08-22T15:04:05+00:00' and '2021-08-28T15:04:05+00:00'\n```\n\n```sql\nExecutionTime < '2021-08-28T15:04:05+00:00' or ExecutionTime > '2021-08-22T15:04:05+00:00'\n```\n\n<!-- ```sql\norder by ExecutionTime\n```\n\n```sql\norder by StartTime desc, CloseTime asc\n```\n\n```sql\norder by CustomIntField asc\n``` -->\n","is_empty":false},{"file_name":"what-is-a-local-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-local-activity.md","id":"concepts/what-is-a-local-activity","title":"What is a Local Activity?","description":"A Local Activity is an Activity Execution that executes in the same process as the Workflow Execution that spawns it.","label":"Local Activity","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Local Activity is an [Activity Execution](/concepts/what-is-an-activity-execution) that executes in the same process as the [Workflow Execution](/workflows#workflow-execution) that spawns it.\n\nSome Activity Executions are very short-living and do not need the queuing semantic, flow control, rate limiting, and routing capabilities.\nFor this case, Temporal supports the Local Activity feature.\n\nThe main benefit of Local Activities is that they use less Temporal Cluster resources (for example, fewer History events) and have much lower latency overhead (because no need to roundtrip to the Cluster) compared to normal Activity Executions.\nHowever, Local Activities are subject to shorter durations and a lack of rate limiting.\n\nConsider using Local Activities for functions that are the following:\n\n- can be implemented in the same binary as the Workflow that calls them.\n- do not require global rate limiting.\n- do not require routing to a specific Worker or Worker pool.\n- no longer than a few seconds, inclusive of retries.\n\nIf it takes longer than 80% of the Workflow Task Timeout (which is 10 seconds by default), the Worker will ask the Cluster to create a new Workflow Task to extend the \"lease\" for processing the Local Activity.\nThe Worker will continue doing so until the Local Activity has completed.\nThis is called Workflow Task Heartbeating.\nThe drawbacks of long-running Local Activities are:\n\n- Each new Workflow Task results in 3 more Events in History.\n- The Workflow won't get notified of new events like Signals and completions until the next Workflow Task Heartbeat.\n- New Commands created by the Workflow concurrently with the Local Activity will not be sent to the Cluster until either the Local Activity completes or the next Workflow Task Heartbeat.\n\nUsing a Local Activity without understanding its limitations can cause various production issues.\n**We recommend using regular Activities unless your use case requires very high throughput and large Activity fan outs of very short-lived Activities.**\nMore guidance in choosing between [Local Activity vs Activity](https://community.temporal.io/t/local-activity-vs-activity/290/3) is available in our forums.\n","is_empty":false},{"file_name":"what-is-a-matching-service.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-matching-service.md","id":"concepts/what-is-a-matching-service","title":"What is a Matching Service?","description":"The Matching Service is responsible for hosting external Task Queues for Task dispatching.","label":"Matching Service","tags":["term"],"ssdi":[],"markdown_content":"\nThe Matching Service is responsible for hosting user-facing [Task Queues](/concepts/what-is-a-task-queue) for Task dispatching.\n\n![Matching Service](/diagrams/temporal-matching-service.svg)\n\nIt is responsible for matching Workers to Tasks and routing new Tasks to the appropriate queue.\nThis service can scale internally by having multiple instances.\n\nIt talks to the Frontend Service, History Service, and the database.\n\n- It uses grpcPort 7235 to host the service handler.\n- It uses port 6935 for membership related communication.\n\nPorts are configurable in the Cluster configuration.\n","is_empty":false},{"file_name":"what-is-a-memo.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-memo.md","id":"concepts/what-is-a-memo","title":"What is a Memo?","description":"A Memo is a non-indexed user-supplied set of Workflow Execution metadata that is returned when you describe or list Workflow Executions.","label":"Memo","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Memo is a non-indexed set of Workflow Execution metadata that developers supply at start time or in Workflow code and that is returned when you describe or list Workflow Executions.\n\nThe primary purpose of using a Memo is to enhance the organization and management of Workflow Executions.\nAdd your own metadata, such as notes or descriptions, to a Workflow Execution, which lets you annotate and categorize Workflow Executions based on developer-defined criteria.\nThis feature is particularly useful when dealing with numerous Workflow Executions because it facilitates the addition of context, reminders, or any other relevant information that aids in understanding or tracking the Workflow Execution.\n\n<!--\n\n:::note Use Memos judiciously\n\nMemos shouldn't store data that's critical to the execution of a Workflow, for some of the following reasons:\n\n- Unlike Workflow inputs, Memos lack type safety\n- Memos are subject to eventual consistency and may not be immediately available\n- Excessive reliance on Memos hides mutable state from the Workflow Execution History\n\n:::\n\n-->\n","is_empty":false},{"file_name":"what-is-a-namespace.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-namespace.md","id":"concepts/what-is-a-namespace","title":"What is a Namespace?","description":"A Namespace is a unit of isolation within the Temporal Platform","label":"Namespace","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Namespace is a unit of isolation within the Temporal Platform.\n\nA single Namespace is still multi-tenant.\n\n### Usage\n\nNamespaces are created on the Temporal Cluster, and provide a range of controls to achieve isolation on Workflow Executions.\n\n- Namespaces are a mechanism for resource isolation. Heavy traffic from one Namespace will not impact other Namespaces running on the same Cluster.\n  For example, you can use Namespaces to match the development lifecycle by having separate `dev` and `prod` Namespaces.\n- If no other Namespace is specified, the Temporal Cluster uses the Namespace \"default\" for all Temporal SDKs and tctl.\n  See the [Registration](#registration) section for details.\n- Namespaces created on self-hosted Temporal Clusters are case-sensitive. For example, `foo` and `Foo` are two different Namespaces.\n  On Temporal Cloud, Namespaces are case-insensitive, and we recommend using lowercase for Namespace names to avoid potential issues.\n- **Membership**: [Task Queue](/concepts/what-is-a-task-queue) names and [Workflow Ids](/concepts/what-is-a-workflow-id) must all correspond to a specific Namespace.\n  For example, when a Workflow Execution is spawned, it does so within a specific Namespace.\n- **Uniqueness**: Temporal guarantees a unique Workflow Id within a Namespace.\n  Workflow Executions may have the same Workflow Id if they are in different Namespaces.\n- **Namespace Configuration**: Various configuration options like the [Retention Period](/concepts/what-is-a-retention-period) and the [Archival](/concepts/what-is-archival) destination are configured per Namespace through a special CRUD API or through [`tctl`](/tctl-v1/namespace).\n\n### Registration\n\nRegistering a Namespace creates the Namespace on the Temporal Cluster.\nWhen you register your Namespace, you must also set the [Retention Period](/concepts/what-is-a-retention-period) for the Namespace.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud/how-to-manage-namespaces-in-temporal-cloud) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to create and manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can register your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nAll SDKs require a Namespace on the Temporal Cluster (or Temporal Cloud) for their Client calls. If not set using Client options, the Workflow Client API looks for the `default` Namespace. If there is no default Namespace registered with your Temporal Cluster (or Temporal Cloud), all calls will throw errors.\nYou must register your Namespace with the Temporal Cluster (or Temporal Cloud) before setting it in your Client.\n\nOn self-hosted Temporal Clusters, you can register your Namespaces in the following ways:\n\n- In your Cluster setup, create your Namespaces, including the default, in your setup script.\n  For example:\n\n  - If deploying through Docker Compose or using the [auto-setup image](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) in a custom Docker Compose application, the Namespace \"default\" is created, through the auto-setup script.\n  - If deploying through the [Temporal Helm charts](https://github.com/temporalio/helm-charts), you can create the \"default\" Namespace by using tctl; for example, `tctl --namespace default namespace register`.\n\n- Use the `tctl namespace register` command with the `--retention` modfiier to register your Namespaces, one at a time, and set the Retention Period on each.\n\n  - [How to register a new Namespace using tctl](/tctl-v1/namespace#register)\n  - [How to register a new Namespace using the Go SDK](/go/register-namespaces)\n  - [How to register a new Namespace using the Java SDK](/java/register-namespaces)\n\n- In your Client program, register your Namespace using `RegisterNamespaceRequest` API available in all the SDKs.\n\nNote that registering a Namespace takes up to 15 seconds to complete. Ensure that you are waiting for this process to complete before making calls to the Namespace.\n\n### Manage Namespaces\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud/how-to-manage-namespaces-in-temporal-cloud) or [tcld commands](/cloud/tcld/namespace/) to manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can manage your registered Namespaces using tctl (recommended) or programmatically using APIs.\nNote that these APIs and tctl commands will not work with Temporal Cloud.\n\n- [How to manage Namespaces using the Go SDK](/go/manage-namespaces)\n- [How to manage Namespaces using the Java SDK](/java/manage-namespaces)\n\n- Update information and configuration for a registered Namespace on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace update`](/tctl-v1/namespace#update)\n  - Use the Update Namespace API to update configuration on a Namespace.\n\n- Get details for a registered Namespace on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace describe`](/tctl-v1/namespace#describe)\n  - Use the Describe Namespace to return information and configuration details for a registered Namespace.\n\n- Get details for all registered Namespaces on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace list`](/tctl-v1/namespace#list)\n  - Use the List Namespace API to return information and configuration details for all registered Namespaces on your Temporal Cluster.\n\n- Deprecate a Namespace: The Deprecate Namespace updates the state of a registered Namespace to \"DEPRECATED\". Once a Namespace is deprecated, you cannot start new Workflow Executions on it. All existing and running Workflow Executions on a deprecated Namespace will continue to run.\n\n- Delete a Namespace: Deletes a Namespace and all Workflow Executions on the Namespace. Note that this API is supported for Temporal Server version 1.17 and later.\n- With tctl: [`tctl namespace delete`](/cli/operator/namespace/delete).\n- Use the DeleteNamespace API to delete a registered Namespaces. All the running Workflow Executions on a deleted Namespace are also deleted.\n\n### Setting\n\nSet Namespaces in your SDK Client to isolate your Workflow Executions to the Namespace.\nIf you do not set a Namespace, all Workflow Executions started using the Client will be associated with the \"default\" Namespace. This means, you must have a default Namespace called \"default\" registered with your Temporal Cluster. See [Registration](#registration) for details.\n\n<!-- TODO add sample for this to link to -[How to set the Namespace for a Temporal Client](/) -->\n\n- [How to list Namespaces in a Cluster using tctl](/tctl-v1/namespace#list)\n- [How to view (describe) Namespace metadata and details using tctl](/tctl-v1/namespace#describe)\n","is_empty":false},{"file_name":"what-is-a-parent-close-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-parent-close-policy.md","id":"concepts/what-is-a-parent-close-policy","title":"What is a Parent Close Policy?","description":"If a Workflow Execution is a Child Workflow Execution, a Parent Close Policy determines what happens to the Workflow Execution if its Parent Workflow Execution changes to a Closed status (Completed, Failed, Timed out).","label":"Parent Close Policy","tags":["term","explanation","child-workflow-executions"],"ssdi":[],"markdown_content":"\nA Parent Close Policy determines what happens to a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) if its Parent changes to a Closed status (Completed, Failed, or Timed out).\n\n- [How to set a Parent Close Policy using the Go SDK](/go/parent-close-policy)\n- [How to set a Parent Close Policy using the Java SDK](/java/parent-close-policy)\n- [How to set a Parent Close Policy using the PHP SDK](/php/parent-close-policy)\n- [How to set a Parent Close Policy using the Python SDK](/python/parent-close-policy)\n- [How to set a Parent Close Policy using the TypeScript SDK](/typescript/parent-close-policy)\n\nThere are three possible values:\n\n- **Abandon**: the Child Workflow Execution is not affected.\n- **Request Cancel**: a Cancellation request is sent to the Child Workflow Execution.\n- **Terminate** (default): the Child Workflow Execution is forcefully Terminated.\n\n[`ParentClosePolicy`](https://github.com/temporalio/api/blob/c1f04d0856a3ba2995e92717607f83536b5a44f5/temporal/api/enums/v1/workflow.proto#L44) proto definition.\n\nEach Child Workflow Execution may have its own Parent Close Policy.\nThis policy applies only to Child Workflow Executions and has no effect otherwise.\n\n![Parent Close Policy entity relationship](/diagrams/parent-close-policy.svg)\n\nYou can set policies per child, which means you can opt out of propagating terminates / cancels on a per-child basis.\nThis is useful for starting Child Workflows asynchronously (see [relevant issue here](https://community.temporal.io/t/best-way-to-create-an-async-child-workflow/114) or the corresponding SDK docs).\n","is_empty":false},{"file_name":"what-is-a-payload-codec.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-payload-codec.md","id":"concepts/what-is-a-payload-codec","title":"What is a Payload Codec?","description":"A Payload Codec transforms an array of Payloads into another array of Payloads.","label":"Payload Codec","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Payload Codec transforms an array of [Payloads](/concepts/what-is-a-payload) (for example, a list of Workflow arguments) into another array of Payloads.\n\nThe Payload Codec is an optional step that happens between the wire and the [Payload Converter](/concepts/what-is-a-payload-converter):\n\n```bash\nUser code <--> Payload Converter <--> Payload Codec <--> Wire <--> Temporal Server\n```\n\nWhen serializing to Payloads, the Payload Converter is applied first to convert your objects to bytes, followed by codecs that convert bytes to bytes.\nWhen deserializing from Payloads, codecs are applied first to last to reverse the effect, followed by the Payload Converter.\n\nFor details, see the API references.\n\n- [Go](https://pkg.go.dev/go.temporal.io/sdk/converter#PayloadCodec)\n- [Java](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/payload/codec/PayloadCodec.html)\n- [Python](https://python.temporal.io/temporalio.converter.PayloadCodec.html)\n- [TypeScript](https://typescript.temporal.io/api/interfaces/common.PayloadCodec)\n\nUse a custom Payload Codec to transform your Payloads; for example, implementing compression and/or encryption on your Workflow Execution data.\n\n#### Encryption\n\nUsing end-to-end encryption in your custom Data Converter ensures that sensitive application data is secure when handled by the Temporal Server.\n\nApply your encryption logic in a custom Payload Codec and use it locally to encrypt data.\nYou maintain all the encryption keys, and the Temporal Server sees only encrypted data.\nYour data exists unencrypted only on the Client and the Worker process that is executing the Workflows and Activities, on hosts that you control.\n\nFor details, see [Securing your data](/production-readiness/develop#securing-your-data).\n\nThe following samples use encryption (AES GCM with 256-bit key) in a custom Data Converter:\n\n- [Go sample](https://github.com/temporalio/samples-go/tree/main/encryption)\n- [Java sample](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/encryptedpayloads)\n- [Python sample](https://github.com/temporalio/samples-python/tree/main/encryption)\n- [TypeScript sample](https://github.com/temporalio/samples-typescript/tree/main/encryption)\n","is_empty":false},{"file_name":"what-is-a-payload-converter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-payload-converter.md","id":"concepts/what-is-a-payload-converter","title":"What is a Payload Converter?","description":"A Payload Converter serializes data, converting objects or values to bytes and back.","label":"Payload Converter","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Payload Converter serializes data, converting values to bytes and back.\n\nWhen you request a Workflow Execution through your Client and pass a data input, the input is serialized using a Data Converter that runs it through a set of Payload Converters.\nWhen your Workflow Execution starts, this data input is deserialized and passed as input to your Workflow.\n\nFor more information, see the API references.\n\n- [Go](https://pkg.go.dev/go.temporal.io/sdk/converter#PayloadConverter)\n- [Java](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/PayloadConverter.html)\n- [Python](https://python.temporal.io/temporalio.converter.PayloadConverter.html)\n- [TypeScript](https://typescript.temporal.io/api/interfaces/common.PayloadConverter)\n\nFor supported values, see [default Data Converter](/dataconversion#default-data-converter).\n\n#### Custom payload conversion\n\nIf you use custom objects or types that are not supported by the Payload Converters provided in the SDKs, you can create a custom Payload Converter and configure the Data Converter with it to run the specific conversions.\n\nYou can set multiple encoding Payload Converters to run your conversions.\nWhen the Data Converter receives a value for conversion, it passes through each Payload Converter in sequence until the converter that handles the data type does the conversion.\n\nFor details on how to use the Payload Converter for custom data types, see Custom Payload Conversion in the following langauages:\n\n- [How to implement custom Payload convesion in Go](/go/custom-payload-conversion)\n- [How to implement custom Payload conversion in Java](/java/custom-payload-conversion)\n","is_empty":false},{"file_name":"what-is-a-payload.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-payload.md","id":"concepts/what-is-a-payload","title":"What is a Payload?","description":"A Payload represents binary data such as input and output from Activities and Workflows.","label":"Payload","tags":["term","payloads","explanation"],"ssdi":[],"markdown_content":"\nA [Payload](https://api-docs.temporal.io/#temporal.api.common.v1.Payload) represents binary data such as input and output from Activities and Workflows.\nPayloads contain metadata that describe the binary data, such as its data type or other arbitrary values for use by custom encoders/converters.\n\nWhen processed through the SDK, the [default Data Converter](/concepts/what-is-a-default-data-converter) serializes your data/value to a Payload before sending it to the Temporal Server.\nThe default Data Converter processes supported type values to Payloads, and you can create a custom [Payload Converter](/concepts/what-is-a-payload-converter) to convert your custom object types.\n\nYou can additionally apply [custom codecs](/concepts/what-is-a-payload-codec) (such as for encryption or compression) on your Payloads to wrap them into new encoded Payloads.\n","is_empty":false},{"file_name":"what-is-a-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-query.md","id":"concepts/what-is-a-query","title":"What is a Query?","description":"A Query is a synchronous operation that is used to report the state of a Workflow Execution.","label":"Query","tags":["term","queries","explanation"],"ssdi":[],"markdown_content":"\nA Query is a synchronous operation that is used to get the state of a [Workflow Execution](/workflows#workflow-execution).\nThe state of a running Workflow Execution is constantly changing.\nYou can use Queries to expose the internal Workflow Execution state to the external world.\nQueries are available for running or completed Workflows Executions only if the Worker is up and listening on the Task Queue.\n\n- [How to send a Query using tctl](/tctl-v1/workflow#query)\n- [How to send and handle Queries with the Go SDK](/go/queries)\n- [How to send and handle Queries with the Java SDK](/java/queries)\n- [How to send and handle Queries with the PHP SDK](/php/queries)\n- [How to send and handle Queries with the Python SDK](/python/queries)\n- [How to send and handle Queries with the TypeScript SDK](/typescript/queries)\n\nQueries are sent from a Temporal Client to a Workflow Execution.\nThe API call is synchronous.\nThe Query is identified at both ends by a Query name.\nThe Workflow must have a Query handler that is developed to handle that Query and provide data that represents the state of the Workflow Execution.\n\nQueries are strongly consistent and are guaranteed to return the most recent state.\nThis means that the data reflects the state of all confirmed Events that came in before the Query was sent.\nAn Event is considered confirmed if the call creating the Event returned success.\nEvents that are created while the Query is outstanding may or may not be reflected in the Workflow state the Query result is based on.\n\nA Query can carry arguments to specify the data it is requesting.\nAnd each Workflow can expose data to multiple types of Queries.\n\nA Query must never mutate the state of the Workflow Execution—that is, Queries are _read-only_ and cannot contain any blocking code.\nThis means, for example, that Query handling logic cannot schedule Activity Executions.\n\nSending Queries to completed Workflow Executions is supported, though Query reject conditions can be configured per Query.\n\n#### Stack Trace Query\n\nIn many SDKs, the Temporal Client exposes a predefined `__stack_trace` Query that returns the stack trace of all the threads owned by that Workflow Execution.\nThis is a great way to troubleshoot a Workflow Execution in production.\nFor example, if a Workflow Execution has been stuck at a state for longer than an expected period of time, you can send a `__stack_trace` Query to return the current call stack.\nThe `__stack_trace` Query name does not require special handling in your Workflow code.\n\n:::note\n\nStack Trace Queries are available only for running Workflow Executions.\n\n:::\n","is_empty":false},{"file_name":"what-is-a-reset.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-reset.md","id":"concepts/what-is-a-reset","title":"What is a Reset?","description":"A Reset terminates a Workflow Execution, removes the progress in the Event History up to the reset point, and then creates a new Workflow Execution with the same Workflow Type and Id to continue.","label":"Reset","tags":["term","resets","explanation"],"ssdi":[],"markdown_content":"\nA Reset terminates a [Workflow Execution](/workflows#workflow-execution), removes the progress in the [Event History](/workflows#event-history) up to the reset point, and then creates a new Workflow Execution with the same [Workflow Type](/workflows#workflow-type) and [Id](/workflows#workflow-id) to continue.\n","is_empty":false},{"file_name":"what-is-a-retention-period.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-retention-period.md","id":"concepts/what-is-a-retention-period","title":"What is a Retention Period?","description":"A Retention Period is the amount of time a Workflow Execution Event History remains in the Cluster's persistence store.","label":"Retention Period","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nRetention Period is the duration for which the Temporal Cluster stores data associated with closed Workflow Executions on a Namespace in the Persistence store.\n\n- [How to set the Retention Period for a Namespace](/tctl-v1/namespace#register)\n- [How to set the Retention Period for a Namespace using the Go SDK](/go/namespaces)\n- [How to set the Retention Period for a Namespace using the Java SDK](/java/namespaces)\n\nA Retention Period applies to all closed Workflow Executions within a [Namespace](/concepts/what-is-a-namespace) and is set when the Namespace is registered.\n\nThe Temporal Cluster triggers a Timer task at the end of the Retention Period that cleans up the data associated with the closed Workflow Execution on that Namespace.\n\nThe minimum Retention Period is 1 day.\nOn Temporal Cluster version 1.18 and later, the maximum Retention Period value for Namespaces can be set to anything over the minimum requirement of 1 day. Ensure that your Persistence store has enough capacity for the storage.\nOn Temporal Cluster versions 1.17 and earlier, the maximum Retention Period you can set is 30 days.\nSetting the Retention Period to 0 results in the error _A valid retention period is not set on request_.\n\nIf you don't set the Retention Period value when using the [`tctl namespace register`](/tctl-v1/namespace#register) command, it defaults to 3 days.\nIf you don't set the Retention Period value when using the Register Namespace Request API, it returns an error.\n\n<!-- TODO link up to working API usage examples -->\n","is_empty":false},{"file_name":"what-is-a-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-retry-policy.md","id":"concepts/what-is-a-retry-policy","title":"What is a Retry Policy?","description":"A Retry Policy is a collection of attributes that instructs the Temporal Server how to retry a failure of a Workflow Execution or an Activity Task Execution.","label":"Retry Policy","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Retry Policy is a collection of attributes that instructs the Temporal Server how to retry a failure of a [Workflow Execution](/workflows#workflow-execution) or an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n(Retry Policies do not apply to [Workflow Task Executions](/concepts/what-is-a-workflow-task-execution), which always retry indefinitely.)\n\n- [Activity retry simulator](/dev-guide/activity-retry-simulator)\n\n- [How to set a custom Retry Policy for an Activity in Go](/go/activity-retries)\n- [How to set a custom Retry Policy for an Activity in Java](/java/activity-retries)\n- [How to set a custom Retry Policy for an Activity in PHP](/php/activity-retries)\n- [How to set a custom Retry Policy for an Activity in Python](/python/activity-retries)\n- [How to set a custom Retry Policy for an Activity in TypeScript](/typescript/activity-retries)\n\n- [How to set a Retry Policy for a Workflow in Go](/go/workflow-retries)\n- [How to set a Retry Policy for a Workflow in Java](/java/workflow-retries)\n- [How to set a Retry Policy for a Workflow in PHP](/php/workflow-retries)\n- [How to set a Retry Policy for a Workflow in Python](/python/workflow-retries)\n- [How to set a Retry Policy for a Workflow in TypeScript](/typescript/workflow-retries)\n\n<!-- ![Diagram that shows the retry interval and its formula](/img/retry-interval-diagram.png) -->\n\n## Default behavior\n\n- **Workflow Execution**: When a Workflow Execution is spawned, it is not associated with a default Retry Policy and thus does not retry by default.\n  The intention is that a Workflow Definition should be written to never fail due to intermittent issues; an Activity is designed to handle such issues.\n\n- **Activity Execution**: When an Activity Execution is spawned, it is associated with a default Retry Policy, and thus Activity Task Executions are retried by default.\n  When an Activity Task Execution is retried, the Cluster places a new [Activity Task](/concepts/what-is-an-activity-task) into its respective [Activity Task Queue](/concepts/what-is-a-task-queue), which results in a new Activity Task Execution.\n\n## Custom Retry Policy\n\nTo use a custom Retry Policy, provide it as an options parameter when starting a Workflow Execution or Activity Execution.\nOnly certain scenarios merit starting a Workflow Execution with a custom Retry Policy, such as the following:\n\n- A [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) or some other stateless, always-running Workflow Execution that can benefit from retries.\n- A file-processing or media-encoding Workflow Execution that downloads files to a host.\n\n## Properties\n\n### Default values for Retry Policy\n\n```\nInitial Interval     = 1 second\nBackoff Coefficient  = 2.0\nMaximum Interval     = 100 × Initial Interval\nMaximum Attempts     = ∞\nNon-Retryable Errors = []\n```\n\n### Initial Interval\n\n- **Description**: Amount of time that must elapse before the first retry occurs.\n  - **The default value is 1 second.**\n- **Use case**: This is used as the base interval time for the [Backoff Coefficient](#backoff-coefficient) to multiply against.\n\n### Backoff Coefficient\n\n- **Description**: The value dictates how much the _retry interval_ increases.\n  - **The default value is 2.0.**\n  - A backoff coefficient of 1.0 means that the retry interval always equals the [Initial Interval](#initial-interval).\n- **Use case**: Use this attribute to increase the interval between retries.\n  By having a backoff coefficient greater than 1.0, the first few retries happen relatively quickly to overcome intermittent failures, but subsequent retries happen farther and farther apart to account for longer outages.\n  Use the [Maximum Interval](#maximum-interval) attribute to prevent the coefficient from increasing the retry interval too much.\n\n### Maximum Interval\n\n- **Description**: Specifies the maximum interval between retries.\n  - **The default value is 100 times the [Initial Interval](#initial-interval).**\n- **Use case**: This attribute is useful for [Backoff Coefficients](#backoff-coefficient) that are greater than 1.0 because it prevents the retry interval from growing infinitely.\n\n### Maximum Attempts\n\n- **Description**: Specifies the maximum number of execution attempts that can be made in the presence of failures.\n  - **The default is unlimited.**\n  - If this limit is exceeded, the execution fails without retrying again. When this happens an error is returned.\n  - Setting the value to 0 also means unlimited.\n  - Setting the value to 1 means a single execution attempt and no retries.\n  - Setting the value to a negative integer results in an error when the execution is invoked.\n- **Use case**: Use this attribute to ensure that retries do not continue indefinitely.\n  However, in the majority of cases, we recommend relying on the Workflow Execution Timeout, in the case of [Workflows](#workflow), or Schedule-To-Close Timeout, in the case of [Activities](#activity), to limit the total duration of retries instead of using this attribute.\n\n### Non-Retryable Errors\n\n- **Description**: Specifies errors that shouldn't be retried.\n  - **Default is none.**\n  - Errors are matched against the `type` field of the [Application Failure](/kb/failures#application-failure).\n  - If one of those errors occurs, a retry does not occur.\n- **Use case**: If you know of errors that should not trigger a retry, you can specify that, if they occur, the execution is not retried.\n\n## Retry interval\n\nThe wait time before a retry is the _retry interval_. A retry interval is the smaller of two values:\n\n- The [Initial Interval](#initial-interval) multiplied by the [Backoff Coefficient](#backoff-coefficient) raised to the power of the number of retries.\n- The [Maximum Interval](#maximum-interval).\n\n## Event History\n\nThere are some subtle nuances to how Events are recorded to an Event History when a Retry Policy comes into play.\n\n- For an Activity Execution, the [ActivityTaskStarted](/concepts/what-is-an-event#activitytaskstarted) Event will not show up in the Workflow Execution Event History until the Activity Execution has completed or failed (having exhausted all retries).\n  This is to avoid filling the Event History with noise.\n  Use the Describe API to get a pending Activity Execution's attempt count.\n\n- For a Workflow Execution with a Retry Policy, if the Workflow Execution fails, the Workflow Execution will [Continue-As-New](/concepts/what-is-continue-as-new) and the associated Event is written to the Event History.\n  The [WorkflowExecutionContinuedAsNew](/concepts/what-is-an-event#workflowexecutioncontinuedasnew) Event will have an \"initiator\" field that will specify the Retry Policy as the value and the new Run Id for the next retry attempt.\n  The new Workflow Execution is created immediately.\n  But the first Workflow Task won't be scheduled until the backoff duration is exhausted.\n  That duration is recorded as the `firstWorkflowTaskBackoff` field of the new run's `WorkflowExecutionStartedEventAttributes` event.\n","is_empty":false},{"file_name":"what-is-a-run-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-run-id.md","id":"concepts/what-is-a-run-id","title":"What is a Run Id?","description":"A Run Id is a globally unique, platform-level identifier for a Workflow Execution.","label":"Run Id","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Run Id is a globally unique, platform-level identifier for a [Workflow Execution](/workflows#workflow-execution).\n\nTemporal guarantees that only one Workflow Execution with a given [Workflow Id](/concepts/what-is-a-workflow-id) can be in an Open state at any given time.\nBut when a Workflow Execution reaches a Closed state, it is possible to have another Workflow Execution in an Open state with the same Workflow Id.\nFor example, a Temporal Cron Job is a chain of Workflow Executions that all have the same Workflow Id.\nEach Workflow Execution within the chain is considered a _Run_.\n\nA Run Id uniquely identifies a Workflow Execution even if it shares a Workflow Id with other Workflow Executions.\n\n:::caution\n\nDon't rely on storing the current Run Id or using it for any logical choices.\nA Workflow Retry changes the Run Id.\nBecause the current Run Id is mutable, relying on it might produce non-determinism issues.\n\n:::\n\n**Learn more**\n\nFor more information, see the following links.\n\n- [`message.proto`](https://github.com/temporalio/api/blob/master/temporal/api/history/v1/message.proto#L75-L82)\n- [Non-determinism issues for Run Ids](/kb/non-determinism-issues-for-run-ids)\n","is_empty":false},{"file_name":"what-is-a-schedule-to-close-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-schedule-to-close-timeout.md","id":"concepts/what-is-a-schedule-to-close-timeout","title":"What is a Schedule-To-Close Timeout?","description":"A Schedule-To-Close Timeout is the maximum amount of time allowed for the overall Activity Execution, from when the first Activity Task is scheduled to when the last Activity Task, in the chain of Activity Tasks that make up the Activity Execution, reaches a Closed status.","label":"Schedule-To-Close Timeout","tags":["term","explanation","timeouts"],"ssdi":[],"markdown_content":"\nA Schedule-To-Close Timeout is the maximum amount of time allowed for the overall [Activity Execution](/concepts/what-is-an-activity-execution), from when the first [Activity Task](/concepts/what-is-an-activity-task) is scheduled to when the last Activity Task, in the chain of Activity Tasks that make up the Activity Execution, reaches a Closed status.\n\n- [How to set a Schedule-To-Close Timeout using the Go SDK](/go/activity-timeouts)\n- [How to set a Schedule-To-Close Timeout using the Java SDK](/java/activity-timeouts)\n- [How to set a Schedule-To-Close Timeout using the PHP SDK](/go/activity-timeouts)\n- [How to set a Schedule-To-Close Timeout using the Python SDK](/go/activity-timeouts)\n- [How to set a Schedule-To-Close Timeout using the TypeScript SDK](/typescript/activity-timeouts)\n\n![Schedule-To-Close Timeout period](/diagrams/schedule-to-close-timeout.svg)\n\nExample Schedule-To-Close Timeout period for an Activity Execution that has a chain Activity Task Executions:\n\n![Schedule-To-Close Timeout period with a retry](/diagrams/schedule-to-close-timeout-with-retry.svg)\n\n**The default Schedule-To-Close Timeout is ∞ (infinity).**\n\nAn Activity Execution must have either this timeout (Schedule-To-Close) or [Start-To-Close](/concepts/what-is-a-start-to-close-timeout) set.\nBy default, an Activity Execution Retry Policy dictates that retries occur for up to 10 years.\nThis timeout can be used to control the overall duration of an Activity Execution in the face of failures (repeated Activity Task Executions), without altering the Maximum Attempts field of the Retry Policy.\n\n:::tip\n\nWe strongly recommend setting a Start-To-Close Timeout.\n\nThe Temporal Server doesn't detect failures when a Worker loses communication with the Server or crashes.\nTherefore, the Temporal Server relies on the Start-To-Close Timeout to force Activity retries.\n\n:::\n","is_empty":false},{"file_name":"what-is-a-schedule-to-start-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-schedule-to-start-timeout.md","id":"concepts/what-is-a-schedule-to-start-timeout","title":"What is a Schedule-To-Start Timeout?","description":"A Schedule-To-Start Timeout is the maximum amount of time that is allowed from when an Activity Task is placed in a Task Queue to when a Worker picks it up from the Task Queue.","label":"Schedule-To-Start Timeout","tags":["term","explanation","timeouts"],"ssdi":[],"markdown_content":"\nA Schedule-To-Start Timeout is the maximum amount of time that is allowed from when an [Activity Task](/concepts/what-is-an-activity-task) is scheduled (that is, placed in a Task Queue) to when a [Worker](/concepts/what-is-a-worker) starts (that is, picks up from the Task Queue) that Activity Task.\nIn other words, it's a limit for how long an Activity Task can be enqueued.\n\n- [How to set a Schedule-To-Start Timeout using the Go SDK](/go/activity-timeouts)\n- [How to set a Schedule-To-Start Timeout using the Java SDK](/java/activity-timeouts)\n- [How to set a Schedule-To-Start Timeout using the PHP SDK](/php/activity-timeouts)\n- [How to set a Schedule-To-Start Timeout using the Python SDK](/python/activity-timeouts)\n- [How to set a Schedule-To-Start Timeout using the TypeScript SDK](/typescript/activity-timeouts)\n\nThe moment that the Task is picked by the Worker from the Task Queue is considered to be the start of the Activity Task for the purposes of the Schedule-To-Start Timeout and associated metrics.\nThis definition of \"Start\" avoids issues that a clock difference between the Temporal Cluster and a Worker might create.\n\n![Schedule-To-Start Timeout period](/diagrams/schedule-to-start-timeout.svg)\n\n\"Schedule\" in Schedule-To-Start and Schedule-To-Close have different frequency guarantees.\n\nThe Schedule-To-Start Timeout is enforced for each Activity Task, whereas the Schedule-To-Close Timeout is enforced once per Activity Execution.\nThus, \"Schedule\" in Schedule-To-Start refers to the scheduling moment of _every_ Activity Task in the sequence of Activity Tasks that make up the Activity Execution, while\n\"Schedule\" in Schedule-To-Close refers to the _first_ Activity Task in that sequence.\n\nA [Retry Policy](/concepts/what-is-a-retry-policy) attached to an Activity Execution retries an Activity Task.\n\n![Start-To-Close Timeout period with retries](/diagrams/schedule-to-start-timeout-with-retry.svg)\n\nThis timeout has two primary use cases:\n\n1. Detect whether an individual Worker has crashed.\n2. Detect whether the fleet of Workers polling the Task Queue is not able to keep up with the rate of Activity Tasks.\n\n**The default Schedule-To-Start Timeout is ∞ (infinity).**\n\nIf this timeout is used, we recommend setting this timeout to the maximum time a Workflow Execution is willing to wait for an Activity Execution in the presence of all possible Worker outages, and have a concrete plan in place to reroute Activity Tasks to a different Task Queue.\nThis timeout **does not** trigger any retries regardless of the Retry Policy, as a retry would place the Activity Task back into the same Task Queue.\nWe do not recommend using this timeout unless you know what you are doing.\n\nIn most cases, we recommend monitoring the `temporal_activity_schedule_to_start_latency` metric to know when Workers slow down picking up Activity Tasks, instead of setting this timeout.\n","is_empty":false},{"file_name":"what-is-a-schedule.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-schedule.md","id":"concepts/what-is-a-schedule","title":"What is a Schedule","description":"A Schedule enables the scheduling of Workflow Executions.","label":"Schedule","tags":["term","explanation"],"ssdi":["Introduced in Temporal Server version 1.17.0","Available in Temporal CLI (and tctl v1.17)","Available in Temporal Cloud in Public Preview","Available in [Go SDK](/dev-guide/go/features#schedule-a-workflow) version [1.22.0](https://github.com/temporalio/sdk-go/releases/tag/v1.22.0)","Available in [Java SDK](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/schedules/package-summary.html) version [1.20.0](https://github.com/temporalio/sdk-java/releases/tag/v1.20.0)","Available in [Python SDK](/dev-guide/python/features#schedule-a-workflow) version [1.1.0](https://github.com/temporalio/sdk-python/releases/tag/1.1.0)","Available in [TypeScript SDK](https://github.com/temporalio/samples-typescript/tree/main/schedules#schedules) version [1.5.0](https://github.com/temporalio/sdk-typescript/blob/main/CHANGELOG.md#150---2022-12-07)","Available in [.NET SDK](https://dotnet.temporal.io/api/Temporalio.Client.Schedules.html) version [0.1.0](https://github.com/temporalio/sdk-dotnet/releases/tag/0.1.0-alpha4)","Available in [gRPC API](https://api-docs.temporal.io/#temporal.api.workflowservice.v1.CreateScheduleRequest)"],"markdown_content":"\nA Schedule contains instructions for starting a [Workflow Execution](/workflows#workflow-execution) at specific times.\nSchedules provide a more flexible and user-friendly approach than [Temporal Cron Jobs](/concepts/what-is-a-temporal-cron-job).\n\n- [How to enable Schedules](#limitations)\n- [How to operate Schedules using tctl](/tctl-v1/schedule#)\n\nA Schedule has an identity and is independent of a Workflow Execution.\nThis differs from a Temporal Cron Job, which relies on a cron schedule as a property of the Workflow Execution.\n\n### Action\n\nThe Action of a Schedule is where the Workflow Execution properties are established, such as Workflow Type, Task Queue, parameters, and timeouts.\n\nWorkflow Executions started by a Schedule have the following additional properties:\n\n- The Action's timestamp is appended to the Workflow Id.\n- The `TemporalScheduledStartTime` [Search Attribute](/concepts/what-is-a-search-attribute) is added to the Workflow Execution.\n  The value is the Action's timestamp.\n- The `TemporalScheduledById` Search Attribute is added to the Workflow Execution.\n  The value is the Schedule Id.\n\n### Spec\n\nThe Schedule Spec describes when the Action is taken.\nThere are two kinds of Schedule Spec:\n\n- A simple interval, like \"every 30 minutes\" (aligned to start at the Unix epoch, and optionally including a phase offset).\n- A calendar-based expression, similar to the \"cron expressions\" supported by lots of software, including the older Temporal Cron feature.\n\nThese two kinds have multiple representations, depending on the interface or SDK you're using, but they all support the same features.\n\nIn tctl, for example, an interval is specified as a string like `45m` to mean every 45 minutes, or `6h/5h` to mean every 6 hours but at the start of the fifth hour within each period.\n\nIn tctl, a calendar expression can be specified as either a traditional cron string with five (or six or seven) positional fields, or as JSON with named fields:\n\n```json\n{\n  \"year\": \"2022\",\n  \"month\": \"Jan,Apr,Jul,Oct\",\n  \"dayOfMonth\": \"1,15\",\n  \"hour\": \"11-14\"\n}\n```\n\nThe following calendar JSON fields are available:\n\n- `year`\n- `month`\n- `dayOfMonth`\n- `dayOfWeek`\n- `hour`\n- `minute`\n- `second`\n- `comment`\n\nEach field can contain a comma-separated list of ranges (or the `*` wildcard), and each range can include a slash followed by a skip value.\nThe `hour`, `minute`, and `second` fields default to `0` while the others default to `*`, so you can describe many useful specs with only a few fields.\n\nFor `month`, names of months may be used instead of integers (case-insensitive, abbreviations permitted).\nFor `dayOfWeek`, day-of-week names may be used.\n\nThe `comment` field is optional and can be used to include a free-form description of the intent of the calendar spec, useful for complicated specs.\n\nNo matter which form you supply, calendar and interval specs are converted to canonical representations.\nWhat you see when you \"describe\" or \"list\" a Schedule might not look exactly like what you entered, but it has the same meaning.\n\nOther Spec features:\n\n**Multiple intervals/calendar expressions:** A Spec can have combinations of multiple intervals and/or calendar expressions to define a specific Schedule.\n\n**Time bounds:** Provide an absolute start or end time (or both) with a Spec to ensure that no actions are taken before the start time or after the end time.\n\n**Exclusions:** A Spec can contain exclusions in the form of zero or more calendar expressions.\nThis can be used to express scheduling like \"each Monday at noon except for holidays.\nYou'll have to provide your own set of exclusions and include it in each schedule; there are no pre-defined sets.\n(This feature isn't currently exposed in tctl or the Temporal Web UI.)\n\n**Jitter:** If given, a random offset between zero and the maximum jitter is added to each Action time (but bounded by the time until the next scheduled Action).\n\n**Time zones:** By default, calendar-based expressions are interpreted in UTC.\nTemporal recommends using UTC to avoid various surprising properties of time zones.\nIf you don't want to use UTC, you can provide the name of a time zone.\nThe time zone definition is loaded on the Temporal Server Worker Service from either disk or the fallback embedded in the binary.\n\nFor more operational control, embed the contents of the time zone database file in the Schedule Spec itself.\n(Note: this isn't currently exposed in tctl or the web UI.)\n\n### Pause\n\nA Schedule can be Paused.\nWhen a Schedule is Paused, the Spec has no effect.\nHowever, you can still force manual actions by using the [tctl schedule trigger](/tctl-v1/schedule#trigger) command.\n\nTo assist communication among developers and operators, a “notes” field can be updated on pause or resume to store an explanation for the current state.\n\n### Backfill\n\nA Schedule can be Backfilled.\nWhen a Schedule is Backfilled, all the Actions that would have been taken over a specified time period are taken now (in parallel if the `AllowAll` [Overlap Policy](#overlap-policy) is used; sequentially if `BufferAll` is used).\nYou might use this to fill in runs from a time period when the Schedule was paused due to an external condition that's now resolved, or a period before the Schedule was created.\n\n### Limit number of Actions\n\nA Schedule can be limited to a certain number of scheduled Actions (that is, not trigger immediately).\nAfter that it will act as if it were paused.\n\n### Policies\n\nA Schedule supports a set of Policies that enable customizing behavior.\n\n#### Overlap Policy\n\nThe Overlap Policy controls what happens when it is time to start a Workflow Execution but a previously started Workflow Execution is still running.\nThe following options are available:\n\n- `Skip`: **Default**.\n  Nothing happens; the Workflow Execution is not started.\n- `BufferOne`: Starts the Workflow Execution as soon as the current one completes.\n  The buffer is limited to one.\n  If another Workflow Execution is supposed to start, but one is already in the buffer, only the one in the buffer eventually starts.\n- `BufferAll`: Allows an unlimited number of Workflows to buffer.\n  They are started sequentially.\n- `CancelOther`: Cancels the running Workflow Execution, and then starts the new one after the old one completes cancellation.\n- `TerminateOther`: Terminates the running Workflow Execution and starts the new one immediately.\n- `AllowAll` Starts any number of concurrent Workflow Executions.\n  With this policy (and only this policy), more than one Workflow Execution, started by the Schedule, can run simultaneously.\n\n#### Catchup Window\n\nThe Temporal Cluster might be down or unavailable at the time when a Schedule should take an Action.\nWhen it comes back up, the Catchup Window controls which missed Actions should be taken at that point.\nThe default is one minute, which means that the Schedule attempts to take any Actions that wouldn't be more than one minute late.\nAn outage that lasts longer than the Catchup Window could lead to missed Actions.\n(But you can always [Backfill](#backfill).)\n\n#### Pause-on-failure\n\nIf this policy is set, a Workflow Execution started by a Schedule that ends with a failure or timeout (but not Cancellation or Termination) causes the Schedule to automatically pause.\n\nNote that with the `AllowAll` Overlap Policy, this pause might not apply to the next Workflow Execution, because the next Workflow Execution might have started before the failed one finished.\nIt applies only to Workflow Executions that were scheduled to start after the failed one finished.\n\n### Last completion result\n\nA Workflow started by a Schedule can obtain the completion result from the most recent successful run.\n(How you do this depends on the SDK you're using.)\n\nFor overlap policies that don't allow overlap, “the most recent successful run” is straightforward to define.\nFor the `AllowAll` policy, it refers to the run that completed most recently, at the time that the run in question is started.\nConsider the following overlapping runs:\n\n```\ntime -------------------------------------------->\n A     |----------------------|\n B               |-------|\n C                          |---------------|\n D                                |--------------T\n```\n\nIf D asks for the last completion result at time T, it gets the result of A.\nNot B, even though B started more recently, because A completed later.\nAnd not C, even though C completed after A, because the result for D is captured when D is started, not when it's queried.\n\nFailures and timeouts do not affect the last completion result.\n\n### Last failure\n\nA Workflow started by a Schedule can obtain the details of the failure of the most recent run that ended at the time when the Workflow in question was started. Unlike last completion result, a _successful_ run _does_ reset the last failure.\n\n### Limitations\n\nInternally, a Schedule is implemented as a Workflow.\nIf you're using Advanced Visibility (Elasticsearch), these Workflow Executions are hidden from normal views.\nIf you're using Standard Visibility, they are visible, though there's no need to interact with them directly.\n","is_empty":false},{"file_name":"what-is-a-search-attribute.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-search-attribute.md","id":"concepts/what-is-a-search-attribute","title":"What is a Search Attribute?","description":"A Search Attribute is an indexed name used in List Filters to filter a list of Workflow Executions that have the Search Attribute in their metadata.","label":"Search Attribute","tags":["term","explanation","filtered-lists","visibility"],"ssdi":[],"markdown_content":"\nA Search Attribute is an indexed field used in a [List Filter](/concepts/what-is-a-list-filter) to filter a list of [Workflow Executions](/workflows#workflow-execution) that have the Search Attribute in their metadata.\n\nEach Search Attribute is a key-value pair metadata object and is part of the Workflow Execution visibility information, stored in the Visibility store. Use Search Attributes for metadata and search purposes only, not business logic.\n\nTemporal provides some [default Search Attributes](#default-search-attributes), such as `ExecutionStatus` of your Workflow Execution.\nYou can also create [custom Search Attribute](#custom-search-attributes) keys in your Visibility store and assign values in a Workflow Execution.\n\nSearch Attribute values are assigned to a specific Workflow Execution and are available for that execution only for the duration of the specified Namespace [Retention Period](/concepts/what-is-a-retention-period).\n\nNote that Search Attribute values are not encrypted because the Temporal Server must be able to read these values from the Visibility store when retrieving Workflow Execution details.\n\nWhen using [Continue-As-New](/concepts/what-is-continue-as-new) or a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job), Search Attributes are carried over to the new Workflow Run by default.\n\n### Default Search Attributes\n\nA Temporal Cluster has a set of default Search Attributes already available.\nDefault Search Attributes are set globally in any Namespace.\nThese Search Attributes are created when the initial index is created.\n\n| NAME                       | TYPE         | DEFINITION                                                                                                                                                                                                   |\n| -------------------------- | ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| BatcherUser                | Keyword      | Used by internal batcher Workflow that runs in `TemporalBatcher` Namespace division to indicate the user who started the batch operation.                                                                    |\n| BinaryChecksums            | Keyword      | List of binary Ids of Workers that run the Workflow Execution. Deprecated since server version 1.21 in favor of the `BuildIds` search attribute.                                                             |\n| BuildIds                   | Keyword List | List of Worker Build Ids that have processed the Workflow Execution, formatted as `versioned:{BuildId}` or `unversioned:{BuildId}`, or the sentinel `unversioned` value. Available from server version 1.21. |\n| CloseTime                  | Datetime     | The time at which the Workflow Execution completed.                                                                                                                                                          |\n| ExecutionDuration          | Int          | The time needed to run the Workflow Execution (in nanoseconds). Available only for closed Workflows.                                                                                                         |\n| ExecutionStatus            | Keyword      | The current state of the Workflow Execution.                                                                                                                                                                 |\n| ExecutionTime              | Datetime     | The time at which the Workflow Execution actually begins running; same as `StartTime` for most cases but different for Cron Workflows and retried Workflows.                                                 |\n| HistoryLength              | Int          | The number of events in the history of Workflow Execution. Available only for closed Workflows.                                                                                                              |\n| HistorySizeBytes           | Long         | The size of the Event History.                                                                                                                                                                               |\n| RunId                      | Keyword      | Identifies the current Workflow Execution Run.                                                                                                                                                               |\n| StartTime                  | Datetime     | The time at which the Workflow Execution started.                                                                                                                                                            |\n| StateTransitionCount       | Int          | The number of times that Workflow Execution has persisted its state. Available only for closed Workflows.                                                                                                    |\n| TaskQueue                  | Keyword      | Task Queue used by Workflow Execution.                                                                                                                                                                       |\n| TemporalChangeVersion      | Keyword      | Stores change/version pairs if the GetVersion API is enabled.                                                                                                                                                |\n| TemporalScheduledStartTime | Datetime     | The time that the Workflow is schedule to start according to the Schedule Spec. Can be manually triggered. Set on Schedules.                                                                                 |\n| TemporalScheduledById      | Keyword      | The Id of the Schedule that started the Workflow.                                                                                                                                                            |\n| TemporalSchedulePaused     | Boolean      | Indicates whether the Schedule has been paused. Set on Schedules.                                                                                                                                            |\n| WorkflowId                 | Keyword      | Identifies the Workflow Execution.                                                                                                                                                                           |\n| WorkflowType               | Keyword      | The type of Workflow.                                                                                                                                                                                        |\n\n- All default Search Attributes are reserved and read-only.\n  You cannot create a custom one with the same name or alter the existing one.\n\n- ExecutionStatus values correspond to Workflow Execution statuses: Running, Completed, Failed, Canceled, Terminated, ContinuedAsNew, TimedOut.\n\n- StartTime, CloseTime, and ExecutionTime are stored as dates but are supported by queries that use either EpochTime in nanoseconds or a string in [RFC3339Nano format](https://pkg.go.dev/time#pkg-constants) (such as \"2006-01-02T15:04:05.999999999Z07:00\").\n\n- ExecutionDuration is stored in nanoseconds but is supported by queries that use integers in nanoseconds, [Golang duration format](https://pkg.go.dev/time#ParseDuration), or \"hh:mm:ss\" format.\n\n- CloseTime, HistoryLength, StateTransitionCount, and ExecutionDuration are present only in a closed Workflow Execution.\n\n- ExecutionTime can differ from StartTime in retry and cron use cases.\n\nYou can use the default Search Attributes in a List Filter, such as in the Temporal Web UI or with the `tctl workflow list` commands, under the following conditions:\n\n- Without advanced Visibility, you can only use the `=` operator with a single default Search Attribute in your List Filter.\n  For example: `tctl workflow list -q \"ExecutionStatus = 'Completed'\"` or `tctl workflow list -q \"WorkflowType = 'YourWorkflow'\"`.\n- With advanced Visibility, you can combine default Search Attributes in a List Filter to get a list of specific Workflow Executions.\n  For example: `tctl workflow list -q \"WorkflowType = 'main.YourWorkflowDefinition' and ExecutionStatus != 'Running' and (StartTime > '2022-06-07T16:46:34.236-08:00' or CloseTime < '2022-06-08T16:46:34-08:00')\"`\n\n### Custom Search Attributes\n\nYou can [create custom Search Attributes](/clusters/how-to-create-custom-search-attribute-keys) with unique key names that are relevant to your business needs.\n\nUse custom Search Attributes in a List Filter, such as in the Temporal Web UI or with the `tctl workflow list` commands, under the following conditions:\n\n- Without advanced Visibility, you cannot use a custom Search Attribute in your List Filter.\n- With advanced Visibility, you can create multiple custom Search Attributes and use them in combinations with List Filters to get a list of specific Workflow Executions.\n  For example: `tctl workflow list -q \"WorkflowType = 'main.YourWorkflowDefinition' and YourCustomSA = 'YourCustomSAValue' and (StartTime > '2022-06-07T16:46:34.236-08:00' or CloseTime < '2022-06-08T16:46:34-08:00')\"`\n  - With Temporal Server v1.19 and earlier, you must [integrate Elasticsearch](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster) to use custom Search Attributes with List Filters.\n  - With Temporal Server v1.20 and later, custom Search Attribute capabilities are available on MySQL (v8.0.17 or later), PostgreSQL (v12 and later), and SQLite (v3.31.0 and later), in addition to Elasticsearch.\n\nIf you use Elasticsearch as your Visibility store, your custom Search Attributes apply globally and can be used across Namespaces.\nHowever, if using any of the [supported SQL databases](/cluster-deployment-guide#visibility-store) with Temporal Server v1.20 and later, your custom Search Attributes are associated with a specific Namespace and can be used for Workflow Executions in that Namespace.\n\nSee [custom Search Attributes limits](#custom-search-attributes-limits) for limits on the number and size of custom Search Attributes you can create.\n\n#### Supported types\n\nCustom Search Attributes must be one of the following types:\n\n- Bool\n- Datetime\n- Double\n- Int\n- Keyword\n- KeywordList\n- Text\n\nNote:\n\n- **Double** is backed up by `scaled_float` Elasticsearch type with scale factor 10000 (4 decimal digits).\n- **Datetime** is backed up by `date` type with milliseconds precision in Elasticsearch 6 and `date_nanos` type with nanoseconds precision in Elasticsearch 7.\n- **Int** is 64-bit integer (`long` Elasticsearch type).\n- **Keyword** and **Text** types are concepts taken from Elasticsearch. Each word in a **Text** is considered a searchable keyword.\n  For a UUID, that can be problematic because Elasticsearch indexes each portion of the UUID separately.\n  To have the whole string considered as a searchable keyword, use the **Keyword** type.\n  For example, if the key `ProductId` has the value of `2dd29ab7-2dd8-4668-83e0-89cae261cfb1`:\n  - As a **Keyword** it would be matched only by `ProductId = \"2dd29ab7-2dd8-4668-83e0-89cae261cfb1`.\n  - As a **Text** it would be matched by `ProductId = 2dd8`, which could cause unwanted matches.\n- With Temporal Server v1.19 and earlier, the **Keyword** type can store a list of values.\n- With Temporal Server v1.20 and later, the **Keyword** type supports only a single value.\n  To store a list of values, use **KeywordList**.\n- The **Text** type cannot be used in the \"Order By\" clause.\n\n#### Custom Search Attributes limits\n\n<!-- TODO - [How to configure maximum number of Search Attribute keys per Cluster](#) -->\n\nThe following table lists the maximum number of custom Search Attributes you can create per Namespace by supported Visibility database.\n\n| Search Attribute type | MySQL (v8.0.17 and later) | PostgreSQL (v12 and later) | SQLite (v3.31.0 and later) | Temporal Cloud |\n| --------------------- | :-----------------------: | :------------------------: | :------------------------: | :------------: |\n| Bool                  |             3             |             3              |             3              |       20       |\n| Datetime              |             3             |             3              |             3              |       20       |\n| Double                |             3             |             3              |             3              |       20       |\n| Int                   |             3             |             3              |             3              |       20       |\n| Keyword               |            10             |             10             |             10             |       20       |\n| KeywordList           |             3             |             3              |             3              |       20       |\n| Text                  |             3             |             3              |             3              |       5        |\n\nTemporal does not impose a limit on the number of custom Search Attributes you can create with Elasticsearch. However, [Elasticsearch sets a default mapping limit](https://www.elastic.co/guide/en/elasticsearch/reference/8.6/mapping-settings-limit.html) that may apply.\nCustom Search Attributes are an advanced Visibility feature and are not supported on Cassandra.\n\nSize limits for a custom Search Attribute:\n\n<!--\n_This refers to the SA key you create in the visibility store with `tctl search-attribute create`. this value is no longer applicable so commenting out for ref later_\nDefault total maximum number of Search Attribute **keys** per Temporal Cluster is 100.-->\n\n- The default single Search Attribute **value** size limit is 2 KB.\n\n<!-- TODO - [How to configure Search Attribute value size limit](#) -->\n\n- The maximum total Search Attribute size is 40 KB.\n\n<!-- TODO - [How to configure total Search Attribute size limite](#) -->\n\n- The maximum total characters per Search Attribute value is 255.\n\n<!-- temp keeping for reference\nThis is configurable with [`SearchAttributesNumberOfKeysLimit`, `SearchAttributesTotalSizeLimit` and `SearchAttributesSizeOfValueLimit`](https://github.com/temporalio/temporal/blob/v1.7.0/service/history/configs/config.go#L440-L442), if you know what you are doing.\n-->\n\n### Usage\n\nSearch Attributes available in your Visibility store can be used with Workflow Executions for that Cluster.\nTo actually have results from the use of a [List Filter](/concepts/what-is-a-list-filter), Search Attributes must be added to a Workflow Execution as metadata.\n\n- To create custom Search Attributes in your Visibility store, see [Create custom Search Attributes](/clusters/how-to-create-custom-search-attribute-keys).\n- To remove a custom Search Attribute from the Visbility store, see [Remove custom Search Attributes](/clusters/how-to-remove-a-custom-search-attribute-key).\n  Removing custom Search Attributes is not supported on Temporal Cloud.\n- To rename a custom Search Attribute on Temporal Cloud, see [`tcld namespace search-attributes rename`](/cloud/tcld/namespace#rename).\n\nWith Workflows you can do the following:\n\n- Set the value of Search Attributes in your Workflow\n- Update the value set for a Search Attribute from within the Workflow code\n- Remove the value set for a Search Attribute from within the Workflow code\n\n- [How to manage Search Attributes using the Go SDK](/go/visibility)\n- [How to manage Search Attributes using the Java SDK](/java/visibility)\n- [How to manage Search Attributes using the PHP SDK](/php/visibility)\n- [How to manage Search Attributes using the Python SDK](/python/visibility)\n- [How to manage Search Attributes using the TypeScript SDK](/typescript/visibility)\n\n- To get a list of Search Attributes using `tctl`, see [How to view Search Attributes using tctl](/tctl-v1/cluster#get-search-attributes).\n\nAfter you add and set your Search Attributes, use your default or custom Search Attributes in a List Filter.\n\n<!-- commenting out this part. added this detail in how to create a custom search attribute under clusters.\nThe [temporalio/auto-setup](https://hub.docker.com/r/temporalio/auto-setup) Docker image uses a pre-defined set of custom Search Attributes that are handy for testing.\nTheir names indicate their types:\n\n- CustomBoolField\n- CustomDatetimeField\n- CustomDoubleField\n- CustomIntField\n- CustomKeywordField\n- CustomTextField\n-->\n","is_empty":false},{"file_name":"what-is-a-side-effect.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-side-effect.md","id":"concepts/what-is-a-side-effect","title":"What is a Side Effect?","description":"A Side Effect is a way to execute a short, non-deterministic code snippet, such as generating a UUID, that executes the provided function once and records its result into the Workflow Execution Event History.","label":"Side Effect","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Side Effect is a way to execute a short, non-deterministic code snippet, such as generating a UUID, that executes the provided function once and records its result into the Workflow Execution Event History.\n\nA Side Effect does not re-execute upon replay, but instead returns the recorded result.\n\nDo not ever have a Side Effect that could fail, because failure could result in the Side Effect function executing more than once.\nIf there is any chance that the code provided to the Side Effect could fail, use an Activity.\n","is_empty":false},{"file_name":"what-is-a-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-signal.md","id":"concepts/what-is-a-signal","title":"What is a Signal?","description":"A Signal is an asynchronous request to a Workflow Execution.","label":"Signal","tags":["term","signals","explanation"],"ssdi":[],"markdown_content":"\nA Signal is an asynchronous request to a [Workflow Execution](/workflows#workflow-execution).\n\n- [How to send a Signal using tctl](/tctl-v1/workflow#signal)\n- [How to develop, send, and handle Signals in Go](/go/signals)\n- [How to develop, send, and handle Signals in Java](/java/signals)\n- [How to develop, send, and handle Signals in PHP](/php/signals)\n- [How to develop, send, and handle Signals in Python](/python/signals)\n- [How to develop, send, and handle Signals in TypeScript](/typescript/signals)\n\nA Signal delivers data to a running Workflow Execution.\nIt cannot return data to the caller; to do so, use a [Query](#queries) instead.\nThe Workflow code that handles a Signal can mutate Workflow state.\nA Signal can be sent from a Temporal Client or a Workflow.\nWhen a Signal is sent, it is received by the Cluster and recorded as an Event to the Workflow Execution [Event History](#event-history).\nA successful response from the Cluster means that the Signal has been persisted and will be delivered at least once to the Workflow Execution.[^1]\nThe next scheduled Workflow Task will contain the Signal Event.\n\nA Signal must include a destination (Namespace and Workflow Id) and name.\nIt can include a list of arguments.\n\nSignal handlers are Workflow functions that listen for Signals by the Signal name.\nSignals are delivered in the order they are received by the Cluster.\nIf multiple deliveries of a Signal would be a problem for your Workflow, add idempotency logic to your Signal handler that checks for duplicates.\n\n[^1]: The Cluster usually deduplicates Signals, but does not guarantee deduplication: During shard migration, two Signal Events (and therefore two deliveries to the Workflow Execution) can be recorded for a single Signal because the deduping info is stored only in memory.\n","is_empty":false},{"file_name":"what-is-a-start-to-close-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-start-to-close-timeout.md","id":"concepts/what-is-a-start-to-close-timeout","title":"What is a Start-To-Close Timeout?","description":"A Start-To-Close Timeout is the maximum time allowed for a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["term","explanation","timeouts"],"ssdi":[],"markdown_content":"\nA Start-To-Close Timeout is the maximum time allowed for a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n\n- [How to set a Start-To-Close Timeout using the Go SDK](/go/activity-timeouts)\n- [How to set a Start-To-Close Timeout using the Java SDK](/java/activity-timeouts)\n- [How to set a Start-To-Close Timeout using the PHP SDK](/php/activity-timeouts)\n- [How to set a Start-To-Close Timeout using the Python SDK](/python/activity-timeouts)\n- [How to set a Start-To-Close Timeout using the TypeScript SDK](/typescript/activity-timeouts)\n\n**The default Start-To-Close Timeout is the same as the default [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout).**\n\nAn Activity Execution must have either this timeout (Start-To-Close) or the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) set.\nWe recommend always setting this timeout; however, make sure that Start-To-Close Timeout is always set to be longer than the maximum possible time for the Activity Execution to complete.\nFor long running Activity Executions, we recommend also using [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat) and [Heartbeat Timeouts](/concepts/what-is-a-heartbeat-timeout).\n\n:::tip\n\nWe strongly recommend setting a Start-To-Close Timeout.\n\nThe Temporal Server doesn't detect failures when a Worker loses communication with the Server or crashes.\nTherefore, the Temporal Server relies on the Start-To-Close Timeout to force Activity retries.\n\n:::\n\nThe main use case for the Start-To-Close timeout is to detect when a Worker crashes after it has started executing an Activity Task.\n\n![Start-To-Close Timeout period](/diagrams/start-to-close-timeout.svg)\n\nA [Retry Policy](/concepts/what-is-a-retry-policy) attached to an Activity Execution retries an Activity Task Execution.\nThus, the Start-To-Close Timeout is applied to each Activity Task Execution within an Activity Execution.\n\nIf the first Activity Task Execution returns an error the first time, then the full Activity Execution might look like this:\n\n![Start-To-Close Timeout period with retries](/diagrams/start-to-close-timeout-with-retry.svg)\n\nIf this timeout is reached, the following actions occur:\n\n- An [ActivityTaskTimedOut](/references/events/#activitytasktimedout) Event is written to the Workflow Execution's mutable state.\n- If a Retry Policy dictates a retry, the Temporal Cluster schedules another Activity Task.\n  - The attempt count increments by 1 in the Workflow Execution's mutable state.\n  - The Start-To-Close Timeout timer is reset.\n","is_empty":false},{"file_name":"what-is-a-state-transition.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-state-transition.md","id":"concepts/what-is-a-state-transition","title":"What is a State Transition?","description":"A State Transition is a unit of progress by a Workflow Execution.","label":"State Transition","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA State Transition is a unit of progress made by a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nEach State Transition is recorded in a persistence store.\n\nSome operations, such as [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat), require only one State Transition each.\nMost operations require multiple State Transitions.\nFor example, a simple Workflow with two sequential [Activity Tasks](/concepts/what-is-an-activity-task) (and no retries) produces 11 State Transitions: two for Workflow start, four for each Activity, and one for Workflow completion.\n","is_empty":false},{"file_name":"what-is-a-sticky-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-sticky-execution.md","id":"concepts/what-is-a-sticky-execution","title":"What is a Sticky Execution?","description":"A Sticky Execution is a when a Worker Entity caches the Workflow Execution Event History and creates a dedicated Task Queue to listen on.","label":"Sticky Execution","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Sticky Execution is when a Worker Entity caches the Workflow Execution Event History and creates a dedicated Task Queue to listen on.\n\nA Sticky Execution occurs after a Worker Entity completes the first Workflow Task in the chain of Workflow Tasks for the Workflow Execution.\n\nThe Worker Entity caches the Workflow Execution Event History and begins polling the dedicated Task Queue for Workflow Tasks that contain updates, rather than the entire Event History.\n\nIf the Worker Entity does not pick up a Workflow Task from the dedicated Task Queue in an appropriate amount of time, the Cluster will resume Scheduling Workflow Tasks on the original Task Queue.\nAnother Worker Entity can then resume the Workflow Execution, and can set up its own Sticky Execution for future Workflow Tasks.\n\n- [How to set a `StickyScheduleToStartTimeout` on a Worker Entity in Go](/go/how-to-set-workeroptions-in-go#stickyscheduletostarttimeout)\n\nSticky Executions are the default behavior of the Temporal Platform.\n","is_empty":false},{"file_name":"what-is-a-task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-task-queue.md","id":"concepts/what-is-a-task-queue","title":"What is a Task Queue?","description":"A Task Queue is a first-in, first-out queue that a Worker Process polls for Tasks.","label":"Task Queue","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Task Queue is a lightweight, dynamically allocated queue that one or more [Worker Entities](/concepts/what-is-a-worker-entity) poll for [Tasks](/concepts/what-is-a-task).\n\nTask Queues do not have any ordering guarantees.\nIt is possible to have a Task that stays in a Task Queue for a period of time, if there is a backlog that wasn't drained for that time.\n\nThere are two types of Task Queues, Activity Task Queues and Workflow Task Queues.\n\n![Task Queue component](/diagrams/task-queue.svg)\n\nTask Queues are very lightweight components.\nTask Queues do not require explicit registration but instead are created on demand when a Workflow Execution or Activity spawns or when a Worker Process subscribes to it.\nWhen a Task Queue is created, both a Workflow Task Queue and an Activity Task Queue are created under the same name.\nThere is no limit to the number of Task Queues a Temporal Application can use or a Temporal Cluster can maintain.\n\nWorkers poll for Tasks in Task Queues via synchronous RPC.\nThis implementation offers several benefits:\n\n- A Worker Process polls for a message only when it has spare capacity, avoiding overloading itself.\n- In effect, Task Queues enable load balancing across many Worker Processes.\n- Task Queues enable what we call [Task Routing](/concepts/what-is-task-routing), which is the routing of specific Tasks to specific Worker Processes or even a specific process.\n- Task Queues support server-side throttling, which enables you to limit the Task dispatching rate to the pool of Worker Processes while still supporting Task dispatching at higher rates when spikes happen.\n- When all Worker Processes are down, messages simply persist in a Task Queue, waiting for the Worker Processes to recover.\n- Worker Processes do not need to advertise themselves through DNS or any other network discovery mechanism.\n- Worker Processes do not need to have any open ports, which is more secure.\n\nAll Workers listening to a given Task Queue must have identical registrations of Activities and/or Workflows.\nThe one exception is during a Server upgrade, where it is okay to have registration temporarily misaligned while the binary rolls out.\n\n#### Where to set Task Queues\n\nThere are four places where the name of the Task Queue can be set by the developer.\n\n1. A Task Queue must be set when spawning a Workflow Execution:\n\n- [How to start a Workflow Execution using tctl](/tctl-v1/workflow#start)\n- [How to start a Workflow Execution using the Go SDK](/go/spawning-workflows)\n- [How to start a Workflow Execution using the Java SDK](/java/how-to-spawn-a-workflow-execution-in-java)\n- [How to start a Workflow Execution using the PHP SDK](/php/spawning-workflows)\n- [How to start a Workflow Execution using the Python SDK](/python/spawning-workflows)\n- [How to start a Workflow Execution using the TypeScript SDK](/typescript/spawning-workflows)\n\n2. A Task Queue name must be set when creating a Worker Entity and when running a Worker Process:\n\n- [How to run a development Worker using the Go SDK](/go/how-to-develop-a-worker-in-go)\n- [How to run a development Worker using the Java SDK](/java/how-to-develop-a-worker-program-in-java)\n- [How to run a development Worker using the PHP SDK](/php/run-a-dev-worker)\n- [How to run a development Worker using the Python SDK](/python/run-a-dev-worker)\n- [How to run a development Worker using the TypeScript SDK](/typescript/run-a-dev-worker)\n\n- [How to run a Temporal Cloud Worker using the Go SDK](/go/run-a-temporal-cloud-worker)\n- [How to run a Temporal Cloud Worker using the TypeScript SDK](/typescript/run-a-temporal-cloud-worker)\n\nNote that all Worker Entities listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker Entity polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. A Task Queue name can be provided when spawning an Activity Execution:\n\nThis is optional.\nAn Activity Execution inherits the Task Queue name from its Workflow Execution if one is not provided.\n\n- [How to start an Activity Execution using the Go SDK](/go/spawning-activities)\n- [How to start an Activity Execution using the Java SDK](/java/spawning-activities)\n- [How to start an Activity Execution using the PHP SDK](/php/spawning-activities)\n- [How to start an Activity Execution using the Python SDK](/python/spawning-activities)\n- [How to start an Activity Execution using the TypeScript SDK](/typescript/spawning-activities)\n\n4. A Task Queue name can be provided when spawning a Child Workflow Execution:\n\nThis is optional.\nA Child Workflow Execution inherits the Task Queue name from its Parent Workflow Execution if one is not provided.\n\n- [How to start a Child Workflow Execution using the Go SDK](/go/child-workflows)\n- [How to start a Child Workflow Execution using the Java SDK](/java/child-workflows)\n- [How to start a Child Workflow Execution using the PHP SDK](/php/child-workflows)\n- [How to start a Child Workflow Execution using the Python SDK](/python/child-workflows)\n- [How to start a Child Workflow Execution using the TypeScript SDK](/typescript/child-workflows)\n","is_empty":false},{"file_name":"what-is-a-task-token.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-task-token.md","id":"concepts/what-is-a-task-token","title":"What is a Task Token?","description":"A Task Token is a unique identifier for an Activity Task Execution.","label":"Task Token","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Task Token is a unique identifier for an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n\n[Asynchronous Activity Completion](/concepts/what-is-asynchronous-activity-completion) calls take either of the following as arguments:\n\n- a Task Token, or\n- an [Activity Id](/concepts/what-is-an-activity-id), a [Workflow Id](/concepts/what-is-a-workflow-id), and optionally a [Run Id](/concepts/what-is-a-run-id).\n","is_empty":false},{"file_name":"what-is-a-task.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-task.md","id":"concepts/what-is-a-task","title":"What is a Task?","description":"A Task is the context needed to make progress with a specific Workflow Execution or Activity Execution.","label":"Task","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Task is the context that a Worker needs to progress with a specific [Workflow Execution](/workflows#workflow-execution) or [Activity Execution](/concepts/what-is-an-activity-execution).\n\nThere are two types of Tasks:\n\n- [Activity Task](/concepts/what-is-an-activity-task)\n- [Workflow Task](/concepts/what-is-a-workflow-task)\n","is_empty":false},{"file_name":"what-is-a-temporal-application.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-temporal-application.md","id":"concepts/what-is-a-temporal-application","title":"What is a Temporal Application","description":"A Temporal Application is a set of Workflow Executions.","label":"Temporal Application","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Temporal Application is a set of [Temporal Workflow Executions](/workflows#workflow-execution).\nEach Temporal Workflow Execution has exclusive access to its local state, executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions and the environment via message passing.\n\nA Temporal Application can consist of millions to billions of Workflow Executions.\nWorkflow Executions are lightweight components.\nA Workflow Execution consumes few compute resources; in fact, if a Workflow Execution is suspended, such as when it is in a waiting state, the Workflow Execution consumes no compute resources at all.\n\n**Reentrant Process**\n\nA Temporal Workflow Execution is a Reentrant Process. A Reentrant Process is resumable, recoverable, and reactive.\n\n- Resumable: Ability of a process to continue execution after execution was suspended on an _awaitable_.\n- Recoverable: Ability of a process to continue execution after execution was suspended on a _failure_.\n- Reactive: Ability of a process to react to external events.\n\nTherefore, a Temporal Workflow Execution executes a [Temporal Workflow Definition](/concepts/what-is-a-workflow-definition), also called a Temporal Workflow Function, your application code, exactly once and to completion—whether your code executes for seconds or years, in the presence of arbitrary load and arbitrary failures.\n","is_empty":false},{"file_name":"what-is-a-temporal-client.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-temporal-client.md","id":"concepts/what-is-a-temporal-client","title":"What is a Temporal Client","description":"A Temporal Client, provided by a Temporal SDK, provides a set of APIs to communicate with a Temporal Cluster.","label":"Temporal Client","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Temporal Client is available in each SDK and provides a set of APIs to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n\nThe most common operations that a Temporal Client enables you to perform are the following:\n\n- Get the result of Workflow Execution.\n- List Workflow Executions.\n- Query a Workflow Execution.\n- Signal a Workflow Execution.\n- Start a Workflow Execution.\n","is_empty":false},{"file_name":"what-is-a-temporal-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-temporal-cluster.md","id":"concepts/what-is-a-temporal-cluster","title":"What is a Temporal Cluster?","description":"A Temporal Cluster is a Temporal Server paired with Persistence and Visibility stores.","label":"Temporal Cluster","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Temporal Cluster is the group of services, known as the [Temporal Server](/concepts/what-is-the-temporal-server), combined with [Persistence](/concepts/what-is-persistence) and [Visibility](/concepts/what-is-visibility) stores, that together act as a component of the Temporal Platform.\n\n- [How to quickly install a Temporal Cluster for testing and development](/kb/all-the-ways-to-run-a-cluster)\n- [Cluster deployment guide](/cluster-deployment-guide)\n\n![A Temporal Cluster (Server + persistence)](/diagrams/temporal-cluster.svg)\n\n<!-- ### Visibility\nCommenting this out because it is out of place. Using the what is visibility concept topic in the guide instead.\nAlso these details are covered in the Visibility store setup under cluster deployment.\n\nTemporal has built-in [Visibility](/concepts/what-is-visibility) features.\nTo enhance this feature, Temporal supports an [integration with Elasticsearch](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster).\n\n- Elasticsearch v8 is supported from Temporal version 1.18.0 onwards\n- Elasticsearch v7.10 is supported from Temporal version 1.7.0 onwards\n- Elasticsearch v6.8 is supported up to Temporal version 1.17.x\n- Elasticsearch v6.8 and v7.10 versions are explicitly supported with AWS Elasticsearch -->\n","is_empty":false},{"file_name":"what-is-a-temporal-cron-job.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-temporal-cron-job.md","id":"concepts/what-is-a-temporal-cron-job","title":"What is a Temporal Cron Job?","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Job","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\n- [How to set a Cron Schedule using the Go SDK](/go/cron-jobs)\n- [How to set a Cron Schedule using the Java SDK](/java/how-to-set-a-cron-schedule-in-java)\n- [How to set a Cron Schedule using the PHP SDK](/php/cron-jobs)\n- [How to set a Cron Schedule using the Python SDK](/python/cron-jobs)\n- [How to set a Cron Schedule using the TypeScript SDK](/typescript/cron-jobs)\n\n![Temporal Cron Job timeline](/diagrams/temporal-cron-job.svg)\n\nA Temporal Cron Job is similar to a classic unix cron job.\nJust as a unix cron job accepts a command and a schedule on which to execute that command, a Cron Schedule can be provided with the call to spawn a Workflow Execution.\nIf a Cron Schedule is provided, the Temporal Server will spawn an execution for the associated Workflow Type per the schedule.\n\nEach Workflow Execution within the series is considered a Run.\n\n- Each Run receives the same input parameters as the initial Run.\n- Each Run inherits the same Workflow Options as the initial Run.\n\nThe Temporal Server spawns the first Workflow Execution in the chain of Runs immediately.\nHowever, it calculates and applies a backoff (`firstWorkflowTaskBackoff`) so that the first Workflow Task of the Workflow Execution does not get placed into a Task Queue until the scheduled time.\nAfter each Run Completes, Fails, or reaches the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout), the same thing happens: the next run will be created immediately with a new `firstWorkflowTaskBackoff` that is calculated based on the current Server time and the defined Cron Schedule.\n\nThe Temporal Server spawns the next Run only after the current Run has Completed, Failed, or has reached the Workflow Run Timeout.\nThis means that, if a Retry Policy has also been provided, and a Run Fails or reaches the Workflow Run Timeout, the Run will first be retried per the Retry Policy until the Run Completes or the Retry Policy has been exhausted.\nIf the next Run, per the Cron Schedule, is due to spawn while the current Run is still Open (including retries), the Server automatically starts the new Run after the current Run completes successfully.\nThe start time for this new Run and the Cron definitions are used to calculate the `firstWorkflowTaskBackoff` that is applied to the new Run.\n\nA [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) is used to limit how long a Workflow can be executing (have an Open status), including retries and any usage of Continue As New.\nThe Cron Schedule runs until the Workflow Execution Timeout is reached or you terminate the Workflow.\n\n![Temporal Cron Job Run Failure with a Retry Policy](/diagrams/temporal-cron-job-failure-with-retry.svg)\n\n### Cron Schedules\n\nCron Schedules are interpreted in UTC time by default.\n\nThe Cron Schedule is provided as a string and must follow one of two specifications:\n\n**Classic specification**\n\nThis is what the \"classic\" specification looks like:\n\n```\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12)\n│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n│ │ │ │ │\n* * * * *\n```\n\nFor example, `15 8 * * *` causes a Workflow Execution to spawn daily at 8:15 AM UTC.\nUse the [crontab guru site](https://crontab.guru/) to test your cron expressions.\n\n### `robfig` predefined schedules and intervals\n\nYou can also pass any of the [predefined schedules](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Predefined_schedules) or [intervals](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Intervals) described in the [`robfig/cron` documentation](https://pkg.go.dev/github.com/robfig/cron/v3).\n\n```\n| Schedules              | Description                                | Equivalent To |\n| ---------------------- | ------------------------------------------ | ------------- |\n| @yearly (or @annually) | Run once a year, midnight, Jan. 1st        | 0 0 1 1 *     |\n| @monthly               | Run once a month, midnight, first of month | 0 0 1 * *     |\n| @weekly                | Run once a week, midnight between Sat/Sun  | 0 0 * * 0     |\n| @daily (or @midnight)  | Run once a day, midnight                   | 0 0 * * *     |\n| @hourly                | Run once an hour, beginning of hour        | 0 * * * *     |\n```\n\nFor example, \"@weekly\" causes a Workflow Execution to spawn once a week at midnight between Saturday and Sunday.\n\nIntervals just take a string that can be accepted by [time.ParseDuration](http://golang.org/pkg/time/#ParseDuration).\n\n```\n@every <duration>\n```\n\n### Time zones\n\n_This feature only applies in Temporal 1.15 and up_\n\nYou can change the time zone that a Cron Schedule is interpreted in by prefixing the specification with `CRON_TZ=America/New_York` (or your [desired time zone from tz](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)). `CRON_TZ=America/New_York 15 8 * * *` therefore spawns a Workflow Execution every day at 8:15 AM New York time, subject to caveats listed below.\n\nConsider that using time zones in production introduces a surprising amount of complexity and failure modes!\n**If at all possible, we recommend specifying Cron Schedules in UTC (the default)**.\n\nIf you need to use time zones, here are a few edge cases to keep in mind:\n\n- **Beware Daylight Saving Time**: If a Temporal Cron Job is scheduled around the time when daylight saving time (DST) begins or ends (for example, `30 2 * * *`), **it might run zero, one, or two times in a day**! The Cron library that we use does not do any special handling of DST transitions. Avoid schedules that include times that fall within DST transition periods.\n  - For example, in the US, DST begins at 2 AM. When you \"fall back,\" the clock goes `1:59 … 1:00 … 1:01 … 1:59 … 2:00 … 2:01 AM` and any Cron jobs that fall in that 1 AM hour are fired again. The inverse happens when clocks \"spring forward\" for DST, and Cron jobs that fall in the 2 AM hour are skipped.\n  - In other time zones like Chile and Iran, DST \"spring forward\" is at midnight. 11:59 PM is followed by 1 AM, which means `00:00:00` never happens.\n- **Self Hosting note**: If you manage your own Temporal Cluster, you are responsible for ensuring that it has access to current `tzdata` files. The official Docker images are built with [tzdata](https://docs.w3cub.com/go/time/tzdata/index) installed (provided by Alpine Linux), but ultimately you should be aware of how tzdata is deployed and updated in your infrastructure.\n- **Updating Temporal**: If you use the official Docker images, note that an upgrade of the Temporal Cluster may include an update to the tzdata files, which may change the meaning of your Cron Schedule. You should be aware of upcoming changes to the definitions of the time zones you use, particularly around daylight saving time start/end dates.\n- **Absolute Time Fixed at Start**: The absolute start time of the next Run is computed and stored in the database when the previous Run completes, and is not recomputed. This means that if you have a Cron Schedule that runs very infrequently, and the definition of the time zone changes between one Run and the next, the Run might happen at the wrong time. For example, `CRON_TZ=America/Los_Angeles 0 12 11 11 *` means \"noon in Los Angeles on November 11\" (normally not in DST). If at some point the government makes any changes (for example, move the end of DST one week later, or stay on permanent DST year-round), the meaning of that specification changes. In that first year, the Run happens at the wrong time, because it was computed using the older definition.\n\n### How to stop a Temporal Cron Job\n\nA Temporal Cron Job does not stop spawning Runs until it has been Terminated or until the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) is reached.\n\nA Cancellation Request affects only the current Run.\n\nUse the Workflow Id in any requests to Cancel or Terminate.\n","is_empty":false},{"file_name":"what-is-a-temporal-sdk.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-temporal-sdk.md","id":"concepts/what-is-a-temporal-sdk","title":"What is a Temporal SDK?","description":"A Temporal SDK is a language-specific library that offers APIs to construct and use a Temporal Client to communicate with a Temporal Cluster, develop Workflow Definitions, and develop Worker Programs.","label":"Temporal SDK","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Temporal SDK is a language-specific library that offers APIs to do the following:\n\n1. Construct and use a [Temporal Client](/concepts/what-is-a-temporal-client)\n2. Develop [Workflow Definitions](/concepts/what-is-a-workflow-definition)\n3. Develop [Worker Programs](/concepts/what-is-a-worker-program)\n\nA Temporal SDK enables you to write your application code using the full power of the programming language, while the Temporal Platform handles the durability, reliability, and scalability of the application.\n\nTemporal currently offers the following SDKs:\n\n- [Get started with the Go SDK](/go/add-sdk)\n- [Get started with the Java SDK](/java/add-sdk)\n- [Get started with the PHP SDK](/dev-guide/php)\n- [Get started with the Python SDK](/python/add-sdk)\n- [How to use the TypeScript SDK](/typescript/add-sdk)\n\nEach SDK emits metrics which can be ingested into monitoring platforms.\nSee the [SDK metrics reference](/references/sdk-metrics) for a complete list.\n\n### Auth\n\nTemporal offers methods of authenticating and authorizing client API calls within our SDKs.\n\n### Sandbox environment\n\nSome SDKs support running Workflows inside a sandbox environment.\n\nThe Temporal Python SDK, for example, enables you to run Workflow code in a sandbox environment to help prevent non-determinism errors in your application.\nThe Temporal Workflow Sandbox for Python is not completely isolated, and some libraries can internally mutate state, which can result in breaking determinism.\n\nBy default, Workflows run in a sandbox environment.\nIf a Workflow Execution performs a non-deterministic event, an exception is thrown, which results in failing the Workflow Task.\nThe Workflow will not progress until the code is fixed.\n\nFor more information, see the knowledge base article on [Python sandbox environments](/kb/python-sandbox-environment).\n\n### SDKs in development\n\nThe following SDKs are in alpha/pre-alpha development stages, but are not yet supported in the Developer's guide:\n\n- [.NET](https://github.com/temporalio/sdk-dotnet)\n- [Rust](https://github.com/temporalio/sdk-core)\n- [Ruby](https://github.com/temporalio/sdk-ruby)\n\n### Third-party SDKs\n\nThe following third-party SDKs exist but are not supported in the [Developer's guide](/dev-guide):\n\n- [Clojure](https://github.com/manetu/temporal-clojure-sdk) - from [@Manetu](https://github.com/manetu)\n- [Scala](https://github.com/vitaliihonta/zio-temporal) from [@vitaliihonta](https://github.com/vitaliihonta)\n- [Ruby](https://github.com/coinbase/temporal-ruby) from [@coinbase](https://github.com/coinbase)\n","is_empty":false},{"file_name":"what-is-a-worker-entity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-worker-entity.md","id":"concepts/what-is-a-worker-entity","title":"What is a Worker Entity?","description":"A Worker Entity is the individual Worker within a Worker Process that listens to a specific Task Queue.","label":"Worker Entity","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Worker Entity is the individual Worker within a Worker Process that listens to a specific Task Queue.\n\nA Worker Entity listens and polls on a single Task Queue.\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it may make progress of either a Workflow Execution or an Activity Execution.\n\n**Can a Worker handle more Workflow Executions than its cache size or number of supported threads?**\n\nYes it can.\nHowever, the trade off is added latency.\n\nWorkers are stateless, so any Workflow Execution in a blocked state can be safely removed from a Worker.\nLater on, it can be resurrected on the same or different Worker when the need arises (in the form of an external event).\nTherefore, a single Worker can handle millions of open Workflow Executions, assuming it can handle the update rate and that a slightly higher latency is not a concern.\n\n**Operation guides:**\n\n- [How to tune Workers](/dev-guide/worker-performance)\n","is_empty":false},{"file_name":"what-is-a-worker-process.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-worker-process.md","id":"concepts/what-is-a-worker-process","title":"What is a Worker Process?","description":"A Worker Process is responsible for polling a Task Queue, dequeueing a Task, executing your code in response to a Task, and responding to the Temporal Server with the results.","label":"Worker Process","tags":["term","explanation"],"ssdi":[],"markdown_content":"\n![Component diagram of a Worker Process and the Temporal Server](/diagrams/worker-and-server-component.svg)\n\nA Worker Process is responsible for polling a [Task Queue](/concepts/what-is-a-task-queue), dequeueing a [Task](/concepts/what-is-a-task), executing your code in response to a Task, and responding to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) with the results.\n\nMore formally, a Worker Process is any process that implements the Task Queue Protocol and the Task Execution Protocol.\n\n- A Worker Process is a Workflow Worker Process if the process implements the Workflow Task Queue Protocol and executes the Workflow Task Execution Protocol to make progress on a Workflow Execution.\n  A Workflow Worker Process can listen on an arbitrary number of Workflow Task Queues and can execute an arbitrary number of Workflow Tasks.\n- A Worker Process is an Activity Worker Process if the process implements the Activity Task Queue Protocol and executes the Activity Task Processing Protocol to make progress on an Activity Execution.\n  An Activity Worker Process can listen on an arbitrary number of Activity Task Queues and can execute an arbitrary number of Activity Tasks.\n\n**Worker Processes are external to a Temporal Cluster.**\nTemporal Application developers are responsible for developing [Worker Programs](/concepts/what-is-a-worker-program) and operating Worker Processes.\nSaid another way, the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) (including the Temporal Cloud) doesn't execute any of your code (Workflow and Activity Definitions) on Temporal Cluster machines. The Cluster is solely responsible for orchestrating [State Transitions](/concepts/what-is-a-state-transition) and providing Tasks to the next available [Worker Entity](/concepts/what-is-a-worker-entity).\n\nWhile data transferred in Event Histories is [secured by mTLS](/security/#encryption-of-network-traffic), by default, it is still readable at rest in the Temporal Cluster.\n\nTo solve this, Temporal SDKs offer a [Data Converter API](/concepts/what-is-a-data-converter) that you can use to customize the serialization of data going out of and coming back in to a Worker Entity, with the net effect of guaranteeing that the Temporal Cluster cannot read sensitive business data.\n\nIn many of our tutorials, we show you how to run both a Temporal Cluster and one Worker on the same machine for local development.\nHowever, a production-grade Temporal Application typically has a _fleet_ of Worker Processes, all running on hosts external to the Temporal Cluster.\nA Temporal Application can have as many Worker Processes as needed.\n\nA Worker Process can be both a Workflow Worker Process and an Activity Worker Process.\nMany SDKs support the ability to have multiple Worker Entities in a single Worker Process.\n(Worker Entity creation and management differ between SDKs.)\nA single Worker Entity can listen to only a single Task Queue.\nBut if a Worker Process has multiple Worker Entities, the Worker Process could be listening to multiple Task Queues.\n\n![Entity relationship diagram (meta model) of Worker Processes, Task Queues, and Tasks](/diagrams/worker-and-server-entity-relationship.svg)\n\nWorker Processes executing Activity Tasks must have access to any resources needed to execute the actions that are defined in Activity Definitions, such as the following:\n\n- Network access for external API calls.\n- Credentials for infrastructure provisioning.\n- Specialized GPUs for machine learning utilities.\n\nThe Temporal Cluster itself has [internal workers](https://temporal.io/blog/workflow-engine-principles/#system-workflows-1910) for system Workflow Executions.\nHowever, these internal workers are not visible to the developer.\n","is_empty":false},{"file_name":"what-is-a-worker-program.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-worker-program.md","id":"concepts/what-is-a-worker-program","title":"What is a Worker Program?","description":"A Worker Program is the static code that defines the constraints of the Worker Process, developed using the APIs of a Temporal SDK.","label":"Worker Program","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Worker Program is the static code that defines the constraints of the Worker Process, developed using the APIs of a Temporal SDK.\n\n- [How to run a development Worker using the Go SDK](/go/how-to-develop-a-worker-in-go)\n- [How to run a development Worker using the Java SDK](/java/how-to-develop-a-worker-program-in-java)\n- [How to run a development Worker using the PHP SDK](/php/run-a-dev-worker)\n- [How to run a development Worker using the Python SDK](/python/run-a-dev-worker)\n- [How to run a development Worker using the TypeScript SDK](/typescript/run-a-dev-worker)\n\n- [How to run a Temporal Cloud Worker using the Go SDK](/go/run-a-temporal-cloud-worker)\n- [How to run a Temporal Cloud Worker using the TypeScript SDK](/typescript/run-a-temporal-cloud-worker)\n","is_empty":false},{"file_name":"what-is-a-worker-service.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-worker-service.md","id":"concepts/what-is-a-worker-service","title":"What is a Worker Service?","description":"The Worker Service runs background processing for the replication queue, system Workflows, and (in versions older than 1.5.0) the Kafka visibility processor.","label":"Worker Service","tags":["term"],"ssdi":[],"markdown_content":"\nThe Worker Service runs background processing for the replication queue, system Workflows, and (in versions older than 1.5.0) the Kafka visibility processor.\n\n![Worker Service](/diagrams/temporal-worker-service.svg)\n\nIt talks to the Frontend Service.\n\n- It uses port 6939 for membership-related communication.\n\nPorts are configurable in the Cluster configuration.\n","is_empty":false},{"file_name":"what-is-a-worker-session.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-worker-session.md","id":"concepts/what-is-a-worker-session","title":"What is a Worker Session","description":"A Worker Session is a feature provided by some SDKs that provides a straightforward way to ensure that Activity Tasks are executed with the same Worker without requiring you to manually specify Task Queue names.","label":"Worker Session","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Worker Session is a feature provided by some SDKs that provides a straightforward API for [Task Routing](/concepts/what-is-task-routing) to ensure that Activity Tasks are executed with the same Worker without requiring you to manually specify Task Queue names.\nIt also includes features like concurrent session limitations and Worker failure detection.\n\n- [How to use Worker Sessions](/go/worker-sessions)\n","is_empty":false},{"file_name":"what-is-a-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-worker.md","id":"concepts/what-is-a-worker","title":"What is a Worker?","description":"In day-to-day conversations, the term Worker is used to denote both a Worker Program and a Worker Process. Temporal documentation aims to be explicit and differentiate between them.","label":"Worker","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nIn day-to-day conversations, the term Worker is used to denote either a [Worker Program](/concepts/what-is-a-worker-program), a [Worker Process](/concepts/what-is-a-worker-process), or a [Worker Entity](/concepts/what-is-a-worker-entity).\nTemporal documentation aims to be explicit and differentiate between them.\n","is_empty":false},{"file_name":"what-is-a-workflow-definition.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-definition.md","id":"concepts/what-is-a-workflow-definition","title":"What is a Workflow Definition?","description":"A Workflow Definition is the code that defines the constraints of a Workflow Execution.","label":"Workflow Definition","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Workflow Definition is the code that defines the constraints of a Workflow Execution.\n\n- [How to develop a Workflow Definition using the Go SDK](/go/developing-workflows)\n- [How to develop a Workflow Definition using the Java SDK](/java/how-to-develop-a-workflow-definition-in-java)\n- [How to develop a Workflow Definition using the PHP SDK](/php/developing-workflows)\n- [How to develop a Workflow Definition using the Python SDK](/python/developing-workflows)\n- [How to develop a Workflow Definition using the TypeScript SDK](/typescript/developing-workflows)\n\nA Workflow Definition is often also referred to as a Workflow Function.\nIn Temporal's documentation, a Workflow Definition refers to the source for the instance of a Workflow Execution, while a Workflow Function refers to the source for the instance of a Workflow Function Execution.\n\nA Workflow Execution effectively executes once to completion, while a Workflow Function Execution occurs many times during the life of a Workflow Execution.\n\nWe strongly recommend that you write a Workflow Definition in a language that has a corresponding Temporal SDK.\n\n### Deterministic constraints\n\nA critical aspect of developing Workflow Definitions is ensuring they exhibit certain deterministic traits – that is, making sure that the same Commands are emitted in the same sequence, whenever a corresponding Workflow Function Execution (instance of the Function Definition) is re-executed.\n\nThe execution semantics of a Workflow Execution include the re-execution of a Workflow Function, which is called a [Replay](#replays).\nThe use of Workflow APIs in the function is what generates [Commands](/concepts/what-is-a-command).\nCommands tell the Cluster which Events to create and add to the Workflow Execution's Event History.\nWhen a Workflow Function executes, the Commands that are emitted are compared with the existing Event History.\nIf a corresponding Event already exists within the Event History that maps to the generation of that Command in the same sequence, and some specific metadata of that Command matches with some specific metadata of the Event, then the Function Execution progresses.\n\nFor example, using an SDK's \"Execute Activity\" API generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nWhen this API is called upon re-execution, that Command is compared with the Event that is in the same location within the sequence.\nThe Event in the sequence must be an [ActivityTaskScheduled](/references/events/#activitytaskscheduled) Event, where the Activity name is the same as what is in the Command.\n\nIf a generated Command doesn't match what it needs to in the existing Event History, then the Workflow Execution returns a _non-deterministic_ error.\n\nThe following are the two reasons why a Command might be generated out of sequence or the wrong Command might be generated altogether:\n\n1. Code changes are made to a Workflow Definition that is in use by a running Workflow Execution.\n2. There is intrinsic non-deterministic logic (such as inline random branching).\n\n### Code changes can cause non-deterministic behavior {#non-deterministic-change}\n\nThe Workflow Definition can change in very limited ways once there is a Workflow Execution depending on it.\nTo alleviate non-deterministic issues that arise from code changes, we recommend using [Workflow Versioning](#workflow-versioning).\n\nFor example, let's say we have a Workflow Definition that defines the following sequence:\n\n1. Start and wait on a Timer/sleep.\n2. Spawn and wait on an Activity Execution.\n3. Complete.\n\nWe start a Worker and spawn a Workflow Execution that uses that Workflow Definition.\nThe Worker would emit the [StartTimer](/references/commands/#starttimer) Command and the Workflow Execution would become suspended.\n\nBefore the Timer is up, we change the Workflow Definition to the following sequence:\n\n1. Spawn and wait on an Activity Execution.\n2. Start and wait on a Timer/sleep.\n3. Complete.\n\nWhen the Timer fires, the next Workflow Task will cause the Workflow Function to re-execute.\nThe first Command the Worker sees would be ScheduleActivityTask Command, which wouldn't match up to the expected [TimerStarted](/references/events/#timerstarted) Event.\n\nThe Workflow Execution would fail and return a non-deterministic error.\n\nThe following are examples of minor changes that would not result in non-determinism errors when re-executing a History which already contain the Events:\n\n- Changing the duration of a Timer, with the following exceptions:\n  - In Java, Python, and Go, changing a Timer’s duration from or to 0 is a non-deterministic behavior.\n  - In .NET, changing a Timer’s duration from or to -1 (which means \"infinite\") is a non-deterministic behavior.\n- Changing the arguments to:\n  - The Activity Options in a call to spawn an Activity Execution (local or nonlocal).\n  - The Child Workflow Options in a call to spawn a Child Workflow Execution.\n  - Call to Signal an External Workflow Execution.\n- Adding a Signal Handler for a Signal Type that has not been sent to this Workflow Execution.\n\n### Intrinsic non-deterministic logic\n\nIntrinsic non-determinism is when a Workflow Function Execution might emit a different sequence of Commands on re-execution, regardless of whether all the input parameters are the same.\n\nFor example, a Workflow Definition can not have inline logic that branches (emits a different Command sequence) based off a local time setting or a random number.\nIn the representative pseudocode below, the `local_clock()` function returns the local time, rather than Temporal-defined time:\n\n```text\nfn your_workflow() {\n  if local_clock().is_before(\"12pm\") {\n    await workflow.sleep(duration_until(\"12pm\"))\n  } else {\n    await your_afternoon_activity()\n  }\n}\n```\n\nEach Temporal SDK offers APIs that enable Workflow Definitions to have logic that gets and uses time, random numbers, and data from unreliable resources.\nWhen those APIs are used, the results are stored as part of the Event History, which means that a re-executed Workflow Function will issue the same sequence of Commands, even if there is branching involved.\n\nIn other words, all operations that do not purely mutate the Workflow Execution's state should occur through a Temporal SDK API.\n\n### Workflow Versioning {#workflow-versioning}\n\nThe Workflow Versioning feature enables the creation of logical branching inside a Workflow Definition based on a developer specified version identifier.\nThis feature is useful for Workflow Definition logic needs to be updated, but there are running Workflow Executions that currently depends on it.\nIt is important to note that a practical way to handle different versions of Workflow Definitions, without using the versioning API, is to run the different versions on separate Task Queues.\n\n- [How to version Workflow Definitions in Go](/go/versioning)\n- [How to version Workflow Definitions in Java](/java/versioning)\n- [How to version Workflow Definitions in TypeScript](/typescript/versioning)\n\n### Handling unreliable Worker Processes\n\nYou do not handle Worker Process failure or restarts in a Workflow Definition.\n\nWorkflow Function Executions are completely oblivious to the Worker Process in terms of failures or downtime.\nThe Temporal Platform ensures that the state of a Workflow Execution is recovered and progress resumes if there is an outage of either Worker Processes or the Temporal Cluster itself.\nThe only reason a Workflow Execution might fail is due to the code throwing an error or exception, not because of underlying infrastructure outages.\n","is_empty":false},{"file_name":"what-is-a-workflow-execution-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-execution-timeout.md","id":"concepts/what-is-a-workflow-execution-timeout","title":"What is a Workflow Execution Timeout?","description":"A Workflow Execution Timeout is the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["term","explanation","timeouts"],"ssdi":[],"markdown_content":"\nA Workflow Execution Timeout is the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n\n- [How to set a Workflow Execution Timeout using the Go SDK](/go/workflow-timeouts)\n- [How to set a Workflow Execution Timeout using the Java SDK](/java/workflow-timeouts)\n- [How to set a Workflow Execution Timeout using the PHP SDK](/php/workflow-timeouts)\n- [How to set a Workflow Execution Timeout using the Python SDK](/python/workflow-timeouts)\n- [How to set a Workflow Execution Timeout using the TypeScript SDK](/typescript/workflow-timeouts)\n\n![Workflow Execution Timeout period](/diagrams/workflow-execution-timeout.svg)\n\n**The default value is ∞ (infinite).**\nIf this timeout is reached, the Workflow Execution changes to a Timed Out status.\nThis timeout is different from the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout).\nThis timeout is most commonly used for stopping the execution of a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) after a certain amount of time has passed.\n","is_empty":false},{"file_name":"what-is-a-workflow-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-execution.md","id":"concepts/what-is-a-workflow-execution","title":"What is a Workflow Execution?","description":"A Temporal Workflow Execution is a durable, scalable, reliable, and reactive function execution. It is the main unit of execution of a Temporal Application.","label":"Workflow Execution","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Temporal Workflow Execution is a durable, reliable, and scalable function execution.\nIt is the main unit of execution of a [Temporal Application](/concepts/what-is-a-temporal-application).\n\n- [How to start a Workflow Execution using tctl](/tctl-v1/workflow#start)\n- [How to start a Workflow Execution using the Go SDK](/go/spawning-workflows)\n- [How to start a Workflow Execution using the Java SDK](/java/how-to-spawn-a-workflow-execution-in-java)\n- [How to start a Workflow Execution using the PHP SDK](/php/spawning-workflows)\n- [How to start a Workflow Execution using the Python SDK](/python/spawning-workflows)\n- [How to start a Workflow Execution using the TypeScript SDK](/typescript/spawning-workflows)\n\nEach Temporal Workflow Execution has exclusive access to its local state.\nIt executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions through [Signals](/concepts/what-is-a-signal) and the environment through [Activities](/concepts/what-is-an-activity).\nWhile a single Workflow Execution has limits on size and throughput, a Temporal Application can consist of millions to billions of Workflow Executions.\n\n**Durability**\n\nDurability is the absence of an imposed time limit.\n\nA Workflow Execution is durable because it executes a Temporal Workflow Definition (also called a Temporal Workflow Function), your application code, effectively once and to completion—whether your code executes for seconds or years.\n\n**Reliability**\n\nReliability is responsiveness in the presence of failure.\n\nA Workflow Execution is reliable, because it is fully recoverable after a failure.\nThe Temporal Platform ensures the state of the Workflow Execution persists in the face of failures and outages and resumes execution from the latest state.\n\n**Scalability**\n\nScalability is responsiveness in the presence of load.\n\nA single Workflow Execution is limited in size and throughput but is scalable because it can [Continue-As-New](/concepts/what-is-continue-as-new) in response to load.\nA Temporal Application is scalable because the Temporal Platform is capable of supporting millions to billions of Workflow Executions executing concurrently, which is realized by the design and nature of the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) and [Worker Processes](/concepts/what-is-a-worker-process).\n\n### Replays\n\nA Replay is the method by which a Workflow Execution resumes making progress. During a Replay the Commands that are generated are checked against an existing Event History. Replays are necessary and often happen to give the effect that Workflow Executions are resumable, reliable, and durable.\n\nFor more information, see [Deterministic constraints](/concepts/what-is-a-workflow-definition#deterministic-constraints).\n\nIf a failure occurs, the Workflow Execution picks up where the last recorded event occurred in the Event History.\n\n- [How to use Replay APIs using the Go SDK](/go/replays)\n- [How to use Replay APIs using the Java SDK](/java/replays)\n- [How to use Replay APIs using the Python SDK](/python/replays)\n- [How to use Replay APIs using the TypeScript SDK](/typescript/replays)\n\n### Commands and awaitables\n\nA Workflow Execution does two things:\n\n1. Issue [Commands](/concepts/what-is-a-command).\n2. Wait on an Awaitables (often called Futures).\n\n![Command generation and waiting](/diagrams/workflow-execution-progession-simple.svg)\n\nCommands are issued and Awaitables are provided by the use of Workflow APIs in the [Workflow Definition](/concepts/what-is-a-workflow-definition).\n\nCommands are generated whenever the Workflow Function is executed.\nThe Worker Process supervises the Command generation and makes sure that it maps to the current Event History.\n(For more information, see [Deterministic constraints](/concepts/what-is-a-workflow-definition#deterministic-constraints).)\nThe Worker Process batches the Commands and then suspends progress to send the Commands to the Cluster whenever the Workflow Function reaches a place where it can no longer progress without a result from an Awaitable.\n\nA Workflow Execution may only ever block progress on an Awaitable that is provided through a Temporal SDK API.\nAwaitables are provided when using APIs for the following:\n\n- Awaiting: Progress can block using explicit \"Await\" APIs.\n- Requesting cancellation of another Workflow Execution: Progress can block on confirmation that the other Workflow Execution is cancelled.\n- Sending a [Signal](/concepts/what-is-a-signal): Progress can block on confirmation that the Signal sent.\n- Spawning a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution): Progress can block on confirmation that the Child Workflow Execution started, and on the result of the Child Workflow Execution.\n- Spawning an [Activity Execution](/concepts/what-is-an-activity-execution): Progress can block on the result of the Activity Execution.\n- Starting a Timer: Progress can block until the Timer fires.\n\n### Status\n\nA Workflow Execution can be either Open or Closed.\n\n![Workflow Execution statuses](/diagrams/workflow-execution-statuses.svg)\n\n**Open**\n\n- Running: The only Open status for a Workflow Execution.\n  When the Workflow Execution is Running, it is either actively progressing or is waiting on something.\n\n**Closed**\n\nA Closed status means that the Workflow Execution cannot make further progress because of one of the following reasons:\n\n- Cancelled: The Workflow Execution successfully handled a cancellation request.\n- Completed: The Workflow Execution has completed successfully.\n- Continued-As-New: The Workflow Execution [Continued-As-New](/concepts/what-is-continue-as-new).\n- Failed: The Workflow Execution returned an error and failed.\n- Terminated: The Workflow Execution was terminated.\n- Timed Out: The Workflow Execution reached a timeout limit.\n\n### Workflow Execution Chain\n\nA Workflow Execution Chain is a sequence of Workflow Executions that share the same Workflow Id.\nEach link in the Chain is often called a Workflow Run.\nEach Workflow Run in the sequence is connected by one of the following:\n\n- [Continue-As-New](/concepts/what-is-continue-as-new)\n- [Retries](/concepts/what-is-a-retry-policy)\n- [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job)\n\nA Workflow Execution is uniquely identified by its [Namespace](/concepts/what-is-a-namespace), [Workflow Id](/concepts/what-is-a-workflow-id), and [Run Id](/concepts/what-is-a-run-id).\n\nThe [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) applies to a Workflow Execution Chain.\nThe [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) applies to a single Workflow Execution (Workflow Run).\n\n### Event loop\n\nA Workflow Execution is made up of a sequence of [Events](/concepts/what-is-an-event) called an [Event History](/concepts/what-is-an-event-history).\nEvents are created by the Temporal Cluster in response to either Commands or actions requested by a Temporal Client (such as a request to spawn a Workflow Execution).\n\n![Workflow Execution](/diagrams/workflow-execution-swim-lane-01.svg)\n\n### Time constraints\n\n**Is there a limit to how long Workflows can run?**\n\nNo, there is no time constraint on how long a Workflow Execution can be Running.\n\nHowever, Workflow Executions intended to run indefinitely should be written with some care.\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\nThe Temporal Cluster logs a warning after 10Ki (10,240) Events and periodically logs additional warnings as new Events are added.\nIf the Event History exceeds 50Ki (51,200) Events, the Workflow Execution is terminated.\n\nTo prevent _runaway_ Workflow Executions, you can use the Workflow Execution Timeout, the Workflow Run Timeout, or both.\nA Workflow Execution Timeout can be used to limit the duration of Workflow Execution Chain, and a Workflow Run Timeout can be used to limit the duration an individual Workflow Execution (Run).\n\nYou can use the [Continue-As-New](/concepts/what-is-continue-as-new) feature to close the current Workflow Execution and create a new Workflow Execution in a single atomic operation.\nThe Workflow Execution spawned from Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\nFor example, it may be reasonable to use Continue-As-New once per day for a long-running Workflow Execution that is generating a large Event History.\n\n### Limits\n\nEach pending Activity generates a metadata entry in the Workflow's mutable state.\nToo many entries create a large mutable state, which causes unstable persistence.\n\nTo protect the system, Temporal enforces a maximum of 50,000 pending Activities, Child Workflows, Signals, and Workflow cancellation requests.\nCurrently, there is no limit on the total number of Signals that a Workflow Execution can receive. <!--From Temporal server v1.21, the default maximum number of Signals that a Workflow Execution can receive is 10000. -->\nThese limits are set with the following [dynamic configuration keys](https://github.com/temporalio/temporal/blob/master/service/history/configs/config.go):\n\n- `limit.numPendingActivities.error`\n- `limit.numPendingChildExecutions.error`\n- `limit.numPendingSignals.error`\n- `limit.numPendingCancelRequests.error`\n- `history.maximumSignalsPerExecution`\n\nBy default, Temporal fails Workflow Task Executions that would cause the Workflow to surpass 50,000 <!--2000 in from v1.21--> pending Activities, Child Workflows, Workflow cancellation requests, or Signals. <!-- The Workflow Execution fails if the number of pending Signals exceeds 2000, or if the total number of Signals received exceeds 10000. -->\nSimilar constraints are enforced for `SignalExternalWorkflowExecution`, `RequestCancelExternalWorkflowExecution`, and `StartChildWorkflowExecution` Commands.\n\n:::note\n\nCloud users are limited to 2,000 each of pending Activities, Child Workflows, Workflow cancellation requests, and Signals.\n\n:::\n","is_empty":false},{"file_name":"what-is-a-workflow-id-reuse-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-id-reuse-policy.md","id":"concepts/what-is-a-workflow-id-reuse-policy","title":"What is a Workflow Id Reuse Policy?","description":"A Workflow Id Reuse Policy determines whether a Workflow Execution is allowed to spawn with a particular Workflow Id, if that Workflow Id has been used with a previous, and now Closed, Workflow Execution.","label":"Workflow Id Reuse Policy","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Workflow Id Reuse Policy determines whether a Workflow Execution is allowed to spawn with a particular Workflow Id, if that Workflow Id has been used with a previous, and now Closed, Workflow Execution.\n\nIt is not possible for a new Workflow Execution to spawn with the same Workflow Id as another Open Workflow Execution, regardless of the Workflow Id Reuse Policy.\nIn some cases, an attempt to spawn a Workflow Execution with a Workflow Id that is the same as the Id of a currently Open Workflow Execution results in a `Workflow execution already started` error.\n\n:::note\n\nThe default [StartWorkflowOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions) behavior in the Go SDK is to not return an error when a new Workflow Execution is attempted with the same Workflow Id as an open Workflow Execution.\nInstead, it returns a WorkflowRun instance representing the current or last run of the open Workflow Execution.\n\nTo return the `Workflow execution already started` error, set `WorkflowExecutionErrorWhenAlreadyStarted` to `true`.\n\n:::\n\nThe Workflow Id Reuse Policy can have one of the following values:\n\n- **Allow Duplicate**: The Workflow Execution is allowed to exist regardless of the Closed status of a previous Workflow Execution with the same Workflow Id.\n  **This is the default policy, if one is not specified.**\n  Use this when it is OK to have a Workflow Execution with the same Workflow Id as a previous, but now Closed, Workflow Execution.\n- **Allow Duplicate Failed Only**: The Workflow Execution is allowed to exist only if a previous Workflow Execution with the same Workflow Id does not have a Completed status.\n  Use this policy when there is a need to re-execute a Failed, Timed Out, Terminated or Cancelled Workflow Execution and guarantee that the Completed Workflow Execution will not be re-executed.\n- **Reject Duplicate**: The Workflow Execution cannot exist if a previous Workflow Execution has the same Workflow Id, regardless of the Closed status.\n  Use this when there can only be one Workflow Execution per Workflow Id within a Namespace for the given retention period.\n- **Terminate if Running**: Specifies that if a Workflow Execution with the same Workflow Id is already running, it should be terminated and a new Workflow Execution with the same Workflow Id should be started. This policy allows for only one Workflow Execution with a specific Workflow Id to be running at any given time.\n\nA Workflow Id Reuse Policy applies only if a Closed Workflow Execution with the same Workflow Id exists within the Retention Period of the associated Namespace.\nFor example, if the Namespace's retention period is 30 days, a Workflow Id Reuse Policy can only compare the Workflow Id of the spawning Workflow Execution against the Closed Workflow Executions for the last 30 days.\n\nIf there is an attempt to spawn a Workflow Execution with a Workflow Id Reuse Policy that won't allow it the Server will prevent the Workflow Execution from spawning.\n","is_empty":false},{"file_name":"what-is-a-workflow-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-id.md","id":"concepts/what-is-a-workflow-id","title":"What is a Workflow Id?","description":"A Workflow Id is a customizable, application-level identifier for a Workflow Execution that is unique to an Open Workflow Execution within a Namespace.","label":"Workflow Id","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Workflow Id is a customizable, application-level identifier for a [Workflow Execution](/workflows#workflow-execution) that is unique to an Open Workflow Execution within a [Namespace](/namespaces).\n\n- [How to set a Workflow Id](/go/how-to-set-a-workflow-id-in-go)\n\nA Workflow Id is meant to be a business-process identifier such as customer identifier or order identifier.\n\nA [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy) can be used to manage whether a Workflow Id can be re-used.\nThe Temporal Platform guarantees uniqueness of the Workflow Id within a [Namespace](/concepts/what-is-a-namespace) based on the Workflow Id Reuse Policy.\n\nA Workflow Execution can be uniquely identified across all Namespaces by its [Namespace](/concepts/what-is-a-namespace), Workflow Id, and [Run Id](/concepts/what-is-a-run-id).\n","is_empty":false},{"file_name":"what-is-a-workflow-run-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-run-timeout.md","id":"concepts/what-is-a-workflow-run-timeout","title":"What is a Workflow Run Timeout?","description":"This is the maximum amount of time that a single Workflow Run is restricted to.","label":"Workflow Run Timeout","tags":["term","explanation","timeouts"],"ssdi":[],"markdown_content":"\nA Workflow Run Timeout is the maximum amount of time that a single Workflow Run is restricted to.\n\n- [How to set a Workflow Run Timeout using the Go SDK](/go/workflow-timeouts)\n- [How to set a Workflow Run Timeout using the Java SDK](/java/workflow-timeouts)\n- [How to set a Workflow Run Timeout using the PHP SDK](/php/workflow-timeouts)\n- [How to set a Workflow Run Timeout using the Python SDK](/python/workflow-timeouts)\n- [How to set a Workflow Run Timeout using the TypeScript SDK](/typescript/workflow-timeouts)\n\n![Workflow Run Timeout period](/diagrams/workflow-run-timeout.svg)\n\n**The default is set to the same value as the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout).**\nThis timeout is most commonly used to limit the execution time of a single [Temporal Cron Job Execution](/concepts/what-is-a-temporal-cron-job).\n\nIf the Workflow Run Timeout is reached, the Workflow Execution is Terminated.\n","is_empty":false},{"file_name":"what-is-a-workflow-task-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-task-execution.md","id":"concepts/what-is-a-workflow-task-execution","title":"What is a Workflow Task Execution?","description":"A Workflow Task Execution occurs when a Worker picks up a Workflow Task and uses it to make progress on the execution of a Workflow Definition.","label":"Workflow Task Execution","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Workflow Task Execution occurs when a [Worker](/concepts/what-is-a-worker-entity) picks up a [Workflow Task](/concepts/what-is-a-workflow-task) and uses it to make progress on the execution of a [Workflow Definition](/concepts/what-is-a-workflow-definition) (also known as a Workflow function).\n","is_empty":false},{"file_name":"what-is-a-workflow-task-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-task-timeout.md","id":"concepts/what-is-a-workflow-task-timeout","title":"What is a Workflow Task Timeout?","description":"A Workflow Task Timeout is the maximum amount of time that the Temporal Server will wait for a Worker to start processing a Workflow Task after the Task has been pulled from the Task Queue.","label":"Workflow Task Timeout","tags":["term","explanation","timeouts"],"ssdi":[],"markdown_content":"\nA Workflow Task Timeout is the maximum amount of time allowed for a [Worker](/concepts/what-is-a-worker) to execute a [Workflow Task](/concepts/what-is-a-workflow-task) after the Worker has pulled that Workflow Task from the [Task Queue](/concepts/what-is-a-task-queue).\n\n- [How to set a Workflow Task Timeout using the Go SDK](/go/workflow-timeouts)\n- [How to set a Workflow Task Timeout using the Java SDK](/java/workflow-timeouts)\n- [How to set a Workflow Task Timeout using the PHP SDK](/php/workflow-timeouts)\n- [How to set a Workflow Task Timeout using the Python SDK](/python/workflow-timeouts)\n- [How to set a Workflow Task Timeout using the TypeScript SDK](/typescript/workflow-timeouts)\n\n![Workflow Task Timeout period](/diagrams/workflow-task-timeout.svg)\n\n**The default value is 10 seconds.**\nThis timeout is primarily available to recognize whether a Worker has gone down so that the Workflow Execution can be recovered on a different Worker.\nThe main reason for increasing the default value would be to accommodate a Workflow Execution that has a very long Workflow Execution History that could take longer than 10 seconds for the Worker to load.\n","is_empty":false},{"file_name":"what-is-a-workflow-task.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-task.md","id":"concepts/what-is-a-workflow-task","title":"What is a Workflow Task?","description":"A Workflow Task is a Task that contains the context needed to make progress with a Workflow Execution.","label":"Workflow Task","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Workflow Task is a Task that contains the context needed to make progress with a Workflow Execution.\n\n- Every time a new external event that might affect a Workflow state is recorded, a Workflow Task that contains the event is added to a Task Queue and then picked up by a Workflow Worker.\n- After the new event is handled, the Workflow Task is completed with a list of [Commands](/concepts/what-is-a-command).\n- Handling of a Workflow Task is usually very fast and is not related to the duration of operations that the Workflow invokes.\n","is_empty":false},{"file_name":"what-is-a-workflow-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow-type.md","id":"concepts/what-is-a-workflow-type","title":"What is a Workflow Type?","description":"A Workflow Type is a name that maps to a Workflow Definition.","label":"Workflow Type","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nA Workflow Type is a name that maps to a Workflow Definition.\n\n- A single Workflow Type can be instantiated as multiple Workflow Executions.\n- A Workflow Type is scoped by a Task Queue.\n  It is acceptable to have the same Workflow Type name map to different Workflow Definitions if they are using completely different Workers.\n\n![Workflow Type cardinality with Workflow Definitions and Workflow Executions](/diagrams/workflow-type-cardinality.svg)\n","is_empty":false},{"file_name":"what-is-a-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-a-workflow.md","id":"concepts/what-is-a-workflow","title":"What is a Workflow?","description":"In day-to-day conversations, the term \"Workflow\" frequently denotes either a Workflow Type, a Workflow Definition, or a Workflow Execution.","label":"Workflow","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nIn day-to-day conversations, the term _Workflow_ frequently denotes either a [Workflow Type](/concepts/what-is-a-workflow-type), a [Workflow Definition](/concepts/what-is-a-workflow-definition), or a [Workflow Execution](/workflows#workflow-execution).\nTemporal documentation aims to be explicit and differentiate between them.\n","is_empty":false},{"file_name":"what-is-advanced-visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-advanced-visibility.md","id":"concepts/what-is-advanced-visibility","title":"What is advanced Visibility?","description":"Advanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through an SQL-like query syntax.","label":"Advanced Visibility","tags":["explanation","filtered-lists","visibility"],"ssdi":[],"markdown_content":"\nAdvanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through a custom SQL-like [List Filter](/concepts/what-is-a-list-filter).\n\n- In Temporal Cluster version 1.20 and later, advanced Visibility is available on SQL databases like MySQL (version 8.0.17 and later) and PostgreSQL (version 12 and later), in addition to support for Elasticsearch.\n- For Temporal Server versions 1.19.1 and earlier, you must [integrate with ElasticSearch](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster) to use advanced Visibility.\n  Elasticsearch takes on the Visibility request load, relieving potential performance issues.\n  We highly recommend operating a Temporal Cluster with Elasticsearch for any use case that spawns more than just a few Workflow Executions.\n","is_empty":false},{"file_name":"what-is-an-action.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-action.md","id":"concepts/what-is-an-action","title":"What is an Action?","description":"An Action is the fundamental pricing unit in Temporal Cloud.","label":"Action","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAn Action is the fundamental pricing unit in [Temporal Cloud](/concepts/what-is-temporal-cloud).\n\nThe following operations result in Actions, which are billed monthly.\n\n**Workflows**\n\n- **Workflow started.**\n  Occurs via client start, client Signal-With-Start, [Continue-As-New](/concepts/what-is-continue-as-new), or [Child Workflow](/concepts/what-is-a-child-workflow-execution) start.\n  If a Workflow start fails, an Action is not recorded.\n- **Workflow reset.**\n  Occurs when a [Workflow](/concepts/what-is-a-workflow) is reset.\n  (Actions that occur before a [Reset](/concepts/what-is-a-reset) are counted even if they are no longer visible in [Event History](/concepts/what-is-an-event-history).)\n- **Timer started.**\n  Includes implicit Timers that are started by a Temporal SDK when timeouts are set, such as `AwaitWithTimeout` in Go or `condition` in TypeScript.\n- **Search Attribute upsert requested.**\n  Occurs after a Workflow starts and invokes `UpsertSearchAttributes`.\n- **Signal sent.**\n  Includes sending a [Signal](/concepts/what-is-a-signal) from a client or from within a Workflow to another Workflow.\n- **Query received.** [Queries](/concepts/what-is-a-query) aren't recorded in Event History.\n  An operation such as viewing the stack trace in the Temporal Cloud UI results in a Query.\n- **Version marker recorded.**\n  Occurs when a Workflow calls `get-version` or `patch`.\n- **Side Effect recorded.**\n  For a mutable [Side Effect](/concepts/what-is-a-side-effect), an Action occurs only when the value changes.\n  (Be aware that some SDKs don't support Side Effects.)\n\n**Activities**\n\n- **Activity started or retried.**\n  Occurs each time an Activity is started or retried.\n- **Local Activity started.**\n  Occurs each time a [Local Activity](/concepts/what-is-a-local-activity) is started.\n- **Activity Heartbeat recorded.**\n  A Heartbeat call from Activity code counts as an Action only if it reaches the [Temporal Server](/concepts/what-is-the-temporal-server).\n  Temporal SDKs throttle [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n  The default throttle is 80% of the [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout).\n  Heartbeats don't apply to Local Activities.\n","is_empty":false},{"file_name":"what-is-an-activity-definition.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-activity-definition.md","id":"concepts/what-is-an-activity-definition","title":"What is an Activity Definition?","description":"An Activity Definition is the code that defines the constraints of an Activity Task Execution.","label":"Activity Definition","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAn Activity Definition is the code that defines the constraints of an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n\n- [How to develop an Activity Definition using the Go SDK](/go/how-to-develop-an-activity-definition-in-go)\n- [How to develop an Activity Definition using the Java SDK](/java/developing-activities)\n- [How to develop an Activity Definition using the PHP SDK](/php/developing-activities)\n- [How to develop an Activity Definition using the Python SDK](/python/developing-activities)\n- [How to develop an Activity Definition using the TypeScript SDK](/typescript/developing-activities)\n\nThe term 'Activity Definition' is used to refer to the full set of primitives in any given language SDK that provides an access point to an Activity Function Definition——the method or function that is invoked for an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\nTherefore, the terms Activity Function and Activity Method refer to the source of an instance of an execution.\n\nActivity Definitions are named and referenced in code by their [Activity Type](/concepts/what-is-an-activity-type).\n\n![Activity Definition](/diagrams/activity-definition.svg)\n\n#### Idempotency\n\nTemporal recommends that Activities be idempotent.\n\nAn Activity is idempotent if multiple [Activity Task Executions](/concepts/what-is-an-activity-task-execution) do not change the state of the system beyond the first Activity Task Execution.\n\nWe recommend using idempotency keys for critical side effects.\n\nThe lack of idempotency might affect the correctness of your application but does not affect the Temporal Platform.\nIn other words, lack of idempotency does not lead to a platform error.\n\nIn some cases, whether something is idempotent does not affect the correctness of an application.\nFor example, if you have a monotonically incrementing counter, you might not care that retries increment the counter because you don’t care about the actual value, only that the current value is greater than a previous value.\n\n#### Constraints\n\nActivity Definitions are executed as normal functions.\n\nIn the event of failure, the function begins at its initial state when retried (except when Activity Heartbeats are established).\n\nTherefore, an Activity Definition has no restrictions on the code it contains.\n\n#### Parameters\n\nAn Activity Definition can support as many parameters as needed.\n\nAll values passed through these parameters are recorded in the [Event History](/concepts/what-is-an-event-history) of the Workflow Execution.\nReturn values are also captured in the Event History for the calling Workflow Execution.\n\nActivity Definitions must contain the following parameters:\n\n- Context: an optional parameter that provides Activity context within multiple APIs.\n- Heartbeat: a notification from the Worker to the Temporal Cluster that the Activity Execution is progressing. Cancelations are allowed only if the Activity Definition permits Heartbeating.\n- Timeouts: intervals that control the execution and retrying of Activity Task Executions.\n\nOther parameters, such as [Retry Policies](/concepts/what-is-a-retry-policy) and return values, can be seen in the implementation guides, listed in the next section.\n","is_empty":false},{"file_name":"what-is-an-activity-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-activity-execution.md","id":"concepts/what-is-an-activity-execution","title":"What is an Activity Execution?","description":"An Activity Execution is the full chain of Activity Task Executions.","label":"Activity Execution","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAn Activity Execution is the full chain of [Activity Task Executions](/concepts/what-is-an-activity-task-execution).\n\n- [How to start an Activity Execution using the Go SDK](/go/spawning-activities)\n- [How to start an Activity Execution using the Java SDK](/java/spawning-activities)\n- [How to start an Activity Execution using the PHP SDK](/php/spawning-activities)\n- [How to start an Activity Execution using the Python SDK](/python/spawning-activities)\n- [How to start an Activity Execution using the TypeScript SDK](/typescript/spawning-activities)\n\n![Activity Execution](/diagrams/activity-execution.svg)\n\nBy default, an Activity Execution has no time limit.\nYou can customize [Activity Execution timeouts](/concepts/what-is-a-start-to-close-timeout) and [retry policies](/concepts/what-is-a-retry-policy).\n\nIf an Activity Execution fails (because it exhausted all retries, threw a [non-retryable error](/concepts/what-is-a-retry-policy#non-retryable-errors), or was canceled), the error is returned to the [Workflow](/workflows), which decides how to handle it.\n\n### Cancellation\n\nActivity Cancellation:\n\n- lets the Activity know it doesn't need to keep doing work, and\n- gives the Activity time to clean up any resources it has created.\n\nActivities can only receive Cancellation if they emit Heartbeats or in Core-based SDKs (TypeScript/Python) are Local Activities (which don't heartbeat but receive Cancellation anyway).\n\nAn Activity may receive Cancellation if:\n\n- The Activity was requested to be Cancelled. This can often cascade from Workflow Cancellation, but not always—SDKs have ways to stop Cancellation from cascading. <!-- TODO link to workflow cancellation -->\n- The Activity was considered failed by the Server because any of the Activity timeouts have triggered (for example, the Server didn't receive a heartbeat within the Activity's Heartbeat timeout). The [Cancelled Failure](/kb/failures#cancelled-failure) that the Activity receives will have `message: 'TIMED_OUT'`.\n- The Workflow Run reached a [Closed state](/workflows#status), in which case the Cancelled Failure will have `message: 'NOT_FOUND'`.\n- In some SDKs:\n  - The Worker is shutting down.\n  - An Activity sends a Heartbeat but the Heartbeat details can't be converted by the Worker's configured [Data Converter](/concepts/what-is-a-data-converter). This fails the Activity Task Execution with an Application Failure.\n\nThere are different ways to receive Cancellation depending on the SDK. <!-- TODO link to dev guide -->\nAn Activity may accept or ignore Cancellation:\n\n- To allow Cancellation to happen, let the Cancellation Failure propagate.\n- To ignore Cancellation, catch it and continue executing.\n\nSome SDKs have ways to shield tasks from being stopped while still letting the Cancellation propagate.\n\nThe Workflow can also decide if it wants to wait for the Activity Cancellation to be accepted or to proceed without waiting.\n\nCancellation can only be requested a single time.\nIf you try to cancel your Activity Execution more than once, it will not receive more than one Cancellation request.\n","is_empty":false},{"file_name":"what-is-an-activity-heartbeat.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-activity-heartbeat.md","id":"concepts/what-is-an-activity-heartbeat","title":"What is an Activity Heartbeat?","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster. Each ping informs the Temporal Cluster that the Activity Execution is making progress and the Worker has not crashed.","label":"Activity Heartbeat","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAn Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.\nEach ping informs the Temporal Cluster that the Activity Execution is making progress and the Worker has not crashed.\n\n- [How to Heartbeat an Activity using the Go SDK](/go/activity-heartbeats)\n- [How to Heartbeat an Activity using the Java SDK](/java/activity-heartbeats)\n- [How to Heartbeat an Activity using the PHP SDK](/php/activity-heartbeats)\n- [How to Heartbeat an Activity using the Python SDK](/python/activity-heartbeats)\n- [How to Heartbeat an Activity using the TypeScript SDK](/typescript/activity-heartbeats)\n\nActivity Heartbeats work in conjunction with a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout).\n\nActivity Heartbeats are implemented within the Activity Definition.\nCustom progress information can be included in the Heartbeat which can then be used by the Activity Execution should a retry occur.\n\nAn Activity Heartbeat can be recorded as often as needed (e.g. once a minute or every loop iteration).\nIt is often a good practice to Heartbeat on anything but the shortest Activity Function Execution.\nTemporal SDKs control the rate at which Heartbeats are sent to the Cluster.\n\nHeartbeating is not required from [Local Activities](/concepts/what-is-a-local-activity), and does nothing.\n\nFor _long-running_ Activities, we recommend using a relatively short Heartbeat Timeout and a frequent Heartbeat.\nThat way if a Worker fails it can be handled in a timely manner.\n\nA Heartbeat can include an application layer payload that can be used to _save_ Activity Execution progress.\nIf an [Activity Task Execution](/concepts/what-is-an-activity-task-execution) times out due to a missed Heartbeat, the next Activity Task can access and continue with that payload.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\n#### Throttling\n\nHeartbeats may not always be sent to the Cluster—they may be throttled by the Worker.\nThe throttle interval is the smaller of the following:\n\n- If `heartbeatTimeout` is provided, `heartbeatTimeout * 0.8`; otherwise, `defaultHeartbeatThrottleInterval`\n- `maxHeartbeatThrottleInterval`\n\n`defaultHeartbeatThrottleInterval` is 30 seconds by default, and `maxHeartbeatThrottleInterval` is 60 seconds by default.\nEach can be set in Worker options.\n\nThrottling is implemented as follows:\n\n- After sending a Heartbeat, the Worker sets a timer for the throttle interval.\n- The Worker stops sending Heartbeats, but continues receiving Heartbeats from the Activity and remembers the most recent one.\n- When the timer fires, the Worker:\n  - Sends the most recent Heartbeat.\n  - Sets the timer again.\n\n#### Which Activities should Heartbeat?\n\nHeartbeating is best thought about not in terms of time, but in terms of \"How do you know you are making progress?\"\nFor short-term operations, progress updates are not a requirement.\nHowever, checking the progress and status of Activity Executions that run over long periods is almost always useful.\n\nConsider the following when setting Activity Hearbeats:\n\n- Your underlying task must be able to report definite progress.\n  Note that your Workflow cannot read this progress information while the Activity is still executing (or it would have to store it in Event History).\n  You can report progress to external sources if you need it exposed to the user.\n\n- Your Activity Execution is long-running, and you need to verify whether the Worker that is processing your Activity is still alive and has not run out of memory or silently crashed.\n\nFor example, the following scenarios are suitable for Heartbeating:\n\n- Reading a large file from Amazon S3.\n- Running a ML training job on some local GPUs.\n\nAnd the following scenarios are not suitable for Heartbeating:\n\n- Making a quick API call.\n- Reading a small file from disk.\n","is_empty":false},{"file_name":"what-is-an-activity-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-activity-id.md","id":"concepts/what-is-an-activity-id","title":"What is an Activity Id?","description":"A unique identifier for an Activity Execution.","label":"Activity Id","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nThe identifier for an [Activity Execution](/concepts/what-is-an-activity-execution).\nThe identifier can be generated by the system, or it can be provided by the Workflow code that spawns the Activity Execution.\nThe identifier is unique among the open Activity Executions of a [Workflow Run](/concepts/what-is-a-run-id).\n(A single Workflow Run may reuse an Activity Id if an earlier Activity Execution with the same Id has closed.)\n\nAn Activity Id can be used to [complete the Activity asynchronously](/concepts/what-is-asynchronous-activity-completion).\n","is_empty":false},{"file_name":"what-is-an-activity-task-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-activity-task-execution.md","id":"concepts/what-is-an-activity-task-execution","title":"What is an Activity Task Execution?","description":"An Activity Task Execution occurs when a Worker uses the context provided from the Activity Task and executes the Activity Definition.","label":"Activity Task Execution","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAn Activity Task Execution occurs when a [Worker](/concepts/what-is-a-worker-entity) uses the context provided from the [Activity Task](/concepts/what-is-an-activity-task) and executes the [Activity Definition](/concepts/what-is-an-activity-definition) (also known as the Activity Function).\n\nThe [ActivityTaskScheduled Event](/references/events#activitytaskscheduled) corresponds to when the Temporal Cluster puts the Activity Task into the Task Queue.\n\nThe [ActivityTaskStarted Event](/references/events#activitytaskstarted) corresponds to when the Worker picks up the Activity Task from the Task Queue.\n\nEither [ActivityTaskCompleted](/references/events#activitytaskcompleted) or one of the other Closed Activity Task Events corresponds to when the Worker has yielded back to the Temporal Cluster.\n\nThe API to schedule an Activity Execution provides an \"effectively once\" experience, even though there may be several Activity Task Executions that take place to successfully complete an Activity.\n\nOnce an Activity Task finishes execution, the Worker responds to the Cluster with a specific Event:\n\n- ActivityTaskCanceled\n- ActivityTaskCompleted\n- ActivityTaskFailed\n- ActivityTaskTerminated\n- ActivityTaskTimedOut\n","is_empty":false},{"file_name":"what-is-an-activity-task.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-activity-task.md","id":"concepts/what-is-an-activity-task","title":"What is an Activity Task?","description":"An Activity Task contains the context needed to make an Activity Task Execution.","label":"Activity Task","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAn Activity Task contains the context needed to proceed with an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\nActivity Tasks largely represent the Activity Task Scheduled Event, which contains the data needed to execute an Activity Function.\n\nIf Heartbeat data is being passed, an Activity Task will also contain the latest Heartbeat details.\n","is_empty":false},{"file_name":"what-is-an-activity-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-activity-type.md","id":"concepts/what-is-an-activity-type","title":"What is an Activity Type?","description":"An Activity Type is the mapping of a name to an Activity Definition.","label":"Activity Type","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAn Activity Type is the mapping of a name to an Activity Definition.\n\nActivity Types are scoped through Task Queues.\n","is_empty":false},{"file_name":"what-is-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-activity.md","id":"concepts/what-is-an-activity","title":"What is an Activity?","description":"In day-to-day conversation, the term \"Activity\" denotes an Activity Type, Activity Definition, or Activity Execution.","label":"Activity","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nIn day-to-day conversation, the term _Activity_ denotes an [Activity Definition](/concepts/what-is-an-activity-definition), [Activity Type](/concepts/what-is-an-activity-type), or [Activity Execution](/concepts/what-is-an-activity-execution).\nTemporal documentation aims to be explicit and differentiate between them.\n\nAn Activity is a normal function or method that executes a single, well-defined action (either short or long running), such as calling another service, transcoding a media file, or sending an email message.\nActivity code can be non-deterministic.\nWe recommend that it be [idempotent](/activities#idempotency).\n\nWorkflow code orchestrates the execution of Activities, persisting the results.\nIf an Activity Function Execution fails, any future execution starts from initial state (except [Heartbeats](/concepts/what-is-an-activity-heartbeat)).\n\nActivity Functions are executed by Worker Processes.\nWhen the Activity Function returns, the Worker sends the results back to the Temporal Cluster as part of the [ActivityTaskCompleted](/references/events#activitytaskcompleted) Event.\nThe Event is added to the Workflow Execution's Event History.\nFor other Activity-related Events, see [Activity Events](/workflows#activity-events).\n","is_empty":false},{"file_name":"what-is-an-authorizer-plugin.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-authorizer-plugin.md","id":"concepts/what-is-an-authorizer-plugin","title":"What is an Authorizer Plugin?","label":"Authorizer Plugin","tags":["term"],"ssdi":[],"markdown_content":"\nThe `Authorizer` plugin contains a single `Authorize` method, which is invoked for each incoming API call.\n`Authorize` receives information about the API call, along with the role and permission claims of the caller.\n\n`Authorizer` allows for a wide range of authorization logic, including call target, role/permissions claims, and other data available to the system.\n\n#### Configuration\n\nThe following arguments must be passed to `Authorizer`:\n\n- `context.Context`: General context of the call.\n- `authorization.Claims`: Claims about the roles assigned to the caller. Its intended use is described in the [`Claims`](#claims) section earlier on this page.\n- `authorization.CallTarget`: Target of the API call.\n\n`Authorizer` then returns one of two decisions:\n\n- `DecisionDeny`: the requested API call is not invoked and an error is returned to the caller.\n- `DecisionAllow`: the requested API call is invoked.\n\n:::warning\n\n`Authorizer` allows all API calls pass by default. Disable the `nopAuthority` authorizer and configure your own to prevent this behavior.\n\n:::\n\nConfigure your `Authorizer` when you start the server via the [`temporal.WithAuthorizer`](/references/server-options#withauthorizer) server option.\n\nIf an `Authorizer` is not set in the server options, Temporal uses the `nopAuthority` authorizer that unconditionally allows all API calls to pass through.\n\n```go\na := authorization.NewDefaultAuthorizer()\n```\n","is_empty":false},{"file_name":"what-is-an-event-history.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-event-history.md","id":"concepts/what-is-an-event-history","title":"What is an Event History?","description":"An append-only log of Events that represents the full state a Workflow Execution.","label":"Event History","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAn append-only log of [Events](/concepts/what-is-an-event) for your application.\n\n- Event History is durably persisted by the Temporal service, enabling seamless recovery of your application state from crashes or failures.\n- It also serves as an audit log for debugging.\n\n**Event History limits**\n\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\n\nThe Temporal Cluster logs a [warning after 10Ki (10,240) Events](/workflows#limits) and periodically logs additional warnings as new Events are added.\nIf the Event History exceeds 50Ki (51,200) Events, the Workflow Execution is terminated.\n","is_empty":false},{"file_name":"what-is-an-event.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-event.md","id":"concepts/what-is-an-event","title":"What is an Event?","description":"Events are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution.","label":"Event","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nEvents are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution. Each Event corresponds to an `enum` that is defined in the [Server API](https://github.com/temporalio/api/blob/master/temporal/api/enums/v1/event_type.proto).\n\nAll Events are recorded in the [Event History](/concepts/what-is-an-event-history).\n\nA list of all possible Events that could appear in a Workflow Execution Event History is provided in the [Event reference](/references/events).\n\n#### Activity Events\n\nSeven Activity-related Events are added to Event History at various points in an Activity Execution:\n\n- After a [Workflow Task Execution](/concepts/what-is-an-activity-task-execution) reaches a line of code that starts/executes an Activity, the Worker sends the Activity Type and arguments to the Temporal Cluster, and the Cluster adds an [ActivityTaskScheduled](/references/events#activitytaskscheduled) Event to Event History.\n- When `ActivityTaskScheduled` is added to History, the Cluster adds a corresponding Activity Task to the Task Queue.\n- A Worker polling that Task Queue picks up the Activity Task and runs the Activity function or method.\n- If the Activity function returns, the Worker reports completion to the Cluster, and the Cluster adds [ActivityTaskStarted](/references/events#activitytaskstarted) and [ActivityTaskCompleted](/references/events#activitytaskcompleted) to Event History.\n- If the Activity function throws a [non-retryable Failure](/kb/failures#non-retryable), the Cluster adds [ActivityTaskStarted](/references/events#activitytaskstarted) and [ActivityTaskFailed](/references/events#activitytaskfailed) to Event History.\n- If the Activity function throws an error or retryable Failure, the Cluster schedules an Activity Task retry to be added to the Task Queue (unless you’ve reached the Maximum Attempts value of the [Retry Policy](/retry-policies), in which case the Cluster adds [ActivityTaskStarted](/references/events#activitytaskstarted) and [ActivityTaskFailed](/references/events#activitytaskfailed) to Event History).\n- If the Activity’s [Start-to-Close Timeout](/activities#start-to-close-timeout) passes before the Activity function returns or throws, the Cluster schedules a retry.\n- If the Activity’s [Schedule-to-Close Timeout](/activities#schedule-to-close-timeout) passes before Activity Execution is complete, or if [Schedule-to-Start Timeout](/activities#schedule-to-start-timeout) passes before a Worker gets the Activity Task, the Cluster writes [ActivityTaskTimedOut](/references/events#activitytasktimedout) to Event History.\n- If the Activity is [canceled](/activities#cancellation), the Cluster writes [ActivityTaskCancelRequested](/references/events#activitytaskcancelrequested) to Event History, and if the Activity accepts cancellation, the Cluster writes [ActivityTaskCanceled](/references/events#activitytaskcanceled).\n\n:::note\n\nWhile the Activity is running and retrying, [ActivityTaskScheduled](/references/events#activitytaskscheduled) is the only Activity-related Event in History: [ActivityTaskStarted](/references/events#activitytaskstarted) is written along with a terminal Event like [ActivityTaskCompleted](/references/events#activitytaskcompleted) or [ActivityTaskFailed](/references/events#activitytaskfailed).\n\n:::\n","is_empty":false},{"file_name":"what-is-an-update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-an-update.md","id":"concepts/what-is-an-update","title":"What is an Update?","description":"An Update is a request to and a response from Workflow Execution.","label":"Update","tags":["term","updates","explanation"],"ssdi":["Released in [Temporal Server version 1.21](https://github.com/temporalio/temporal/releases/tag/v1.21.0)","Available in the Go SDK since [v1.23.0](https://pkg.go.dev/go.temporal.io/sdk/client?tab=versions)"],"markdown_content":"\nAn Update is a request to and a response from a Temporal Client to a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\n- [How to develop, send, and handle Updates in Go](/go/updates)\n\nThe Workflow must have a function to handle the Update.\nUnlike a [Signal](/concepts/what-is-a-signal) handler, the Update handler function can mutate the state of the Workflow while also returning a value to the caller.\nThe Update handler listens for Updates by the Update's name.\n\nWhen there is the potential for multiple Updates to cause a duplication problem, Temporal recommends adding idempotency logic to your Update handler that checks for duplicates.\n\nAn Update has four phases.\n\n1. **Admission.** The Temporal Cluster first validates Update submissions against the configured resource usage limits.\n   For example, limits apply to concurrent requests and requests per second.\n   See the [Temporal Platform limits sheet](/kb/temporal-platform-limits-sheet) for more details.\n   When this phase is complete, the Platform changes the status of the Update to **Admitted**.\n   At this stage, the Platform hasn't yet persisted the Update to the Workflow Execution's Event History or sent it to a Worker.\n1. **Validation.** An optional developer provided function that performs request validation.\n   This validation code, similar to a [Query](/concepts/what-is-a-query) handler, can observe but not change the Workflow state.\n   This means that the validation of an Update request may depend on the Workflow state at runtime.\n   If an Update request doesn't pass validation at this stage, the system rejects the request and doesn't record anything in the Workflow Event History to indicate that the Update ever happened.\n   The Update processing doesn't proceed to later phases.\n   When the Update completes the validation stage, the Platform changes its state to **Accepted**.\n   A [WorkflowExecutionUpdateAcceptedEvent](/references/events#workflowexecutionupdateacceptedevent) Event in the Workflow Execution [Event History](#event-history) denotes the acceptance of an Update.\n1. **Execution.** Accepted Update requests move to the execution phase.\n   In this phase, the Worker delivers the request to the Update handler.\n   Like every bit of code in a Workflow, Update handlers must be [deterministic](/concepts/what-is-a-workflow-definition#deterministic-constraints).\n1. **Completion.** The Update handler can return a result or a language-appropriate error/exception to indicate its completion.\n   The Platform sends the Update outcome back to the original invoking entity as an Update response.\n   A [WorkflowExecutionUpdateCompletedEvent](/references/events#workflowexecutionupdatecompletedevent) Event in the Workflow Execution Event History denotes the completion of an Update.\n","is_empty":false},{"file_name":"what-is-archival.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-archival.md","id":"concepts/what-is-archival","title":"What is Archival?","description":"Archival is a feature that automatically backs up Event Histories from Temporal Cluster persistence to a custom blob store after the Closed Workflow Execution retention period is reached.","label":"Archival","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nArchival is a feature that automatically backs up [Event Histories](/concepts/what-is-an-event-history) and Visibility records from Temporal Cluster persistence to a custom blob store.\n\n- [How to create a custom Archiver](/clusters/how-to-create-a-custom-archiver)\n- [How to set up Archival](/clusters/how-to-set-up-archival)\n\nWorkflow Execution Event Histories are backed up after the [Retention Period](/concepts/what-is-a-namespace#retention-period) is reached.\nVisibility records are backed up immediately after a Workflow Execution reaches a Closed status.\n\nArchival enables Workflow Execution data to persist as long as needed, while not overwhelming the Cluster's persistence store.\n\nThis feature is helpful for compliance and debugging.\n\nTemporal's Archival feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nArchival is not supported when running Temporal through Docker and is disabled by default when installing the system manually and when deploying through [helm charts](https://github.com/temporalio/helm-charts/blob/master/templates/server-configmap.yaml) (but can be enabled in the [config](https://github.com/temporalio/temporal/blob/master/config/development.yaml)).\n","is_empty":false},{"file_name":"what-is-asynchronous-activity-completion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-asynchronous-activity-completion.md","id":"concepts/what-is-asynchronous-activity-completion","title":"What is Asynchronous Activity Completion?","description":"Asynchronous Activity Completion occurs when an external system provides the final result of a computation, started by an Activity, to the Temporal System.","label":"Asynchronous Activity Completion","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAsynchronous Activity Completion is a feature that enables an Activity Function to return without causing the Activity Execution to complete.\nThe Temporal Client can then be used to both Heartbeat Activity Execution progress and eventually provide a result.\n\n- [How to complete an Activity Asynchronously in Go](/go/async-activity-completion)\n- [How to complete an Activity Asynchronously in Java](/java/async-activity-completion)\n- [How to complete an Activity Asynchronously in PHP](/php/async-activity-completion)\n- [How to complete an Activity Asynchronously in Python](/python/async-activity-completion)\n- [How to complete an Activity Asynchronously in TypeScript](/typescript/async-activity-completion)\n\n#### When to use Async Completion\n\nThe intended use-case for this feature is when an external system has the final result of a computation, started by an Activity.\n\nConsider using Asynchronous Activities instead of Signals if the external process is unreliable and might fail to send critical status updates through a Signal.\n\nConsider using [Signals](/concepts/what-is-a-signal) as an alternative to Asynchronous Activities to return data back to a Workflow Execution if there is a human in the process loop.\nThe reason is that a human in the loop means multiple steps in the process.\nThe first is the Activity Function that stores state in an external system and at least one other step where a human would “complete” the activity.\nIf the first step fails, you want to detect that quickly and retry instead of waiting for the entire process, which could be significantly longer when humans are involved.\n","is_empty":false},{"file_name":"what-is-audit-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-audit-logging.md","id":"concepts/what-is-audit-logging","title":"What is Audit Logging?","description":"Audit Logging is a feature that provides forensic access information for accounts, users, and Namespaces.","label":"Audit Logging","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nAudit Logging is a feature of [Temporal Cloud](/concepts/what-is-temporal-cloud) that provides forensic access information at the account level, the user level, and the [Namespace](/concepts/what-is-a-namespace) level.\n\nAudit Logging answers \"who, when, and what\" questions about Temporal Cloud resources.\nThese answers can help you evaluate the security of your organization, and they can provide information that you need to satisfy audit and compliance requirements.\n","is_empty":false},{"file_name":"what-is-cluster-configuration.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-cluster-configuration.md","id":"concepts/what-is-cluster-configuration","title":"What is Cluster configuration?","description":"Cluster Configuration is the setup and configuration details of your Temporal Cluster, defined using YAML.","label":"Cluster configuration","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nCluster configuration is the setup and configuration details of your self-hosted Temporal Cluster, defined using YAML.\nYou must define your Cluster configuration when setting up your self-hosted Temporal Cluster.\n\nFor details on using Temporal Cloud, see [Temporal Cloud documentation](/cloud).\n\nCluster configuration is composed of two types of configuration: [Static configuration](#static-configuration) and [Dynamic configuration](#dynamic-configuration).\n\n### Static configuration\n\nStatic configuration contains details of how the Cluster should be set up.\nThe static configuration is read just once and used to configure service nodes at startup.\nDepending on how you want to deploy your self-hosted Temporal Cluster, your static configuration must contain details for setting up:\n\n- Temporal Services—Frontend, History, Matching, Worker\n- Membership ports for the Temporal Services\n- Persistence (including History Shard count), Visibility, Archival store setups.\n- TLS, authentication, authorization\n- Server log level\n- Metrics\n- Cluster metadata\n- Dynamic config Client\n\nStatic configuration values cannot be changed at runtime.\nSome values, such as the Metrics configuration or Server log level can be changed in the static configuration but require restarting the Cluster for the changes to take effect.\n\nFor details on static configuration keys, see [Cluster configuration reference](/references/configuration).\n\nFor static configuration examples, see <https://github.com/temporalio/temporal/tree/master/config>.\n\n### Dynamic configuration\n\nDynamic configuration contains configuration keys that you can update in your Cluster setup without having to restart the server processes.\n\nAll dynamic configuration keys provided by Temporal have default values that are used by the Cluster.\nYou can override the default values by setting different values for the keys in a YAML file and setting the [dynamic configuration client](/references/configuration#dynamicconfigclient) to poll this file for updates.\nSetting dynamic configuration for your Cluster is optional.\n\nSetting overrides for some configuration keys updates the Cluster configuration immediately.\nHowever, for configuration fields that are checked at startup (such as thread pool size), you must restart the server for the changes to take effect.\n\nUse dynamic configuration keys to fine-tune your self-deployed Cluster setup.\n\nFor details on dynamic configuration keys, see [Dynamic configuration reference](/references/dynamic-configuration).\n\nFor dynamic configuration examples, see <https://github.com/temporalio/temporal/tree/master/config/dynamicconfig>.\n","is_empty":false},{"file_name":"what-is-cluster-observability.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-cluster-observability.md","id":"concepts/what-is-cluster-obervability","title":"What is Cluster observability?","description":"Monitor and observe Cluster performance with metrics emitted by your self-hosted Temporal Cluster or by Temporal Cloud.","label":"Monitoring and observation","tags":["explanation"],"ssdi":[],"markdown_content":"\nYou can monitor and observe performance with metrics emitted by your self-hosted Temporal Cluster or by Temporal Cloud.\n\nTemporal emits metrics by default in a format that is supported by Prometheus.\nAny metrics software that supports the same format can be used.\nCurrently, we test with the following Prometheus and Grafana versions:\n\n- **Prometheus >= v2.0**\n- **Grafana >= v2.5**\n\nTemporal Cloud emits metrics through a Prometheus HTTP API endpoint, which can be directly used as a Prometheus data source in Grafana or to query and export Cloud metrics to any observability platform.\n\nFor details on Cloud metrics and setup, see the following:\n\n- [Temporal Cloud metrics reference](/cloud/how-to-monitor-temporal-cloud-metrics)\n- [Set up Grafana with Temporal Cloud observability to view metrics](/kb/prometheus-grafana-setup-cloud#data-sources-configuration-for-temporal-cloud-and-sdk-metrics-in-grafana)\n\nOn self-hosted Temporal Clusters, expose Prometheus endpoints in your Cluster configuration and configure Prometheus to scrape metrics from the endpoints.\nYou can then set up your observability platform (such as Grafana) to use Prometheus as a data source.\n\nFor details on self-hosted Cluster metrics and setup, see the following:\n\n- [Temporal Cluster OSS metrics reference](/references/cluster-metrics)\n- [Set up Prometheus and Grafana to view SDK and self-hosted Cluster metrics](/kb/prometheus-grafana-setup)\n","is_empty":false},{"file_name":"what-is-cluster-security-configuration.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-cluster-security-configuration.md","id":"concepts/what-is-cluster-security-configuration","title":"What is Cluster security configuration?","description":"Secure your Temporal Cluster (self-hosted and Temporal Cloud) by encrypting your network communication and setting authentication and authorization protocols for API calls.","label":"Temporal Cluster security configuration","tags":["explanation"],"ssdi":[],"markdown_content":"\nSecure your Temporal Cluster (self-hosted and Temporal Cloud) by encrypting your network communication and setting authentication and authorization protocols for API calls.\n\nFor details on setting up your Temporal Cluster security, see [Temporal Platform security features](/security).\n\n#### mTLS encryption\n\nTemporal supports Mutual Transport Layer Security (mTLS) to encrypt network traffic between services within a Temporal Cluster, or between application processes and a Cluster.\n\nOn self-hosted Temporal Clusters, configure mTLS in the `tls` section of the [Cluster configuration](/references/configuration#tls).\nmTLS configuration is a [static configuration](#static-configuration) property.\n\nYou can then use either the [`WithConfig`](/references/server-options#withconfig) or [`WithConfigLoader`](/references/server-options#withconfigloader) server option to start your Temporal Cluster with this configuration.\n\nThe mTLS configuration includes two sections that serve to separate communication within a Temporal Cluster and client calls made from your application to the Cluster.\n\n- `internode`: configuration for encrypting communication between nodes within the Cluster.\n- `frontend`: configuration for encrypting the public endpoints of the Frontend Service.\n\nSetting mTLS for `internode` and `frontend` separately lets you use different certificates and settings to encrypt each section of traffic.\n\n#### Using certificates for Client connections\n\nUse CA certificates to authenticate client connections to your Temporal Cluster.\n\nOn Temporal Cloud, you can [set your CA certificates in your Temporal Cloud settings](/cloud/how-to-manage-certificates-in-temporal-cloud) and use the end-entity certificates in your client calls.\n\nOn self-hosted Temporal Clusters, you can restrict access to Temporal Cluster endpoints by using the `clientCAFiles` or `clientCAData` property and the [`requireClientAuth`](/references/configuration#tls) property in your Cluster configuration.\nThese properties can be specified in both the `internode` and `frontend` sections of the [mTLS configuration](/references/configuration#tls).\nFor details, see the [tls configuration reference](/references/configuration#tls).\n\n#### Server name specification\n\nOn self-hosted Temporal Clusters, you can specify `serverName` in the `client` section of your mTLS configuration to prevent spoofing and [MITM attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack).\n\nEntering a value for `serverName` enables established connections to authenticate the endpoint.\nThis ensures that the server certificate presented to any connected client has the specified server name in its CN property.\n\nThis measure can be used for `internode` and `frontend` endpoints.\n\nFor more information on mTLS configuration, see [tls configuration reference](/references/configuration#tls).\n\n#### Authentication and authorization\n\n<!-- commenting this very generic explanation out. Can include it back in if everyone feels strongly.\n **Authentication** is the process of verifying users who want to access your application are actually the users you want accessing it.\n**Authorization** is the verification of applications and data that a user on your Cluster or application has access to. -->\n\nTemporal provides authentication interfaces that can be set to restrict access to your data.\nThese protocols address three areas: servers, client connections, and users.\n\nTemporal offers two plugin interfaces for authentication and authorization of API calls.\n\n- [`ClaimMapper`](/concepts/what-is-a-claimmapper-plugin)\n- [`Authorizer`](/concepts/what-is-an-authorizer-plugin)\n\nThe logic of both plugins can be customized to fit a variety of use cases.\nWhen plugins are provided, the Frontend Service invokes their implementation before running the requested operation.\n","is_empty":false},{"file_name":"what-is-continue-as-new.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-continue-as-new.md","id":"concepts/what-is-continue-as-new","title":"What is Continue-As-New?","description":"Continue-As-New is the mechanism by which all relevant state is passed to a new Workflow Execution with a fresh Event History.","label":"Continue-As-New","tags":["term","explanation","continue-as-new"],"ssdi":[],"markdown_content":"\nContinue-As-New is a mechanism by which the latest relevant state is passed to a new Workflow Execution, with a fresh Event History.\n\nAs a precautionary measure, the Temporal Platform limits the total [Event History](/concepts/what-is-an-event-history) to 51,200 Events or 50 MB, and will warn you after 10,240 Events or 10 MB.\nTo prevent a Workflow Execution Event History from exceeding this limit and failing, use Continue-As-New to start a new Workflow Execution with a fresh Event History.\n\nAll values passed to a Workflow Execution through parameters or returned through a result value are recorded into the Event History.\nA Temporal Cluster stores the full Event History of a Workflow Execution for the duration of a Namespace's retention period.\nA Workflow Execution that periodically executes many Activities has the potential of hitting the size limit.\n\nA very large Event History can adversely affect the performance of a Workflow Execution.\nFor example, in the case of a Workflow Worker failure, the full Event History must be pulled from the Temporal Cluster and given to another Worker via a Workflow Task.\nIf the Event history is very large, it may take some time to load it.\n\nThe Continue-As-New feature enables developers to complete the current Workflow Execution and start a new one atomically.\n\nThe new Workflow Execution has the same Workflow Id, but a different Run Id, and has its own Event History.\n\nIn the case of [Temporal Cron Jobs](/concepts/what-is-a-temporal-cron-job), Continue-As-New is actually used internally for the same effect.\n\n- [How to Continue-As-New using the Go SDK](/go/continue-as-new)\n- [How to Continue-As-New using the Java SDK](/java/continue-as-new)\n- [How to Continue-As-New using the PHP SDK](/php/continue-as-new)\n- [How to Continue-As-New using the Python SDK](/python/continue-as-new)\n- [How to Continue-As-New using the TypeScript SDK](/typescript/continue-as-new)\n","is_empty":false},{"file_name":"what-is-dual-visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-dual-visibility.md","id":"concepts/what-is-dual-visibility","title":"What is Dual Visibility?","description":"Dual Visibility is a feature that lets you set a secondary Visibility store in your Temporal Cluster to facilitate migrating your Visibility data from one database to another.","label":"Dual Visibility","tags":["term","explanation","filtered-lists","visibility"],"ssdi":[],"markdown_content":"\nDual Visibility is a feature that lets you set a secondary Visibility store in addition to a primary store in your Temporal Cluster.\nSetting up Dual Visibility is optional and can be used to [migrate your Visibility database](/cluster-deployment-guide#migrating-visibility-database) or create a backup Visibility store.\n\nFor example, if you have Cassandra configured as your Visibility database, you can set up a supported SQL database as your secondary Visibility store and gradually migrate your data to the secondary store before deprecating your primary one.\n\nA Dual Visibility setup requires two Visibility store configurations:\n\n- **Primary Visibility**: The primary Visibility store where Visibility data is written to and read from by default. The primary Visibility store is set with the `visibilityStore` configuration key in your Temporal Cluster.\n- **Secondary Visibility**: A secondary storage for your Visibility data. The secondary Visibility store is set with the `secondaryVisibilityStore` configuration key in your Temporal Cluster.\n\nFor configuration details, see [Dual Visibility setup](/cluster-deployment-guide#dual-visibility).\n\nThe following combinations are allowed in a Dual Visibility setting.\n\n| Primary                     | Secondary                       |\n| --------------------------- | ------------------------------- |\n| Standard (Cassandra or SQL) | Advanced (SQL or Elasticsearch) |\n| Advanced (SQL)              | Advanced (SQL)                  |\n| Advanced (Elasticsearch)    | Advanced (Elasticsearch)        |\n\nWith Dual Visibility, you can read from only one Visibility store at a time, but can configure your Temporal Cluster to write to primary only, secondary only, or to both primary and secondary Visibility stores.\nWhen migrating from one Visibility store database to another, set up the database you want to migrate to as your secondary Visibility store.\n\nYou can plan your migration using specific dynamic configuration keys that help you transition your read and write operations from the primary to the secondary Visibility store.\nFor details on migrating your Visibility store databases, see [Dual Visibility](/clusters/how-to-set-up-dual-visibility).\n","is_empty":false},{"file_name":"what-is-multi-cluster-replication.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-multi-cluster-replication.md","id":"concepts/what-is-multi-cluster-replication","title":"What is Multi-Cluster Replication?","description":"Multi-Cluster Replication is a feature which asynchronously replicates Workflow Executions from active Clusters to other passive Clusters, for backup and state reconstruction.","label":"Multi-Cluster Replication","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nMulti-Cluster Replication is a feature which asynchronously replicates Workflow Executions from active Clusters to other passive Clusters, for backup and state reconstruction.\nWhen necessary, for higher availability, Cluster operators can failover to any of the backup Clusters.\n\nTemporal's Multi-Cluster Replication feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nTemporal automatically forwards Start, Signal, and Query requests to the active Cluster.\nThis feature must be enabled through a Dynamic Config flag per [Global Namespace](/concepts/what-is-a-global-namespace).\n\nWhen the feature is enabled, Tasks are sent to the Parent Task Queue partition that matches that Namespace, if it exists.\n\nAll Visibility APIs can be used against active and standby Clusters.\nThis enables [Temporal UI](https://docs.temporal.io/web-ui) to work seamlessly for Global Namespaces.\nApplications making API calls directly to the Temporal Visibility API continue to work even if a Global Namespace is in standby mode.\nHowever, they might see a lag due to replication delay when querying the Workflow Execution state from a standby Cluster.\n\n#### Namespace Versions\n\nA _version_ is a concept in Multi-Cluster Replication that describes the chronological order of events per Namespace.\n\nWith Multi-Cluster Replication, all Namespace change events and Workflow Execution History events are replicated asynchronously for high throughput.\nThis means that data across clusters is **not** strongly consistent.\nTo guarantee that Namespace data and Workflow Execution data will achieve eventual consistency (especially when there is a data conflict during a failover), a **version** is introduced and attached to Namespaces.\nAll Workflow Execution History entries generated in a Namespace will also come with the version attached to that Namespace.\n\nAll participating Clusters are pre-configured with a unique initial version and a shared version increment:\n\n- `initial version < shared version increment`\n\nWhen performing failover for a Namespace from one Cluster to another Cluster, the version attached to the Namespace will be changed by the following rule:\n\n- for all versions which follow `version % (shared version increment) == (active cluster's initial version)`, find the smallest version which has `version >= old version in namespace`\n\nWhen there is a data conflict, a comparison will be made and Workflow Execution History entries with the highest version will be considered the source of truth.\n\nWhen a cluster is trying to mutate a Workflow Execution History, the version will be checked.\nA cluster can mutate a Workflow Execution History only if the following is true:\n\n- The version in the Namespace belongs to this cluster, i.e.\n  `(version in namespace) % (shared version increment) == (this cluster's initial version)`\n- The version of this Workflow Execution History's last entry (event) is equal or less than the version in the Namespace, i.e.\n  `(last event's version) <= (version in namespace)`\n\n<details>\n<summary>Namespace version change example\n</summary>\n\nAssuming the following scenario:\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: Namespace α is registered, with active Cluster set to Cluster A\n\n```\nnamespace α's version is 1\nall workflows events generated within this namespace, will come with version 1\n```\n\nT = 1: namespace β is registered, with active Cluster set to Cluster B\n\n```\nnamespace β's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 2: Namespace α is updated to with active Cluster set to Cluster B\n\n```\nnamespace α's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 3: Namespace β is updated to with active Cluster set to Cluster A\n\n```\nnamespace β's version is 11\nall workflows events generated within this namespace, will come with version 11\n```\n\n</details>\n\n#### Version history\n\nVersion history is a concept which provides a high level summary of version information in regards to Workflow Execution History.\n\nWhenever there is a new Workflow Execution History entry generated, the version from Namespace will be attached.\nThe Workflow Executions's mutable state will keep track of all history entries (events) and the corresponding version.\n\n<details>\n<summary>Version history example (without data conflict)\n</summary>\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: adding event with event ID == 1 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 1               | 1       |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 2 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 2: adding event with event ID == 3 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               |                 |         |\n| 3        | 1               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 3: Namespace failover triggered, Namespace version is now 2\nadding event with event ID == 4 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               | 4               | 2       |\n| 3        | 1               |                 |         |\n| 4        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 4: adding event with event ID == 5 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               | 5               | 2       |\n| 3        | 1               |                 |         |\n| 4        | 2               |                 |         |\n| 5        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n</details>\n\nSince Temporal is AP, during failover (change of active Temporal Cluster Namespace), there can exist cases where more than one Cluster can modify a Workflow Execution, causing divergence of Workflow Execution History. Below shows how the version history will look like under such conditions.\n\n<details>\n<summary>Version history example (with data conflict)\n</summary>\n\nBelow, shows version history of the same Workflow Execution in 2 different Clusters.\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Cluster C comes with initial version: 3\n- Shared version increment: 10\n\nT = 0:\n\nView in both Cluster B & C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 3               | 2       |\n| 3        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 4 & version == 2 in Cluster B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 4               | 2       |\n| 3        | 2               |                 |         |\n| 4        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 1: namespace failover to Cluster C, adding event with event ID == 4 & version == 3 in Cluster C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 3               | 2       |\n| 3        | 2               | 4               | 3       |\n| 4        | 3               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster C arrives in Cluster B\n\nNote: below are a tree structures\n\n```\n                | -------- | ------------- |\n                | Events        |\n                | ------------- | ------------- |\n                | Event ID      | Event Version |\n                | --------      | ------------- |\n                | 1             | 1             |\n                | 2             | 1             |\n                | 3             | 2             |\n                | --------      | ------------- |\n                |               |\n                | ------------- | ------------  |\n                |               |\n                | --------      | ------------- |  | -------- | ------------- |\n                | Event ID      | Event Version |  | Event ID | Event Version |\n                | --------      | ------------- |  | -------- | ------------- |\n                | 4             | 2             |  | 4        | 3             |\n                | --------      | ------------- |  | -------- | ------------- |\n\n          | --------------- | ------- |\n          | Version History |\n          | --------------- | ------------------- |\n          | Event ID        | Version             |\n          | --------------- | -------             |\n          | 2               | 1                   |\n          | 3               | 2                   |\n          | --------------- | -------             |\n          |                 |\n          | -------         | ------------------- |\n          |                 |\n          | --------------- | -------             |  | --------------- | ------- |\n          | Event ID        | Version             |  | Event ID        | Version |\n          | --------------- | -------             |  | --------------- | ------- |\n          | 4               | 2                   |  | 4               | 3       |\n          | --------------- | -------             |  | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster B arrives in Cluster C, same as above\n\n</details>\n\n#### Conflict resolution\n\nWhen a Workflow Execution History diverges, proper conflict resolution is applied.\n\nIn Multi-cluster Replication, Workflow Execution History Events are modeled as a tree, as shown in the second example in [Version History](#version-history).\n\nWorkflow Execution Histories that diverge will have more than one history branch.\nAmong all history branches, the history branch with the highest version is considered the `current branch` and the Workflow Execution's mutable state is a summary of the current branch.\nWhenever there is a switch between Workflow Execution History branches, a complete rebuild of the Workflow Execution's mutable state will occur.\n\nTemporal Multi-Cluster Replication relies on asynchronous replication of Events across Clusters, so in the case of a failover it is possible to have an Activity Task dispatched again to the newly active Cluster due to a replication task lag.\nThis also means that whenever a Workflow Execution is updated after a failover by the new Cluster, any previous replication tasks for that Execution cannot be applied.\nThis results in loss of some progress made by the Workflow Execution in the previous active Cluster.\nDuring such conflict resolution, Temporal re-injects any external Events like Signals in the new Event History before discarding replication tasks.\nEven though some progress could roll back during failovers, Temporal provides the guarantee that Workflow Executions won’t get stuck and will continue to make forward progress.\n\nActivity Execution completions are not forwarded across Clusters.\nAny outstanding Activities will eventually time out based on the configuration.\nYour application should have retry logic in place so that the Activity gets retried and dispatched again to a Worker after the failover to the new Cluster.\nHandling this is similar to handling an Activity Task timeout caused by a Worker restarting.\n\n#### Zombie Workflows\n\nThere is an existing contract that for any Namespace and Workflow Id combination, there can be at most one run (Namespace + Workflow Id + Run Id) open / executing.\n\nMulti-cluster Replication aims to keep the Workflow Execution History as up-to-date as possible among all participating Clusters.\n\nDue to the nature of Multi-cluster Replication (for example, Workflow Execution History events are replicated asynchronously) different Runs (same Namespace and Workflow Id) can arrive at the target Cluster at different times, sometimes out of order, as shown below:\n\n```\n| ------------- |          | ------------- |          | ------------- |\n| Cluster A |  | Network Layer |  | Cluster B |\n| --------- || ------------- |          | ------------- |\n        |                          |                          |\n        | Run 1 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        | Run 2 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          | Run 2 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n        |                          | Run 1 Replication Events |\n        |                          | -----------------------> |\n        |     |  |\n        | --- || ------------- |          | ------------- |\n| Cluster A |  | Network Layer |  | Cluster B |\n| --------- || ------------- |          | ------------- |\n```\n\nBecause Run 2 appears in Cluster B first, Run 1 cannot be replicated as \"runnable\" due to the rule `at most one Run open` (see above), thus the \"zombie\" Workflow Execution state is introduced.\nA \"zombie\" state is one in which a Workflow Execution which cannot be actively mutated by a Cluster (assuming the corresponding Namespace is active in this Cluster). A zombie Workflow Execution can only be changed by a replication Task.\n\nRun 1 will be replicated similar to Run 2, except when Run 1's execution will become a \"zombie\" before Run 1 reaches completion.\n\n#### Workflow Task processing\n\nIn the context of Multi-cluster Replication, a Workflow Execution's mutable state is an entity which tracks all pending tasks.\nPrior to the introduction of Multi-cluster Replication, Workflow Execution History entries (events) are from a single branch, and the Temporal Server will only append new entries (events) to the Workflow Execution History.\n\nAfter the introduction of Multi-cluster Replication, it is possible that a Workflow Execution can have multiple Workflow Execution History branches.\nTasks generated according to one history branch may become invalidated by switching history branches during conflict resolution.\n\nExample:\n\nT = 0: task A is generated according to Event Id: 4, version: 2\n\n```\n| -------- | ------------- |\n| Events   |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 1        | 1             |\n| 2        | 1             |\n| 3        | 2             |\n| -------- | ------------- |\n|          |\n|          |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event |\n| -------- | ------------- |\n```\n\nT = 1: conflict resolution happens, Workflow Execution's mutable state is rebuilt and history Event Id: 4, version: 3 is written down to persistence\n\n```\n| -------- | ------------- |\n| Events        |\n| ------------- | -------------------------------------------- |\n| Event ID      | Event Version                                |\n| --------      | -------------                                |\n| 1             | 1                                            |\n| 2             | 1                                            |\n| 3             | 2                                            |\n| --------      | -------------                                |\n|               |\n| ------------- | -------------------------------------------- |\n|               |\n| --------      | -------------                                |                                  | -------- | ------------- |\n| Event ID      | Event Version                                |                                  | Event ID | Event Version |\n| --------      | -------------                                |                                  | -------- | ------------- |\n| 4             | 2                                            | <-- task A belongs to this event | 4        | 3             | <-- current branch / mutable state |\n| --------      | -------------                                |                                  | -------- | ------------- |\n```\n\nT = 2: task A is loaded.\n\nAt this time, due to the rebuild of a Workflow Execution's mutable state (conflict resolution), Task A is no longer relevant (Task A's corresponding Event belongs to non-current branch).\nTask processing logic will verify both the Event Id and version of the Task against a corresponding Workflow Execution's mutable state, then discard task A.\n","is_empty":false},{"file_name":"what-is-persistence.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-persistence.md","id":"concepts/what-is-persistence","title":"What is Persistence?","description":"The Temporal Persistence store is a database used by Temporal Services to persist events generated and processed in the Temporal Cluster and SDK.","label":"Persistence","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nThe Temporal Persistence store is a database used by [Temporal Services](/concepts/what-is-the-temporal-server) to persist events generated and processed in your Temporal Cluster and SDK.\n\nA Temporal Cluster's only required dependency for basic operation is the Persistence database.\nMultiple types of databases are supported.\n\n![Persistence](/diagrams/temporal-database.svg)\n\nThe database stores the following types of data:\n\n- Tasks: Tasks to be dispatched.\n- State of Workflow Executions:\n  - Execution table: A capture of the mutable state of Workflow Executions.\n  - History table: An append-only log of Workflow Execution History Events.\n- Namespace metadata: Metadata of each Namespace in the Cluster.\n- [Visibility](/concepts/what-is-visibility) data: Enables operations like \"show all running Workflow Executions\".\n  For production environments, we recommend using Elasticsearch as your Visibility store.\n\nAn Elasticsearch database must be configured in a self-hosted Cluster to enable [advanced Visibility](/concepts/what-is-advanced-visibility) on Temporal Server versions 1.19.1 and earlier.\n\nWith Temporal Server version 1.20 and later, advanced Visibility features are available on SQL databases like MySQL (version 8.0.17 and later), PostgreSQL (version 12 and later), SQLite (v3.31.0 and later), and Elasticsearch.\n\n#### Dependency versions\n\nTemporal tests compatibility by spanning the minimum and maximum stable major versions for each supported database.\nThe following versions are used in our test pipelines and actively tested before we release any version of Temporal:\n\n- **Cassandra v3.11 and v4.0**\n- **PostgreSQL v10.18 and v13.4**\n- **MySQL v5.7 and v8.0** (specifically 8.0.19+ due to a bug)\n\nYou can verify supported databases in the [Temporal Server release notes](https://github.com/temporalio/temporal/releases).\n\n- Because Temporal Server primarily relies on core database functionality, we do not expect compatibility to break often.\n  <!--Temporal has no opinions on database upgrade paths; as long as you can upgrade your database according to each project's specifications, Temporal should work with any version within supported ranges.-->\n- We do not run tests with vendors like Vitess and CockroachDB.\n- Temporal also supports SQLite v3.x persistence, but this is meant only for development and testing, not production usage.\n","is_empty":false},{"file_name":"what-is-remote-data-encoding.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-remote-data-encoding.md","id":"concepts/what-is-remote-data-encoding","title":"What is remote data encoding?","description":"Remote data encding is using your custom Data Converter to decode (and encode) your Payloads remotely through endpoints.","label":"Remote data encoding","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nRemote data encoding is exposing your Payload Codec via HTTP endpoints to support remote encoding and decoding.\n\nRunning your encoding remotely allows you to use it with `tctl` to encode/decode data for several commands including `tctl workflow start` and with Temporal Web UI to encode and decode data in your Workflow Execution details view.\n\nTo run data encoding/decoding remotely, use a [Codec Server](/concepts/what-is-a-codec-server). A Codec Server is an HTTP server that is configured to use your custom Payload Codec.\n\n<!-- Note that currently only Go and Java SDKs support setting a remote Payload Codec with a custom Data Converter.\nYou can however create a Codec Server in any of the SDKs, and use it to decode payloads on the Web UI and in `tctl`.-->\n\nBefore you use a remote data encoder to encode/decode your data, ensure that you consider all the security implications of running codecs remotely. For example, codecs that perform encryption may need to be secured to prevent decryption by untrusted callers.\n\n#### Encoding data on the Web UI and tctl\n\nYou can perform some operations on your Workflow Execution using tctl and the Web UI, such as starting or sending a Signal to an active Workflow Execution using tctl or canceling a Workflow Execution from the Web UI, which might require inputs that contain sensitive data.\n\nTo encode this data, [specify your Codec Server endpoints](/dataconversion#setting-codec-server-endpoints) with the tctl command and configure your Web UI to use the Codec Server endpoints.\n\n#### Decoding data on the Web UI and tctl\n\nIf you use custom encoding in your custom Data Converter, Payload data handled by the Temporal Cluster is encoded. Since the Web UI uses the [Visibility](/concepts/what-is-visibility) database to show events and data stored on the Temporal Server, all data in the Workflow Execution History in your Web UI or tctl shows in the encoded format.\n\nTo see the original format of data in your Web UI and tctl, create a [Codec Server](/concepts/what-is-a-codec-server) with a remote data encoder and use the Payload Codec to decode your data locally.\n\nNote that a remote data encoder is a separate system with access to your encryption keys and exposes APIs to encode and decode any data with the Payload Codec used. Evaluate and ensure that your remote data encoder endpoints are secured and only authorized users have access to them.\n\nSamples:\n\n- [Go](https://github.com/temporalio/samples-go/tree/main/codec-server)\n- [Java](https://github.com/temporalio/sdk-java/tree/master/temporal-remote-data-encoder)\n- [Python](https://github.com/temporalio/samples-python/tree/main/encryption)\n- [TypeScript](https://github.com/temporalio/samples-typescript/tree/main/encryption)\n","is_empty":false},{"file_name":"what-is-standard-visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-standard-visibility.md","id":"concepts/what-is-standard-visibility","title":"What is standard Visibility?","description":"Standard Visibility, within the Temporal Platform, is the subsystem and APIs that list Workflow Executions by a predefined set of filters.","label":"Standard Visibility","tags":["explanation","filtered-lists","visibility"],"ssdi":[],"markdown_content":"\nStandard Visibility, within the Temporal Platform, is the subsystem and APIs that list Workflow Executions by a predefined set of filters.\n\nOpen Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, or Run Id.\n\nClosed Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, Run Id, or Execution Status (Completed, Failed, Timed Out, Terminated, Canceled, or Continued-As-New).\n\nSupport for standard Visibility is deprecated beginning with Temporal Server v1.21.\nFor updates, check [Supported databases](/cluster-deployment-guide#supported-databases).\n","is_empty":false},{"file_name":"what-is-task-routing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-task-routing.md","id":"concepts/what-is-task-routing","title":"What is Task Routing?","description":"Task Routing is when a Task Queue is paired with one or more Worker Processes, primarily for Activity Task Executions.","label":"Task Routing","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nTask Routing is simply when a Task Queue is paired with one or more Workers, primarily for Activity Task Executions.\n\nThis could also mean employing multiple Task Queues, each one paired with a Worker Process.\n\nTask Routing has many applicable use cases.\n\nSome SDKs provide a [Session API](/concepts/what-is-a-worker-session) that provides a straightforward way to ensure that Activity Tasks are executed with the same Worker without requiring you to manually specify Task Queue names.\nIt also includes features like concurrent session limitations and worker failure detection.\n\n### Flow control\n\nA Worker that consumes from a Task Queue asks for an Activity Task only when it has available capacity, so it is never overloaded by request spikes.\nIf Activity Tasks get created faster than Workers can process them, they are backlogged in the Task Queue.\n\n### Throttling\n\nThe rate at which each Activity Worker polls for and processes Activity Tasks is configurable per Worker.\nWorkers do not exceed this rate even if it has spare capacity.\nThere is also support for global Task Queue rate limiting.\nThis limit works across all Workers for the given Task Queue.\nIt is frequently used to limit load on a downstream service that an Activity calls into.\n\n### Specific environments\n\nIn some cases, you might need to execute Activities in a dedicated environment.\nTo send Activity Tasks to this environment, use a dedicated Task Queue.\n\n#### Route Activity Tasks to a specific host\n\nIn some use cases, such as file processing or machine learning model training, an Activity Task must be routed to a specific Worker Process or Worker Entity.\n\nFor example, suppose that you have a Workflow with the following three separate Activities:\n\n- Download a file.\n- Process the file in some way.\n- Upload a file to another location.\n\nThe first Activity, to download the file, could occur on any Worker on any host.\nHowever, the second and third Activities must be executed by a Worker on the same host where the first Activity downloaded the file.\n\nIn a real-life scenario, you might have many Worker Processes scaled over many hosts.\nYou would need to develop your Temporal Application to route Tasks to specific Worker Processes when needed.\n\nCode samples:\n\n- [Go file processing example](https://github.com/temporalio/samples-go/tree/master/fileprocessing)\n- [Java file processing example](https://github.com/temporalio/samples-java/tree/master/src/main/java/io/temporal/samples/fileprocessing)\n- [PHP file processing example](https://github.com/temporalio/samples-php/tree/master/app/src/FileProcessing)\n\n#### Route Activity Tasks to a specific process\n\nSome Activities load large datasets and cache them in the process.\nThe Activities that rely on those datasets should be routed to the same process.\n\nIn this case, a unique Task Queue would exist for each Worker Process involved.\n\n#### Workers with different capabilities\n\nSome Workers might exist on GPU boxes versus non-GPU boxes.\nIn this case, each type of box would have its own Task Queue and a Workflow can pick one to send Activity Tasks.\n\n### Multiple priorities\n\nIf your use case involves more than one priority, you can create one Task Queue per priority, with a Worker pool per priority.\n\n### Versioning\n\nTask Routing is the simplest way to version your code.\n\nIf you have a new backward-incompatible Activity Definition, start by using a different Task Queue.\n","is_empty":false},{"file_name":"what-is-tctl-v1.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-tctl-v1.md","id":"concepts/what-is-tctl-v1","title":"What is tctl?","description":"tctl is a command-line tool that you can use to interact with a Temporal Cluster.","label":"tctl","tags":["term","tctl"],"ssdi":[],"markdown_content":"\n:::success Temporal CLI is now available!\n\nThe new [Temporal CLI](/cli) is available for use.\n\ntctl v1.17 can still be used with Temporal Server version 1.20 and is expected to be compatible with Temporal Server version 1.21.\n\ntctl is expected to be fully deprecated by Temporal Server version 1.22\n\n:::\n\n:::note\n\nThis documentation reflects tctl version 1.17\n\n:::\n\nThe Temporal CLI (tctl) is a command-line tool that you can use to interact with a Temporal Cluster.\nIt can perform [Namespace](/concepts/what-is-a-namespace) operations (such as register, update, and describe) and [Workflow](/concepts/what-is-a-workflow) operations (such as start\nWorkflow, show Workflow History, and Signal Workflow).\n\n- [How to install tctl](/tctl-v1/how-to-install-tctl)\n- [Environment variables for tctl](/tctl-v1/environment-variables)\n\n## tctl commands\n\n- [tctl activity](/tctl-v1/activity/)\n- [tctl admin](/tctl-v1/admin/)\n- [tctl batch](/tctl-v1/batch/)\n- [tctl cluster](/tctl-v1/cluster/)\n- [tctl dataconverter](/tctl-v1/dataconverter/)\n- [tctl namespace](/tctl-v1/namespace/)\n- [tctl taskqueue](/tctl-v1/taskqueue/)\n- [tctl workflow](/tctl-v1/workflow/)\n","is_empty":false},{"file_name":"what-is-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-temporal-cloud.md","id":"concepts/what-is-temporal-cloud","title":"What is Temporal Cloud?","description":"Temporal Cloud is a managed, hosted Temporal environment that provides a platform for Temporal Applications.","label":"Temporal Cloud","tags":["term","explanation"],"ssdi":[],"markdown_content":"\n[Temporal Cloud](https://temporal.io/cloud) is a managed, hosted Temporal environment that provides a platform for [Temporal Applications](/temporal/#temporal-application)—an alternative to deploying and operating your own [Temporal Cluster](/clusters).\n\nTemporal Cloud is offered in units of isolation known as [Namespaces](/namespaces). You can provision and use one or more Cloud Namespaces. A typical use case is to use separate Namespaces as development, testing, integration, staging, and production environments for an application.\n","is_empty":false},{"file_name":"what-is-temporal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-temporal.md","id":"concepts/what-is-temporal","title":"What is Temporal?","description":"Temporal is a scalable and reliable runtime for Reentrant Processes called Temporal Workflow Executions.","label":"Temporal","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nTemporal is a scalable and reliable runtime for Reentrant Processes called [Temporal Workflow Executions](/workflows#workflow-execution).\n\n<!-- TODO content more appropriate for blog\n:::note [Temporal's tenth rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule)\n\nAny sufficiently complex distributed system contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of temporal.io.\n\n:::\n-->\n\n![The Temporal System](/diagrams/temporal-system-simple.svg)\n","is_empty":false},{"file_name":"what-is-the-temporal-cli.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-the-temporal-cli.md","id":"concepts/what-is-the-temporal-cli","title":"What is the Temporal CLI?","description":"The Temporal CLI is the most recent version of Temporal's command-line tool.","label":"Temporal CLI","tags":["term","cli"],"ssdi":[],"markdown_content":"\nThe Temporal CLI is a command-line tool that includes a distribution of a Temporal Cluster ([Temporal Server](/concepts/what-is-the-temporal-server), persistence (SQLite), and the [Temporal Web UI](/concepts/what-is-the-temporal-web-ui)).\n\n### Available commands\n\n- [temporal activity](/cli/activity/)\n- [temporal batch](/cli/batch/)\n- [temporal env](/cli/env/)\n- [temporal operator](/cli/operator/)\n- [temporal schedule](/cli/schedule/)\n- [temporal server](/cli/server)\n- [temporal task-queue](/cli/task-queue/)\n- [temporal workflow](/cli/workflow/)\n\n## Installation\n\n### cURL\n\n`curl -sSf https://temporal.download/cli.sh | sh`\n\n### Homebrew\n\n`brew install temporal`\n\n### Manual\n\n1. Download the version for your OS and architecture:\n   - [Linux amd64](https://temporal.download/cli/archive/latest?platform=linux&arch=amd64)\n   - [Linux arm64](https://temporal.download/cli/archive/latest?platform=linux&arch=arm64)\n   - [macOS amd64](https://temporal.download/cli/archive/latest?platform=darwin&arch=amd64)\n   - [macOS arm64](https://temporal.download/cli/archive/latest?platform=darwin&arch=arm64) (Apple silicon)\n   - [Windows amd64](https://temporal.download/cli/archive/latest?platform=windows&arch=amd64)\n   - [Windows arm64](https://temporal.download/cli/archive/latest?platform=windows&arch=arm64)\n2. Extract the downloaded archive.\n3. Add the `temporal` binary to your PATH. (`temporal.exe` for Windows)\n\n## Starting the Temporal Server\n\nRun the following command to start the Temporal Server.\nThis command also starts the Web UI.\n\n```bash\ntemporal server start-dev\n```\n\nAt this point you should have a server running on `localhost:7233` and a web interface at <http://localhost:8233>.\n\nBy default, it doesn’t persist your data—if you start a Workflow, Ctrl-C, and run the command again, your Workflow will be gone.\n\nIf you'd like your Workflows to be saved, use the `--db-filename` flag:\n\n```bash\ntemporal server start-dev --db-filename temporal.db\n```\n\n## Interacting with the Server\n\nIn another terminal, you can run commands to interact with the Server. This command starts a Workflow:\n\n```bash\n$ temporal workflow start \\\n  --task-queue hello-world \\\n  --type MyWorkflow \\\n  --workflow-id 123 \\\n  --input 456\n\nRunning execution:\n  WorkflowId                                   123\n  RunId       357074e4-0dd8-4c44-8367-d92536dd0943\n  Type        MyWorkflow\n  Namespace   default\n  TaskQueue   hello-world\n  Args        [456]\n```\n\nThe shorthand options are:\n\n```bash\ntemporal workflow start -t hello-world --type MyWorkflow -w 123 -i 456\n```\n\nYou can also list and describe Workflows:\n\n```bash\n$ temporal workflow list\n\n  Status   WorkflowId     Name       StartTime\n  Running         123  MyWorkflow  14 seconds ago\n\n$ temporal workflow describe --workflow-id 123\n\n{\n  \"executionConfig\": {\n    \"taskQueue\": {\n      \"name\": \"hello-world\",\n      \"kind\": \"Normal\"\n    },\n    \"workflowExecutionTimeout\": \"0s\",\n    \"workflowRunTimeout\": \"0s\",\n    \"defaultWorkflowTaskTimeout\": \"10s\"\n  },\n  \"workflowExecutionInfo\": {\n    \"execution\": {\n      \"workflowId\": \"123\",\n      \"runId\": \"357074e4-0dd8-4c44-8367-d92536dd0943\"\n    },\n    \"type\": {\n      \"name\": \"MyWorkflow\"\n    },\n    \"startTime\": \"2023-04-15T06:42:31.191137Z\",\n    \"status\": \"Running\",\n    \"historyLength\": \"2\",\n    \"executionTime\": \"2023-04-15T06:42:31.191137Z\",\n    \"memo\": {\n\n    },\n    \"autoResetPoints\": {\n\n    },\n    \"stateTransitionCount\": \"1\"\n  },\n  \"pendingWorkflowTask\": {\n    \"state\": \"Scheduled\",\n    \"scheduledTime\": \"2023-04-15T06:42:31.191173Z\",\n    \"originalScheduledTime\": \"2023-04-15T06:42:31.191173Z\",\n    \"attempt\": 1\n  }\n}\n```\n\nWhen listing, you can get more Workflow fields and output in JSON:\n\n```bash\n$ temporal workflow list --fields long --output json\n\n[\n  {\n    \"execution\": {\n      \"workflow_id\": \"123\",\n      \"run_id\": \"357074e4-0dd8-4c44-8367-d92536dd0943\"\n    },\n    \"type\": {\n      \"name\": \"MyWorkflow\"\n    },\n    \"start_time\": \"2023-04-15T06:42:31.191137Z\",\n    \"status\": 1,\n    \"execution_time\": \"2023-04-15T06:42:31.191137Z\",\n    \"memo\": {},\n    \"task_queue\": \"hello-world\"\n  }\n]\n```\n\nFilter out just the type with [jq](https://stedolan.github.io/jq/):\n\n```bash\n$ temporal workflow list --fields long -o json | jq '.[].type.name'\n\n\"OtherWorkflow\"\n\"MyWorkflow\"\n\"MyWorkflow\"\n```\n\nAnd count how many Workflows of each type you have:\n\n```bash\n$ temporal workflow list --fields long -o json | jq '.[].type.name' | uniq -c\n\n   1 \"OtherWorkflow\"\n   2 \"MyWorkflow\"\n```\n\nTo see what else you can do to Workflows, run `temporal workflow` or visit [CLI ▶️ workflow](/cli/workflow).\n\nTo see the list of top-level commands, run `temporal` or visit [Available commands](#available-commands).\n\n## Environments\n\nSo far, the CLI has been talking to the Server at the default address, `localhost:7233`. To talk to another Server, like a production namespace on Temporal Cloud:\n\n1. Create an environment named `prod`.\n2. Pass `--env prod` to commands, like `temporal workflow list --env prod`.\n\nTo create a new environment, start setting its properties:\n\n```bash\ntemporal env set prod.namespace production.f45a2\ntemporal env set prod.address production.f45a2.tmprl.cloud:7233\ntemporal env set prod.tls-cert-path /temporal/certs/prod.pem\ntemporal env set prod.tls-key-path /temporal/certs/prod.key\n```\n\nCheck that you set them correctly:\n\n```bash\n$ temporal env get prod\n\n  address        production.f45a2.tmprl.cloud:7233\n  namespace      production.f45a2\n  tls-cert-path  /temporal/certs/prod.pem\n  tls-key-path   /temporal/certs/prod.key\n```\n\nIf they’re correct, then this shouldn’t log a connection error:\n\n```bash\n$ temporal workflow list --env prod\n```\n\nFor the full list of properties you can set, see the below options:\n\n```bash\n$ temporal env set -h\n\nOPTIONS:\n   Client Options:\n\n   --address value                          The host and port (formatted as host:port) for the Temporal Frontend Service. [$TEMPORAL_CLI_ADDRESS]\n   --codec-auth value                       Sets the authorization header on requests to the Codec Server. [$TEMPORAL_CLI_CODEC_AUTH]\n   --codec-endpoint value                   Endpoint for a remote Codec Server. [$TEMPORAL_CLI_CODEC_ENDPOINT]\n   --context-timeout value                  An optional timeout for the context of an RPC call (in seconds). (default: 5) [$TEMPORAL_CONTEXT_TIMEOUT]\n   --env value                              Name of the environment to read environmental variables from. (default: \"default\")\n   --grpc-meta value [ --grpc-meta value ]  Contains gRPC metadata to send with requests (format: key=value). Values must be in a valid JSON format.\n   --namespace value, -n value              Identifies a Namespace in the Temporal Workflow. (default: \"default\") [$TEMPORAL_CLI_NAMESPACE]\n   --tls-ca-path value                      Path to server CA certificate. [$TEMPORAL_CLI_TLS_CA]\n   --tls-cert-path value                    Path to x509 certificate. [$TEMPORAL_CLI_TLS_CERT]\n   --tls-disable-host-verification          Disables TLS host name verification if already enabled. (default: false) [$TEMPORAL_CLI_TLS_DISABLE_HOST_VERIFICATION]\n   --tls-key-path value                     Path to private certificate key. [$TEMPORAL_CLI_TLS_KEY]\n   --tls-server-name value                  Provides an override for the target TLS server name. [$TEMPORAL_CLI_TLS_SERVER_NAME]\n\n   Display Options:\n\n   --color value  when to use color: auto, always, never. (default: \"auto\")\n```\n\nFor example, to set `--codec-endpoint`, you would do:\n\n```bash\n$ temporal env set prod.codec-endpoint localhost:3000\n```\n\n## Server configuration\n\nUse the help flag to see a full list of CLI options:\n\n```bash\ntemporal server start-dev --help\n```\n\n### Namespace registration\n\nNamespaces are pre-registered at startup so they're available to use immediately.\nTo customize the pre-registered namespaces, start the server with the following:\n\n```bash\ntemporal server start-dev --namespace foo --namespace bar\n```\n\nYou can also register Namespaces with the following command:\n\n```bash\ntemporal operator namespace create foo\n```\n\n### Enable or disable Temporal UI\n\nBy default, the Temporal UI is started with Temporal CLI. The UI can be disabled via a runtime flag:\n\n```bash\ntemporal server start-dev --headless\n```\n\n### Dynamic configuration\n\nAdvanced configuration of the Temporal CLI requires the use of a dynamic configuration file.\nThis file is created outside the Temporal CLI; it is usually located with the service's config files.\n\nDynamic configuration values can also be set via `--dynamic-config-value KEY=JSON_VALUE`.\nFor example, to enable the Search Attribute cache (disabled by default), run the following:\n\n```bash\ntemporal server start-dev --dynamic-config-value system.forceSearchAttributesCacheRefreshOnRead=false\n```\n\nThis setting makes created Search Attributes immediately available for use.\n\n## Environmental variables\n\nThe Temporal CLI hosts a set of Client Options that can be used to configure the system environment.\nUse the following table as a reference for the Temporal CLI environmental variables.\n\n| Variable                                     | Definition                                                                        | Client Option                   |\n| -------------------------------------------- | --------------------------------------------------------------------------------- | ------------------------------- |\n| `TEMPORAL_CLI_ADDRESS`                       | The host and port (formatted as host:port) for the Temporal Frontend Service.     | --address                       |\n| `TEMPORAL_CLI_CODEC_AUTH`                    | Sets the authorization header on requests to the Codec Server.                    | --codec-auth                    |\n| `TEMPORAL_CLI_CODEC_ENDPOINT`                | Endpoint for a remote Codec Server.                                               | --codec-endpoint                |\n| `TEMPORAL_CONTEXT_TIMEOUT`                   | An optional timeout for the context of an RPC call (in seconds). Default value: 5 | --context-timeout               |\n| `TEMPORAL_CLI_NAMESPACE`                     | Identifies a Namespace in the Temporal Workflow. Default value: \"default\".        | --namespace                     |\n| `TEMPORAL_CLI_TLS_CA`                        | Path to server CA certificate.                                                    | --tls-ca-path                   |\n| `TEMPORAL_CLI_TLS_CERT`                      | Path to x509 certificate.                                                         | --tls-cert-path                 |\n| `TEMPORAL_CLI_TLS_DISABLE_HOST_VERIFICATION` | Disables TLS host name verification if already enabled. Default value: false.     | --tls-disable-host-verification |\n| `TEMPORAL_CLI_TLS_KEY`                       | Path to private certificate key.                                                  | --tls-key-path                  |\n| `TEMPORAL_CLI_TLS_SERVER_NAME`               | Provides an override for the target TLS server name.                              | --tls-server-name               |\n\n## Auto-completion\n\nThe Temporal CLI has the capability to auto-complete commands.\n\nRunning `temporal completion SHELL` outputs the related completion SHELL code.\n\n### zsh auto-completion\n\n<!-- TODO: add more information about zsh to make comparable to bash section -->\n\nAdd the following code snippet to your `~/.zshrc` file:\n\n```sh\nsource <(temporal completion zsh)\n```\n\nIf you're running auto-completion from the terminal, run the following command:\n\n```sh\necho 'source <(temporal completion zsh)' >> ~/.zshrc\n```\n\nAfter setting the variable, run the following command:\n\n`source ~/.zshrc`.\n\n### Bash auto-completion\n\nBash auto-completion relies on `bash-completion`.\n\nInstall the software with the steps provided in the [bash-completion README](https://github.com/scop/bash-completion#installation), or use your preferred package manager on your operating system.\n\nFor more information, see [the Bash Completion page on Repology](https://repology.org/project/bash-completion/versions).\n\n### Aliases\n\nYou can also add aliases to your `~/.bash_profile` such as:\n\n```bash\nalias t='temporal'\nalias tw='temporal workflow'\nalias ts='temporal server start-dev'\nalias tsdb='temporal server start-dev --db-filename ~/temporal.db'\n\n# send process to background so you can continue using the terminal\nalias tsbg='temporal server start-dev &> /dev/null & disown'\n```\n","is_empty":false},{"file_name":"what-is-the-temporal-platform.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-the-temporal-platform.md","id":"concepts/what-is-the-temporal-platform","title":"What is the Temporal Platform?","description":"The Temporal Platform consists of a Temporal Cluster and Worker Processes.","label":"Temporal Platform","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nThe Temporal Platform consists of a [Temporal Cluster](/concepts/what-is-a-temporal-cluster) and [Worker Processes](/concepts/what-is-a-worker-process).\nTogether these components create a runtime for Workflow Executions.\n\n![The Temporal Platform](/diagrams/temporal-platform-simple.svg)\n\nThe Temporal Cluster is open source and can be operated by you.\nThe Temporal Cloud is a set of Clusters operated by us.\n\nWorker Processes are hosted by you and execute your code.\nThey communicate with a Temporal Cluster via gRPC.\n","is_empty":false},{"file_name":"what-is-the-temporal-server.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-the-temporal-server.md","id":"concepts/what-is-the-temporal-server","title":"What is the Temporal Server?","description":"The Temporal Server is a grouping of four horizontally scalable services.","label":"Temporal Server","tags":["term","explanation"],"ssdi":[],"markdown_content":"\nThe Temporal Server consists of four independently scalable services:\n\n- Frontend gateway: for rate limiting, routing, authorizing.\n- History subsystem: maintains data (mutable state, queues, and timers).\n- Matching subsystem: hosts Task Queues for dispatching.\n- Worker Service: for internal background Workflows.\n\nFor example, a real-life production deployment can have 5 Frontend, 15 History, 17 Matching, and 3 Worker Services per cluster.\n\nThe Temporal Server services can run independently or be grouped together into shared processes on one or more physical or virtual machines.\nFor live (production) environments, we recommend that each service runs independently, because each one has different scaling requirements and troubleshooting becomes easier.\nThe History, Matching, and Worker Services can scale horizontally within a Cluster.\nThe Frontend Service scales differently than the others because it has no sharding or partitioning; it is just stateless.\n\nEach service is aware of the others, including scaled instances, through a membership protocol via [Ringpop](https://github.com/temporalio/ringpop-go).\n\n#### Versions and support\n\nAll Temporal Server releases abide by the [Semantic Versioning Specification](https://semver.org/).\n\nWe support upgrade paths from every version beginning with Temporal v1.7.0.\nFor details on upgrading your Temporal Cluster, see [Upgrade Server](/cluster-deployment-guide#upgrade-server).\n\nWe provide maintenance support for previously published minor and major versions by continuing to release critical bug fixes related to security, the prevention of data loss, and reliability, whenever they are found.\n\nWe aim to publish incremental upgrade guides for each minor and major version, which include specifics about dependency upgrades that we have tested for (such as Cassandra 3.0 -> 3.11).\n\nWe offer maintenance support of the last three **minor** versions after a release and do not plan to \"backport\" patches beyond that.\n\nWe offer maintenance support of **major** versions for at least 12 months after a GA release, and we provide at least 6 months' notice before EOL/deprecating support.\n\n**Dependencies**\n\nTemporal offers official support for, and is tested against, dependencies with the exact versions described in the `go.mod` file of the corresponding release tag.\n(For example, [v1.5.1](https://github.com/temporalio/temporal/tree/v1.5.1) dependencies are documented in [the go.mod for v1.5.1](https://github.com/temporalio/temporal/blob/v1.5.1/go.mod).)\n","is_empty":false},{"file_name":"what-is-the-temporal-web-ui.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-the-temporal-web-ui.md","id":"concepts/what-is-the-temporal-web-ui","title":"What is the Temporal Web UI?","description":"The Temporal Web UI provides users with Workflow Execution state and metadata for debugging purposes.","label":"Temporal Web UI","tags":["term","web-ui"],"ssdi":[],"markdown_content":"\nThe Temporal Web UI provides users with Workflow Execution state and metadata for debugging purposes.\nIt ships with every [Temporal CLI](/concepts/what-is-the-temporal-cli) release and [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker--docker-compose) update and is available with [Temporal Cloud](/cloud).\n\nYou can configure the Temporal Web UI to work in your own environment.\nSee the [UI configuration reference](/references/web-ui-configuration).\n\nWeb UI open source repos:\n\n- [temporalio/ui](https://github.com/temporalio/ui)\n- [temporalio/ui-server](https://github.com/temporalio/ui-server)\n\nThe Web UI is packed with several features.\n\n### Namespaces\n\nAll Namespaces in your self-hosted Cluster or Temporal Cloud account are listed under **Namespaces** in the left section of the window.\nYou can also switch Namespaces from the Workflows view by selecting from the Namespace switcher at the top right corner of the window.\nAfter you select a Namespace, the Web UI shows the Recent Workflows page for that Namespace.\nIn Temporal Cloud, users can access only the Namespaces that they have been granted access to.\nFor details, see [Namespace-level permissions](/cloud/#namespace-level-permissions).\n\n### Recent Workflows\n\nRecent Workflows lists all Workflow Executions run in the past 24 hours.\nThe default number shown is 1,000 Workflow Executions.\n\nUsers can list Workflow Executions by any of the following:\n\n- Status\n- [Workflow ID](/concepts/what-is-a-workflow-id)\n- [Workflow Type](/concepts/what-is-a-workflow-type)\n- Start time\n- End time\n- A [List Filter](/concepts/what-is-a-list-filter)\n\nFor start time and end time, users can set their preferred date and time format as one of the following:\n\n- UTC\n- Local\n- Relative\n\nSelect a Workflow Execution to view the Workflow Execution's History, Workers, and pending Activities.\n\n#### History\n\nThis is a view of the [Events](/concepts/what-is-an-event) and Event fields within the Workflow Execution.\nApproximately [40 different Events](/references/events) can appear in a Workflow Execution's Event History.\n\nThe top of the page lists the following execution metadata:\n\n- [Workflow Type](/concepts/what-is-a-workflow-type)\n- [Run ID](/concepts/what-is-a-run-id)\n- Start Time and Close Time\n- [Task Queue](/concepts/what-is-a-task-queue)\n- Parent and Parent ID\n- [State Transitions](/concepts/what-is-a-state-transition)\n\nThe Input and Results section displays the function arguments and return values for debugging purposes.\nResults are not available until the Workflow finishes.\n\nThe Recent Events tab has the following views:\n\n- Timeline: A chronological or reverse-chronological order of events with a summary.\n  Clicking into an Event displays all details for that Event.\n  Clicking “Expand all” displays all Event details.\n  Similarly, clicking “Collapse all” collapses the table and displays only the summary.\n- Compact: A logical grouping of Activities, Signals and Timers.\n- JSON: The full JSON code for the workflow.\n\n#### Download Event History\n\nThe entire Workflow Execution Event History, in JSON format, can be downloaded from this section.\n\n#### Terminate Workflow\n\nWorkflow Executions can be Terminated directly from the UI.\nA custom note can be logged from the UI when that happens.\n\n#### Workers\n\nDisplays the Workers currently polling on the Workflow Task Queue with a count.\nIf no Workers are polling, an error displays.\n\n#### Pending Activities\n\nDisplays a summary of recently active and/or pending Activity Executions.\nClicking a pending Activity directs the user to the Pending Activities tab to view details.\n\n#### Stack Trace\n\nThe screen shows the captured result from the [\\_\\_stack_trace](/workflows#stack-trace-query) Query.\nThe Query is performed when the tab is selected.\nIt works only if a Worker is running and available to return the stack trace.\n\n#### Queries\n\nLists all Queries sent to the Workflow Execution.\n\n### Schedules\n\nOn Temporal Cloud and self-hosted Temporal Cluster Web UI, the Schedules page lists all the [Schedules](/workflows#schedule) created on the selected Namespace.\n\nClick a Schedule to see details, such as configured frequency, start and end times, and recent and upcoming runs.\n\n### Settings\n\nOn Temporal Cloud, **Settings** is visible only to [Global Admins](/cloud/#account-level-roles).\n\nClick **Settings** to see and manage the list of users in your account and to set up integrations such as [Observability](/cloud/how-to-monitor-temporal-cloud-metrics#configure-a-metrics-endpoint-using-temporal-cloud-ui) and [Audit logging](/cloud/how-to-manage-audit-logging).\n\nOn self-hosted Temporal Clusters, manage your users, metrics, and logging in your [server configuration](/references/configuration).\n\n<!--\nAB: Commenting because this is redundant now? Also this needs to be updated for self-hosted clusters.\nDisplays the following information:\n\n- Description of the Namespace.\n- Owner: Namespace owner.\n- Global?: Whether the Namespace is a Global Namespace\n- Retention Period: Namespace Retention Period\n- History Archival: Whether History Archival is enabled\n- Visibility Archival: Whether Visibility Archival is enabled\n- Failover Version: Namespace Failover Version\n- Clusters: Cluster information -->\n\n### Archive\n\nOn self-hosted Temporal Clusters, Archive shows [Archived](/concepts/what-is-archival) data of your Workflow Executions on the Namespace.\n\nTo see data in your self-hosted Temporal Cluster, you must have [Archival set up and configured](/cluster-deployment-guide#archival).\n\nFor information and details on the Archive feature in Temporal Cloud, contact your Temporal representative.\n\n### Codec Server\n\nThe Web UI can use a [Codec Server](/dataconversion#codec-server) with a custom Data Converter to decode inputs and return values.\nFor details, see [Securing your data](/production-readiness/develop#securing-your-data).\nThe UI supports both a [Codec Server endpoint](/production-readiness/develop#web-ui) and the `tctl` plugin port.\n\nFor details on setting the Codec Server endpoint, see [Codec Server setup](/production-readiness/develop#codec-server-setup).\n","is_empty":false},{"file_name":"what-is-visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-visibility.md","id":"concepts/what-is-visibility","title":"What is Visibility?","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["term"],"ssdi":["For Temporal Server v1.19 and earlier, all supported databases for Visibility provide standard Visibility features, and an Elasticsearch database is required for advanced Visibility features.","For Temporal Server v1.20 and later, advanced Visibility features are enabled on all supported SQL databases, in addition to Elasticsearch.","In Temporal Server v1.21 and later, standard Visibility is no longer in development, and we recommend migrating to a [database that supports advanced Visibility features](/cluster-deployment-guide#supported-databases). Visibility configuration in Temporal Cluster is updated and Dual Visibility is enabled. For details, see [Visibility store setup](/cluster-deployment-guide#visibility-store)."],"markdown_content":"\nThe term [Visibility](/visibility), within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view, filter, and search for Workflow Executions that currently exist within a Cluster.\n\nThe [Visibility store](/cluster-deployment-guide#visibility-store) in your Temporal Cluster stores persisted Workflow Execution Event History data and is set up as a part of your [Persistence store](/concepts/what-is-a-temporal-cluster#persistence) to enable listing and filtering details about Workflow Executions that exist on your Temporal Cluster.\n\n- [How to set up a Visibility store](/cluster-deployment-guide#visibility-store)\n\nWith Temporal Server v1.21, you can set up [Dual Visibility](/concepts/what-is-dual-visibility) to migrate your Visibility store from one database to another.\n\n<!-- A Visibility store can be configured to provide [atandard Visibility](/visibility#standard-visibility) and [advanced Visibility](/visibility#advanced-visibility) features.\n\nSupport for separate standard and advanced Visibility setups will be deprecated from Temporal Server v1.21 onwards. Check [Supported databases](/cluster-deployment-guide#supported-databases) for updates. -->\n","is_empty":false},{"file_name":"what-is-worker-versioning.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/what-is-worker-versioning.md","id":"concepts/what-is-worker-versioning","title":"What is Worker Versioning?","description":"Worker Versioning lets you more easily deploy changes to Workflow Definitions.","label":"Worker Versioning","tags":["explanation","versioning"],"ssdi":["Introduced in Temporal Server version [1.21.0](https://github.com/temporalio/temporal/releases/tag/v1.21.0)","Available in [Go SDK](/dev-guide/go/versioning#worker-versioning) version [1.23.0](https://github.com/temporalio/sdk-go/releases/tag/v1.23.0)","Available in [Java SDK](/dev-guide/java/versioning#worker-versioning) version [1.20.0](https://github.com/temporalio/sdk-java/releases/tag/v1.20.0)","Will come to CLI in version 0.10.0","Not yet available in Temporal Cloud"],"markdown_content":"\nWorker Versioning simplifies the process of deploying changes to [Workflow Definitions](/workflows/#workflow-definition).\nIt does this by letting you define sets of versions that are compatible with each other, and then assigning a Build ID to the code that defines a Worker.\nThe Temporal Server uses the Build ID to determine which versions of a Workflow Definition a Worker can process.\n\nWe recommend that you read about Workflow Definitions before proceeding, because Workflow Versioning is largely concerned with helping to manage nondeterministic changes to those definitions.\n\nWorker Versioning helps manage nondeterministic changes by providing a convenient way to ensure that [Workers](#workers) with different Workflow and Activity Definitions operating on the same [Task Queue](#task-queue) don't attempt to process [Workflow Tasks](#workflow-task) and [Activity Tasks](#activity-task-execution) that they can't successfully process, according to sets of versions associated with that Task Queue that you've defined.\n\nAccomplish this goal by assigning a Build ID (a free-form string) to the code that defines a Worker, and specifying which Build IDs are compatible with each other by updating the version sets associated with the Task Queue, stored by the Temporal Server.\n\n### When and why you should use Worker Versioning\n\nThe main reason to use this feature is to deploy incompatible changes to short-lived [Workflows](/workflows).\nOn Task Queues using this feature, the Workflow starter doesn't have to know about the introduction of new versions.\n\nThe new code in the newly deployed Workers executes new [Workflow Executions](#workflow-execution), while only Workers with an appropriate version process old Workflow Executions.\n\n#### Decommission old Workers\n\nYou can decommission old Workers after you archive all open Workflows using their version.\nIf you have no need to query closed Workflows, you can decommission them when no open Workflows remain at that version.\n\nFor example, if you have a Workflow that completes within a day, a good strategy is to assign a new Build ID to every new Worker build and add it as the new overall default in the version sets.\n\nBecause your Workflow completes in a day, you know that you won't need to keep older Workers running for more than a day after you deploy the new version (assuming availability).\n\nRemoving old versions from the sets isn't necessary.\nLeaving them doesn't cause any harm.\n\nYou can apply this technique to longer-lived Workflows too; however, you might need to run multiple Worker versions simultaneously while open Workflows complete.\n\n#### Deploy code changes to Workers\n\nThe feature also lets you implement compatible changes to or prevent a buggy code path from executing on currently open Workflows.\nYou can achieve this by adding a new version to an existing set and defining it as _compatible_ with an existing version, which shouldn't execute any future Workflow Tasks.\nBecause the new version processes existing [Event Histories](/workflows/#event-history), it must adhere to the usual [deterministic constraints](/workflows/#deterministic-constraints), and you might need to use one of the [versioning APIs](/workflows/#workflow-versioning).\n\nMoreover, this feature lets you make incompatible changes to Activity Definitions in conjunction with incompatible changes to Workflow Definitions that use those Activities.\nThis functionality works because any Activity that a Workflow schedules on the same Task Queue gets dispatched only to Workers compatible with the Workflow that scheduled it.\nIf you want to change an Activity Definition's type signature while creating a new incompatible Build ID for a Worker, you can do so without worrying about the Activity failing to execute on some other Worker with an incompatible definition.\nThe same principle applies to Child Workflows.\n\n:::tip\n\nPublic-facing Workflows on a versioned Task Queue shouldn't change their signatures because doing so contradicts the purpose of Workflow-launching Clients remaining unaware of changes in the Workflow Definition.\nIf you need to change a Workflow's signature, use a different Workflow Type or a completely new Task Queue.\n\n:::\n\n:::note\n\nIf you schedule an Activity or a Child Workflow on _a different_ Task Queue from the one the Workflow runs on, the system doesn't assign a specific version.\nThis means if the target queue is versioned, they run on the latest default, and if it's unversioned, they operate as they would have without this feature.\n\n:::\n\n**Continue-As-New and Worker Versioning**\n\nBy default, a versioned Task Queue's Continue-as-New function starts the continued Workflow on the same compatible set as the original Workflow.\n\nIf you continue-as-new onto a different Task Queue, the system doesn't assign any particular version.\nYou also have the option to specify that the continued Workflow should start using the Task Queue's latest default version.\n\n### How to use Worker Versioning\n\nTo use Worker Versioning, follow these steps:\n\n1. Define Worker build-identifier version sets for the Task Queue.\n   You can use either the `temporal` CLI or your choice of SDK.\n2. Enable the feature on your Worker by specifying a Build ID.\n\n#### Defining the version sets\n\nWhether you use [Temporal CLI](/cli/) or an SDK, updating the version sets feels the same.\nYou specify the Task Queue that you're targeting, the Build ID that you're adding (or promoting), whether it becomes the new default version, and any existing versions it should be considered compatible with.\n\nThe rest of this section uses updates to one Task Queue's version sets as examples.\n\nBy default, both Task Queues and Workers are in an unversioned state.\n[Unversioned Worker](#unversioned-workers) can poll unversioned Task Queues and receive tasks.\nTo use this feature, both the Task Queue and the Worker must be associated with Build IDs.\n\nIf you run a Worker using versioning against a Task Queue that has not been set up to use versioning (or is missing that Worker's Build ID), it won't get any tasks.\nLikewise, a unversioned Worker polling a Task Queue with versioning won't work either.\n\n:::note Versions don't need to follow semver or any other semantic versioning scheme!\n\nThe versions in the following examples look like semver versions for clarity, but they don't need to be.\nVersions can be any arbitrary string.\n\n:::\n\nFirst, add a version `1.0` to the Task Queue as the new default.\nYour version sets now look like this:\n\n| set 1 (default) |\n| --------------- |\n| 1.0 (default)   |\n\nAll new Workflows started on the Task Queue have their first tasks assigned to version `1.0`.\nWorkers with their Build ID set to `1.0` receive these Tasks.\n\nIf Workflows that don't have an assigned version are still running on the Task Queue, Workers without a version take those tasks.\nSo ensure that such Workers are still operational if any Workflows were open when you added the first version.\nIf you deployed any Workers with a _different_ version, those Workers receive no Tasks.\n\nNow, imagine you need change the Workflow for some reason.\n\nAdd `2.0` to the sets as the new default:\n\n| set 1         | set 2 (default) |\n| ------------- | --------------- |\n| 1.0 (default) | 2.0 (default)   |\n\nAll new Workflows started on the Task Queue have their first tasks assigned to version `2.0`.\nExisting `1.0` Workflows keep generating tasks targeting `1.0`.\nEach deployment of Workers receives their respective Tasks.\nThis same concept carries forward for each new incompatible version.\n\nMaybe you have a bug in `2.0`, and you want to make sure all open `2.0` Workflows switch to some new code as fast as possible.\nSo, you add `2.1` to the sets, marking it as compatible with `2.0`.\nNow your sets look like this:\n\n| set 1         | set 2 (default) |\n| ------------- | --------------- |\n| 1.0 (default) | 2.0             |\n|               | 2.1 (default)   |\n\nAll new Workflow Tasks that are generated for Workflows whose last Workflow Task completion was on version `2.0` are now assigned to version `2.1`.\nBecause you specified that `2.1` is compatible with `2.0`, Temporal Server assumes that Workers with this version can process the existing Event Histories successfully.\n\nContinue with your normal development cycle, adding a `3.0` version.\nNothing new here:\n\n| set 1         | set 2         | set 3 (default) |\n| ------------- | ------------- | --------------- |\n| 1.0 (default) | 2.0           | 3.0 (default)   |\n|               | 2.1 (default) |                 |\n\nNow imagine that version `3.0` doesn't have an explicit bug, but something about the business logic\nis less than ideal.\nYou are okay with existing `3.0` Workflows running to completion, but you want new Workflows to use the old `2.x` branch.\nThis operation is supported by performing an update targeting `2.1` (or `2.0`) and setting its set as the current default, which results in these sets:\n\n| set 1         | set 3         | set 2 (default) |\n| ------------- | ------------- | --------------- |\n| 1.0 (default) | 3.0 (default) | 2.0             |\n|               |               | 2.1 (default)   |\n\nNow new Workflows start on `2.1`.\n\n#### Permitted and forbidden operations on version sets\n\nA request to change the sets can do one of the following:\n\n- Add a version to the sets as the new default version in a new overall-default compatible set.\n- Add a version to an existing set that's compatible with an existing version.\n  - Optionally making it the default for that set.\n  - Optionally making that set the overall-default set.\n- Promote a version within an existing set to become the default for that set.\n- Promote a set to become the overall-default set.\n\nYou can't explicitly delete versions.This helps you avoid the situation in which Workflows accidentally become stuck with no means of making progress because the version they're associated with no longer exists.\n\nHowever, sometimes you might want to do this intentionally.\nIf you _want_ to make sure that all Workflows currently being processed by, say, `2.0` stop (even if you don't yet have a new version ready), you can add a new version `2.1` to the sets marked as compatible with `2.0`.\nNew tasks will target `2.1`, but because you haven't deployed any `2.1` Workers, they won't make any progress.\n\n#### Set constraints\n\nThe sets have a maximum size limit, which defaults to 100 build IDs across all sets.\nThis limit is configurable on Temporal Server via the `limit.versionBuildIdLimitPerQueue` dynamic config property.\nOperations to add new Build IDs to the sets fail if the limit would be exceeded.\n\nThere is also a limit on the number of sets, which defaults to 10.\nThis limit is configurable via the `limit.versionCompatibleSetLimitPerQueue` dynamic config property.\n\nIn practice, these limits should rarely be a concern because a version is no longer needed after no open Workflows are using that version, and a background process will delete IDs and sets that are no longer needed.\n\nThere is also a limit on the size of each Build ID or version string, which defaults to 255 characters.\nThis limit is configurable on the server via the `limit.workerBuildIdSize` dynamic config property.\n\n### Build ID reachability\n\nEventually, you'll want to know whether you can retire the old Worker versions.\nTemporal provides functionality to help you determine whether a version is still in use by open or closed Workflows.\nYou can use the Temporal CLI to do this with the following command:\n\n```command\ntemporal task-queue get-build-id-reachability\n```\n\nThe command determines, for each Task Queue, whether the Build ID in question is unreachable, only reachable by closed Workflows, or reachable by open and new Workfloww.\nFor example, this \"2.0\" Build ID is shown here by the CLI to be reachable by both new Workflows and some existing Workflows:\n\n```command\ntemporal task-queue get-build-id-reachability --build-id \"2.0\"\n```\n\n```output\nBuildId                         TaskQueue                                   Reachability\n    2.0  build-id-versioning-dc0068f6-0426-428f-b0b2-703a7e409a97  [NewWorkflows\n                                                                   ExistingWorkflows]\n```\n\nFor more information, see the [CLI documentation](/cli/) or help output.\n\nYou can also use this API `GetWorkerTaskReachability` directly from within language SDKs.\n\n### Unversioned Workers\n\nUnversioned Workers refer to Workers that have not opted into the Worker Versioning feature in their configuration.\nThey receive tasks only from Task Queues that do not have any version sets defined on them, or that have open workflows that began executing before versions were added to the queue.\n","is_empty":false},{"file_name":"why-temporal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/concepts/why-temporal.md","id":"concepts/why-temporal","title":"What are the differences between Temporal and a traditional system?","description":"This page compares a function execution in a traditional system and a Workflow Execution in Temporal.","tags":["explanation"],"ssdi":[],"markdown_content":"\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nOne of the aspects of the Temporal System is that it abstracts the complexity of a distributed system.\nDistributed systems exist to scale computation across multiple machines as the potential load of a system changes.\nIn theory, a distributed system facilitates a reliable and highly performant application.\n\nHowever, any failure that leaves the downstream part of the application waiting for a response can make things very complicated, especially at a large scale.\n\n![Distributed application failures](/diagrams/basic-distributed-system.svg)\n\nHow will a downstream part of the application know if there was a failure before or a failure after changes to the state if there is no response?\nHow will the application track and reconcile an inconsistent state?\n\nIn traditional systems, a large investment is often made to maintain the health of each individual component, visualize the health of the overall system, define timeout constraints for computations, orchestrate retries for computations that fail, and maintain a consistent state.\n\nThese systems are often a mixture of stateless services, databases, cron jobs, and queues.\nAnd as these systems scale, responding to multiple asynchronous events, communicating with unreliable external resources, or tracking the state of something very complex becomes more and more challenging.\n\nTemporal restructures the use of services, databases, cron jobs, queues, host processes, and SDKs, into the Temporal Platform, and addresses failures head on.\n\nIn a traditional system, the service exists to spawn function executions.\nThe Temporal Platform exists to facilitate [Workflow Executions](/workflows#workflow-execution).\n\n![Temporal vs Traditional system](/diagrams/temporal-vs-traditional.svg)\n\nAlthough the two systems seem similar at first glance, they differ in several significant ways.\n\n**Failure**\n\nWith a traditional system, a service function execution is both volatile and short-lived.\n\n- If a function execution fails, it's not resumable because all execution state is lost. The longer a function execution awaits, the higher the chance of failure.\n- A traditional function execution typically has a limited lifespan, often measured in minutes.\n\nWith Temporal, a Workflow Execution is resumable.\n\n- A Workflow Execution is fully resumable after a failure.\n- Temporal imposes no deadlines on Workflow Executions.\n\n**State**\n\nWith a traditional system, stoppage or failure means that all execution state is lost.\nYour application (or a supporting component) must monitor the service's response to initiate a retry of the service execution.\nA retry starts from its _initial_ state.\n\nWith Temporal, computation resumes from its _latest_ state. All progress is retained.\n\n**Communication**\n\nWith a traditional system, you can't communicate with a function execution.\n\nWith Temporal, [Signals](/concepts/what-is-a-signal) and [Queries](/concepts/what-is-a-query) enable data to be sent to or extracted from a Workflow Execution.\n\n**Scope**\n\nWith a traditional system, a service function execution can at best represent a business process.\nTypically, it represents only a part of a business process.\n\nA Temporal Workflow Execution can represent a business process or an entire business object.\n\n### Example subscription use case\n\nLet's look at a subscription-based use case to compare the difference between a Temporal Application and other traditional approaches.\n\nThe basic business steps are as follows:\n\n1. A customer signs up for a service that has a trial period.\n2. After the trial period, if the customer has not canceled, they should be charged once a month.\n3. The customer has to be notified via email about the charges and should be able to cancel the subscription at any time.\n\nThis business logic is not very complicated and can be expressed in a few dozen lines of code.\nAny practical implementation also has to ensure that the business process is fault-tolerant and scalable.\n\n**Database-centric design approach**\n\nThe first approach might be to center everything around a database where an application process would periodically scan the database tables for customers in specific states, execute necessary actions, and update the database to reflect changes.\n\nHowever, there are various drawbacks.\n\n- The most obvious one is that the application state machine of the customer's state quickly becomes extremely complicated.\n  For example, if a credit card charge attempt fails or sending an email fails due to a downstream system's unavailability, the state is now in limbo.\n- Failed calls likely need to be retried for a long time, and these calls need to be throttled to not overload external resources.\n- There needs to be logic to handle corrupted customer records to avoid blocking the whole process.\n- Additionally, databases have performance and scalability limitations (eventually requiring sharding) and are not efficient for scenarios that require constant polling.\n\n**Queue system design approach**\n\nThe next commonly employed approach is to use a timer service and queues.\nUpdates are pushed to a queue while a service consumes them one at a time, updating a database, and possibly pushing more messages into other downstream queues.\nA timer service can be used to schedule queue polling or database actions.\n\nWhile this approach has shown to scale a bit better, the programming model can become very complex and error-prone, as there are usually no transactional updates between a queuing system, a timer service, and a database.\n\n**Temporal design approach**\n\nThe Temporal Platform approach aims to encapsulate and implement the entire business logic in a simple function or object method.\nThanks to the Temporal Platform, the function/method is durably stateful, and the implementer doesn't need to employ any additional systems to ensure consistency and fault tolerance.\n\nHere are example Workflow Definitions that implement the subscription management use case in Java, Go, Typescript and PHP:\n\n<Tabs\ndefaultValue=\"java\"\nvalues={[\n{label: 'Go', value: 'go'},\n{label: 'Java', value: 'java'},\n{label: 'Typescript', value: 'ts'},\n{label: 'PHP', value: 'php'},\n]\n}>\n\n<TabItem value=\"go\">\n\n<!--SNIPSTART subscription-go-workflow-definition-->\n<!--SNIPEND-->\n\n</TabItem>\n<TabItem value=\"java\">\n\n<!--SNIPSTART subscription-java-workflow-definition-implementation-->\n<!--SNIPEND-->\n\n</TabItem>\n<TabItem value=\"ts\">\n\n<!--SNIPSTART subscription-ts-workflow-definition-->\n<!--SNIPEND-->\n\n</TabItem>\n<TabItem value=\"php\">\n\n<!--SNIPSTART subscription-php-workflow-definition-implementation-->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\nAgain, it is important to note that this is working application code that directly implements the business logic.\nIf any of the operations take a long time, the code is not going to change.\n\nIt is completely okay to be blocked on `chargeCustomerForBillingPeriod` for a day or more if the downstream processing service is down or not responding.\nIn the same way, it is a completely normal operation to sleep for 30 days directly inside the Workflow code.\nThis is possible because infrastructure failures won't affect the Workflow state—including threads, blocking calls, and any variables.\n\nThe Temporal Platform has practically no scalability limits on the number of open Workflow Executions, so this code can be used over and over even if your application has hundreds of millions of customers.\n","is_empty":false},{"file_name":"data-encryption.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/prod-readiness-context/data-encryption.md","id":"prod-readiness-context/data-encryption","title":"How to encrypt data using a custom Data Converter","description":"Configure your custom encryption logic with `PayloadCodec` and set it with a custom Data Converter.","label":"Securing your data","tags":["guide-context","production-readiness"],"ssdi":[],"markdown_content":"\nTemporal Server stores and persists the data handled in your Workflow Execution.\nEncrypting this data ensures that any sensitive application data is secure when handled by the Temporal Server.\n\nFor example, if you have sensitive information passed in the following objects that are persisted in the Workflow Execution Event History, use encryption to secure it:\n\n- Inputs and outputs/results in your [Workflow](/concepts/what-is-a-workflow-execution), [Activity](/concepts/what-is-an-activity-execution), and [Child Workflow](/concepts/what-is-a-child-workflow-execution)\n- [Signal](/concepts/what-is-a-signal) inputs\n- [Memo](/concepts/what-is-a-memo)\n- Headers (verify if applicable to your SDK)\n- [Query](/concepts/what-is-a-query) inputs and results\n- Results of [Local Activities](/concepts/what-is-a-local-activity) and [Side Effects](/concepts/what-is-a-side-effect)\n- [Application errors and failures](/kb/failures)\n\n  Failure messages and stack traces are not encoded as codec-capable Payloads by default; you must explicitly enable encoding these common attributes on failures. For more details, see [Failure Converter](/concepts/what-is-a-failure-converter).\n\nUsing encryption ensures that your sensitive data exists unencrypted only on the Client and the Worker Process that is executing the Workflows and Activities, on hosts that you control.\n\nBy default, your data is serialized to a [Payload](/concepts/what-is-a-payload) by a [Data Converter](/concepts/what-is-a-data-converter).\nTo encrypt your Payload, configure your custom encryption logic with a [Payload Codec](/concepts/what-is-a-payload-codec) and set it with a [custom Data Converter](/concepts/what-is-a-custom-data-converter).\n\nA Payload Codec does byte-to-byte conversion to transform your Payload (for example, by implementing compression and/or encryption and decryption) and is an optional step that happens between the wire and the [Payload Converter](/concepts/what-is-a-payload-converter):\n\n```bash\nUser code <--> Payload Converter <--> Payload Codec <--> Wire <--> Temporal Server\n```\n\nYou can run your Payload Codec with a [Codec Server](/concepts/what-is-a-codec-server) and use the Codec Server endpoints in Web UI and tctl to decode your encrypted Payload locally.\nFor details on how to set up a Codec Server, see [Codec Server setup](/prod-readiness-context/how-to-set-up-codec-server).\n\nHowever, if you plan to set up [remote data encoding](/concepts/what-is-remote-data-encoding) for your data, ensure that you consider all security implications of running encryption remotely before implementing it.\n\nIn codec implementations, we recommend running the function (such as compression or encryption) on the entire input Payload and putting the result in the data field of a new Payload with a different encoding metadata field.\nUsing this technique ensures that the input Payload's metadata is preserved.\nWhen the encoded Payload is sent to be decoded, you can verify the metadata field before applying the decryption.\nIf your Payload is _not_ encoded, we recommend passing the unencoded data to the decode function instead of failing the conversion.\n\nExamples for implementing encryption:\n\n- [Go sample](https://github.com/temporalio/samples-go/tree/main/encryption)\n- [Java sample](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/encryptedpayloads)\n- [Python sample](https://github.com/temporalio/samples-python/tree/main/encryption)\n- [TypeScript sample](https://github.com/temporalio/samples-typescript/tree/main/encryption)\n\nExamples for implementing compression:\n\n- [Go sample](https://pkg.go.dev/go.temporal.io/sdk/converter#ZlibCodecOptions)\n- [Java sample](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/payload/codec/ZlibPayloadCodec.html)\n","is_empty":false},{"file_name":"how-to-set-up-codec-server.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/prod-readiness-context/how-to-set-up-codec-server.md","id":"prod-readiness-context/how-to-set-up-codec-server","title":"Codec Server setup","description":"Run a Codec Server with your Payload Codec and then configure the Web UI and CLI to use the server endpoints.","label":"Codec Server setup","tags":["security","how-to"],"ssdi":[],"markdown_content":"\nUse a Codec Server to decode your encoded [payloads](/concepts/what-is-a-payload) and integrate it with the Temporal Web UI and CLI commands when debugging your Workflows.\n\nA Codec Server is an HTTP or HTTPS Server that you create and host.\nIt must be configured to use a [Payload Codec](/concepts/what-is-a-payload-codec) with the required decode logic and encryption keys.\nTemporal Cloud requires an HTTPS Codec Server.\n\nThe Codec Server is independent of the Temporal Server and decodes your encrypted payloads through endpoints.\nWhen you set the codec endpoint in the Temporal Web UI, the Web UI uses the remote endpoint to send encoded payloads to the Codec Server and receive decoded payloads from the Codec Server.\nSee [API contract requirements](#api-contract-specifications).\nDecoded payloads are then displayed in the Workflow Execution Event History on the Web UI.\n\nNote that when you use a Codec Server, the decoded payloads are visible only to you on the Web UI; payloads on the Temporal Server (whether on Temporal Cloud or a self-hosted Temporal Cluster) remain encrypted.\n\nBecause you create, operate, and manage access to your Codec Server in your controlled environment, ensure that you consider the following:\n\n- When you set your codec endpoint with your Web UI, expect your Codec Server to receive a large number of requests per Workflow Execution from the Web UI.\n- Ensure that you secure access your Codec Server.\n  For details, see [Authorization](#authorization).\n- The Temporal Web UI only displays the decoded payloads received from your Codec Server in real-time; it does not store or send the data back to the Temporal Server (whether on Cloud or self-hosted Temporal Cluster).\n- You might have latencies introduced in the Web UI when sending and receiving payloads to the Codec Server.\n\nTo create a Codec Server, you need the following components:\n\n- A [Payload Codec](/concepts/what-is-a-payload-codec) with the requisite keys and logic to decode your encrypted payloads.\n  You can use the Payload Codec that you applied with your Data Converter to encode your Payloads and configure it with your Codec Server.\n  However, if you are writing your Codec Server in a different SDK from the one that applies the Data Converter, ensure that your logic and keys are correctly replicated.\n- Key management infrastructure or plan for sharing your encryption keys between the Workers and your Codec Server.\n- [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) configuration on the HTTP/HTTPS endpoints in your Codec Server for sending and receiving requests from the Temporal Web UI.\n- Optional: Secure access through VPN and access control.\n  For details, see [Authorization](#authorization).\n\nFor examples on how to create your Codec Server, see following Codec Server implementation samples:\n\n- [Go](https://github.com/temporalio/samples-go/tree/main/codec-server)\n- [Java](https://github.com/temporalio/sdk-java/tree/master/temporal-remote-data-encoder)\n- [Python](https://github.com/temporalio/samples-python/blob/main/encryption/codec_server.py)\n- [TypeScript](https://github.com/temporalio/samples-typescript/blob/main/encryption/src/codec-server.ts)\n\n### API contract specifications\n\nWhen you create your Codec Server to handle requests from the Web UI, the following requirements must be met.\n\n#### Endpoints\n\nThe [Web UI/CLI calls the POST method with the /decode endpoint](https://github.com/temporalio/ui/blob/11ef7ddb47711444a365c7760eae41853446da07/src/lib/services/data-encoder.ts#L38).\n\nIn your Codec Server, create a `/decode` path and pass the incoming payload to the decode method in your Payload Codec.\n\nYou can also add a [verification step](#authorization) to check whether the incoming request has the required authorization to access the decode logic in your Payload Codec.\n\n#### Headers\n\nEach request from the Web UI to your Codec Server includes the following headers:\n\n- `Content-Type: application/json`: Ensure that your Codec Server can accommodate this [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types).\n\n- `X-Namespace: {namespace}`: This is a custom HTTP Header. Ensure that the [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) configuration in your Codec Server includes this header.\n\n- [Optional] `Authorization: <credentials>`: Include this in your CORS configuration when enabling authorization with your Codec Server.\n\nFor details on setting up authorization, see [Authorization](#authorization).\n\n#### Request body\n\nThe general specification for the `POST` request body contains payloads.\nBy default, all field values in your payload are base64 encoded, regardless of whether they are encrypted by your custom codec implementation.\n\nThe following example shows a sample `POST` request body with base64 encoding.\n\n```json\n{\n  \"payloads\": [{\n    \"metadata\": {\n      \"encoding\": <base64EncodedEncodingHint>\n    },\n    \"data\": <encryptedPayloadData>\n  }, ...]\n}\n```\n\n#### CORS\n\nEnable [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) requests on your Codec Server to receive HTTP/HTTPS requests from the Temporal Web UI.\n\nAt a minimum, enable the following responses from your Codec Server to allow requests coming from the Temporal Web UI:\n\n- `Access-Control-Allow-Origin`\n- `Access-Control-Allow-Methods`\n- `Access-Control-Allow-Headers`\n\nFor example, for Temporal Cloud Web UI hosted at https://cloud.temporal.io, enable the following in your Codec Server:\n\n- `Access-Control-Allow-Origin: https://cloud.temporal.io`\n- `Access-Control-Allow-Methods: POST, GET, OPTIONS`\n- `Access-Control-Allow-Headers: X-Namespace, Content-Type`\n\nFor details on what a sample request/response looks like from the Temporal Web UI, see [Sample Request/Response](#sample-requestresponse).\nIf setting authorization, include `Authorization` in your `Access-Control-Allow-Headers`.\nFor details on setting up authorization, see [Authorization](#authorization).\n\n#### Authorization\n\nTo enable authorization from the Web UI (for both self-hosted Cluster and Temporal Cloud), your Codec Server must be an HTTPS Server.\n\n**Temporal Cloud**\n\nThe Temporal Cloud UI provides an option to pass access tokens (JWT) to your Codec Server endpoints.\nUse the access tokens to validate access and then return decoded payloads from the Codec Server.\n\nYou can enable this by selecting **Pass access token** in your Codec Server endpoint interface where you add your endpoint.\nEnabling this option in the Temporal Cloud UI adds an authorization header to each request sent to the Codec Server endpoint that you set.\n\nIn your Codec Server implementation, verify the signature on this access token (in your authorization header) against the JWKS endpoint provided to you.\n\n<!--Update: the JWKS link is provided in the UI onboarding content for now.\nIs this process defined? when a customer signs up for temporal cloud, do we provide them with the JWKS as part of the onboarding process? also the JWKS endpoint is rate-limited - something we should call out when providing the link to users.-->\n\n<!-- Commenting this for now.-->\n<!--If you want to unpack the claims in your token to add additional checks on whether the user has valid access to the Namespace and payloads they are trying to access, you can implement it using Auth0 SDKs, middleware, or one of the third-party libraries at JWT.io.-->\n\nThe token provided from Temporal Cloud UI contains the email identifier of the person requesting access to the payloads.\nBased on the permissions you have provided to the user in your access control systems, set conditions in your Codec Server whether to return decoded payloads or just return the original encoded payloads.\n\n**Self-hosted Temporal Cluster**\n\nOn self-hosted Temporal Clusters, configure [authorization in the Web UI configuration](/references/web-ui-configuration#auth) in your Temporal Cluster setup.\n\nWith this enabled, you can pass access tokens to your Codec Server and validate the requests from the Web UI to the Codec Server endpoints that you set.\n\nNote that with self-hosted Temporal Clusters, you must explicitly configure authorization specifications for the Web UI and CLI.\n\nThe following sample provides implementation examples for applying authentication on your Codec Server using the Go SDK.\n\n- [Codec Server](https://github.com/temporalio/samples-go/tree/main/codec-server)\n\n#### Sample request/response\n\nConsider the following sample request/response when creating and hosting a Codec Server with the following specifications:\n\n- Scheme: `https`\n- Host: `dev.mydomain.com/codec`\n- Path: `/decode`\n\n```json\nHTTP/1.1 POST /decode\nHost: https://dev.mydomain.com/codec\nContent-Type: application/json\nX-Namespace: myapp-dev.acctid123\nAuthorization: Bearer <token>\n\n{\"payloads\":[{\"metadata\":{\"encoding\":\"anNvbi9wcm90b2J1Zg==\",\"messageType\":\"dGVtcG9yYWxfc2hvcC5vcmNoZXN0cmF0aW9ucy52MS5TdGFydFNob3BwaW5nQ2FydFJlcXVlc3Q=\"},\"data\":\"eyJjYXJ0SWQiOiJleGFtcGxlLWNhcnQiLCJzaG9wcGVySWQiOiJ5b3VyLXNob3BwZXItaWQtZXhhbXBsZSIsImVtYWlsIjoieW91ci1lbWFpbEBkb21haW4uY29tIn0\"}]}\n\n200 OK\nContent-Type: application/json\n\n{\n  \"payloads\": [{\n    \"metadata\":{\n      \"encoding\": \"json/protobuf\",\n      \"messageType\": \"temporal_shop.orchestrations.v1.StartShoppingCartRequest\"\n    },\n    \"data\":{\n      \"cartId\":\"example-cart\",\n      \"shopperId\":\"your-shopper-id-example\",\n      \"email\":\"your-email@domain.com\"\n    }}]\n}\n```\n\n### Hosting your Codec Server\n\nYour Codec Server can be hosted at an organization level or locally.\n\n#### Organization-level hosting\n\nHosting the Codec Server for your organization simplifies both key management used for decryption and versioning the codec itself.\nConsider the following details for a multi-tenant approach to setting up your Codec Server:\n\n- Ingress: Your server will require ingress configuration for your users to access the server.\n- Authorization: You must set explicit authorization checks to validate requests to your Codec Server.\n\n#### Local hosting\n\nLocally hosting the Codec Server is simpler to get started.\nHowever, consider the following before choosing to do so:\n\n- A single URL configuration is accepted for the Cloud account.\n  This means some agreed-upon policy on the URL must be made for everyone using the Namespaces in this account.\n  For example, if you configure your remote codec endpoint to be http://localhost:8080/codec, every developer must host your Codec Server locally at that port.\n\n  Alternatively, you can use the local `hosts` file to allow each developer to choose where to host.\n  For example, configure the remote codec endpoint as http://codec.server and allow each developer to control what it maps to locally.\n\n- Distributing encryption keys that can decrypt the payloads at your organization can be a security risk.\n\n### Set your Codec Server endpoints with Web UI and CLI\n\nAfter you create your Codec Server and expose the requisite endpoints, set the endpoints in your Web UI and CLI.\n\n#### Web UI\n\nOn Temporal Cloud and self-hosted Temporal Clusters, you can configure a Codec Server endpoint to be used for a Namespace in the Web UI.\n\n![Codec Server endpoint Namespace setting](/img/set-codec-endpoint-form.png)\n\nTo set a Codec Server endpoint on a Namespace, do the following.\n\n1. In the Web UI, go to Namespaces, select the Namespace where you want to configure the Codec Server endpoint, and click **Edit**.\n1. In the **Codec Server** section on the Namespace configuration page, enter your Codec Server endpoint and port number.\n1. Optional: If your Codec Server is configured to [authenticate requests](#authorization) from Temporal Web UI, enable **Pass access token** to send a JWT access token with the HTTPS requests.\n1. Optional: If your Codec Server is configured to [verify origins of requests](#cors), enable **Include cross-origin credentials**.\n\nSetting a Codec Server endpoint on a Namespace enables it for all users on the Namespace.\nOn Temporal Cloud, you must have [Namespace Admin privileges](/cloud/#namespace-level-permissions) to add a Codec Server endpoint on the Namespace.\n\nAll users on a Namespace have the option to override the Namespace-level setting at the browser level.\nOverriding the Namespace-level endpoint only affects your browser.\nThis can be useful when developing, testing, or troubleshooting encoding functionality.\n\n![Codec Server endpoint browser setting](/img/data-encoder-button.png)\n\nTo set a browser override for the Namespace-level endpoint, do the following.\n\n1. Navigate to **Workflows** in your Namespace.\n2. In the top-right corner, select **Configure Codec Server**.\n3. Select whether you want to use the Namespace-level (or Cluster-level for self-hosted Cluster) or the browser-level Codec Endpoint setting as the default for your browser.\n   In Temporal Cloud:\n   - **Use Namespace-level settings, where available. Otherwise, use my browser setting.**\n     Uses the Namespace-level Codec Server endpoint by default.\n     If no endpoint is set on the Namespace, your browser setting is applied.\n   - **Use my browser setting and ignore Namespace-level setting.**\n     Applies your browser-level setting by default, overriding the Namespace-level Codec Server endpoint.\n4. Enter your Codec Server endpoint and port number.\n5. Optional: If your Codec Server is configured to [authenticate requests](#authorization) from Temporal Web UI, enable **Pass access token** to send a JWT access token with the HTTPS requests.\n6. Optional: If your Codec Server is configured to [verify origins of requests](#cors), enable **Include cross-origin credentials**.\n\nIn self-hosted Temporal Clusters where you set up your UI Server, you can also set the codec endpoint in the UI server [configuration file](/references/web-ui-configuration#codec), as shown in the following example.\n\n```yaml\ncodec:\n    endpoint: {{ default .Env.TEMPORAL_CODEC_ENDPOINT \"{namespace}\"}}\n```\n\nStart the UI server to use this endpoint on the Web UI for decoding data in Workflow Executions in the specified Namespace.\n\n#### CLI\n\nIn self-hosted Temporal Clusters, after the Codec Server is started, provide the exposed endpoint to CLI using the `--codec_endpoint` command option.\n\nFor example, if you are running your Codec Server locally and expose port 8888 as your endpoint, run the following command to set the codec endpoint globally.\n\n```bash\ntemporal env set --codec-endpoint \"http://localhost:8888\"\n```\n\nIf your codec endpoint is not set globally, use the `--codec-endpoint` option with your CLI commands.\nFor example, to see the decoded output of the Workflow Execution \"yourWorkflow\" in the Namespace \"yourNamespace\", run the following command.\n\n```bash\ntemporal --codec-endpoint \"http://localhost:8888\" --namespace \"yourNamespace\" workflow show --workflow-id \"yourWorkflow\"  --run-id \"<yourRunId>\" --output \"table\"\n```\n\nFor details, see the [CLI reference](/cli/).\n\nCurrently in Temporal Cloud, you can set the Codec Server endpoint only from the Web UI.\n","is_empty":false},{"file_name":"activity-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/activity-heartbeats.md","id":"go/activity-heartbeats","title":"How to Heartbeat an Activity","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.","label":"Activity Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn [Activity Heartbeat](/concepts/what-is-an-activity-heartbeat) is a ping from the [Worker Process](/concepts/what-is-a-worker-process) that is executing the Activity to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nEach Heartbeat informs the Temporal Cluster that the [Activity Execution](/concepts/what-is-an-activity-execution) is making progress and the Worker has not crashed.\nIf the Cluster does not receive a Heartbeat within a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) time period, the Activity will be considered failed and another [Activity Task Execution](/concepts/what-is-an-activity-task-execution) may be scheduled according to the Retry Policy.\n\nHeartbeats may not always be sent to the Cluster—they may be [throttled](/concepts/what-is-an-activity-heartbeat#throttling) by the Worker.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\nHeartbeats can contain a `details` field describing the Activity's current progress.\nIf an Activity gets retried, the Activity can access the `details` from the last Heartbeat that was sent to the Cluster.\n","is_empty":false},{"file_name":"activity-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/activity-parameters.md","id":"go/activity-parameters","title":"How to develop Activity Parameters","description":"When it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.","label":"Activity parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThere is no explicit limit to the total number of parameters that an [Activity Definition](/concepts/what-is-an-activity-definition) may support.\nHowever, there is a limit of the total size of the data ends up encoded into a gRPC message Payload.\n\nA single argument is limited to a maximum size of 2 MB.\nAnd the total size of a gRPC message, which includes all the arguments, is limited to a maximum of 4 MB.\n\nAlso, keep in mind that all Payload data is recorded in the [Workflow Execution Event History](/concepts/what-is-an-event-history) and large Event Histories can affect Worker performance.\nThis is because the entire Event History could be transferred to a Worker Process with a [Workflow Task](/concepts/what-is-a-workflow-task).\n\n<!--TODO link to gRPC limit section when available -->\n\nSome SDKs require that you pass context objects, others do not.\nWhen it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.\nThis is so that you can change what data is passed to the Activity without breaking a function or method signature.\n","is_empty":false},{"file_name":"activity-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/activity-retries.md","id":"go/activity-retries","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/activity-retry-policy.md","id":"go/activity-retry-policy","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-simulator.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/activity-retry-simulator.md","id":"go/activity-retry-simulator","title":"How to visualize an Activity Retry Policy with timeouts","description":"Use this tool to visualize total Activity Execution times and experiment with various Activity timeouts and Retry Policies.","label":"Activity retry simulator","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse this tool to visualize total Activity Execution times and experiment with different Activity timeouts and Retry Policies.\n\nThe simulator is based on a common Activity use-case, which is to call a third party HTTP API and return the results.\nSee the example code snippets below.\n\nUse the Activity Retries settings to configure how long the API request takes to succeed or fail.\nThere is an option to generate scenarios.\nThe _Task Time in Queue_ simulates the time the Activity Task might be waiting in the Task Queue.\n\nUse the Activity Timeouts and Retry Policy settings to see how they impact the success or failure of an Activity Execution.\n\nimport RetrySimulator from '/docs/components/RetrySimulator/RetrySimulator';\n\n<RetrySimulator />\n","is_empty":false},{"file_name":"activity-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/activity-return-values.md","id":"go/activity-return-values","title":"How to define Activity return values","description":"All data returned from an Activity must be serializable.","label":"Activity return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll data returned from an Activity must be serializable.\n\nThere is no explicit limit to the amount of data that can be returned by an Activity, but keep in mind that all return values are recorded in a [Workflow Execution Event History](/concepts/what-is-an-event-history).\n","is_empty":false},{"file_name":"activity-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/activity-timeouts-and-retries.md","id":"go/activity-timeouts-and-retries","title":"How to set Activity timeouts and retries","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts and retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"activity-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/activity-timeouts.md","id":"go/activity-timeouts","title":"How to set Activity timeouts","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\n\nThe following timeouts are available in the Activity Options.\n\n- **[Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout)**: is the maximum amount of time allowed for the overall [Activity Execution](/concepts/what-is-an-activity-execution).\n- **[Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout)**: is the maximum time allowed for a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n- **[Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout)**: is the maximum amount of time that is allowed from when an [Activity Task](/concepts/what-is-an-activity-task) is scheduled to when a [Worker](/concepts/what-is-a-worker) starts that Activity Task.\n\nAn Activity Execution must have either the Start-To-Close or the Schedule-To-Close Timeout set.\n","is_empty":false},{"file_name":"add-sdk.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/add-sdk.md","id":"go/add-sdk","title":"How to install a Temporal SDK","description":"A Temporal SDK provides a framework for Temporal Application development.","label":"Install a Temporal SDK","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal SDK](/concepts/what-is-a-temporal-sdk) provides a framework for [Temporal Application](/concepts/what-is-a-temporal-application) development.\n\nAn SDK provides you with the following:\n\n- A [Temporal Client](/concepts/what-is-a-temporal-client) to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n- APIs to develop [Workflows](/concepts/what-is-a-workflow).\n- APIs to create and manage [Worker Processes](/concepts/what-is-a-worker).\n- APIs to author [Activities](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"additional-session-info.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/additional-session-info.md","id":"go/additional-session-info","title":"Additional Session usage information","description":"The Session Context also stores some Session metadata, which can be retrieved by the GetSessionInfo API.","label":"Session metadata","tags":["go","sessions","task-routing"],"ssdi":[],"markdown_content":"\n```go\ntype SessionInfo struct {\n // A unique Id for the session\n SessionID         string\n // The hostname of the worker that is executing the session\n HostName          string\n // ... other unexported fields\n}\n\nfunc GetSessionInfo(ctx Context) *SessionInfo\n```\n\nThe Session Context also stores some Session metadata, which can be retrieved by the `GetSessionInfo()` API.\nIf the Context passed in doesn't contain any Session metadata, this API will return a `nil` pointer.\n\n### Recreate Session\n\nFor long-running Sessions, you may want to use the `ContinueAsNew` feature to split the Workflow into multiple runs when all Activities need to be executed by the same Worker.\nThe `RecreateSession()` API is designed for such a use case.\n\n```go\nfunc RecreateSession(ctx Context, recreateToken []byte, sessionOptions *SessionOptions) (Context, error)\n```\n\nIts usage is the same as `CreateSession()` except that it also takes in a `recreateToken`, which is needed to create a new Session on the same Worker as the previous one.\nYou can get the token by calling the `GetRecreateToken()` method of the `SessionInfo` object.\n\n```go\ntoken := workflow.GetSessionInfo(sessionCtx).GetRecreateToken()\n```\n\n**Is there a complete example?**\n\nYes, the [file processing example](https://github.com/temporalio/samples-go/tree/master/fileprocessing) in the [temporalio/samples-go](https://github.com/temporalio/samples-go) repo has been updated to use the session framework.\n\n**What happens to my Activity if the Worker dies?**\n\nIf your Activity has already been scheduled, it will be canceled.\nIf not, you will get a `workflow.ErrSessionFailed` error when you call `workflow.ExecuteActivity()`.\n\n**Is the concurrent session limitation per process or per host?**\n\nIt's per Worker Process, so make sure there's only one Worker Process running on the host if you plan to use this feature.\n\n**Future Work**\n\n- Right now, a Session is considered failed if the Worker Process dies.\n  However, for some use cases, you may only care whether the Worker host is alive or not.\n  For these use cases, the Session should be automatically re-established if the Worker Process is restarted.\n\n- The current implementation assumes that all Sessions are consuming the same type of resource and there's only one global limitation.\n  Our plan is to allow you to specify what type of resource your Session will consume and enforce different limitations on different types of resources.\n","is_empty":false},{"file_name":"api-reference-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/api-reference-go.md","id":"go/api-reference-go","title":"How to find the Go SDK API reference","description":"The Go SDK API reference is published on pkg.go.dev","label":"API reference","ssdi":[],"markdown_content":"\nThe Temporal Go SDK API reference is published on [pkg.go.dev](https://pkg.go.dev/go.temporal.io/sdk).\n\n- Short link: [`t.mp/go-api`](https://t.mp/go-api)\n","is_empty":false},{"file_name":"assert-in-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/assert-in-workflows.md","id":"go/assert-in-workflows","title":"Assert in Workflows","description":"How to Assert in Workflows","label":"Assert in Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\n<!-- not used -->\n\nIn some cases it's useful to assert directly in the Workflow context.\n\nFor example, TypeScript and Python, can use `assert` in Workflow code.\n","is_empty":false},{"file_name":"async-activity-completion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/async-activity-completion.md","id":"go/async-activity-completion","title":"How to asynchronously complete an Activity","description":"Asynchronous Activity Completion enables the Activity Function to return without the Activity Execution completing.","label":"Asynchronous Activity Completion","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Asynchronous Activity Completion](/concepts/what-is-asynchronous-activity-completion) enables the Activity Function to return without the Activity Execution completing.\n\nThere are three steps to follow:\n\n1. The Activity provides the external system with identifying information needed to complete the Activity Execution.\n   Identifying information can be a [Task Token](/concepts/what-is-a-task-token), or a combination of Namespace, Workflow Id, and Activity Id.\n2. The Activity Function completes in a way that identifies it as waiting to be completed by an external system.\n3. The Temporal Client is used to Heartbeat and complete the Activity.\n","is_empty":false},{"file_name":"cancel-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/cancel-activity.md","id":"go/cancel-activity","title":"Cancel an Activity from a Workflow","description":"An Activity can be canceled from within a Workflow if the Activity sends Heartbeats.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCanceling an Activity from within a Workflow requires that the Activity Execution sends Heartbeats and sets a Heartbeat Timeout.\nIf the Heartbeat is not invoked, the Activity cannot receive a cancellation request.\nWhen any non-immediate Activity is executed, the Activity Execution should send Heartbeats and set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) to ensure that the server knows it is still working.\n\nWhen an Activity is canceled, an error is raised in the Activity at the next available opportunity.\nIf cleanup logic needs to be performed, it can be done in a `finally` clause or inside a caught cancel error.\nHowever, for the Activity to appear canceled the exception needs to be re-raised.\n\n:::note\n\nUnlike regular Activities, [Local Activities](/concepts/what-is-a-local-activity) can be canceled if they don't send Heartbeats.\nLocal Activities are handled locally, and all the information needed to handle the cancellation logic is available in the same Worker process.\n\n:::\n","is_empty":false},{"file_name":"cancel-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/cancel-an-activity.md","id":"go/cancel-an-activity","title":"Cancel an Activity","description":"If an Activity is supposed to react to Cancellation, you can test whether it reacts correctly by canceling it.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity is supposed to react to a Cancellation, you can test whether it reacts correctly by canceling it.\n","is_empty":false},{"file_name":"child-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/child-workflows.md","id":"go/child-workflows","title":"How to start a Child Workflow Execution","description":"A Child Workflow Execution is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.","label":"Child Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.\n\nWhen using a Child Workflow API, Child Workflow related Events ([StartChildWorkflowExecutionInitiated](/references/events#startchildworkflowexecutioninitiated), [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted), [ChildWorkflowExecutionCompleted](/references/events#childworkflowexecutioncompleted), etc...) are logged in the Workflow Execution Event History.\n\nAlways block progress until the [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted) Event is logged to the Event History to ensure the Child Workflow Execution has started.\nAfter that, Child Workflow Executions may be abandoned using the default _Abandon_ [Parent Close Policy](/concepts/what-is-a-parent-close-policy) set in the Child Workflow Options.\n\nTo be sure that the Child Workflow Execution has started, first call the Child Workflow Execution method on the instance of Child Workflow future, which returns a different future.\n\nThen get the value of an object that acts as a proxy for a result that is initially unknown, which is what waits until the Child Workflow Execution has spawned.\n","is_empty":false},{"file_name":"code-samples-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/code-samples-go.md","id":"go/code-samples-go","title":"Code samples","label":"Code samples","ssdi":[],"markdown_content":"\n- [Go Samples repo](https://github.com/temporalio/samples-go#samples-directory)\n- [Background Check application](https://github.com/temporalio/background-checks): Provides a non-trivial Temporal Application implementation in conjunction with [application documentation](https://learn.temporal.io/examples/go/background-checks/).\n- [Hello world application template in Go](https://github.com/temporalio/hello-world-project-template-go): Provides a quick-start development app for users.\n  This sample works in conjunction with the [\"Hello World!\" from scratch tutorial in Go](https://learn.temporal.io/getting_started/go/hello_world_in_go/).\n- [Money transfer application template in Go](https://github.com/temporalio/money-transfer-project-template-go): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Go](https://learn.temporal.io/getting_started/go/first_program_in_go/).\n- [Subscription-style Workflow Definition in Go](https://github.com/temporalio/subscription-workflow-project-template-go): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n- [eCommerce application example in Go](https://github.com/temporalio/temporal-ecommerce): Showcases a per-user shopping cart–style Workflow Definition that includes an API for adding and removing items from the cart as well as a web UI.\n  This application sample works in conjunction with the [eCommerce in Go tutorial](https://temporal.io/blog/build-an-ecommerce-app-with-temporal-part-1).\n","is_empty":false},{"file_name":"code-samples.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/code-samples.md","id":"go/code-samples","title":"Where are SDK-specific code examples?","description":"You can find a complete list of executable code samples in Temporal's GitHub repository.","label":"Code samples","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can find a complete list of executable code samples in [Temporal's GitHub repository](https://github.com/temporalio?q=samples-&type=all&language=&sort=).\n\nAdditionally, several of the [Tutorials](https://learn.temporal.io) are backed by a fully executable template application.\n","is_empty":false},{"file_name":"connect-to-a-dev-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/connect-to-a-dev-cluster.md","id":"go/connect-to-a-dev-cluster","title":"How to connect a Temporal Client to a Temporal Cluster","description":"When connecting a Temporal Client to a Temporal Cluster, you must provide the address and port number of the Temporal Cluster.","label":"Connect to a dev Cluster","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal Client](/concepts/what-is-a-temporal-client) enables you to communicate with the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nCommunication with a Temporal Cluster includes, but isn't limited to, the following:\n\n- Starting Workflow Executions.\n- Sending Signals to Workflow Executions.\n- Sending Queries to Workflow Executions.\n- Getting the results of a Workflow Execution.\n- Providing an Activity Task Token.\n\n:::caution\n\nA Temporal Client cannot be initialized and used inside a Workflow.\nHowever, it is acceptable and common to use a Temporal Client inside an Activity to communicate with a Temporal Cluster.\n\n:::\n\nWhen you are running a Cluster locally (such as [Temporalite](/kb/all-the-ways-to-run-a-cluster#temporalite)), the number of connection options you must provide is minimal.\nMany SDKs default to the local host or IP address and port that Temporalite and [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose) serve (`127.0.0.1:7233`).\n","is_empty":false},{"file_name":"connect-to-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/connect-to-temporal-cloud.md","id":"go/connect-to-temporal-cloud","title":"How to connect to Temporal Cloud","description":"Use a compatible mTLS CA certificate and mTLS private key and your Cloud Namespace to connect to Temporal Cloud.","label":"Connect to Temporal Cloud","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen you connect to [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"continue-as-new.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/continue-as-new.md","id":"go/continue-as-new","title":"How to Continue-As-New","description":"Continue-As-New enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.","label":"Continue-As-New","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Continue-As-New](/concepts/what-is-continue-as-new) enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.\nThe Workflow Execution spawned from the use of Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\n","is_empty":false},{"file_name":"create-a-session.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/create-a-session.md","id":"go/create-a-session","title":"How to create a Worker Session","description":"Within the Workflow code use the Workflow APIs to create a Session with whichever Worker picks up the first Activity Task.","label":"Create a Session","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWithin the Workflow code use the Workflow APIs to create a Session with whichever Worker picks up the first Activity Task.\n","is_empty":false},{"file_name":"cron-jobs.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/cron-jobs.md","id":"go/cron-jobs","title":"How to use Temporal Cron Jobs","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Jobs","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.\n","is_empty":false},{"file_name":"custom-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/custom-logging.md","id":"go/custom-logging","title":"How to provide a custom logger","description":"Use a custom logger for logging.","label":"Custom logger","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a custom logger for logging.\n","is_empty":false},{"file_name":"custom-payload-conversion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/custom-payload-conversion.md","id":"go/custom-payload-conversion","title":"How to use custom payload conversion","description":"Create your custom `PayloadConverter` and set it on a `DataConverter` in your Client options.","label":"Custom payload conversion","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal SDKs provide a [Payload Converter](/concepts/what-is-a-payload-converter) that can be customized to convert a custom data type to [Payload](/concepts/what-is-a-payload) and back.\n\nImplementing custom Payload conversion is optional.\nIt is needed only if the [default Data Converter](/concepts/what-is-a-default-data-converter) does not support your custom values.\n\nTo support custom Payload conversion, create a [custom Payload Converter](/concepts/what-is-a-payload-converter#custom-payload-conversion) and configure the Data Converter to use it in your Client options.\n\nThe order in which your encoding Payload Converters are applied depend on the order given to the Data Converter.\nYou can set multiple encoding Payload Converters to run your conversions.\nWhen the Data Converter receives a value for conversion, it passes through each Payload Converter in sequence until the converter that handles the data type does the conversion.\n","is_empty":false},{"file_name":"debug-environment-development.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/debug-environment-development.md","id":"go/debug-environment-development","title":"How to debug in a development environment","description":"In addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the Web UI and tctl.","label":"Debug in a development environment","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the [Web UI](/web-ui) or [`tctl`](/tctl-v1).\n","is_empty":false},{"file_name":"debug-environment-production.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/debug-environment-production.md","id":"go/debug-environment-production","title":"How to debug in a production environment","description":"Debug production Workflows using the Web UI, tctl, Replays, Tracing, or Logging.","label":"Debug in a production environment","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can debug production Workflows using:\n\n- [Web UI](/web-ui)\n- [tctl](/tctl-v1)\n- [Replay](/go/testing#replay)\n- [Tracing](/go/tracing)\n- [Logging](/go/logging)\n\nYou can debug and tune Worker performance with metrics and the [Worker performance guide](/dev-guide/worker-performance).\nFor more information, see [Metrics](/go/metrics) for setting up SDK metrics.\n\nDebug Server performance with [Cloud metrics](/cloud/how-to-monitor-temporal-cloud-metrics) or [self-hosted Server metrics](/kb/legacy-oss-prod-deploy#scaling-and-metrics).\n","is_empty":false},{"file_name":"debugging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/debugging.md","id":"go/debugging","title":"Debugging","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Debug","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can use a debugger tool provided by your favorite IDE to debug your Workflow Definitions prior to testing or executing them.\n\nThe Temporal Go SDK includes deadlock detection which fails a Workflow Task in case the code blocks over a second without relinquishing execution control.\nBecause of this you can often encounter a `PanicError: Potential deadlock detected` while stepping through Workflow Definitions during debugging.\n\nTo alleviate this issue, you can set the `TEMPORAL_DEBUG` environment variable to `true` before debugging your Workflow Definition.\n\n:::note\n\nMake sure to set `TEMPORAL_DEBUG` to true only during debugging.\n\n:::\n","is_empty":false},{"file_name":"define-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/define-query.md","id":"go/define-query","title":"How to define a Query","description":"A Query has a name and can have arguments.","label":"Define Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Query has a name and can have arguments.\n\n- The name, also called a Query type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"define-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/define-signal.md","id":"go/define-signal","title":"How to define a Signal","description":"A Signal has a name and can have arguments.","label":"Define Signal","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"develop-a-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/develop-a-worker.md","id":"go/develop-a-worker","title":"How to develop a Worker in Go","description":"Develop an instance of a Worker by calling `worker.New()`, available via the `go.temporal.io/sdk/worker` package.","label":"Develop Worker","tags":["developer-guide","go","workers"],"ssdi":[],"markdown_content":"\nCreate an instance of [`Worker`](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) by calling [`worker.New()`](https://pkg.go.dev/go.temporal.io/sdk/worker#New), available through the `go.temporal.io/sdk/worker` package, and pass it the following parameters:\n\n1. An instance of the Temporal Go SDK `Client`.\n1. The name of the Task Queue that it will poll.\n1. An instance of `worker.Options`, which can be empty.\n\nThen, register the Workflow Types and the Activity Types that the Worker will be capable of executing.\n\nLastly, call either the `Start()` or the `Run()` method on the instance of the Worker.\nRun accepts an interrupt channel as a parameter, so that the Worker can be stopped in the terminal.\nOtherwise, the `Stop()` method must be called to stop the Worker.\n\n```go\npackage main\n\nimport (\n   \"go.temporal.io/sdk/client\"\n   \"go.temporal.io/sdk/worker\"\n)\n\nfunc main() {\n   c, err := client.Dial(client.Options{})\n   if err != nil {\n       // ...\n   }\n   defer c.Close()\n   w := worker.New(c, \"your-task-queue\", worker.Options{})\n   w.RegisterWorkflow(YourWorkflowDefinition)\n   w.RegisterActivity(YourActivityDefinition)\n   err = w.Run(worker.InterruptCh())\n   if err != nil {\n       // ...\n   }\n // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n}\n\nfunc YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResponse, error) {\n // ...\n}\n```\n\n:::tip\n\nIf you have [`gow`](https://github.com/mitranim/gow) installed, the Worker Process automatically \"reloads\" when you update the Worker file:\n\n```bash\ngo install github.com/mitranim/gow@latest\ngow run worker/main.go # automatically reload when file changed\n```\n\n:::\n","is_empty":false},{"file_name":"develop-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/develop-activities.md","id":"go/develop-activities","title":"How to develop an Activity in Go","description":"In the Temporal Go SDK programming model, an Activity Definition is an exportable function or `stuct` method.","label":"Activity Development","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nIn the Temporal Go SDK programming model, an Activity Definition is an exportable function or a `struct` method.\n\n**Function**\n\n```go\n// basic function signature\nfunc YourActivityDefinition(ctx context.Context) error {\n // ...\n return nil\n}\n\n// with parameters and return values\nfunc SimpleActivity(ctx context.Context, value string) (string, error)\n```\n\n**Struct method**\n\n```go\ntype YourActivityStruct struct {\n ActivityFieldOne string\n ActivityFieldTwo int\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinition(ctx context.Context) error {\n // ...\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinitionTwo(ctx context.Context) error {\n // ...\n}\n```\n\nAn _Activity struct_ can have more than one method, with each method acting as a separate Activity Type.\nActivities written as struct methods can use shared struct variables, such as:\n\n- an application level DB pool\n- client connection to another service\n- reusable utilities\n- any other expensive resources that you only want to initialize once per process\n\nBecause this is such a common need, the rest of this guide shows Activities written as `struct` methods.\n\n### Parameters\n\nThe first parameter of an Activity Definition is `context.Context`.\nThis parameter is optional for an Activity Definition, though it is recommended, especially if the Activity is expected to use other Go SDK APIs.\n\nAn Activity Definition can support as many other custom parameters as needed.\nHowever, all parameters must be serializable (parameters can’t be channels, functions, variadic, or unsafe pointers), and it is recommended to pass a single struct that can be updated later.\n\n```go\ntype YourActivityParam struct {\n ActivityParamFieldOne string\n ActivityParamFieldTwo int\n}\n\ntype YourActivityStruct struct {\n // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n // ...\n}\n```\n\n### Return values\n\nA Go-based Activity Definition can return either just an `error` or a `customValue, error` combination (same as a Workflow Definition).\nYou may wish to use a `struct` type to hold all custom values, just keep in mind they must all be serializable.\n\n```go\ntype YourActivityResult struct{\n  ActivityResultFieldOne string\n  ActivityResultFieldTwo int\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResult, error) {\n  // ...\n  result := YourActivityResult {\n    ActivityResultFieldOne: a.ActivityFieldOne,\n    ActivityResultFieldTwo: a.ActivityFieldTwo,\n  }\n  return result, nil\n}\n```\n","is_empty":false},{"file_name":"develop-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/develop-workflows.md","id":"go/develop-workflows","title":"Develop a Workflow in Go","description":"In the Temporal Go SDK programming model, a Workflow Definition is an exportable function.","label":"Workflow Development","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nIn the Temporal Go SDK programming model, a [Workflow Definition](/concepts/what-is-a-workflow-definition) is an exportable function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context) error {\n  // ...\n  return nil\n}\n```\n\nIn Go, by default, the Workflow Type name is the same as the function name.\n\n### Parameters\n\nThe first parameter of a Go-based Workflow Definition must be of the [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context) type, as it is used by the Temporal Go SDK to pass around Workflow Execution context, and virtually all the Go SDK APIs that are callable from the Workflow require it.\nIt is acquired from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package.\n\n```go\nimport (\n   \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param string) error {\n // ...\n}\n```\n\nThe `workflow.Context` entity operates similarly to the standard `context.Context` entity provided by Go.\nThe only difference between `workflow.Context` and `context.Context` is that the `Done()` function, provided by `workflow.Context`, returns `workflow.Channel` instead of the standard Go `chan`.\n\nThe second parameter, `string`, is a custom parameter that is passed to the Workflow when it is invoked.\nA Workflow Definition may support multiple custom parameters, or none.\nThese parameters can be regular type variables or safe pointers.\nHowever, the best practice is to pass a single parameter that is of a `struct` type, so there can be some backward compatibility if new parameters are added.\n\n```go\ntype YourWorkflowParam struct {\n WorkflowParamFieldOne string\n WorkflowParamFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n // ...\n}\n```\n\nAll Workflow Definition parameters must be serializable, regardless of whether pointers or regular type values are used.\nParameters can’t be channels, functions, variadic, or unsafe pointers.\n\n### Return values\n\nA Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.\nAgain, the best practice here is to use a `struct` type to hold all custom values.\n\n```go\ntype YourWorkflowResponse struct{\n WorkflowResultFieldOne string\n WorkflowResultFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n if err != nil {\n   return \"\", err\n }\n responseVar := YourWorkflowResponse {\n   FieldOne: \"super\",\n   FieldTwo: 1,\n }\n return responseVar, nil\n}\n```\n\nA Workflow Definition written in Go can return both a custom value and an error.\nHowever, it's not possible to receive both a custom value and an error in the calling process, as is normal in Go.\nThe caller will receive either one or the other.\nReturning a non-nil `error` from a Workflow indicates that an error was encountered during its execution and the Workflow Execution should be terminated, and any custom return values will be ignored by the system.\n\n### Logic requirements\n\nIn Go, Workflow Definition code cannot directly do the following:\n\n- Iterate over maps using `range`, because with `range` the order of the map's iteration is randomized.\n  Instead you can collect the keys of the map, sort them, and then iterate over the sorted keys to access the map.\n  This technique provides deterministic results.\n  You can also use a Side Effect or an Activity to process the map instead.\n- Call an external API, conduct a file I/O operation, talk to another service, etc. (Use an Activity for these.)\n\nThe Temporal Go SDK has APIs to handle equivalent Go constructs:\n\n- `workflow.Now()` This is a replacement for `time.Now()`.\n- `workflow.Sleep()` This is a replacement for `time.Sleep()`.\n- `workflow.GetLogger()` This ensures that the provided logger does not duplicate logs during a replay.\n- `workflow.Go()` This is a replacement for the `go` statement.\n- `workflow.Channel` This is a replacement for the native `chan` type.\n  Temporal provides support for both buffered and unbuffered channels.\n- `workflow.Selector` This is a replacement for the `select` statement.\n  Learn more on the [Go SDK Selectors](/go/selectors) page.\n- `workflow.Context` This is a replacement for `context.Context`.\n  See [Tracing](/go/tracing) for more information about context propagation.\n","is_empty":false},{"file_name":"developing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/developing-workflows.md","id":"go/developing-workflows","title":"How to develop a basic Workflow","description":"Workflows are the fundamental unit of a Temporal Application, and it all starts with the development of a Workflow Definition.","label":"Develop Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/concepts/what-is-a-workflow-definition).\n","is_empty":false},{"file_name":"enable-worker-sessions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/enable-worker-sessions.md","id":"go/enable-worker-sessions","title":"How to enable Worker Sessions","description":"Enable the Worker to use Sessions.","label":"Enable Sessions","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEnable the Worker to use Sessions.\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/environment-variables.md","id":"go/environment-variables","title":"How to read and pass environment variables","description":"Environment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.","label":"Environment variables","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEnvironment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.\nThey can't be used normally with Workflow code, as that would be [non-deterministic](workflows#intrinsic-non-deterministic-logic) (if the environment variables changed between Workflow replays, the code that used them would behave differently).\n\nMost of the time, you can provide environment variables in your Activity function; however, if you need them in your Workflow functions, you can use the following options:\n\n- Provide environment variables as arguments when starting the Workflow.\n- Call a Local Activity at the beginning of the Workflow that returns environment variables.\n\nIn either case, the environment variables will appear in Event History, so you may want to use an [encryption Data Converter](/concepts/what-is-a-data-converter#encryption).\n","is_empty":false},{"file_name":"error-handling.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/error-handling.md","id":"go/error-handling","title":"Error Handling in Go","description":"Handling Activity or Workflow errors in Go.","label":"Error Handling in Go","tags":["developer-guide","sdk","go"],"ssdi":[],"markdown_content":"\nAn Activity, or a Child Workflow, might fail, and you could handle errors differently based on the different\nerror cases.\n\nIf the Activity returns an error as `errors.New()` or `fmt.Errorf()`, that error is converted into `*temporal.ApplicationError`.\n\nIf the Activity returns an error as `temporal.NewNonRetryableApplicationError(\"error message\", details)`, that error is returned as `*temporal.ApplicationError`.\n\nThere are other types of errors such as `*temporal.TimeoutError`, `*temporal.CanceledError` and\n`*temporal.PanicError`.\nFollowing is an example of what your error code might look like:\n\nHere's an example of handling Activity errors within Workflow code that differentiates between different error types.\n\n```go\nerr := workflow.ExecuteActivity(ctx, YourActivity, ...).Get(ctx, nil)\nif err != nil {\n\tvar applicationErr *ApplicationError\n\tif errors.As(err, &applicationErr) {\n\t\t// retrieve error message\n\t\tfmt.Println(applicationError.Error())\n\n\t\t// handle Activity errors (created via NewApplicationError() API)\n\t\tvar detailMsg string // assuming Activity return error by NewApplicationError(\"message\", true, \"string details\")\n\t\tapplicationErr.Details(&detailMsg) // extract strong typed details\n\n\t\t// handle Activity errors (errors created other than using NewApplicationError() API)\n\t\tswitch applicationErr.Type() {\n\t\tcase \"CustomErrTypeA\":\n\t\t\t// handle CustomErrTypeA\n\t\tcase CustomErrTypeB:\n\t\t\t// handle CustomErrTypeB\n\t\tdefault:\n\t\t\t// newer version of Activity could return new errors that Workflow was not aware of.\n\t\t}\n\t}\n\n\tvar canceledErr *CanceledError\n\tif errors.As(err, &canceledErr) {\n\t\t// handle cancellation\n\t}\n\n\tvar timeoutErr *TimeoutError\n\tif errors.As(err, &timeoutErr) {\n\t\t// handle timeout, could check timeout type by timeoutErr.TimeoutType()\n        switch err.TimeoutType() {\n        case commonpb.ScheduleToStart:\n                // Handle ScheduleToStart timeout.\n        case commonpb.StartToClose:\n                // Handle StartToClose timeout.\n        case commonpb.Heartbeat:\n                // Handle heartbeat timeout.\n        default:\n        }\n\t}\n\n\tvar panicErr *PanicError\n\tif errors.As(err, &panicErr) {\n\t\t// handle panic, message and stack trace are available by panicErr.Error() and panicErr.StackTrace()\n\t}\n}\n```\n","is_empty":false},{"file_name":"features.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/features.md","id":"go/features","title":"How to use Workflow and Activity features","description":"The Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.","label":"Features","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\n\nIn this section you can find the following:\n\n- [How to develop Signals](#signals)\n- [How to develop Queries](#queries)\n- [How to start a Child Workflow Execution](#child-workflows)\n- [How to start a Temporal Cron Job](#temporal-cron-jobs)\n- [How to use Continue-As-New](#continue-as-new)\n- [How to set Workflow timeouts & retries](#workflow-timeouts)\n- [How to set Activity timeouts & retries](#activity-timeouts)\n- [How to Heartbeat an Activity](#activity-heartbeats)\n- [How to Asynchronously complete an Activity](#asynchronous-activity-completion)\n- [How to register Namespaces](#namespaces)\n- [How to use custom payload conversion](#custom-payload-conversion)\n","is_empty":false},{"file_name":"foundations.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/foundations.md","id":"go/foundations","title":"How to build a basic Temporal Application","description":"The Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application—that is, all the relevant steps to start a Workflow Execution that executes an Activity.","label":"Foundations","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a [Temporal Application](/concepts/what-is-a-temporal-application)—that is, all the relevant steps to start a [Workflow Execution](#develop-workflows) that executes an [Activity](#develop-activities).\n\nIn this section you can find the following:\n\n- [Run a development Cluster](/clusters/how-to-install-temporal-cli)\n- [Install your SDK](/go/add-sdk)\n- [Connect to a dev Cluster](/go/connect-to-a-dev-cluster)\n- [Connect to Temporal Cloud](/go/connect-to-temporal-cloud)\n- [Develop a Workflow](/go/developing-workflows)\n- [Develop an Activity](/go/how-to-develop-an-activity-definition-in-go)\n- [Start an Activity Execution](/go/spawning-activities)\n- [Run a dev Worker](/go/how-to-develop-a-worker-in-go)\n- [Run a Temporal Cloud Worker](/go/run-a-temporal-cloud-worker)\n- [Start a Workflow Execution](/go/spawning-workflows)\n","is_empty":false},{"file_name":"get-activity-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/get-activity-results.md","id":"go/get-activity-results","title":"How to get the results of an Activity Execution","description":"The call to spawn an Activity Execution generates the ScheduleActivityTask Command and provides the Workflow with an Awaitable.","label":"Get Activity results","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe call to spawn an [Activity Execution](/concepts/what-is-an-activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.\n","is_empty":false},{"file_name":"get-the-result-of-a-workflow-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/get-the-result-of-a-workflow-execution.md","id":"go/get-the-result-of-a-workflow-execution","title":"How to get the result of a Workflow Execution in Go","description":"Use the Future returned by `ExecuteWorkflow` API call to retrieve the result.","label":"Workflow Execution result","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nThe `ExecuteWorkflow` call returns an instance of [`WorkflowRun`](https://pkg.go.dev/go.temporal.io/sdk/client#WorkflowRun), which is the `workflowRun` variable in the following line.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, app.YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n // ...\n}\n```\n\nThe instance of `WorkflowRun` has the following three methods:\n\n- `GetWorkflowID()`: Returns the Workflow Id of the invoked Workflow Execution.\n- `GetRunID()`: Always returns the Run Id of the initial Run (See [Continue As New](#)) in the series of Runs that make up the full Workflow Execution.\n- `Get`: Takes a pointer as a parameter and populates the associated variable with the Workflow Execution result.\n\nTo wait on the result of Workflow Execution in the same process that invoked it, call `Get()` on the instance of `WorkflowRun` that is returned by the `ExecuteWorkflow()` call.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n}\n```\n\nHowever, the result of a Workflow Execution can be obtained from a completely different process.\nAll that is needed is the [Workflow Id](#).\n(A [Run Id](#) is optional if more than one closed Workflow Execution has the same Workflow Id.)\nThe result of the Workflow Execution is available for as long as the Workflow Execution Event History remains in the system.\n\n<!-- TODO (See [How long do Workflow Execution Histories persist](#)). -->\n\nCall the `GetWorkflow()` method on an instance of the Go SDK Client and pass it the Workflow Id used to spawn the Workflow Execution.\nThen call the `Get()` method on the instance of `WorkflowRun` that is returned, passing it a pointer to populate the result.\n\n```go\n // ...\n workflowID := \"Your-Custom-Workflow-Id\"\n workflowRun := c.GetWorkflow(context.Background, workflowID)\n\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n```\n\n**Get last completion result**\n\nIn the case of a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job), you might need to get the result of the previous Workflow Run and use it in the current Workflow Run.\n\nTo do this, use the [`HasLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#HasLastCompletionResult) and [`GetLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLastCompletionResult) APIs, available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package, directly in your Workflow code.\n\n```go\ntype CronResult struct {\n Count int\n}\n\nfunc YourCronWorkflowDefinition(ctx workflow.Context) (CronResult, error) {\n count := 1\n\n if workflow.HasLastCompletionResult(ctx) {\n   var lastResult CronResult\n   if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {\n     count = count + lastResult.Count\n   }\n }\n\n newResult := CronResult {\n   Count: count,\n }\n return newResult, nil\n}\n```\n\nThis will work even if one of the cron Workflow Runs fails.\nThe next Workflow Run gets the result of the last successfully Completed Workflow Run.\n","is_empty":false},{"file_name":"get-the-result-of-an-activity-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/get-the-result-of-an-activity-execution.md","id":"go/get-the-result-of-an-activity-execution","title":"How to get the result of an Activity Execution in Go","description":"Use the Future returned from the `ExecuteActivity` API call to retrieve the result.","label":"Activity Execution result","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nThe `ExecuteActivity` API call returns an instance of [`workflow.Future`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Futures) which has the following two methods:\n\n- `Get()`: Takes an instance of the `workflow.Context`, that was passed to the Activity Execution, and a pointer as parameters.\n  The variable associated with the pointer is populated with the Activity Execution result.\n  This call blocks until the results are available.\n- `IsReady()`: Returns `true` when the result of the Activity Execution is ready.\n\nCall the `Get()` method on the instance of `workflow.Future` to get the result of the Activity Execution.\nThe type of the result parameter must match the type of the return value declared by the Activity function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n var yourActivityResult YourActivityResult\n if err := future.Get(ctx, &yourActivityResult); err != nil {\n   // ...\n }\n // ...\n}\n```\n\nUse the `IsReady()` method first to make sure the `Get()` call doesn't cause the Workflow Execution to wait on the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n // ...\n if(future.IsReady()) {\n   var yourActivityResult YourActivityResult\n   if err := future.Get(ctx, &yourActivityResult); err != nil {\n     // ...\n   }\n }\n // ...\n}\n```\n\nIt is idiomatic to invoke multiple Activity Executions from within a Workflow.\nTherefore, it is also idiomatic to either block on the results of the Activity Executions or continue on to execute additional logic, checking for the Activity Execution results at a later time.\n","is_empty":false},{"file_name":"get-workflow-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/get-workflow-results.md","id":"go/get-workflow-results","title":"How to get the results of a Workflow Execution","description":"If the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.","label":"Get Workflow results","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.\n\nThe Workflow Id, Run Id, and Namespace may be used to uniquely identify a Workflow Execution in the system and get its result.\n\nIt's possible to both block progress on the result (synchronous execution) or get the result at some other point in time (asynchronous execution).\n\nIn the Temporal Platform, it's also acceptable to use Queries as the preferred method for accessing the state and results of Workflow Executions.\n","is_empty":false},{"file_name":"handle-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/handle-query.md","id":"go/handle-query","title":"How to handle a Query","description":"Queries are handled by your Workflow.","label":"Handle Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are handled by your Workflow.\n\nDon’t include any logic that causes [Command](/concepts/what-is-a-command) generation within a Query handler (such as executing Activities).\nIncluding such logic causes unexpected behavior.\n","is_empty":false},{"file_name":"handle-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/handle-signal.md","id":"go/handle-signal","title":"How to handle a Signal","description":"Workflows listen for Signals by the Signal's name.","label":"Handle Signal","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows listen for Signals by the Signal's name.\n","is_empty":false},{"file_name":"heartbeat-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/heartbeat-an-activity.md","id":"go/heartbeat-an-activity","title":"How to Heartbeat an Activity in Go","description":"Use, the `RecordHeartbeat` API to report that the execution is alive and progressing.","label":"Activity Heartbeats","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nTo [Heartbeat](/concepts/what-is-an-activity-heartbeat) in an Activity in Go, use the `RecordHeartbeat` API.\n\n```go\nimport (\n    // ...\n    \"go.temporal.io/sdk/workflow\"\n    // ...\n)\n\nfunc YourActivityDefinition(ctx, YourActivityDefinitionParam) (YourActivityDefinitionResult, error) {\n    // ...\n    activity.RecordHeartbeat(ctx, details)\n    // ...\n}\n```\n\nWhen an Activity Task Execution times out due to a missed Heartbeat, the last value of the `details` variable above is returned to the calling Workflow in the `details` field of `TimeoutError` with `TimeoutType` set to `Heartbeat`.\n\nYou can also Heartbeat an Activity from an external source:\n\n```go\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n// Record heartbeat.\nerr := temporalClient.RecordActivityHeartbeat(ctx, taskToken, details)\n```\n\nThe parameters of the `RecordActivityHeartbeat` function are:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `details`: The serializable payload containing progress information.\n\nIf an Activity Execution Heartbeats its progress before it failed, the retry attempt will have access to the progress information, so that the Activity Execution can resume from the failed state.\nHere's an example of how this can be implemented:\n\n```go\nfunc SampleActivity(ctx context.Context, inputArg InputParams) error {\n    startIdx := inputArg.StartIndex\n    if activity.HasHeartbeatDetails(ctx) {\n        // Recover from finished progress.\n        var finishedIndex int\n        if err := activity.GetHeartbeatDetails(ctx, &finishedIndex); err == nil {\n            startIdx = finishedIndex + 1 // Start from next one.\n        }\n    }\n\n    // Normal Activity logic...\n    for i:=startIdx; i<inputArg.EndIdx; i++ {\n        // Code for processing item i goes here...\n        activity.RecordHeartbeat(ctx, i) // Report progress.\n    }\n}\n```\n","is_empty":false},{"file_name":"heartbeat-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/heartbeat-timeout.md","id":"go/heartbeat-timeout","title":"How to set a Heartbeat Timeout","description":"A Heartbeat Timeout works in conjunction with Activity Heartbeats.","label":"Heartbeat Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) works in conjunction with [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go.md","id":"go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go","title":"How to add custom Search Attributes to Workflow Executions at start time in Go","description":"Add custom Search Attributes to Workflow Executions at start time","label":"Add custom Search Attributes to Workflow Executions at start time","tags":["developer-guide","go","client"],"ssdi":[],"markdown_content":"\nProvide key-value pairs in [`StartWorkflowOptions.SearchAttributes`](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions).\n\nSearch Attributes are represented as `map[string]interface{}`.\nThe values in the map must correspond to the [Search Attribute's value type](/visibility#types):\n\n- Bool = `bool`\n- Datetime = `time.Time`\n- Double = `float64`\n- Int = `int64`\n- Keyword = `string`\n- Text = `string`\n\nIf you had custom Search Attributes `CustomerId` of type Keyword and `MiscData` of type Text, you would provide `string` values:\n\n```go\nfunc (c *Client) CallYourWorkflow(ctx context.Context, workflowID string, payload map[string]interface{}) error {\n    // ...\n    searchAttributes := map[string]interface{}{\n        \"CustomerId\": payload[\"customer\"],\n        \"MiscData\": payload[\"miscData\"]\n    }\n    options := client.StartWorkflowOptions{\n        SearchAttributes:   searchAttributes\n        // ...\n    }\n    we, err := c.Client.ExecuteWorkflow(ctx, options, app.YourWorkflow, payload)\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-asynchronously-complete-an-activity-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-asynchronously-complete-an-activity-in-go.md","id":"go/how-to-asynchronously-complete-an-activity-in-go","title":"How to asynchronously complete an Activity in Go","description":"Provide the external system with a Task Token to complete the Activity Execution.","label":"Asynchronous Activity Completion","tags":["how-to","go"],"ssdi":[],"markdown_content":"\n1. Provide the external system with a Task Token to complete the Activity Execution.\n   To do this, use the `GetInfo()` API from the `go.temporal.io/sdk/activity` package.\n\n```go\n// Retrieve the Activity information needed to asynchronously complete the Activity.\nactivityInfo := activity.GetInfo(ctx)\ntaskToken := activityInfo.TaskToken\n// Send the taskToken to the external service that will complete the Activity.\n```\n\n2. Return an `activity.ErrResultPending` error to indicate that the Activity is completing asynchronously.\n\n```go\nreturn \"\", activity.ErrResultPending\n```\n\n3. Use the Temporal Client to complete the Activity using the Task Token.\n\n```go\n// Instantiate a Temporal service client.\n// The same client can be used to complete or fail any number of Activities.\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n\n// Complete the Activity.\ntemporalClient.CompleteActivity(context.Background(), taskToken, result, nil)\n```\n\nThe following are the parameters of the `CompleteActivity` function:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `result`: The return value to record for the Activity. The type of this value must match the type\n  of the return value declared by the Activity function.\n- `err`: The error code to return if the Activity terminates with an error.\n\nIf `error` is not null, the value of the `result` field is ignored.\n\nTo fail the Activity, you would do the following:\n\n```go\n// Fail the Activity.\nclient.CompleteActivity(context.Background(), taskToken, nil, err)\n```\n","is_empty":false},{"file_name":"how-to-backfill-a-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-backfill-a-schedule-in-go.md","id":"go/how-to-backfill-a-schedule-in-go","title":"How to backfill a Schedule in Go","description":"Backfill a Schedule to execute a Workflow at a later time.","label":"Backfill Schedule","ssdi":[],"markdown_content":"\nBackfilling a [Schedule](/concepts/what-is-a-schedule) executes Actions ahead of the Schedule's specified time range.\nThis is useful for executing a missed or delayed [Action](/concepts/what-is-a-schedule#action), or for testing the [Workflow](/concepts/what-is-a-workflow) ahead of time.\n\nTo backfill a Schedule in Go, use `Backfill()` on [`ScheduleHandle`](https://pkg.go.dev/go.temporal.io/sdk/internal#ScheduleClient).\nSpecify the start and end times to execute the Workflow, along with the [Overlap Policy](/concepts/what-is-a-schedule#overlap-policy).\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/add-go-schedule-sample/schedule/backfill/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\t\tBackfill: []client.ScheduleBackfill{\n\t\t\t{\n\t\t\t\tStart: now.Add(-4 * time.Minute),\n\t\t\t\tEnd: now.Add(-2 * time.Minute),\n\t\t\t\tOverlap: enums.SCHEDULE_OVERLAP_POLICY_ALLOW_ALL,\n\t\t\t},\n\t\t\t{\n\t\t\t\tStart: now.Add(-2 * time.Minute),\n\t\t\t\tEnd: now,\n\t\t\t\tOverlap: enums.SCHEDULE_OVERLAP_POLICY_ALLOW_ALL,\n\t\t\t},\n\t\t},\n\t})\n\t\t\n// ...\n```\n","is_empty":false},{"file_name":"how-to-configure-max-concurrent-sessions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-configure-max-concurrent-sessions.md","id":"go/how-to-configure-max-concurrent-sessions","title":"How to configure the maximum concurrent Sessions on the Worker","description":"Set MaxConcurrentSessionExecutionSize in the Worker options.","label":"Max concurrent Sessions","ssdi":[],"markdown_content":"\nTo limit the number of concurrent Sessions running on a Worker, set the `MaxConcurrentSessionExecutionSize` field of `worker.Options` to the desired value.\nBy default, this field is set to a very large value, so there's no need to manually set it if no limitation is needed.\n\nIf a Worker hits this limitation, it won't accept any new `CreateSession()` requests until one of the existing sessions is completed.\nIf the session can't be created within `CreationTimeout`, `CreateSession()` returns an error .\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/sessions/worker/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\tworkerOptions := worker.Options{\n// ...\n\t\t// This configures the maximum allowed concurrent sessions.\n\t\t// Customize this value only if you need to.\n\t\tMaxConcurrentSessionExecutionSize: 1000,\n// ...\n}\n// ...\n```\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-configure-tracing-in-go.md","id":"go/how-to-configure-tracing-in-go","title":"How to configure tracing in Go","description":"Configure tracing","label":"Configure tracing","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nThe Go SDK provides support for distributed tracing through [OpenTracing](https://opentracing.io/).\nTracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.\n\nTracing can be configured by providing an [opentracing.Tracer](https://pkg.go.dev/github.com/opentracing/opentracing-go#Tracer)\nimplementation in [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions) during client instantiation.\n\nFor more details on how to configure and leverage tracing, see the [OpenTracing documentation](https://opentracing.io/docs/getting-started/).\n\nThe OpenTracing support has been validated using [Jaeger](https://www.jaegertracing.io/), but other implementations mentioned [here](https://opentracing.io/docs/supported-tracers/) should also work.\n\nTracing functionality utilizes generic context propagation provided by the Client.\n","is_empty":false},{"file_name":"how-to-connect-to-a-cluster-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-connect-to-a-cluster-in-go.md","id":"go/how-to-connect-to-a-cluster-in-go","title":"How to connect to a Temporal Cluster in Go","description":"Connect a Temporal Client to a Cluster in the Go SDK.","label":"Connect a Temporal Client","tags":["developer-guide","sdk","go"],"ssdi":[],"markdown_content":"\nUse the [`Dial()`](https://pkg.go.dev/go.temporal.io/sdk/client#Dial) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to create a new [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nIf you don't provide [`HostPort`](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions), the Client defaults the address and port number to `127.0.0.1:7233`.\n\nSet a custom Namespace name in the Namespace field on an instance of the Client Options.\n\nUse the [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#ConnectionOptions) API to connect a Client with mTLS.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\nfunc main() {\n    cert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n    if err != nil {\n        return err\n    }\n    client, err := client.Dial(client.Options{\n        HostPort:  \"your-custom-namespace.tmprl.cloud:7233\",\n        Namespace: \"your-custom-namespace\",\n        ConnectionOptions: client.ConnectionOptions{\n            TLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n        },\n    }\n    defer temporalClient.Close()\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-connect-to-a-development-cluster-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-connect-to-a-development-cluster-in-go.md","id":"go/how-to-connect-to-a-development-cluster-in-go","title":"How to connect to a Temporal dev Cluster in Go","description":"Use the Dial() method on the Temporal Client and omit setting any client options. If there is a local dev Cluster running, the Client will connect to it.","label":"Connect to a dev Cluster","ssdi":[],"markdown_content":"\nUse the [`Dial()`](https://pkg.go.dev/go.temporal.io/sdk/client#Dial) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to create a [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nIf you don't provide [`HostPort`](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions), the Client defaults the address and port number to `127.0.0.1:7233`, which is the port of the development Cluster.\n\nIf you don't set a custom Namespace name in the Namespace field, the client connects to the default Namespace.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/gateway/main_dacx.go\">View source code</a>\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"documentation-samples-go/yourapp\"\n\n\t\"go.temporal.io/sdk/client\"\n)\n\n\nfunc main() {\n\t// Create a Temporal Client to communicate with the Temporal Cluster.\n\t// A Temporal Client is a heavyweight object that should be created just once per process.\n\ttemporalClient, err := client.Dial(client.Options{\n\t\tHostPort: client.DefaultHostPort,\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create Temporal Client\", err)\n\t}\n\tdefer temporalClient.Close()\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-connect-to-temporal-cloud-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-connect-to-temporal-cloud-in-go.md","id":"go/how-to-connect-to-temporal-cloud-in-go","title":"How to connect to Temporal Cloud","description":"Use a certificate key pair and your Temporal Cloud Namespace to connect to Temporal Cloud.","label":"Connect to Temporal Cloud","ssdi":[],"markdown_content":"\nTo connect to and run Workflows through Temporal Cloud, you need the following:\n\n- A compatible mTLS CA certificate and mTLS private key that has been added to your Namespace.\n  See [certificate requirements](/cloud-context/certificates-requirements).\n- Your [Temporal Cloud Namespace Id](/concepts/what-is-a-cloud-namespace-id), which includes your [Temporal Cloud Namespace Name](/concepts/what-is-a-cloud-namespace-name) and the unique five- or six-digit [Temporal Cloud Account Id](/concepts/what-is-a-cloud-account-id) that is appended to it.\n  This information can be found in the URL of your Namespace; for example, `https://cloud.temporal.io/namespaces/yournamespace.a2fx6/`.\n  Remember that the Namespace Id must include the Account Id: `yournamespace.a2fx6`.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/cloud/client/main_dacx.go\">View source code</a>\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"log\"\n\n\t\"documentation-samples-go/cloud\"\n\n\t\"go.temporal.io/sdk/client\"\n)\n\n\nfunc main() {\n\t// Get the key and cert from your env or local machine\n\tclientKeyPath := \"./secrets/yourkey.key\"\n\tclientCertPath := \"./secrets/yourcert.pem\"\n\t// Specify the host and port of your Temporal Cloud Namespace\n\t// Host and port format: namespace.unique_id.tmprl.cloud:port\n\thostPort := \"<yournamespace>.<id>.tmprl.cloud:7233\"\n\tnamespace := \"<yournamespace>.<id>\"\n\t// Use the crypto/tls package to create a cert object\n\tcert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to load cert and key pair.\", err)\n\t}\n\t// Add the cert to the tls certificates in the ConnectionOptions of the Client\n\ttemporalClient, err := client.Dial(client.Options{\n\t\tHostPort:  hostPort,\n\t\tNamespace: namespace,\n\t\tConnectionOptions: client.ConnectionOptions{\n\t\t\tTLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to connect to Temporal Cloud.\", err)\n\t}\n\tdefer temporalClient.Close()\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-continue-as-new-in-go.md","id":"go/how-to-continue-as-new-in-go","title":"How to Continue-As-New-in-Go","description":"To cause a Workflow Execution to Continue-As-New, the Workflow function should return the result of the `NewContinueAsNewError()` API available from the `go.temporal.io/sdk/workflow` package.","label":"Continue-As-New","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nTo cause a Workflow Execution to [Continue-As-New](/concepts/what-is-continue-as-new), the Workflow API should return the result of the [`NewContinueAsNewError()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#NewContinueAsNewError) function available from the `go.temporal.io/sdk/workflow` package.\n\n```go\nfunc SimpleWorkflow(ctx workflow.Context, value string) error {\n    ...\n    return workflow.NewContinueAsNewError(ctx, SimpleWorkflow, value)\n}\n```\n\nTo check whether a Workflow Execution was spawned as a result of Continue-As-New, you can check if `workflow.GetInfo(ctx).ContinuedExecutionRunID` is not empty (i.e. `\"\"`).\n\n**Notes**\n\n- To prevent Signal loss, be sure to perform an asynchronous drain on the Signal channel.\n  Failure to do so can result in buffered Signals being ignored and lost.\n- Make sure that the previous Workflow and the Continue-As-New Workflow are referenced by the same alias.\n  Failure to do so can cause the Workflow to Continue-As-New on an entirely different Workflow.\n","is_empty":false},{"file_name":"how-to-create-a-custom-data-converter-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-create-a-custom-data-converter-in-go.md","id":"go/how-to-create-a-custom-data-converter-in-go","title":"How to create a custom Data Converter in Go","description":"Wrap your custom functionality around the default Data Converter.","label":"Custom Data Converter","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nWrap your custom functionality around the default [Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter).\n","is_empty":false},{"file_name":"how-to-create-a-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-create-a-schedule-in-go.md","id":"go/how-to-create-a-schedule-in-go","title":"How to create a Schedule in Go","description":"Create a Schedule for a Workflow in Go.","label":"Create Schedule","ssdi":[],"markdown_content":"\n[Schedules](/concepts/what-is-a-schedule) are initiated with the `create` call.\nThe user generates a unique Schedule ID for each new Schedule.\n\nTo create a Schedule in Go, use `Create()` on the [Client](/concepts/what-is-a-temporal-client).\nSchedules must be initialized with a Schedule ID, [Spec](/concepts/what-is-a-schedule#spec), and [Action](/concepts/what-is-a-schedule#action) in `client.ScheduleOptions{}`.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/add-go-schedule-sample/schedule/create/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n    // Create Schedule and Workflow IDs\n\tscheduleID := \"schedule_\" + uuid.New()\n\tworkflowID := \"schedule_workflow_\" + uuid.New()\n\t// Create the schedule.\n\tscheduleHandle, err := temporalClient.ScheduleClient().Create(ctx, client.ScheduleOptions{\n\t\tID:   scheduleID,\n\t\tSpec: client.ScheduleSpec{},\n\t\tAction: &client.ScheduleWorkflowAction{\n\t\t\tID:        workflowID,\n\t\t\tWorkflow:  schedule.ScheduleWorkflow,\n\t\t\tTaskQueue: \"schedule\",\n\t\t},\n\t})\n// ...\n```\n","is_empty":false},{"file_name":"how-to-create-a-session-from-the-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-create-a-session-from-the-workflow-in-go.md","id":"go/how-to-create-a-session-from-the-workflow-in-go","title":"How to create a Worker Session in Go","description":"Enable Sessions on the Worker via the Worker Options and then use the `CreateSession` API to create a Context object that can be passed to the calls to spawn Activity Executions.","label":"Worker Session","ssdi":[],"markdown_content":"\nUse the [`CreateSession`](https://pkg.go.dev/go.temporal.io/sdk/workflow#CreateSession) API to create a Context object that can be passed to calls to spawn Activity Executions.\n\nPass an instance of `workflow.Context` and [`SessionOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SessionOptions) to the `CreateSession` API call and get a Session Context that contains metadata information of the Session.\n\nUse the Session Context to spawn all Activity Executions that should belong to the Session.\nAll associated Activity Tasks are then processed by the same Worker Entity.\nWhen the `CreateSession` API is called, the Task Queue name that is specified in `ActivityOptions` (or in `StartWorkflowOptions` if the Task Queue name is not specified in `ActivityOptions`) is used, and a Session is created with one of the Workers polling that Task Queue.\n\nThe Session Context is cancelled if the Worker executing this Session dies or `CompleteSession()` is called.\nWhen using the returned Session Context to spawn Activity Executions, a `workflow.ErrSessionFailed` error is returned if the Session framework detects that the Worker executing this Session has died.\nThe failure of Activity Executions won't affect the state of the Session, so you still need to handle the errors returned from your Activities and call `CompleteSession()` if necessary.\n\nIf the context passed in already contains an open Session, `CreateSession()` returns an error.\nIf all the Workers are currently busy and unable to handle a new Session, the framework keeps retrying until the `CreationTimeout` period you specified in `SessionOptions` has passed before returning an error.\n(For more details, check the \"Concurrent Session Limitation\" section.)\n\n`CompleteSession()` releases the resources reserved on the Worker, so it's important to call it as soon as you no longer need the Session.\nIt cancels the session context and therefore all the Activity Executions using that Session Context.\nIt is safe to call `CompleteSession()` on a failed Session, meaning that you can call it from a `defer` function after the Session is successfully created.\n\nIf the Worker goes down between Activities, any scheduled Activities meant for the Session Worker are canceled.\nIf not, you get a `workflow.ErrSessionFailed` error when the next call of `workflow.ExecuteActivity()` is made from that Workflow.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/sessions/workflow_dacx.go\">View source code</a>\n\n```go\npackage sessions\n\nimport (\n\t\"time\"\n\n\t\"go.temporal.io/sdk/workflow\"\n)\n\n// ...\n// SomeFileProcessingWorkflow is a Workflow Definition.\nfunc SomeFileProcessingWorkflow(ctx workflow.Context, param FileProcessingWFParam) error {\n\tactivityOptions := workflow.ActivityOptions{\n\t\tStartToCloseTimeout: time.Minute,\n\t}\n\tctx = workflow.WithActivityOptions(ctx, activityOptions)\n// ...\n\tsessionOptions := &workflow.SessionOptions{\n\t\tCreationTimeout:  time.Minute,\n\t\tExecutionTimeout: time.Minute,\n\t}\n\t// Create a Session with the Worker so that all Activities execute with the same Worker.\n\tsessionCtx, err := workflow.CreateSession(ctx, sessionOptions)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer workflow.CompleteSession(sessionCtx)\n// ...\n\terr = workflow.ExecuteActivity(sessionCtx, a.DownloadFile, param).Get(sessionCtx, &downloadResult)\n// ...\n\terr = workflow.ExecuteActivity(sessionCtx, a.ProcessFile, processParam).Get(sessionCtx, &processResult)\n// ...\n\terr = workflow.ExecuteActivity(sessionCtx, a.UploadFile, uploadParam).Get(sessionCtx, nil)\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-create-a-temporal-client-in-go.md","id":"go/how-to-create-a-temporal-client-in-go","title":"How to create a Temporal Client in Go","description":"Use the `NewClient()` API available in the `go.temporal.io/sdk/client` package to create a new `Client`.","label":"Temporal Client","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nUse the [`Dial()`](https://pkg.go.dev/go.temporal.io/sdk/client#Dial) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to create a new [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nIf you don't provide [`HostPort`](https://pkg.go.dev/go.temporal.io/sdk@v1.15.0/internal#ClientOptions), the Client defaults the address and port number to `127.0.0.1:7233`.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n}\n```\n\nTo connect to your Cluster, specify `HostPort` followed by your Cluster address.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{\n    HostPort: \"web.<Namespace_ID>.tmprl.cloud.\",\n  })\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-customize-activity-type-in-go.md","id":"go/how-to-customize-activity-type-in-go","title":"How to customize Activity Type in Go","description":"To customize the Workflow Type set the Name parameter with RegisterOptions when registering your Workflow with a Worker.","label":"Customize Activity Type","ssdi":[],"markdown_content":"\nTo customize the Activity Type, set the `Name` parameter with `RegisterOptions` when registering your Activity with a Worker.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/worker/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\tyourWorker := worker.New(temporalClient, \"your-custom-task-queue-name\", worker.Options{})\n// ...\n\t// Use RegisterOptions to change the name of the Activity Type for example.\n\tregisterAOptions := activity.RegisterOptions{\n\t\tName: \"JustAnotherActivity\",\n\t}\n\tyourWorker.RegisterActivityWithOptions(yourapp.YourSimpleActivityDefinition, registerAOptions)\n\t// Run the Worker\n\terr = yourWorker.Run(worker.InterruptCh())\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-customize-workflow-type-in-go.md","id":"go/how-to-customize-workflow-type-in-go","title":"How to customize Workflow Type in Go","description":"To customize the Workflow Type set the Name parameter with RegisterOptions when registering your Workflow with a Worker.","label":"Customize Workflow Type","tags":["go","workflow-type"],"ssdi":[],"markdown_content":"\nIn Go, by default, the Workflow Type name is the same as the function name.\n\nTo customize the Workflow Type, set the `Name` parameter with `RegisterOptions` when registering your Workflow with a [Worker](/go/how-to-develop-a-worker-in-go).\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/worker/main_dacx.go\">View source code</a>\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\t\"go.temporal.io/sdk/activity\"\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n\t\"go.temporal.io/sdk/workflow\"\n\n\t\"documentation-samples-go/yourapp\"\n)\n// ...\nfunc main() {\n// ...\n\tyourWorker := worker.New(temporalClient, \"your-custom-task-queue-name\", worker.Options{})\n// ...\n\t// Use RegisterOptions to set the name of the Workflow Type for example.\n\tregisterWFOptions := workflow.RegisterOptions{\n\t\tName: \"JustAnotherWorkflow\",\n\t}\n\tyourWorker.RegisterWorkflowWithOptions(yourapp.YourSimpleWorkflowDefinition, registerWFOptions)\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-define-a-query-type-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-define-a-query-type-in-go.md","id":"go/how-to-define-a-query-type-in-go","title":"How to define a Query Type in Go","description":"A Query type, also called a Query name, is a `string` value.","label":"Query type","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nIn Go, a Query type, also called a Query name, is a `string` value.\n\n```go\nqueryType := \"your_query_name\"\n```\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-define-a-signal-in-go.md","id":"go/how-to-define-a-signal-in-go","title":"How to define a Signal in Go","description":"Structs should be used to define Signals and carry data.","label":"Define Signal","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nStructs should be used to define Signals and carry data, as long as the struct is [serializable via the Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#CompositeDataConverter.ToPayload).\nThe `Receive()` method on the Data Converter decodes the data into the Struct within the Workflow.\nOnly public fields are serializable.\n\n```go\nMySignal struct {\n\tMessage string // serializable\n\tmessage string // not serializable\n}\n```\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-define-activity-parameters-in-go.md","id":"go/how-to-define-activity-parameters-in-go","title":"How to define Activity parameters in Go","description":"The only required parameter is `context.Context`, but Activities can support many custom parameters.","label":"Activity parameters","ssdi":[],"markdown_content":"\nThe first parameter of an Activity Definition is `context.Context`.\nThis parameter is optional for an Activity Definition, though it is recommended, especially if the Activity is expected to use other Go SDK APIs.\n\nAn Activity Definition can support as many other custom parameters as needed.\nHowever, all parameters must be serializable (parameters can’t be channels, functions, variadic, or unsafe pointers), and it is recommended to pass a single struct that can be updated later.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/your_activity_definition_dacx.go\">View source code</a>\n\n```go\n// YourActivityParam is the struct passed to your Activity.\n// Use a struct so that your function signature remains compatible if fields change.\ntype YourActivityParam struct {\n\tActivityParamX string\n\tActivityParamY int\n}\n// ...\nfunc (a *YourActivityObject) YourActivityDefinition(ctx context.Context, param YourActivityParam) (*YourActivityResultObject, error) {\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-define-activity-return-values-in-go.md","id":"go/how-to-define-activity-return-values-in-go","title":"How to define Activity return values in Go","description":"A Go-based Activity Definition can return either just an `error` or a `customValue, error` combination.","label":"Activity return values","ssdi":[],"markdown_content":"\nA Go-based Activity Definition can return either just an `error` or a `customValue, error` combination (same as a Workflow Definition).\nYou may wish to use a `struct` type to hold all custom values, just keep in mind they must all be serializable.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/your_activity_definition_dacx.go\">View source code</a>\n\n```go\n// YourActivityResultObject is the struct returned from your Activity.\n// Use a struct so that you can return multiple values of different types.\n// Additionally, your function signature remains compatible if the fields change.\ntype YourActivityResultObject struct {\n\tResultFieldX string\n\tResultFieldY int\n}\n// ...\nfunc (a *YourActivityObject) YourActivityDefinition(ctx context.Context, param YourActivityParam) (*YourActivityResultObject, error) {\n// ...\n\tresult := &YourActivityResultObject{\n\t\tResultFieldX: \"Success\",\n\t\tResultFieldY: 1,\n\t}\n\t// Return the results back to the Workflow Execution.\n\t// The results persist within the Event History of the Workflow Execution.\n\treturn result, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-define-an-update-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-define-an-update-in-go.md","id":"go/how-to-define-an-update-in-go","title":"How to define an Update in Go","description":"Define an Update by giving it a name to identify it.","label":"Define Update","ssdi":[],"markdown_content":"\nIn Go, you define an Update type, also known as an Update name, as a `string` value.\nYou must ensure the arguments and result are [serializable](/concepts/what-is-a-data-converter).\nWhen sending and receiving the Update, use the Update name as an identifier.\nThe name does not link to the data type(s) sent with the Update.\nEnsure that every Workflow listening to the same Update name can handle the same Update arguments.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourupdate/your_updatable_workflow_dacx.go\">View source code</a>\n\n```go\n// YourUpdateName holds a string value used to correlate Updates.\nconst YourUpdateName = \"your_update_name\"\n// ...\nfunc YourUpdatableWorkflow(ctx workflow.Context, param WFParam) (WFResult, error) {\n// ...\n\terr := workflow.SetUpdateHandler(ctx, YourUpdateName, func(ctx workflow.Context, arg YourUpdateArg) (YourUpdateResult, error) {\n// ...\n\t}\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-define-workflow-parameters-in-go.md","id":"go/how-to-define-workflow-parameters-in-go","title":"How to define Workflow parameters in Go","description":"A Go-based Workflow Definition must accept workflow.Context and may support multiple custom parameters.","label":"Workflow parameters","ssdi":[],"markdown_content":"\nThe first parameter of a Go-based Workflow Definition must be of the [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context) type.\nIt is used by the Temporal Go SDK to pass around Workflow Execution context, and virtually all the Go SDK APIs that are callable from the Workflow require it.\nIt is acquired from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package.\n\nThe `workflow.Context` entity operates similarly to the standard `context.Context` entity provided by Go.\nThe only difference between `workflow.Context` and `context.Context` is that the `Done()` function, provided by `workflow.Context`, returns `workflow.Channel` instead of the standard Go `chan`.\n\nAdditional parameters can be passed to the Workflow when it is invoked.\nA Workflow Definition may support multiple custom parameters, or none.\nThese parameters can be regular type variables or safe pointers.\nHowever, the best practice is to pass a single parameter that is of a `struct` type, so there can be some backward compatibility if new parameters are added.\n\nAll Workflow Definition parameters must be serializable and can't be channels, functions, variadic, or unsafe pointers.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/your_workflow_definition_dacx.go\">View source code</a>\n\n```go\npackage yourapp\n\nimport (\n\t\"time\"\n\n\t\"go.temporal.io/sdk/workflow\"\n)\n\n\n// YourWorkflowParam is the object passed to the Workflow.\ntype YourWorkflowParam struct {\n\tWorkflowParamX string\n\tWorkflowParamY int\n}\n// ...\n// YourWorkflowDefinition is your custom Workflow Definition.\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (*YourWorkflowResultObject, error) {\t\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-define-workflow-return-values-in-go.md","id":"go/how-to-define-workflow-return-values-in-go","title":"How to define Workflow return values in Go","description":"A Go-based Workflow Definition can return either just an error or a customValue, error combination.","label":"Workflow return values","ssdi":[],"markdown_content":"\nA Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.\nAgain, the best practice here is to use a `struct` type to hold all custom values.\nA Workflow Definition written in Go can return both a custom value and an error.\nHowever, it's not possible to receive both a custom value and an error in the calling process, as is normal in Go.\nThe caller will receive either one or the other.\nReturning a non-nil `error` from a Workflow indicates that an error was encountered during its execution and the Workflow Execution should be terminated, and any custom return values will be ignored by the system.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/your_workflow_definition_dacx.go\">View source code</a>\n\n```go\npackage yourapp\n\nimport (\n\t\"time\"\n\n\t\"go.temporal.io/sdk/workflow\"\n)\n// ...\n\n// YourWorkflowResultObject is the object returned by the Workflow.\ntype YourWorkflowResultObject struct {\n\tWFResultFieldX string\n\tWFResultFieldY int\n}\n// ...\n// YourWorkflowDefinition is your custom Workflow Definition.\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (*YourWorkflowResultObject, error) {\t\n// ...\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Make the results of the Workflow Execution available.\n\tworkflowResult := &YourWorkflowResultObject{\n\t\tWFResultFieldX: activityResult.ResultFieldX,\n\t\tWFResultFieldY: activityResult.ResultFieldY,\n\t}\n\treturn workflowResult, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-delete-a-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-delete-a-schedule-in-go.md","id":"go/how-to-delete-a-schedule-in-go","title":"How to delete a Schedule in Go","description":null,"label":"Delete Schedule","ssdi":[],"markdown_content":"\nDeleting a [Schedule](/concepts/what-is-a-schedule) erases a Schedule.\nDeletion does not affect any [Workflows](/concepts/what-is-a-workflow) started by the Schedule.\n\nTo delete a Schedule, use `Delete()` on the `ScheduleHandle`.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/add-go-schedule-sample/schedule/delete/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\tscheduleHandle.Delete(ctx)\t\n}\n// ...\n```\n","is_empty":false},{"file_name":"how-to-describe-a-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-describe-a-schedule-in-go.md","id":"go/how-to-describe-a-schedule-in-go","title":"How to describe a Schedule in Go","description":"Describe a Schedule in Go.","label":"Describe Schedule","ssdi":[],"markdown_content":"\n`Describe` retrieves information about the current [Schedule](/concepts/what-is-a-schedule) configuration.\nThis can include details about the Schedule [Spec](/concepts/what-is-a-schedule#spec) (such as Intervals or CronExpressions) and Schedule State.\n\nTo describe a Schedule, use `Describe()` on the `ScheduleHandle`.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/add-go-schedule-sample/schedule/describe/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\t// describe schedule\n\tscheduleHandle.Describe(ctx)\n}\n// ...\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-develop-a-worker-in-go.md","id":"go/how-to-develop-a-worker-in-go","title":"How to develop a Worker in Go","description":"Develop an instance of a Worker by calling worker.New(), available via the go.temporal.io/sdk/worker package.","label":"Develop Worker","ssdi":[],"markdown_content":"\nCreate an instance of [`Worker`](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) by calling [`worker.New()`](https://pkg.go.dev/go.temporal.io/sdk/worker#New), available through the `go.temporal.io/sdk/worker` package, and pass it the following parameters:\n\n1. An instance of the Temporal Go SDK `Client`.\n1. The name of the Task Queue that it will poll.\n1. An instance of `worker.Options`, which can be empty.\n\nThen, register the Workflow Types and the Activity Types that the Worker will be capable of executing.\n\nLastly, call either the `Start()` or the `Run()` method on the instance of the Worker.\nRun accepts an interrupt channel as a parameter, so that the Worker can be stopped in the terminal.\nOtherwise, the `Stop()` method must be called to stop the Worker.\n\n:::tip\n\nIf you have [`gow`](https://github.com/mitranim/gow) installed, the Worker Process automatically \"reloads\" when you update the Worker file:\n\n```bash\ngo install github.com/mitranim/gow@latest\ngow run worker/main.go # automatically reloads when file changes\n```\n\n:::\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/worker/main_dacx.go\">View source code</a>\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\t\"go.temporal.io/sdk/activity\"\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n\t\"go.temporal.io/sdk/workflow\"\n\n\t\"documentation-samples-go/yourapp\"\n)\n\n\nfunc main() {\n\t// Create a Temporal Client\n\t// A Temporal Client is a heavyweight object that should be created just once per process.\n\ttemporalClient, err := client.Dial(client.Options{})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create client\", err)\n\t}\n\tdefer temporalClient.Close()\n\t// Create a new Worker.\n\tyourWorker := worker.New(temporalClient, \"your-custom-task-queue-name\", worker.Options{})\n\t// Register your Workflow Definitions with the Worker.\n\t// Use the ReisterWorkflow or RegisterWorkflowWithOptions method for each Workflow registration.\n\tyourWorker.RegisterWorkflow(yourapp.YourWorkflowDefinition)\n// ...\n\t// Register your Activity Definitons with the Worker.\n\t// Use this technique for registering all Activities that are part of a struct and set the shared variable values.\n\tmessage := \"This could be a connection string or endpoint details\"\n\tnumber := 100\n\tactivities := &yourapp.YourActivityObject{\n\t\tMessage: &message,\n\t\tNumber: &number,\n\t}\n\t// Use the RegisterActivity or RegisterActivityWithOptions method for each Activity.\n\tyourWorker.RegisterActivity(activities)\n// ...\n\t// Run the Worker\n\terr = yourWorker.Run(worker.InterruptCh())\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to start Worker\", err)\n\t}\n}\n// ...\n```\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-develop-a-workflow-definition-in-go.md","id":"go/how-to-develop-a-workflow-definition-in-go","title":"How to develop a Workflow Definition in Go","description":"In the Temporal Go SDK programming model, a Workflow Definition is an exportable function.","label":"Workflow Definition","ssdi":[],"markdown_content":"\nIn the Temporal Go SDK programming model, a [Workflow Definition](/concepts/what-is-a-workflow-definition) is an exportable function.\nBelow is an example of a basic Workflow Definition.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/your_workflow_definition_dacx.go\">View source code</a>\n\n```go\npackage yourapp\n\nimport (\n\t\"time\"\n\n\t\"go.temporal.io/sdk/workflow\"\n)\n// ...\n\n// YourSimpleWorkflowDefintiion is the most basic Workflow Defintion.\nfunc YourSimpleWorkflowDefinition(ctx workflow.Context) error {\n\t// ...\n\treturn nil\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-develop-an-activity-definition-in-go.md","id":"go/how-to-develop-an-activity-definition-in-go","title":"How to develop an Activity Definition in Go","description":"In the Temporal Go SDK programming model, an Activity Definition is an exportable function or a `struct` method.","label":"Activity Definition","ssdi":[],"markdown_content":"\nIn the Temporal Go SDK programming model, an Activity Definition is an exportable function or a `struct` method.\nBelow is an example of both a basic Activity Definition and of an Activity defined as a Struct method.\nAn _Activity struct_ can have more than one method, with each method acting as a separate Activity Type.\nActivities written as struct methods can use shared struct variables, such as:\n\n- an application level DB pool\n- client connection to another service\n- reusable utilities\n- any other expensive resources that you only want to initialize once per process\n\nBecause this is such a common need, the rest of this guide shows Activities written as `struct` methods.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/your_activity_definition_dacx.go\">View source code</a>\n\n```go\npackage yourapp\n\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/sdk/activity\"\n)\n// ...\n\n// YourSimpleActivityDefinition is a basic Activity Definiton.\nfunc YourSimpleActivityDefinition(ctx context.Context) error {\n\treturn nil\n}\n\n// YourActivityObject is the struct that maintains shared state across Activities.\n// If the Worker crashes this Activity object loses its state.\ntype YourActivityObject struct {\n\tMessage *string\n\tNumber *int\n}\n\n// YourActivityDefinition is your custom Activity Definition.\n// An Activity Definiton is an exportable function.\nfunc (a *YourActivityObject) YourActivityDefinition(ctx context.Context, param YourActivityParam) (*YourActivityResultObject, error) {\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-emit-metrics-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-emit-metrics-in-go.md","id":"go/how-to-emit-metrics-in-go","title":"How to emit metrics in Go","description":"Emit metrics","label":"Emit metrics","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nTo emit metrics from the Temporal Client in Go, create a [metrics handler](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler) from the [Client Options](https://pkg.go.dev/go.temporal.io/sdk@v1.15.0/internal#ClientOptions) and specify a listener address to be used by Prometheus.\n\n```go\nclient.Options{\n\t\tMetricsHandler: sdktally.NewMetricsHandler(newPrometheusScope(prometheus.Configuration{\n\t\t\tListenAddress: \"0.0.0.0:9090\",\n\t\t\tTimerType:     \"histogram\",\n\t\t}\n```\n\nThe Go SDK currently supports the [Tally](https://pkg.go.dev/go.temporal.io/sdk/contrib/tally) library; however, Tally offers [extensible custom metrics reporting](https://github.com/uber-go/tally#report-your-metrics), which is exposed through the [`WithCustomMetricsReporter`](/references/server-options#withcustommetricsreporter) API.\n\nFor more information, see the [Go sample for metrics](https://github.com/temporalio/samples-go/tree/main/metrics).\n","is_empty":false},{"file_name":"how-to-enable-sessions-on-a-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-enable-sessions-on-a-worker.md","id":"go/how-to-enable-sessions-on-a-worker","title":"How to enable Sessions on a Worker","description":"Set EnableSessionWorker to true in the Worker options.","label":"Enable Sessions","ssdi":[],"markdown_content":"\nSet `EnableSessionWorker` to `true` in the Worker options.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/sessions/worker/main_dacx.go\">View source code</a>\n\n```go\n// ...\nfunc main() {\n// ...\n\t// Enable Sessions for this Worker.\n\tworkerOptions := worker.Options{\n\t\tEnableSessionWorker: true,\n// ...\n\t}\n\tw := worker.New(temporalClient, \"fileprocessing\", workerOptions)\n\tw.RegisterWorkflow(sessions.SomeFileProcessingWorkflow)\n\tw.RegisterActivity(&sessions.FileActivities{})\n\terr = w.Run(worker.InterruptCh())\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-execute-a-side-effect-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-execute-a-side-effect-in-go.md","id":"go/how-to-execute-a-side-effect-in-go","title":"How to execute a Side Effect in Go","description":"Use the SideEffect API from the `go.temporal.io/sdk/workflow` package to execute a Side Effect directly in your Workflow.","label":"Side Effect","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nUse the [`SideEffect`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SideEffect) function from the `go.temporal.io/sdk/workflow` package to execute a [Side Effect](/concepts/what-is-a-side-effect) directly in your Workflow.\n\nPass it an instance of `context.Context` and the function to execute.\n\nThe `SideEffect` API returns a Future, an instance of [`converter.EncodedValue`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SideEffect).\n\nUse the `Get` method on the Future to retrieve the result of the Side Effect.\n\n**Correct implementation**\n\nThe following example demonstrates the correct way to use `SideEffect`:\n\n```go\nencodedRandom := workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {\n return rand.Intn(100)\n})\n\nvar random int\nencodedRandom.Get(&random)\n// ...\n}\n```\n\n**Incorrect implementation**\n\nThe following example demonstrates how NOT to use `SideEffect`:\n\n```go\n// Warning: This is an incorrect example.\n// This code is non-deterministic.\nvar random int\nworkflow.SideEffect(func(ctx workflow.Context) interface{} {\n      random = rand.Intn(100)\n      return nil\n})\n// random will always be 0 in replay, so this code is non-deterministic.\n```\n\nOn replay the provided function is not executed, the random number will always be 0, and the Workflow Execution could take a different path, breaking determinism.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-get-the-result-of-a-workflow-execution-in-go.md","id":"go/how-to-get-the-result-of-a-workflow-execution-in-go","title":"How to get the result of a Workflow Execution in Go","description":"Use the Future returned by `ExecuteWorkflow` API call to retrieve the result.","label":"Workflow Execution result","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nThe `ExecuteWorkflow` call returns an instance of [`WorkflowRun`](https://pkg.go.dev/go.temporal.io/sdk/client#WorkflowRun), which is the `workflowRun` variable in the following line.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, app.YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n // ...\n}\n```\n\nThe instance of `WorkflowRun` has the following three methods:\n\n- `GetWorkflowID()`: Returns the Workflow Id of the invoked Workflow Execution.\n- `GetRunID()`: Always returns the Run Id of the initial Run (See [Continue As New](#)) in the series of Runs that make up the full Workflow Execution.\n- `Get`: Takes a pointer as a parameter and populates the associated variable with the Workflow Execution result.\n\nTo wait on the result of Workflow Execution in the same process that invoked it, call `Get()` on the instance of `WorkflowRun` that is returned by the `ExecuteWorkflow()` call.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n}\n```\n\nHowever, the result of a Workflow Execution can be obtained from a completely different process.\nAll that is needed is the [Workflow Id](#).\n(A [Run Id](#) is optional if more than one closed Workflow Execution has the same Workflow Id.)\nThe result of the Workflow Execution is available for as long as the Workflow Execution Event History remains in the system.\n\n<!-- TODO (See [How long do Workflow Execution Histories persist](#)). -->\n\nCall the `GetWorkflow()` method on an instance of the Go SDK Client and pass it the Workflow Id used to spawn the Workflow Execution.\nThen call the `Get()` method on the instance of `WorkflowRun` that is returned, passing it a pointer to populate the result.\n\n```go\n // ...\n workflowID := \"Your-Custom-Workflow-Id\"\n workflowRun := c.GetWorkflow(context.Background, workflowID)\n\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n```\n\n**Get last completion result**\n\nIn the case of a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job), you might need to get the result of the previous Workflow Run and use it in the current Workflow Run.\n\nTo do this, use the [`HasLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#HasLastCompletionResult) and [`GetLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLastCompletionResult) APIs, available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package, directly in your Workflow code.\n\n```go\ntype CronResult struct {\n Count int\n}\n\nfunc YourCronWorkflowDefinition(ctx workflow.Context) (CronResult, error) {\n count := 1\n\n if workflow.HasLastCompletionResult(ctx) {\n   var lastResult CronResult\n   if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {\n     count = count + lastResult.Count\n   }\n }\n\n newResult := CronResult {\n   Count: count,\n }\n return newResult, nil\n}\n```\n\nThis will work even if one of the cron Workflow Runs fails.\nThe next Workflow Run gets the result of the last successfully Completed Workflow Run.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-get-the-result-of-an-activity-execution-in-go.md","id":"go/how-to-get-the-result-of-an-activity-execution-in-go","title":"How to get the result of an Activity Execution in Go","description":"Use the Future returned from the `ExecuteActivity` API call to retrieve the result.","label":"Activity Execution result","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nThe `ExecuteActivity` API call returns an instance of [`workflow.Future`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Futures) which has the following two methods:\n\n- `Get()`: Takes an instance of the `workflow.Context`, that was passed to the Activity Execution, and a pointer as parameters.\n  The variable associated with the pointer is populated with the Activity Execution result.\n  This call blocks until the results are available.\n- `IsReady()`: Returns `true` when the result of the Activity Execution is ready.\n\nCall the `Get()` method on the instance of `workflow.Future` to get the result of the Activity Execution.\nThe type of the result parameter must match the type of the return value declared by the Activity function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n var yourActivityResult YourActivityResult\n if err := future.Get(ctx, &yourActivityResult); err != nil {\n   // ...\n }\n // ...\n}\n```\n\nUse the `IsReady()` method first to make sure the `Get()` call doesn't cause the Workflow Execution to wait on the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n // ...\n if(future.IsReady()) {\n   var yourActivityResult YourActivityResult\n   if err := future.Get(ctx, &yourActivityResult); err != nil {\n     // ...\n   }\n }\n // ...\n}\n```\n\nIt is idiomatic to invoke multiple Activity Executions from within a Workflow.\nTherefore, it is also idiomatic to either block on the results of the Activity Executions or continue on to execute additional logic, checking for the Activity Execution results at a later time.\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-handle-a-query-in-a-workflow-in-go.md","id":"go/how-to-handle-a-query-in-a-workflow-in-go","title":"How to handle a Query in a Workflow in Go","description":"Use the `SetQueryHandler` API to set a Query Handler that listens for a Query by name.","label":"Handling Queries","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nUse the `SetQueryHandler` API from the `go.temporal.io/sdk/workflow` package to set a Query Handler that listens for a Query by name.\n\nThe handler must be a function that returns two values:\n\n1. A serializable result\n2. An error\n\nThe handler function can receive any number of input parameters, but all input parameters must be serializable.\nThe following sample code sets up a Query Handler that handles the `current_state` Query type:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n  currentState := \"started\" // This could be any serializable struct.\n  queryType := \"current_state\"\n  err := workflow.SetQueryHandler(ctx, queryType, func() (string, error) {\n    return currentState, nil\n  })\n  if err != nil {\n    currentState = \"failed to register query handler\"\n    return err\n  }\n  // Your normal Workflow code begins here, and you update the currentState as the code makes progress.\n  currentState = \"waiting timer\"\n  err = NewTimer(ctx, time.Hour).Get(ctx, nil)\n  if err != nil {\n    currentState = \"timer failed\"\n    return err\n  }\n  currentState = \"waiting activity\"\n  ctx = WithActivityOptions(ctx, yourActivityOptions)\n  err = ExecuteActivity(ctx, YourActivity, \"your_input\").Get(ctx, nil)\n  if err != nil {\n    currentState = \"activity failed\"\n    return err\n  }\n  currentState = \"done\"\n  return nil\n}\n```\n\nFor example, suppose your query handler function takes two parameters:\n\n```go\nerr := workflow.SetQueryHandler(ctx, \"current_state\", func(prefix string, suffix string) (string, error) {\n    return prefix + currentState + suffix, nil\n})\n```\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-handle-a-signal-in-go.md","id":"go/how-to-handle-a-signal-in-go","title":"How to handle a Signal in Go","description":"Use the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.","label":"Handle Signal","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nUse the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  // ...\n  var signal MySignal\n  signalChan := workflow.GetSignalChannel(ctx, \"your-signal-name\")\n  signalChan.Receive(ctx, &signal)\n  if len(signal.Message) > 0 && signal.Message != \"SOME_VALUE\" {\n      return errors.New(\"signal\")\n  }\n  // ...\n}\n```\n\nIn the example above, the Workflow code uses `workflow.GetSignalChannel` to open a `workflow.Channel` for the Signal type (identified by the Signal name).\n\nBefore completing the Workflow or using [Continue-As-New](/go/continue-as-new), make sure to do an asynchronous drain on the Signal channel.\nOtherwise, the Signals will be lost.\n","is_empty":false},{"file_name":"how-to-handle-an-update-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-handle-an-update-in-go.md","id":"go/how-to-handle-an-update-in-go","title":"How to handle an Update in Go","description":"Use the SetUpateHandler API from the go.temporal.io/sdk/workflow package to register an Update Handler for a given name.","label":"Handle Update","ssdi":[],"markdown_content":"\nRegister an Update handler for a given name using the [SetUpdateHandler](https://pkg.go.dev/go.temporal.io/sdk/workflow#SetUpdateHandler) API from the `go.temporal.io/sdk/workflow` package.\nThe handler function can accept multiple serializable input parameters, but we recommend using only a single parameter.\nThis practice enables you to add fields in future versions while maintaining backward compatibility.\nYou can optionally include a `workflow.Context` parameter in the first position of the function.\nThe function can return either a serializable value with an error or just an error.\nThe Workflow's WorkflowPanicPolicy configuration determines how panics are handled inside the Handler function.\nWorkflowPanicPolicy is set in the Worker Options.\n\nUpdate handlers, unlike Query handlers, can change Workflow state.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourupdate/your_updatable_workflow_dacx.go\">View source code</a>\n\n```go\n// ...\nfunc YourUpdatableWorkflow(ctx workflow.Context, param WFParam) (WFResult, error) {\n\tcounter := param.StartCount\n\terr := workflow.SetUpdateHandler(ctx, YourUpdateName, func(ctx workflow.Context, arg YourUpdateArg) (YourUpdateResult, error) {\n\t\tcounter += arg.Add\n\t\tresult := YourUpdateResult{\n\t\t\tTotal: counter,\n\t\t}\n\t\treturn result, nil\n\t})\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-handle-workflow-logic-requirements-in-go.md","id":"go/how-to-handle-workflow-logic-requirements-in-go","title":"How to handle Workflow logic requirements in Go","description":"In Go, Workflow Definition code cannot directly do a few things to adhere to deterministic constraints.","label":"Workflow logic requirements","ssdi":[],"markdown_content":"\nIn Go, Workflow Definition code cannot directly do the following:\n\n- Iterate over maps using `range`, because with `range` the order of the map's iteration is randomized.\n  Instead you can collect the keys of the map, sort them, and then iterate over the sorted keys to access the map.\n  This technique provides deterministic results.\n  You can also use a Side Effect or an Activity to process the map instead.\n- Call an external API, conduct a file I/O operation, talk to another service, etc. (Use an Activity for these.)\n\nThe Temporal Go SDK has APIs to handle equivalent Go constructs:\n\n- `workflow.Now()` This is a replacement for `time.Now()`.\n- `workflow.Sleep()` This is a replacement for `time.Sleep()`.\n- `workflow.GetLogger()` This ensures that the provided logger does not duplicate logs during a replay.\n- `workflow.Go()` This is a replacement for the `go` statement.\n- `workflow.Channel` This is a replacement for the native `chan` type.\n  Temporal provides support for both buffered and unbuffered channels.\n- `workflow.Selector` This is a replacement for the `select` statement.\n  Learn more on the [Go SDK Selectors](/go/selectors) page.\n- `workflow.Context` This is a replacement for `context.Context`.\n  See [Tracing](/dev-guide/go/observability#tracing) for more information about context propagation.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/your_workflow_definition_dacx.go\">View source code</a>\n\n```go\n```\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-heartbeat-an-activity-in-go.md","id":"go/how-to-heartbeat-an-activity-in-go","title":"How to Heartbeat an Activity in Go","description":"Use, the `RecordHeartbeat` API to report that the execution is alive and progressing.","label":"Activity Heartbeats","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nTo [Heartbeat](/concepts/what-is-an-activity-heartbeat) in an Activity in Go, use the `RecordHeartbeat` API.\n\n```go\nimport (\n    // ...\n    \"go.temporal.io/sdk/workflow\"\n    // ...\n)\n\nfunc YourActivityDefinition(ctx, YourActivityDefinitionParam) (YourActivityDefinitionResult, error) {\n    // ...\n    activity.RecordHeartbeat(ctx, details)\n    // ...\n}\n```\n\nWhen an Activity Task Execution times out due to a missed Heartbeat, the last value of the `details` variable above is returned to the calling Workflow in the `details` field of `TimeoutError` with `TimeoutType` set to `Heartbeat`.\n\nYou can also Heartbeat an Activity from an external source:\n\n```go\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n// Record heartbeat.\nerr := temporalClient.RecordActivityHeartbeat(ctx, taskToken, details)\n```\n\nThe parameters of the `RecordActivityHeartbeat` function are:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `details`: The serializable payload containing progress information.\n\nIf an Activity Execution Heartbeats its progress before it failed, the retry attempt will have access to the progress information, so that the Activity Execution can resume from the failed state.\nHere's an example of how this can be implemented:\n\n```go\nfunc SampleActivity(ctx context.Context, inputArg InputParams) error {\n    startIdx := inputArg.StartIndex\n    if activity.HasHeartbeatDetails(ctx) {\n        // Recover from finished progress.\n        var finishedIndex int\n        if err := activity.GetHeartbeatDetails(ctx, &finishedIndex); err == nil {\n            startIdx = finishedIndex + 1 // Start from next one.\n        }\n    }\n\n    // Normal Activity logic...\n    for i:=startIdx; i<inputArg.EndIdx; i++ {\n        // Code for processing item i goes here...\n        activity.RecordHeartbeat(ctx, i) // Report progress.\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-list-a-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-list-a-schedule-in-go.md","id":"go/how-to-list-a-schedule-in-go","title":"How to list a Schedule in Go","description":"List all Schedules in a Namespace in Go.","label":"List Schedules","ssdi":[],"markdown_content":"\nThe `List` action returns a list of existing [Schedules](/concepts/what-is-a-schedule) and their respective Schedule IDs.\n\nTo return information on all Schedules, use [`ScheduleClient.List()`](https://pkg.go.dev/go.temporal.io/sdk/internal#ScheduleClient).\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/add-go-schedule-sample/schedule/list/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\t// list schedules\n\tlistView, _ := temporalClient.ScheduleClient().List(ctx, client.ScheduleListOptions{\n\t\tPageSize: 1,\n\t})\n// ...\n}\n// ...\n```\n","is_empty":false},{"file_name":"how-to-list-workflow-executions-using-the-client-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-list-workflow-executions-using-the-client-in-go.md","id":"go/how-to-list-workflow-executions-using-the-client-in-go","title":"How to list Workflow Executions using the Client in Go","description":"List Workflow Executions using the Client","label":"List Workflow Executions using the Client","tags":["developer-guide","go","client"],"ssdi":[],"markdown_content":"\nThe [ListWorkflow()](https://pkg.go.dev/go.temporal.io/sdk/client#Client.ListWorkflow) function retrieves a list of [Workflow Executions](/concepts/what-is-a-workflow-execution) that match the [Search Attributes](/concepts/what-is-a-search-attribute) of a given [List Filter](/concepts/what-is-a-list-filter).\nThe metadata returned from the [Visibility](/concepts/what-is-visibility) store can be used to get a Workflow Execution's history and details from the [Persistence](/concepts/what-is-a-temporal-cluster#persistence) store.\n\nUse a List Filter to define a `request` to pass into `ListWorkflow()`.\n\n```go\nrequest := &workflowservice.ListWorkflowExecutionsRequest{ Query: \"CloseTime = missing\" }\n```\n\nThis `request` value returns only open Workflows.\nFor more List Filter examples, see the [examples provided for List Filters in the Temporal Visibility guide.](/concepts/what-is-a-list-filter#list-filter-examples)\n\n```go\nresp, err := temporalClient.ListWorkflow(ctx.Background(), request)\nif err != nil {\n  return err\n}\n\nfmt.Println(\"First page of results:\")\nfor _, exec := range resp.Executions {\n  fmt.Printf(\"Workflow ID %v\\n\", exec.Execution.WorkflowId)\n}\n```\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-log-from-a-workflow-in-go.md","id":"go/how-to-log-from-a-workflow-in-go","title":"How to log from a Workflow in Go","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","go","log"],"ssdi":[],"markdown_content":"\nIn Workflow Definitions you can use [`workflow.GetLogger(ctx)`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLogger) to write logs.\n\n```go\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"go.temporal.io/sdk/activity\"\n\t\"go.temporal.io/sdk/workflow\"\n)\n\n// Workflow is a standard workflow definition.\n// Note that the Workflow and Activity don't need to care that\n// their inputs/results are being compressed.\nfunc Workflow(ctx workflow.Context, name string) (string, error) {\n// ...\n\nworkflow.WithActivityOptions(ctx, ao)\n\n// Getting the logger from the context.\n\tlogger := workflow.GetLogger(ctx)\n// Logging a message with the key value pair `name` and `name`\n\tlogger.Info(\"Compressed Payloads workflow started\", \"name\", name)\n\n\tinfo := map[string]string{\n\t\t\"name\": name,\n\t}\n\n\n\tlogger.Info(\"Compressed Payloads workflow completed.\", \"result\", result)\n\n\treturn result, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-manage-namespaces-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-manage-namespaces-in-go.md","id":"go/how-to-manage-namespaces-in-go","title":"How to manage Namespaces in Go","description":null,"label":"Manage Namespaces","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud/how-to-manage-namespaces-in-temporal-cloud) or [tcld commands](/cloud/tcld/namespace/) to manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can manage your registered Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\n- Update information and configuration for a registered Namespace on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace update`](/tctl-v1/namespace#update)\n    Example\n  - Use the [`UpdateNamespace` API](https://pkg.go.dev/go.temporal.io/sdk/client#NamespaceClient) to update configuration on a Namespace.\n    Example\n\n    ```go\n    //...\n      err = client.Update(context.Background(), &workflowservice.UpdateNamespaceRequest{\n      Namespace:         \"your-namespace-name\",\n      UpdateInfo:        &namespace.UpdateNamespaceInfo{ //updates info for the namespace \"your-namespace-name\"\n          Description:   \"updated namespace description\",\n          OwnerEmail:    \"newowner@mail.com\",\n          //Data:        nil,\n          //State:       0,\n      },\n      /*other details that you can update:\n      Config:            &namespace.NamespaceConfig{ //updates the configuration of the namespace with the following options\n          //WorkflowExecutionRetentionTtl: nil,\n          //BadBinaries:                   nil,\n          //HistoryArchivalState:          0,\n          //HistoryArchivalUri:            \"\",\n          //VisibilityArchivalState:       0,\n          //VisibilityArchivalUri:         \"\",\n      },\n      ReplicationConfig: &replication.NamespaceReplicationConfig{ //updates the replication configuration for the namespace\n          //ActiveClusterName: \"\",\n          //Clusters:          nil,\n          //State:             0,\n      },\n      SecurityToken:     \"\",\n      DeleteBadBinary:   \"\",\n      PromoteNamespace:  false,\n      })*/\n    //...\n    ```\n\n- Get details for a registered Namespace on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace describe`](/tctl-v1/namespace#describe)\n  - Use the [`DescribeNamespace` API](https://pkg.go.dev/go.temporal.io/sdk/client#NamespaceClient) to return information and configuration details for a registered Namespace.\n    Example\n\n    ```go\n    //...\n      client, err := client.NewNamespaceClient(client.Options{})\n      //...\n      client.Describe(context.Background(), \"default\")\n    //...\n    ```\n\n- Get details for all registered Namespaces on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace list`](/tctl-v1/namespace#list)\n  - Use the [`ListNamespace` API](https://github.com/temporalio/api/blob/f0350f8032ad2f0c60c539b3b61ea37f412f1cf7/temporal/api/operatorservice/v1/service.proto) to return information and configuration details for all registered Namespaces on your Temporal Cluster.\n    Example\n\n  ```go\n  //...\n      namespace.Handler.ListNamespaces(context.Context(), &workflowservice.ListNamespacesRequest{ //lists 1 page (1-100) of namespaces on the active cluster. You can set a large PageSize or loop until NextPageToken is nil\n          //PageSize:        0,\n          //NextPageToken:   nil,\n          //NamespaceFilter: nil,\n          })\n  //...\n  ```\n\n- Delete a Namespace: The [`DeleteNamespace` API](https://github.com/temporalio/api/blob/f0350f8032ad2f0c60c539b3b61ea37f412f1cf7/temporal/api/operatorservice/v1/service.proto) deletes a Namespace. Deleting a Namespace deletes all running and completed Workflow Executions on the Namespace, and removes them from the persistence store and the visibility store.\n  Example:\n\n  ```go\n  //...\n  client.OperatorService().DeleteNamespace(ctx, &operatorservice.DeleteNamespaceRequest{...\n  //...\n  ```\n","is_empty":false},{"file_name":"how-to-pause-a-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-pause-a-schedule-in-go.md","id":"go/how-to-pause-a-schedule-in-go","title":"How to pause a Schedule in Go","description":"Show how to unpause and pause a Schedule in Go.","label":"Pause Schedule","ssdi":[],"markdown_content":"\n`Pause` and `Unpause` enable the start or stop of all future [Workflow Runs](/concepts/what-is-a-workflow) on a given [Schedule](/concepts/what-is-a-schedule).\n\nPausing a Schedule halts all future Workflow Runs.\nPause a Schedule by setting `State.Paused` to `true`, or by using `Pause()` on the `ScheduleHandle`.\n\nUnpausing a Schedule allows the Workflow to execute as planned.\nTo unpause a Schedule, use `Unpause()` on the `ScheduleHandle`, or set `State.Paused` to `false`.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/add-go-schedule-sample/schedule/pause/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\tscheduleHandle, err := temporalClient.ScheduleClient().Create(ctx, client.ScheduleOptions{\n// ...\n\t\tPaused: true,\n\t})\n// ...\n\tscheduleHandle.Unpause(ctx, client.ScheduleUnpauseOptions{\n\t\tNote: \"The Schedule has been unpaused.\",\n\t})\n\tscheduleHandle.Pause(ctx, client.SchedulePauseOptions{\n\t\tNote: \"The Schedule has been paused.\",\n\t})\n}\n// ...\n```\n","is_empty":false},{"file_name":"how-to-register-namespace-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-register-namespace-in-go.md","id":"go/how-to-register-namespace-in-go","title":"How to register a Namespace in Go","description":"Use the `NamespaceClient` interface with the `Register` APIs to register your namespace.","label":"Register Namespaces","tags":["developer-guide","go","workers"],"ssdi":[],"markdown_content":"\nUse [`Register` API](https://pkg.go.dev/go.temporal.io/sdk/client#NamespaceClient) with the `NamespaceClient` interface to register a [Namespace](/concepts/what-is-a-namespace) and set the [Retention Period](/concepts/what-is-a-retention-period) for the Workflow Execution Event History for the Namespace.\n\nYou can also [register Namespaces using the tctl command-line tool](/tctl-v1/namespace/register).\n\n```go\nclient, err := client.NewNamespaceClient(client.Options{HostPort: ts.config.ServiceAddr})\n        //...\n    err = client.Register(ctx, &workflowservice.RegisterNamespaceRequest{\n        Namespace: your-namespace-name,\n        WorkflowExecutionRetentionPeriod: &retention,\n    })\n```\n\nThe Retention Period setting using `WorkflowExecutionRetentionPeriod` is mandatory.\nThe minimum value you can set for this period is 1 day.\n\nOnce registered, set Namespace using `Dial` in a Workflow Client to run your Workflow Executions within that Namespace.\nSee [how to set Namespace in a Client in Go](/go/connect-to-temporal-cloud) for details.\n\nNote that Namespace registration using this API takes up to 10 seconds to complete.\nEnsure that you wait for this registration to complete before starting the Workflow Execution against the Namespace.\n\nTo update your Namespace, use the [`Update` API](https://pkg.go.dev/go.temporal.io/sdk/client#NamespaceClient) with the `NamespaceClient`.\n\nTo update your Namespace using tctl, use the [tctl namespace update](/tctl-v1/namespace/update) command.\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-register-types-with-a-worker-in-go.md","id":"go/how-to-register-types-with-a-worker-in-go","title":"How to register types with a Worker in Go","description":"The `RegisterWorkflow()` and `RegisterActivity()` calls create an in-memory mapping between the Workflow Types and their implementations.","label":"Register Types","tags":["developer-guide","go","workers"],"ssdi":[],"markdown_content":"\nThe `RegisterWorkflow()` and `RegisterActivity()` calls essentially create an in-memory mapping between the Workflow Types and their implementations, inside the Worker process.\n\n**Registering Activity `structs`**\n\nPer [Activity Definition](/go/how-to-develop-an-activity-definition-in-go) best practices, you might have an Activity struct that has multiple methods and fields.\nWhen you use `RegisterActivity()` for an Activity struct, that Worker has access to all exported methods.\n\n**Registering multiple Types**\n\nTo register multiple Activity Types and/or Workflow Types with the Worker Entity, just make multiple Activity registration calls, but make sure each Type name is unique:\n\n```go\nw.RegisterActivity(ActivityA)\nw.RegisterActivity(ActivityB)\nw.RegisterActivity(ActivityC)\nw.RegisterWorkflow(WorkflowA)\nw.RegisterWorkflow(WorkflowB)\nw.RegisterWorkflow(WorkflowC)\n```\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-remove-search-attributes-from-a-workflow-in-go.md","id":"go/how-to-remove-search-attributes-from-a-workflow-in-go","title":"How to remove Search Attributes from a Workflow in Go","description":"How to remove Search Attributes from a Workflow","label":"How to remove Search Attributes from a Workflow","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\n**There is no support for removing a field.**\n\nHowever, to achieve a similar effect, set the field to some placeholder value.\nFor example, you could set `CustomKeywordField` to `impossibleVal`.\nThen searching `CustomKeywordField != 'impossibleVal'` will match Workflows with `CustomKeywordField` not equal to `impossibleVal`, which includes Workflows without the `CustomKeywordField` set.\n","is_empty":false},{"file_name":"how-to-replay-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-replay-a-workflow-execution-in-go.md","id":"go/how-to-replay-a-workflow-execution-in-go","title":"How to replay a Workflow Execution in Go","description":"Use the `WorkflowReplayer` API to replay an existing Workflow Execution from an Event History to replicate errors.","label":"WorkflowReplayer","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nUse the [worker.WorkflowReplayer](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowReplayer) to replay an existing Workflow Execution from its Event History to replicate errors.\n\nFor example, the following code retrieves the Event History of a Workflow:\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/api/enums/v1\"\n\t\"go.temporal.io/api/history/v1\"\n\t\"go.temporal.io/sdk/client\"\n)\n\nfunc GetWorkflowHistory(ctx context.Context, client client.Client, id, runID string) (*history.History, error) {\n\tvar hist history.History\n\titer := client.GetWorkflowHistory(ctx, id, runID, false, enums.HISTORY_EVENT_FILTER_TYPE_ALL_EVENT)\n\tfor iter.HasNext() {\n\t\tevent, err := iter.Next()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thist.Events = append(hist.Events, event)\n\t}\n\treturn &hist, nil\n}\n```\n\nThis history can then be used to _replay_.\nFor example, the following code creates a `WorkflowReplayer` and register the `YourWorkflow` Workflow function.\nThen it calls the `ReplayWorkflowHistory` to _replay_ the Event History and return an error code.\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n)\n\nfunc ReplayWorkflow(ctx context.Context, client client.Client, id, runID string) error {\n\thist, err := GetWorkflowHistory(ctx, client, id, runID)\n\tif err != nil {\n\t\treturn err\n\t}\n\treplayer := worker.NewWorkflowReplayer()\n\treplayer.RegisterWorkflow(YourWorkflow)\n\treturn replayer.ReplayWorkflowHistory(nil, hist)\n}\n```\n\nThe code above will cause the Worker to re-execute the Workflow's Workflow Function using the original Event History.\nIf a noticeably different code path was followed or some code caused a deadlock, it will be returned in the error code.\nReplaying a Workflow Execution locally is a good way to see exactly what code path was taken for given input and events.\n\nYou can replay many Event Histories by registering all the needed Workflow implementation and then calling `ReplayWorkflowHistory` repeatedly.\n","is_empty":false},{"file_name":"how-to-request-cancellation-of-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-request-cancellation-of-a-workflow-execution-in-go.md","id":"go/how-to-request-cancellation-of-a-workflow-execution-in-go","title":"How to request Cancellation of a Workflow Execution in Go","description":"Use the `CancelWorkflow` API to cancel a Workflow Execution using its Id.","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nUse the `CancelWorkflow` API to cancel a Workflow Execution using its Id.\n\n<!--SNIPSTART samples-go-cancellation-cancel-workflow-execution-trigger-->\n\n[cancellation/cancel/main.go](https://github.com/temporalio/samples-go/blob/master/cancellation/cancel/main.go)\n\n```go\nfunc main() {\n\tvar workflowID string\n\tflag.StringVar(&workflowID, \"wid\", \"workflowID-to-cancel\", \"workflowID of the Workflow Execution to be canceled.\")\n\tflag.Parse()\n\n\tif workflowID == \"\" {\n\t\tflag.PrintDefaults()\n\t\treturn\n\t}\n\n\t// The client is a heavyweight object that should be created once per process.\n\tc, err := client.Dial(client.Options{\n\t\tHostPort: client.DefaultHostPort,\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create client\", err)\n\t}\n\tdefer c.Close()\n\n\terr = c.CancelWorkflow(context.Background(), workflowID, \"\")\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to cancel Workflow Execution\", err)\n\t}\n\tlog.Println(\"Workflow Execution cancelled\", \"WorkflowID\", workflowID)\n}\n```\n\n<!--SNIPEND-->\n\n#### How to clean up after a Workflow is cancelled\n\nWorkflow Definitions can be written to handle execution cancellation requests with Go's `defer` and the `workflow.NewDisconnectedContext` API.\nIn the Workflow Definition below, there is a special Activity that handles clean up should the execution be cancelled.\n\n<!--SNIPSTART samples-go-cancellation-workflow-definition-->\n\n[cancellation/workflow.go](https://github.com/temporalio/samples-go/blob/master/cancellation/workflow.go)\n\n```go\n// YourWorkflow is a Workflow Definition that shows how it can be canceled.\nfunc YourWorkflow(ctx workflow.Context) error {\n\tao := workflow.ActivityOptions{\n\t\tStartToCloseTimeout: 30 * time.Minute,\n\t\tHeartbeatTimeout:    5 * time.Second,\n\t\tWaitForCancellation: true,\n\t}\n\tctx = workflow.WithActivityOptions(ctx, ao)\n\tlogger := workflow.GetLogger(ctx)\n\tlogger.Info(\"cancel workflow started\")\n\tvar a *Activities // Used to call Activities by function pointer\n\tdefer func() {\n\n\t\tif !errors.Is(ctx.Err(), workflow.ErrCanceled) {\n\t\t\treturn\n\t\t}\n\n\t\t// When the Workflow is canceled, it has to get a new disconnected context to execute any Activities\n\t\tnewCtx, _ := workflow.NewDisconnectedContext(ctx)\n\t\terr := workflow.ExecuteActivity(newCtx, a.CleanupActivity).Get(ctx, nil)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"CleanupActivity failed\", \"Error\", err)\n\t\t}\n\t}()\n\n\tvar result string\n\terr := workflow.ExecuteActivity(ctx, a.ActivityToBeCanceled).Get(ctx, &result)\n\tlogger.Info(fmt.Sprintf(\"ActivityToBeCanceled returns %v, %v\", result, err))\n\n\terr = workflow.ExecuteActivity(ctx, a.ActivityToBeSkipped).Get(ctx, nil)\n\tlogger.Error(\"Error from ActivityToBeSkipped\", \"Error\", err)\n\n\tlogger.Info(\"Workflow Execution complete.\")\n\n\treturn nil\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-run-a-temporal-cloud-worker-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-run-a-temporal-cloud-worker-in-go.md","id":"go/how-to-run-a-temporal-cloud-worker-in-go","title":"How to run a Temporal Cloud Worker in Go","description":"Use a certificate key pair and your Temporal Cloud Namespace to connect to Temporal Cloud.","label":"Run a Cloud Worker","ssdi":[],"markdown_content":"\nTo run a Worker that talks to Temporal Cloud, you need the following:\n\n- A compatible mTLS CA certificate and mTLS private key that has been added to your Namespace.\n  See [certificate requirements](/cloud-context/certificates-requirements).\n- Your [Temporal Cloud Namespace Id](/concepts/what-is-a-cloud-namespace-id), which includes your [Temporal Cloud Namespace Name](/concepts/what-is-a-cloud-namespace-name) and the unique five- or six-digit [Temporal Cloud Account Id](/concepts/what-is-a-cloud-account-id) that is appended to it.\n  This information can be found in the URL of your Namespace; for example, `https://cloud.temporal.io/namespaces/yournamespace.a2fx6/`.\n  Remember that the Namespace Id must include the Account Id: `yournamespace.a2fx6`.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/cloud/worker/main_dacx.go\">View source code</a>\n\n```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"log\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n\n\t\"documentation-samples-go/cloud\"\n)\n\n\nfunc main() {\n\t// Get the key and cert from your env or local machine\n\tclientKeyPath := \"./secrets/yourkey.key\"\n\tclientCertPath := \"./secrets/yourcert.pem\"\n\t// Specify the host and port of your Temporal Cloud Namespace\n\t// Host and port format: namespace.unique_id.tmprl.cloud:port\n\thostPort := \"<yournamespace>.<id>.tmprl.cloud:7233\"\n\tnamespace := \"<yournamespace>.<id>\"\n\t// Use the crypto/tls package to create a cert object\n\tcert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to load cert and key pair.\", err)\n\t}\n\t// Add the cert to the tls certificates in the ConnectionOptions of the Client\n\ttemporalClient, err := client.Dial(client.Options{\n\t\tHostPort:  hostPort,\n\t\tNamespace: namespace,\n\t\tConnectionOptions: client.ConnectionOptions{\n\t\t\tTLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to connect to Temporal Cloud.\", err)\n\t}\n\tdefer temporalClient.Close()\n\t// Create a new Worker.\n\tyourWorker := worker.New(temporalClient, \"cloud-connection-example-go-task-queue\", worker.Options{})\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-send-a-query-to-a-workflow-execution-in-go.md","id":"go/how-to-send-a-query-to-a-workflow-execution-in-go","title":"How to send a Query to a Workflow Execution in Go","description":"Use the `QueryWorkflow()` API to send a Query to a Workflow in Go.","label":"Sending Queries","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nUse the `QueryWorkflow()` API or the `QueryWorkflowWithOptions` API on the Temporal Client to send a Query to a Workflow Execution.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType)\nif err != nil {\n  // ...\n}\n// ...\n```\n\nYou can pass an arbitrary number of arguments to the `QueryWorkflow()` function.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType, \"foo\", \"baz\")\nif err != nil {\n  // ...\n}\n// ...\n```\n\nThe value of `response` returned by the Query needs to be decoded into `result`.\nBecause this is a future, use `Get()` on `response` to get the result, such as a string in this example.\n\n```go\nvar result string\nif err != response.Get(&result); err != nil {\n  // ...\n}\nlog.Println(\"Received Query result. Result: \" + result)\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-send-a-signal-from-a-client-in-go.md","id":"go/how-to-send-a-signal-from-a-client-in-go","title":"How to send a Signal from a Temporal Client in Go","description":"Use the `SignalWorkflow()` method on an instance of the Go SDK Temporal Client to send a Signal to a Workflow Execution.","label":"Send Signal from Client","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nUse the `SignalWorkflow()` method on an instance of the [Go SDK Temporal Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) to send a [Signal](/concepts/what-is-a-signal) to a [Workflow Execution](/workflows#workflow-execution).\n\nPass in both the [Workflow Id](/concepts/what-is-a-workflow-id) and [Run Id](/concepts/what-is-a-run-id) to uniquely identify the Workflow Execution.\nIf only the Workflow Id is supplied (provide an empty string as the Run Id param), the Workflow Execution that is Running receives the Signal.\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWorkflow(context.Background(), \"your-workflow-id\", runID, \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n// ...\n```\n\nPossible errors:\n\n- `serviceerror.NotFound`\n- `serviceerror.Internal`\n- `serviceerror.Unavailable`\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-send-a-signal-from-a-workflow-in-go.md","id":"go/how-to-send-a-signal-from-a-workflow-in-go","title":"How to send a Signal from a Workflow in Go","description":"A Signal can be sent from within a Workflow to a different Workflow Execution using the `SignalExternalWorkflow` API from the `go.temporal.io/sdk/workflow` package.","label":"Send Signal from Workflow","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nA Signal can be sent from within a Workflow to a different Workflow Execution using the [`SignalExternalWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SignalExternalWorkflow) API from the `go.temporal.io/sdk/workflow` package.\n\n```go\n// ...\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  //...\n  signal := MySignal {\n    Message: \"Some important data\",\n  }\n  err :=  workflow.SignalExternalWorkflow(ctx, \"some-workflow-id\", \"\", \"your-signal-name\", signal).Get(ctx, nil)\n  if err != nil {\n    // ...\n  }\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-send-a-signal-with-start-in-go.md","id":"go/how-to-send-a-signal-with-start-in-go","title":"How to send a Signal-With-Start in Go","description":"Use the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.","label":"Signal-With-Start","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nUse the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.\n\nBecause the Workflow Execution might not exist, this API does not take a Run ID as a parameter\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWithStartWorkflow(context.Background(), \"your-workflow-id\", \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n```\n","is_empty":false},{"file_name":"how-to-send-an-update-from-a-client-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-send-an-update-from-a-client-in-go.md","id":"go/how-to-send-an-update-from-a-client-in-go","title":"How to send an Update from a Temporal Client in Go","description":"Use the UpdateWorkflow method on an instance of the Go SDK Temporal Client to send an Update to a Workflow Execution.","label":"Send Update from Client","ssdi":[],"markdown_content":"\nInvoke the UpdateWorkflow() method on an instance of the [Go SDK Temporal Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) to dispatch an [Update](/concepts/what-is-an-update) to a Workflow Execution.\n\nYou must provide the Workflow Id, but specifying a Run Id is optional.\nIf you supply only the Workflow Id (and provide an empty string as the Run Id param), the currently running Workflow Execution receives the Update.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourupdate/update/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\t// Set the Update argument values.\n\tupdateArg := yourupdate.YourUpdateArg{\n\t\tAdd: n,\n\t}\n\t// Call the UpdateWorkflow API.\n\t// A blank RunID means that the Update is routed to the most recent Workflow Run of the specified Workflow ID.\n\tupdateHandle, err := temporalClient.UpdateWorkflow(context.Background(), yourupdate.YourUpdateWFID, \"\", yourupdate.YourUpdateName, updateArg)\n\tif err != nil {\n\t\tlog.Fatalln(\"Error issuing Update request\", err)\n\t}\n\t// Get the result of the Update.\n\tvar updateResult yourupdate.YourUpdateResult\n\terr = updateHandle.Get(context.Background(), &updateResult)\n\tif err != nil {\n\t\tlog.Fatalln(\"Update encountered an error\", err)\n\t}\n\tlog.Println(\"Update succeeded, new total: \", updateResult.Total)\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-cron-schedule-in-go.md","id":"go/how-to-set-a-cron-schedule-in-go","title":"How to set a Cron Schedule in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `CronSchedule` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Cron Schedule","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `CronSchedule` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-custom-logger-in-go.md","id":"go/how-to-set-a-custom-logger-in-go","title":"How to set a custom logger in Go","description":"Set a custom logger","label":"Custom logger","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nThis field sets a custom Logger that is used for all logging actions of the instance of the Temporal Client.\n\nAlthough the Go SDK does not support most third-party logging solutions natively, [our friends at Banzai Cloud](https://github.com/sagikazarmark) built the adapter package [logur](https://github.com/logur/logur) which makes it possible to use third party loggers with minimal overhead.\nMost of the popular logging solutions have existing adapters in Logur, but you can find a full list [in the Logur Github project](https://github.com/logur?q=adapter-).\n\nHere is an example of using Logur to support [Logrus](https://github.com/sirupsen/logrus):\n\n```go\npackage main\nimport (\n  \"go.temporal.io/sdk/client\"\n\n\t\"github.com/sirupsen/logrus\"\n\tlogrusadapter \"logur.dev/adapter/logrus\"\n\t\"logur.dev/logur\"\n)\n\nfunc main() {\n  // ...\n  logger := logur.LoggerToKV(logrusadapter.New(logrus.New()))\n  clientOptions := client.Options{\n    Logger: logger,\n  }\n  temporalClient, err := client.Dial(clientOptions)\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-heartbeat-timeout-in-go.md","id":"go/how-to-set-a-heartbeat-timeout-in-go","title":"How to set a Heartbeat Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `HeartbeatTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Retry Policy","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nTo set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout), Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  HeartbeatTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-parent-close-policy-in-go.md","id":"go/how-to-set-a-parent-close-policy-in-go","title":"How to set a Parent Close Policy in Go","description":"Create an instance of `ChildWorkflowOptions` from the `go.temporal.io/sdk/workflow` package, set the `ParentClosePolicy` field, apply the options to the instance of `workflow.Context`, and pass the context to the `ExecuteChildWorkflow` call.","label":"Parent Close Policy","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nIn Go, a Parent Close Policy is set on the `ParentClosePolicy` field of an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions).\nThe possible values can be obtained from the [`go.temporal.io/api/enums/v1`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy) package.\n\n- `PARENT_CLOSE_POLICY_ABANDON`\n- `PARENT_CLOSE_POLICY_TERMINATE`\n- `PARENT_CLOSE_POLICY_REQUEST_CANCEL`\n\nThe Child Workflow Options are then applied to the instance of `workflow.Context` by using the `WithChildOptions` API, which is then passed to the `ExecuteChildWorkflow()` call.\n\n- Type: [`ParentClosePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy)\n- Default: `PARENT_CLOSE_POLICY_TERMINATE`\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n  // ...\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    // ...\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // ...\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-schedule-to-close-timeout-in-go.md","id":"go/how-to-set-a-schedule-to-close-timeout-in-go","title":"How to set a Schedule-To-Close Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Schedule-To-Close Timeout","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nTo set a [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `time.Duration`\n- Default: ∞ (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-schedule-to-start-timeout-in-go.md","id":"go/how-to-set-a-schedule-to-start-timeout-in-go","title":"How to set a Schedule-To-Start Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Schedule-To-Close Timeout","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nTo set a [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: `time.Duration`\n- Default: ∞ (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-start-to-close-timeout-in-go.md","id":"go/how-to-set-a-start-to-close-timeout-in-go","title":"How to set a Start-To-Close Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Start-To-Close Timeout","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nTo set a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `time.Duration`\n- Default: Same as the `ScheduleToCloseTimeout`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  StartToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-execution-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-workflow-execution-timeout-in-go.md","id":"go/how-to-set-a-workflow-execution-timeout-in-go","title":"How to set a Workflow Execution Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Execution Timeout","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  WorkflowExecutionTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-workflow-id-in-go.md","id":"go/how-to-set-a-workflow-id-in-go","title":"How to set a custom Workflow Id in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Id","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nAlthough it is not required, we recommend providing your own [Workflow Id](/concepts/what-is-a-workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.\n\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: System generated UUID\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  ID: \"Your-Custom-Workflow-Id\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-retry-policy-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-workflow-retry-policy-in-go.md","id":"go/how-to-set-a-workflow-retry-policy-in-go","title":"How to set a Workflow Retry Policy in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `RetryPolicy` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Retry Policy","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nCreate an instance of a [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy) from the `go.temporal.io/sdk/temporal` package and provide it as the value to the `RetryPolicy` field of the instance of `StartWorkflowOptions`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default: None\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\nworkflowOptions := client.StartWorkflowOptions{\n  RetryPolicy: retrypolicy,\n  // ...\n}\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-run-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-workflow-run-timeout-in-go.md","id":"go/how-to-set-a-workflow-run-timeout-in-go","title":"How to set a Workflow Run Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Run Timeout","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Same as [`WorkflowExecutionTimeout`](#workflowexecutiontimeout)\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowRunTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-workflow-task-queue-in-go.md","id":"go/how-to-set-a-workflow-task-queue-in-go","title":"How to set the Task Queue for Workflow Execution in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Task Queue","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None, this is a required field to be set by the developer\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  TaskQueue: \"your-task-queue\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-a-workflow-task-timeout-in-go.md","id":"go/how-to-set-a-workflow-task-timeout-in-go","title":"How to set a Workflow Task Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Task Timeout","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: `time.Seconds * 10`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowTaskTimeout: time.Second * 10,\n  //...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-activity-timeouts-in-go.md","id":"go/how-to-set-activity-timeouts-in-go","title":"How to set Activity Timeouts in Go","description":"Create an instance of StartWorkflowOptions.","label":"Activity Timeouts","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nTo set an Activity Timeout in Go, create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the Activity Timeout field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nAvailable timeouts are:\n\n- `StartToCloseTimeout`\n- `ScheduleToClose`\n- `ScheduleToStartTimeout`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  // Set Activity Timeout duration\n  ScheduleToCloseTimeout: 10 * time.Second,\n  // StartToCloseTimeout: 10 * time.Second,\n  // ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-an-activity-retry-policy-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-an-activity-retry-policy-in-go.md","id":"go/how-to-set-an-activity-retry-policy-in-go","title":"How to set an Activity Retry Policy in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Retry Policy","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nTo set a [RetryPolicy](/concepts/what-is-a-retry-policy), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default:\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100, // 100 * InitialInterval\n  MaximumAttempts: 0, // Unlimited\n  NonRetryableErrorTypes: []string, // empty\n}\n```\n\nProviding a Retry Policy here is a customization, and overwrites individual Field defaults.\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\n\nactivityoptions := workflow.ActivityOptions{\n  RetryPolicy: retrypolicy,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-an-update-validator-function-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-an-update-validator-function-in-go.md","id":"go/how-to-set-an-update-validator-function-in-go","title":"How to set an Update validator function in go","description":"Use the SetUpdateHandlerWithOptions API and pass it a validator function to validate inputs.","label":"Validator function","ssdi":[],"markdown_content":"\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourupdate/your_updatable_workflow_dacx.go\">View source code</a>\n\n```go\nValidate certain aspects of the data sent to the Workflow using an Update validator function.\nFor instance, a counter Workflow might never want to accept a non-positive number.\nInvoke the `SetUpdateHandlerWithOptions` API and define a validator function as one of the options.\n\nWhen you use a Validator function, the Worker receives the Update first, before any Events are written to the Event History.\nIf the Update is rejected, it's not recorded in the Event History.\nIf it's accepted, the `WorkflowExecutionUpdateAccepted` Event occurs.\nAfterwards, the Worker executes the accepted Update and, upon completion, a `WorkflowExecutionUpdateCompleted` Event gets written into the Event History.\nThe Validator function, unlike the Update Handler, can not change the state of the Workflow.\n\nThe platform treats a panic in the Validator function as a rejection of the Update.\"\n\n// UpdatableWorkflowWithValidator is a Workflow Definition.\n// This Workflow Definition has an Update handler that uses the isPositive() validator function.\n// After setting the Update hanlder it sleeps for 1 minutue.\n// Updates can be sent to the Workflow during this time.\nfunc UpdatableWorkflowWithValidator(ctx workflow.Context, param WFParam) (WFResult, error) {\n\tcounter := param.StartCount\n\terr := workflow.SetUpdateHandlerWithOptions(\n\t\tctx, YourValidatedUpdateName,\n\t\tfunc(ctx workflow.Context, arg YourUpdateArg) (YourUpdateResult, error) {\n// ...\n\t\t},\n\t\t// Set the isPositive validator.\n\t\tworkflow.UpdateHandlerOptions{Validator: isPositive},\n\t)\n\tif err != nil {\n\t\treturn WFResult{}, err\n\t}\n// ...\n}\n\n// isPositive is a validator function.\n// It returns an error if the int value is below 1.\n// This function can not change the state of the Workflow.\n// workflow.Context can be used to log\nfunc isPositive(ctx workflow.Context, u YourUpdateArg) error {\n\tlog := workflow.GetLogger(ctx)\n\tif u.Add < 1 {\n\t\tlog.Debug(\"Rejecting non-positive number, positive integers only\", \"UpdateValue\", u.Add)\n\t\treturn fmt.Errorf(\"addend must be a positive integer (%v)\", u.Add)\n\t}\n\tlog.Debug(\"Accepting Update\", \"UpdateValue\", u.Add)\n\treturn nil\n}\n```\n","is_empty":false},{"file_name":"how-to-set-childworkflowoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-childworkflowoptions-in-go.md","id":"go/how-to-set-childworkflowoptions-in-go","title":"How to set ChildWorkflowOptions in Go","description":"Used to set all Child Workflow Execution specific options","label":"ChildWorkflowOptions","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nUsed to set all Child Workflow specific options\n\n| Field                    | Description                                                                       | Type                   |\n| ------------------------ | --------------------------------------------------------------------------------- | ---------------------- |\n| Namespace                | Set the namespace of the Child Workflow Execution                                 | string                 |\n| WorkflowID               | Set the Id of the Child Workflow to be scheduled                                  | string                 |\n| TaskQueue                | Set Task Queue that the Child Workflow needs to be scheduled on                   | string                 |\n| WorkflowExecutionTimeout | Set the end to end timeout for the Child Workflow Execution including retries     | time.Duration          |\n| WorkflowRunTimeout       | Set the timeout for a single run of the Child Workflow Execution                  | time.Duration          |\n| WorkflowTaskTimeout      | Set the maximum execution time of a single Workflow Task                          | time.Duration          |\n| WaitForCancellation      | Set to wait for canceled Child Workflow to be ended                               | bool                   |\n| WorkflowIDReusePolicy    | Set if server allow reuse of Workflow Id                                          | WorkflowIdReusePolicy  |\n| RetryPolicy              | Set how to retry Child Workflow if error happens                                  | RetryPolicy            |\n| CronSchedule             | Set the cron schedule for Child Workflow                                          | string                 |\n| Memo                     | Set non-indexed info that will be shown in list Child Workflow                    | map[string]interface{} |\n| SearchAttributes         | Set indexed info that can be used in query of List/Scan/Count Child Workflow APIs | map[string]interface{} |\n| ParentClosePolicy        | Set policy to decide what to do for the child when the parent closes              | ParentClosePolicy      |\n\n### Parent Close Policy\n\nimport ParentClosePolicy from './how-to-set-a-parent-close-policy-in-go.md'\n\n<ParentClosePolicy/>\n","is_empty":false},{"file_name":"how-to-set-clientoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-clientoptions-in-go.md","id":"go/how-to-set-clientoptions-in-go","title":"How to set ClientOptions in Go","description":"Create an instance of `Options` from the `go.temporal.io/sdk/client` package and pass it the call to create a new Temporal Client.","label":"ClientOptions","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nCreate an instance of [`Options`](https://pkg.go.dev/go.temporal.io/sdk/client#Options) from the `go.temporal.io/sdk/client` package and pass it the call to create a new Temporal Client.\n\n| Field                                       | Required | Type                                                                                       |\n| ------------------------------------------- | -------- | ------------------------------------------------------------------------------------------ |\n| [`HostPort`](#hostport)                     | No       | `string`                                                                                   |\n| [`Namespace`](#namespace)                   | No       | `string`                                                                                   |\n| [`Logger`](#logger)                         | No       | [`log.Logger`](https://pkg.go.dev/go.temporal.io/sdk/log#Logger)                           |\n| [`MetricsHandler`](#metricshandler)         | No       | [`metrics.Handler`](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler) |\n| [`Identity`](#identify)                     | No       | `string`                                                                                   |\n| [`DataConverter`](#dataconverter)           | No       | [`converter.DataConverter`](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter) |\n| [`ContextPropagators`](#contextpropagators) | No       | [`[]ContextPropagator`](https://pkg.go.dev/go.temporal.io/sdk/internal#ContextPropagator)  |\n| [`ConnectionOptions`](#connectionoptions)   | No       | [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/internal#ConnectionOptions)    |\n| [`HeadersProvider`](#headersprovider)       | No       | [`HeadersProvider`](https://pkg.go.dev/go.temporal.io/sdk/internal#HeadersProvider)        |\n| [`TrafficController`](#trafficcontroller)   | No       | [`TrafficController`](https://pkg.go.dev/go.temporal.io/sdk/internal#TrafficController)    |\n| [`Interceptors`](#interceptors)             | No       | [`[]ClientInterceptor`](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientInterceptor)  |\n\n### `HostPort`\n\n**How to set the Temporal Client's host:port connection in Go**\n\n- Type: `string`\n- Default: [`client.DefaultHostPort`](https://pkg.go.dev/go.temporal.io/sdk/client#pkg-constants) (127.0.0.1:7233)\n\n```go\nclientOptions := client.Options{\n  HostPort: client.DefaultHostPort,\n}\ntemporalClient, err := client.Dial(clientOptions)\n```\n\nThe `HostPort` value is a gRPC address and therefore can also support a special-formatted address of `<resolver>:///<value>` that will use a registered resolver.\nBy default all hosts returned from the resolver will be used in a round-robin fashion.\n\nThe \"dns\" resolver is registered by default.\nUsing a `dns:///` prefixed address will cause a periodic round-robin resolution of all IPs for all DNS addresses.\n\nA custom resolver can be created to provide multiple hosts in other ways.\nFor example, to manually provide multiple IPs to round-robin across, a `google.golang.org/grpc/resolver/` manual resolver can be created and registered with a custom scheme:\n\n```go\nbuilder := manual.NewBuilderWithScheme(\"myresolver\")\nbuilder.InitialState(resolver.State{Addresses: []resolver.Address{{Addr: \"1.2.3.4:1234\"},{Addr: \"2.3.4.5:2345\"}}})\nresolver.Register(builder)\ntemporalClient, err := client.Dial(client.Options{HostPort: \"myresolver:///ignoredvalue\"})\n```\n\nOther more advanced resolvers can also be registered.\n\n### `Namespace`\n\nimport Namespace from './how-to-set-the-namespace-for-a-temporal-client-in-go.md'\n\n<Namespace/>\n\n### `Logger`\n\n**How to use a custom logger in Go**\n\nThis field sets a custom Logger that is used for all logging actions of the instance of the Temporal Client.\n\nAlthough the Go SDK does not support most third-party logging solutions natively, [our friends at Banzai Cloud](https://github.com/sagikazarmark) built the adapter package [logur](https://github.com/logur/logur) which makes it possible to use third party loggers with minimal overhead.\nMost of the popular logging solutions have existing adapters in Logur, but you can find a full list [in the Logur Github project](https://github.com/logur?q=adapter-).\n\nHere is an example of using Logur to support [Logrus](https://github.com/sirupsen/logrus):\n\n```go\npackage main\nimport (\n  \"go.temporal.io/sdk/client\"\n\n\t\"github.com/sirupsen/logrus\"\n\tlogrusadapter \"logur.dev/adapter/logrus\"\n\t\"logur.dev/logur\"\n)\n\nfunc main() {\n  // ...\n  logger := logur.LoggerToKV(logrusadapter.New(logrus.New()))\n  clientOptions := client.Options{\n    Logger: logger,\n  }\n  temporalClient, err := client.Dial(clientOptions)\n  // ...\n}\n```\n\n### `MetricsHandler`\n\nSets the metric scope, which metrics should be reported\n\n- Type: [`metrics.Handler`](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler)\n- Default: None\n\n### `Identity`\n\nSets an identify that can be used to track this host for debugging\n\n### `DataConverter`\n\nSets DataConverter to customize serialization/deserialization of arguments in Temporal\n\n- Type: [`converter.DataConverter`](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter)\n\n### `ContextPropagators`\n\nSets ContextPropagators that allows users to control the context information passed through a Workflow\n\n- Type: `[]ContextPropagator`\n\n### `ConnectionOptions`\n\nSets options for server connection that allow users to control features of connections such as TLS settings\n\n- Type: `ConnectionOptions`\n\n### `HeadersProvider`\n\nSets custom request headers\n\n- Type: `HeadersProvider`\n\n### `TrafficController`\n\nSet to induce artificial failures in test scenarios\n\n- Type: `TrafficController`\n\n### `Interceptors`\n\ngRPC interceptors that are applied to every RPC call performed by this connection.\nBy default, an interceptor is included; it automatically retries retryable errors.\nIf you do not want to perform automatic retries, set this to an empty list (or a list with your own interceptors).\n\n- Type: `[]ClientInterceptor`\n","is_empty":false},{"file_name":"how-to-set-connectionoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-connectionoptions-in-go.md","id":"go/how-to-set-connectionoptions-in-go","title":"How to set ConnectionOptions in Go","description":"Options to control optional connection params","label":"ConnectionOptions","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\n- Options to control optional connection params\n\n| Option                       | Description                                                                   | Type          |\n| ---------------------------- | ----------------------------------------------------------------------------- | ------------- |\n| TLS                          | Configures connection level security credentials                              | tls.Config    |\n| Authority                    | Set the value to be used as the :authority pseudo-header                      | string        |\n| DisableHealthCheck           | Disable health check                                                          | bool          |\n| HealthCheckAttemptTimeout    | Specify how to long to wait for service response on each health check attempt | time.Duration |\n| HealthCheckTimeout           | Set the default health check timeout                                          | time.Duration |\n| EnableKeepAliveCheck         | Set enable keep alive check                                                   | bool          |\n| KeepAliveTime                | Set the keep alive time                                                       | time.Duration |\n| KeepAliveTimeout             | Set the keep alive timeout                                                    | time.Duration |\n| KeepAlivePermitWithoutStream | Set if client sends keepalive pings even with no active RPCs                  | bool          |\n","is_empty":false},{"file_name":"how-to-set-executelocalactivityoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-executelocalactivityoptions-in-go.md","id":"go/how-to-set-executelocalactivityoptions-in-go","title":"How to set ExecuteLocalActivityOptions in Go","description":"Used to set local activity specific parameters that will be stored inside of a context","label":"ExecuteLocalActivityOptions","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\n- Used to set local activity specific parameters that will be stored inside a context\n\n| Option                 | Description                                                         | Type          |\n| ---------------------- | ------------------------------------------------------------------- | ------------- |\n| ScheduleToCloseTimeout | Set the end to end timeout for the local activity including retries | time.Duration |\n| StartToCloseTimeout    | Set timeout for a single execution of the local activity            | time.Duration |\n| RetryPolicy            | Set how to retry Activity if error happens                          | time.Duration |\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-mtls-configuration-in-go.md","id":"go/how-to-set-mtls-configuration-in-go","title":"How to set mTLS configuration in Go","description":"Use the `ConnectionOptions` API available in the `go.temporal.io/sdk/client` package to connect a Client with mTLS.","label":"Set mTLS configuration","tags":["developer-guide","sdk","Go"],"ssdi":[],"markdown_content":"\nUse the [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#ConnectionOptions) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to connect a Client with mTLS.\n\n```go\ncert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\nif err != nil {\n\treturn err\n}\nclient, err := client.Dial(client.Options{\n\tHostPort:  \"foo.bar.tmprl.cloud:7233\",\n\tNamespace: \"foo.bar\",\n\tConnectionOptions: client.ConnectionOptions{\n\t\tTLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n\t},\n})\n```\n","is_empty":false},{"file_name":"how-to-set-mutable-side-effects-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-mutable-side-effects-in-go.md","id":"go/how-to-set-mutable-side-effects-in-go","title":"How to set Mutable Side Effects in Go","description":"To use MutableSideEffect() in Go, provide the Workflow Id.","label":"Set Mutable Side Effects","tags":["developer-guide","sdk","Go"],"ssdi":[],"markdown_content":"\nTo use [`MutableSideEffect()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#MutableSideEffect) in Go, provide a unique name within the scope of the workflow.\n\n```go\nif err := workflow.MutableSideEffect(ctx, \"configureNumber\", get, eq).Get(&number); err != nil {\n    panic(\"can't decode number:\" + err.Error())\n  }\n```\n","is_empty":false},{"file_name":"how-to-set-registeractivityoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-registeractivityoptions-in-go.md","id":"go/how-to-set-registeractivityoptions-in-go","title":"How to set RegisterActivityOptions in Go","description":"Create an instance of `RegisterOptions` from the `go.temporal.io/sdk/activity` package and pass it to the `RegisterActivityWithOptions` call when registering the Activity Type with the Worker.","label":"RegisterActivityOptions","tags":["developer-guide"],"ssdi":[],"markdown_content":"\nCreate an instance of [`RegisterOptions`](https://pkg.go.dev/go.temporal.io/sdk/activity#RegisterOptions) from the `go.temporal.io/sdk/activity` package and pass it to the [`RegisterActivityWithOptions`](https://pkg.go.dev/go.temporal.io/sdk/worker#ActivityRegistry) call when registering the Activity Type with the Worker.\n\nOptions for registering an Activity\n\n| Field                                                             | Required | Type     |\n| ----------------------------------------------------------------- | -------- | -------- |\n| [`Name`](#name)                                                   | No       | `string` |\n| [`DisableAlreadyRegisteredCheck`](#disablealreadyregisteredcheck) | No       | `bool`   |\n| [`SkipInvalidStructFunctions`](#skipinvalidstructfunctions)       | No       | `bool`   |\n\n#### Name\n\nSee [How to customize Activity Type in Go](/go/how-to-customize-activity-type-in-go).\n\n#### DisableAlreadyRegisteredCheck\n\nDisables the check to see if the Activity has already been registered.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  DisableAlreadyRegisteredCheck: false,\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n\n#### SkipInvalidStructFunctions\n\nWhen registering a struct that has Activities, skip functions that are not valid.\nIf false, registration panics.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  SkipInvalidStructFunctions: false,\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-registerworkflowoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-registerworkflowoptions-in-go.md","id":"go/how-to-set-registerworkflowoptions-in-go","title":"How to set RegisterWorkflowOptions in Go","description":"Create an instance of `RegisterOptions` from the `go.temporal.io/sdk/workflow` package and pass it to the `RegisterWorkflowWithOptions` call when registering the Workflow Type with the Worker","label":"RegisterWorkflowOptions","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nCreate an instance of [`RegisterOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#RegisterOptions) from the `go.temporal.io/sdk/workflow` package and pass it to the [`RegisterWorkflowWithOptions`](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowRegistry) call when registering the Workflow Type with the Worker.\n\n- Used to set options for registering a Workflow\n\n| Field                                                             | Required | Type     |\n| ----------------------------------------------------------------- | -------- | -------- |\n| [`Name`](#name)                                                   | No       | `string` |\n| [`DisableAlreadyRegisteredCheck`](#disablealreadyregisteredcheck) | No       | `bool`   |\n\n#### Name\n\nSee [How to customize a Workflow Type in Go](/go/how-to-customize-workflow-type-in-go)\n\n#### DisableAlreadyRegisteredCheck\n\nDisables the check to see if the Workflow Type has already been registered.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := workflow.RegisterOptions{\n  DisableAlreadyRegisteredCheck: `false`,\n  // ...\n}\nw.RegisterWorkflowWithOptions(YourWorkflowDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-session-options-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-session-options-in-go.md","id":"go/how-to-set-sessionoptions-in-go","title":"How to set SessionOptions in Go","description":"Create an instance of `SessionOptions` and pass it to the `CreateSession()` API call.","label":"SessionOptions","tags":["developer-guide"],"ssdi":[],"markdown_content":"\nCreate an instance of [`SessionOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SessionOptions) and pass them to the [`CreateSession()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#CreateSession)\n\n| Field                                   | Required | Type            |\n| --------------------------------------- | -------- | --------------- |\n| [`ExecutionTimeout`](#executiontimeout) | No       | `time.Duration` |\n| [`CreationTimeout`](#creationtimeout)   | No       | `time.Duration` |\n| [`HeartbeatTimeout`](#heartbeattimeout) | No       | `time.Duration` |\n\n### ExecutionTimeout\n\nSpecifies the maximum amount of time the session can run.\n\n- Type: `time.Duration`\n- Default:\n\n### CreationTimeout\n\nSpecifies how long session creation can take before returning an error.\n\n- Type: `time.Duration`\n- Default:\n\n### HeartbeatTimeout\n\nSpecifies the heartbeat timeout.\n\n- Type: `time.Duration`\n- Default:\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-the-namespace-for-a-temporal-client-in-go.md","id":"go/how-to-set-the-namespace-for-a-temporal-client-in-go","title":"How to set a Namespace for a Temporal Client in Go","description":"Set the Namespace field on an instance of the Client Options.","label":"Set Namespace","tags":["how-to","go"],"ssdi":[],"markdown_content":"\nSet the `Namespace` field on an instance of the Client Options.\n\n```go\n// ...\nclientOptions := client.Options{\n  Namespace: \"your-custom-namespace\",\n}\ntemporalClient, err := client.Dial(clientOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-timers-in-go.md","id":"go/how-to-set-timers-in-go","title":"How to set Timers in Go","description":"To set a Timer in Go, use the `NewTimer()` function.","label":"Timers","tags":["timers","sleep"],"ssdi":[],"markdown_content":"\nTo set a Timer in Go, use the [`NewTimer()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#NewTimer) function and pass the duration you want to wait before continuing.\n\n```go\ntimer := workflow.NewTimer(timerCtx, duration)\n```\n\nTo set a sleep duration in Go, use the [`sleep()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Sleep) function and pass the duration you want to wait before continuing.\nA zero or negative sleep duration causes the function to return immediately.\n\n```go\nsleep = workflow.Sleep(ctx, 10*time.Second)\n```\n\nFor more information, see the [Timer](https://github.com/temporalio/samples-go/tree/main/timer) example in the [Go Samples repository](https://github.com/temporalio/samples-go).\n","is_empty":false},{"file_name":"how-to-set-workeroptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-workeroptions-in-go.md","id":"go/how-to-set-workeroptions-in-go","title":"How to set WorkerOptions in Go","description":"Create an instance of `Options` from the `go.temporal.io/sdk/worker` package, set any of the optional fields, and pass the instance to the `New` call.","label":"WorkerOptions","tags":["developer-guide","options","go"],"ssdi":[],"markdown_content":"\nCreate an instance of [`Options`](https://pkg.go.dev/go.temporal.io/sdk/worker#Options) from the `go.temporal.io/sdk/worker` package, set any of the optional fields, and pass the instance to the [`New`](https://pkg.go.dev/go.temporal.io/sdk/worker#New) call.\n\n| Field                                                                                 | Required | Type                                                                                          |\n| ------------------------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------- |\n| [`MaxConcurrentActivityExecutionSize`](#maxconcurrentactivityexecutionsize)           | No       | `int`                                                                                         |\n| [`WorkerActivitiesPerSecond`](#workeractivitiespersecond)                             | No       | `float64`                                                                                     |\n| [`MaxConcurrentLocalActivityExecutionSize`](#maxconcurrentlocalactivityexecutionsize) | No       | `int`                                                                                         |\n| [`WorkerLocalActivitiesPerSecond`](#workerlocalactivitiespersecond)                   | No       | `float64`                                                                                     |\n| [`TaskQueueActivitiesPerSecond`](#taskqueueactivitiespersecond)                       | No       | `float64`                                                                                     |\n| [`MaxConcurrentActivityTaskPollers`](#maxconcurrentactivitytaskpollers)               | No       | `int`                                                                                         |\n| [`MaxConcurrentWorkflowTaskExecutionSize`](#maxconcurrentworkflowtaskexecutionsize)   | No       | `int`                                                                                         |\n| [`MaxConcurrentWorkflowTaskPollers`](#maxconcurrentworkflowtaskpollers)               | No       | `int`                                                                                         |\n| [`EnableLoggingInReplay`](#enablelogginginreplay)                                     | No       | `bool`                                                                                        |\n| [`DisableStickyExecution`](#disablestickyexecution)                                   | No       | `bool`                                                                                        |\n| [`StickyScheduleToStartTimeout`](#stickyscheduletostarttimeout)                       | No       | [`time.Duration`](https://pkg.go.dev/time#Duration)                                           |\n| [`BackgroundActivityContext`](#backgroundactivitycontext)                             | No       | [`context.Context`](https://pkg.go.dev/context#Context)                                       |\n| [`WorkflowPanicPolicy`](#workflowopanicpolicy)                                        | No       | [`WorkflowPanicPolicy`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowPanicPolicy)   |\n| [`WorkerStopTimeout`](#workerstoptimeout)                                             | No       | [`time.Duration`](https://pkg.go.dev/time#Duration)                                           |\n| [`EnableSessionWorker`](#enablesessionworker)                                         | No       | `bool`                                                                                        |\n| [`MaxConcurrentSessionExecutionSize`](#maxconcurrentsessionexecutionsize)             | No       | `int`                                                                                         |\n| [`WorkflowInterceptorChainFactories`](#workflowinterceptorchainfactories)             | No       | [`[]WorkflowInterceptor`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowInterceptor) |\n| [`LocalActivityWorkerOnly`](#localactivityworkeronly)                                 | No       | `bool`                                                                                        |\n| [`Identity`](#identity)                                                               | No       | `string`                                                                                      |\n| [`DeadlockDetectionTimeout`](#deadlockdetectiontimeout)                               | No       | [`time.Duration`](https://pkg.go.dev/time#Duration)                                           |\n\n#### MaxConcurrentActivityExecutionSize\n\nSets the maximum concurrent Activity Executions for the Worker.\n\n- Type: `int`\n- Default: `1000`\n\nA value of `0` sets to the default.\n\n```go\n// ...\nworkerOptions := worker.Options{\n  MaxConcurrentActivityExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### WorkerActivitiesPerSecond\n\nRate limits the number of Activity Task Executions started per second for the Worker.\n\n- Type: `float64`\n- Default: `100000`\n\nA value of `0` sets to the default.\n\nIntended use case is to limit resources used by the Worker.\n\nNotice that the value type is a float so that the value can be less than 1 if needed.\nFor example, if set to 0.1, Activity Task Executions will happen once every ten seconds.\nThis can be used to protect down stream services from flooding with requests.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tWorkerActivitiesPerSecond: 100000,\n  // ..\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### MaxConcurrentLocalActivityExecutionSize\n\nSet the maximum concurrent [Local Activity Executions](/concepts/what-is-a-local-activity) for the Worker.\n\n- Type: `int`\n- Default: `1000`\n\nA value of `0` sets to the default value.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentLocalActivityExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### WorkerLocalActivitiesPerSecond\n\nRate limits the number of Local Activity Executions per second executed for the Worker.\n\n- Type: `float64`\n- Default: `100000`\n\nA value of `0` sets to the default value.\n\nIntended use case is to limit resources used by the Worker.\n\nNotice that the value type is a float so that the value can be less than 1 if needed.\nFor example, if set to 0.1, Local Activity Task Executions will happen once every ten seconds.\nThis can be used to protect down stream services from flooding with requests.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tWorkerLocalActivitiesPerSecond: 100000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### TaskQueueActivitiesPerSecond\n\nRate limits the number of Activity Executions that can be started per second.\n\n- Type: `float64`\n- Default: `100000`\n\nA value of `0` sets to the default value.\n\nThis rate is managed by the Temporal Cluster and limits the Activity Tasks per second for the entire Task Queue. This is in contrast to [`WorkerActivityTasksPerSecond`](#workeractivitytaskspersecond) controls activities only per Worker.\n\nNotice that the number is represented in float, so that you can set it to less than 1 if needed.\nFor example, set the number to 0.1 means you want your Activity to be executed once for every 10 seconds.\nThis can be used to protect down stream services from flooding.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tTaskQueueActivitiesPerSecond: 100000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### MaxConcurrentActivityTaskPollers\n\nSets the maximum number of goroutines to concurrently poll the Task Queue for Activity Tasks.\n\n- Type: `int`\n- Default: `2`\n\nChanging this value will affect the rate at which the Worker is able to consume Activity Tasks from the Task Queue.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentActivityTaskPollers: 2,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### MaxConcurrentWorkflowTaskExecutionSize\n\nSets the maximum number of concurrent Workflow Task Executions the Worker can have.\n\n- Type: `int`\n- Default: `1000`\n\nA value of `0` sets to the default value.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentWorkflowTaskExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### MaxConcurrentWorkflowTaskPollers\n\nSets the maximum number of goroutines that will concurrently poll the Task Queue for Workflow Tasks.\n\n- Type: `int`\n- Default: `2`\n\nChanging this value will affect the rate at which the Worker is able to consume Workflow Tasks from the Task Queue.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentWorkflowTaskPollers: 2,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### EnableLoggingInReplay\n\nSet to enable logging in Workflow Execution replays.\n\n- type: `bool`\n- Default: `false`\n\nIn Workflow Definitions you can use [`workflow.GetLogger(ctx)`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLogger) to write logs.\nBy default, the logger will skip logging during replays, so you do not see duplicate logs.\n\nThis is only really useful for debugging purpose.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tEnableLoggingInReplay: false,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### DisableStickyExecution\n\n:::caution Deprecated\n\nWhen DisableStickyExecution is `true` it can harm performance.\nIt will be removed soon.\nSee [`SetStickyWorkflowCacheSize`](https://pkg.go.dev/go.temporal.io/sdk/worker#SetStickyWorkflowCacheSize) instead.\n\n:::\n\nSet to disable Sticky Executions\n\n- Type: `bool`\n- Default: `false`\n\nSticky Execution runs Workflow Tasks of a Workflow Execution on same host (could be a different Worker, as long as it is on the same host).\nThis is an optimization for Workflow Executions.\nWhen sticky execution is enabled, Worker keeps the Workflow state in memory.\nNew Workflow Task contains the new history events will be dispatched to the same Worker.\nIf this Worker crashes, the sticky Workflow Task will timeout after `StickyScheduleToStartTimeout`, and Temporal Cluster will clear the stickiness for that Workflow Execution and automatically reschedule a new Workflow Task that is available for any Worker to pick up and resume the progress.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tStickyScheduleToStartTimeout: time.Second(5),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### StickyScheduleToStartTimeout\n\nSets the Sticky Execution Schedule-To-Start Timeout for Workflow Tasks.\n\n- Type: [`time.Duration`](https://pkg.go.dev/time#Duration)\n- Default value is `5`\n\nThe resolution is in seconds.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tStickyScheduleToStartTimeout: time.Second(5),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### BackgroundActivityContext\n\n:::caution Not recommended\n\nThis method of passing dependencies between Activity Task Executions is not recommended anymore.\n\nInstead, we recommend using a struct with fields that contain dependencies and develop Activity Definitions as struct methods and then pass all the dependencies on the structure initialization.\n\n- [How to develop an Activity Definition using the Go SDK](/go/how-to-develop-an-activity-definition-in-go)\n\n:::\n\n- Type: [`context.Context`](https://pkg.go.dev/context#Context)\n\nSets the background `context.Context` for all Activity Types registered with the Worker.\n\nThe context can be used to pass external dependencies such as database connections to Activity Task Executions.\n\n```go\n// ...\nctx := context.WithValue(context.Background(), \"your-key\", \"your-value\")\nworkerOptions := worker.Options{\n\tBackgroundActivityContext: ctx,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### WorkflowPanicPolicy\n\nSets how the Workflow Worker handles a non-deterministic Workflow Execution History Event and other panics from Workflow Definition code.\n\n- Type: [`WorkflowPanicPolicy`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowPanicPolicy)\n- Default: `BlockWorkflow`\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tDisableStickyExecution: internal.BlockWorkflow,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### WorkerStopTimeout\n\nSets the Worker's graceful stop timeout\n\n- Type: [`time.Duration`](https://pkg.go.dev/time#Duration)\n- Default: `0`\n\nValue resolution is in seconds.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tWorkerStopTimeout: time.Second(0),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### EnableSessionWorker\n\nEnables Sessions for Activity Workers.\n\n- Type: `bool`\n- Default: `false`\n\nWhen `true` the Activity Worker creates a Session to sequentially process Activity Tasks for the given Task Queue.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tEnableSessionWorker: true,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### MaxConcurrentSessionExecutionSize\n\nSets the maximum number of concurrent Sessions that the Worker can support.\n\n- Type: `int`\n- Default: 1000\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentSessionExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### WorkflowInterceptorChainFactories\n\nSpecifies the factories used to instantiate the Workflow interceptor chain.\n\n- Type: [`[]WorkflowInterceptor`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowInterceptor)\n\nThe chain is instantiated for each replay of a Workflow Execution.\n\n#### LocalActivityWorkerOnly\n\nSets the Worker to only handle Workflow Tasks and local Activity Tasks.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tLocalActivityWorkerOnly: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### Identity\n\nSets the Temporal Client-level Identity value, overwriting the existing one.\n\n- Type: string\n- Default: client identity\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tIdentity: \"your_custom_identity\",\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n#### DeadlockDetectionTimeout\n\nSets the maximum time that a Workflow Task can execute for.\n\n- Type: [`time.Duration`](https://pkg.go.dev/time#Duration)\n- Default: 1\n\nResolution is in seconds.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tDeadlockDetectionTimeout: time.Second(1),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-set-workflow-timeouts-in-go.md","id":"go/how-to-set-workflow-timeouts-in-go","title":"How to set Workflow Timeouts in Go","description":"Create an instance of StartWorkflowOptions.","label":"Workflow Timeouts","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set a timeout, and pass the instance to the `ExecuteWorkflow` call.\n\nAvailable timeouts are:\n\n- `WorkflowExecutionTimeout`\n- `WorkflowRunTimeout`\n- `WorkflowTaskTimeout`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  // Set Workflow Timeout duration\n  WorkflowExecutionTimeout: time.Hours * 24 * 365 * 10,\n  // WorkflowRunTimeout: time.Hours * 24 * 365 * 10,\n  // WorkflowTaskTimeout: time.Second * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-spawn-a-child-workflow-execution-in-go.md","id":"go/how-to-spawn-a-child-workflow-execution-in-go","title":"How to spawn a Child Workflow Execution in Go","description":"Use the `ExecuteChildWorkflow`, available from the `go.temporal.io/sdk/workflow` package, to spawn a Child Workflow Execution in Go.","label":"Child Workflow Execution","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nTo spawn a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) in Go, use the [`ExecuteChildWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ExecuteChildWorkflow) API, which is available from the `go.temporal.io/sdk/workflow` package.\n\nThe `ExecuteChildWorkflow` call requires an instance of [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context), with an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions) applied to it, the Workflow Type, and any parameters that should be passed to the Child Workflow Execution.\n\n`workflow.ChildWorkflowOptions` contain the same fields as `client.StartWorkflowOptions`.\nWorkflow Option fields automatically inherit their values from the Parent Workflow Options if they are not explicitly set.\nIf a custom `WorkflowID` is not set, one is generated when the Child Workflow Execution is spawned.\nUse the [`WithChildOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithChildOptions) API to apply Child Workflow Options to the instance of `workflow.Context`.\n\nThe `ExecuteChildWorkflow` call returns an instance of a [`ChildWorkflowFuture`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowFuture).\n\nCall the `.Get()` method on the instance of `ChildWorkflowFuture` to wait for the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{}\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  var result ChildResp\n  err := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{}).Get(ctx, &result)\n  if err != nil {\n    // ...\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\nTo asynchronously spawn a Child Workflow Execution, the Child Workflow must have an \"Abandon\" Parent Close Policy set in the Child Workflow Options.\nAdditionally, the Parent Workflow Execution must wait for the `ChildWorkflowExecutionStarted` Event to appear in its Event History before it completes.\n\nIf the Parent makes the `ExecuteChildWorkflow` call and then immediately completes, the Child Workflow Execution does not spawn.\n\nTo be sure that the Child Workflow Execution has started, first call the `GetChildWorkflowExecution` method on the instance of the `ChildWorkflowFuture`, which will return a different Future.\nThen call the `Get()` method on that Future, which is what will wait until the Child Workflow Execution has spawned.\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // Wait for the Child Workflow Execution to spawn\n  var childWE workflow.Execution\n  if err := childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE); err != nil {\n     return err\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-spawn-a-workflow-execution-in-go.md","id":"go/how-to-spawn-a-workflow-execution-in-go","title":"How to spawn a Workflow Execution in Go","description":"Use the `ExecuteWorkflow()` method on the Go SDK `Client`, which is available via `Dial()` in the `go.temporal.io/sdk/client` package.","label":"Workflow Execution","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nTo spawn a [Workflow Execution](/workflows#workflow-execution), use the `ExecuteWorkflow()` method on the Go SDK [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nThe `ExecuteWorkflow()` API call requires an instance of [`context.Context`](https://pkg.go.dev/context#Context), an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions), a Workflow Type name, and all variables to be passed to the Workflow Execution.\nThe `ExecuteWorkflow()` call returns a Future, which can be used to get the result of the Workflow Execution.\n\n```go\npackage main\n\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n  workflowOptions := client.StartWorkflowOptions{\n    // ...\n  }\n  workflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n  if err != nil {\n    // ...\n  }\n  // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n}\n```\n\nIf the invocation process has access to the function directly, then the Workflow Type name parameter can be passed as if the function name were a variable, without quotations.\n\n```go\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n```\n\nIf the invocation process does not have direct access to the statically defined Workflow Definition, for example, if the Workflow Definition is in an un-importable package, or it is written in a completely different language, then the Workflow Type can be provided as a `string`.\n\n```go\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, \"YourWorkflowDefinition\", param)\n```\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-spawn-an-activity-execution-in-go.md","id":"go/how-to-spawn-an-activity-execution-in-go","title":"How to spawn an Activity Execution in Go","description":"Use the ExecuteActivity() API call available from the go.temporal.io/sdk/workflow package.","label":"Activity Execution","ssdi":[],"markdown_content":"\nTo spawn an [Activity Execution](/concepts/what-is-an-activity-execution), call [`ExecuteActivity()`](https://pkg.go.dev/go.temporal.io/workflow#ExecuteActivity) inside your Workflow Definition.\nThe API is available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/workflow) package.\nThe `ExecuteActivity()` API call requires an instance of `workflow.Context`, the Activity function name, and any variables to be passed to the Activity Execution.\nThe Activity function name can be provided as a variable object (no quotations) or as a string.\nThe benefit of passing the actual function object is that the framework can validate the parameters against the Activity Definition.\nThe `ExecuteActivity` call returns a Future, which can be used to get the result of the Activity Execution.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/main/yourapp/your_workflow_definition_dacx.go\">View source code</a>\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (*YourWorkflowResultObject, error) {\t\n\t// Set the options for the Activity Execution.\n\t// Either StartToClose Timeout OR ScheduleToClose is required.\n\t// Not specifying a Task Queue will default to the parent Workflow Task Queue.\n\tactivityOptions := workflow.ActivityOptions{\n\t\tStartToCloseTimeout: 10 * time.Second,\n\t}\n\tctx = workflow.WithActivityOptions(ctx, activityOptions)\n\tactivityParam := YourActivityParam{\n\t\tActivityParamX: param.WorkflowParamX,\n\t\tActivityParamY: param.WorkflowParamY,\n\t}\n\t// Use a nil struct pointer to call Activities that are part of a struct.\n\tvar a *YourActivityObject\n\t// Execute the Activity and wait for the result.\n\tvar activityResult *YourActivityResultObject\n\terr := workflow.ExecuteActivity(ctx, a.YourActivityDefinition, activityParam).Get(ctx, &activityResult)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-test-workflow-definitions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-test-workflow-definitions-in-go.md","id":"go/how-to-test-workflow-definitions-in-go","title":"How to test Workflow Definitions in Go","label":"Testing and debugging","ssdi":[],"markdown_content":"\nThe Temporal Go SDK provides a test framework to facilitate testing Workflow implementations.\n\nThis framework is suited for implementing unit tests as well as functional tests of the Workflow logic.\n\nThe following code implements unit tests for the `SimpleWorkflow` sample:\n\n```go\npackage sample\n\nimport (\n        \"context\"\n        \"errors\"\n        \"testing\"\n\n        \"github.com/stretchr/testify/mock\"\n        \"github.com/stretchr/testify/suite\"\n\n        \"go.temporal.io/sdk/activity\"\n        \"go.temporal.io/sdk/testsuite\"\n)\n\ntype UnitTestSuite struct {\n        suite.Suite\n        testsuite.WorkflowTestSuite\n\n        env *testsuite.TestWorkflowEnvironment\n}\n\nfunc (s *UnitTestSuite) SetupTest() {\n        s.env = s.NewTestWorkflowEnvironment()\n}\n\nfunc (s *UnitTestSuite) AfterTest(suiteName, testName string) {\n        s.env.AssertExpectations(s.T())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n\nfunc TestUnitTestSuite(t *testing.T) {\n        suite.Run(t, new(UnitTestSuite))\n}\n```\n\n#### Setup\n\nTo run unit tests, we first define a test suite struct that absorbs both the\nbasic suite functionality from [testify](https://pkg.go.dev/github.com/stretchr/testify/suite)\nvia `suite.Suite` and the suite functionality from the Temporal test framework via\n`testsuite.WorkflowTestSuite`. Because every test in this test suite will test our Workflow, we\nadd a property to our struct to hold an instance of the test environment. This allows us to initialize\nthe test environment in a setup method. For testing Workflows, we use a `testsuite.TestWorkflowEnvironment`.\n\nNext, we implement a `SetupTest` method to set up a new test environment before each test. Doing so\nensures that each test runs in its own isolated sandbox. We also implement an `AfterTest` function\nwhere we assert that all the mocks we set up were indeed called by invoking `s.env.AssertExpectations(s.T())`.\n\nTimeout for the entire test can be set using `SetTestTimeout` in the Workflow or Activity environment.\n\nFinally, we create a regular test function recognized by the `go test` command, and pass the struct to `suite.Run`.\n\n#### A Simple Test\n\nThe simplest test case we can write is to have the test environment execute the Workflow and then\nevaluate the results.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\nCalling `s.env.ExecuteWorkflow(...)` executes the Workflow logic and any invoked Activities inside the\ntest process. The first parameter of `s.env.ExecuteWorkflow(...)` contains the Workflow functions,\nand any subsequent parameters contain values for custom input parameters declared by the Workflow\nfunction.\n\n> Note that unless the Activity invocations are mocked or Activity implementation\n> replaced (see [Activity mocking and overriding](#activity-mocking-and-overriding)), the test environment\n> will execute the actual Activity code including any calls to outside services.\n\nAfter executing the Workflow in the above example, we assert that the Workflow ran through completion\nvia the call to `s.env.IsWorkflowComplete()`. We also assert that no errors were returned by asserting\non the return value of `s.env.GetWorkflowError()`. If our Workflow returned a value, we could have\nretrieved that value via a call to `s.env.GetWorkflowResult(&value)` and had additional asserts on that\nvalue.\n\n#### Activity mocking and overriding\n\nWhen running unit tests on Workflows, we want to test the Workflow logic in isolation. Additionally,\nwe want to inject Activity errors during our test runs. The test framework provides two mechanisms\nthat support these scenarios: Activity mocking and Activity overriding. Both of these mechanisms allow\nyou to change the behavior of Activities invoked by your Workflow without the need to modify the actual\nWorkflow code.\n\nLet's take a look at a test that simulates a test that fails via the \"Activity mocking\" mechanism.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n```\n\nThis test simulates the execution of the Activity `SimpleActivity` that is invoked by our Workflow\n`SimpleWorkflow` returning an error. We accomplish this by setting up a mock on the test environment\nfor the `SimpleActivity` that returns an error.\n\n```go\ns.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n  \"\", errors.New(\"SimpleActivityFailure\"))\n```\n\nWith the mock set up we can now execute the Workflow via the `s.env.ExecuteWorkflow(...)` method and\nassert that the Workflow completed successfully and returned the expected error.\n\nSimply mocking the execution to return a desired value or error is a pretty powerful mechanism to\nisolate Workflow logic. However, sometimes we want to replace the Activity with an alternate implementation\nto support a more complex test scenario. Let's assume we want to validate that the Activity gets called\nwith the correct parameters.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\nIn this example, we provide a function implementation as the parameter to `Return`. This allows us to\nprovide an alternate implementation for the Activity `SimpleActivity`. The framework will execute this\nfunction whenever the Activity is invoked and pass on the return value from the function as the result\nof the Activity invocation. Additionally, the framework will validate that the signature of the \"mock\"\nfunction matches the signature of the original Activity function.\n\nSince this can be an entire function, there is no limitation as to what we can do here. In this\nexample, we assert that the `value` param has the same content as the value param we passed to the Workflow.\n\n#### Queries\n\n`TestWorkflowEnvironment` instances have a [`QueryWorkflow()` method](https://pkg.go.dev/go.temporal.io/temporal/internal#TestWorkflowEnvironment.QueryWorkflow) that lets you query the state of the currently running Workflow.\nFor example, suppose you have a Workflow that lets you query the progress of a long running task as shown below.\n\n```go\nfunc ProgressWorkflow(ctx workflow.Context, percent int) error {\n\tlogger := workflow.GetLogger(ctx)\n\n\terr := workflow.SetQueryHandler(ctx, \"getProgress\", func(input []byte) (int, error) {\n\t\treturn percent, nil\n\t})\n\tif err != nil {\n\t\tlogger.Info(\"SetQueryHandler failed.\", \"Error\", err)\n\t\treturn err\n\t}\n\n\tfor percent = 0; percent<100; percent++ {\n                // Important! Use `workflow.Sleep()`, not `time.Sleep()`, because Temporal's\n                // test environment doesn't stub out `time.Sleep()`.\n\t\tworkflow.Sleep(ctx, time.Second*1)\n\t}\n\n\treturn nil\n}\n```\n\nThis Workflow tracks the current progress of a task in percentage terms, and increments the percentage by 1 every second.\nBelow is how you would write a test case that queries this Workflow.\nNote that you should always query the Workflow either after `ExecuteWorkflow()` is done or in a `RegisterDelayedCallback()` callback, otherwise you'll get a `runtime error` panic.\n\n```go\nfunc (s *UnitTestSuite) Test_ProgressWorkflow() {\n\tvalue := 0\n\n\t// After 10 seconds plus padding, progress should be 10.\n\t// Note that `RegisterDelayedCallback()` doesn't actually make your test wait for 10 seconds!\n\t// Temporal's test framework advances time internally, so this test should take < 1 second.\n\ts.env.RegisterDelayedCallback(func() {\n\t\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\t\ts.NoError(err)\n\t\terr = res.Get(&value)\n\t\ts.NoError(err)\n\t\ts.Equal(10, value)\n\t}, time.Second*10+time.Millisecond*1)\n\n\ts.env.ExecuteWorkflow(ProgressWorkflow, 0)\n\n\ts.True(s.env.IsWorkflowCompleted())\n\n\t// Once the workflow is completed, progress should always be 100\n\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\ts.NoError(err)\n\terr = res.Get(&value)\n\ts.NoError(err)\n\ts.Equal(value, 100)\n}\n```\n\n:::note\n\n`RegisterDelayedCallback` can also be used to send [Signals](/concepts/what-is-a-signal).\nWhen using \"Signal-With-Start\", set the delay to `0`.\n:::\n\n#### Debugging\n\nYou can use a debugger tool provided by your favorite IDE to debug your Workflow Definitions prior to testing or executing them.\n\nThe Temporal Go SDK includes deadlock detection which fails a Workflow Task in case the code blocks over a second without relinquishing execution control.\nBecause of this you can often encounter a `PanicError: Potential deadlock detected` while stepping through Workflow Definitions during debugging.\n\nTo alleviate this issue, you can set the `TEMPORAL_DEBUG` environment variable to `true` before debugging your Workflow Definition.\n\n:::note\n\nMake sure to set `TEMPORAL_DEBUG` to true only during debugging.\n\n:::\n","is_empty":false},{"file_name":"how-to-trigger-a-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-trigger-a-schedule-in-go.md","id":"go/how-to-trigger-a-schedule-in-go","title":"How to trigger a Schedule in Go","description":"Immediately execute an Action in a Schedule.","label":"Trigger Schedule","ssdi":[],"markdown_content":"\nTriggering a [Schedule](/concepts/what-is-a-schedule) immediately executes an [Action](/concepts/what-is-a-schedule#action) defined in that Schedule.\nBy default, `trigger` is subject to the `AllowAll` Overlap Policy.\n\nTo trigger a Scheduled [Workflow Execution](/concepts/what-is-a-workflow-execution), use `trigger()` on `ScheduleHandle`.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/add-go-schedule-sample/schedule/trigger/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\t// Create a Schedule to trigger\n\tscheduleHandle, _ := temporalClient.ScheduleClient().Create(ctx, client.ScheduleOptions{\n\t\tID: \"trigger-schedule\",\n\t\tSpec: client.ScheduleSpec{},\n\t\tAction: &client.ScheduleWorkflowAction{},\n\t\tPaused: true,\n\t\tOverlap: enums.SCHEDULE_OVERLAP_POLICY_ALLOW_ALL,\n\t})\n// ...\n\t// Trigger Schedule\n\tfor i := 0; i < 5; i++ {\n\t\tscheduleHandle.Trigger(ctx, client.ScheduleTriggerOptions{\n\t\t\tOverlap: enums.SCHEDULE_OVERLAP_POLICY_ALLOW_ALL,\n\t\t})\n\t\ttime.Sleep(2 * time.Second)\n\t}\n}\n// ...\n```\n","is_empty":false},{"file_name":"how-to-update-a-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-update-a-schedule-in-go.md","id":"go/how-to-update-a-schedule-in-go","title":"How to update a Schedule in Go","description":"Update the configuration of a Schedule.","label":"Update Schedule","ssdi":[],"markdown_content":"\nUpdating a [Schedule](/concepts/what-is-a-schedule) changes the configuration of an existing Schedule.\nThese changes can be made to [Actions](/concepts/what-is-a-schedule#action), Action parameters, [Memos](/concepts/what-is-a-memo), and the Workflow's Cancellation Policy.\n\nUse `Update()` on the `ScheduleHandle` to modify a Schedule.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-go/blob/add-go-schedule-sample/schedule/update/main_dacx.go\">View source code</a>\n\n```go\nfunc main() {\n// ...\n\tupdateSchedule := func(input client.ScheduleUpdateInput) (*client.ScheduleUpdate, error) {\n\t\treturn &client.ScheduleUpdate{\n\t\t\tSchedule:  &input.Description.Schedule,\n\t\t}, nil\n\t}\n\n\t_ = scheduleHandle.Update(ctx, client.ScheduleUpdateOptions{\n\t\tDoUpdate: updateSchedule,\n\t})\n}\n// ...\n```\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go.md","id":"go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go","title":"How to upsert custom Search Attributes to Workflow during Execution","label":"How to upsert custom Search Attributes to Workflow during Execution","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nIn advanced cases, you may want to dynamically update these attributes as the Workflow progresses.\n[UpsertSearchAttributes](https://pkg.go.dev/go.temporal.io/sdk/workflow#UpsertSearchAttributes) is used to add or update Search Attributes from within Workflow code.\n\n`UpsertSearchAttributes` will merge attributes to the existing map in the Workflow.\nConsider this example Workflow code:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n\n    attr1 := map[string]interface{}{\n        \"CustomIntField\": 1,\n        \"CustomBoolField\": true,\n    }\n    workflow.UpsertSearchAttributes(ctx, attr1)\n\n    attr2 := map[string]interface{}{\n        \"CustomIntField\": 2,\n        \"CustomKeywordField\": \"seattle\",\n    }\n    workflow.UpsertSearchAttributes(ctx, attr2)\n}\n```\n\nAfter the second call to `UpsertSearchAttributes`, the map will contain:\n\n```go\nmap[string]interface{}{\n    \"CustomIntField\": 2, // last update wins\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"seattle\",\n}\n```\n","is_empty":false},{"file_name":"how-to-use-a-custom-payload-codec-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-use-a-custom-payload-codec-in-go.md","id":"go/how-to-use-a-custom-payload-codec-in-go","title":"How to use a custom Payload Codec in Go","description":"Create a custom `PayloadCodec` implementation and define your encryption/compression and decryption/decompression logic in the `Encode` and `Decode` functions.","label":"Custom Payload Codec","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\n**Create a custom Payload Codec**\n\nCreate a custom [PayloadCodec](https://pkg.go.dev/go.temporal.io/sdk/converter#PayloadCodec) implementation and define your encryption/compression and decryption/decompression logic in the `Encode` and `Decode` functions.\n\nThe Payload Codec converts bytes to bytes.\nIt must be used in an instance of [CodecDataConverter](https://pkg.go.dev/go.temporal.io/sdk/converter#CodecDataConverter) that wraps a Data Converter to do the [Payload](/concepts/what-is-a-payload) conversions, and applies the custom encoding and decoding in `PayloadCodec` to the converted Payloads.\n\nThe following example from the [Data Converter sample](https://github.com/temporalio/samples-go/blob/main/codec-server/data_converter.go) shows how to create a custom `NewCodecDataConverter` that wraps an instance of a Data Converter with a custom `PayloadCodec`.\n\n```go\n// Create an instance of Data Converter with your codec.\nvar DataConverter = converter.NewCodecDataConverter(\n\tconverter.GetDefaultDataConverter(),\n\tNewPayloadCodec(),\n)\n//...\n// Create an instance of PaylodCodec.\nfunc NewPayloadCodec() converter.PayloadCodec {\n\treturn &Codec{}\n}\n```\n\nImplement your encryption/compression logic in the `Encode` function and the decryption/decompression logic in the `Decode` function in your custom `PayloadCodec`, as shown in the following example.\n\n```go\n// Codec implements converter.PayloadEncoder for snappy compression.\ntype Codec struct{}\n\n// Encode implements converter.PayloadCodec.Encode.\nfunc (Codec) Encode(payloads []*commonpb.Payload) ([]*commonpb.Payload, error) {\n\tresult := make([]*commonpb.Payload, len(payloads))\n\tfor i, p := range payloads {\n\t\t// Marshal proto\n\t\torigBytes, err := p.Marshal()\n\t\tif err != nil {\n\t\t\treturn payloads, err\n\t\t}\n\t\t// Compress\n\t\tb := snappy.Encode(nil, origBytes)\n\t\tresult[i] = &commonpb.Payload{\n\t\t\tMetadata: map[string][]byte{converter.MetadataEncoding: []byte(\"binary/snappy\")},\n\t\t\tData:     b,\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// Decode implements converter.PayloadCodec.Decode.\nfunc (Codec) Decode(payloads []*commonpb.Payload) ([]*commonpb.Payload, error) {\n\tresult := make([]*commonpb.Payload, len(payloads))\n\tfor i, p := range payloads {\n\t\t// Decode only if it's our encoding\n\t\tif string(p.Metadata[converter.MetadataEncoding]) != \"binary/snappy\" {\n\t\t\tresult[i] = p\n\t\t\tcontinue\n\t\t}\n\t\t// Uncompress\n\t\tb, err := snappy.Decode(nil, p.Data)\n\t\tif err != nil {\n\t\t\treturn payloads, err\n\t\t}\n\t\t// Unmarshal proto\n\t\tresult[i] = &commonpb.Payload{}\n\t\terr = result[i].Unmarshal(b)\n\t\tif err != nil {\n\t\t\treturn payloads, err\n\t\t}\n\t}\n\n\treturn result, nil\n}\n```\n\n**Set Data Converter to use custom Payload Codec**\n\nSet your custom `PayloadCodec` with an instance of `DataConverter` in your `Dial` client options that you use to create the client.\n\nThe following example shows how to set your custom Data Converter from a package called `mycodecpackage`.\n\n```go\n//...\nc, err := client.Dial(client.Options{\n\t\t// Set DataConverter here to ensure that Workflow inputs and results are\n\t\t// encoded as required.\n\t\tDataConverter: mycodecpackage.DataConverter,\n\t})\n//...\n```\n\nFor reference, see the following samples:\n\n- [Codec server](https://github.com/temporalio/samples-go/tree/main/codec-server)\n- [Encryption](https://github.com/temporalio/samples-go/tree/main/encryption)\n","is_empty":false},{"file_name":"how-to-use-a-custom-payload-converter-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-use-a-custom-payload-converter-in-go.md","id":"go/how-to-use-a-custom-payload-converter-in-go","title":"How to use a custom Payload Converter in Go","description":"Use a `CompositeDataConverter` to apply custom `PayloadConverter` in a specified order.","label":"Custom Payload Converter","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nUse [CompositeDataConverter](https://pkg.go.dev/go.temporal.io/sdk/converter#CompositeDataConverter) to apply custom, type-specific Payload Converters in a specified order.\n\n`NewCompositeDataConverter` creates a new instance of `CompositeDataConverter` from an ordered list of type-specific Payload Converters.\nThe following type-specific Payload Converters are available in the Go SDK, listed in the order that they are applied by the default Data Converter:\n\n- [NewNilPayloadConverter()](https://pkg.go.dev/go.temporal.io/sdk/converter#NilPayloadConverter.ToString)\n- [NewByteSlicePayloadConverter()](https://pkg.go.dev/go.temporal.io/sdk/converter#ByteSlicePayloadConverter)\n- [NewProtoJSONPayloadConverter()](https://pkg.go.dev/go.temporal.io/sdk/converter#ProtoJSONPayloadConverter)\n- [NewProtoPayloadConverter()](https://pkg.go.dev/go.temporal.io/sdk/converter#ProtoPayloadConverter)\n- [NewJSONPayloadConverter()](https://pkg.go.dev/go.temporal.io/sdk/converter#JSONPayloadConverter)\n\nThe order in which the Payload Converters are applied is important because during serialization the Data Converter tries the Payload Converters in that specific order until a Payload Converter returns a non-nil Payload.\n\nA custom [`PayloadConverter`](https://pkg.go.dev/go.temporal.io/sdk/converter#PayloadConverter) must implement functions `FromPayload` (for a single value) or `FromPayloads` (for a list of values) to convert to values from a Payload, and `ToPayload` (for a single value) or `ToPayloads` (for a list of values) to convert values to a Payload.\n\nTo set your custom Payload Converter, use [`NewCompositeDataConverter`](https://pkg.go.dev/go.temporal.io/sdk/converter#NewCompositeDataConverter) and set it as the Data Converter in the Client options.\n\n- To replace the default Data Converter with a custom `NewCompositeDataConverter`, use the following.\n\n  ```go\n  dataConverter := converter.NewCompositeDataConverter(YourCustomPayloadConverter())\n  ```\n\n- To add your custom type conversion to the default Data Converter, use the following to keep the defaults but set yours just before the default JSON fall through.\n\n  ```go\n  dataConverter := converter.NewCompositeDataConverter(\n    converter.NewNilPayloadConverter(),\n    converter.NewByteSlicePayloadConverter(),\n    converter.NewProtoJSONPayloadConverter(),\n    converter.NewProtoPayloadConverter(),\n    YourCustomPayloadConverter(),\n    converter.NewJSONPayloadConverter(),\n  )\n  ```\n","is_empty":false},{"file_name":"how-to-use-queries-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-use-queries-in-go.md","id":"go/how-to-use-queries-in-go","title":"How to use Queries in Go","description":"A Query is sent from a Temporal Client to a Workflow Execution and is identified by its name.","label":"Queries","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nimport QueryType from './how-to-define-a-query-type-in-go.md'\n\n<QueryType/>\n\n### Send Query\n\nimport SendQuery from './how-to-send-a-query-to-a-workflow-execution-in-go.md'\n\n<SendQuery/>\n\n### Handle Query\n\nimport HandleQuery from './how-to-handle-a-query-in-a-workflow-in-go.md'\n\n<HandleQuery/>\n","is_empty":false},{"file_name":"how-to-use-test-frameworks-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-use-test-frameworks-in-go.md","id":"go/how-to-use-test-frameworks-in-go","title":"How to use the test framework in Go","description":"To use the test framework in Go, import `helloworld_test.go`.","label":"Test Framework","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nTo use the test framework in Go, import the following packages, use the [samples-go repo](https://github.com/temporalio/samples-go/), and run `go test ./helloworld` to run these sample tests.\n\n[helloworld/helloworld_test.go](https://github.com/temporalio/samples-go/blob/main/helloworld/helloworld_test.go)\n","is_empty":false},{"file_name":"how-to-use-the-go-sdk.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-use-the-go-sdk.md","id":"go/how-to-use-the-go-sdk","title":"How to use the Temporal Go SDK","description":"Add the Temporal Go SDK to your project.","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\n[![Build Status](https://badge.buildkite.com/ce6df3b1a8b375270261ae70fb2d2756af298fef3a0dac4d20.svg?theme=github&branch=master)](https://buildkite.com/temporal/temporal-go-client) [![Coverage Status](https://coveralls.io/repos/github/temporalio/temporal-go-sdk/badge.svg?branch=master)](https://coveralls.io/github/temporalio/temporal-go-sdk?branch=master) [![Go reference](https://pkg.go.dev/badge/go.temporal.io/sdk)](https://pkg.go.dev/go.temporal.io/sdk)\n\nAdd the [Temporal Go SDK](https://github.com/temporalio/sdk-go) to your project:\n\n```bash\ngo get go.temporal.io/sdk\n```\n\nOr clone the Go SDK repo to your preferred location:\n\n```bash\ngit clone git@github.com:temporalio/sdk-go.git\n```\n","is_empty":false},{"file_name":"how-to-use-worker-versioning-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/how-to-use-worker-versioning-in-go.md","id":"go/how-to-use-worker-versioning-in-go","title":"How to use Worker Versioning in Go","description":"Version your Go Workers by using build ID–based versioning","label":"Worker Versioning","tags":["go","how-to"],"ssdi":[],"markdown_content":"\nTo use Worker Versioning in Go, you need to do the following:\n\n1. Determine and assign a Build ID to your built Worker code, and opt in to versioning.\n2. Tell the Task Queue your Worker is listening on about that Build ID, and whether its compatible with an existing Build ID.\n\n### Assign a Build ID to your Worker\n\nLet's say you've chosen `deadbeef` as your Build ID, which might be a short git commit hash (a reasonable choice as Build ID).\nTo assign it in your Worker code, you assign the following Worker Options:\n\n```go\n// ...\nworkerOptions := worker.Options{\n   BuildID: \"deadbeef\",\n   UseBuildIDForVersioning: true,\n// ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\nThat's all you need to do in your Worker code.\nImportantly, if you start this Worker, it won't receive any tasks.\nThat's because you need to tell the Task Queue about your Worker's Build ID first.\n\n### Tell the Task Queue about your Worker's Build ID\n\nNow you can use the SDK (or the Temporal CLI) to tell the Task Queue about your Worker's Build ID.\nYou might want to do this as part of your CI deployment process.\n\n```go\n// ...\nerr := client.UpdateWorkerBuildIdCompatibility(ctx, &client.UpdateWorkerBuildIdCompatibilityOptions{\n   TaskQueue: \"your_task_queue_name\",\n   Operation: &client.BuildIDOpAddNewIDInNewDefaultSet{\n      BuildID: \"deadbeef\",\n   },\n})\n```\n\nThis code adds the `deadbeef` Build ID to the Task Queue as the sole version in a new version set, which becomes the default for the queue.\nNew Workflows execute on Workers with this Build ID, and existing ones will continue to process by appropriately compatible Workers.\n\nIf, instead, you want to add the Build ID to an existing compatible set, you can do this:\n\n```go\n// ...\nerr := client.UpdateWorkerBuildIdCompatibility(ctx, &client.UpdateWorkerBuildIdCompatibilityOptions{\n   TaskQueue: \"your_task_queue_name\",\n   Operation: &client.BuildIDOpAddNewCompatibleVersion{\n      BuildID:                   \"deadbeef\",\n      ExistingCompatibleBuildId: \"some-existing-build-id\",\n   },\n})\n```\n\nThis code adds `deadbeef` to the existing compatible set containing `some-existing-build-id` and marks it as the new default Build ID for that set.\n\nYou can also promote an existing Build ID in a set to be the default for that set:\n\n```go\n// ...\nerr := client.UpdateWorkerBuildIdCompatibility(ctx, &client.UpdateWorkerBuildIdCompatibilityOptions{\n   TaskQueue: \"your_task_queue_name\",\n   Operation: &client.BuildIDPromoteIDWithinSet{\n      BuildID: \"some-existing-build-id\",\n   },\n})\n```\n\nYou can also promote an entire set to become the default set for the queue. New Workflows will start using that set's default.\n\n```go\n// ...\nerr := client.UpdateWorkerBuildIdCompatibility(ctx, &client.UpdateWorkerBuildIdCompatibilityOptions{\n   TaskQueue: \"your_task_queue_name\",\n   Operation: &client.BuildIDPromoteSet{\n      BuildID: \"some-existing-build-id\",\n   },\n})\n```\n\n### Specify versions for Commands\n\nBy default, Activities, Child Workflows, and Continue-as-New use the same compatible version set as the Workflow that invoked them if they're also using the same Task Queue.\n\nIf you want to override this behavior, you can specify your intent via the `VersioningIntent` field on the appropriate options struct.\n\n<!-- For more information refer to the [conceptual documentation](/concepts/what-is-worker-versioning). -->\n\nFor example, if you want to use the latest default version for an Activity, do the following inside your Workflow code:\n\n```go\n// ...\nao := workflow.ActivityOptions{\n    VersioningIntent: VersioningIntentDefault,\n    // ...other options\n}\nactivityCtx := workflow.WithActivityOptions(ctx, ao)\nvar yourActivityResult YourActivityResultType\nerr := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\n// ...\n```\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/index.md","id":"go/index","title":"How to use the Temporal Go SDK","description":"Add the Temporal Go SDK to your project.","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\n:::caution Legacy docs set\n\nThe information provided in this documentation set is intended to be available in the [Developer's guide](/dev-guide).\n\nHowever, the guide is still a work in progress.\nAlthough much of the information is already represented there, if you can't find what you are looking for, we still encourage you to check this legacy docs set.\n\n:::\n\n[![Build Status](https://badge.buildkite.com/ce6df3b1a8b375270261ae70fb2d2756af298fef3a0dac4d20.svg?theme=github&branch=master)](https://buildkite.com/temporal/temporal-go-client) [![Coverage Status](https://coveralls.io/repos/github/temporalio/temporal-go-sdk/badge.svg?branch=master)](https://coveralls.io/github/temporalio/temporal-go-sdk?branch=master) [![Go reference](https://pkg.go.dev/badge/go.temporal.io/sdk)](https://pkg.go.dev/go.temporal.io/sdk)\n\nAdd the [Temporal Go SDK](https://github.com/temporalio/sdk-go) to your project:\n\n```bash\ngo get go.temporal.io/sdk\n```\n\nOr clone the Go SDK repo to your preferred location:\n\n```bash\ngit clone git@github.com:temporalio/sdk-go.git\n```\n","is_empty":false},{"file_name":"listen-to-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/listen-to-heartbeats.md","id":"go/listen-to-heartbeats","title":"Listen to Heartbeats","description":"When an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.","label":"Listen to Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.\n","is_empty":false},{"file_name":"logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/logging.md","id":"go/logging","title":"How to log from a Workflow","description":"Send logs and errors to a logging service, so that when things go wrong, you can see what happened.","label":"Logging","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nThe SDK core uses `WARN` for its default logging level.\n","is_empty":false},{"file_name":"manage-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/manage-namespaces.md","id":"go/manage-namespaces","title":"How to manage Namespaces","description":"You can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.","label":"Manage Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can manage your registered Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"max-concurrent-sessions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/max-concurrent-sessions.md","id":"go/max-concurrent-sessions","title":"How to change the maximum concurrent Sessions of a Worker.","description":"You can adjust the maximum concurrent Sessions of a Worker.","label":"Max concurrent Sessions","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can adjust the maximum concurrent Sessions of a Worker.\n","is_empty":false},{"file_name":"metrics.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/metrics.md","id":"go/metrics","title":"How to emit metrics","description":"Each Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.","label":"Metrics","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.\nFor a complete list of metrics capable of being emitted, see the [SDK metrics reference](/references/sdk-metrics).\n\nMetrics can be scraped and stored in time series databases, such as:\n\n- [Prometheus](https://prometheus.io/docs/introduction/overview/)\n- [M3db](https://m3db.io/docs/)\n- [statsd](https://github.com/statsd/statsd)\n\nTemporal also provides a dashboard you can integrate with graphing services like [Grafana](https://grafana.com/docs/). For more information, see:\n\n- Temporal's implementation of the [Grafana dashboard](https://github.com/temporalio/dashboards)\n- [How to export metrics in Grafana](https://github.com/temporalio/helm-charts#exploring-metrics-via-grafana)\n","is_empty":false},{"file_name":"mock-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/mock-activities.md","id":"go/mock-activities","title":"How to mock Activities","description":"Mock an Activity by providing mock Activity implementations to the Worker.","label":"Mock Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMock the Activity invocation when unit testing your Workflows.\n\nWhen integration testing Workflows with a Worker, you can mock Activities by providing mock Activity implementations to the Worker.\n","is_empty":false},{"file_name":"mutable-side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/mutable-side-effects.md","id":"go/mutable-side-effects","title":"Mutable Side Effects","description":"Mutable Side Effects are a method of execution to produce non-deterministic code.","label":"Mutable Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMutable Side Effects execute the provided function once, and then it looks up the History of the value with the given Workflow ID.\n\n- If there is no existing value, then it records the function result as a value with the given Workflow Id on the History.\n- If there is an existing value, then it compares whether the existing value from the History has changed from the new function results, by calling the equals function.\n  - If the values are equal, then it returns the value without recording a new Marker Event\n  - If the values aren't equal, then it records the new value with the same ID on the History.\n\n:::note\n\nDuring a Workflow Execution, every new Side Effect call results in a new Marker recorded on the Workflow History; whereas Mutable Side Effects only records a new Marker on the Workflow History if the value for the Side Effect ID changes or is set the first time.\n\nDuring a Replay, Mutable Side Effects will not execute the function again. Instead, it returns the exact same value that was returned during the Workflow Execution.\n\n:::\n","is_empty":false},{"file_name":"namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/namespaces.md","id":"go/namespaces","title":"How to create and manage Namespaces","description":"You can create, update, deprecate or delete your Namespaces using either tctl or SDK APIs..","label":"Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can create, update, deprecate or delete your [Namespaces](/concepts/what-is-a-namespace) using either tctl or SDK APIs.\n\nUse Namespaces to isolate your Workflow Executions according to your needs.\nFor example, you can use Namespaces to match the development lifecycle by having separate `dev` and `prod` Namespaces.\nYou could also use them to ensure Workflow Executions between different teams never communicate - such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) to create and manage a Namespace from the UI, or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces from the command-line interface.\n\nOn self-hosted Temporal Cluster, you can register and manage your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"observability.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/observability.md","id":"go/observability","title":"How to use Temporal Observability features","description":"The observability section of the Temporal Developer's guide covers the many ways to view the current state of your Temporal Application—that is, ways to view which Workflow Executions are tracked by the Temporal Platform and the state of any specified Workflow Execution, either currently or at points of an execution","label":"Observability","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe observability section of the Temporal Developer's guide covers the many ways to view the current state of your [Temporal Application](/concepts/what-is-a-temporal-application)—that is, ways to view which [Workflow Executions](/workflows#workflow-execution) are tracked by the [Temporal Platform](/concepts/what-is-the-temporal-platform) and the state of any specified Workflow Execution, either currently or at points of an execution.\n\nThis section covers features related to viewing the state of the application, including:\n\n- [Metrics](#metrics)\n- [Tracing](#tracing)\n- [Logging](#logging)\n- [Visibility](#visibility)\n","is_empty":false},{"file_name":"parent-close-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/parent-close-policy.md","id":"go/parent-close-policy","title":"How to set a Parent Close Policy","description":"A Parent Close Policy determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).","label":"Parent Close Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Parent Close Policy](/concepts/what-is-a-parent-close-policy) determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).\n\nThe default Parent Close Policy option is set to terminate the Child Workflow Execution.\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/queries.md","id":"go/queries","title":"How to develop with Queries","description":"A Query is a synchronous operation that is used to get the state of a Workflow Execution.","label":"Queries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Query](/concepts/what-is-a-query) is a synchronous operation that is used to get the state of a Workflow Execution.\n","is_empty":false},{"file_name":"reference-activityoptions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/reference-activityoptions.md","id":"go/activityoptions-reference","title":"Go ActivityOptions reference","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package and use `WithActivityOptions()` to apply it to the instance of `workflow.Context`.","label":"Activity Options reference","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nCreate an instance of [`ActivityOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ActivityOptions) from the `go.temporal.io/sdk/workflow` package and use [`WithActivityOptions()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithActivityOptions) to apply it to the instance of `workflow.Context`.\n\nThe instance of `workflow.Context` is then passed to the `ExecuteActivity()` call.\n\n| Field                                               | Required                          | Type                                                                        |\n| --------------------------------------------------- | --------------------------------- | --------------------------------------------------------------------------- |\n| [`ActivityID`](#activityid)                         | No                                | `string`                                                                    |\n| [`TaskQueueName`](#taskqueuename)                   | No                                | `string`                                                                    |\n| [`ScheduleToCloseTimeout`](#scheduletoclosetimeout) | Yes (or `StartToCloseTimeout`)    | `time.Duration`                                                             |\n| [`ScheduleToStartTimeout`](#scheduletostarttimeout) | No                                | `time.Duration`                                                             |\n| [`StartToCloseTimeout`](#scheduletoclosetimeout)    | Yes (or `ScheduleToCloseTimeout`) | `time.Duration`                                                             |\n| [`HeartbeatTimeout`](#heartbeattimeout)             | No                                | `time.Duration`                                                             |\n| [`WaitForCancellation`](#waitforcancellation)       | No                                | `bool`                                                                      |\n| [`OriginalTaskQueueName`](#originaltaskqueuename)   | No                                | `string`                                                                    |\n| [`RetryPolicy`](#retrypolicy)                       | No                                | [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy) |\n\n#### ActivityID\n\n- Type: `string`\n- Default: None\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ActivityID: \"your-activity-id\",\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n- [What is an Activity Id](/concepts/what-is-an-activity-id)\n\n#### TaskQueueName\n\n- Type: `string`\n- Default: Inherits the TaskQueue name from the Workflow.\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  TaskQueueName: \"your-task-queue-name\",\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n- [What is a Task Queue](/concepts/what-is-a-task-queue)\n\n#### ScheduleToCloseTimeout\n\nTo set a [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `time.Duration`\n- Default: ∞ (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n#### ScheduleToStartTimeout\n\nTo set a [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: `time.Duration`\n- Default: ∞ (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n#### StartToCloseTimeout\n\nTo set a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `ScheduleToCloseTimeout` must be set.\n\n- Type: `time.Duration`\n- Default: Same as the `ScheduleToCloseTimeout`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  StartToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n#### HeartbeatTimeout\n\nTo set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  HeartbeatTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n#### WaitForCancellation\n\nIf `true` the Activity Execution will finish executing should there be a Cancellation request.\n\n- Type: `bool`\n- Default: `false`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  WaitForCancellation: false,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n#### OriginalTaskQueueName\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  OriginalTaskQueueName: \"your-original-task-queue-name\",\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n#### RetryPolicy\n\nTo set a [RetryPolicy](/concepts/what-is-a-retry-policy), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default:\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100, // 100 * InitialInterval\n  MaximumAttempts:    0, // Unlimited\n  NonRetryableErrorTypes: []string, // empty\n}\n```\n\nProviding a Retry Policy here is a customization that overwrites individual Field defaults.\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\n\nactivityoptions := workflow.ActivityOptions{\n  RetryPolicy: retrypolicy,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"reference-startworkflowoptions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/reference-startworkflowoptions.md","id":"go/startworkflowoptions-reference","title":"Go StartWorkflowOptions reference","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Options reference","tags":["developer-guide","options"],"ssdi":[],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, and pass the instance to the `ExecuteWorkflow` call.\n\nThe following fields are available:\n\n| Field                                                                                   | Required | Type                                                                                            |\n| --------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------- |\n| [`ID`](#id)                                                                             | No       | `string`                                                                                        |\n| [`TaskQueue`](#taskqueue)                                                               | **Yes**  | `string`                                                                                        |\n| [`WorkflowExecutionTimeout`](#workflowexecutiontimeout)                                 | No       | `time.Duration`                                                                                 |\n| [`WorkflowRunTimeout`](#workflowruntimeout)                                             | No       | `time.Duration`                                                                                 |\n| [`WorkflowTaskTimeout`](#workflowtasktimeout)                                           | No       | `time.Duration`                                                                                 |\n| [`WorkflowIDReusePolicy`](#workflowidreusepolicy)                                       | No       | [`WorkflowIdReusePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#WorkflowIdReusePolicy) |\n| [`WorkflowExecutionErrorWhenAlreadyStarted`](#workflowexecutionerrorwhenalreadystarted) | No       | `bool`                                                                                          |\n| [`RetryPolicy`](#retrypolicy)                                                           | No       | [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)                     |\n| [`CronSchedule`](#cronschedule)                                                         | No       | `string`                                                                                        |\n| [`Memo`](#memo)                                                                         | No       | `map[string]interface{}`                                                                        |\n| [`SearchAttributes`](#searchattributes)                                                 | No       | `map[string]interface{}`                                                                        |\n\n#### ID\n\nAlthough it is not required, we recommend providing your own [Workflow Id](/concepts/what-is-a-workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.\n\nCreate an instance of [StartWorkflowOptions](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: System generated UUID\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  ID: \"Your-Custom-Workflow-Id\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n#### TaskQueue\n\nCreate an instance of [StartWorkflowOptions](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None; this is a required field to be set by the developer\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  TaskQueue: \"your-task-queue\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n#### WorkflowExecutionTimeout\n\nCreate an instance of StartWorkflowOptions](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  WorkflowExecutionTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n#### WorkflowRunTimeout\n\nCreate an instance of [StartWorkflowOptions](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Same as [`WorkflowExecutionTimeout`](#workflowexecutiontimeout)\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowRunTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n#### WorkflowTaskTimeout\n\nCreate an instance of [StartWorkflowOptions](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: `time.Seconds * 10`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowTaskTimeout: time.Second * 10,\n  //...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n#### WorkflowIDReusePolicy\n\n- Type: [WorkflowIdReusePolicy](https://pkg.go.dev/go.temporal.io/api/enums/v1#WorkflowIdReusePolicy)\n- Default: `enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE`\n\nSet a value from the `go.temporal.io/api/enums/v1` package.\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowIdReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n#### WorkflowExecutionErrorWhenAlreadyStarted\n\n- Type: `bool`\n- Default: `false`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowExecutionErrorWhenAlreadyStarted: false,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n#### RetryPolicy\n\nCreate an instance of a [RetryPolicy](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy) from the `go.temporal.io/sdk/temporal` package and provide it as the value to the `RetryPolicy` field of the instance of `StartWorkflowOptions`.\n\n- Type: [RetryPolicy](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default: None\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\nworkflowOptions := client.StartWorkflowOptions{\n  RetryPolicy: retrypolicy,\n  // ...\n}\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n#### CronSchedule\n\n- Type: `string`\n- Default: None\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n[Sample](https://github.com/temporalio/samples-go/tree/master/cron)\n\n#### Memo\n\n- Type: `map[string]interface{}`\n- Default: Empty\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  Memo: map[string]interface{}{\n    \"description\": \"Test search attributes workflow\",\n  },\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n#### SearchAttributes\n\n**How to set Workflow Execution Search Attributes in Go**\n\n- Type: `map[string]interface{}`\n- Default: Empty.\n\nThese are the corresponding [Search Attribute value types](/visibility#types) in Go:\n\n- Keyword = string\n- Int = int64\n- Double = float64\n- Bool = bool\n- Datetime = time.Time\n- Text = string\n\n```go\nsearchAttributes := map[string]interface{}{\n  \"CustomIntField\": 1,\n  \"MiscData\": \"yellow\",\n}\nworkflowOptions := client.StartWorkflowOptions{\n  SearchAttributes: searchAttributes,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"register-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/register-namespaces.md","id":"go/register-namespaces","title":"How to register Namespaces","description":"On Temporal Cloud, use the Temporal Cloud UI or tcld commands, and on self-hosted Temporal Cluster, use `tctl namespace register` or `RegisterNamespaceRequest` API to create Namespaces.","label":"Register Namespace","tags":["guide-context"],"ssdi":[],"markdown_content":"\nRegistering a Namespace creates a Namespace on the Temporal Cluster or Temporal Cloud.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to create Namespaces.\n\nOn self-hosted Temporal Cluster, you can register your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n","is_empty":false},{"file_name":"registering-types.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/registering-types.md","id":"go/registering-types","title":"How to register types","description":"How to register Workflow and Activity Types","label":"Register types","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it fails that Task.\nHowever, the failure of the Task does not cause the associated Workflow Execution to fail.\n","is_empty":false},{"file_name":"remove-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/remove-search-attributes.md","id":"go/remove-search-attributes","title":"How to remove a Search Attribute from a Workflow","description":"To remove a Search Attribute that was previously set, set it to an empty array.","label":"Remove Search Attribute","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array: `[]`.\n","is_empty":false},{"file_name":"replays.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/replays.md","id":"go/replays","title":"How to Replay a Workflow Execution","description":"Replay recreates the exact state of a Workflow Execution.","label":"Replay","tags":["guide-context"],"ssdi":[],"markdown_content":"\nReplay recreates the exact state of a Workflow Execution.\nYou can replay a Workflow from the beginning of its Event History.\n\nReplay succeeds only if the [Workflow Definition](/concepts/what-is-a-workflow-definition) is compatible with the provided history from a deterministic point of view.\n\nWhen you test changes to your Workflow Definitions, we recommend doing the following as part of your CI checks:\n\n1. Determine which Workflow Types or Task Queues (or both) will be targeted by the Worker code under test.\n2. Download the Event Histories of a representative set of recent open and closed Workflows from each Task Queue, either programmatically using the SDK client or via `tctl`.\n3. Run the Event Histories through replay.\n4. Fail CI if any error is encountered during replay.\n\nThe following are examples of fetching and replaying Event Histories:\n","is_empty":false},{"file_name":"required-activity-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/required-activity-timeout.md","id":"go/required-activity-timeout","title":"How to set the required Activity Timeouts","description":"The only required value that needs to be set is either a Schedule-To-Close Timeout or a Start-To-Close Timeout","label":"Required timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nActivity Execution semantics rely on several parameters.\nThe only required value that needs to be set is either a [Schedule-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) or a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout).\nThese values are set in the Activity Options.\n","is_empty":false},{"file_name":"run-a-temporal-cloud-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/run-a-temporal-cloud-worker.md","id":"go/run-a-temporal-cloud-worker","title":"How to run a Temporal Cloud Worker","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run a Temporal Cloud Worker","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo run a Worker that uses [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"run-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/run-an-activity.md","id":"go/run-an-activity","title":"Run an Activity","description":"If an Activity references its context, you need to mock that context when testing in isolation.","label":"Run an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity references its context, you need to mock that context when testing in isolation.\n","is_empty":false},{"file_name":"schedule-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/schedule-to-close.md","id":"go/schedule-to-close","title":"How to set a Schedule-To-Close Timeout","description":"Use the Schedule-To-Close Timeout to limit the maximum duration of an Activity Execution.","label":"Schedule-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"schedule-to-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/schedule-to-start.md","id":"go/schedule-to-start","title":"How to set a Schedule-To-Start Timeout","description":"Use the Schedule-To-Start Timeout to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","label":"Schedule-To-Start Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.\n","is_empty":false},{"file_name":"schedules.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/schedules.md","id":"go/schedules","title":"How to Schedule a Workflow","description":"Schedule a Workflow.","label":"Schedule a Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nScheduling Workflows is a crucial aspect of any automation process, especially when dealing with time-sensitive tasks. By scheduling a Workflow, you can automate repetitive tasks, reduce the need for manual intervention, and ensure timely execution of your business processes\n\nUse any of the following action to help Schedule a Workflow Execution and take control over your automation process.\n","is_empty":false},{"file_name":"search-apis.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/search-apis.md","id":"go/search-apis","title":"Using Custom Searchable Attributes in Go","label":"Search Attributes","ssdi":[],"markdown_content":"\n## Overview\n\nSearch Attributes enable complex and business-logic-focused search queries for Workflow Executions.\nThese are often queried through the Temporal Web UI, but you can also query from within your Workflow code.\n\nMany [Search Attributes](/concepts/what-is-a-search-attribute) are added to Workflow Executions by default.\nBut these are necessarily focused on Temporal internal state tracking.\n\nFor more debugging and monitoring, you might want to add your own domain-specific Search Attributes, such as `customerId` or `numItems`, that can serve as useful search filters.\n\nThe [Go SDK Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) offers APIs for configuring Search Attributes.\nThere are also APIs on the SDK client for listing Workflows by status.\nGo samples for Search Attributes can be found at [`temporalio/samples-go`](https://github.com/temporalio/samples-go/tree/master/searchattributes).\n\n## Value types\n\nHere are the [Search Attribute value types](/visibility#types) and their corresponding types in Go:\n\n- Bool = bool\n- Datetime = time.Time\n- Double = float64\n- Int = int64\n- Keyword = string\n- Text = string\n\n## Tagging Search Attributes at Workflow creation\n\nYou can provide key-value pairs as Search Attributes in [StartWorkflowOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions).\nIn Go, Search Attributes are represented as `map[string]interface{}`.\nThe value provided in the map must be the same type that was added to a Cluster.\n\nThis can be useful for tagging executions with useful attributes you may want to search up later. For example:\n\n```go\nfunc (c *Client) CallYourWorkflow(ctx context.Context, workflowID string, payload map[string]interface{}) error {\n    // ...\n    searchAttributes := map[string]interface{}{\n        \"CustomerId\": payload[\"customer\"],\n        \"MiscData\": payload[\"miscData\"]\n    }\n    options := client.StartWorkflowOptions{\n        ID:                 workflowID,\n        TaskQueue:          app.MyTaskQueue,\n        SearchAttributes:   searchAttributes\n    }\n    we, err := c.Client.ExecuteWorkflow(ctx, options, app.YourWorkflow, payload)\n    // ...\n}\n```\n\n## Upsert Search Attributes during Workflow Execution\n\nIn advanced cases, you may want to dynamically update these attributes as the Workflow progresses.\n[UpsertSearchAttributes](https://pkg.go.dev/go.temporal.io/sdk/workflow#UpsertSearchAttributes) is used to add or update Search Attributes from within Workflow code.\n\n`UpsertSearchAttributes` will merge attributes to the existing map in the Workflow.\nConsider this example Workflow code:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n\n    attr1 := map[string]interface{}{\n        \"CustomIntField\": 1,\n        \"CustomBoolField\": true,\n    }\n    workflow.UpsertSearchAttributes(ctx, attr1)\n\n    attr2 := map[string]interface{}{\n        \"CustomIntField\": 2,\n        \"CustomKeywordField\": \"seattle\",\n    }\n    workflow.UpsertSearchAttributes(ctx, attr2)\n}\n```\n\nAfter the second call to `UpsertSearchAttributes`, the map will contain:\n\n```go\nmap[string]interface{}{\n    \"CustomIntField\": 2, // last update wins\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"seattle\",\n}\n```\n\n## Removing Search Attributes\n\n**There is no support for removing a field.**\n\nHowever, to achieve a similar effect, set the field to some placeholder value.\nFor example, you could set `CustomKeywordField` to `impossibleVal`.\nThen searching `CustomKeywordField != 'impossibleVal'` will match Workflows with `CustomKeywordField` not equal to `impossibleVal`, which includes Workflows without the `CustomKeywordField` set.\n\n## Retrieving Search Attributes\n\nUse the `SearchAttributes` property of `workflow.GetInfo` to get a specific Search Attribute:\n\n```go\n// Get search attributes that were provided when workflow was started.\ninfo := workflow.GetInfo(ctx)\nval := info.SearchAttributes.IndexedFields[\"CustomIntField\"]\n```\n\n## Querying Search Attributes within a Workflow\n\nYou can programmatically retrieve attributes from a Workflow Execution with `GetSearchAttributes`, and log out all fields with `GetIndexedFields`:\n\n```go\nsearchAttributes := workflowExecution.GetSearchAttributes()\nvar builder strings.Builder\nfor k, v := range searchAttributes.GetIndexedFields() {\n    var currentVal interface{}\n    err := converter.GetDefaultDataConverter().FromPayload(v, &currentVal)\n    if err != nil {\n        logger.Error(fmt.Sprintf(\"Get search attribute for key %s failed.\", k), \"Error\", err)\n        return err\n    }\n    builder.WriteString(fmt.Sprintf(\"%s=%v\\n\", k, currentVal))\n}\n```\n\n## Testing Search Attributes\n\nThe Go SDK's test suite comes with corresponding methods for mocking and asserting these operations:\n\n```go\nfunc Test_Workflow(t *testing.T) {\n\ttestSuite := &testsuite.WorkflowTestSuite{}\n\tenv := testSuite.NewTestWorkflowEnvironment()\n\tenv.RegisterActivity(ListExecutions)\n\n\t// mock search attributes on start\n\t_ = env.SetSearchAttributesOnStart(map[string]interface{}{\"CustomIntField\": 1})\n\n\t// mock upsert operations\n\tattributes := map[string]interface{}{\n\t\t\"CustomIntField\":      2, // update CustomIntField from 1 to 2, then insert other fields\n\t\t\"CustomKeywordField\":  \"Update1\",\n\t\t\"CustomBoolField\":     true,\n\t\t\"CustomDoubleField\":   3.14,\n\t\t\"CustomDatetimeField\": env.Now().UTC(),\n\t\t\"CustomStringField\":   \"String field is for text. When query, it will be tokenized for partial match. StringTypeField cannot be used in Order By\",\n\t}\n\tenv.OnUpsertSearchAttributes(attributes).Return(nil).Once()\n\n\tattributes = map[string]interface{}{\n\t\t\"CustomKeywordField\": \"Update2\",\n\t}\n\tenv.OnUpsertSearchAttributes(attributes).Return(nil).Once()\n\n\t// mock activity\n\tenv.OnActivity(ListExecutions, mock.Anything, mock.Anything).Return([]*workflowpb.WorkflowExecutionInfo{{}}, nil).Once()\n\n\tenv.ExecuteWorkflow(SearchAttributesWorkflow)\n\trequire.True(t, env.IsWorkflowCompleted())\n\trequire.NoError(t, env.GetWorkflowError())\n}\n```\n\n## Full Search Attributes example code\n\nYou can find full example Search Attributes sample code [in the Temporal `samples-go` repo](https://github.com/temporalio/samples-go/tree/master/searchattributes).\n","is_empty":false},{"file_name":"search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/search-attributes.md","id":"go/search-attributes","title":"How to use Search Attributes","description":"Search Attributes enable complex List Filters to find the exact of Workflow Executions you are looking for.","label":"Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe typical method of retrieving a Workflow Execution is by its Workflow Id.\n\nHowever, sometimes you'll want to retrieve one or more Workflow Executions based on another property. For example, imagine you want to get all Workflow Executions of a certain type that have failed within a time range, so that you can start new ones with the same arguments.\n\nYou can do this with [Search Attributes](/concepts/what-is-a-search-attribute).\n\n- [Default Search Attributes](/concepts/what-is-a-search-attribute#default-search-attributes) like `WorkflowType`, `StartTime` and `ExecutionStatus` are automatically added to Workflow Executions.\n- _Custom Search Attributes_ can contain their own domain-specific data (like `customerId` or `numItems`).\n  - A few [generic Custom Search Attributes](/concepts/what-is-a-search-attribute#custom-search-attributes) like `CustomKeywordField` and `CustomIntField` are created by default in Temporal's [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose).\n\nThe steps to using custom Search Attributes are:\n\n- Create a new Search Attribute in your Cluster using `tctl search-attribute create` or the Cloud UI.\n- Set the value of the Search Attribute for a Workflow Execution:\n  - On the Client by including it as an option when starting the Execution.\n  - In the Workflow by calling `UpsertSearchAttributes`.\n- Read the value of the Search Attribute:\n  - On the Client by calling `DescribeWorkflow`.\n  - In the Workflow by looking at `WorkflowInfo`.\n- Query Workflow Executions by the Search Attribute using a [List Filter](/concepts/what-is-a-list-filter):\n  - [In `tctl`](/tctl-v1/workflow/list).\n  - In code by calling `ListWorkflowExecutions`.\n\nHere is how to query Workflow Executions:\n","is_empty":false},{"file_name":"selectors.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/selectors.md","id":"go/selectors","title":"Go SDK Selectors","description":"Implementing Selectors in the Temporal Go SDK.","label":"Selectors","tags":["guide-context"],"ssdi":[],"markdown_content":"\n### Overview\n\nIn Go, the `select` statement lets a goroutine wait on multiple communication operations.\nA `select` **blocks until one of its cases can run**, then it executes that case.\nIt chooses one at random if multiple are ready.\n\nHowever, a normal Go select statement can not be used inside of Workflows directly because of the random nature.\nTemporal's Go SDK `Selector`s are similar and act as a replacement.\nThey can block on sending and receiving from Channels but as a bonus can listen on Future deferred work.\nUsage of Selectors to defer and process work (in place of Go's `select`) are necessary in order to ensure deterministic Workflow code execution (though using `select` in Activity code is fine).\n\n### Full API Example\n\nThe API is sufficiently different from `select` that it bears documenting:\n\n```go\nfunc SampleWorkflow(ctx workflow.Context) error {\n\t// standard Workflow setup code omitted...\n\n\t// API Example: declare a new selector\n\tselector := workflow.NewSelector(ctx)\n\n\t// API Example: defer code execution until the Future that represents Activity result is ready\n\twork := workflow.ExecuteActivity(ctx, ExampleActivity)\n\tselector.AddFuture(work, func(f workflow.Future) {\n\t\t// deferred code omitted...\n\t})\n\n\t// more parallel timers and activities initiated...\n\n\t// API Example: receive information from a Channel\n\tvar signalVal string\n\tchannel := workflow.GetSignalChannel(ctx, channelName)\n\tselector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {\n\t\t// matching on the channel doesn't consume the message.\n\t \t// So it has to be explicitly consumed here\n\t\tc.Receive(ctx, &signalVal)\n\t\t// do something with received information\n\t})\n\n\t// API Example: block until the next Future is ready to run\n\t// important! none of the deferred code runs until you call selector.Select\n\tselector.Select(ctx)\n\n\t// Todo: document selector.HasPending\n}\n```\n\n### Using Selectors with Futures\n\nYou usually add `Future`s after `Activities`:\n\n```go\n// API Example: defer code execution until after an activity is done\nwork := workflow.ExecuteActivity(ctx, ExampleActivity)\nselector.AddFuture(work, func(f workflow.Future) {\n\t// deferred code omitted...\n})\n```\n\n`selector.Select(ctx)` is the primary mechanism which blocks on and executes `Future` work.\nIt is intentionally flexible; you may call it conditionally or multiple times:\n\n```go\n\t// API Example: blocking conditionally\n  if somecondition != nil {\n\t\tselector.Select(ctx)\n  }\n\n\t// API Example: popping off all remaining Futures\n  for i := 0; i < len(someArray); i++ {\n\t\tselector.Select(ctx) // this will wait for one branch\n\t\t// you can interrupt execution here\n\t}\n```\n\nA Future matches only once per Selector instance even if Select is called multiple times.\nIf multiple items are available, the order of matching is not defined.\n\n#### Using Selectors with Timers\n\nAn important use case of futures is setting up a race between a timer and a pending activity, effectively adding a \"soft\" timeout that doesn't result in any errors or retries of that activity.\n\nFor example, [the Timer sample](https://github.com/temporalio/samples-go/blob/master/timer) shows how you can write a long running order processing operation where:\n\n- if processing takes too long, we send out a notification email to user about the delay, but we won't cancel the operation\n- if the operation finishes before the timer fires, then we want to cancel the timer.\n\n```go\nvar processingDone bool\nf := workflow.ExecuteActivity(ctx, OrderProcessingActivity)\nselector.AddFuture(f, func(f workflow.Future) {\n\tprocessingDone = true\n\t// cancel timerFuture\n\tcancelHandler()\n})\n\n// use timer future to send notification email if processing takes too long\ntimerFuture := workflow.NewTimer(childCtx, processingTimeThreshold)\nselector.AddFuture(timerFuture, func(f workflow.Future) {\n\tif !processingDone {\n\t\t// processing is not done yet when timer fires, send notification email\n\t\t_ = workflow.ExecuteActivity(ctx, SendEmailActivity).Get(ctx, nil)\n\t}\n})\n\n// wait the timer or the order processing to finish\nselector.Select(ctx)\n```\n\nWe create timers with the `workflow.NewTimer` API.\n\n### Using Selectors with Channels\n\n`selector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {})` is the primary mechanism which receives messages from `Channels`.\n\n```go\n// API Example: receive information from a Channel\nvar signalVal string\nchannel := workflow.GetSignalChannel(ctx, channelName)\nselector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {\n\tc.Receive(ctx, &signalVal)\n\t// do something with received information\n})\n```\n\nMerely matching on the channel doesn't consume the message; it has to be explicitly consumed with a `c.Receive(ctx, &signalVal)` call.\n\n### Querying Selector State\n\nYou can use the `selector.HasPending` API to ensure that signals are not lost when a Workflow is closed (e.g. by `ContinueAsNew`).\n\n### Learn More\n\nUsage of Selectors is best learned by example:\n\n- Setting up a race condition between an Activity and a Timer, and conditionally execute ([Timer example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/timer/workflow.go))\n- Receiving information in a Channel ([Mutex example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/mutex/mutex_workflow.go))\n- Looping through a list of work and scheduling them all in parallel ([DSL example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/dsl/workflow.go))\n- Executing activities in parallel, pick the first result, cancel remainder ([Pick First example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/pickfirst/pickfirst_workflow.go))\n","is_empty":false},{"file_name":"send-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/send-query.md","id":"go/send-query","title":"How to send a Query","description":"Queries are sent from a Temporal Client.","label":"Send Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are sent from a Temporal Client.\n","is_empty":false},{"file_name":"send-signal-from-client.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/send-signal-from-client.md","id":"go/send-signal-from-client","title":"How to send a Signal from a Temporal Client","description":"When a Signal is sent successfully from the Temporal Client, the WorkflowExecutionSignaled Event appears in the Event History of the Workflow that receives the Signal.","label":"Send Signal from Client","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen a Signal is sent successfully from the Temporal Client, the [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Event History of the Workflow that receives the Signal.\n","is_empty":false},{"file_name":"send-signal-from-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/send-signal-from-workflow.md","id":"go/send-signal-from-workflow","title":"How to send a Signal from a Workflow","description":"A Workflow can send a Signal to another Workflow, in which case it's called an External Signal","label":"Send Signal from Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.\n\nWhen an External Signal is sent:\n\n- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.\n- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.\n","is_empty":false},{"file_name":"set-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/set-custom-search-attributes.md","id":"go/set-custom-search-attributes","title":"How to set custom Search Attributes","description":"After you've created custom Search Attributes in your Cluster (using `tctl` or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.","label":"Custom Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAfter you've created custom Search Attributes in your Cluster (using `tctl search-attribute create`or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.\n","is_empty":false},{"file_name":"set-task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/set-task-queue.md","id":"go/set-task-queue","title":"How to set a Workflow's Task Queue","description":"In most SDKs, the only Workflow Option that must be set is the name of the Task Queue.","label":"Set Task Queue","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn most SDKs, the only Workflow Option that must be set is the name of the [Task Queue](/concepts/what-is-a-task-queue).\n\nFor any code to execute, a Worker Process must be running that contains a Worker Entity that is polling the same Task Queue name.\n","is_empty":false},{"file_name":"side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/side-effects.md","id":"go/side-effects","title":"Side Effects","description":"A Side Effect is used to produce non-deterministic code, such as generating a UUID or a random number.","label":"Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSide Effects are used to execute non-deterministic code, such as generating a UUID or a random number, without compromising deterministic in the Workflow. This is done by storing the non-deterministic results of the Side Effect into the Workflow [Event History](/workflows/#event-history).\n\nA Side Effect does not re-execute during a Replay. Instead, it returns the recorded result from the Workflow Execution Event History.\n\nSide Effects should not fail. An exception that is thrown from the Side Effect causes failure and retry of the current Workflow Task.\n\nAn Activity or a Local Activity may also be used instead of a Side effect, as its result is also persisted in Workflow Execution History.\n\n:::note\n\nYou shouldn’t modify the Workflow state inside a Side Effect function, because it is not reexecuted during Replay. Side Effect function should be used to return a value.\n\n:::\n","is_empty":false},{"file_name":"signal-with-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/signal-with-start.md","id":"go/signal-with-start","title":"How to Signal-With-Start","description":"Signal-With-Start is used from the Client","label":"Signal-With-Start","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSignal-With-Start is used from the Client.\nIt takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.\n\nIf there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/signals.md","id":"go/signals","title":"How to develop with Signals","description":"A Signal is a message sent to a running Workflow Execution","label":"Signals","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Signal](/concepts/what-is-a-signal) is a message sent to a running Workflow Execution.\n\nSignals are defined in your code and handled in your Workflow Definition.\nSignals can be sent to Workflow Executions from a Temporal Client or from another Workflow Execution.\n","is_empty":false},{"file_name":"skip-time-set-up.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/skip-time-set-up.md","id":"go/skip-time-set-up","title":"Set up time skipping","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Setting up","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to set up the time-skipping test framework in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/skip-time-skip-activities.md","id":"go/skip-time-skip-activities","title":"Skip time in Activities","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time in Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time in Activities in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-automatically.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/skip-time-skip-automatically.md","id":"go/skip-time-skip-automatically","title":"Skip time automatically","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Automatic method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can skip time automatically in the SDK of your choice.\nStart a test server process that skips time as needed.\nFor example, in the time-skipping mode, Timers, which include sleeps and conditional timeouts, are fast-forwarded except when Activities are running.\n","is_empty":false},{"file_name":"skip-time-skip-manually.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/skip-time-skip-manually.md","id":"go/skip-time-skip-manually","title":"Skip time manually","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Manual method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time manually in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/skip-time.md","id":"go/skip-time","title":"How to skip time","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSome long-running Workflows can persist for months or even years.\nImplementing the test framework allows your Workflow code to skip time and complete your tests in seconds rather than the Workflow's specified amount.\n\nFor example, if you have a Workflow sleep for a day, or have an Activity failure with a long retry interval, you don't need to wait the entire length of the sleep period to test whether the sleep function works.\nInstead, test the logic that happens after the sleep by skipping forward in time and complete your tests in a timely manner.\n\n:::note\n\nSkipping time is not relevant to unit testing Workflow code, because in that case you’re mocking functions that take time, like sleep and Activity calls.\n\n:::\n\nThe test framework included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.\nTime is a global property of an instance of `TestWorkflowEnvironment`: skipping time (either automatically or manually) applies to all currently running tests.\nIf you need different time behaviors for different tests, run your tests in a series or with separate instances of the test server.\nFor example, you could run all tests with automatic time skipping in parallel, and then all tests with manual time skipping in series, and then all tests without time skipping in parallel.\n","is_empty":false},{"file_name":"spawn-a-child-workflow-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/spawn-a-child-workflow-execution.md","id":"go/spawn-a-child-workflow-execution","title":"How to spawn a Child Workflow Execution in Go","description":"Use the `ExecuteChildWorkflow`, available from the `go.temporal.io/sdk/workflow` package, to spawn a Child Workflow Execution in Go.","label":"Child Workflow Execution","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nTo spawn a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) in Go, use the [`ExecuteChildWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ExecuteChildWorkflow) API, which is available from the `go.temporal.io/sdk/workflow` package.\n\nThe `ExecuteChildWorkflow` call requires an instance of [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context), with an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions) applied to it, the Workflow Type, and any parameters that should be passed to the Child Workflow Execution.\n\n`workflow.ChildWorkflowOptions` contain the same fields as `client.StartWorkflowOptions`.\nWorkflow Option fields automatically inherit their values from the Parent Workflow Options if they are not explicitly set.\nIf a custom `WorkflowID` is not set, one is generated when the Child Workflow Execution is spawned.\nUse the [`WithChildOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithChildOptions) API to apply Child Workflow Options to the instance of `workflow.Context`.\n\nThe `ExecuteChildWorkflow` call returns an instance of a [`ChildWorkflowFuture`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowFuture).\n\nCall the `.Get()` method on the instance of `ChildWorkflowFuture` to wait for the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{}\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  var result ChildResp\n  err := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{}).Get(ctx, &result)\n  if err != nil {\n    // ...\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\nTo asynchronously spawn a Child Workflow Execution, the Child Workflow must have an \"Abandon\" Parent Close Policy set in the Child Workflow Options.\nAdditionally, the Parent Workflow Execution must wait for the \"ChildWorkflowExecutionStarted\" event to appear in its event history before it completes.\n\nIf the Parent makes the `ExecuteChildWorkflow` call and then immediately completes, the Child Workflow Execution will not spawn.\n\nTo be sure that the Child Workflow Execution has started, first call the `GetChildWorkflowExecution` method on the instance of the `ChildWorkflowFuture`, which will return a different Future.\nThen call the `Get()` method on that Future, which is what will wait until the Child Workflow Execution has spawned.\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // Wait for the Child Workflow Execution to spawn\n  var childWE workflow.Execution\n  if err := childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE); err != nil {\n     return err\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n","is_empty":false},{"file_name":"spawn-a-workflow-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/spawn-a-workflow-execution.md","id":"go/spawn-a-workflow-execution","title":"How to spawn a Workflow Execution in Go","description":"Use the `ExecuteWorkflow()` method on the Go SDK `Client`, which is available via `Dial()` in the `go.temporal.io/sdk/client` package.","label":"Workflow Execution","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nTo spawn a [Workflow Execution](/workflows#workflow-execution), use the `ExecuteWorkflow()` method on the Go SDK [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nThe `ExecuteWorkflow()` API call requires an instance of [`context.Context`](https://pkg.go.dev/context#Context), an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions), a Workflow Type name, and all variables to be passed to the Workflow Execution.\nThe `ExecuteWorkflow()` call returns a Future, which can be used to get the result of the Workflow Execution.\n\n```go\npackage main\n\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n  workflowOptions := client.StartWorkflowOptions{\n    // ...\n  }\n  workflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n  if err != nil {\n    // ...\n  }\n  // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n}\n```\n\nIf the invocation process has access to the function directly, then the Workflow Type name parameter can be passed as if the function name were a variable, without quotations.\n\n```go\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n```\n\nIf the invocation process does not have direct access to the statically defined Workflow Definition, for example, if the Workflow Definition is in an un-importable package, or it is written in a completely different language, then the Workflow Type can be provided as a `string`.\n\n```go\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, \"YourWorkflowDefinition\", param)\n```\n","is_empty":false},{"file_name":"spawn-activity-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/spawn-activity-execution.md","id":"go/spawn-an-activity-execution","title":"How to spawn an Activity Execution in Go","description":"Use the `ExecuteActivity()` API call available from the `go.temporal.io/sdk/workflow` package.","label":"Activity Execution","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nTo spawn an [Activity Execution](/concepts/what-is-an-activity-execution), use the [`ExecuteActivity()`](https://pkg.go.dev/go.temporal.io/workflow#ExecuteActivity) API call inside your Workflow Definition.\nThe API is available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/workflow) package.\n\nThe `ExecuteActivity()` API call requires an instance of `workflow.Context`, the Activity function name, and any variables to be passed to the Activity Execution.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n  yourActivityParam := YourActivityParam{\n    // ...\n  }\n  var activities *YourActivityStruct\n  future := workflow.ExecuteActivity(ctx, activities.YourActivityDefinition, yourActivityParam)\n  // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n  // ...\n}\n```\n\nThe Activity function name can be provided as a variable object (no quotations) or as a string.\n\n```go\n// ...\n  future := workflow.ExecuteActivity(ctx, \"YourActivityDefinition\", yourActivityParam)\n// ...\n```\n\nThe benefit of passing the actual function object is that the framework can validate the parameters against the Activity Definition.\n\nThe `ExecuteActivity` call returns a Future, which can be used to get the result of the Activity Execution.\n","is_empty":false},{"file_name":"spawning-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/spawning-activities.md","id":"go/spawning-activities","title":"How to start an Activity Execution","description":"Calls to spawn Activity Executions are written within a Workflow Definition.","label":"Activity Execution","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCalls to spawn [Activity Executions](/concepts/what-is-an-activity-execution) are written within a [Workflow Definition](/concepts/what-is-a-workflow-definition).\nThe call to spawn an Activity Execution generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nThis results in the set of three [Activity Task](/concepts/what-is-an-activity-task) related Events ([ActivityTaskScheduled](/references/events/#activitytaskscheduled), [ActivityTaskStarted](/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.\n\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the Execution history.\nThe entire Execution history is transferred from the Temporal service to Workflow Workers when a Workflow state needs to recover.\nA large Execution history can thus adversely impact the performance of your Workflow.\n\nTherefore, be mindful of the amount of data you transfer through Activity invocation parameters or Return Values.\nOtherwise, no additional limitations exist on Activity implementations.\n","is_empty":false},{"file_name":"spawning-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/spawning-workflows.md","id":"go/spawning-workflows","title":"How to start a Workflow Execution","description":"Workflow Execution semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.","label":"Start Workflow Execution","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Workflow Execution](/workflows#workflow-execution) semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.\n\nIn the examples below, all Workflow Executions are started using a Temporal Client.\nTo spawn Workflow Executions from within another Workflow Execution, use either the [Child Workflow](#child-workflows) or External Workflow APIs.\n\nSee the [Customize Workflow Type](#customize-workflow-type) section to see how to customize the name of the Workflow Type.\n\nA request to spawn a Workflow Execution causes the Temporal Cluster to create the first Event ([WorkflowExecutionStarted](/references/events/#workflowexecutionstarted)) in the Workflow Execution Event History.\nThe Temporal Cluster then creates the first Workflow Task, resulting in the first [WorkflowTaskScheduled](/references/events/#workflowtaskscheduled) Event.\n","is_empty":false},{"file_name":"start-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/start-to-close.md","id":"go/start-to-close","title":"How to set a Start-To-Close Timeout","description":"Use the Start-To-Close Timeout to limit the maximum duration of a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) to limit the maximum duration of a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n","is_empty":false},{"file_name":"test-functions-assert-in-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/test-functions-assert-in-workflow.md","id":"go/test-functions-assert-in-workflow","title":"Assert in Workflow","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Assert in Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe `assert` statement is a convenient way to insert debugging assertions into the Workflow context.\n\nThe `assert` method is available in Python and TypeScript.\n","is_empty":false},{"file_name":"test-functions-in-workflow-context.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/test-functions-in-workflow-context.md","id":"go/test-functions-in-workflow-context","title":"Test functions in Workflow context","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Workflow context","tags":["guide-context"],"ssdi":[],"markdown_content":"\nFor a function or method to run in the Workflow context (where it’s possible to get the current Workflow info, or running inside the sandbox in the case of TypeScript or Python), it needs to be run by the Worker as if it were a Workflow.\n\n:::note\n\nThis section is applicable in Python and TypeScript.\nIn Python, we allow testing of Workflows only and not generic Workflow-related code.\n\n:::\n","is_empty":false},{"file_name":"testing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/testing-activities.md","id":"go/testing-activities","title":"Testing Activities","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn Activity can be tested with a mock Activity environment, which provides a way to mock the Activity context, listen to Heartbeats, and cancel the Activity.\nThis behavior allows you to test the Activity in isolation by calling it directly, without needing to create a Worker to run the Activity.\n\n## Mock and override Activities\n\nWhen running unit tests on Workflows, we want to test the Workflow logic in isolation. Additionally, we want to inject Activity errors during our test runs. The test framework provides two mechanisms that support these scenarios: Activity mocking and Activity overriding. Both of these mechanisms allow you to change the behavior of Activities invoked by your Workflow without the need to modify the actual Workflow code.\n\nLet's take a look at a test that simulates a test that fails via the \"Activity mocking\" mechanism.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n```\n\nThis test simulates the execution of the Activity `SimpleActivity` that is invoked by our Workflow `SimpleWorkflow` returning an error. We accomplish this by setting up a mock on the test environment for the `SimpleActivity` that returns an error.\n\n```go\ns.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n  \"\", errors.New(\"SimpleActivityFailure\"))\n```\n\nWith the mock set up we can now execute the Workflow via the `s.env.ExecuteWorkflow(...)` method and assert that the Workflow completed successfully and returned the expected error.\n\nSimply mocking the execution to return a desired value or error is a pretty powerful mechanism to isolate Workflow logic.\nHowever, sometimes we want to replace the Activity with an alternate implementation to support a more complex test scenario.\nLet's assume we want to validate that the Activity gets called with the correct parameters.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\nIn this example, we provide a function implementation as the parameter to `Return`.\nThis allows us to provide an alternate implementation for the Activity `SimpleActivity`.\nThe framework will execute this function whenever the Activity is invoked and pass on the return value from the function as the result of the Activity invocation.\n\nAdditionally, the framework will validate that the signature of the \"mock\" function matches the signature of the original Activity function.\n\nSince this can be an entire function, there is no limitation as to what we can do here. In this example, we assert that the `value` param has the same content as the value param we passed to the Workflow.\n","is_empty":false},{"file_name":"testing-frameworks.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/testing-frameworks.md","id":"go/testing-frameworks","title":"Test frameworks","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test frameworks","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Temporal Go SDK provides a test framework to facilitate testing Workflow implementations.\n\nThis framework is suited for implementing unit tests as well as functional tests of the Workflow logic.\n\n## Test setup\n\nTo run unit tests, we first define a test suite struct that absorbs both the basic suite functionality from [testify](https://pkg.go.dev/github.com/stretchr/testify/suite) via `suite.Suite` and the suite functionality from the Temporal test framework via `testsuite.WorkflowTestSuite`.\n\nBecause every test in this test suite will test our Workflow, we\nadd a property to our struct to hold an instance of the test environment. This allows us to initialize the test environment in a setup method.\n\nFor testing Workflows, we use a `testsuite.TestWorkflowEnvironment`.\n\n```go\ntype UnitTestSuite struct {\n        suite.Suite\n        testsuite.WorkflowTestSuite\n\n        env *testsuite.TestWorkflowEnvironment\n}\n```\n\nNext, we implement a `SetupTest` method to set up a new test environment before each test.\nDoing so ensures that each test runs in its own isolated sandbox.\n\n```go\nfunc (s *UnitTestSuite) SetupTest() {\n        s.env = s.NewTestWorkflowEnvironment()\n}\n```\n\nWe also implement an `AfterTest` function where we assert that all the mocks we set up were indeed called by invoking `s.env.AssertExpectations(s.T())`.\nTimeout for the entire test can be set using `SetTestTimeout` in the Workflow or Activity environment.\n\n```go\nfunc (s *UnitTestSuite) AfterTest(suiteName, testName string) {\n        s.env.AssertExpectations(s.T())\n}\n```\n\nFinally, we create a regular test function recognized by the `go test` command, and pass the struct to `suite.Run`.\n\n```go\nfunc TestUnitTestSuite(t *testing.T) {\n        suite.Run(t, new(UnitTestSuite))\n}\n```\n","is_empty":false},{"file_name":"testing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/testing-workflows.md","id":"go/testing-workflows","title":"Testing Workflows","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen running unit tests on Workflows, we want to test the Workflow logic in isolation.\nThe simplest test case we can write is to have the test environment execute the Workflow and then evaluate the results.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\nCalling `s.env.ExecuteWorkflow(...)` executes the Workflow logic and any invoked Activities inside the test process. The first parameter of `s.env.ExecuteWorkflow(...)` contains the Workflow functions, and any subsequent parameters contain values for custom input parameters declared by the Workflow.\n\n> Note that unless the Activity invocations are mocked or Activity implementation replaced (see [Activity mocking and overriding](#activity-mocking-and-overriding)), the test environment will execute the actual Activity code including any calls to outside services.\n\nAfter executing the Workflow in the above example, we assert that the Workflow ran through completion via the call to `s.env.IsWorkflowComplete()`. We also assert that no errors were returned by asserting on the return value of `s.env.GetWorkflowError()`.\nIf our Workflow returned a value, we could have retrieved that value via a call to `s.env.GetWorkflowResult(&value)` and had additional asserts on that value.\n\n## Query tests\n\n`TestWorkflowEnvironment` instances have a [`QueryWorkflow()` method](https://pkg.go.dev/go.temporal.io/temporal/internal#TestWorkflowEnvironment.QueryWorkflow) that lets you query the state of the currently running Workflow.\nFor example, suppose you have a Workflow that lets you query the progress of a long running task as shown below.\n\n```go\nfunc ProgressWorkflow(ctx workflow.Context, percent int) error {\n\tlogger := workflow.GetLogger(ctx)\n\n\terr := workflow.SetQueryHandler(ctx, \"getProgress\", func(input []byte) (int, error) {\n\t\treturn percent, nil\n\t})\n\tif err != nil {\n\t\tlogger.Info(\"SetQueryHandler failed.\", \"Error\", err)\n\t\treturn err\n\t}\n\n\tfor percent = 0; percent<100; percent++ {\n                // Important! Use `workflow.Sleep()`, not `time.Sleep()`, because Temporal's\n                // test environment doesn't stub out `time.Sleep()`.\n\t\tworkflow.Sleep(ctx, time.Second*1)\n\t}\n\n\treturn nil\n}\n```\n\nThis Workflow tracks the current progress of a task in percentage terms, and increments the percentage by 1 every second.\nBelow is how you would write a test case that queries this Workflow.\nNote that you should always query the Workflow either after `ExecuteWorkflow()` is done or in a `RegisterDelayedCallback()` callback, otherwise you'll get a `runtime error` panic.\n\n```go\nfunc (s *UnitTestSuite) Test_ProgressWorkflow() {\n\tvalue := 0\n\n\t// After 10 seconds plus padding, progress should be 10.\n\t// Note that `RegisterDelayedCallback()` doesn't actually make your test wait for 10 seconds!\n\t// Temporal's test framework advances time internally, so this test should take < 1 second.\n\ts.env.RegisterDelayedCallback(func() {\n\t\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\t\ts.NoError(err)\n\t\terr = res.Get(&value)\n\t\ts.NoError(err)\n\t\ts.Equal(10, value)\n\t}, time.Second*10+time.Millisecond*1)\n\n\ts.env.ExecuteWorkflow(ProgressWorkflow, 0)\n\n\ts.True(s.env.IsWorkflowCompleted())\n\n\t// Once the workflow is completed, progress should always be 100\n\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\ts.NoError(err)\n\terr = res.Get(&value)\n\ts.NoError(err)\n\ts.Equal(value, 100)\n}\n```\n\n:::note\n\n`RegisterDelayedCallback` can also be used to send [Signals](/concepts/what-is-a-signal).\nWhen using \"Signal-With-Start\", set the delay to `0`.\n:::\n","is_empty":false},{"file_name":"testing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/testing.md","id":"go/testing","title":"Testing","description":"The Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.","label":"Testing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.\n\nIn the context of Temporal, you can create these types of automated tests:\n\n- **End-to-end**: Running a Temporal Server and Worker with all its Workflows and Activities; starting and interacting with Workflows from a Client.\n- **Integration**: Anything between end-to-end and unit testing.\n  - Running Activities with mocked Context and other SDK imports (and usually network requests).\n  - Running Workers with mock Activities, and using a Client to start Workflows.\n  - Running Workflows with mocked SDK imports.\n- **Unit**: Running a piece of Workflow or Activity code (a function or method) and mocking any code it calls.\n\nWe generally recommend writing the majority of your tests as integration tests.\n\nBecause the test server supports skipping time, use the test server for both end-to-end and integration tests with Workers.\n","is_empty":false},{"file_name":"timers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/timers.md","id":"go/timers","title":"What is a Timer?","description":"A Timer lets a Workflow sleep for a fixed time period.","label":"Timers","tags":["guide-context","timers","sleep"],"ssdi":[],"markdown_content":"\nA Workflow can set a durable timer for a fixed time period.\nIn some SDKs, the function is called `sleep()`, and in others, it's called `timer()`.\n\nA Workflow can sleep for months.\nTimers are persisted, so even if your Worker or Temporal Cluster is down when the time period completes, as soon as your Worker and Cluster are back up, the `sleep()` call will resolve and your code will continue executing.\n\nSleeping is a resource-light operation: it does not tie up the process, and you can run millions of Timers off a single Worker.\n","is_empty":false},{"file_name":"tracing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/tracing.md","id":"go/tracing","title":"Tracing and Context Propagation","description":"Explains how the Go SDK supports tracing and custom context propogation.","label":"Tracing and Context Propogation","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Go SDK provides support for distributed tracing through [OpenTracing](https://opentracing.io/).\nTracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.\n\nTracing can be configured by providing an [opentracing.Tracer](https://pkg.go.dev/github.com/opentracing/opentracing-go#Tracer)\nimplementation in [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions) during client instantiation.\nFor more details on how to configure and leverage tracing, see the [OpenTracing documentation](https://opentracing.io/docs/getting-started/).\n\nThe OpenTracing support has been validated using [Jaeger](https://www.jaegertracing.io/), but other implementations mentioned [here](https://opentracing.io/docs/supported-tracers/) should also work.\nTracing functionality utilizes generic context propagation provided by the client.\n\n### Context Propagation\n\nTemporal provides a standard way to propagate a custom context across a Workflow.\nYou can configure a context propagator in via the [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions).\nThe context propagator extracts and passes on information present in `context.Context` and `workflow.Context` objects across the Workflow.\nOnce a context propagator is configured, you should be able to access the required values in the context objects as you would normally do in Go.\nYou can see how the Go SDK implements a [tracing context propagator](https://github.com/temporalio/sdk-go/blob/master/internal/tracer.go).\n\n#### Server-Side Headers\n\nOn the server side, Temporal provides a mechanism for propagating context across Workflow transitions called headers.\n\n```proto\nmessage Header {\n    map<string, Payload> fields = 1;\n}\n```\n\n`Client` leverages headers to pass around additional context information.\n[HeaderReader](https://pkg.go.dev/go.temporal.io/sdk/internal#HeaderReader) and [HeaderWriter](https://pkg.go.dev/go.temporal.io/sdk/internal#HeaderWriter) are interfaces that allow reading and writing to the Temporal Server headers.\nThe SDK includes [implementations](https://github.com/temporalio/sdk-go/blob/master/internal/headers.go) for these interfaces.\n`HeaderWriter` sets a value for a header.\nHeaders are held as a map, so setting a value for the same key will overwrite its previous value.\n`HeaderReader` gets a value of a header.\nIt also can iterate through all headers and execute the provided handler function on each header, so that your code can operate on select headers you need.\n\n```go\ntype HeaderWriter interface {\n\tSet(string, *commonpb.Payload)\n}\n\ntype HeaderReader interface {\n\tGet(string) (*commonpb.Payload, bool)\n\tForEachKey(handler func(string, *commonpb.Payload) error) error\n}\n```\n\n#### Context Propagators\n\nYou can propagate additional context through Workflow Execution by using a context propagator.\nA context propagator needs to implement the `ContextPropagator` interface that includes the following four methods:\n\n```go\ntype ContextPropagator interface {\n  Inject(context.Context, HeaderWriter) error\n\n  Extract(context.Context, HeaderReader) (context.Context, error)\n\n  InjectFromWorkflow(Context, HeaderWriter) error\n\n  ExtractToWorkflow(Context, HeaderReader) (Context, error)\n}\n```\n\n- `Inject` reads select context keys from a Go [context.Context](https://golang.org/pkg/context/#Context) object and writes them into the headers using the [HeaderWriter](https://pkg.go.dev/go.temporal.io/sdk/internal#HeaderWriter) interface.\n- `InjectFromWorkflow` operates similar to `Inject` but reads from a [workflow.Context](https://pkg.go.dev/go.temporal.io/sdk/internal#Context) object.\n- `Extract` picks select headers and put their values into the [context.Context](https://golang.org/pkg/context/#Context) object.\n- `ExtractToWorkflow` operates similar to `Extract` but write to a [workflow.Context](https://pkg.go.dev/go.temporal.io/sdk/internal#Context) object.\n\nThe [tracing context propagator](https://github.com/temporalio/sdk-go/blob/master/internal/tracer.go) shows a sample implementation of a context propagator.\n\n#### Is there a complete example?\n\nThe [context propagation sample](https://github.com/temporalio/samples-go/blob/master/ctxpropagation/) configures a custom context propagator and shows context propagation of custom keys across a Workflow and an Activity.\nIt also uses Jaeger for tracing.\n\n#### Can I configure multiple context propagators?\n\nYes. Multiple context propagators help to structure code with each propagator having its own scope of responsibility.\n\n### Useful Resources\n\n- [Passing Context with Temporal](https://spiralscout.com/blog/passing-context-with-temporal) by SpiralScout\n","is_empty":false},{"file_name":"updates.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/updates.md","id":"go/updates","title":"How to develop with Updates","description":"An Update is an operation that can mutate the state of a Workflow Execution and return a response.","label":"Updates","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn [Update](/concepts/what-is-an-update) is an operation that can mutate the state of a Workflow Execution and return a response.\n","is_empty":false},{"file_name":"upsert-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/upsert-custom-search-attributes.md","id":"go/upsert-custom-search-attributes","title":"How to upsert Search Attributes","description":"You can upsert Search Attributes to add or update Search Attributes from within Workflow code.","label":"Upsert Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can upsert Search Attributes to add or update Search Attributes from within Workflow code.\n","is_empty":false},{"file_name":"use-signals.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/use-signals.md","id":"go/use-signals","title":"How to use Signals in Go","description":"Use the `SignalWorkflow()` method on and instance of the Go SDK Temporal Client to send a Signal to a Workflow Execution.","label":"Signals","tags":["go","developer-guide"],"ssdi":[],"markdown_content":"\nTo use Signals in Go, first define your Signal type and then add a Signal handler to your Workflow Definition.\nSignals can then be sent via the Temporal Client or from within a Workflow.\n\n### Define Signal type\n\nStructs should be used to define Signals and carry data, as long as the struct is [serializable via the Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#CompositeDataConverter.ToPayload).\nThe `Receive()` method on the Data Converter decodes the data into the Struct within the Workflow.\nOnly public fields are serializable.\n\n```go\nMySignal struct {\n\tMessage string // serializable\n\tmessage string // not serializable\n}\n```\n\n### Handle Signal\n\n---\n\nid: how-to-handle-a-signal-in-go\ntitle: How to handle a Signal in Go\nsidebar_label: Handle Signal\ndescription: Use the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.\ntags:\n\n- go\n- how-to\n\n---\n\nUse the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.\nGet a new [`Selector`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Selector) and pass it the Signal Channel and a callback function to handle the payload.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  // ...\n  var signal MySignal\n  signalChan := workflow.GetSignalChannel(ctx, \"your-signal-name\")\n  selector := workflow.NewSelector(ctx)\n  selector.AddReceive(signalChan, func(channel workflow.ReceiveChannel, more bool) {\n      channel.Receive(ctx, &signal)\n      // ...\n  })\n  selector.Select(ctx)\n  if len(signal.Message) > 0 && signal.Message != \"SOME_VALUE\" {\n      return errors.New(\"signal\")\n  }\n  // ...\n}\n```\n\nIn the example above, the Workflow code uses `workflow.GetSignalChannel` to open a `workflow.Channel` for the Signal type (identified by the Signal name).\nWe then use a [`workflow.Selector`](/go/selectors) and the `AddReceive()` to wait on a Signal from this channel.\nThe `more` bool in the callback function indicates that channel is not closed and more deliveries are possible.\n\nBefore completing the Workflow or using [Continue-As-New](/go/continue-as-new), make sure to do an asynchronous drain on the Signal channel.\nOtherwise, the Signals will be lost.\n\n### Send Signal from Temporal Client\n\nUse the `SignalWorkflow()` method on an instance of the [Go SDK Temporal Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) to send a [Signal](/concepts/what-is-a-signal) to a [Workflow Execution](/workflows#workflow-execution).\n\nPass in both the [Workflow Id](/concepts/what-is-a-workflow-id) and [Run Id](/concepts/what-is-a-run-id) to uniquely identify the Workflow Execution.\nIf only the Workflow Id is supplied (provide an empty string as the Run Id param), the Workflow Execution that is Running receives the Signal.\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWorkflow(context.Background(), \"your-workflow-id\", runID, \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n// ...\n```\n\nPossible errors:\n\n- `serviceerror.NotFound`\n- `serviceerror.Internal`\n- `serviceerror.Unavailable`\n\n### Send Signal from within a Workflow\n\nA Signal can be sent from within a Workflow to a different Workflow Execution using the [`SignalExternalWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SignalExternalWorkflow) API from the `go.temporal.io/sdk/workflow` package.\n\n```go\n// ...\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  //...\n  signal := MySignal {\n    Message: \"Some important data\",\n  }\n  err :=  workflow.SignalExternalWorkflow(ctx, \"some-workflow-id\", \"\", \"your-signal-name\", signal).Get(ctx, nil)\n  if err != nil {\n    // ...\n  }\n// ...\n}\n```\n\n### Signal-With-Start\n\nUse the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.\n\nBecause the Workflow Execution might not exist, this API does not take a Run ID as a parameter\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWithStartWorkflow(context.Background(), \"your-workflow-id\", \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n```\n","is_empty":false},{"file_name":"versioning.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/versioning.md","id":"go/versioning","title":"Versioning","description":"Version Workflows in Go","label":"Versioning","tags":["go","versioning"],"ssdi":[],"markdown_content":"\nThe definition code of a Temporal Workflow must be deterministic because Temporal uses event sourcing\nto reconstruct the Workflow state by replaying the saved history event data on the Workflow\ndefinition code. This means that any incompatible update to the Workflow Definition code could cause\na non-deterministic issue if not handled correctly.\n\n## Introduction to Versioning\n\nBecause we design for potentially long running Workflows at scale, versioning with Temporal works differently. We explain more in this optional 30 minute introduction: [https://www.youtube.com/watch?v=kkP899WxgzY](https://www.youtube.com/watch?v=kkP899WxgzY)\n\n## workflow.GetVersion()\n\nConsider the following Workflow Definition:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, data string) (string, error) {\n        ao := workflow.ActivityOptions{\n                ScheduleToStartTimeout: time.Minute,\n                StartToCloseTimeout:    time.Minute,\n        }\n        ctx = workflow.WithActivityOptions(ctx, ao)\n        var result1 string\n        err := workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n        if err != nil {\n                return \"\", err\n        }\n        var result2 string\n        err = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\n        return result2, err\n}\n```\n\nNow let's say we have replaced ActivityA with ActivityC, and deployed the updated code. If there\nis an existing Workflow Execution that was started by the original version of the Workflow code, where\nActivityA had already completed and the result was recorded to history, the new version of the Workflow\ncode will pick up that Workflow Execution and try to resume from there. However, the Workflow will fail\nbecause the new code expects a result for ActivityC from the history data, but instead it gets the\nresult for ActivityA. This causes the Workflow to fail on the non-deterministic error.\n\nThus we use `workflow.GetVersion().`\n\n```go\nvar err error\nv := workflow.GetVersion(ctx, \"Step1\", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n}\nif err != nil {\n        return \"\", err\n}\n\nvar result2 string\nerr = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\nreturn result2, err\n```\n\nWhen `workflow.GetVersion()` is run for the new Workflow Execution, it records a marker in the Workflow history so that all future calls to `GetVersion` for this change Id—`Step 1` in the example—on this Workflow Execution will always return the given version number, which is `1` in the example.\n\nIf you make an additional change, such as replacing ActivityC with ActivityD, you need to\nadd some additional code:\n\n```go\nv := workflow.GetVersion(ctx, \"Step1\", workflow.DefaultVersion, 2)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else if v == 1 {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n```\n\nNote that we have changed `maxSupported` from 1 to 2. A Workflow that had already passed this\n`GetVersion()` call before it was introduced will return `DefaultVersion`. A Workflow that was run\nwith `maxSupported` set to 1, will return 1. New Workflows will return 2.\n\nAfter you are sure that all of the Workflow Executions prior to version 1 have completed, you can remove the code for that version.\nIt should now look like the following:\n\n```go\nv := workflow.GetVersion(ctx, \"Step1\", 1, 2)\nif v == 1 {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n```\n\nYou'll note that `minSupported` has changed from `DefaultVersion` to `1`.\nIf an older version of the Workflow Execution history is replayed on this code, it fails because the minimum expected version is 1.\nAfter you are sure that all of the Workflow Executions for version 1 have completed, you can remove version 1 so that your code looks like the following:\n\n```go\n_ := workflow.GetVersion(ctx, \"Step1\", 2, 2)\nerr = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n```\n\nNote that we have preserved the call to `GetVersion()`. There are two reasons to preserve this call:\n\n1. This ensures that if there is a Workflow Execution still running for an older version, it will\n   fail here and not proceed.\n2. If you need to make additional changes for `Step1`, such as changing ActivityD to ActivityE, you\n   only need to update `maxVersion` from 2 to 3 and branch from there.\n\nYou only need to preserve the first call to `GetVersion()` for each `changeID`. All subsequent calls to\n`GetVersion()` with the same change Id are safe to remove. If necessary, you can remove the first\n`GetVersion()` call, but you need to ensure the following:\n\n- All executions with an older version are completed.\n- You can no longer use `Step1` for the changeId. If you need to make changes to that same part in\n  the future, such as change from ActivityD to ActivityE, you would need to use a different changeId\n  like `Step1-fix2`, and start minVersion from DefaultVersion again. The code would look like the\n  following:\n\n```go\nv := workflow.GetVersion(ctx, \"Step1-fix2\", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityE, data).Get(ctx, &result1)\n}\n```\n\nUpgrading a Workflow is straightforward if you don't need to preserve your currently running Workflow Executions.\nYou can simply terminate all of the currently running Workflow Executions and suspend new ones from being created while you deploy the new version of your Workflow code, which does not use `GetVersion()`, and then resume Workflow creation.\nHowever, that is often not the case, and you need to take care of the currently running Workflow Executions, so using `GetVersion()` to update your code is the method to use.\n\nHowever, if you want your currently running Workflows to proceed based on the current Workflow logic,\nbut you want to ensure new Workflows are running on new logic, you can define your Workflow as a\nnew `WorkflowType`, and change your start path (calls to `StartWorkflow()`) to start the new Workflow\ntype.\n\n## Sanity checking\n\nThe Temporal client SDK performs a sanity check to help prevent obvious incompatible changes.\nThe sanity check verifies whether a Command made in replay matches the event recorded in history,\nin the same order. The Command is generated by calling any of the following methods:\n\n- workflow.ExecuteActivity()\n- workflow.ExecuteChildWorkflow()\n- workflow.NewTimer()\n- workflow.RequestCancelWorkflow()\n- workflow.SideEffect()\n- workflow.SignalExternalWorkflow()\n- workflow.Sleep()\n\nAdding, removing, or reordering any of the above methods triggers the sanity check and results in\na non-deterministic error.\n\nThe sanity check does not perform a thorough check. For example, it does not check on the Activity's\ninput arguments or the timer duration. If the check is enforced on every property, then it becomes\ntoo restricted and harder to maintain the Workflow code. For example, if you move your Activity code\nfrom one package to another package, that changes the `ActivityType`, which technically becomes a different\nActivity. But, we don't want to fail on that change, so we only check the function name part of the\n`ActivityType`.\n","is_empty":false},{"file_name":"visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/visibility.md","id":"go/visibility","title":"How to use Visibility APIs","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n","is_empty":false},{"file_name":"worker-sessions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/worker-sessions.md","id":"go/worker-sessions","title":"How to use Worker Session APIs","description":"To use Worker Sessions for Activity Executions the Worker must be enabled to use Sessions for the Workflows and Activities it is registered with.","label":"Worker Sessions","tags":["guide-context"],"ssdi":["This feature is currently available only in the Go SDK."],"markdown_content":"\nA Worker Session is a feature that provides a straightforward API for [Task Routing](/concepts/what-is-task-routing) to ensure that Activity Tasks are executed with the same Worker without requiring you to manually specify Task Queue names.\n","is_empty":false},{"file_name":"workflow-execution-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-execution-timeout.md","id":"go/workflow-execution-timeout","title":"How to set a Workflow Execution Timeout","description":"Use the Workflow Execution Timeout to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n","is_empty":false},{"file_name":"workflow-logic-requirements.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-logic-requirements.md","id":"go/workflow-logic-requirements","title":"How develop Workflow logic","description":"Workflow logic is constrained by deterministic execution requirements.","label":"Workflow logic requirements","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow logic is constrained by [deterministic execution requirements](/concepts/what-is-a-workflow-definition#deterministic-constraints).\nTherefore, each language is limited to the use of certain idiomatic techniques.\nHowever, each Temporal SDK provides a set of APIs that can be used inside your Workflow to interact with external (to the Workflow) application code.\n","is_empty":false},{"file_name":"workflow-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-parameters.md","id":"go/workflow-parameters","title":"How to define Workflow parameters","description":"Temporal Workflows may have any number of custom parameters.","label":"Workflow parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal Workflows may have any number of custom parameters.\nHowever, we strongly recommend that objects are used as parameters, so that the object's individual fields may be altered without breaking the signature of the Workflow.\nAll Workflow Definition parameters must be serializable.\n","is_empty":false},{"file_name":"workflow-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-retries.md","id":"go/workflow-retries","title":"Workflow retries","description":"A Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.","label":"Workflow retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-retry-policy.md","id":"go/workflow-retry-policy","title":"How to set a Workflow Retry Policy","description":"Use a Retry Policy to retry a Workflow Execution in the event of a failure.","label":"Workflow Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-return-values.md","id":"go/workflow-return-values","title":"How to define Workflow return parameters","description":"Workflow return values must also be serializable.","label":"Workflow return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow return values must also be serializable.\nReturning results, returning errors, or throwing exceptions is fairly idiomatic in each language that is supported.\nHowever, Temporal APIs that must be used to get the result of a Workflow Execution will only ever receive one of either the result or the error.\n","is_empty":false},{"file_name":"workflow-run-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-run-timeout.md","id":"go/workflow-run-timeout","title":"How to set a Workflow Run Timeout","description":"Use the Workflow Run Timeout to restrict the maximum amount of time that a single Workflow Run can last.","label":"Workflow Run Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) to restrict the maximum amount of time that a single [Workflow Run](/concepts/what-is-a-workflow-execution#workflow-execution-chain) can last.\n","is_empty":false},{"file_name":"workflow-task-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-task-timeout.md","id":"go/workflow-task-timeout","title":"How to set a Workflow Task Timeout","description":"Use the Workflow Task Timeout to restrict the maximum amount of time that a Worker can execute a Workflow Task.","label":"Workflow Task Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout) to restrict the maximum amount of time that a Worker can execute a [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"workflow-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-timeouts-and-retries.md","id":"go/workflow-timeouts-and-retries","title":"Workflow timeouts and retries","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts & retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"workflow-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/go/workflow-timeouts.md","id":"go/workflow-timeouts","title":"Workflow timeouts","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\n\nWorkflow timeouts are set when [starting the Workflow Execution](/go/workflow-timeouts).\n\n- **[Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout)** - restricts the maximum amount of time that a single Workflow Execution can be executed.\n- **[Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout)**: restricts the maximum amount of time that a single Workflow Run can last.\n- **[Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout)**: restricts the maximum amount of time that a Worker can execute a Workflow Task.\n","is_empty":false},{"file_name":"activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activities.md","id":"java/activities","title":"Activities in Java","label":"Activities","ssdi":[],"markdown_content":"\n## What is an Activity?\n\nActivities are implementations of certain tasks that need to be performed during a Workflow Execution.\nThey can be used to interact with external systems, such as databases and services.\n\nWorkflows orchestrate invocations of Activities.\n\nJust like [Workflows](./workflows.md), Activities must be registered with a [Worker](./workers.md).\n\n### Activity interface\n\nSimilar to Workflows, Activities in Temporal Java SDK programming model are classes which implement\nthe ActivityInterface Interface.\n\nActivity Interfaces are Java Interfaces which are annotated with the `@ActivityInterface` annotation:\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    String composeGreeting(String greeting, String language);\n}\n```\n\nEach method defined in the Activity interface defines a separate Activity method.\nYou can annotate each method in the Activity interface with the `@ActivityMethod`\nannotation, but this is completely optional, for example:\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod(name = \"greet\")\n    String composeGreeting(String greeting, String language);\n}\n```\n\nNote that the `@ActivityMethod` annotation has a `name` parameter which can be used to define the Activity type.\nIf it is specified like in the example above the type would be \"greet\".\nIf not specified, the Activity method name (with the first letter capitalized) is used by default, so in the example again it would be `composeGreeting`.\n\n### Activity implementation\n\nAn Activity implementation is Java class which implements an Activity Interface, for example:\n\n```java\n  public class MultiLanguageGreeting implements GreetingsActivities {\n    private final TranslationService translationService;\n\n    public MultiLanguageGreeting(TranslationService translationService) {\n      this.translationService = translationService;\n    }\n\n    @Override\n    public String composeGreeting(String greeting, String language) {\n      return translationService.translate(greeting, language);\n    }\n  }\n```\n\n## Registering Activities with a Worker\n\nJust like Workflows, Activities need to be registered with a Worker, for example:\n\n```java\nWorker worker = factory.newWorker(TASK_QUEUE);\n...\n// register the Activity\nworker.registerActivitiesImplementations(new MultiLanguageGreeting(translationService));\n```\n\nNote that when registering Activities, we register an instance of the Activity implementation, and can pass any\nnumber of dependencies in its constructor, such as the database connections, services, etc.\n\n## Invoking Activities inside Workflows\n\nSimilar to Workflows, Activities should only be instantiated via stubs.\n\n`Workflow.newActivityStub` returns a client-side stub that implements an Activity interface.\nIt takes Activity type and Activity options as arguments.\nActivity options allow you to specify different Activity timeout and retry options.\n\nCalling a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if an Activity's execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\nLet's take a look at an example Workflow that calls Activities:\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) {\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    // ...\n}\n```\n\nIn this example we use `Workflow.newActivityStub` to create a client-side stub of our file processing Activity.\nWe also define ActivityOptions and set the setStartToCloseTimeout timeout to one hour, meaning that we set the total execution timeout for each of its method invocations to one hour (from when the Activity Execution is started to when it completes).\n\nWorkflow can create multiple Activity stubs. Each activity stub can have its own ActivityOptions defined, for example:\n\n```java\npublic FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue1\")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue2\")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n```\n\n### Invoking Activities Asynchronously\n\nSometimes Workflows need to perform certain operations in parallel.\nThe Temporal Java SDK provides the `Async` class which includes static methods used to invoke any Activity asynchronously.\nThe calls return a result of type `Promise` which is similar to the Java `Future` and `CompletionStage`.\n\nWhen you need to get the results of an async invoked Activity method, you can use the `Promise` `get` method to block until the Activity method result is available.\n\nTo convert the following synchronous Activity method call:\n\n```java\nString localName = activities.download(sourceBucket, sourceFile);\n```\n\nTo asynchronous style, the method reference is passed to `Async.function` or `Async.procedure`\nfollowed by Activity arguments:\n\n```java\nPromise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);\n```\n\nThen to wait synchronously for the result you can do the following:\n\n```java\nString localName = localNamePromise.get();\n```\n\nHere is the above example rewritten to call download and upload Activity methods in parallel, on multiple files:\n\n```java\n  public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n      // Download all files in parallel.\n      for (String sourceFilename : args.getSourceFilenames()) {\n        Promise<String> localName =\n            Async.function(activities::download, args.getSourceBucketName(), sourceFilename);\n        localNamePromises.add(localName);\n      }\n      List<String> localNames = new ArrayList<>();\n      for (Promise<String> localName : localNamePromises) {\n        localNames.add(localName.get());\n      }\n      processedNames = activities.processFiles(localNames);\n\n      // Upload all results in parallel.\n      List<Promise<Void>> uploadedList = new ArrayList<>();\n      for (String processedName : processedNames) {\n        Promise<Void> uploaded =\n            Async.procedure(\n                activities::upload,\n                args.getTargetBucketName(),\n                args.getTargetFilename(),\n                processedName);\n        uploadedList.add(uploaded);\n      }\n      // Wait for all uploads to complete.\n      Promise.allOf(uploadedList).get();\n    } finally {\n      for (Promise<String> localNamePromise : localNamePromises) {\n        // Skip files that haven't completed downloading.\n        if (localNamePromise.isCompleted()) {\n          activities.deleteLocalFile(localNamePromise.get());\n        }\n      }\n      if (processedNames != null) {\n        for (String processedName : processedNames) {\n          activities.deleteLocalFile(processedName);\n        }\n      }\n    }\n  }\n```\n\n## Invoking Activities via `Workflow.newUntypedActivityStub`\n\nIt is also possible to invoke Activities inside Workflows using `Workflow.newUntypedActivityStub`, meaning you can\ninvoke them without referencing an interface it implements.\nThis is useful in scenarios where the Activity type is not known at compile time, or to invoke\nActivities implemented in different programming languages.\n\n```java\n   // Workflow code\n    ActivityOptions activityOptions =\n        ActivityOptions.newBuilder()\n        .setStartToCloseTimeout(Duration.ofSeconds(3))\n        .setTaskQueue(\"simple-queue-node\")\n        .build();\n\n    ActivityStub activity = Workflow.newUntypedActivityStub(activityOptions);\n    activity.execute(\"ComposeGreeting\", String.class, \"Hello World\" , \"Spanish\");\n```\n\n## Activity Execution Context\n\n`ActivityExecutionContext` is a context object passed to each Activity implementation by default.\nYou can access it in your Activity implementations via `Activity.getExecutionContext()`.\n\nIt provides getters to access information about the Workflow that invoked the Activity.\nNote that the Activity context information is stored in a thread-local variable.\nTherefore, calls to `getExecutionContext()` succeed only within the thread that invoked the Activity function.\n\nFollowing is an example of using the `ActivityExecutionContext`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n    ActivityInfo info = ctx.getInfo();\n\n    log.info(\"namespace=\" +  info.getActivityNamespace());\n    log.info(\"workflowId=\" + info.getWorkflowId());\n    log.info(\"runId=\" + info.getRunId());\n    log.info(\"activityId=\" + info.getActivityId());\n    log.info(\"activityTimeout=\" + info.getStartToCloseTimeoutSeconds());\n\n    return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n  }\n    ...\n}\n```\n\n## Asynchronous Activity Completion\n\nSometimes an Activity lifecycle goes beyond a synchronous method invocation.\nFor example, a request can be put in a queue and later a reply comes and is picked up by a different Worker process.\nThe whole request-reply interaction can be modeled as a single Activity.\n\nTo indicate that an Activity should not be completed upon its method return, call `ActivityExecutionContext.doNotCompleteOnReturn()` from the original Activity thread.\n\nThen later, when replies come, complete the Activity using the `ActivityCompletionClient`.\nTo correlate Activity invocation with completion, use either a `TaskToken` or Workflow and Activity Ids.\n\nFollowing is an example of using `ActivityExecutionContext.doNotCompleteOnReturn()`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n\n    // Used to correlate reply\n    byte[] taskToken = ctx.getInfo().getTaskToken();\n    asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n    ctx.doNotCompleteOnReturn();\n\n    // Return value is ignored when doNotCompleteOnReturn was called.\n    return \"ignored\";\n  }\n  ...\n}\n```\n\nWhen the download is complete, the download service potentially can complete the Activity, or fail it from a different process, for example:\n\n```java\n  public <R> void completeActivity(byte[] taskToken, R result) {\n    completionClient.complete(taskToken, result);\n  }\n\n  public void failActivity(byte[] taskToken, Exception failure) {\n    completionClient.completeExceptionally(taskToken, failure);\n  }\n```\n\n## Activity heartbeats\n\nActivities can be long-running.\nIn these cases the Activity Execution timeouts should be set to be longer than the maximum predicted time of the Activity Execution.\nIn those cases it can happen that an Activity Execution is started and cannot proceed, or fails to continue its execution for some reasons.\nWith our long set execution timeout the calling Workflow will not be able to time out the Activity and retry it or fail it until this timeout is reached.\n\nIn order to react quickly to crashes of long-running Activities you can use the Activity heartbeat mechanism.\nYou can set a short heartbeat timeout in order to detect Activity issues and react to them without having to wait for the long Activity Execution timeout to complete first.\n\n`Activity.getExecutionContext().heartbeat()` lets the Temporal service know that the Activity is still alive.\n\nThe `Activity.getExecutionContext().heartbeat()` can take an argument which represents heartbeat\n`details`.\nIf an Activity times out, the last heartbeat `details` will be included in the thrown `ActivityTimeoutException` which can be caught by the calling Workflow.\nThe Workflow then can use the `details` information to pass to the next Activity invocation if needed.\n\nIn the case of Activity retries, the last Heartbeat's `details` are available and can be extracted from the last fail attempt using `Activity.getExecutionContext().getHeartbeatDetails(Class<V> detailsClass)`\n\nFollowing is an example of using Activity heartbeat:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n    InputStream inputStream = openInputStream(file);\n    try {\n      byte[] bytes = new byte[MAX_BUFFER_SIZE];\n      while ((read = inputStream.read(bytes)) != -1) {\n        totalRead += read;\n        f.write(bytes, 0, read);\n        // Let the Server know about the download progress.\n        Activity.getExecutionContext().heartbeat(totalRead);\n      }\n    } finally{\n      inputStream.close();\n    }\n  }\n  ...\n}\n```\n\n## Throwing Activity errors\n\nIf there is a need to throw checked Exception from Activity methods which do not support re-throwing checked Exceptions in their signatures,\nyou should wrap them using the `Activity.wrap` method and re-throw the Exceptions.\n\nThere is no need to wrap unchecked Exceptions, but it's safe to do so if you want to.\n\nIn addition, when wrapping checked Exceptions, the original Exception is attached as a cause to the wrapped one, and is not lost.\n\nHere is an example of catching a checked Exception and wrapping it:\n\n```java\ntry {\n  return someCall();\n} catch (Exception e) {\n  throw Activity.wrap(e);\n}\n```\n\nNote that any Exception thrown from an Activity is converted to `io.temporal.failure.ApplicationFailure`, unless the thrown Exception extends `io.temporal.failure.TemporalException` .\n","is_empty":false},{"file_name":"activity-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activity-heartbeats.md","id":"java/activity-heartbeats","title":"How to Heartbeat an Activity","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.","label":"Activity Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn [Activity Heartbeat](/concepts/what-is-an-activity-heartbeat) is a ping from the [Worker Process](/concepts/what-is-a-worker-process) that is executing the Activity to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nEach Heartbeat informs the Temporal Cluster that the [Activity Execution](/concepts/what-is-an-activity-execution) is making progress and the Worker has not crashed.\nIf the Cluster does not receive a Heartbeat within a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) time period, the Activity will be considered failed and another [Activity Task Execution](/concepts/what-is-an-activity-task-execution) may be scheduled according to the Retry Policy.\n\nHeartbeats may not always be sent to the Cluster—they may be [throttled](/concepts/what-is-an-activity-heartbeat#throttling) by the Worker.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\nHeartbeats can contain a `details` field describing the Activity's current progress.\nIf an Activity gets retried, the Activity can access the `details` from the last Heartbeat that was sent to the Cluster.\n","is_empty":false},{"file_name":"activity-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activity-parameters.md","id":"java/activity-parameters","title":"How to develop Activity Parameters","description":"When it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.","label":"Activity parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThere is no explicit limit to the total number of parameters that an [Activity Definition](/concepts/what-is-an-activity-definition) may support.\nHowever, there is a limit of the total size of the data ends up encoded into a gRPC message Payload.\n\nA single argument is limited to a maximum size of 2 MB.\nAnd the total size of a gRPC message, which includes all the arguments, is limited to a maximum of 4 MB.\n\nAlso, keep in mind that all Payload data is recorded in the [Workflow Execution Event History](/concepts/what-is-an-event-history) and large Event Histories can affect Worker performance.\nThis is because the entire Event History could be transferred to a Worker Process with a [Workflow Task](/concepts/what-is-a-workflow-task).\n\n<!--TODO link to gRPC limit section when available -->\n\nSome SDKs require that you pass context objects, others do not.\nWhen it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.\nThis is so that you can change what data is passed to the Activity without breaking a function or method signature.\n","is_empty":false},{"file_name":"activity-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activity-retries.md","id":"java/activity-retries","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activity-retry-policy.md","id":"java/activity-retry-policy","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-simulator.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activity-retry-simulator.md","id":"java/activity-retry-simulator","title":"How to visualize an Activity Retry Policy with timeouts","description":"Use this tool to visualize total Activity Execution times and experiment with various Activity timeouts and Retry Policies.","label":"Activity retry simulator","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse this tool to visualize total Activity Execution times and experiment with different Activity timeouts and Retry Policies.\n\nThe simulator is based on a common Activity use-case, which is to call a third party HTTP API and return the results.\nSee the example code snippets below.\n\nUse the Activity Retries settings to configure how long the API request takes to succeed or fail.\nThere is an option to generate scenarios.\nThe _Task Time in Queue_ simulates the time the Activity Task might be waiting in the Task Queue.\n\nUse the Activity Timeouts and Retry Policy settings to see how they impact the success or failure of an Activity Execution.\n\nimport RetrySimulator from '/docs/components/RetrySimulator/RetrySimulator';\n\n<RetrySimulator />\n","is_empty":false},{"file_name":"activity-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activity-return-values.md","id":"java/activity-return-values","title":"How to define Activity return values","description":"All data returned from an Activity must be serializable.","label":"Activity return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll data returned from an Activity must be serializable.\n\nThere is no explicit limit to the amount of data that can be returned by an Activity, but keep in mind that all return values are recorded in a [Workflow Execution Event History](/concepts/what-is-an-event-history).\n","is_empty":false},{"file_name":"activity-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activity-timeouts-and-retries.md","id":"java/activity-timeouts-and-retries","title":"How to set Activity timeouts and retries","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts and retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"activity-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activity-timeouts.md","id":"java/activity-timeouts","title":"How to set Activity timeouts","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\n\nThe following timeouts are available in the Activity Options.\n\n- **[Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout)**: is the maximum amount of time allowed for the overall [Activity Execution](/concepts/what-is-an-activity-execution).\n- **[Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout)**: is the maximum time allowed for a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n- **[Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout)**: is the maximum amount of time that is allowed from when an [Activity Task](/concepts/what-is-an-activity-task) is scheduled to when a [Worker](/concepts/what-is-a-worker) starts that Activity Task.\n\nAn Activity Execution must have either the Start-To-Close or the Schedule-To-Close Timeout set.\n","is_empty":false},{"file_name":"activity-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/activity-type.md","id":"java/activity-type","title":"How to customize your Activity Type","description":"You can set a custom name for your Activity Type.","label":"Activity Type","tags":["guide-context"],"ssdi":[],"markdown_content":"\nActivities have a Type that are referred to as the Activity name.\nThe following examples demonstrate how to set a custom name for your Activity Type.\n","is_empty":false},{"file_name":"add-sdk.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/add-sdk.md","id":"java/add-sdk","title":"How to install a Temporal SDK","description":"A Temporal SDK provides a framework for Temporal Application development.","label":"Install a Temporal SDK","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal SDK](/concepts/what-is-a-temporal-sdk) provides a framework for [Temporal Application](/concepts/what-is-a-temporal-application) development.\n\nAn SDK provides you with the following:\n\n- A [Temporal Client](/concepts/what-is-a-temporal-client) to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n- APIs to develop [Workflows](/concepts/what-is-a-workflow).\n- APIs to create and manage [Worker Processes](/concepts/what-is-a-worker).\n- APIs to author [Activities](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"api-reference-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/api-reference-java.md","id":"java/api-reference-java","title":"How to find the Java SDK API reference","description":"The Java SDK API reference is published on javadoc.io","label":"API reference","ssdi":[],"markdown_content":"\nThe Temporal Java SDK API reference is published on [javadoc.io](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/index.html).\n\n- Short link: [`t.mp/java-api`](https://t.mp/java-api)\n","is_empty":false},{"file_name":"assert-in-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/assert-in-workflows.md","id":"java/assert-in-workflows","title":"Assert in Workflows","description":"How to Assert in Workflows","label":"Assert in Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\n<!-- not used -->\n\nIn some cases it's useful to assert directly in the Workflow context.\n\nFor example, TypeScript and Python, can use `assert` in Workflow code.\n","is_empty":false},{"file_name":"async-activity-completion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/async-activity-completion.md","id":"java/async-activity-completion","title":"How to asynchronously complete an Activity","description":"Asynchronous Activity Completion enables the Activity Function to return without the Activity Execution completing.","label":"Asynchronous Activity Completion","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Asynchronous Activity Completion](/concepts/what-is-asynchronous-activity-completion) enables the Activity Function to return without the Activity Execution completing.\n\nThere are three steps to follow:\n\n1. The Activity provides the external system with identifying information needed to complete the Activity Execution.\n   Identifying information can be a [Task Token](/concepts/what-is-a-task-token), or a combination of Namespace, Workflow Id, and Activity Id.\n2. The Activity Function completes in a way that identifies it as waiting to be completed by an external system.\n3. The Temporal Client is used to Heartbeat and complete the Activity.\n","is_empty":false},{"file_name":"cancel-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/cancel-activity.md","id":"java/cancel-activity","title":"Cancel an Activity from a Workflow","description":"An Activity can be canceled from within a Workflow if the Activity sends Heartbeats.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCanceling an Activity from within a Workflow requires that the Activity Execution sends Heartbeats and sets a Heartbeat Timeout.\nIf the Heartbeat is not invoked, the Activity cannot receive a cancellation request.\nWhen any non-immediate Activity is executed, the Activity Execution should send Heartbeats and set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) to ensure that the server knows it is still working.\n\nWhen an Activity is canceled, an error is raised in the Activity at the next available opportunity.\nIf cleanup logic needs to be performed, it can be done in a `finally` clause or inside a caught cancel error.\nHowever, for the Activity to appear canceled the exception needs to be re-raised.\n\n:::note\n\nUnlike regular Activities, [Local Activities](/concepts/what-is-a-local-activity) can be canceled if they don't send Heartbeats.\nLocal Activities are handled locally, and all the information needed to handle the cancellation logic is available in the same Worker process.\n\n:::\n","is_empty":false},{"file_name":"cancel-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/cancel-an-activity.md","id":"java/cancel-an-activity","title":"Cancel an Activity","description":"If an Activity is supposed to react to Cancellation, you can test whether it reacts correctly by canceling it.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity is supposed to react to a Cancellation, you can test whether it reacts correctly by canceling it.\n","is_empty":false},{"file_name":"child-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/child-workflows.md","id":"java/child-workflows","title":"How to start a Child Workflow Execution","description":"A Child Workflow Execution is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.","label":"Child Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.\n\nWhen using a Child Workflow API, Child Workflow related Events ([StartChildWorkflowExecutionInitiated](/references/events#startchildworkflowexecutioninitiated), [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted), [ChildWorkflowExecutionCompleted](/references/events#childworkflowexecutioncompleted), etc...) are logged in the Workflow Execution Event History.\n\nAlways block progress until the [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted) Event is logged to the Event History to ensure the Child Workflow Execution has started.\nAfter that, Child Workflow Executions may be abandoned using the default _Abandon_ [Parent Close Policy](/concepts/what-is-a-parent-close-policy) set in the Child Workflow Options.\n\nTo be sure that the Child Workflow Execution has started, first call the Child Workflow Execution method on the instance of Child Workflow future, which returns a different future.\n\nThen get the value of an object that acts as a proxy for a result that is initially unknown, which is what waits until the Child Workflow Execution has spawned.\n","is_empty":false},{"file_name":"code-samples-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/code-samples-java.md","id":"java/code-samples-java","title":"Code samples","label":"Code samples","ssdi":[],"markdown_content":"\n- [Java samples library](https://github.com/temporalio/samples-java)\n- [Hello world application template in Java](https://github.com/temporalio/hello-world-project-template-java): Provides a quick-start development app for users.\n  Works in conjunction with the [\"Hello World!\" from scratch tutorial in Java](https://learn.temporal.io/getting_started/java/hello_world_in_java/).\n- [Money transfer application template in Java](https://github.com/temporalio/money-transfer-project-template-java): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Java](https://learn.temporal.io/getting_started/java/first_program_in_java/).\n- [Subscription-style Workflow Definition in Java](https://github.com/temporalio/subscription-workflow-project-template-java): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n","is_empty":false},{"file_name":"code-samples.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/code-samples.md","id":"java/code-samples","title":"Where are SDK-specific code examples?","description":"You can find a complete list of executable code samples in Temporal's GitHub repository.","label":"Code samples","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can find a complete list of executable code samples in [Temporal's GitHub repository](https://github.com/temporalio?q=samples-&type=all&language=&sort=).\n\nAdditionally, several of the [Tutorials](https://learn.temporal.io) are backed by a fully executable template application.\n","is_empty":false},{"file_name":"connect-to-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/connect-to-temporal-cloud.md","id":"java/connect-to-temporal-cloud","title":"How to connect to Temporal Cloud","description":"Use a compatible mTLS CA certificate and mTLS private key and your Cloud Namespace to connect to Temporal Cloud.","label":"Connect to Temporal Cloud","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen you connect to [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"continue-as-new.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/continue-as-new.md","id":"java/continue-as-new","title":"How to Continue-As-New","description":"Continue-As-New enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.","label":"Continue-As-New","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Continue-As-New](/concepts/what-is-continue-as-new) enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.\nThe Workflow Execution spawned from the use of Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\n","is_empty":false},{"file_name":"custom-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/custom-logging.md","id":"java/custom-logging","title":"How to provide a custom logger","description":"Use a custom logger for logging.","label":"Custom logger","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a custom logger for logging.\n","is_empty":false},{"file_name":"custom-payload-conversion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/custom-payload-conversion.md","id":"java/custom-payload-conversion","title":"How to use custom payload conversion","description":"Create your custom `PayloadConverter` and set it on a `DataConverter` in your Client options.","label":"Custom payload conversion","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal SDKs provide a [Payload Converter](/concepts/what-is-a-payload-converter) that can be customized to convert a custom data type to [Payload](/concepts/what-is-a-payload) and back.\n\nImplementing custom Payload conversion is optional.\nIt is needed only if the [default Data Converter](/concepts/what-is-a-default-data-converter) does not support your custom values.\n\nTo support custom Payload conversion, create a [custom Payload Converter](/concepts/what-is-a-payload-converter#custom-payload-conversion) and configure the Data Converter to use it in your Client options.\n\nThe order in which your encoding Payload Converters are applied depend on the order given to the Data Converter.\nYou can set multiple encoding Payload Converters to run your conversions.\nWhen the Data Converter receives a value for conversion, it passes through each Payload Converter in sequence until the converter that handles the data type does the conversion.\n","is_empty":false},{"file_name":"debug-environment-development.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/debug-environment-development.md","id":"java/debug-environment-development","title":"How to debug in a development environment","description":"In addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the Web UI and tctl.","label":"Debug in a development environment","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the [Web UI](/web-ui) or [`tctl`](/tctl-v1).\n","is_empty":false},{"file_name":"debug-environment-production.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/debug-environment-production.md","id":"java/debug-environment-production","title":"How to debug in a production environment","description":"Debug production Workflows using the Web UI, tctl, Replays, Tracing, or Logging.","label":"Debug in a production environment","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can debug production Workflows using:\n\n- [Web UI](/web-ui)\n- [tctl](/tctl-v1)\n- [Replay](#replay)\n- [Tracing](/java/tracing)\n- [Logging](/java/logging)\n\nYou can debug and tune Worker performance with metrics and the [Worker performance guide](/dev-guide/worker-performance).\nFor more information, see [Observability ▶️ Metrics](/dev-guide/java/observability#metrics) for setting up SDK metrics.\n\nDebug Server performance with [Cloud metrics](/cloud/how-to-monitor-temporal-cloud-metrics) or [self-hosted Server metrics](/kb/legacy-oss-prod-deploy#scaling-and-metrics).\n","is_empty":false},{"file_name":"debugging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/debugging.md","id":"java/debugging","title":"Debugging","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Debug","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn addition to writing unit and integration tests, debugging your Workflows is also a very valuable testing tool.\nYou can debug your Workflow code using a debugger provided by your favorite Java IDE.\n\nNote that when debugging your Workflow code, the Temporal Java SDK includes deadlock detection which fails a Workflow Task in case the code blocks over a second without relinquishing execution control.\nBecause of this you can often encounter the `PotentialDeadlockException` Exception while stepping through Workflow code during debugging.\n\nTo alleviate this issue, you can set the `TEMPORAL_DEBUG` environment variable to true before debugging your Workflow code. Make sure to set `TEMPORAL_DEBUG` to true only during debugging.\n","is_empty":false},{"file_name":"define-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/define-query.md","id":"java/define-query","title":"How to define a Query","description":"A Query has a name and can have arguments.","label":"Define Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Query has a name and can have arguments.\n\n- The name, also called a Query type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"define-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/define-signal.md","id":"java/define-signal","title":"How to define a Signal","description":"A Signal has a name and can have arguments.","label":"Define Signal","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"developing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/developing-activities.md","id":"java/developing-activities","title":"How to develop a basic Activity","description":"One of the primary things that Workflows do is orchestrate the execution of Activities.","label":"Develop Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nOne of the primary things that Workflows do is orchestrate the execution of Activities.\nAn Activity is a normal function or method execution that's intended to execute a single, well-defined action (either short or long-running), such as querying a database, calling a third-party API, or transcoding a media file.\nAn Activity can interact with world outside the Temporal Platform or use a Temporal Client to interact with a Cluster.\nFor the Workflow to be able to execute the Activity, we must define the [Activity Definition](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"distributed-cron.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/distributed-cron.md","id":"java/distributed-cron","title":"Distributed CRON","ssdi":[],"markdown_content":"\n<!-- prettier-ignore -->\n\nimport * as WhatIsATemporalCronJob from '../concepts/what-is-a-temporal-cron-job.md'\n\nThis is how you set a cron schedule in Java:\n\n```java\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder()\n            .setWorkflowId(WORKFLOW_ID)\n            .setTaskQueue(TASK_QUEUE)\n            .setCronSchedule(\"* * * * *\")\n            .setWorkflowExecutionTimeout(Duration.ofMinutes(3))\n            .setWorkflowRunTimeout(Duration.ofMinutes(1))\n            .build();\n\n    // Create the workflow client stub. It is used to start our workflow execution.\n    GreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);\n```\n\nSetting `setCronSchedule` turns the Workflow Execution into a <preview page={WhatIsATemporalCronJob}>Temporal Cron Job</preview>\n\nYou can check our [Java samples](https://github.com/temporalio/samples-java/blob/master/src/main/java/io/temporal/samples/hello/HelloCron.java) for example code.\n\nJava SDK `workflowOptions` source code: https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.html\n\n## Retrieve last successful result\n\nSometimes it is useful to obtain the progress of previous successful runs.\nThis is supported by one new APIs in the Java SDK:\n`GetLastCompletionResult`. The method returns null if there is no previous completion. Below is an example of how\nto use this in Java:\n\n```java\npublic String cronWorkflow() {\n    String lastProcessedFileName = Workflow.getLastCompletionResult(String.class);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the cron schedule runs failed. The\nnext schedule will still get the last successful result if it ever successfully\ncompleted at least once. For example, for a daily cron Workflow, if the first day\nrun succeeds and the second day fails, then the third day run will still get\nthe result from first day's run using these APIs.\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/environment-variables.md","id":"java/environment-variables","title":"How to read and pass environment variables","description":"Environment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.","label":"Environment variables","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEnvironment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.\nThey can't be used normally with Workflow code, as that would be [non-deterministic](workflows#intrinsic-non-deterministic-logic) (if the environment variables changed between Workflow replays, the code that used them would behave differently).\n\nMost of the time, you can provide environment variables in your Activity function; however, if you need them in your Workflow functions, you can use the following options:\n\n- Provide environment variables as arguments when starting the Workflow.\n- Call a Local Activity at the beginning of the Workflow that returns environment variables.\n\nIn either case, the environment variables will appear in Event History, so you may want to use an [encryption Data Converter](/concepts/what-is-a-data-converter#encryption).\n","is_empty":false},{"file_name":"features.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/features.md","id":"java/features","title":"How to use Workflow and Activity features","description":"The Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.","label":"Features","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\n\nIn this section you can find the following:\n\n- [How to develop Signals](#signals)\n- [How to develop Queries](#queries)\n- [How to start a Child Workflow Execution](#child-workflows)\n- [How to start a Temporal Cron Job](#temporal-cron-jobs)\n- [How to use Continue-As-New](#continue-as-new)\n- [How to set Workflow timeouts & retries](#workflow-timeouts)\n- [How to set Activity timeouts & retries](#activity-timeouts)\n- [How to Heartbeat an Activity](#activity-heartbeats)\n- [How to Asynchronously complete an Activity](#asynchronous-activity-completion)\n- [How to register Namespaces](#namespaces)\n- [How to use custom payload conversion](#custom-payload-conversion)\n","is_empty":false},{"file_name":"foundations.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/foundations.md","id":"java/foundations","title":"How to build a basic Temporal Application","description":"The Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application—that is, all the relevant steps to start a Workflow Execution that executes an Activity.","label":"Foundations","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a [Temporal Application](/concepts/what-is-a-temporal-application)—that is, all the relevant steps to start a [Workflow Execution](#develop-workflows) that executes an [Activity](#develop-activities).\n\nIn this section you can find the following:\n\n- [Run a development Cluster](/clusters/how-to-install-temporal-cli)\n- [Install your SDK](/java/add-sdk)\n- [Connect to a dev Cluster](/java/how-to-create-a-temporal-client-in-java)\n- [Develop a Workflow](/java/how-to-develop-a-workflow-definition-in-java)\n- [Develop an Activity](/java/developing-activities)\n- [Start an Activity Execution](/java/spawning-activities)\n- [Run a dev Worker](/java/how-to-develop-a-worker-program-in-java)\n- [Start a Workflow Execution](/java/how-to-spawn-a-workflow-execution-in-java)\n","is_empty":false},{"file_name":"get-activity-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/get-activity-results.md","id":"java/get-activity-results","title":"How to get the results of an Activity Execution","description":"The call to spawn an Activity Execution generates the ScheduleActivityTask Command and provides the Workflow with an Awaitable.","label":"Get Activity results","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe call to spawn an [Activity Execution](/concepts/what-is-an-activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.\n","is_empty":false},{"file_name":"handle-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/handle-query.md","id":"java/handle-query","title":"How to handle a Query","description":"Queries are handled by your Workflow.","label":"Handle Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are handled by your Workflow.\n\nDon’t include any logic that causes [Command](/concepts/what-is-a-command) generation within a Query handler (such as executing Activities).\nIncluding such logic causes unexpected behavior.\n","is_empty":false},{"file_name":"heartbeat-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/heartbeat-timeout.md","id":"java/heartbeat-timeout","title":"How to set a Heartbeat Timeout","description":"A Heartbeat Timeout works in conjunction with Activity Heartbeats.","label":"Heartbeat Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) works in conjunction with [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-java.md","id":"java/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-java","title":"How to set custom Search Attributes in Java","description":"To set custom Search Attributes, call the setSearchAttributes method.","label":"Set custom Search Attributes","tags":["developer-guide","sdk","java"],"ssdi":[],"markdown_content":"\nTo set a custom Search Attribute, call the [`setSearchAttributes()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html#setSearchAttributes(java.util.Map)) method.\n\n```java\nWorkflowOptions workflowOptions =\n    WorkflowOptions.newBuilder()\n        .setSearchAttributes(generateSearchAttributes())\n        .build();\n```\n\n`generateSearchAttributes()` is a `Map<String, ?>` from the Search Attribute used as the key to a value of one of the following types.\n\n- `String`\n- `Long`\n- `Integer`\n- `Boolean`\n- `Double`\n- `OffsetDateTime`\n","is_empty":false},{"file_name":"how-to-asynchronously-complete-an-activity-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-asynchronously-complete-an-activity-in-java.md","id":"java/how-to-asynchronously-complete-an-activity-in-java","title":"How to asynchronously complete an Activity in Java","description":"To asynchronously complete an Activity in Java, set the `ActivityCompletionClient` interface to the `complete()` method.","label":"Asynchronously complete an Activity","tags":["java","how-to"],"ssdi":[],"markdown_content":"\nTo complete an Activity asynchronously, set the [`ActivityCompletionClient`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/ActivityCompletionClient.html) interface to the `complete()` method.\n\n```java\n    @Override\n    public String composeGreeting(String greeting, String name) {\n\n      // Get the activity execution context\n      ActivityExecutionContext context = Activity.getExecutionContext();\n\n      // Set a correlation token that can be used to complete the activity asynchronously\n      byte[] taskToken = context.getTaskToken();\n\n      /**\n       * For the example we will use a {@link java.util.concurrent.ForkJoinPool} to execute our\n       * activity. In real-life applications this could be any service. The composeGreetingAsync\n       * method is the one that will actually complete workflow action execution.\n       */\n      ForkJoinPool.commonPool().execute(() -> composeGreetingAsync(taskToken, greeting, name));\n      context.doNotCompleteOnReturn();\n\n      // Since we have set doNotCompleteOnReturn(), the workflow action method return value is\n      // ignored.\n      return \"ignored\";\n    }\n\n    // Method that will complete action execution using the defined ActivityCompletionClient\n    private void composeGreetingAsync(byte[] taskToken, String greeting, String name) {\n      String result = greeting + \" \" + name + \"!\";\n\n      // Complete our workflow activity using ActivityCompletionClient\n      completionClient.complete(taskToken, result);\n    }\n  }\n```\n\nAlternatively, set the [`doNotCompleteOnReturn()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityExecutionContext.html#doNotCompleteOnReturn()) method during an Activity Execution.\n\n```java\n    @Override\n    public String composeGreeting(String greeting, String name) {\n\n      // Get the activity execution context\n      ActivityExecutionContext context = Activity.getExecutionContext();\n\n      // Set a correlation token that can be used to complete the activity asynchronously\n      byte[] taskToken = context.getTaskToken();\n\n      /**\n       * For the example we will use a {@link java.util.concurrent.ForkJoinPool} to execute our\n       * activity. In real-life applications this could be any service. The composeGreetingAsync\n       * method is the one that will actually complete workflow action execution.\n       */\n      ForkJoinPool.commonPool().execute(() -> composeGreetingAsync(taskToken, greeting, name));\n      context.doNotCompleteOnReturn();\n\n      // Since we have set doNotCompleteOnReturn(), the workflow action method return value is\n      // ignored.\n      return \"ignored\";\n    }\n```\n\nWhen this method is called during an Activity Execution, the Activity Execution does not complete when its method returns.\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-configure-tracing-in-java.md","id":"java/how-to-configure-tracing-in-java","title":"How to configure tracing in Java","description":"To configure tracing in Java, register the `OpenTracingClientInterceptor()` interceptor.","label":"Configure tracing","tags":["java","how-to"],"ssdi":[],"markdown_content":"\nTo configure tracing in Java, register the `OpenTracingClientInterceptor()` interceptor.\nYou can register the interceptors on both the Temporal Client side and the Worker side.\n\nThe following code examples demonstrate the `OpenTracingClientInterceptor()` on the Temporal Client.\n\n```java\nWorkflowClientOptions.newBuilder()\n   //...\n   .setInterceptors(new OpenTracingClientInterceptor())\n   .build();\n```\n\n```java\nWorkflowClientOptions clientOptions =\n    WorkflowClientOptions.newBuilder()\n        .setInterceptors(new OpenTracingClientInterceptor(JaegerUtils.getJaegerOptions(type)))\n        .build();\nWorkflowClient client = WorkflowClient.newInstance(service, clientOptions);\n```\n\nThe following code examples demonstrate the `OpenTracingClientInterceptor()` on the Worker.\n\n```java\nWorkerFactoryOptions.newBuilder()\n   //...\n   .setWorkerInterceptors(new OpenTracingWorkerInterceptor())\n   .build();\n```\n\n```java\nWorkerFactoryOptions factoryOptions =\n    WorkerFactoryOptions.newBuilder()\n        .setWorkerInterceptors(\n            new OpenTracingWorkerInterceptor(JaegerUtils.getJaegerOptions(type)))\n        .build();\nWorkerFactory factory = WorkerFactory.newInstance(client, factoryOptions);\n```\n\nFor more information, see the Temporal [OpenTracing module](https://github.com/temporalio/sdk-java/blob/master/temporal-opentracing/README.md).\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-continue-as-new-in-java.md","id":"java/how-to-continue-as-new-in-java","title":"How to Continue-As-New in Java","description":"To cause a Workflow to Continue-As-New, use `Workflow.continueAsNew()`.","label":"Continue-As-New","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nTemporal SDK allows you to use [Continue-As-New](/concepts/what-is-continue-as-new) in various ways.\n\nTo continue execution of the same Workflow that is currently running, use:\n\n```java\nWorkflow.continueAsNew(input1, ...);\n```\n\nTo continue execution of a currently running Workflow as a completely different Workflow Type, use `Workflow.newContinueAsNewStub()`.\nFor example, in a Workflow class called `YourWorkflow`, we can create a Workflow stub with a different type, and call its Workflow method to continue execution as that type:\n\n```java\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class);\nconinueAsNew.greet(input);\n```\n\nTo provide `ContinueAsNewOptions` options in `Workflow.newContinueAsNewStub()` use:\n\n```java\nContinueAsNewOptions options = ContinueAsNewOptions.newBuilder()\n        .setTaskQueue(\"newTaskQueueName\")\n        .build();\n\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class, options);\n// ...\ncontinueAsNew.greet(input);\n```\n\nProviding these options allows you to continue Workflow Execution as a new Workflow run, with a different Workflow Type, and on a different Task Queue.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-create-a-temporal-client-in-java.md","id":"java/how-to-create-a-temporal-client-in-java","title":"How to create a Temporal Client in Java","description":"To initialize a Workflow Client, create an instance of a `WorkflowClient`, create a client-side `WorkflowStub`, and then call a Workflow method (annotated with the `@WorkflowMethod` annotation).","label":"Connect to a dev Cluster","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nA [Temporal Client](/concepts/what-is-a-temporal-client) enables you to communicate with the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nCommunication with a Temporal Cluster includes, but isn't limited to, the following:\n\n- Starting Workflow Executions.\n- Sending Signals to Workflow Executions.\n- Sending Queries to Workflow Executions.\n- Getting the results of a Workflow Execution.\n- Providing an Activity Task Token.\n\n:::caution\n\nA Temporal Client cannot be initialized and used inside a Workflow.\nHowever, it is acceptable and common to use a Temporal Client inside an Activity to communicate with a Temporal Cluster.\n\n:::\n\nWhen you are running a Cluster locally (such as [Temporalite](/kb/all-the-ways-to-run-a-cluster#temporalite)), the number of connection options you must provide is minimal.\nMany SDKs default to the local host or IP address and port that Temporalite and [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose) serve (`127.0.0.1:7233`).\n\nTo initialize a Workflow Client, create an instance of a `WorkflowClient`, create a client-side `WorkflowStub`, and then call a Workflow method (annotated with `@WorkflowMethod`).\n\nTo start a Workflow Execution, your Temporal Server must be running, and your front-end service must be accepting gRPC calls.\n\nTo establish a connection with the front-end service, use `WorkflowServiceStubs`.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n```\n\nYou can provide `WorkflowServiceStubsOptions` to override the default values for the gRPC calls.\n\nFor example, the default front-end service gRPC address is set to `127.0.0.1:7233`, where `7233` is the default port for the Temporal Frontend Service.\n\nIf your server is running on a different host or port from the default, you can set it as shown in the following example.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newInstance(\n                    WorkflowServiceStubsOptions.newBuilder()\n                     .setTarget(TARGET_ENDPOINT)\n                            .build());\n```\n\nAfter the connection to the Temporal Frontend Service is established, create a Client for the service stub.\nThe Workflow Client helps with client-side APIs and is required by Workers.\n\nCreate an instance of a `WorkflowClient` for the Workflow service stub, and use `WorkflowClientOptions` to set options for the Workflow Client.\nThe following example shows how to create a `WorkflowClient` instance called \"client\" for the `WorkflowServiceStubs` \"service\" that we created in the previous example, and set `Namespace` option for the `WorkflowClient`.\n\n```java\nWorkflowClient client = WorkflowClient.newInstance(\n                service,\n                WorkflowClientOptions.newBuilder()\n                        .setNamespace(“Abc”)\n                    .build());\n```\n\nFor more information, see [WorkflowClientOptions](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClientOptions.Builder.html).\n\n`WorkflowService` and `WorkflowClient` creation is a heavyweight operation, and will be resource-intensive if created each time you start a Workflow or send a Signal to it.\nThe recommended way is to create them once and reuse where possible.\n\nWith the Client defined, you can start interacting with the Temporal Frontend Service.\n\nTo initialize a Workflow in the Client, create a `WorkflowStub`, and start the Workflow Execution with `WorkflowClient.start()`.\nStarting Workflows or sending Signals or Queries to Workflows from within a Client must be done using `WorkflowStubs`.\n\n```java\nWorkflowClient workflowClient =  WorkflowClient.newInstance(service, clientOptions);\n // Create a Workflow stub.\n YourWorkflow workflow = workflowClient.newWorkflowStub(YourWorkflow.class);\n // Start Workflow asynchronously and call its \"yourWFMethod\" Workflow method\n WorkflowClient.start(workflow::yourWFMethod);\n```\n\nFor more information, see the following:\n\n- [How to spawn a Workflow Execution in Java](/java/how-to-spawn-a-workflow-execution-in-java)\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-customize-activity-type-in-java.md","id":"java/how-to-customize-activity-type-in-java","title":"How to customize Activity Type in Java","description":"The Activity Type defaults to method name with the first letter of the method name capitalized, and can be customized using `namePrefix()` or `{ActivityMethod.name()}` to ensure they are distinct.","label":"Customize Activity Type","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nThe Activity Type defaults to method name, with the first letter of the method name capitalized, and can be customized using `namePrefix()` or `{ActivityMethod.name()}` to ensure they are distinct.\n\nIn the following example, the Activity Type defaults to `ComposeGreeting`.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nTo overwrite this default naming and assign a custom Activity Type, use the `@ActivityMethod` annotation with the `name` parameter.\nIn the following example, the Activity Type is set to \"greet\".\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod(name = \"greet\")\n    String composeGreeting(String greeting, String language);\n}\n```\n\nYou can also define a prefix for all of your Activity Types using the `namePrefix` parameter with the `@ActivityInterface` annotation.\nThe following example shows a `namePrefix` parameter applied to the `@ActivityInterface`, and two Activity methods, of which one is defined using the `@ActivityMethod` annotation.\n\n```java\n@ActivityInterface(namePrefix = \"A_\")\nPublic interface GreetingActivities {\n    String sendGreeting(String input);\n\n  @ActivityMethod(name = \"abc\")\n  String composeGreeting(String greeting, String language);\n}\n```\n\nIn this example, the Activity type for the first method is set to `A_SendGreeting`.\nThe Activity type for the method annotated with `@ActivityMethod` is set to `A_abc`.\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-customize-workflow-type-in-java.md","id":"java/how-to-customize-workflow-type-in-java","title":"How to customize Workflow Type in Java","description":"The Workflow Type defaults to the short name of the Workflow interface, and can be customized with the `name` parameter.","label":"Customize Workflow Type","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nThe Workflow Type defaults to the short name of the Workflow interface.\nIn the following example, the Workflow Type defaults to `NotifyUserAccounts`.\n\n```java\n  @WorkflowInterface\n\n  public interface NotifyUserAccounts {\n    @WorkflowMethod\n    void notify(String[] accountIds);\n}\n```\n\nTo overwrite this default naming and assign a custom Workflow Type, use the `@WorkflowMethod` annotation with the `name` parameter.\nIn the following example, the Workflow Type is set to `Abc`.\n\n```java\n@WorkflowInterface\n\n  public interface NotifyUserAccounts {\n  @WorkflowMethod(name = \"Abc\")\n  void notify(String[] accountIds);\n  }\n```\n\nWhen you set the Workflow Type this way, the value of the `name` parameter does not have to start with an uppercase letter.\n","is_empty":false},{"file_name":"how-to-define-a-query-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-define-a-query-in-java.md","id":"java/how-to-define-a-query-in-java","title":"How to define a Query in Java","description":"Create a Query handler using the `@QueryMethod` annotation in the Workflow interface.","label":"Define Query","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nTo define a Query, define the method name and the result type of the Query.\n\n```java\nquery(String queryType, Class<R> resultClass, Type resultType, Object... args);\n\n  /* @param queryType name of the Query handler. Usually it is a method name.\n   * @param resultClass class of the Query result type\n   * @param args optional Query arguments\n   * @param <R> type of the Query result\n  */\n```\n\nQuery methods can take in any number of input parameters which can be used to limit the data that is returned.\n\nUse the Query method names to send and receive Queries.\n\nQuery methods must never change any Workflow state including starting Activities or blocking threads in any way.\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-define-a-signal-in-java.md","id":"java/how-to-define-a-signal-in-java","title":"How to define Signals in Java","description":"Define a Signal method with `@SignalMethod` annotation in the Workflow interface.","label":"Define Signal","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nThe `@SignalMethod` annotation indicates that the method is used to handle and react to external Signals.\n\n```java\n@SignalMethod\n   void mySignal(String signalName);\n```\n\nThe method can have parameters that contain the Signal payload and must be serializable by the default Jackson JSON Payload Converter.\n\n```java\nvoid mySignal(String signalName, Object... args);\n```\n\nThis method does not return a value and must have a `void` return type.\n\nThings to consider when defining Signals:\n\n- Use Workflow object constructors and initialization blocks to initialize the internal data structures if possible.\n- Signals might be received by a Workflow before the Workflow method is executed.\n  When implementing Signals in scenarios where this can occur, assume that no parts of Workflow code ran.\n  In some cases, Signal method implementation might require some initialization to be performed by the Workflow method code first—for example, when the Signal processing depends on, and is defined by the Workflow input.\n  In this case, you can use a flag to determine whether the Workflow method is already triggered; if not, persist the Signal data into a collection for delayed processing by the Workflow method.\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-define-activity-parameters-in-java.md","id":"java/how-to-define-activity-parameters-in-java","title":"How to define Activity paramters in Java","description":"An Activity interface can have any number of parameters.","label":"Activity parameters","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nAn Activity interface can have any number of parameters.\nAll inputs should be serializable by the default Jackson JSON Payload Converter.\n\nWhen implementing Activities, be mindful of the amount of data that you transfer using the Activity invocation parameters or return values as these are recorded in the Workflow Execution Events History.\nLarge Events Histories can adversely impact performance.\n\nYou can create a custom object, and pass it to the Activity interface, as shown in the following example.\n\n```java\n@ActivityInterface\npublic interface YourActivities {\n    String getCustomObject(CustomObj customobj);\n    void sendCustomObject(CustomObj customobj, String abc);\n}\n```\n\nThe `execute` method in the dynamic Activity interface implementation takes in `EncodedValues` that are inputs to the Activity Execution, as shown in the following example.\n\n```java\n// Dynamic Activity implementation\n public static class DynamicActivityImpl implements DynamicActivity {\n   @Override\n   public Object execute(EncodedValues args) {\n     String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n     return activityType\n         + \": \"\n         + args.get(0, String.class)\n         + \" \"\n         + args.get(1, String.class)\n         + \" from: \"\n         + args.get(2, String.class);\n   }\n }\n```\n\nFor more details, see [Dynamic Activity Reference](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/DynamicActivity.html).\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-define-activity-return-values-in-java.md","id":"java/how-to-define-activity-return-values-in-java","title":"How to define Activity return values in Java","description":"Activity return values must be serializable and deserializable by the provided `DataConverter`","label":"Activity return values","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nActivity return values must be serializable and deserializable by the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.17.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicActivity` can return type Object.\nEnsure that your Workflow or Client can handle an Object type return or is able to convert the Object type response.\n\n- [Data Converter](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-define-workflow-parameters-in-java.md","id":"java/how-to-define-workflow-parameters-in-java","title":"How to define Workflow Parameters in Java","description":"A method annotated with `@WorkflowMethod` can have any number of parameters.","label":"Workflow parameters","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nA method annotated with `@WorkflowMethod` can have any number of parameters.\n\nWe recommend passing a single parameter that contains all the input fields to allow for adding fields in a backward-compatible manner.\n\nNote that all inputs should be serializable by the default Jackson JSON Payload Converter.\n\nYou can create a custom object and pass it to the Workflow method, as shown in the following example.\n\n```java\n//...\n@WorkflowInterface\npublic interface YourWorkflow {\n    @WorkflowMethod\n    String yourWFMethod(CustomObj customobj);\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-define-workflow-return-values-in-java.md","id":"java/how-to-define-workflow-return-values-in-java","title":"How to define Workflow return values in Java","description":"Workflow method arguments and return values must be serializable and deserializable using the provided `DataConverter`.","label":"Workflow return values","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nWorkflow method arguments and return values must be serializable and deserializable using the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.17.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicWorkflow` can return type Object.\nEnsure that your Client can handle an Object type return or is able to convert the Object type response.\n\nRelated references:\n\n- [Data Converter](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-develop-a-worker-program-in-java.md","id":"java/how-to-develop-a-worker-program-in-java","title":"How to develop a Worker Program in Java","description":"Use the `newWorker` method on an instance of a `WorkerFactory` to create a new Worker in Java.","label":"Run a dev Worker","tags":["developer-guide","java","workers"],"ssdi":[],"markdown_content":"\nThe [Worker Process](/concepts/what-is-a-worker-process) is where Workflow Functions and Activity Functions are executed.\n\n- Each [Worker Entity](/concepts/what-is-a-worker-entity) in the Worker Process must register the exact Workflow Types and Activity Types it may execute.\n- Each Worker Entity must also associate itself with exactly one [Task Queue](/concepts/what-is-a-task-queue).\n- Each Worker Entity polling the same Task Queue must be registered with the same Workflow Types and Activity Types.\n\nA [Worker Entity](/concepts/what-is-a-worker-entity) is the component within a Worker Process that listens to a specific Task Queue.\n\nAlthough multiple Worker Entities can be in a single Worker Process, a single Worker Entity Worker Process may be perfectly sufficient.\nFor more information, see the [Worker tuning guide](/dev-guide/worker-performance).\n\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it can make progress for either a Workflow Execution or an Activity Execution.\n\nUse the `newWorker` method on an instance of a [`WorkerFactory`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/worker/WorkerFactory.html) to create a new Worker in Java.\n\nA single Worker Entity can contain many Worker Objects.\nCall the `start()` method on the instance of the `WorkerFactory` to start all the Workers created in this process.\n\n```java\n// ...\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.serviceclient.WorkflowServiceStubs;\nimport io.temporal.worker.Worker;\nimport io.temporal.worker.WorkerFactory;\n\npublic class YourWorker {\n\n  public static void main(String[] args) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker yourWorker = factory.newWorker(\"your_task_queue\");\n\n    // Register Workflow\n    // and/or register Activities\n\n    factory.start();\n  }\n}\n```\n\nAfter creating the Worker entity, register all Workflow Types and all Activity Types that the Worker can execute.\nA Worker can be registered with just Workflows, just Activities, or both.\n\n**Operation guides:**\n\n- [How to tune Workers](/dev-guide/worker-performance)\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-develop-a-workflow-definition-in-java.md","id":"java/how-to-develop-a-workflow-definition-in-java","title":"How to develop a Workflow Definition in Java","description":"In the Temporal Java SDK programming model, a Workflow is a class which implements a Workflow interface.","label":"Develop Workflows","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nWorkflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/concepts/what-is-a-workflow-definition).\n\nIn the Temporal Java SDK programming model, a Workflow Definition comprises a Workflow interface annotated with `@WorkflowInterface` and a Workflow implementation that implements the Workflow interface.\n\nThe Workflow interface is a Java interface and is annotated with `@WorkflowInterface`.\nEach Workflow interface must have only one method annotated with `@WorkflowMethod`.\n\n```java\n// Workflow interface\n@WorkflowInterface\npublic interface YourWorkflow {\n\n    @WorkflowMethod\n    String yourWFMethod(Arguments args);\n}\n```\n\nHowever, when using dynamic Workflows, do not specify a `@WorkflowMethod`, and implement the `DynamicWorkflow` directly in the Workflow implementation code.\n\nThe `@WorkflowMethod` identifies the method that is the starting point of the Workflow Execution.\nThe Workflow Execution completes when this method completes.\n\nYou can create interface inheritance hierarchies to reuse components across other Workflow interfaces.\nThe interface inheritance approach does not apply to `@WorkflowMethod` annotations.\n\nA Workflow implementation implements a Workflow interface.\n\n```java\n// Define the Workflow implementation which implements our getGreeting Workflow method.\n  public static class GreetingWorkflowImpl implements GreetingWorkflow {\n      ...\n    }\n  }\n```\n\nTo call Activities in your Workflow, call the Activity implementation.\n\nUse `ExternalWorkflowStub` to start or send Signals from within a Workflow to other running Workflow Executions.\n\nYou can also invoke other Workflows as Child Workflows with `Workflow.newChildWorkflowStub()` or `Workflow.newUntypedChildWorkflowStub()` within a Workflow Definition.\n\nUse [`DynamicWorkflow`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/DynamicWorkflow.html) to implement Workflow Types dynamically.\nRegister a Workflow implementation type that extends `DynamicWorkflow` to implement any Workflow Type that is not explicitly registered with the Worker.\n\nThe dynamic Workflow interface is implemented with the `execute` method. This method takes in `EncodedValues` that are inputs to the Workflow Execution.\nThese inputs can be specified by the Client when invoking the Workflow Execution.\n\n```java\npublic class MyDynamicWorkflow implements DynamicWorkflow {\n   @Override\n    public Object execute(EncodedValues args) {\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-develop-an-activity-definition-in-java.md","id":"java/how-to-develop-an-activity-definition-in-java","title":"How to develop an Activity Definition in Java","description":"In the Temporal Java SDK programming model, Activities are classes which implement the Activity Interface.","label":"Activity Definition","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nAn [Activity Definition](/concepts/what-is-an-activity) is a combination of the Temporal Java SDK [Activity](https://www.javadoc.io/static/io.temporal/temporal-sdk/0.19.0/io/temporal/activity/Activity.html) Class implementing a specially annotated interface.\n\nAn Activity interface is annotated with `@ActivityInterface` and an Activity implementation implements this Activity interface.\nTo handle Activity types that do not have an explicitly registered handler, you can directly implement a dynamic Activity.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    String composeGreeting(String greeting, String language);\n}\n```\n\nEach method defined in the Activity interface defines a separate Activity method.\nYou can annotate each method in the Activity interface with the `@ActivityMethod` annotation, but this is completely optional.\nThe following example uses the `@ActivityMethod` annotation for the method defined in the previous example.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nAn Activity implementation is a Java class that implements an Activity annotated interface.\n\n```java\n// Implementation for the GreetingActivities interface example from in the previous section\n static class GreetingActivitiesImpl implements GreetingActivities {\n    @Override\n    public String composeGreeting(String greeting, String name) {\n      return greeting + \" \" + name + \"!\";\n    }\n  }\n```\n\nUse `DynamicActivity` to implement any number of Activity types dynamically.\nWhen an Activity implementation that extends `DynamicActivity` is registered, it is called for any Activity type invocation that doesn't have an explicitly registered handler.\n\nThe dynamic Activity interface is implemented with the `execute` method, as shown in the following example.\n\n```java\n// Dynamic Activity implementation\n public static class DynamicGreetingActivityImpl implements DynamicActivity {\n   @Override\n   public Object execute(EncodedValues args) {\n     String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n     return activityType\n         + \": \"\n         + args.get(0, String.class)\n         + \" \"\n         + args.get(1, String.class)\n         + \" from: \"\n         + args.get(2, String.class);\n   }\n }\n```\n\nUse `Activity.getExecutionContext()` to get information about the Activity type that should be implemented dynamically.\n","is_empty":false},{"file_name":"how-to-develop-an-activity-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-develop-an-activity-in-java.md","id":"java/how-to-develop-an-activity-in-java","title":"How to develop an Activity in Java","description":"In the Temporal Java SDK programming model, Activities are classes which implement the Activity Interface.","label":"Activity Development","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nimport ActivityDefinition from './how-to-develop-an-activity-definition-in-java.md'\n\n<ActivityDefinition/>\n\n### Customize Activity Type\n\nimport CustomizeActivityType from './how-to-customize-activity-type-in-java.md'\n\n<CustomizeActivityType/>\n\n### Parameters\n\nimport ActivityParameters from './how-to-define-activity-parameters-in-java.md'\n\n<ActivityParameters/>\n\n### Return values\n\nimport ActivityReturnValues from './how-to-define-activity-return-values-in-java.md'\n\n<ActivityReturnValues/>\n","is_empty":false},{"file_name":"how-to-emit-metrics-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-emit-metrics-in-java.md","id":"java/how-to-emit-metrics-in-java","title":"How to emit metrics in Java","description":"To emit metrics with the Java SDK, use `WorkflowServiceStubsOptions.Builder.setMetricsScope` to set the metrics scope in your Worker or Client code.","label":"Emit metrics","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nTo emit metrics with the Java SDK, use the[`MicrometerClientStatsReporter`](https://github.com/temporalio/sdk-java/blob/55ee7894aec427d7e384c3519732bdd61119961a/src/main/java/io/temporal/common/reporter/MicrometerClientStatsReporter.java#L34) class to integrate with Micrometer MeterRegistry configured for your metrics backend.\n[Micrometer](https://micrometer.io/docs) is a popular Java framework that provides integration with Prometheus and other backends.\n\nThe following example shows how to use `MicrometerClientStatsReporter` to define the metrics scope and set it with the `WorkflowServiceStubsOptions`.\n\n```java\n//...\n   // see the Micrometer documentation for configuration details on other supported monitoring systems.\n   // in this example shows how to set up Prometheus registry and stats reported.\n   PrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\n   StatsReporter reporter = new MicrometerClientStatsReporter(registry);\n    // set up a new scope, report every 10 seconds\n     Scope scope = new RootScopeBuilder()\n             .reporter(reporter)\n             .reportEvery(com.uber.m3.util.Duration.ofSeconds(10));\n   // for Prometheus collection, expose a scrape endpoint.\n   //...\n   // add metrics scope to WorkflowServiceStub options\n   WorkflowServiceStubsOptions stubOptions =\n       WorkflowServiceStubsOptions.newBuilder().setMetricsScope(scope).build();\n//...\n```\n\nFor more details, see the [Java SDK Samples](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/metrics).\nFor details on configuring a Prometheus scrape endpoint with Micrometer, see the [Micrometer Prometheus Configuring](https://micrometer.io/docs/registry/prometheus#_configuring) documentation.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-get-the-result-of-a-workflow-execution-in-java.md","id":"java/how-to-get-the-result-of-a-workflow-execution-in-java","title":"How to get the result of a Workflow Execution in Java","description":"A synchronous Workflow Execution blocks your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure). An asynchronous Workflow Execution immediately returns a value to the caller.","label":"Get Workflow results","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nIf the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.\n\nThe Workflow Id, Run Id, and Namespace may be used to uniquely identify a Workflow Execution in the system and get its result.\n\nIt's possible to both block progress on the result (synchronous execution) or get the result at some other point in time (asynchronous execution).\n\nIn the Temporal Platform, it's also acceptable to use Queries as the preferred method for accessing the state and results of Workflow Executions.\n\nA synchronous Workflow Execution blocks your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure).\n\nThe following example is a type-safe approach for getting the results of a synchronous Workflow Execution.\n\n```java\n FileProcessingWorkflow workflow = client.newWorkflowStub(\n                FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setWorkflowId(workflowId)\n                        .setTaskQueue(taskQueue)\n                        .build();\n\n// start sync and wait for results (or failure)\nString result = workflow.processfile(new Argument());\n```\n\nAn asynchronous Workflow Execution immediately returns a value to the caller.\n\nThe following examples show how to get the results of a Workflow Execution through typed and untyped `WorkflowStub`.\n\n- **Typed WorkflowStub Example**\n\n  ```java\n  // create typed Workflow stub\n  FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setTaskQueue(taskQueue)\n                        .setWorkflowId(workflowId)\n                        .build());\n  // use WorkflowClient.execute (if your Workflow takes in arguments) or WorkflowClient.start (for zero arguments)\n  WorkflowClient.start(workflow::greetCustomer);\n  ```\n\n- **Untyped WorkflowStub Example**\n\n  ```java\n  WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n                  WorkflowOptions.newBuilder()\n                          .setWorkflowId(workflowId)\n                          .setTaskQueue(taskQueue)\n                          .build());\n\n  // blocks until Workflow Execution has been started (not until it completes)\n  untyped.start(argument);\n  ```\n\nIf you need to wait for a Workflow Execution to complete after an asynchronous start, the most straightforward way is to call the blocking Workflow instance again.\n\nNote that if `WorkflowOptions.WorkflowIdReusePolicy` is not set to `AllowDuplicate`, then instead of throwing `DuplicateWorkflowException`, it reconnects to an existing Workflow and waits for its completion.\n\nThe following example shows how to do this from a different process than the one that started the Workflow Execution.\n\n```java\nYourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflow.yourMethod();\n```\n\nAnother way to connect to an existing Workflow and wait for its completion from another process, is to use `UntypedWorkflowStub`. For example:\n\n```java\nWorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = untyped.getResult(String.class);\n```\n\n**Get last (successful) completion result**\n\nFor a Temporal Cron Job, get the result of previous successful runs using `GetLastCompletionResult()`.\nThe method returns `null` if there is no previous completion.\nThe following example shows how to implement this in a Workflow.\n\n```java\npublic String cronWorkflow() {\n    String lastProcessedFileName = Workflow.getLastCompletionResult(String.class);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the Cron schedule runs failed.\nThe next schedule will still get the last successful result if it ever successfully completed at least once.\nFor example, for a daily cron Workflow, if the run succeeds on the first day and fails on the second day, then the third day run will get the result from first day's run using these APIs.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-get-the-result-of-an-activity-execution-in-java.md","id":"java/how-to-get-the-result-of-an-activity-execution-in-java","title":"How to get the result of an Activity Execution","description":"To get the results of an asynchronously invoked Activity method, use the `Promise` `get` method to block until the Activity method result is available.","label":"Activity Execution Result","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nThe call to spawn an [Activity Execution](/concepts/what-is-an-activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.\n\nTo get the results of an asynchronously invoked Activity method, use the `Promise` `get` method to block until the Activity method result is available.\n\nSometimes an Activity Execution lifecycle goes beyond a synchronous method invocation.\nFor example, a request can be put in a queue and later a reply comes and is picked up by a different Worker process.\nThe whole request-reply interaction can be modeled as a single Activity.\n\nTo indicate that an Activity should not be completed upon its method return, call `ActivityExecutionContext.doNotCompleteOnReturn()` from the original Activity thread.\n\nThen later, when replies come, complete the Activity using the `ActivityCompletionClient`.\nTo correlate Activity invocation with completion, use either a `TaskToken` or Workflow and Activity Ids.\n\nFollowing is an example of using `ActivityExecutionContext.doNotCompleteOnReturn()`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n\n    // Used to correlate reply\n    byte[] taskToken = ctx.getInfo().getTaskToken();\n\n    asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n    ctx.doNotCompleteOnReturn();\n\n    // Return value is ignored when doNotCompleteOnReturn was called.\n    return \"ignored\";\n  }\n  ...\n}\n```\n\nWhen the download is complete, the download service potentially can complete the Activity, or fail it from a different process, for example:\n\n```java\n  public <R> void completeActivity(byte[] taskToken, R result) {\n    completionClient.complete(taskToken, result);\n  }\n\n  public void failActivity(byte[] taskToken, Exception failure) {\n    completionClient.completeExceptionally(taskToken, failure);\n  }\n```\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-handle-a-query-in-a-workflow-in-java.md","id":"java/how-to-handle-a-query-in-a-workflow-in-java","title":"How to handle a Query in a Workflow in Java","description":"To handle a Query in a Workflow, define a Query handler method using the `@QueryMethod` annotation in the Workflow interface.","label":"Handle Query","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nTo handle a Query in the Workflow, create a Query handler using the `@QueryMethod` annotation in the Workflow interface and define it in the Workflow implementation.\n\nThe `@QueryMethod` annotation indicates that the method is used to handle a Query that is sent to the Workflow Execution.\nThe method can have parameters that can be used to filter data that the Query returns.\nBecause the method returns a value, it must have a return type that is not `void`.\n\nThe Query name defaults to the name of the method.\nIn the following example, the Query name defaults to `getStatus`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod\n   String getStatus();\n}\n```\n\nTo overwrite this default naming and assign a custom Query name, use the `@QueryMethod` annotation with the `name` parameter. In the following example, the Query name is set to \"history\".\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod(name = \"history\")\n   String getStatus();\n}\n```\n\nA Workflow Definition interface can define multiple methods annotated with `@QueryMethod`, but the method names or the `name` parameters for each must be unique.\n\nThe following Workflow interface has a Query method `getCount()` to handle Queries to this Workflow.\n\n```java\n  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @QueryMethod\n    int getCount();\n  }\n```\n\nThe following example is the Workflow implementation with the Query method defined in the `HelloWorld` Workflow interface from the previous example.\n\n```java\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = \"Hello\";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!\"Bye\".equals(greeting)) {\n        logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n```\n\n**Dynamic Query Handler**\nYou can also implement Query handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicQueryListener` in the Workflow implementation code.\n\n```java\nWorkflow.registerListener(\n  (DynamicQueryHandler)\n      (queryName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Queries sent to the Workflow without a defined handler will be delivered to the `DynamicQueryHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicQueryHandler` can be implemented in both regular and dynamic Workflow implementations.\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-handle-a-signal-in-a-workflow-in-java.md","id":"java/how-to-handle-a-signal-in-a-workflow-in-java","title":"How to handle Signals in an Workflow in Java","description":"Use the @SignalMethod annotation to handle Signals within the Workflow interface.","label":"Handle Signals","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nWorkflows listen for Signals by the Signal's name.\n\nUse the `@SignalMethod` annotation to handle Signals in the Workflow interface.\n\nThe Signal type defaults to the name of the method. In the following example, the Signal type defaults to `retryNow`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod\n   void retryNow();\n}\n```\n\nTo overwrite this default naming and assign a custom Signal type, use the `@SignalMethod` annotation with the `name` parameter.\nIn the following example, the Signal type is set to `retrysignal`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod(name = \"retrysignal\")\n   void retryNow();\n}\n```\n\nA Workflow interface can define any number of methods annotated with `@SignalMethod`, but the method names or the `name` parameters for each must be unique.\n\nIn the following example, we define a Signal method `updateGreeting` to update the greeting in the Workflow.\nWe set a `Workflow.await` in the Workflow implementation to block the current Workflow Execution until the provided unblock condition is evaluated to `true`.\nIn this case, the unblocking condition is evaluated to `true` when the Signal to update the greeting is received.\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n}\n```\n\n```java\npublic class HelloWorldImpl implements HelloWorld {\n    private final Logger workflowLogger = Workflow.getLogger(HelloWorldImpl.class);\n    private String greeting;\n\n    @Override\n    public void sayHello(String name) {\n        int count = 0;\n        while (!\"Bye\".equals(greeting)) {\n            String oldGreeting = greeting;\n            Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n        }\n        workflowLogger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n        this.greeting = greeting;\n    }\n}\n```\n\nThis Workflow completes when the Signal updates the greeting to `Bye`.\n\n**Dynamic Signal Handler**\nYou can also implement Signal handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicSignalListener` in the Workflow implementation code.\n\n```java\nWorkflow.registerListener(\n  (DynamicSignalHandler)\n      (signalName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Signals sent to the Workflow without a defined handler will be delivered to the `DynamicSignalHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicSignalHandler` can be implemented in both regular and dynamic Workflow implementations.\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-handle-workflow-logic-requirements-in-java.md","id":"java/how-to-handle-workflow-logic-requirements-in-java","title":"How to handle Workflow Logic Requirements in Java","description":"When defining Workflows using the Temporal Java SDK, the Workflow code must be written to execute effectively once and to completion.","label":"Workflow logic requirements","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nWhen defining Workflows using the Temporal Java SDK, the Workflow code must be written to execute effectively once and to completion.\n\nThe following constraints apply when writing Workflow Definitions:\n\n- Do not use mutable global variables in your Workflow implementations.\n  This will ensure that multiple Workflow instances are fully isolated.\n- Your Workflow code must be deterministic.\n  Do not call non-deterministic functions (such as non-seeded random or `UUID.randomUUID()`) directly from the Workflow code.\n  The Temporal SDK provides specific API for calling non-deterministic code in your Workflows.\n- Do not use programming language constructs that rely on system time.\n  For example, only use `Workflow.currentTimeMillis()` to get the current time inside a Workflow.\n- Do not use native Java `Thread` or any other multi-threaded classes like `ThreadPoolExecutor`.\n  Use `Async.function` or `Async.procedure`, provided by the Temporal SDK, to execute code asynchronously.\n- Do not use synchronization, locks, or other standard Java blocking concurrency-related classes besides those provided by the Workflow class.\n  There is no need for explicit synchronization because multi-threaded code inside a Workflow is executed one thread at a time and under a global lock.\n  - Call `Workflow.sleep` instead of `Thread.sleep`.\n  - Use `Promise` and `CompletablePromise` instead of `Future` and `CompletableFuture`.\n  - Use `WorkflowQueue` instead of `BlockingQueue`.\n- Use `Workflow.getVersion` when making any changes to the Workflow code.\n  Without this, any deployment of updated Workflow code might break already running Workflows.\n- Do not access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n- Use `DynamicWorkflow` when you need a default Workflow that can handle all Workflow Types that are not registered with a Worker.\n  A single implementation can implement a Workflow Type which by definition is dynamically loaded from some external source.\n  All standard `WorkflowOptions` and determinism rules apply to Dynamic Workflow implementations.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-heartbeat-an-activity-in-java.md","id":"java/how-to-heartbeat-an-activity-in-java","title":"How to Heartbeat an Activity in Java","description":"To inform the Temporal service that the Activity is still alive, use `Activity.getExecutionContext().heartbeat()` in the Activity implementation code.","label":"Activity Heartbeat","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nTo Heartbeat an Activity Execution in Java, use the `Activity.getExecutionContext().heartbeat()` Class method.\n\n```java\npublic class YourActivityDefinitionImpl implements YourActivityDefinition {\n\n  @Override\n  public String yourActivityMethod(YourActivityMethodParam param) {\n    // ...\n    Activity.getExecutionContext().heartbeat(details);\n    // ...\n  }\n  // ...\n}\n```\n\nThe method takes an optional argument, the `details` variable above that represents latest progress of the Activity Execution.\nThis method can take a variety of types such as an exception object, custom object, or string.\n\nIf the Activity Execution times out, the last Heartbeat `details` are included in the thrown `ActivityTimeoutException`, which can be caught by the calling Workflow.\nThe Workflow can then use the `details` information to pass to the next Activity invocation if needed.\n\nIn the case of Activity retries, the last Heartbeat's `details` are available and can be extracted from the last failed attempt by using `Activity.getExecutionContext().getHeartbeatDetails(Class<V> detailsClass)`\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-log-from-a-workflow-in-java.md","id":"java/how-to-log-from-a-workflow-in-java","title":"How to log from a Workflow in Java","description":"To log from a Workflow in Java, use the `Workflow.getLogger` method.","label":"Log from a Workflow","tags":["developer-guide","sdk","java"],"ssdi":[],"markdown_content":"\nTo get a standard `slf4j` logger in your Workflow code, use the [`Workflow.getLogger`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html) method.\n\n```java\nprivate static final Logger logger = Workflow.getLogger(DynamicDslWorkflow.class);\n```\n\nLogs in replay mode are omitted unless the [`WorkerFactoryOptions.Builder.setEnableLoggingInReplay(boolean)`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/worker/WorkerFactoryOptions.Builder.html#setEnableLoggingInReplay(boolean)) method is set to true.\n","is_empty":false},{"file_name":"how-to-manage-namespaces-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-manage-namespaces-in-java.md","id":"java/how-to-manage-namespaces-in-java","title":"How to manage Namespaces in Java","description":"Manage your registered Namespaces on self-hosted Temporal Clusters using tctl (recommended) or programmatically using the APIs for updating, listing, and ddeprecating your Namespaces.","label":"Manage Namespaces","tags":["developer-guide","java"],"ssdi":[],"markdown_content":"\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud/how-to-manage-namespaces-in-temporal-cloud) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can manage your registered Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\n- Update information and configuration for a registered Namespace on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace update`](/tctl-v1/namespace#update)\n    Example\n  - Use the [`UpdateNamespace` API](https://github.com/temporalio/api/blob/e5cf521c6fdc71c69353f3d2ac5506dd6e827af8/temporal/api/workflowservice/v1/service.proto) to update configuration on a Namespace.\n    Example\n\n  ```java\n  import io.temporal.api.workflowservice.v1.*;\n  //...\n  UpdateNamespaceRequest updateNamespaceRequest = UpdateNamespaceRequest.newBuilder()\n              .setNamespace(\"your-namespace-name\") //the namespace that you want to update\n              .setUpdateInfo(UpdateNamespaceInfo.newBuilder() //has options to update namespace info\n                      .setDescription(\"your updated namespace description\") //updates description in the namespace info.\n                      .build())\n              .setConfig(NamespaceConfig.newBuilder() //has options to update namespace configuration\n                      .setWorkflowExecutionRetentionTtl(Durations.fromHours(30)) //updates the retention period for the namespace \"your-namespace--name\" to 30 hrs.\n                      .build())\n              .build();\n      UpdateNamespaceResponse updateNamespaceResponse = namespaceservice.blockingStub().updateNamespace(updateNamespaceRequest);\n  //...\n  ```\n\n- Get details for a registered Namespace on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace describe`](/tctl-v1/namespace#describe)\n  - Use the [`DescribeNamespace` API](https://github.com/temporalio/api/blob/e5cf521c6fdc71c69353f3d2ac5506dd6e827af8/temporal/api/workflowservice/v1/service.proto) to return information and configuration details for a registered Namespace.\n    Example\n\n  ```java\n  import io.temporal.api.workflowservice.v1.*;\n  //...\n  DescribeNamespaceRequest descNamespace = DescribeNamespaceRequest.newBuilder()\n              .setNamespace(\"your-namespace-name\") //specify the namespace you want details for\n              .build();\n      DescribeNamespaceResponse describeNamespaceResponse = namespaceservice.blockingStub().describeNamespace(descNamespace);\n      System.out.println(\"Namespace Description: \" + describeNamespaceResponse);\n  //...\n  ```\n\n- Get details for all registered Namespaces on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace list`](/tctl-v1/namespace#list)\n  - Use the [`ListNamespace` API](https://github.com/temporalio/api/blob/e5cf521c6fdc71c69353f3d2ac5506dd6e827af8/temporal/api/workflowservice/v1/service.proto) to return information and configuration details for all registered Namespaces on your Temporal Cluster.\n    Example\n\n  ```java\n  import io.temporal.api.workflowservice.v1.*;\n  //...\n  ListNamespacesRequest listNamespaces = ListNamespacesRequest.newBuilder().build();\n      ListNamespacesResponse listNamespacesResponse = namespaceservice.blockingStub().listNamespaces(listNamespaces); //lists 1-100 namespaces (1 page) in the active cluster. To list all, set the page size or loop until NextPageToken is nil.\n  //...\n  ```\n\n- Deprecate a Namespace: The [`DeprecateNamespace` API](https://github.com/temporalio/api/blob/e5cf521c6fdc71c69353f3d2ac5506dd6e827af8/temporal/api/workflowservice/v1/service.proto) updates the state of a registered Namespace to \"DEPRECATED\". Once a Namespace is deprecated, you cannot start new Workflow Executions on it. All existing and running Workflow Executions on a deprecated Namespace will continue to run.\n  Example:\n\n  ```java\n  import io.temporal.api.workflowservice.v1.*;\n  //...\n  DeprecateNamespaceRequest deprecateNamespace = DeprecateNamespaceRequest.newBuilder()\n              .setNamespace(\"your-namespace-name\") //specify the namespace that you want to deprecate\n              .build();\n      DeprecateNamespaceResponse response = namespaceservice.blockingStub().deprecateNamespace(deprecateNamespace);\n  //...\n  ```\n\n- Delete a Namespace: The [`DeleteNamespace` API](https://github.com/temporalio/api/blob/e5cf521c6fdc71c69353f3d2ac5506dd6e827af8/temporal/api/workflowservice/v1/service.proto) deletes a Namespace. Deleting a Namespace deletes all running and completed Workflow Executions on the Namespace, and removes them from the persistence store and the visibility store.\n\n  Example:\n\n  ```java\n  //...\n  DeleteNamespaceResponse res =\n  OperatorServiceStubs.newServiceStubs(OperatorServiceStubsOptions.newBuilder()\n          .setChannel(service.getRawChannel())\n          .validateAndBuildWithDefaults())\n      .blockingStub()\n      .deleteNamespace(DeleteNamespaceRequest.newBuilder().setNamespace(\"your-namespace-name\").build());\n  //...\n  ```\n","is_empty":false},{"file_name":"how-to-pass-an-authorization-header-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-pass-an-authorization-header-in-java.md","id":"java/how-to-provide-an-authorization-token-in-java","title":"How to provide an Authorization Token in Java (JWT)","description":"Providing authorization header to Temporal Server in Java SDK including JWT tokens","label":"Authorization","tags":["developer-guide","java","auth"],"ssdi":[],"markdown_content":"\nThe Temporal Server [expects](/security/#authentication) an `authorization` gRPC header with an authorization token to be passed with API calls if [requests authorization](/security/#authorization) is configured.\n\nAuthorization Tokens may be provided to the Temporal Java SDK by implementing a `io.temporal.authorization.AuthorizationTokenSupplier` interface.\nThe implementation should be used to create `io.temporal.authorization.AuthorizationGrpcMetadataProvider` that may be configured on ServiceStub gRPC interceptors list.\n\nThe implementation is called for each SDK gRPC request and may supply dynamic tokens.\n\n**JWT**\n\nOne of the token types that may be passed this way are JWT tokens.\nTemporal Server provides a [default implementation of JWT authentication](/security/#default-jwt-claimmapper).\n\n**Example**\n\n```java\nAuthorizationTokenSupplier tokenSupplier =\n  //your implementation of token supplier\n  () -> \"Bearer <Base64 url-encoded value of the token for default JWT ClaimMapper>\";\nWorkflowServiceStubsOptions serviceStubOptions =\n  WorkflowServiceStubsOptions.newBuilder()\n    //other service stub options\n    .addGrpcMetadataProvider(new AuthorizationGrpcMetadataProvider(tokenSupplier))\n    .build();\nWorkflowServiceStubs service = WorkflowServiceStubs.newServiceStubs(serviceStubOptions);\nWorkflowClient client = WorkflowClient.newInstance(service);\n```\n\nRelated read:\n\n- [How to secure a Temporal Cluster](/security)\n","is_empty":false},{"file_name":"how-to-register-namespace-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-register-namespace-in-java.md","id":"java/how-to-register-namespace-in-java","title":"How to register a Namespace in Java","description":"Use the `RegisterNamespaceRequest` API to register a Namespace and set the Retention Period for the Workflow Execution Event History for the Namespace.","label":"Register Namespaces","tags":["developer-guide","java","workers"],"ssdi":[],"markdown_content":"\nUse the [`RegisterNamespace` API](https://github.com/temporalio/api/blob/f0350f8032ad2f0c60c539b3b61ea37f412f1cf7/temporal/api/workflowservice/v1/service.proto) to register a [Namespace](/concepts/what-is-a-namespace) and set the [Retention Period](/concepts/what-is-a-retention-period) for the Workflow Execution Event History for the Namespace.\n\n```java\n//...\nimport com.google.protobuf.util.Durations;\nimport io.temporal.api.workflowservice.v1.RegisterNamespaceRequest;\n//...\npublic static void createNamespace(String name) {\n    RegisterNamespaceRequest req = RegisterNamespaceRequest.newBuilder()\n            .setNamespace(\"your-custom-namespace\")\n            .setWorkflowExecutionRetentionPeriod(Durations.fromDays(3)) // keeps the Workflow Execution\n            //Event History for up to 3 days in the Persistence store. Not setting this value will throw an error.\n            .build();\n    service.blockingStub().registerNamespace(req);\n}\n//...\n```\n\nThe Retention Period setting using `WorkflowExecutionRetentionPeriod` is mandatory.\nThe minimum value you can set for this period is 1 day.\n\nOnce registered, set Namespace using `WorkflowClientOptions` within a Workflow Client to run your Workflow Executions within that Namespace.\nSee [how to set Namespace in a Client in Java](/java/how-to-create-a-temporal-client-in-java) for details.\n\nNote that Namespace registration using this API takes up to 10 seconds to complete.\nEnsure that you wait for this registration to complete before starting the Workflow Execution against the Namespace.\n\nTo update your Namespace, use the [`UpdateNamespace` API](/dev-guide/java/features/#namespaces) with the `NamespaceClient`.\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-register-types-with-a-worker-in-java.md","id":"java/how-to-register-types-with-a-worker-in-java","title":"How to register types with a Worker in Java","description":"Use `worker.registerWorkflowImplementationTypes` to register Workflow Type and `worker.registerActivitiesImplementations` to register Activity implementation with Workers.","label":"Register Types","tags":["developer-guide","java","workers"],"ssdi":[],"markdown_content":"\nUse `worker.registerWorkflowImplementationTypes` to register Workflow Type and `worker.registerActivitiesImplementations` to register Activity implementation with Workers.\n\nFor Workflows, the Workflow Type is registered with a Worker.\nA Workflow Type can be registered only once per Worker entity.\nIf you define multiple Workflow implementations of the same type, you get an exception at the time of registration.\n\nFor Activities, Activity implementation instances are registered with a Worker because they are stateless and thread-safe.\nYou can pass any number of dependencies in the Activity implementation constructor, such as the database connections, services, etc.\n\nThe following example shows how to register a Workflow and an Activity with a Worker.\n\n```java\nWorker worker = workerFactory.newWorker(\"your_task_queue\");\n...\n// Register Workflow\nworker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n// Register Activity\nworker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n```\n\nWhen you register a single instance of an Activity, you can have multiple instances of Workflow Executions calling the same Activity.\nActivity code must be thread-safe because the same instance of the Activity code is run for every Workflow Execution that calls it.\n\nFor `DynamicWorkflow`, only one Workflow implementation that extends `DynamicWorkflow` can be registered with a Worker.\nThe following example shows how to register the `DynamicWorkflow` and `DynamicActivity` implementation with a Worker.\n\n```java\n  public static void main(String[] arg) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker(TASK_QUEUE);\n\n    /* Register the Dynamic Workflow implementation with the Worker. Workflow implementations\n    ** must be known to the Worker at runtime to dispatch Workflow Tasks.\n    */\n    worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    // Start all the Workers that are in this process.\n    factory.start();\n\n    /* Create the Workflow stub. Note that the Workflow Type is not explicitly registered with the Worker. */\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n    /**\n     * Register Dynamic Activity implementation with the Worker. Since Activities are stateless\n     * and thread-safe, we need to register a shared instance.\n    */\n    worker.registerActivitiesImplementations(new DynamicGreetingActivityImpl());\n\n    /* Start Workflow Execution and immmediately send Signal. Pass in the Workflow args and Signal args. */\n    workflow.signalWithStart(\"greetingSignal\", new Object[] {\"John\"}, new Object[] {\"Hello\"});\n\n    // Wait for the Workflow to finish getting the results.\n    String result = workflow.getResult(String.class);\n\n    System.out.println(result);\n\n    System.exit(0);\n  }\n}\n```\n\nYou can register multiple type-specific Workflow implementations alongside a single `DynamicWorkflow` implementation.\nYou can register only one Activity instance that implements `DynamicActivity` with a Worker.\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-remove-search-attributes-from-a-workflow-in-java.md","id":"java/how-to-remove-search-attributes-from-a-workflow-in-java","title":"How to remove Search Attributes in Java","description":"To remove a Search Attribute, use `upsertSearchAttributes()` with an empty list as its value.","label":"Remove Search Attributes","tags":["developer-guide","sdk","java"],"ssdi":[],"markdown_content":"\nTo remove a Search Attribute, call the `upsertSearchAttributes()` method and set it to an empty map.\n","is_empty":false},{"file_name":"how-to-replay-a-workflow-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-replay-a-workflow-execution-in-java.md","id":"java/how-to-replay-a-workflow-execution-in-java","title":"How to replay a Workflow Execution in Java","description":"Replay a Workflow Execution","label":"Replay a Workflow Execution","tags":["developer-guide","sdk","java"],"ssdi":[],"markdown_content":"\nTo replay Workflow Executions, use the [WorkflowReplayer](https://www.javadoc.io/doc/io.temporal/temporal-testing/latest/io/temporal/testing/WorkflowReplayer.html) class in the `temporal-testing` package.\n\nIn the following example, Event Histories are downloaded from the server, and then replayed.\nNote that this requires Advanced Visibility to be enabled.\n\n```java\n// Note we assume you already have a WorkflowServiceStubs (`service`) and WorkflowClient (`client`)\n// in scope.\nListWorkflowExecutionsRequest listWorkflowExecutionRequest =\n    ListWorkflowExecutionsRequest.newBuilder()\n        .setNamespace(client.getOptions().getNamespace())\n        .setQuery(\"TaskQueue = 'mytaskqueue'\")\n        .build();\nListWorkflowExecutionsResponse listWorkflowExecutionsResponse =\n    service.blockingStub().listWorkflowExecutions(listWorkflowExecutionRequest);\nList<WorkflowExecutionHistory> histories =\n    listWorkflowExecutionsResponse.getExecutionsList().stream()\n        .map(\n            (info) -> {\n              GetWorkflowExecutionHistoryResponse weh =\n                  service.blockingStub().getWorkflowExecutionHistory(\n                      GetWorkflowExecutionHistoryRequest.newBuilder()\n                          .setNamespace(testEnvironment.getNamespace())\n                          .setExecution(info.getExecution())\n                          .build());\n              return new WorkflowExecutionHistory(\n                  weh.getHistory(), info.getExecution().getWorkflowId());\n            })\n        .collect(Collectors.toList());\n\n\nWorkflowReplayer.replayWorkflowExecutions(\n    histories, true, WorkflowA.class, WorkflowB.class, WorkflowC.class);\n```\n\nIn the next example, a single history is loaded from a JSON file on disk:\n\n```java\nFile file = new File(\"my_history.json\");\nWorkflowReplayer.replayWorkflowExecution(file, MyWorkflow.class);\n```\n\nIn both examples, if Event History is non-deterministic, an error is thrown.\nYou can choose to wait until all histories have been replayed with `replayWorkflowExecutions` by setting the `failFast` argument to `false`.\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-send-a-query-to-a-workflow-in-java.md","id":"java/how-to-send-a-query-to-a-workflow-in-java","title":"How to send a Query in Java","description":"To send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.","label":"Send Query","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nTo send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.\n\nFor example, the following Client code calls a Query method `queryGreeting()` defined in the `GreetingWorkflow` Workflow interface.\n\n```java\n // Create our workflow options\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder()\n        .setWorkflowId(WORKFLOW_ID)\n        .setTaskQueue(TASK_QUEUE).build();\n\n    // Create the Temporal client stub. It is used to start our workflow execution.\n    GreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);\n\n    // Start our workflow asynchronously to not use another thread to query.\n    WorkflowClient.start(workflow::createGreeting, \"World\");\n\n    // Query the Workflow to get the current value of greeting and print it.\n    System.out.println(workflow.queryGreeting());\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-send-a-signal-from-a-client-in-java.md","id":"java/how-to-send-a-signal-from-a-client-in-java","title":"How to send a Signal from a Client in Java","description":"To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.","label":"Send Signal from Client","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nTo send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.\n\nIn the following Client code example, we start the Workflow `greetCustomer` and call the Signal method `addCustomer` that is handled in the Workflow.\n\n```java\n// create a typed Workflow stub for GreetingsWorkflow\nGreetingsWorkflow workflow = client.newWorkflowStub(GreetingsWorkflow.class,\n        WorkflowOptions.newBuilder()\n                // set the Task Queue\n                .setTaskQueue(taskQueue)\n                // Workflow Id is recommended but not required\n                .setWorkflowId(workflowId)\n                .build());\n\n// start the Workflow\nWorkflowClient.start(workflow::greetCustomer);\n// send a Signal to the Workflow\nCustomer customer = new Customer(\"John\", \"Spanish\", \"john@john.com\");\nworkflow.addCustomer(customer); //addCustomer is the Signal method defined in the greetCustomer Workflow.\n```\n\nSee [Handle Signals](/java/how-to-handle-a-signal-in-a-workflow-in-java) for details on how to handle Signals in a Workflow.\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-send-a-signal-from-a-workflow-in-java.md","id":"java/how-to-send-a-signal-from-a-workflow-in-java","title":"How to send a Signal from a Workflow in Java","description":"To send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow.","label":"Send Signal from Workflow","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nTo send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow.\n\nThe following example shows how to use an untyped `ExternalWorkflowStub` in the Workflow implementation to send a Signal to another Workflow.\n\n```java\n    public String sendGreeting(String name) {\n\n        // initiate ExternalWorkflowStub to call another Workflow by its Id \"ReplyWF\"\n        ExternalWorkflowStub callRespondWorkflow = Workflow.newUntypedExternalWorkflowStub(\"ReplyWF\");\n\n        String responseTrigger = activity.greeting(\"Hello\", name);\n\n        // send a Signal from this sendGreeting Workflow to the other Workflow\n        // by calling the Signal method name \"getGreetCall\" defined in that Workflow.\n        callRespondWorkflow.signal(\"getGreetCall\", responseTrigger);\n\n        return responseTrigger;\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-send-a-signal-with-start-in-java.md","id":"java/how-to-send-a-signal-with-start-in-java","title":"How to send a Signal-with-Start in Java","description":"To send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart` with a `WorkflowStub` in the Client code.","label":"Signal-With-Start","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nSignal-With-Start is used from the Client.\nIt takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.\n\nIf there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.\n\nTo send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart` with a `WorkflowStub` in the Client code.\nThis method ensures that if the Workflow Execution is in a closed state, a new Workflow Execution is spawned and the Signal is delivered to the running Workflow Execution.\n\nNote that when the `SignalwithStart` spawns a new Workflow Execution, the Signal is delivered before the call to your `@WorkflowMethod`.\nThis means that the Signal handler in your Workflow interface code will execute before the `@WorkfowMethod`.\nYou must ensure that your code logic can deal with this.\n\nIn the following example, the Client code uses `SignalwithStart` to send the Signal `setCustomer` to the `UntypedWorkflowStub` named `GreetingWorkflow`.\nIf the `GreetingWorkflow` Workflow Execution is not running, the `SignalwithStart` starts the Workflow Execution.\n\n```java\n...\npublic static void signalWithStart() {\n        // WorkflowStub is a client-side stub to a single Workflow instance\n        WorkflowStub untypedWorkflowStub = client.newUntypedWorkflowStub(\"GreetingWorkflow\",\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(workflowId)\n                .setTaskQueue(taskQueue)\n                .build());\n\n        untypedWorkflowStub.signalWithStart(\"setCustomer\", new Object[] {customer2}, new Object[] {customer1});\n\n        printWorkflowStatus();\n\n        try {\n            String greeting = untypedWorkflowStub.getResult(String.class);\n            printWorkflowStatus();\n            System.out.println(\"Greeting: \" + greeting);\n        } catch(WorkflowFailedException e) {\n            System.out.println(\"Workflow failed: \" + e.getCause().getMessage());\n            printWorkflowStatus();\n        }\n    }\n...\n```\n\nThe following example shows the Workflow interface for the `GreetingWorkflow` called in the previous example.\n\n```java\n...\n@WorkflowInterface\npublic interface GreetingWorkflow {\n    @WorkflowMethod\n    String greet(Customer customer);\n\n    @SignalMethod\n    void setCustomer(Customer customer);\n\n    @QueryMethod\n    Customer getCustomer();\n...\n}\n```\n\nNote that the Signal handler `setCustomer` is executed before the `@WorkflowMethod` `greet` is called.\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-cron-schedule-in-java.md","id":"java/how-to-set-a-cron-schedule-in-java","title":"How to set a Cron Schedule in Java","description":"Set the Cron Schedule with the `WorkflowStub` instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`","label":"Cron Schedule","tags":["java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nA [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.\n\nSet the Cron Schedule with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\nSetting `setCronSchedule` changes the Workflow Execution into a Temporal Cron Job.\nThe default timezone for a Cron is UTC.\n\n- Type: `String`\n- Default: None\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    YourWorker.yourclient.newWorkflowStub(\n        YourWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(YourWorker.TASK_QUEUE)\n                // Set Cron Schedule\n                .setCronSchedule(\"* * * * *\")\n                .build());\n```\n\nFor more details, see the [Cron Sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/hello/HelloCron.java)\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-custom-logger-in-java.md","id":"java/how-to-set-a-custom-logger-in-java","title":"How to set a custom Logger in Java","description":"Configure your custom logger the same way you would for any other Java application.","label":"Custom Logger","tags":["java","how-to"],"ssdi":[],"markdown_content":"\nTo set a custom logger, supply your own logging implementation and configuration details the same way you would in any other Java application.\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-heartbeat-timeout-in-java.md","id":"java/how-to-set-a-heartbeat-timeout-in-java","title":"How to set a Heartbeat Timeout in Java","description":"To set a Heartbeat Timeout, use `ActivityOptions.newBuilder.setHeartbeatTimeout​`].","label":"Heartbeat Timeout","tags":["Java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nTo set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout), use [`ActivityOptions.newBuilder.setHeartbeatTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: None\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  private final GreetingActivities activities =\n      Workflow.newActivityStub(\n          GreetingActivities.class,\n          ActivityOptions.newBuilder()\n              // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n              // required when setting Activity options.\n              .setStartToCloseTimeout(Duration.ofSeconds(5))\n              .setHeartbeatTimeout(Duration.ofSeconds(2))\n              .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                          // required when setting Activity options.\n                                            .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                            .setHeartbeatTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-parent-close-policy-in-java.md","id":"java/how-to-set-a-parent-close-policy-in-java","title":"How to set Parent Close Policy in Java","description":"Set `Parent Close Policy` on an instance of `ChildWorkflowOptions` using `ChildWorkflowOptions.newBuilder().setParentClosePolicy`.","label":"Parent Close Policy","tags":["java","developer-guide","how-to"],"ssdi":[],"markdown_content":"\nSet [Parent Close Policy](/concepts/what-is-a-parent-close-policy) on an instance of `ChildWorkflowOptions` using [`ChildWorkflowOptions.newBuilder().setParentClosePolicy`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/ChildWorkflowOptions.Builder.html).\n\n- Type: `ChildWorkflowOptions.Builder`\n- Default: `PARENT_CLOSE_POLICY_TERMINATE`\n\n```java\n public void parentWorkflow() {\n     ChildWorkflowOptions options =\n        ChildWorkflowOptions.newBuilder()\n            .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)\n            .build();\n     MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, options);\n     Async.procedure(child::<workflowMethod>, <args>...);\n     Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(child);\n     // Wait for child to start\n     childExecution.get()\n}\n```\n\nIn this example, we are:\n\n1. Setting `ChildWorkflowOptions.ParentClosePolicy` to `ABANDON` when creating a Child Workflow stub.\n2. Starting Child Workflow Execution asynchronously using `Async.function` or `Async.procedure`.\n3. Calling `Workflow.getWorkflowExecution(…)` on the child stub.\n4. Waiting for the `Promise` returned by `getWorkflowExecution` to complete.\n   This indicates whether the Child Workflow started successfully (or failed).\n5. Completing parent Workflow Execution asynchronously.\n\nSteps 3 and 4 are needed to ensure that a Child Workflow Execution starts before the parent closes.\nIf the parent initiates a Child Workflow Execution and then completes immediately after, the Child Workflow will never execute.\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-schedule-to-close-timeout-in-java.md","id":"java/how-to-set-a-schedule-to-close-timeout-in-java","title":"How to set a Schedule-To-Close Timeout in Java","description":"To set a Schedule-To-Close Timeout, use `ActivityOptions.newBuilder.setScheduleToCloseTimeout​`].","label":"Schedule-To-Close Timeout","tags":["Java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nTo set a [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout), use [`ActivityOptions.newBuilder.setScheduleToCloseTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `Duration`\n- Default: Unlimited.\n  Note that if `WorkflowRunTimeout` and/or `WorkflowExecutionTimeout` are defined in the Workflow, all Activity retries will stop when either or both of these timeouts are reached.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                      \"GetCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                          .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-schedule-to-start-timeout-in-java.md","id":"java/how-to-set-a-schedule-to-start-timeout-in-java","title":"How to set a Schedule-To-Start Timeout in Java","description":"To set a Schedule-To-Start Timeout, use `ActivityOptions.newBuilder.setScheduleToStartTimeout​`].","label":"Schedule-To-Start Timeout","tags":["Java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nTo set a [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout), use [`ActivityOptions.newBuilder.setScheduleToStartTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: Unlimited. This timeout is non-retryable.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                          // required when setting Activity options.\n                          .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n             WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"GetCustomerGreeting\",\n                                ActivityOptions.newBuilder()\n                                    .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                    .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-start-to-close-timeout-in-java.md","id":"java/how-to-set-a-start-to-close-timeout-in-java","title":"How to set a Start-To-Close Timeout in Java","description":"To set a Start-To-Close Timeout, use `ActivityOptions.newBuilder.setStartToCloseTimeout​`].","label":"Start-To-Close Timeout","tags":["Java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nTo set a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout), use [`ActivityOptions.newBuilder.setStartToCloseTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `Duration`\n- Default: Defaults to [`ScheduleToCloseTimeout`](#scheduletoclosetimeout) value\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n              ActivityOptions.newBuilder()\n                      .setStartToCloseTimeout(Duration.ofSeconds(2))\n                      .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // Set Activity Execution timeout (single run)\n                                            .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-execution-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-workflow-execution-timeout-in-java.md","id":"java/how-to-set-a-workflow-execution-timeout-in-java","title":"How to set a Workflow Execution Timeout in Java","description":"Set the Workflow Execution Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowExecutionTimeout`.","label":"Workflow Execution Timeout","tags":["java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nSet the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowExecutionTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Execution Timeout duration\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-workflow-id-in-java.md","id":"java/how-to-set-a-workflow-id-in-java","title":"How to set a custom Workflow Id in Java","description":"Set the Workflow Id with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowId​`.","label":"Workflow Id","tags":["Java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nSet the Workflow Id with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowId​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                // Set the Workflow Id\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-run-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-workflow-run-timeout-in-java.md","id":"java/how-to-set-a-workflow-run-timeout-in-java","title":"How to set a Workflow Run Timeout in Java","description":"Set the Workflow Run Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowRunTimeout`.","label":"Workflow Run Timeout","tags":["java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nSet the Workflow Run Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowRunTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Same as [WorkflowExecutionTimeout](/java/how-to-set-a-workflow-execution-timeout-in-java).\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Run Timeout duration\n                .setWorkflowRunTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-workflow-task-queue-in-java.md","id":"java/how-to-set-a-workflow-task-queue-in-java","title":"How to set the Task Queue for Workflow Execution in Java","description":"Set the Workflow Task Queue with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setTaskQueue`.","label":"Task Queue","tags":["java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nSet the Workflow Task Queue with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setTaskQueue`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                // Set the Task Queue\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-a-workflow-task-timeout-in-java.md","id":"java/how-to-set-a-workflow-task-timeout-in-java","title":"How to set a Workflow Task Timeout in Java","description":"Set the Workflow Task Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowTaskTimeout`.","label":"Workflow Task Timeout","tags":["java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nSet the Workflow Task Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowTaskTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: 10 seconds.\n- Values: Maximum accepted value is 60 seconds.\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Task Timeout duration\n                .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-activity-retry-options-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-activity-retry-options-in-java.md","id":"java/how-to-set-activity-retry-options-in-java","title":"How to set Activity Retry Options in Java","description":"To set a Heartbeat Timeout, use `ActivityOptions.newBuilder.setHeartbeatTimeout​`].","label":"Activity Retry Options","tags":["Java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nTo set a Retry Policy, known as the [Retry Options](/concepts/what-is-a-retry-policy) in Java, use [`ActivityOptions.newBuilder.setRetryOptions()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: Server-defined Activity Retry policy.\n\n- With `ActivityStub`\n\n  ```java\n  private final ActivityOptions options =\n      ActivityOptions.newBuilder()\n          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n          // required when setting Activity options.\n          .setStartToCloseTimeout(Duration.ofSeconds(5))\n          .setRetryOptions(\n              RetryOptions.newBuilder()\n                  .setInitialInterval(Duration.ofSeconds(1))\n                  .setMaximumInterval(Duration.ofSeconds(10))\n                  .build())\n          .build();\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                // required when setting Activity options.\n                                .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                .setRetryOptions(\n                                      RetryOptions.newBuilder()\n                                          .setDoNotRetry(NullPointerException.class.getName())\n                                          .build())\n                                .build()))\n                .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-activity-timeouts-in-java.md","id":"java/how-to-set-activity-timeouts-in-java","title":"How to set Activity Timeouts in Java","description":"Activity Timeouts","label":"Activity Timeouts","tags":["Java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nSet your Activity Timeout from the [`ActivityOptions.Builder`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html) class.\n\nAvailable timeouts are:\n\n- ScheduleToCloseTimeout()\n- ScheduleToStartTimeout()\n- StartToCloseTimeout()\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\n\nThe following uses `ActivityStub`.\n\n```java\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                        // .setStartToCloseTimeout(Duration.ofSeconds(2)\n                        // .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                        .build());\n```\n\nThe following uses `WorkflowImplementationOptions`.\n\n```java\nWorkflowImplementationOptions options =\n            WorkflowImplementationOptions.newBuilder()\n                    .setActivityOptions(\n                            ImmutableMap.of(\n                                    \"GetCustomerGreeting\",\n                                    // Set Activity Execution timeout\n                                    ActivityOptions.newBuilder()\n                                        .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                        // .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                        // .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                        .build()))\n                    .build();\n```\n\n:::note\n\nIf you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n:::\n","is_empty":false},{"file_name":"how-to-set-activityoptions-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-activityoptions-in-java.md","id":"java/how-to-set-activityoptions-in-java","title":"How to set ActivityOptions in Java","description":"Use `ActivityOptions` to configure how to invoke an Activity Execution.","label":"Set Activity Options","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nUse `ActivityOptions` to configure how to invoke an Activity Execution.\nNote that Activity options must be set before the Activity Execution is invoked.\n\nYou can set Activity options for Activities within a Workflow or define specific Activity options per Activity Type within a Worker.\n\n## Setting Activity options within a Workflow\n\nUse `ActivityOptions` with `ActivityStub` to set options for invoking Activities within a Workflow.\nThe following example shows how to set `ActivityOptions` for Activities within a Workflow.\n\n```java\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofSeconds(5))\n                        // if task queue not set, it will be same Task Queue as what the Workflow uses\n                        .setTaskQueue(\"yourTaskQueue\")\n                        // If RetryOptions are not explicitly set, Activities have a default RetryOption that apply.\n                       .setRetryOptions(RetryOptions.newBuilder()\n                                .build())\n                        .build());\n```\n\nNote that these Activity options will apply for all the Activities defined in the _GreetingActivities_ Activity interface.\nYou can create multiple Activity stubs within a Workflow, and each can have different Activity options defined.\n\n## Setting per-Activity options when registering a Workflow with a Worker\n\nTo set different options per Activity type, use `.setActivityOptions` with `WorkflowImplementationOptions`.\nNote that if you define options per Activity Type with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically within `ActivityOptions` in a Workflow will override this setting.\n\nThe following example shows how to set Activity options for Activity Types with `WorkflowImplementationOptions`.\n\n```java\n WorkflowImplementationOptions options =\n                WorkflowImplementationOptions.newBuilder()\n                        // setActivityOptions allows you to set different ActivityOption per Activity type.\n                        // By default Activity type is the name of Activity method (with first letter capitalized.)\n                        .setActivityOptions(\n                                ImmutableMap.of(\n                                        \"GetCustomerGreeting\",\n                                        ActivityOptions.newBuilder()\n                                                // Set Activity Execution timeout (including retries)\n                                                .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                                .build(),\n                                        \"EmailCustomerGreeting\",\n                                        ActivityOptions.newBuilder()\n                                                // Set Activity Execution timeout (single run)\n                                                .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                                .setRetryOptions(\n                                                        RetryOptions.newBuilder()\n                                                                // ActivityTypeB activity type shouldn't retry on NPE\n                                                                .setDoNotRetry(NullPointerException.class.getName())\n                                                                .build())\n                                                .build()))\n                        .build();\n// ...\nworker.registerWorkflowImplementationTypes(options, YourWorkflowImpl.class);\n```\n\nFor more details, see [Activity Options Reference](/java/reference-activityoptions).\n","is_empty":false},{"file_name":"how-to-set-child-workflow-options-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-child-workflow-options-in-java.md","id":"java/how-to-set-child-workflow-options-in-java","title":"How to set ChildWorkflowOptions in Java","description":"Set Child Workflow specific options with the `ChildWorkflowOptions` class.","label":"Child Workflow Options","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nSet Child Workflow specific options with the `ChildWorkflowOptions.Builder` class and [methods](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.8.0/io/temporal/workflow/ChildWorkflowOptions.Builder.html).\n\n| Option                                                  | Required | Type                         |\n| ------------------------------------------------------- | -------- | ---------------------------- |\n| [`Namespace`](#namespace)                               | No       | String                       |\n| [`WorkflowId`](#workflowId)                             | No       | String                       |\n| [`ParentClosePolicy`](#parentclosepolicy)               | No       | ChildWorkflowOptions.Builder |\n| [`WorkflowIdReusePolicy`](#workflowidreusepolicy)       | No       | WorkflowIdReusePolicy        |\n| [`WorkflowExecutionTimeout`](#workflowexecutiontimeout) | No       | Duration                     |\n| [`WorkflowRunTimeout`](#workflowruntimeout)             | No       | Duration                     |\n| [`WorkflowTaskTimeout`](#workflowtasktimeout)           | No       | Duration                     |\n| [`RetryOptions`](#retryoptions)                         | No       | RetryOptions                 |\n| [`CronSchedule`](#cronschedule)                         | No       | String                       |\n| [`Memo`](#memo)                                         | No       | String                       |\n| [`SearchAttributes`](#searchattributes)                 | No       | Map<String, Object>          |\n\n### `Namespace`\n\n- Type: `String`\n- Default: Inherits the `namespace` value set from the parent Workflow.\n\n```java\npublic void parentWorkflow() {\n   ChildWorkflowOptions options = ChildWorkflowOptions.newBuilder()\n        .setNamespace(\"childWorkflowNamespace\")\n        .build();\n   GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class, options);\n  }\n```\n\nSee [What is a Namespace?](/concepts/what-is-a-namespace)\n\n### `WorkflowId`\n\n- Type: `String`\n- Default: none\n\n```java\n private void parentWorkflow() {\n        ChildWorkflowOptions options =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowId(\"childWorkflow1\")\n                        .build();\n\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a WorkflowId?](/concepts/what-is-a-workflow-id)\n\n### `ParentClosePolicy`\n\nimport ParentClosePolicy from './how-to-set-a-parent-close-policy-in-java.md'\n\n<ParentClosePolicy/>\n\n### `WorkflowIdReusePolicy`\n\n- Type: `WorkflowIdReusePolicy`\n- Default: `enums.AllowDuplicateFailedOnly` is the default value. It means that the Workflow can start a new run if the previous run failed, was canceled, or was terminated.\n- Values: `AllowDuplicate` allows a new run independently of the previous run closure status.\n  `RejectDuplicate` doesn't allow a new run independently of the previous run closure status.\n\n```java\nprivate void parentWorkflow() {\n       ChildWorkflowOptions options = ChildWorkflowOptions.newBuilder()\n       .setWorkflowId(\"YourWorkflowId\")\n       .setWorkflowRunTimeout(Duration.ofSeconds(5))\n       .setWorkflowIdReusePolicy(\n               WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE\n       )\n       .build();\n       // Get the Child Workflow stub\n       ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n       // invoke Child Workflow and wait for it to complete\n       child.executeChild();\n   }\n```\n\nSee [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy).\n\n### `WorkflowExecutionTimeout`\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```java\nprivate void parentWorkflow() {\n       ChildWorkflowOptions childWorkflowOptions =\n               ChildWorkflowOptions.newBuilder()\n                       .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                       .build();\n       // Get the Child Workflow stub\n       ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n       // invoke Child Workflow and wait for it to complete\n       child.executeChild();\n   }\n```\n\nSee [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout).\n\n### `WorkflowRunTimeout`\n\n- Type: `time.Duration`\n- Default: Same as [WorkflowExecutionTimeout](#WorkflowExecutionTimeout).\n\n```java\nprivate void parentWorkflow() {\n        ChildWorkflowOptions childWorkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowRunTimeout(Duration.ofSeconds(4))\n                        .build();\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a Workflow Run Timeout?](/concepts/what-is-a-workflow-run-timeout)\n\n### `WorkflowTaskTimeout`\n\n- Type: `time.Duration`\n- Default: 10 seconds.\n- Values: Maximum accepted value is 60 seconds.\n\n```java\nprivate void parentWorkflow() {\n       ChildWorkflowOptions childWorkflowOptions =\n               ChildWorkflowOptions.newBuilder()\n                       .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                       .build();\n       // Get the Child Workflow stub\n       ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n       // invoke Child Workflow and wait for it to complete\n       child.executeChild();\n   }\n```\n\nSee [What is a Workflow Task Timeout?](/concepts/what-is-a-workflow-task-timeout)\n\n### `RetryOptions`\n\n- Type: `RetryOptions`\n- Default: `Null` which means no retries will be attempted.\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowExecutionTimeout(Duration.ofSeconds(10)\n                        .setRetryOptions(RetryOptions.newBuilder()\n                                .build())\n                        .build();\n         ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, ChildworkflowOptions);\n         child.executeChild();\n```\n\nSee [What is a Retry Policy?](/concepts/what-is-a-retry-policy)\n\n### `CronSchedule`\n\n- Type: `String`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setCronSchedule(\"@every 10s\")\n                        .build();\n         ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, ChildworkflowOptions);\n         child.executeChild();\n```\n\nSee [Cron Schedules](/concepts/what-is-a-temporal-cron-job#cron-schedules)\n\n### `Memo`\n\n- Type: `String`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // You can set additional non-indexed info via Memo\n                        .setMemo(ImmutableMap.of(\n                                \"memoKey\", \"memoValue\"\n                        ))\n                        .build();\n```\n\nSee [What is a Memo?](/concepts/what-is-a-memo)\n\n### `SearchAttributes`\n\n- Type: `Map<String, Object>`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // You can set search attributes just like in WorkflowOptions\n                        // make sure that these search attributes were added before\n                        .setSearchAttributes(ImmutableMap.of(\"MySearchAttributeNAme\", \"value\"))\n                        .build();\n```\n\nSee [What is a Search Attribute?](/concepts/what-is-a-search-attribute)\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-mtls-configuration-in-java.md","id":"java/how-to-set-mtls-configuration-in-java","title":"How to set mTLS configuration in Java","description":"To set the mTLS configuration in Java, provide the certificate and private key in an instance of `WorkflowServiceStub`.","label":"Set mTLS configuration","tags":["developer-guide","sdk","java"],"ssdi":[],"markdown_content":"\nTo set the mTLS configuration in Java, provide the certificate and private key in an instance of `WorkflowServiceStub`.\n\nThe following example shows how to set up certificates and pass the `SSLContext` for the Client.\n\n```java\nimport io.temporal.serviceclient.SimpleSslContextBuilder;\n...\n// Load your client certificate, which should look like:\n    // -----BEGIN CERTIFICATE-----\n    // ...\n    // -----END CERTIFICATE-----\n    InputStream clientCert = new FileInputStream(System.getenv(\"TEMPORAL_CLIENT_CERT\"));\n    // PKCS8 client key, which should look like:\n    // -----BEGIN PRIVATE KEY-----\n    // ...\n    // -----END PRIVATE KEY-----\n    InputStream clientKey = new FileInputStream(System.getenv(\"TEMPORAL_CLIENT_KEY\"));\n    // For Temporal Cloud this would likely be ${namespace}.tmprl.cloud:7233\n    String targetEndpoint = System.getenv(\"TEMPORAL_ENDPOINT\");\n    // Your registered Namespace.\n    String namespace = System.getenv(\"TEMPORAL_NAMESPACE\");\n    // Create SSL enabled client by passing SslContext, created by SimpleSslContextBuilder.\n    WorkflowServiceStubs service =\n        WorkflowServiceStubs.newInstance(\n            WorkflowServiceStubsOptions.newBuilder()\n                .setSslContext(SimpleSslContextBuilder.forPKCS8(clientCert, clientKey).build())\n                .setTarget(targetEndpoint)\n                .build());\n```\n\nFor more information, see [Sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/ssl/SslEnabledWorker.java).\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-the-namespace-for-a-temporal-client-in-java.md","id":"java/how-to-set-the-namespace-for-a-temporal-client-in-java","title":"How to set a Namespace for a Temporal Client in Java","description":"Use the setNamespace method on Workflow Client Options Builder.","label":"Set Namespace","tags":["how-to","java"],"ssdi":[],"markdown_content":"\nUse the `setNamespace()` method on Workflow Client Options Builder.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\nWorkflowClientOptions clientOptions = WorkflowClientOptions.newBuilder()\n        .setNamespace(\"your-custom-namespace\").build();\nWorkflowClient workflowClient =  WorkflowClient.newInstance(service, clientOptions);\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-timers-in-java.md","id":"java/how-to-set-timers-in-java","title":"How to set Timers in Java","description":"To set a Timer in Java, use `sleep()`.","label":"Timers","tags":["timers","sleep"],"ssdi":[],"markdown_content":"\nTo set a Timer in Java, use [`sleep()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#sleep) and pass the number of seconds you want to wait before continuing.\n\n```java\nsleep(5);\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-retry-options-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-workflow-retry-options-in-java.md","id":"java/how-to-set-workflow-retry-options-in-java","title":"How to set Workflow Retry Options in Java","description":"Set Workflow Retry Options in the `WorkflowStub` instance using `WorkflowOptions.Builder.setWorkflowRetryOptions`.","label":"Workflow Retry Options","tags":["java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nTo set a Workflow Retry Options in the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance use [`WorkflowOptions.Builder.setWorkflowRetryOptions`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: `Null` which means no retries will be attempted.\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Retry Options\n                .setRetryOptions(RetryOptions.newBuilder()\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-workflow-timeouts-in-java.md","id":"java/how-to-set-workflow-timeouts-in-java","title":"How to set Workflow Timeouts in Java","description":"Set the Workflow Execution Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowExecutionTimeout`.","label":"Workflow Timeouts","tags":["java","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nCreate an instance of [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) in the Client code and set your timeout.\n\nAvailable timeouts are:\n\n- [setWorkflowExecutionTimeout()](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html#setWorkflowExecutionTimeout(java.time.Duration))\n- [setWorkflowRunTimeout()](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html#setWorkflowRunTimeout(java.time.Duration))\n- [setWorkflowTaskTimeout()](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html#setWorkflowTaskTimeout(java.time.Duration))\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWorkflow\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Timeout duration\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                // .setWorkflowRunTimeout(Duration.ofSeconds(10))\n                // .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-workflowclientoptions-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-workflowclientoptions-in-java.md","id":"java/how-to-set-workflowclientoptions-in-java","title":"How to set WorkflowClientOptions in Java","description":"Set `WorkflowClient` specific options with the `WorkflowClientOptions` class.","label":"WorkflowClientOptions","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nSet `WorkflowClient` specific options with the `WorkflowClientOptions` class.\n\nThe following table lists the options used to configure `WorkflowClient`.\n\n| Option                  | Description                                                                       | Type                        |\n| ----------------------- | --------------------------------------------------------------------------------- | --------------------------- |\n| setDataConverter        | Set data converter                                                                | DataConverter               |\n| setInterceptors         | Set interceptors used to intercept Workflow Client calls                          | WorkflowClientInterceptor[] |\n| setIdentity             | Set human-readable identity of the Worker                                         | String                      |\n| setBinaryChecksum       | Set Worker binary checksum                                                        | String                      |\n| setContextPropagators   | Set the Context Propagators                                                       | List< ContextPropagator >   |\n| setQueryRejectCondition | Set conditions for when a Query should be rejected by closed and failed Workflows | QueryRejectCondition        |\n","is_empty":false},{"file_name":"how-to-set-workflowservicestuboptions-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-set-workflowservicestuboptions-in-java.md","id":"java/how-to-set-workflowservicestuboptions-in-java","title":"How to set WorkflowServiceStubOptions in Java","description":"Set `WorkflowServiceStub` specific options with the `WorkflowServiceStubOptions` class.","label":"WorkflowServiceStubOptions","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nSet `WorkflowServiceStub`-specific options with the `WorkflowServiceStubOptions` class.\nThe following table lists the options used to configure `WorkflowServiceStub`.\n\n| Option                             | Description                                                                 | Type            |\n| ---------------------------------- | --------------------------------------------------------------------------- | --------------- |\n| setChannel                         | Sets gRPC channel to use. Exclusive with target and sslContext              | ManagedChannel  |\n| setSslContext                      | Sets gRPC SSL Context to use                                                | SslContext      |\n| setEnableHttps                     | Sets option to enable SSL/TLS/HTTPS for gRPC                                | boolean         |\n| setTarget                          | Sets a target string                                                        | String          |\n| setRpcTimeout                      | Sets the rpc timeout value for non query and non long poll calls            | Duration        |\n| setRpcLongPollTimeout              | Sets the rpc timeout value                                                  | Duration        |\n| setRpcQueryTimeout                 | Sets the rpc timeout for queries                                            | Duration        |\n| setRpcRetryOptions                 | Set the rpc retry options                                                   | RpcRetryOptions |\n| setConnectionBackoffResetFrequency | Sets frequency at which gRPC connection backoff should be reset practically | Duration        |\n| setGrpcReconnectFrequency          | Sets frequency at which gRPC channel will be moved into an idle state       | Duration        |\n| setQueryRpcTimeout                 | Set the query rpc options                                                   | Duration        |\n| setHeaders                         | Set the headers                                                             | Metadata        |\n| setBlockingStubInterceptor         | Set blocking stub interceptor                                               | Function        |\n| setFutureStubInterceptor           | Set the future stub interceptor                                             | Function        |\n| setMetricsScope                    | Set the metric scope                                                        | Scope           |\n| setEnableKeepAlive                 | Set keep alive ping from client to the server                               | boolean         |\n| setKeepAliveTime                   | Set the keep alive time                                                     | Duration        |\n| setKeepAliveTimeout                | Set the keep alive timeout                                                  | Duration        |\n| setKeepAlivePermitWithoutStream    | Set if client sends keepalive pings even with no active RPCs                | boolean         |\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-spawn-a-child-workflow-execution-in-java.md","id":"java/how-to-spawn-a-child-workflow-execution-in-java","title":"How to spawn a Child Workflow Execution in Java","description":"The first call to the Child Workflow stub can be synchronous or asynchronous using `Async.function(Functions.Func)` or `Async.procedure(Functions.Proc)`, and must always be to a method annotated with `@WorkflowMethod`.","label":"Child Workflow Execution","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nThe first call to the Child Workflow stub must always be its Workflow method (method annotated with `@WorkflowMethod`).\nSimilar to Activities, invoking Child Workflow methods can be made synchronous or asynchronous by using `Async#function` or `Async#procedure`.\nThe synchronous call blocks until a Child Workflow method completes.\nThe asynchronous call returns a `Promise` which can be used to wait for the completion of the Child Workflow method, as in the following example:\n\n```java\nGreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\nPromise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n// ...\ngreeting.get()\n```\n\nTo execute an untyped Child Workflow asynchronously, call `executeAsync` on the `ChildWorkflowStub`, as shown in the following example.\n\n```java\n//...\nChildWorkflowStub childUntyped =\n    Workflow.newUntypedChildWorkflowStub(\n        \"GreetingChild\", // your workflow type\n        ChildWorkflowOptions.newBuilder().setWorkflowId(\"childWorkflow\").build());\n\nPromise<String> greeting =\n    childUntyped.executeAsync(String.class, String.class, \"Hello\", name);\nString result = greeting.get();\n//...\n```\n\nThe following examples show how to spawn a Child Workflow:\n\n- Spawn a Child Workflow from a Workflow:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n  @WorkflowMethod\n  String composeGreeting(String greeting, String name);\n  }\n  // Child Workflow implementation not shown\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n  @Override\n  public String getGreeting(String name) {\n      GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n      // This is a blocking call that returns only after child has completed.\n      return child.composeGreeting(\"Hello\", name );\n  }\n  }\n  ```\n\n- Spawn two Child Workflows (with the same type) in parallel:\n\n  ```java\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n\n          // Workflows are stateful, so a new stub must be created for each new child.\n          GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting1 = Async.function(child1::composeGreeting, \"Hello\", name);\n\n          // Both children will run concurrently.\n          GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting2 = Async.function(child2::composeGreeting, \"Bye\", name);\n\n          // Do something else here.\n          ...\n          return \"First: \" + greeting1.get() + \", second: \" + greeting2.get();\n      }\n  }\n  ```\n\n- Send a Signal to a Child Workflow from the parent:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n      @WorkflowMethod\n      String composeGreeting(String greeting, String name);\n\n      @SignalMethod\n      void updateName(String name);\n  }\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n          GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n          child.updateName(\"Temporal\");\n          return greeting.get();\n      }\n  }\n  ```\n\n- Sending a Query to Child Workflows from within the parent Workflow code is not supported. However, you can send a Query to Child Workflows from Activities using `WorkflowClient`.\n\nRelated reads:\n\n- [How to set Child Workflow Options in Java](/java/child-workflows)\n\n- [How to develop a Workflow Definition](/java/how-to-develop-a-workflow-definition-in-java)\n\n- Java Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-spawn-a-workflow-execution-in-java.md","id":"java/how-to-spawn-a-workflow-execution-in-java","title":"How to spawn a Workflow Execution in Java","description":"Use `WorkflowStub` to start a Workflow Execution from within a Client, and `ExternalWorkflowStub` to start a different Workflow Execution from within a Workflow.","label":"Start Workflow Execution","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\n[Workflow Execution](/workflows#workflow-execution) semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.\n\nIn the examples below, all Workflow Executions are started using a Temporal Client.\nTo spawn Workflow Executions from within another Workflow Execution, use either the [Child Workflow](#child-workflows) or External Workflow APIs.\n\nSee the [Customize Workflow Type](#customize-workflow-type) section to see how to customize the name of the Workflow Type.\n\nA request to spawn a Workflow Execution causes the Temporal Cluster to create the first Event ([WorkflowExecutionStarted](/references/events/#workflowexecutionstarted)) in the Workflow Execution Event History.\nThe Temporal Cluster then creates the first Workflow Task, resulting in the first [WorkflowTaskScheduled](/references/events/#workflowtaskscheduled) Event.\n\nUse `WorkflowStub` to start a Workflow Execution from within a Client, and `ExternalWorkflowStub` to start a different Workflow Execution from within a Workflow.\n\nSee [`SignalwithStart`](/java/how-to-send-a-signal-with-start-in-java) to start a Workflow Execution to receive a Signal from within another Workflow.\n\n**Using `WorkflowStub`**\n\n`WorkflowStub` is a proxy generated by the `WorkflowClient`.\nEach time a new Workflow Execution is started, an instance of the Workflow implementation object is created.\nThen, one of the methods (depending on the Workflow Type of the instance) annotated with `@WorkflowMethod` can be invoked.\nAs soon as this method returns, the Workflow Execution is considered to be complete.\n\nYou can use a typed or untyped `WorkflowStub` in the client code.\n\n- Typed `WorkflowStub` are useful because they are type safe and allow you to invoke your Workflow methods such as `@WorkflowMethod`, `@QueryMethod`, and `@SignalMethod` directly.\n- An untyped `WorkflowStub` does not use the Workflow interface, and is not type safe. It is more flexible because it has methods from the `WorkflowStub` interface, such as `start`, `signalWithStart`, `getResults` (sync and async), `query`, `signal`, `cancel` and `terminate`.\n  Note that the Temporal Java SDK also provides typed `WorkflowStub` versions for these methods.\n  When using untyped `WorkflowStub`, we rely on the Workflow Type, Activity Type, Child Workflow Type, as well as Query and Signal names.\n  For details, see [Temporal Client](/java/how-to-create-a-temporal-client-in-java).\n\nA Workflow Execution can be started either synchronously or asynchronously.\n\n- Synchronous invocation starts a Workflow and then waits for its completion. If the process that started the Workflow crashes or stops waiting, the Workflow continues executing.\n  Because Workflows are potentially long-running, and Client crashes happen, it is not very commonly found in production use.\n  The following example is a type-safe approach for starting a Workflow Execution synchronously.\n\n  ```java\n    NotifyUserAccounts workflow = client.newWorkflowStub(\n          NotifyUserAccounts.class,\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(\"notifyAccounts\")\n                  .setTaskQueue(taskQueue)\n                  .build()\n          );\n\n  // start the Workflow and wait for a result.\n    workflow.notify(new String[] { \"Account1\", \"Account2\", \"Account3\", \"Account4\", \"Account5\",\n                  \"Account6\", \"Account7\", \"Account8\", \"Account9\", \"Account10\"});\n      }\n  // notify(String[] accountIds) is a Workflow method defined in the Workflow Definition.\n  ```\n\n- Asynchronous start initiates a Workflow Execution and immediately returns to the caller. This is the most common way to start Workflows in production code.\n  The `WorkflowClient` <https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/client/WorkflowClient.java)> provides some static methods, such as `start`, `execute`, `signalWithStart` etc., that help with starting your Workflows asynchronously.\n\n  The following examples show how to start Workflow Executions asynchronously, with either typed or untyped `WorkflowStub`.\n\n  - **Typed WorkflowStub Example**\n\n    ```java\n    // create typed Workflow stub\n    FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n          WorkflowOptions.newBuilder()\n                  .setTaskQueue(taskQueue)\n                  .setWorkflowId(workflowId)\n                  .build());\n    // use WorkflowClient.execute to return future that contains Workflow result or failure, or\n    // use WorkflowClient.start to return WorkflowId and RunId of the started Workflow).\n    WorkflowClient.start(workflow::greetCustomer);\n    ```\n\n  - **Untyped WorkflowStub Example**\n\n    ```java\n    WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(workflowId)\n                  .setTaskQueue(taskQueue)\n                  .build());\n\n    // blocks until Workflow Execution has been started (not until it completes)\n    untyped.start(argument);\n    ```\n\nYou can call a Dynamic Workflow implementation using an untyped `WorkflowStub`.\nThe following example shows how to call the Dynamic Workflow implementation in the Client code.\n\n```java\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    /**\n      * Note that for this part of the client code, the dynamic Workflow implementation must\n      * be known to the Worker at runtime in order to dispatch Workflow tasks, and may be defined\n      * in the Worker definition as:*/\n    // worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    /* Create the Workflow stub to call the dynamic Workflow.\n    * Note that the Workflow Type is not explicitly registered with the Worker.*/\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n```\n\n`DynamicWorkflow` can be used to invoke different Workflow Types.\nTo check what type is running when your Dynamic Workflow `execute` method runs, use `getWorkflowType()` in the implementation code.\n\n```java\nString type = Workflow.getInfo().getWorkflowType();\n```\n\nSee [Workflow Execution Result](/java/how-to-get-the-result-of-a-workflow-execution-in-java) for details on how to get the results of the Workflow Execution.\n\n**Using `ExternalWorkflowStub`**\n\nUse `ExternalWorkflowStub` within a Workflow to invoke, and send Signals to, other Workflows by type.\n\nThis helps particularly for executing Workflows written in other language SDKs, as shown in the following example.\n\n```java\n@Override\n  public String yourWFMethod(String name) {\n      ExternalWorkflowStub callOtherWorkflow = Workflow.newUntypedExternalWorkflowStub(\"OtherWFId\");\n    }\n```\n\nSee the [Temporal Polyglot](https://github.com/tsurdilo/temporal-polyglot) code for examples of executing Workflows written in other language SDKs.\n\n**Recurring start**\n\nYou can start a Workflow Execution on a regular schedule by using [`setCronSchedule`](/java/how-to-set-a-cron-schedule-in-java) Workflow option in the Client code.\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-spawn-an-activity-execution-in-java.md","id":"java/how-to-spawn-an-activity-execution-in-java","title":"How to spawn an Activity Execution in Java","description":"Invoke Activities using `Workflow.newActivityStub`(type-safe) or `Workflow.newUntypedActivityStub` (untyped) from within a Workflow.","label":"Activity Execution","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nActivities are remote procedure calls that must be invoked from within a Workflow using `ActivityStub`.\nActivities are not executable on their own. You cannot start an Activity Execution by itself.\n\nNote that before an Activity Execution is invoked:\n\n- Activity options (either [`setStartToCloseTimeout`](/concepts/what-is-a-start-to-close-timeout) or [`ScheduleToCloseTimeout`](/concepts/what-is-a-schedule-to-close-timeout) are required) must be set for the Activity.\n  For details, see [How to set Activity timeouts](/java/activity-timeouts).\n- The Activity must be registered with a Worker.\n  See [Worker Program](/java/how-to-develop-a-worker-program-in-java)\n- Activity code must be thread-safe.\n\nActivities should only be instantiated using stubs from within a Workflow.\nAn `ActivityStub` returns a client-side stub that implements an Activity interface.\nYou can invoke Activities using `Workflow.newActivityStub`(type-safe) or `Workflow.newUntypedActivityStub` (untyped).\n\nCalling a method on the Activity interface schedules the Activity invocation with the Temporal service, and generates an [`ActivityTaskScheduled` Event](/concepts/what-is-an-event#activitytaskscheduled).\n\nActivities can be invoked synchronously or asynchronously.\n\n**Invoking Activities Synchronously**\n\nIn the following example, we use the type-safe `Workflow.newActivityStub` within the \"FileProcessingWorkflow\" Workflow implementation to create a client-side stub of the `FileProcessingActivities` class. We also define `ActivityOptions` and set `setStartToCloseTimeout` option to one hour.\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) {\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    // ...\n}\n```\n\nA Workflow can have multiple Activity stubs. Each Activity stub can have its own `ActivityOptions` defined.\nThe following example shows a Workflow implementation with two typed Activity stubs.\n\n```java\npublic FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue1\")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue2\")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n```\n\nTo invoke Activities inside Workflows without referencing the interface it implements, use an untyped Activity stub `Workflow.newUntypedActivityStub`.\nThis is useful when the Activity type is not known at compile time, or to invoke Activities implemented in different programming languages.\n\n```java\n   // Workflow code\n    ActivityOptions activityOptions =\n        ActivityOptions.newBuilder()\n        .setStartToCloseTimeout(Duration.ofSeconds(3))\n        .setTaskQueue(\"simple-queue-node\")\n        .build();\n\n    ActivityStub activity = Workflow.newUntypedActivityStub(activityOptions);\n    activity.execute(\"ComposeGreeting\", String.class, \"Hello World\" , \"Spanish\");\n```\n\n**Invoking Activities Asynchronously**\n\nSometimes Workflows need to perform certain operations in parallel.\nThe Temporal Java SDK provides the `Async` class which includes static methods used to invoke any Activity asynchronously.\nThe calls return a result of type `Promise` which is similar to the Java `Future` and `CompletionStage`.\nWhen invoking Activities, use `Async.function` for Activities that return a result, and `Async.procedure` for Activities that return void.\n\nIn the following asynchronous Activity invocation, the method reference is passed to `Async.function` followed by Activity arguments.\n\n```java\nPromise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);\n```\n\nThe following example shows how to call two Activity methods, \"download\" and \"upload\", in parallel on multiple files.\n\n```java\n  public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n      // Download all files in parallel.\n      for (String sourceFilename : args.getSourceFilenames()) {\n        Promise<String> localName =\n            Async.function(activities::download, args.getSourceBucketName(), sourceFilename);\n        localNamePromises.add(localName);\n      }\n      List<String> localNames = new ArrayList<>();\n      for (Promise<String> localName : localNamePromises) {\n        localNames.add(localName.get());\n      }\n      processedNames = activities.processFiles(localNames);\n\n      // Upload all results in parallel.\n      List<Promise<Void>> uploadedList = new ArrayList<>();\n      for (String processedName : processedNames) {\n        Promise<Void> uploaded =\n            Async.procedure(\n                activities::upload,\n                args.getTargetBucketName(),\n                args.getTargetFilename(),\n                processedName);\n        uploadedList.add(uploaded);\n      }\n      // Wait for all uploads to complete.\n      Promise.allOf(uploadedList).get();\n    } finally {\n      for (Promise<String> localNamePromise : localNamePromises) {\n        // Skip files that haven't completed downloading.\n        if (localNamePromise.isCompleted()) {\n          activities.deleteLocalFile(localNamePromise.get());\n        }\n      }\n      if (processedNames != null) {\n        for (String processedName : processedNames) {\n          activities.deleteLocalFile(processedName);\n        }\n      }\n    }\n  }\n```\n\n**Activity Execution Context**\n\n`ActivityExecutionContext` is a context object passed to each Activity implementation by default.\nYou can access it in your Activity implementations via `Activity.getExecutionContext()`.\n\nIt provides getters to access information about the Workflow that invoked the Activity.\nNote that the Activity context information is stored in a thread-local variable.\nTherefore, calls to `getExecutionContext()` succeed only within the thread that invoked the Activity function.\n\nFollowing is an example of using the `ActivityExecutionContext`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n    ActivityInfo info = ctx.getInfo();\n\n    log.info(\"namespace=\" +  info.getActivityNamespace());\n    log.info(\"workflowId=\" + info.getWorkflowId());\n    log.info(\"runId=\" + info.getRunId());\n    log.info(\"activityId=\" + info.getActivityId());\n    log.info(\"activityTimeout=\" + info.getStartToCloseTimeout();\n\n    return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n  }\n    ...\n}\n```\n\nFor details on getting the results of an Activity Execution, see [Activity Execution Result](/java/how-to-get-the-result-of-an-activity-execution-in-java).\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-java.md","id":"java/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-java","title":"How to upsert custom Search Attributes","description":"To upsert custom Search Attributes, call the Workflow.upsertSearchAttributes(Map<String, ?> searchAttributes) method.","label":"Upsert custom Search Attributes","tags":["developer-guide","sdk","java"],"ssdi":[],"markdown_content":"\nIn your Workflow code, call the [`upsertSearchAttributes(Map<String, ?> searchAttributes)`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#upsertSearchAttributes(java.util.Map)) method.\n\n```java\n Map<String, Object> attr1 = new HashMap<>();\n     attr1.put(\"CustomIntField\", 1);\n     attr1.put(\"CustomBoolField\", true);\n     Workflow.upsertSearchAttributes(attr1);\n\n     Map<String, Object> attr2 = new HashMap<>();\n     attr2.put(\"CustomIntField\", Lists.newArrayList(1, 2));\n     attr2.put(\"CustomKeywordField\", \"Seattle\");\n     Workflow.upsertSearchAttributes(attr2);\n```\n\nThe results of `upsertSearchAttributes()` output the following search attributes.\n\n```json\n{\n    \"CustomIntField\": 1, 2,\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"Seattle\",\n  }\n```\n","is_empty":false},{"file_name":"how-to-use-a-custom-payload-codec-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-use-a-custom-payload-codec-in-java.md","id":"java/how-to-use-a-custom-payload-codec-in-java","title":"How to use a custom Payload Codec in Java","description":"Create a custom implementation of `PayloadCodec` and use it in `CodecDataConverter` to set a custom Data Converter.","label":"Custom Payload Codec","tags":["Java","developer-guide"],"ssdi":[],"markdown_content":"\n**Create a custom Payload Codec**\n\nCreate a custom implementation of [`PayloadCodec`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/payload/codec/PayloadCodec.html) and use it in [`CodecDataConverter`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/CodecDataConverter.html) to set a custom Data Converter.\n\nThe Payload Codec does byte-to-byte conversion and must be set with a Data Converter.\n\nDefine custom encryption/compression logic in your `encode` method and decryption/decompression logic in your `decode` method.\n\nThe following example from the [Java encryption sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/encryptedpayloads/CryptCodec.java) shows how to implement encryption and decryption logic on your payloads in your `encode` and `decode` methods.\n\n```java\nclass YourCustomPayloadCodec implements PayloadCodec {\n\n  static final ByteString METADATA_ENCODING =\n      ByteString.copyFrom(\"binary/encrypted\", StandardCharsets.UTF_8);\n\n  private static final String CIPHER = \"AES/GCM/NoPadding\";\n\n  // Define constants that you can add to your encoded Payload to create a new Payload.\n  static final String METADATA_ENCRYPTION_CIPHER_KEY = \"encryption-cipher\";\n\n  static final ByteString METADATA_ENCRYPTION_CIPHER =\n      ByteString.copyFrom(CIPHER, StandardCharsets.UTF_8);\n\n  static final String METADATA_ENCRYPTION_KEY_ID_KEY = \"encryption-key-id\";\n\n  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n\n  // See the linked sample for details on the methods called here.\n  @NotNull\n  @Override\n  public List<Payload> encode(@NotNull List<Payload> payloads) {\n    return payloads.stream().map(this::encodePayload).collect(Collectors.toList());\n  }\n\n  @NotNull\n  @Override\n  public List<Payload> decode(@NotNull List<Payload> payloads) {\n    return payloads.stream().map(this::decodePayload).collect(Collectors.toList());\n  }\n\n  private Payload encodePayload(Payload payload) {\n    String keyId = getKeyId();\n    SecretKey key = getKey(keyId);\n\n    byte[] encryptedData;\n    try {\n      encryptedData = encrypt(payload.toByteArray(), key); // The encrypt method contains your custom encryption logic.\n    } catch (Throwable e) {\n      throw new DataConverterException(e);\n    }\n    // Apply metadata to the encoded Payload that you can verify in your decode method before decoding.\n    // See the sample for details on the metadata values set.\n    return Payload.newBuilder()\n        .putMetadata(EncodingKeys.METADATA_ENCODING_KEY, METADATA_ENCODING)\n        .putMetadata(METADATA_ENCRYPTION_CIPHER_KEY, METADATA_ENCRYPTION_CIPHER)\n        .putMetadata(METADATA_ENCRYPTION_KEY_ID_KEY, ByteString.copyFromUtf8(keyId))\n        .setData(ByteString.copyFrom(encryptedData))\n        .build();\n  }\n\n  private Payload decodePayload(Payload payload) {\n    // Verify the incoming encoded Payload metadata before applying decryption.\n    if (METADATA_ENCODING.equals(\n        payload.getMetadataOrDefault(EncodingKeys.METADATA_ENCODING_KEY, null))) {\n      String keyId;\n      try {\n        keyId = payload.getMetadataOrThrow(METADATA_ENCRYPTION_KEY_ID_KEY).toString(UTF_8);\n      } catch (Exception e) {\n        throw new PayloadCodecException(e);\n      }\n      SecretKey key = getKey(keyId);\n      byte[] plainData;\n      Payload decryptedPayload;\n\n      try {\n        plainData = decrypt(payload.getData().toByteArray(), key); // The decrypt method contains your custom decryption logic.\n        decryptedPayload = Payload.parseFrom(plainData);\n        return decryptedPayload;\n      } catch (Throwable e) {\n        throw new PayloadCodecException(e);\n      }\n    } else {\n      return payload;\n    }\n  }\n\n  private String getKeyId() {\n    // Currently there is no context available to vary which key is used.\n    // Use a fixed key for all payloads.\n    // This still supports key rotation as the key ID is recorded on payloads allowing\n    // decryption to use a previous key.\n\n    return \"test-key-test-key-test-key-test!\";\n  }\n\n  private SecretKey getKey(String keyId) {\n    // Key must be fetched from KMS or other secure storage.\n    // Hard coded here only for example purposes.\n    return new SecretKeySpec(keyId.getBytes(UTF_8), \"AES\");\n  }\n\n  //...\n}\n```\n\n**Set Data Converter to use custom Payload Codec**\n\nUse `CodecDataConverter` with an instance of a Data Converter and the custom `PayloadCodec` in the `WorkflowClient` options that you use in your Worker process and to start your Workflow Executions.\n\nFor example, to set a custom `PayloadCodec` implementation with `DefaultDataConverter`, use the following code:\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n  // Client that can be used to start and signal Workflows\n  WorkflowClient client =\n      WorkflowClient.newInstance(\n          service,\n          WorkflowClientOptions.newBuilder()\n              .setDataConverter(\n                  new CodecDataConverter(\n                      DefaultDataConverter.newDefaultInstance(),\n                      Collections.singletonList(new YourCustomPayloadCodec()))) // Sets the custom Payload Codec created in the previous example with an instance of the default Data Converter.\n              .build());\n```\n\nFor example implementations, see the following samples:\n\n- [Encrypted Payloads](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/encryptedpayloads)\n- [Remote Data Encoder and Codec Server](https://github.com/temporalio/sdk-java/tree/master/temporal-remote-data-encoder)\n","is_empty":false},{"file_name":"how-to-use-a-custom-payload-converter-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-use-a-custom-payload-converter-in-java.md","id":"java/how-to-use-a-custom-payload-converter-in-java","title":"How to use a custom Payload Converter in Java","description":"Create a custom implementation of a `PayloadConverter` interface and use it to override the default Data Converter behavior.","label":"Custom Payload Converter","tags":["Java","developer-guide"],"ssdi":[],"markdown_content":"\nCreate a custom implementation of a [PayloadConverter](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/PayloadConverter.html) interface and use the `withPayloadConverterOverrides` method to implement the custom object conversion with `DefaultDataConverter`.\n\n`PayloadConverter` serializes and deserializes method parameters that need to be sent over the wire.\nYou can create a custom implementation of `PayloadConverter` for custom formats, as shown in the following example:\n\n```java\n/** Payload Converter specific to your custom object */\npublic class YourCustomPayloadConverter implements PayloadConverter {\n //...\n  @Override\n  public String getEncodingType() {\n    return \"json/plain\"; // The encoding type determines which default conversion behavior to override.\n  }\n\n  @Override\n  public Optional<Payload> toData(Object value) throws DataConverterException {\n      // Add your convert-to logic here.\n  }\n\n  @Override\n  public <T> T fromData(Payload content, Class<T> valueClass, Type valueType)\n      throws DataConverterException {\n    // Add your convert-from logic here.\n  }\n//...\n}\n```\n\nYou can also use [specific implementation classes](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.18.1/io/temporal/common/converter/package-summary.html) provided in the Java SDK.\n\nFor example, to create a custom `JacksonJsonPayloadConverter`, use the following:\n\n```java\n//...\nprivate static JacksonJsonPayloadConverter yourCustomJacksonJsonPayloadConverter() {\n  ObjectMapper objectMapper = new ObjectMapper();\n  // Add your custom logic here.\n  return new JacksonJsonPayloadConverter(objectMapper);\n}\n//...\n```\n\nTo set your custom Payload Converter, use it with [withPayloadConverterOverrides](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DefaultDataConverter.html#withPayloadConverterOverrides(io.temporal.common.converter.PayloadConverter...)) with a new instance of `DefaultDataConverter` in your `WorkflowClient` options that you use in your Worker process and to start your Workflow Executions.\n\nThe following example shows how to set a custom `YourCustomPayloadConverter` Payload Converter.\n\n```java\n//...\nDefaultDataConverter ddc =\n        DefaultDataConverter.newDefaultInstance()\n            .withPayloadConverterOverrides(new YourCustomPayloadConverter());\n\n    WorkflowClientOptions workflowClientOptions =\n        WorkflowClientOptions.newBuilder().setDataConverter(ddc).build();\n//...\n```\n","is_empty":false},{"file_name":"how-to-use-a-side-effect-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-use-a-side-effect-in-java.md","id":"java/how-to-use-a-side-effect-in-java","title":"How to use a Side Effect in Java","description":"A Side Effect is a method of execution to produce non-deterministic code.","label":"Side Effect","tags":["Java","developer-guide"],"ssdi":[],"markdown_content":"\nTo use a Side Effect in Java, set the [`sideEffect()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#sideEffect(java.lang.Class,io.temporal.workflow.Functions.Func)) function in your Workflow Execution and return the non-deterministic code.\n\n```java\nint random = Workflow.sideEffect(Integer.class, () -> random.nextInt(100));\nif random < 50 {\n       ....\n} else {\n       ....\n}\n```\n\nHere's another example that uses `sideEffect()`.\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.sideEffect( int.class, () -> {\n        Random random = new SecureRandom();\n        return random.nextInt();\n    });\n\n    String userHome = Workflow.sideEffect(String.class, () -> System.getenv(\"USER_HOME\"));\n\n    if(randomInt % 2 == 0) {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n\nJava also provides a deterministic method to generate random numbers or random UUIDs.\n\nTo generate random numbers in a deterministic method, use [`newRandom()`](https://www.javadoc.io/static/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#newRandom())\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.newRandom().nextInt();\n    // ...\n}\n```\n\nTo generate a random UUID in a deterministic method, use [`randomUUID()`](https://www.javadoc.io/static/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#newRandom()).\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    String randomUUID = Workflow.randomUUID().toString();\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-use-queries-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-use-queries-in-java.md","id":"java/how-to-use-queries-in-java","title":"How to use Queries in Java","description":"Define a Query method inside the Workflow interface, annotated with the `@QueryMethod` annotation and call the method from an external process.","label":"Queries","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nTo use Queries to query the state of a Workflow at any stage of the Workflow Execution, create a Query handler using the `@QueryMethod` annotation in the Workflow interface and call the method in your external process.\n\nYou can send a Query to an open or closed Workflow Execution.\n\nWhen using Queries, the following restrictions apply:\n\n- It cannot modify Workflow state in any way.\n- It is not allowed to block its thread in any way.\n\n### Define Query Method\n\nimport DefineQuery from './how-to-define-a-query-in-java.md'\n\n<DefineQuery/>\n\n### Handle Query\n\nimport HandleQuery from './how-to-handle-a-query-in-a-workflow-in-java.md'\n\n<HandleQuery/>\n\n### Send Query from Temporal Client\n\nimport SendQuery from './how-to-send-a-query-to-a-workflow-in-java.md'\n\n<SendQuery/>\n","is_empty":false},{"file_name":"how-to-use-signals-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-use-signals-in-java.md","id":"java/how-to-use-signals-in-java","title":"How to use Signals in Java","description":"Initiate the Signal method with `@SignalMethod` annotation in the Workflow interface and call it either directly from the Client or from within another Workflow.","label":"Signals","tags":["java","developer-guide"],"ssdi":[],"markdown_content":"\nTo use Signals in Java, initiate the Signal method with `@SignalMethod` annotation in the Workflow interface and call the Signal method either directly from the Client or use `ExternalWorkflowStub` to call the Signal method from within another Workflow.\n\nA Signal method can be called from either a Client or another Workflow to send Signals to this Workflow.\n\nNote that you can send a Signal only to running Workflow Executions.\nYou can use Signals to update the state of a running Workflow Execution.\n\n### Define Signal Method\n\nimport DefineSignal from './how-to-define-a-signal-in-java.md'\n\n<DefineSignal/>\n\n### Handle Signal\n\nimport HandleSignal from './how-to-handle-a-signal-in-a-workflow-in-java.md'\n\n<HandleSignal/>\n\n### Send Signal from Temporal Client\n\nimport SendSignalClient from './how-to-send-a-signal-from-a-client-in-java.md'\n\n<SendSignalClient/>\n\n### Send Signal from within a Workflow\n\nimport SendSignalWorkflow from './how-to-send-a-signal-from-a-workflow-in-java.md'\n\n<SendSignalWorkflow/>\n\n### Signal-With-Start\n\nimport SignalWithStart from './how-to-send-a-signal-with-start-in-java.md'\n\n<SignalWithStart/>\n","is_empty":false},{"file_name":"how-to-use-worker-versioning-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/how-to-use-worker-versioning-in-java.md","id":"java/how-to-use-worker-versioning-in-java","title":"How to use Worker Versioning in Java","description":"Version your Java Workers by using build ID-based versioning","label":"Worker Versioning","tags":["java","how-to"],"ssdi":[],"markdown_content":"\nTo use Worker Versioning in Java, you need to do the following:\n\n1. Determine and assign a Build ID to your built Worker code, and opt in to versioning.\n2. Tell the Task Queue your Worker is listening on about that Build ID, and whether its compatible with an existing Build ID.\n\n### Assign a Build ID to your Worker\n\nLet's say you've chosen `deadbeef` as your Build ID, which might be a short git commit hash (a reasonable choice as Build ID).\nTo assign it in your Worker code, assign the following Worker Options:\n\n```java\n// ...\nWorkerOptions workerOptions = WorkerOptions.newBuilder()\n    .setBuildId(\"deadbeef\")\n    .setUseBuildIdForVersioning(true)\n    // ...\n    .build();\nWorker w = workerFactory.newWorker(\"your_task_queue_name\", workerOptions);\n// ...\n```\n\nThat's all you need to do in your Worker code.\nImportantly, if you start this Worker, it won't receive any tasks.\nThat's because you need to tell the Task Queue about your Worker's Build ID first.\n\n### Tell the Task Queue about your Worker's Build ID\n\nNow you can use the SDK (or the Temporal CLI) to tell the Task Queue about your Worker's Build ID.\nYou might want to do this as part of your CI deployment process.\n\n```java\n// ...\nworkflowClient.updateWorkerBuildIdCompatability(\n    \"your_task_queue_name\", BuildIdOperation.newIdInNewDefaultSet(\"deadbeef\"));\n```\n\nThis code adds the `deadbeef` Build ID to the Task Queue as the sole version in a new version set, which becomes the default for the queue.\nNew Workflows execute on Workers with this Build ID, and existing ones will continue to process by appropriately compatible Workers.\n\nIf, instead, you want to add the Build ID to an existing compatible set, you can do this:\n\n```java\n// ...\nworkflowClient.updateWorkerBuildIdCompatability(\n    \"your_task_queue_name\", BuildIdOperation.newCompatibleVersion(\"deadbeef\", \"some-existing-build-id\"));\n```\n\nThis code adds `deadbeef` to the existing compatible set containing `some-existing-build-id` and marks it as the new default Build ID for that set.\n\nYou can also promote an existing Build ID in a set to be the default for that set:\n\n```java\n// ...\nworkflowClient.updateWorkerBuildIdCompatability(\n    \"your_task_queue_name\", BuildIdOperation.promoteBuildIdWithinSet(\"deadbeef\"));\n```\n\nYou can also promote an entire set to become the default set for the queue. New Workflows will start using that set's default.\n\n```java\n// ...\nworkflowClient.updateWorkerBuildIdCompatability(\n    \"your_task_queue_name\", BuildIdOperation.promoteSetByBuildId(\"deadbeef\"));\n```\n\n### Specify versions for Commands\n\nBy default, Activities, Child Workflows, and Continue-as-New use the same compatible version set as the Workflow that invoked them if they're also using the same Task Queue.\n\nIf you want to override this behavior, you can specify your intent via the `setVersioningIntent` method on the `ActivityOptions`, `ChildWorkflowOptions`, or `ContinueAsNewOptions` objects.\n\n<!-- For more information refer to the [conceptual documentation](/concepts/what-is-worker-versioning). -->\n\nFor example, if you want to use the latest default version for an Activity, you can define your Activity Options like this:\n\n```java\n// ...\nprivate final MyActivity activity =\n    Workflow.newActivityStub(\n        MyActivity.class,\n        ActivityOptions.newBuilder()\n          .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n          .setVersioningIntent(VersioningIntent.VERSIONING_INTENT_DEFAULT)\n          // ...other options\n          .build()\n    );\n// ...\n```\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/index.md","id":"java/index","title":"How to use the Temporal Java SDK","description":"Add the Temporal Java SDK to your project.","label":"Java How-to","tags":["developer-guide","Java"],"ssdi":[],"markdown_content":"\n[![Build status](https://badge.buildkite.com/663f6d1be81be6700c28c242b35905f20b68c4fda7b2c7c4e3.svg?branch=master)](https://buildkite.com/temporal/java-sdk-public)\n\nAdd the [Temporal Java SDK](https://github.com/temporalio/sdk-java) to your project as a dependency:\n\n**[Apache Maven](https://maven.apache.org/)**:\n\n```maven\n<dependency>\n  <groupId>io.temporal</groupId>\n  <artifactId>temporal-sdk</artifactId>\n  <version>1.17.0</version>\n</dependency>\n```\n\n**[Gradle Groovy DSL](https://gradle.org/)**:\n\n```groovy\nimplementation 'io.temporal:temporal-sdk:1.17.0'\n```\n\n**Other**:\n\nAdditional scripts for each SDK version are available here: [https://search.maven.org/artifact/io.temporal/temporal-sdk](https://search.maven.org/artifact/io.temporal/temporal-sdk).\nSelect an SDK version to see available scripts.\n","is_empty":false},{"file_name":"listen-to-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/listen-to-heartbeats.md","id":"java/listen-to-heartbeats","title":"Listen to Heartbeats","description":"When an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.","label":"Listen to Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.\n","is_empty":false},{"file_name":"logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/logging.md","id":"java/logging","title":"How to log from a Workflow","description":"Send logs and errors to a logging service, so that when things go wrong, you can see what happened.","label":"Logging","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nThe SDK core uses `WARN` for its default logging level.\n","is_empty":false},{"file_name":"manage-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/manage-namespaces.md","id":"java/manage-namespaces","title":"How to manage Namespaces","description":"You can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.","label":"Manage Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can manage your registered Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"metrics.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/metrics.md","id":"java/metrics","title":"How to emit metrics","description":"Each Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.","label":"Metrics","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.\nFor a complete list of metrics capable of being emitted, see the [SDK metrics reference](/references/sdk-metrics).\n\nMetrics can be scraped and stored in time series databases, such as:\n\n- [Prometheus](https://prometheus.io/docs/introduction/overview/)\n- [M3db](https://m3db.io/docs/)\n- [statsd](https://github.com/statsd/statsd)\n\nTemporal also provides a dashboard you can integrate with graphing services like [Grafana](https://grafana.com/docs/). For more information, see:\n\n- Temporal's implementation of the [Grafana dashboard](https://github.com/temporalio/dashboards)\n- [How to export metrics in Grafana](https://github.com/temporalio/helm-charts#exploring-metrics-via-grafana)\n","is_empty":false},{"file_name":"mock-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/mock-activities.md","id":"java/mock-activities","title":"How to mock Activities","description":"Mock an Activity by providing mock Activity implementations to the Worker.","label":"Mock Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMock the Activity invocation when unit testing your Workflows.\n\nWhen integration testing Workflows with a Worker, you can mock Activities by providing mock Activity implementations to the Worker.\n","is_empty":false},{"file_name":"mutable-side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/mutable-side-effects.md","id":"java/mutable-side-effects","title":"Mutable Side Effects","description":"Mutable Side Effects are a method of execution to produce non-deterministic code.","label":"Mutable Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMutable Side Effects execute the provided function once, and then it looks up the History of the value with the given Workflow ID.\n\n- If there is no existing value, then it records the function result as a value with the given Workflow Id on the History.\n- If there is an existing value, then it compares whether the existing value from the History has changed from the new function results, by calling the equals function.\n  - If the values are equal, then it returns the value without recording a new Marker Event\n  - If the values aren't equal, then it records the new value with the same ID on the History.\n\n:::note\n\nDuring a Workflow Execution, every new Side Effect call results in a new Marker recorded on the Workflow History; whereas Mutable Side Effects only records a new Marker on the Workflow History if the value for the Side Effect ID changes or is set the first time.\n\nDuring a Replay, Mutable Side Effects will not execute the function again. Instead, it returns the exact same value that was returned during the Workflow Execution.\n\n:::\n","is_empty":false},{"file_name":"namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/namespaces.md","id":"java/namespaces","title":"How to create and manage Namespaces","description":"You can create, update, deprecate or delete your Namespaces using either tctl or SDK APIs..","label":"Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can create, update, deprecate or delete your [Namespaces](/concepts/what-is-a-namespace) using either tctl or SDK APIs.\n\nUse Namespaces to isolate your Workflow Executions according to your needs.\nFor example, you can use Namespaces to match the development lifecycle by having separate `dev` and `prod` Namespaces.\nYou could also use them to ensure Workflow Executions between different teams never communicate - such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) to create and manage a Namespace from the UI, or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces from the command-line interface.\n\nOn self-hosted Temporal Cluster, you can register and manage your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"observability.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/observability.md","id":"java/observability","title":"How to use Temporal Observability features","description":"The observability section of the Temporal Developer's guide covers the many ways to view the current state of your Temporal Application—that is, ways to view which Workflow Executions are tracked by the Temporal Platform and the state of any specified Workflow Execution, either currently or at points of an execution","label":"Observability","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe observability section of the Temporal Developer's guide covers the many ways to view the current state of your [Temporal Application](/concepts/what-is-a-temporal-application)—that is, ways to view which [Workflow Executions](/workflows#workflow-execution) are tracked by the [Temporal Platform](/concepts/what-is-the-temporal-platform) and the state of any specified Workflow Execution, either currently or at points of an execution.\n\nThis section covers features related to viewing the state of the application, including:\n\n- [Metrics](#metrics)\n- [Tracing](#tracing)\n- [Logging](#logging)\n- [Visibility](#visibility)\n","is_empty":false},{"file_name":"parent-close-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/parent-close-policy.md","id":"java/parent-close-policy","title":"How to set a Parent Close Policy","description":"A Parent Close Policy determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).","label":"Parent Close Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Parent Close Policy](/concepts/what-is-a-parent-close-policy) determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).\n\nThe default Parent Close Policy option is set to terminate the Child Workflow Execution.\n","is_empty":false},{"file_name":"queries copy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/queries copy.md","id":"java/queries","title":"How to develop with Queries","description":"A Query is a synchronous operation that is used to get the state of a Workflow Execution.","label":"Queries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Query](/concepts/what-is-a-query) is a synchronous operation that is used to get the state of a Workflow Execution.\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/queries.md","id":"java/queries","title":"Queries in Java","label":"Queries","tags":["java"],"ssdi":[],"markdown_content":"\nWorkflow queries can be used to query a Workflow state by external processes at any time during its execution.\nQuery methods can only be defined inside Workflows Interfaces and are methods annotated with the `@QueryMethod` annotation, for example:\n\n```java\n  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @QueryMethod\n    int getCount();\n  }\n```\n\nNotice that the `getCount` method is annotated with `@QueryMethod`.\nThere can be multiple Query methods per Workflow interface.\n\nThe `QueryMethod` annotation has an optional `name` property which can be used to define the query type.\nIf not specified it defaults to the method name.\n\nLet's look at a Workflow implementation and its query method:\n\n```java\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = \"Hello\";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!\"Bye\".equals(greeting)) {\n        logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n```\n\nThe restrictions on the implementation of the Query method are the following:\n\n- It can not modify Workflow state in any way.\n- It is not allowed to block its thread in any way.\n\nThe Query method usually just returns a value derived from the fields of the Workflow object.\n\nQuery methods can take in any number of input parameters which can be used to limit the data that is returned for example.\n","is_empty":false},{"file_name":"reference-activityoptions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/reference-activityoptions.md","id":"java/reference-activityoptions","title":"Java ActivityOptions reference","description":"Use `ActivityOptions` to configure how to invoke an Activity Execution.","label":"Activity Options reference","tags":["developer-guide","how-to","java"],"ssdi":[],"markdown_content":"\nUse [`ActivityOptions`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html) to configure how to invoke an Activity Execution.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\nThe following table lists all `ActivityOptions` that can be configured for an Activity invocation.\n\n| Option                                                 | Required                                           | Type                     |\n| ------------------------------------------------------ | -------------------------------------------------- | ------------------------ |\n| [`setScheduleToCloseTimeout`](#scheduletoclosetimeout) | Yes (if `StartToCloseTimeout` is not specified)    | Duration                 |\n| [`setScheduleToStartTimeout`](#scheduletostarttimeout) | No                                                 | Duration                 |\n| [`setStartToCloseTimeout`](#starttoclosetimeout)       | Yes (if `ScheduleToCloseTimeout` is not specified) | Duration                 |\n| [`setHeartbeatTimeout`](#heartbeattimeout)             | No                                                 | Duration                 |\n| [`setTaskQueue`](#taskqueue)                           | No                                                 | String                   |\n| [`setRetryOptions`](#retryoptions)                     | No                                                 | RetryOptions             |\n| [`setCancellationType`](#cancellationtype)             | No                                                 | ActivityCancellationType |\n\n#### ScheduleToCloseTimeout\n\nTo set a [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout), use [`ActivityOptions.newBuilder.setScheduleToCloseTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `Duration`\n- Default: Unlimited.\n  Note that if `WorkflowRunTimeout` and/or `WorkflowExecutionTimeout` are defined in the Workflow, all Activity retries will stop when either or both of these timeouts are reached.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                      \"GetCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                          .build()))\n                      .build();\n  ```\n\n#### ScheduleToStartTimeout\n\nTo set a [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout), use [`ActivityOptions.newBuilder.setScheduleToStartTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: Unlimited. This timeout is non-retryable.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                          // required when setting Activity options.\n                          .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n             WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"GetCustomerGreeting\",\n                                ActivityOptions.newBuilder()\n                                    .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                    .build()))\n                      .build();\n  ```\n\n#### StartToCloseTimeout\n\nTo set a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout), use [`ActivityOptions.newBuilder.setStartToCloseTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `Duration`\n- Default: Defaults to [`ScheduleToCloseTimeout`](#scheduletoclosetimeout) value\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n              ActivityOptions.newBuilder()\n                      .setStartToCloseTimeout(Duration.ofSeconds(2))\n                      .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // Set Activity Execution timeout (single run)\n                                            .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n\n#### HeartbeatTimeout\n\nTo set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout), use [`ActivityOptions.newBuilder.setHeartbeatTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: None\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  private final GreetingActivities activities =\n      Workflow.newActivityStub(\n          GreetingActivities.class,\n          ActivityOptions.newBuilder()\n              // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n              // required when setting Activity options.\n              .setStartToCloseTimeout(Duration.ofSeconds(5))\n              .setHeartbeatTimeout(Duration.ofSeconds(2))\n              .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                          // required when setting Activity options.\n                                            .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                            .setHeartbeatTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n\n#### TaskQueue\n\n- Type: `String`\n- Default: Defaults to the Task Queue that the Workflow was started with.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are required when\n                          // setting Activity options.\n                          .setStartToCloseTimeout(Duration.ofSeconds(5))\n                          .setTaskQueue(\"yourTaskQueue\")\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                            // required when setting Activity options.\n                                            .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                            .setTaskQueue(\"yourTaskQueue\")\n                                            .build()))\n                      .build();\n  ```\n\nSee [Task Queue](/concepts/what-is-a-task-queue)\n\n#### RetryOptions\n\nTo set a Retry Policy, known as the [Retry Options](/concepts/what-is-a-retry-policy) in Java, use [`ActivityOptions.newBuilder.setRetryOptions()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: Server-defined Activity Retry policy.\n\n- With `ActivityStub`\n\n  ```java\n  private final ActivityOptions options =\n      ActivityOptions.newBuilder()\n          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n          // required when setting Activity options.\n          .setStartToCloseTimeout(Duration.ofSeconds(5))\n          .setRetryOptions(\n              RetryOptions.newBuilder()\n                  .setInitialInterval(Duration.ofSeconds(1))\n                  .setMaximumInterval(Duration.ofSeconds(10))\n                  .build())\n          .build();\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                // required when setting Activity options.\n                                .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                .setRetryOptions(\n                                      RetryOptions.newBuilder()\n                                          .setDoNotRetry(NullPointerException.class.getName())\n                                          .build())\n                                .build()))\n                .build();\n  ```\n\n#### setCancellationType\n\n- Type: `ActivityCancellationType`\n- Default: `ActivityCancellationType.TRY_CANCEL`\n\n- With `ActivityStub`\n\n  ```java\n  private final GreetingActivities activities =\n    Workflow.newActivityStub(\n        GreetingActivities.class,\n        ActivityOptions.newBuilder()\n            .setCancellationType(ActivityCancellationType.WAIT_CANCELLATION_COMPLETED)\n            .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                .setCancellationType(ActivityCancellationType.WAIT_CANCELLATION_COMPLETED)\n                                .build()))\n                .build();\n  ```\n","is_empty":false},{"file_name":"reference-workflowoptions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/reference-workflowoptions.md","id":"java/reference-workflowoptions","title":"Java WorkflowOptions reference","description":"Create a `newWorkflowStub` in the Temporal Client code, call the instance of the Workflow, and set the Workflow options with the `WorkflowOptions.Builder` class.","label":"Workflow Options reference","tags":["developer-guide","options"],"ssdi":[],"markdown_content":"\nCreate a [`newWorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) in the Temporal Client code, call the instance of the Workflow, and set the Workflow options with the [`WorkflowOptions.Builder`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html) class.\n\nThe following fields are available:\n\n| Option                                                  | Required             | Type                                                                                                                 |\n| ------------------------------------------------------- | -------------------- | -------------------------------------------------------------------------------------------------------------------- |\n| [`WorkflowId`](#id)                                     | No (but recommended) | String                                                                                                               |\n| [`TaskQueue`](#taskqueue)                               | **Yes**              | String                                                                                                               |\n| [`WorkflowExecutionTimeout`](#workflowexecutiontimeout) | No                   | `Duration`                                                                                                           |\n| [`WorkflowRunTimeout`](#workflowruntimeout)             | No                   | `Duration`                                                                                                           |\n| [`WorkflowTaskTimeout`](#workflowtasktimeout)           | No                   | `Duration`                                                                                                           |\n| [`WorkflowIdReusePolicy`](#workflowidreusepolicy)       | No                   | `WorkflowIdReusePolicy`                                                                                              |\n| [`RetryOptions`](#retryoptions)                         | No                   | [`RetryOptions`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.17.0/io/temporal/common/RetryOptions.html) |\n| [`CronSchedule`](#cronschedule)                         | No                   | String                                                                                                               |\n| [`Memo`](#memo)                                         | No                   | string                                                                                                               |\n| [`SearchAttributes`](#searchattributes)                 | No                   | Map<String, Object>                                                                                                  |\n\n#### WorkflowId\n\nSet the Workflow Id with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowId​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                // Set the Workflow Id\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n\n#### TaskQueue\n\nSet the Workflow Task Queue with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setTaskQueue`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                // Set the Task Queue\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n\n#### WorkflowExecutionTimeout\n\nSet the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowExecutionTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Execution Timeout duration\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                .build());\n```\n\n#### WorkflowRunTimeout\n\nSet the Workflow Run Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowRunTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Same as [WorkflowExecutionTimeout](#workflowexecutiontimeout).\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Run Timeout duration\n                .setWorkflowRunTimeout(Duration.ofSeconds(10))\n                .build());\n```\n\n#### WorkflowTaskTimeout\n\nSet the Workflow Task Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowTaskTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: 10 seconds.\n- Values: Maximum accepted value is 60 seconds.\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Task Timeout duration\n                .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                .build());\n```\n\n#### WorkflowIDReusePolicy\n\n- Type: `WorkflowIdReusePolicy`\n- Default: `AllowDuplicate`\n- Values:\n  - `enums.AllowDuplicateFailedOnly`: The Workflow can start if the earlier Workflow Execution failed, Canceled, or Terminated.\n  - `AllowDuplicate`: The Workflow can start regardless of the earlier Execution's closure status.\n  - `RejectDuplicate`: The Workflow can not start if there is a earlier Run.\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Id Reuse Policy\n                .setWorkflowIdReusePolicy(\n                        WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE)\n                .build());\n```\n\n#### RetryOptions\n\nTo set a Workflow Retry Options in the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance use [`WorkflowOptions.Builder.setWorkflowRetryOptions`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: `Null` which means no retries will be attempted.\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Retry Options\n                .setRetryOptions(RetryOptions.newBuilder()\n                .build());\n```\n\n#### CronSchedule\n\nA [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.\n\nSet the Cron Schedule with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\nSetting `setCronSchedule` changes the Workflow Execution into a Temporal Cron Job.\nThe default timezone for a Cron is UTC.\n\n- Type: `String`\n- Default: None\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    YourWorker.yourclient.newWorkflowStub(\n        YourWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(YourWorker.TASK_QUEUE)\n                // Set Cron Schedule\n                .setCronSchedule(\"* * * * *\")\n                .build());\n```\n\nFor more details, see the [Cron Sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/hello/HelloCron.java)\n\n#### Memo\n\n- Type: `String`\n- Default: None\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Memo. You can set additional non-indexed info via Memo\n                        .setMemo(ImmutableMap.of(\n                                \"memoKey\", \"memoValue\"\n                        ))\n                .build());\n```\n\n#### SearchAttributes\n\nSearch Attributes are additional indexed information attributed to Workflow and used for search and visibility.\nThese can be used in a query of List/Scan/Count Workflow APIs.\nThe key and its value type must be registered on Temporal server side.\n\n- Type: `Map<String, Object>`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // Set Search Attributes\n                        .setSearchAttributes(ImmutableMap.of(\"MySearchAttributeNAme\", \"value\"))\n                        .build();\n```\n\nThe following Java types are supported:\n\n- String\n- Long, Integer, Short, Byte\n- Boolean\n- Double\n- OffsetDateTime\n- Collection of the types in this list.\n","is_empty":false},{"file_name":"register-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/register-namespaces.md","id":"java/register-namespaces","title":"How to register Namespaces","description":"On Temporal Cloud, use the Temporal Cloud UI or tcld commands, and on self-hosted Temporal Cluster, use `tctl namespace register` or `RegisterNamespaceRequest` API to create Namespaces.","label":"Register Namespace","tags":["guide-context"],"ssdi":[],"markdown_content":"\nRegistering a Namespace creates a Namespace on the Temporal Cluster or Temporal Cloud.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to create Namespaces.\n\nOn self-hosted Temporal Cluster, you can register your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n","is_empty":false},{"file_name":"registering-types.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/registering-types.md","id":"java/registering-types","title":"How to register types","description":"How to register Workflow and Activity Types","label":"Register types","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it fails that Task.\nHowever, the failure of the Task does not cause the associated Workflow Execution to fail.\n","is_empty":false},{"file_name":"remove-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/remove-search-attributes.md","id":"java/remove-search-attributes","title":"How to remove a Search Attribute from a Workflow","description":"To remove a Search Attribute that was previously set, set it to an empty array.","label":"Remove Search Attribute","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array: `[]`.\n","is_empty":false},{"file_name":"replays.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/replays.md","id":"java/replays","title":"How to Replay a Workflow Execution","description":"Replay recreates the exact state of a Workflow Execution.","label":"Replay","tags":["guide-context"],"ssdi":[],"markdown_content":"\nReplay recreates the exact state of a Workflow Execution.\nYou can replay a Workflow from the beginning of its Event History.\n\nReplay succeeds only if the [Workflow Definition](/concepts/what-is-a-workflow-definition) is compatible with the provided history from a deterministic point of view.\n\nWhen you test changes to your Workflow Definitions, we recommend doing the following as part of your CI checks:\n\n1. Determine which Workflow Types or Task Queues (or both) will be targeted by the Worker code under test.\n2. Download the Event Histories of a representative set of recent open and closed Workflows from each Task Queue, either programmatically using the SDK client or via `tctl`.\n3. Run the Event Histories through replay.\n4. Fail CI if any error is encountered during replay.\n\nThe following are examples of fetching and replaying Event Histories:\n","is_empty":false},{"file_name":"required-activity-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/required-activity-timeout.md","id":"java/required-activity-timeout","title":"How to set the required Activity Timeouts","description":"The only required value that needs to be set is either a Schedule-To-Close Timeout or a Start-To-Close Timeout","label":"Required timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nActivity Execution semantics rely on several parameters.\nThe only required value that needs to be set is either a [Schedule-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) or a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout).\nThese values are set in the Activity Options.\n","is_empty":false},{"file_name":"run-a-temporal-cloud-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/run-a-temporal-cloud-worker.md","id":"java/run-a-temporal-cloud-worker","title":"How to run a Temporal Cloud Worker","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run a Temporal Cloud Worker","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo run a Worker that uses [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"run-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/run-an-activity.md","id":"java/run-an-activity","title":"Run an Activity","description":"If an Activity references its context, you need to mock that context when testing in isolation.","label":"Run an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity references its context, you need to mock that context when testing in isolation.\n","is_empty":false},{"file_name":"schedule-backfill.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-backfill.md","id":"java/schedule-backfill","title":"How to Backfill a Scheduled Workflow","description":null,"label":"Backfill","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe backfill action executes Actions ahead of their specified time range. This command is useful when you need to execute a missed or delayed Action, or when you want to test the Workflow before its scheduled time.\n","is_empty":false},{"file_name":"schedule-create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-create.md","id":"java/schedule-create","title":"How to Create a Scheduled Workflow","description":null,"label":"Create","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe create action enables you to create a new Schedule. When you create a new Schedule, a unique Schedule ID is generated, which you can use to reference the Schedule in other Schedule commands.\n","is_empty":false},{"file_name":"schedule-delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-delete.md","id":"java/schedule-delete","title":"How to Delete a Scheduled Workflow","description":null,"label":"Delete","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe delete action enables you to delete a Schedule. When you delete a Schedule, it does not affect any Workflows that were started by the Schedule.\n","is_empty":false},{"file_name":"schedule-describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-describe.md","id":"java/schedule-describe","title":"How to Describe a Scheduled Workflow","description":null,"label":"Describe","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe describe action shows the current Schedule configuration, including information about past, current, and future Workflow Runs. This command is helpful when you want to get a detailed view of the Schedule and its associated Workflow Runs.\n","is_empty":false},{"file_name":"schedule-list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-list.md","id":"java/schedule-list","title":"How to List a Scheduled Workflow","description":null,"label":"List","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe list action lists all the available Schedules. This command is useful when you want to view a list of all the Schedules and their respective Schedule IDs.\n","is_empty":false},{"file_name":"schedule-pause.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-pause.md","id":"java/schedule-pause","title":"How to Pause a Scheduled Workflow","description":null,"label":"Pause","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe pause action enables you to pause and unpause a Schedule. When you pause a Schedule, all the future Workflow Runs associated with the Schedule are temporarily stopped. This command is useful when you want to temporarily halt a Workflow due to maintenance or any other reason.\n","is_empty":false},{"file_name":"schedule-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-to-close.md","id":"java/schedule-to-close","title":"How to set a Schedule-To-Close Timeout","description":"Use the Schedule-To-Close Timeout to limit the maximum duration of an Activity Execution.","label":"Schedule-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"schedule-to-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-to-start.md","id":"java/schedule-to-start","title":"How to set a Schedule-To-Start Timeout","description":"Use the Schedule-To-Start Timeout to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","label":"Schedule-To-Start Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.\n","is_empty":false},{"file_name":"schedule-trigger.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-trigger.md","id":"java/schedule-trigger","title":"How to Trigger a Scheduled Workflow","description":null,"label":"Trigger","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe trigger action triggers an immediate action with a given Schedule. By default, this action is subject to the Overlap Policy of the Schedule. This command is helpful when you want to execute a Workflow outside of its scheduled time.\n","is_empty":false},{"file_name":"schedule-update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedule-update.md","id":"java/schedule-update","title":"How to Update a Scheduled Workflow","description":null,"label":"Update","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe update action enables you to update an existing Schedule. This command is useful when you need to modify the Schedule's configuration, such as changing the start time, end time, or interval.\n","is_empty":false},{"file_name":"schedules.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/schedules.md","id":"java/schedules","title":"How to Schedule a Workflow","description":"Schedule a Workflow.","label":"Schedule a Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nScheduling Workflows is a crucial aspect of any automation process, especially when dealing with time-sensitive tasks. By scheduling a Workflow, you can automate repetitive tasks, reduce the need for manual intervention, and ensure timely execution of your business processes\n\nUse any of the following action to help Schedule a Workflow Execution and take control over your automation process.\n","is_empty":false},{"file_name":"search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/search-attributes.md","id":"java/search-attributes","title":"How to use Search Attributes","description":"Search Attributes enable complex List Filters to find the exact of Workflow Executions you are looking for.","label":"Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe typical method of retrieving a Workflow Execution is by its Workflow Id.\n\nHowever, sometimes you'll want to retrieve one or more Workflow Executions based on another property. For example, imagine you want to get all Workflow Executions of a certain type that have failed within a time range, so that you can start new ones with the same arguments.\n\nYou can do this with [Search Attributes](/concepts/what-is-a-search-attribute).\n\n- [Default Search Attributes](/concepts/what-is-a-search-attribute#default-search-attributes) like `WorkflowType`, `StartTime` and `ExecutionStatus` are automatically added to Workflow Executions.\n- _Custom Search Attributes_ can contain their own domain-specific data (like `customerId` or `numItems`).\n  - A few [generic Custom Search Attributes](/concepts/what-is-a-search-attribute#custom-search-attributes) like `CustomKeywordField` and `CustomIntField` are created by default in Temporal's [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose).\n\nThe steps to using custom Search Attributes are:\n\n- Create a new Search Attribute in your Cluster using `tctl search-attribute create` or the Cloud UI.\n- Set the value of the Search Attribute for a Workflow Execution:\n  - On the Client by including it as an option when starting the Execution.\n  - In the Workflow by calling `UpsertSearchAttributes`.\n- Read the value of the Search Attribute:\n  - On the Client by calling `DescribeWorkflow`.\n  - In the Workflow by looking at `WorkflowInfo`.\n- Query Workflow Executions by the Search Attribute using a [List Filter](/concepts/what-is-a-list-filter):\n  - [In `tctl`](/tctl-v1/workflow/list).\n  - In code by calling `ListWorkflowExecutions`.\n\nHere is how to query Workflow Executions:\n","is_empty":false},{"file_name":"send-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/send-query.md","id":"java/send-query","title":"How to send a Query","description":"Queries are sent from a Temporal Client.","label":"Send Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are sent from a Temporal Client.\n","is_empty":false},{"file_name":"send-signal-from-client.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/send-signal-from-client.md","id":"java/send-signal-from-client","title":"How to send a Signal from a Temporal Client","description":"When a Signal is sent successfully from the Temporal Client, the WorkflowExecutionSignaled Event appears in the Event History of the Workflow that receives the Signal.","label":"Send Signal from Client","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen a Signal is sent successfully from the Temporal Client, the [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Event History of the Workflow that receives the Signal.\n","is_empty":false},{"file_name":"send-signal-from-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/send-signal-from-workflow.md","id":"java/send-signal-from-workflow","title":"How to send a Signal from a Workflow","description":"A Workflow can send a Signal to another Workflow, in which case it's called an External Signal","label":"Send Signal from Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.\n\nWhen an External Signal is sent:\n\n- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.\n- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.\n","is_empty":false},{"file_name":"set-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/set-custom-search-attributes.md","id":"java/set-custom-search-attributes","title":"How to set custom Search Attributes","description":"After you've created custom Search Attributes in your Cluster (using `tctl` or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.","label":"Custom Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAfter you've created custom Search Attributes in your Cluster (using `tctl search-attribute create`or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.\n","is_empty":false},{"file_name":"set-task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/set-task-queue.md","id":"java/set-task-queue","title":"How to set a Workflow's Task Queue","description":"In most SDKs, the only Workflow Option that must be set is the name of the Task Queue.","label":"Set Task Queue","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn most SDKs, the only Workflow Option that must be set is the name of the [Task Queue](/concepts/what-is-a-task-queue).\n\nFor any code to execute, a Worker Process must be running that contains a Worker Entity that is polling the same Task Queue name.\n","is_empty":false},{"file_name":"set-workflow-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/set-workflow-id.md","id":"java/set-workflow-id","title":"How to set a Workflow Id","description":"Although it is not required, we recommend providing your own Workflow Id that maps to a business process or business entity identifier, such as an order identifier or customer identifier.","label":"Workflow Id","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAlthough it is not required, we recommend providing your own [Workflow Id](/concepts/what-is-a-workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.\n","is_empty":false},{"file_name":"side-effect.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/side-effect.md","id":"java/side-effect","title":"SideEffect","ssdi":[],"markdown_content":"\nWorkflow code must be deterministic.\nThis is important so Temporal can replay your Workflow to the point of failure and continue its execution.\n\nWorkflow code that includes arbitrary side effects (for example getting a random number or generating a random UUID, etc), can cause unpredictable results during replay.\n\nBeing able to add some non-deterministic code inside your Workflow is in some cases important, and you can do that using `Workflow.sideEffect`.\n\nThe following sample demonstrates how to use it:\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.sideEffect( int.class, () -> {\n        Random random = new SecureRandom();\n        return random.nextInt();\n    });\n\n    String userHome = Workflow.sideEffect(String.class, () -> System.getenv(\"USER_HOME\"));\n\n    if(randomInt % 2 == 0) {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n\nThe result of `Workflow.sideEffect` is recorded into the Workflow history, meaning that during a replay it will be returned from the history without executing its code again.\n\nNote that you shouldn't modify the Workflow state inside `Workflow.sideEffect`.\nFor that you should only use the `Workflow.sideEffect` return value.\n\nThe Temporal Java SDK provides deterministic methods to generate a random number, or a random UUID as well:\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.newRandom().nextInt();\n\n    String randomUUID = Workflow.randomUUID().toString();\n\n    // ...\n}\n```\n","is_empty":false},{"file_name":"side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/side-effects.md","id":"java/side-effects","title":"Side Effects","description":"A Side Effect is used to produce non-deterministic code, such as generating a UUID or a random number.","label":"Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSide Effects are used to execute non-deterministic code, such as generating a UUID or a random number, without compromising deterministic in the Workflow. This is done by storing the non-deterministic results of the Side Effect into the Workflow [Event History](/workflows/#event-history).\n\nA Side Effect does not re-execute during a Replay. Instead, it returns the recorded result from the Workflow Execution Event History.\n\nSide Effects should not fail. An exception that is thrown from the Side Effect causes failure and retry of the current Workflow Task.\n\nAn Activity or a Local Activity may also be used instead of a Side effect, as its result is also persisted in Workflow Execution History.\n\n:::note\n\nYou shouldn’t modify the Workflow state inside a Side Effect function, because it is not reexecuted during Replay. Side Effect function should be used to return a value.\n\n:::\n","is_empty":false},{"file_name":"signals copy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/signals copy.md","id":"java/signals","title":"How to develop with Signals","description":"A Signal is a message sent to a running Workflow Execution","label":"Signals","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Signal](/concepts/what-is-a-signal) is a message sent to a running Workflow Execution.\n\nSignals are defined in your code and handled in your Workflow Definition.\nSignals can be sent to Workflow Executions from a Temporal Client or from another Workflow Execution.\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/signals.md","id":"java/signals","title":"Signals in Java","label":"Signals","tags":["java"],"ssdi":[],"markdown_content":"\nimport {RelatedReadContainer, RelatedReadItem} from '../components/RelatedReadList.js'\n\n<!-- prettier-ignore -->\n\nimport * as WhatIsASignal from '../concepts/what-is-a-signal.md'\n\n<RelatedReadContainer>\n  <RelatedReadItem page={WhatIsASignal} />\n</RelatedReadContainer>\n\nSignal methods can only be defined inside Workflows Interfaces and are methods annotated with the `@SignalMethod` annotation, for example:\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n\n    @SignalMethod\n    void exit();\n}\n```\n\nA Workflow interface can define any number of signal methods.\n\nNote that the `@SignalMethod` interface has a `name` parameter which can be used to set the signal type.\nIf not specified, the signal type defaults to the name of the method.\n\nThe following example shows how signals can be used to update the Workflow state.\nYou can use the `Workflow.await` to block the current Workflow Execution until the provided unblock condition is evaluated to `true`.\nIn our case, the unblocking condition is evaluated to `true` when we receive a Signal that updates the greeting to something different from the current greeting.\nThis Workflow completes when the greeting becomes \"Bye\".\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n}\n```\n\n```java\npublic class HelloWorldImpl implements HelloWorld {\n    private final Logger workflowLogger = Workflow.getLogger(HelloWorldImpl.class);\n    private String greeting;\n\n    @Override\n    public void sayHello(String name) {\n        int count = 0;\n        while (!\"Bye\".equals(greeting)) {\n            String oldGreeting = greeting;\n            Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n        }\n        workflowLogger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n        this.greeting = greeting;\n    }\n}\n```\n","is_empty":false},{"file_name":"skip-time-set-up.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/skip-time-set-up.md","id":"java/skip-time-set-up","title":"Set up time skipping","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Setting up","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to set up the time-skipping test framework in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/skip-time-skip-activities.md","id":"java/skip-time-skip-activities","title":"Skip time in Activities","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time in Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time in Activities in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-automatically.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/skip-time-skip-automatically.md","id":"java/skip-time-skip-automatically","title":"Skip time automatically","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Automatic method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can skip time automatically in the SDK of your choice.\nStart a test server process that skips time as needed.\nFor example, in the time-skipping mode, Timers, which include sleeps and conditional timeouts, are fast-forwarded except when Activities are running.\n","is_empty":false},{"file_name":"skip-time-skip-manually.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/skip-time-skip-manually.md","id":"java/skip-time-skip-manually","title":"Skip time manually","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Manual method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time manually in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/skip-time.md","id":"java/skip-time","title":"How to skip time","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSome long-running Workflows can persist for months or even years.\nImplementing the test framework allows your Workflow code to skip time and complete your tests in seconds rather than the Workflow's specified amount.\n\nFor example, if you have a Workflow sleep for a day, or have an Activity failure with a long retry interval, you don't need to wait the entire length of the sleep period to test whether the sleep function works.\nInstead, test the logic that happens after the sleep by skipping forward in time and complete your tests in a timely manner.\n\n:::note\n\nSkipping time is not relevant to unit testing Workflow code, because in that case you’re mocking functions that take time, like sleep and Activity calls.\n\n:::\n\nThe test framework included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.\nTime is a global property of an instance of `TestWorkflowEnvironment`: skipping time (either automatically or manually) applies to all currently running tests.\nIf you need different time behaviors for different tests, run your tests in a series or with separate instances of the test server.\nFor example, you could run all tests with automatic time skipping in parallel, and then all tests with manual time skipping in series, and then all tests without time skipping in parallel.\n","is_empty":false},{"file_name":"spawning-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/spawning-activities.md","id":"java/spawning-activities","title":"How to start an Activity Execution","description":"Calls to spawn Activity Executions are written within a Workflow Definition.","label":"Activity Execution","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCalls to spawn [Activity Executions](/concepts/what-is-an-activity-execution) are written within a [Workflow Definition](/concepts/what-is-a-workflow-definition).\nThe call to spawn an Activity Execution generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nThis results in the set of three [Activity Task](/concepts/what-is-an-activity-task) related Events ([ActivityTaskScheduled](/references/events/#activitytaskscheduled), [ActivityTaskStarted](/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.\n\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the Execution history.\nThe entire Execution history is transferred from the Temporal service to Workflow Workers when a Workflow state needs to recover.\nA large Execution history can thus adversely impact the performance of your Workflow.\n\nTherefore, be mindful of the amount of data you transfer through Activity invocation parameters or Return Values.\nOtherwise, no additional limitations exist on Activity implementations.\n","is_empty":false},{"file_name":"start-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/start-to-close.md","id":"java/start-to-close","title":"How to set a Start-To-Close Timeout","description":"Use the Start-To-Close Timeout to limit the maximum duration of a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) to limit the maximum duration of a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n","is_empty":false},{"file_name":"task-queues.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/task-queues.md","id":"java/task-queues","title":"Task Queues in Java","label":"Task Queues","ssdi":[],"markdown_content":"\nIn Java, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```java\npublic class InitiateWorkflow {\n\n  public static void main(String[] args) throws Exception {\n    // Create the WorkflowClient\n    // ...\n    WorkflowOptions options = WorkflowOptions.newBuilder()\n      .setTaskQueue(\"Workflow-Task-Queue-1\")\n      .build();\n    // pass the options to the Workflow stub\n    HelloWorldWorkflow workflow = client.newWorkflowStub(\n      WorkflowImplementation.class,\n      options\n    );\n    // Call the Workflow method on the implementation\n    // ...\n  }\n}\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```java\npublic class YourWorker {\n\n  public static void main(String[] args) {\n    // Create the WorkflowClient\n    // ...\n    // Create a Worker factory that can be used to create Workers that poll specific Task Queues.\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker(\"Workflow-Task-Queue-1\");\n    // Register Workflow implementation classes\n    worker.registerWorkflowImplementationTypes(YourdWorkflowImpl.class);\n    // Start polling the Task Queue.\n    factory.start();\n  }\n}\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```java\npublic class YourWorkflowImpl implements YourWorkflow {\n\n  ActivityOptions activityOptions = ActivityOptions.newBuilder()\n    .setTaskQueue(\"Activity-Task-Queue-1\")\n    // ...\n    .build();\n  // Pass the options to the new ActivityStub\n  private final YourActivity yourActivity = Workflow.newActivityStub(\n    YourActivity.class,\n    activityOptions\n  );\n  // Call the Activity from within the Workflow method\n  @Override\n  public String workflowMethod() {\n    return yourActivity.somemethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```java\npublic static class YourWorkflowImpl implements YourWorkflow {\n\n  @Override\n  public String workflowMethod() {\n\n    // Set the Task Queue in the Child Workflow options\n    ChildWorkflowOptions childWorkflowOptions =\n      ChildWorkflowOptions.newBuilder()\n        .setTaskQueue(\"Child-Workflow-Task-Queue-1\")\n        // ...\n        .build();\n    // Pass the options to the new Child Workflow Stub\n    ChildWorkflow childWorkflow = Workflow.newChildWorkflowStub(\n      ChildWorkflow.class,\n      childWorkflowOptions\n    );\n    // Call the Child Workflow method\n    String result = childWorkflow.workflowMethod(...);\n    return result;\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.\n","is_empty":false},{"file_name":"test-functions-in-workflow-context.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/test-functions-in-workflow-context.md","id":"java/test-functions-in-workflow-context","title":"Test functions in Workflow context","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Workflow context","tags":["guide-context"],"ssdi":[],"markdown_content":"\nFor a function or method to run in the Workflow context (where it’s possible to get the current Workflow info, or running inside the sandbox in the case of TypeScript or Python), it needs to be run by the Worker as if it were a Workflow.\n\n:::note\n\nThis section is applicable in Python and TypeScript.\nIn Python, we allow testing of Workflows only and not generic Workflow-related code.\n\n:::\n","is_empty":false},{"file_name":"testing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/testing-activities.md","id":"java/testing-activities","title":"Testing Activities","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn Activity can be tested with a mock Activity environment, which provides a way to mock the Activity context, listen to Heartbeats, and cancel the Activity.\nThis behavior allows you to test the Activity in isolation by calling it directly, without needing to create a Worker to run the Activity.\n","is_empty":false},{"file_name":"testing-frameworks.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/testing-frameworks.md","id":"java/testing-frameworks","title":"Test frameworks","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test frameworks","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Temporal Java SDK provides a test framework to facilitate Workflow unit and integration testing.\nThe test framework provides a `TestWorkflowEnvironment` class which includes an in-memory implementation\nof the Temporal service that supports automatic time skipping. This allows you to\neasily test long-running Workflows in seconds, without having to change your Workflow code.\n\nYou can use the provided `TestWorkflowEnvironment` with a Java unit testing framework of your choice,\nsuch as JUnit.\n\n### Setup testing dependency\n\nTo start using the Java SDK test framework, you need to add [`io.temporal:temporal-testing`](https://search.maven.org/artifact/io.temporal/temporal-testing)\nas a dependency to your project:\n\n**[Apache Maven](https://maven.apache.org/)**:\n\n```maven\n<dependency>\n    <groupId>io.temporal</groupId>\n    <artifactId>temporal-testing</artifactId>\n    <version>1.17.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\n**[Gradle Groovy DSL](https://gradle.org/)**:\n\n```groovy\ntestImplementation (\"io.temporal:temporal-testing:1.17.0\")\n```\n\nMake sure to set the version that matches your dependency version of the [Temporal Java SDK](https://github.com/temporalio/sdk-java).\n\n### Sample unit tests\n\nThe following code implements unit tests for the `HelloActivity` sample:\n\n```java\npublic class HelloActivityTest {\n\n    private TestWorkflowEnvironment testEnv;\n    private Worker worker;\n    private WorkflowClient client;\n\n    // Set up the test workflow environment\n    @Before\n    public void setUp() {\n        testEnv = TestWorkflowEnvironment.newInstance();\n        worker = testEnv.newWorker(TASK_QUEUE);\n        // Register your workflow implementations\n        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n\n        client = testEnv.getWorkflowClient();\n    }\n\n    // Clean up test environment after tests are completed\n    @After\n    public void tearDown() {\n        testEnv.close();\n    }\n\n    @Test\n    public void testActivityImpl() {\n        // This uses the actual activity impl\n        worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n\n        // Start test environment\n        testEnv.start();\n\n        // Create the workflow stub\n        GreetingWorkflow workflow =\n                client.newWorkflowStub(\n                        GreetingWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).build());\n\n        // Execute our workflow waiting for it to complete\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n    }\n}\n```\n\nIn cases where you do not wish to execute your actual Activity implementations during\nunit testing, you can use a framework such as Mockito to mock them.\n\nThe following code implements a unit test for the `HelloActivity` sample which shows\nhow activities can be mocked:\n\n```java\npublic class HelloActivityTest {\n\n    private TestWorkflowEnvironment testEnv;\n    private Worker worker;\n    private WorkflowClient client;\n\n    // Set up the test workflow environment\n    @Before\n    public void setUp() {\n        testEnv = TestWorkflowEnvironment.newInstance();\n        worker = testEnv.newWorker(TASK_QUEUE);\n        // Register your workflow implementations\n        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n\n        client = testEnv.getWorkflowClient();\n    }\n\n    // Clean up test environment after tests are completed\n    @After\n    public void tearDown() {\n        testEnv.close();\n    }\n\n    @Test\n    public void testMockedActivity() {\n        // Mock our workflow activity\n        GreetingActivities activities = mock(GreetingActivities.class);\n        when(activities.composeGreeting(\"Hello\", \"World\")).thenReturn(\"Hello Mocked World!\");\n        worker.registerActivitiesImplementations(activities);\n\n        // Start test environment\n        testEnv.start();\n\n        // Create the workflow stub\n        GreetingWorkflow workflow =\n                client.newWorkflowStub(\n                        GreetingWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).build());\n\n        // Execute our workflow waiting for it to complete\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello Mocked World!\", greeting);\n    }\n}\n```\n\n### Testing with JUnit4\n\nFor Junit4 tests, Temporal provides the TestWorkflowRule class which simplifies the Temporal test environment setup, as well as the\ncreation and shutdown of Workflow Workers in your tests.\n\nMake sure to set the version that matches your dependency version of the [Temporal Java SDK](https://github.com/temporalio/sdk-java).\n\nWe can now rewrite our above mentioned \"HelloActivityTest\" test class as follows:\n\n```java\npublic class HelloActivityJUnit4Test {\n    @Rule\n    public TestWorkflowRule testWorkflowRule =\n            TestWorkflowRule.newBuilder()\n                    .setWorkflowTypes(GreetingWorkflowImpl.class)\n                    .setActivityImplementations(new GreetingActivitiesImpl())\n                    .build();\n\n    @Test\n    public void testActivityImpl() {\n        // Get a workflow stub using the same task queue the worker uses.\n        GreetingWorkflow workflow =\n                testWorkflowRule\n                        .getWorkflowClient()\n                        .newWorkflowStub(\n                                GreetingWorkflow.class,\n                                WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build());\n        // Execute a workflow waiting for it to complete.\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n\n        testWorkflowRule.getTestEnvironment().shutdown();\n    }\n}\n```\n\n### Testing with JUnit5\n\nFor Junit5 tests, Temporal also provides the TestWorkflowExtension helped class which can be used to simplify the Temporal test environment setup\nas well as Workflow Worker startup and shutdowns.\n\nTo start using JUnit5 TestWorkflowExtension in your tests with [Gradle](https://gradle.org/), you need to enable capability [`io.temporal:temporal-testing-junit5`]:\n\nMake sure to set the version that matches your dependency version of the [Temporal Java SDK](https://github.com/temporalio/sdk-java).\n\nWe can now use JUnit5 and rewrite our above mentioned \"HelloActivityTest\" test class as follows:\n\n```java\npublic class HelloActivityJUnit5Test {\n    @RegisterExtension\n    public static final TestWorkflowExtension testWorkflowExtension =\n            TestWorkflowExtension.newBuilder()\n                    .setWorkflowTypes(GreetingWorkflowImpl.class)\n                    .setActivityImplementations(new GreetingActivitiesImpl())\n                    .build();\n\n    @Test\n    public void testActivityImpl(\n            TestWorkflowEnvironment testEnv, Worker worker, GreetingWorkflow workflow) {\n        // Execute a workflow waiting for it to complete.\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n    }\n}\n```\n\nYou can find all unit tests for the [Temporal Java samples](https://github.com/temporalio/samples-java) repository in [its test package](https://github.com/temporalio/samples-java/tree/master/src/test/java/io/temporal/samples).\n","is_empty":false},{"file_name":"testing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/testing-workflows.md","id":"java/testing-workflows","title":"Testing Workflows","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"","is_empty":false},{"file_name":"testing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/testing.md","id":"java/testing","title":"Testing","description":"The Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.","label":"Testing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.\n\nIn the context of Temporal, you can create these types of automated tests:\n\n- **End-to-end**: Running a Temporal Server and Worker with all its Workflows and Activities; starting and interacting with Workflows from a Client.\n- **Integration**: Anything between end-to-end and unit testing.\n  - Running Activities with mocked Context and other SDK imports (and usually network requests).\n  - Running Workers with mock Activities, and using a Client to start Workflows.\n  - Running Workflows with mocked SDK imports.\n- **Unit**: Running a piece of Workflow or Activity code (a function or method) and mocking any code it calls.\n\nWe generally recommend writing the majority of your tests as integration tests.\n\nBecause the test server supports skipping time, use the test server for both end-to-end and integration tests with Workers.\n","is_empty":false},{"file_name":"timers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/timers.md","id":"java/timers","title":"What is a Timer?","description":"A Timer lets a Workflow sleep for a fixed time period.","label":"Timers","tags":["guide-context","timers","sleep"],"ssdi":[],"markdown_content":"\nA Workflow can set a durable timer for a fixed time period.\nIn some SDKs, the function is called `sleep()`, and in others, it's called `timer()`.\n\nA Workflow can sleep for months.\nTimers are persisted, so even if your Worker or Temporal Cluster is down when the time period completes, as soon as your Worker and Cluster are back up, the `sleep()` call will resolve and your code will continue executing.\n\nSleeping is a resource-light operation: it does not tie up the process, and you can run millions of Timers off a single Worker.\n","is_empty":false},{"file_name":"tracing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/tracing.md","id":"java/tracing","title":"How to setup Tracing","description":"Tracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.","label":"Tracing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.\n\nTemporal Web's tracing capabilities mainly track Activity Execution within a Temporal context. If you need custom tracing specific for your use case, you should make use of context propagation to add tracing logic accordingly.\n\nFor information about Workflow tracing, see [Tracing Temporal Workflows with DataDog](https://spiralscout.com/blog/tracing-temporal-workflow-with-datadog).\n\nFor information about how to configure exporters and instrument your code, see [Tracing Temporal Services with OTEL](https://github.com/temporalio/temporal/blob/master/develop/docs/tracing.md).\n","is_empty":false},{"file_name":"upsert-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/upsert-custom-search-attributes.md","id":"java/upsert-custom-search-attributes","title":"How to upsert Search Attributes","description":"You can upsert Search Attributes to add or update Search Attributes from within Workflow code.","label":"Upsert Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can upsert Search Attributes to add or update Search Attributes from within Workflow code.\n","is_empty":false},{"file_name":"versioning.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/versioning.md","id":"java/versioning","title":"How to version Workflows in Java","description":"Properly version your Workflows to avoid non-deterministic errors.","label":"Versioning","tags":["java","workflow-versions"],"ssdi":[],"markdown_content":"\nAs outlined in the _Workflow Implementation Constraints_ section, Workflow code has to be deterministic by taking the same\ncode path when replaying history events. Any Workflow code change that affects the order in which commands are generated breaks\nthis assumption. The solution that allows updating code of already running Workflows is to keep both the old and new code.\nWhen replaying, use the code version that the events were generated with and when executing a new code path, always take the\nnew code.\n\n## Introduction to Versioning\n\nBecause we design for potentially long-running Workflows at scale, versioning with Temporal works differently than with other workflow systems.\nWe explain more in this optional 30-minute introduction: [https://www.youtube.com/watch?v=kkP899WxgzY](https://www.youtube.com/watch?v=kkP899WxgzY).\n\n## Java Versioning API\n\nUse the `Workflow.getVersion` function to return a version of the code that should be executed and then use the returned\nvalue to pick a correct branch. Let's look at an example.\n\n```java\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\nNow we decide to calculate the processed file checksum and pass it to upload.\nThe correct way to implement this change is:\n\n```java\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        int version = Workflow.getVersion(\"checksumAdded\", Workflow.DEFAULT_VERSION, 1);\n        if (version == Workflow.DEFAULT_VERSION) {\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } else {\n            long checksum = activities.calculateChecksum(processedName);\n            activities.uploadWithChecksum(\n                args.getTargetBucketName(), args.getTargetFilename(), processedName, checksum);\n        }\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\nLater, when all Workflows that use the old version are completed, the old branch can be removed.\n\n```java\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        // getVersion call is left here to ensure that any attempt to replay history\n        // for a different version fails. It can be removed later when there is no possibility\n        // of this happening.\n        Workflow.getVersion(\"checksumAdded\", 1, 1);\n        long checksum = activities.calculateChecksum(processedName);\n        activities.uploadWithChecksum(\n            args.getTargetBucketName(), args.getTargetFilename(), processedName, checksum);\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\nThe Id that is passed to the `getVersion` call identifies the change. Each change is expected to have its own Id. But if\na change spawns multiple places in the Workflow code and the new code should be either executed in all of them or\nin none of them, then they have to share the Id.\n","is_empty":false},{"file_name":"visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/visibility.md","id":"java/visibility","title":"How to use Visibility APIs","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n","is_empty":false},{"file_name":"workers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workers.md","id":"java/workers","title":"Workers in Java","label":"Workers","ssdi":[],"markdown_content":"\n## What is a Worker?\n\nA Worker is a service that executes [Workflows](/java/workflows) and [Activities](/java/activities).\nWorkers are defined and executed on user controlled hosts.\nYou can use the `WorkerFactory` class to create and run as many Workers as your use case demands, across any number of hosts.\n\nWorkers poll Task Queues for Tasks, execute chunks of code in response to those Tasks, and then communicate the results back to the Temporal Server.\n\nAs a developer, running Workers is a fairly simple procedure,\nbecause the Java SDK handles all the communication between the Worker and the Temporal Server behind the scenes.\n\n## How to start a Worker\n\nTo start a Worker you need to:\n\n1. Create a WorkflowClient instance\n2. Optionally create WorkerOptions\n3. Create a WorkerFactory instance\n4. Create a Worker using the created WorkerFactory's `newWorker` method\n5. Register Workflows and Activities this Worker should execute\n\nAs a simple example, let's say we want our Worker to be able to execute the following Workflow implementation:\n\n```java\npublic static class EmployeeWorkflowImpl implements EmployeeWorkflow {\n\n    private final EmployeeActivities activities =\n        Workflow.newActivityStub(\n                EmployeeActivities.class,\n            ActivityOptions.newBuilder().setStartToCloseTimeout(Duration.ofSeconds(2)).build());\n\n    @Override\n    public Employee getEmployee(String id) {\n      return activities.getEmployeeById(id);\n    }\n  }\n```\n\nOur Workflow invokes `EmployeeActivities` Activities. We can register our Workflow with our Worker:\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\nWorkflowClient client = WorkflowClient.newInstance(service);\nWorkerFactory factory = WorkerFactory.newInstance(client);\n\nWorker worker = factory.newWorker(TASK_QUEUE_NAME);\n\nworker.registerWorkflowImplementationTypes(EmployeeWorkflowImpl.class);\n```\n\nNote that in order to execute our `EmployeeWorkflowImpl` Workflow implementation, there is no need to register any Activities.\nOnly if our created Worker is also used to host the Activity implementations we should register them as well by adding for example:\n\n```java\nString connectionUrl = \"jdbc:sqlserver://localhost:1433;databaseName=EmployeesDb;user=user;password=pass\";\nworker.registerActivitiesImplementations(new EmployeeActivitiesImpl(connectionUrl));\n```\n\nFor Workflows we register the Workflow Type.\nFor Activities, since they are stateless and thread-safe, we need\nto register an Activity instance.\n\nWhen you start a Workflow or when a Workflow needs to invoke an Activity, the Temporal Server adds\na new task to the Workflows / Activity Task Queue. Any Worker polling that Task Queue and has that Workflow / Activity\nregistered can pick up the new task and execute it.\n","is_empty":false},{"file_name":"workflow-execution-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-execution-timeout.md","id":"java/workflow-execution-timeout","title":"How to set a Workflow Execution Timeout","description":"Use the Workflow Execution Timeout to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n","is_empty":false},{"file_name":"workflow-logic-requirements.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-logic-requirements.md","id":"java/workflow-logic-requirements","title":"How develop Workflow logic","description":"Workflow logic is constrained by deterministic execution requirements.","label":"Workflow logic requirements","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow logic is constrained by [deterministic execution requirements](/concepts/what-is-a-workflow-definition#deterministic-constraints).\nTherefore, each language is limited to the use of certain idiomatic techniques.\nHowever, each Temporal SDK provides a set of APIs that can be used inside your Workflow to interact with external (to the Workflow) application code.\n","is_empty":false},{"file_name":"workflow-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-parameters.md","id":"java/workflow-parameters","title":"How to define Workflow parameters","description":"Temporal Workflows may have any number of custom parameters.","label":"Workflow parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal Workflows may have any number of custom parameters.\nHowever, we strongly recommend that objects are used as parameters, so that the object's individual fields may be altered without breaking the signature of the Workflow.\nAll Workflow Definition parameters must be serializable.\n","is_empty":false},{"file_name":"workflow-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-retries.md","id":"java/workflow-retries","title":"Workflow retries","description":"A Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.","label":"Workflow retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-retry-policy.md","id":"java/workflow-retry-policy","title":"How to set a Workflow Retry Policy","description":"Use a Retry Policy to retry a Workflow Execution in the event of a failure.","label":"Workflow Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-return-values.md","id":"java/workflow-return-values","title":"How to define Workflow return parameters","description":"Workflow return values must also be serializable.","label":"Workflow return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow return values must also be serializable.\nReturning results, returning errors, or throwing exceptions is fairly idiomatic in each language that is supported.\nHowever, Temporal APIs that must be used to get the result of a Workflow Execution will only ever receive one of either the result or the error.\n","is_empty":false},{"file_name":"workflow-run-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-run-timeout.md","id":"java/workflow-run-timeout","title":"How to set a Workflow Run Timeout","description":"Use the Workflow Run Timeout to restrict the maximum amount of time that a single Workflow Run can last.","label":"Workflow Run Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) to restrict the maximum amount of time that a single [Workflow Run](/concepts/what-is-a-workflow-execution#workflow-execution-chain) can last.\n","is_empty":false},{"file_name":"workflow-task-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-task-timeout.md","id":"java/workflow-task-timeout","title":"How to set a Workflow Task Timeout","description":"Use the Workflow Task Timeout to restrict the maximum amount of time that a Worker can execute a Workflow Task.","label":"Workflow Task Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout) to restrict the maximum amount of time that a Worker can execute a [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"workflow-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-timeouts-and-retries.md","id":"java/workflow-timeouts-and-retries","title":"Workflow timeouts and retries","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts & retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"workflow-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-timeouts.md","id":"java/workflow-timeouts","title":"Workflow timeouts","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\n\nWorkflow timeouts are set when [starting the Workflow Execution](/java/workflow-timeouts).\n\n- **[Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout)** - restricts the maximum amount of time that a single Workflow Execution can be executed.\n- **[Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout)**: restricts the maximum amount of time that a single Workflow Run can last.\n- **[Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout)**: restricts the maximum amount of time that a Worker can execute a Workflow Task.\n","is_empty":false},{"file_name":"workflow-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflow-type.md","id":"java/workflow-type","title":"How to customize your Workflow Type","description":"You can set a custom name for your Workflow Type.","label":"Workflow Type","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows have a Type that are referred to as the Workflow name.\n\nThe following examples demonstrate how to set a custom name for your Workflow Type.\n","is_empty":false},{"file_name":"workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/java/workflows.md","id":"java/workflows","title":"Workflows in Java","description":"The core abstraction of the Temporal solution is a fault-oblivious stateful Workflow.","label":"Workflows","ssdi":[],"markdown_content":"\nimport RelatedReadList from '../components/RelatedReadList.js'\n\n## What is a Workflow?\n\nWorkflows are resilient programs, meaning that they will continue execution even in the presence of\ndifferent failure conditions.\n\nWorkflows encapsulate execution and orchestration of Tasks, which include Activities and Child Workflows.\nThey also need to react to external events, respond to Query requests, and deal with Timeouts.\n\nIn the Temporal Java SDK programming model, a Workflow is a class that implements a Workflow Interface:\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n  // ...\n}\n```\n\nThe Workflow Interface is a Java interface which is annotated with the `@WorkflowInterface` annotation.\n\n## Workflow Interface\n\nWorkflow interface methods must have one of the following annotations:\n\n- **@WorkflowMethod** denotes the starting point of a Workflow Execution.\n  Workflow Execution completes when this method returns.\n- **@SignalMethod** indicates that this method is a Signal handler method and that it can react to external Signals.\n  It can have parameters that can contain the Signal payload.\n  It does not return a value, so it must have a `void` return type.\n- **@QueryMethod** indicates that this method can be used to query the Workflow's state at any time during its execution.\n  It can have parameters that can be used to filter a subset of the Workflow's state that it returns.\n  Because it does return a value, it cannot have a `void` return type.\n\nWorkflow interfaces can define only a single method annotated with `@WorkflowMethod`. They can define\nany number of methods annotated with `@SignalMethod` and `@QueryMethod`, for example:\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n    @WorkflowMethod\n    String processFile(Arguments args);\n\n    @QueryMethod(name=\"history\")\n    List<String> getHistory();\n\n    @QueryMethod\n    String getStatus();\n\n    @SignalMethod\n    void retryNow();\n\n    @SignalMethod\n    void abandon();\n}\n```\n\nThe `@WorkflowMethod` annotation has a `name` parameter, for example: `@WorkflowMethod(name = \"YourWorkflowType\")`.\nIt can be used to denote the Workflow Type. If not set, the Workflow Type defaults to the short name of the Workflow interface,\nin the example above being `FileProcessingWorkflow`.\nMethods annotated with `@WorkflowMethod` can have any number of parameters.\nWe recommend passing a single parameter that contains all the input fields.\nThis allows adding fields in a backward compatible manner.\n\nThe `@QueryMethod` annotation also has a `name` parameter, for example: `@QueryMethod(name = \"history\")`. It can be\nused to denote the query name. If not set, the query name defaults to the name of the method, in the example above\nbeing `getStatus`.\n\nThe `@SignalMethod` too has a `name` parameter, for example: `@SignalMethod(name = \"mysignal\")`. It can be used to denote the\nsignal type. If not set, the signal type defaults to the name of the method, in the example above being `retryNow` and `abandon`.\n\n### Workflow Interface Inheritance\n\nWorkflow interfaces can form inheritance hierarchies. It may be useful for creating components reusable across multiple\nWorkflow interfaces. For example imaging a UI or CLI button that allows to call `retryNow` signal on any Workflow. To implement\nthis feature you can redesign the above interface to:\n\n```java\npublic interface Retryable {\n    @SignalMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface FileProcessingWorkflow extends Retryable {\n\n    @WorkflowMethod\n    String processFile(Arguments args);\n\n    @QueryMethod(name=\"history\")\n    List<String> getHistory();\n\n    @QueryMethod\n    String getStatus();\n\n    @SignalMethod\n    void abandon();\n}\n```\n\nThen some other Workflow interface can extend just `Retryable`, for example:\n\n```java\n@WorkflowInterface\npublic interface MediaProcessingWorkflow extends Retryable {\n\n    @WorkflowMethod\n    String processBlob(Arguments args);\n}\n```\n\nNow if we have two running Workflows, one that implements the `FileProcessingWorkflow` interface and another that implements the\n`MediaProcessingWorkflow` interface, we can signal to both using their common interface and knowing their workflowIds, for example:\n\n```java\nRetryable r1 = client.newWorkflowStub(Retryable.class, firstWorkflowId);\nRetryable r2 = client.newWorkflowStub(Retryable.class, secondWorkflowId);\nr1.retryNow();\nr2.retryNow();\n```\n\nThe same technique can be used to query Workflows using a base Workflow interface.\n\nNote that this approach does not apply to `@WorkflowMethod` annotations, meaning that when using a base interface, it should\nnot include any `@WorkflowMethod` methods.\nTo illustrate this, lets' say that we define the following **invalid** code:\n\n```java\n// INVALID CODE!\npublic interface BaseWorkflow {\n    @WorkflowMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface Workflow1 extends BaseWorkflow {}\n\n@WorkflowInterface\npublic interface Workflow2 extends BaseWorkflow {}\n```\n\nIf we attempt to register implementations of Workflow1 and Workflow2 with a Worker will fail. Let's say that we have:\n\n```java\nworker.registerWorkflowImplementationTypes(\n        Workflow1Impl.class, Workflow2Impl.class);\n```\n\nThis registration will fail with:\n\n```text\njava.lang.IllegalStateException: BaseWorkflow workflow type is already registered with the worker\n```\n\n## Implementing Workflows\n\nA Workflow implementation implements a Workflow interface. Each time a new Workflow Execution is started,\na new instance of the Workflow implementation object is created.\nThen, one of the methods\n(depending on which Workflow Type has been started) annotated with `@WorkflowMethod` can be invoked.\nAs soon as this method returns, the Workflow Execution is considered as completed.\n\nWorkflow methods annotated with `@QueryMethod` and `@SignalMethod` can be invoked during a Workflow's execution.\n\nNote that methods annotated with `@QueryMethod` can be invoked even when a Workflow is in the `Completed`\nstate.\n\n### Workflow Implementation Constraints\n\nTemporal uses the [Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover\nthe state of a Workflow object including its threads and local variable values.\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nNote that during replay, successfully executed Activities are not re-executed as their results are already recorded\nin the Workflow event history.\n\nEven though Temporal has the replay capability, which brings resilience to your Workflows, you should never think about\nthis capability when writing your Workflows.\nInstead, you should focus on implementing your business logic/requirements and write your Workflows\nas they would execute only once.\n\nThere are some things however to think about when writing your Workflows, namely determinism and isolation.\nWe summarize these constraints here:\n\nThey shouldn't use any constructs that rely on system time.\n\n- Do not use any mutable global variables in your Workflow implementations. This will assure that multiple Workflow instances are fully isolated.\n- Do not call any non-deterministic functions like non seeded random or UUID.randomUUID() directly from the Workflow code. The Temporal SDK provides specific API for calling non-deterministic code in your Workflows, which we will show later on in this document.\n- Perform all IO operations and calls to third-party services on Activities and not Workflows, as they are usually non-deterministic in nature.\n- Do not use any programming language constructs that rely on system time. For example, only use `Workflow.currentTimeMillis()` to get the current time inside a Workflow.\n- Do not use native Java `Thread` or any other multi-threaded classes like `ThreadPoolExecutor`. Use `Async.function` or `Async.procedure`,\n  provided by the Temporal SDK, to execute code asynchronously.\n- Don't use any synchronization, locks, and other standard Java blocking concurrency-related classes besides those provided\n  by the Workflow class. There is no need in explicit synchronization because multi-threaded code inside a Workflow is\n  executed one thread at a time and under a global lock.\n  - Call `Workflow.sleep` instead of `Thread.sleep`.\n  - Use `Promise` and `CompletablePromise` instead of `Future` and `CompletableFuture`.\n  - Use `WorkflowQueue` instead of `BlockingQueue`.\n- Use `Workflow.getVersion` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already running Workflows.\n- Don’t access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\n### Workflow Method Arguments\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n\nJava DataConverter reference: https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html\n\n## Workflow Activities\n\nTo learn about Workflow Activities visit [this page](/java/activities).\n\n## Child Workflows\n\nBesides Activities, a Workflow can also start other Workflows.\n\n<RelatedReadList\nreadlist={[\n[\"What is a Child Workflow Execution?\",\"/concepts/what-is-a-child-workflow-execution\",\"explanation\"],\\\n]}\n/>\n\n### Java Child Workflow API\n\n`Workflow.newChildWorkflowStub` returns a client-side stub that implements a Child Workflow interface.\nIt takes a Child Workflow Type and optional Child Workflow options as arguments.\nWorkflow options can be used to set Timeouts, retry options, and Task Queue settings, for example.\nBy default, a Child Workflow inherits the Workflow options of its parent.\nYou can, however, overwrite these default options by passing in custom Workflow options when creating the Child Workflow stub.\n\nThe first call to the Child Workflow stub must always be its Workflow method (the method annotated with `@WorkflowMethod`).\n\nSimilar to Activities, invoking child Workflow methods can be made synchronous or asynchronous by using `Async#function` or `Async#procedure`.\nThe synchronous call blocks until a child Workflow method completes. The asynchronous call\nreturns a `Promise` that can be used to wait for the completion of the child Workflow method, for example:\n\n```java\nGreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\nPromise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n// ...\ngreeting.get()\n```\n\nNote that querying child Workflows from within the parent Workflow code is not supported. You can however\nquery child Workflows from Activities using `WorkflowClient`.\n\nFollowing are examples of using a child Workflow inside a Workflow:\n\n```java\n// Child Workflow interface\n@WorkflowInterface\npublic interface GreetingChild {\n   @WorkflowMethod\n   String composeGreeting(String greeting, String name);\n}\n// Child Workflow implementation not shown\n\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n   @Override\n   public String getGreeting(String name) {\n       GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n       // This is a blocking call that returns only after child has completed.\n       return child.composeGreeting(\"Hello\", name );\n   }\n}\n```\n\nRunning two children (with the same type) in parallel:\n\n```java\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n\n        // Workflows are stateful, so a new stub must be created for each new child.\n        GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting1 = Async.function(child1::composeGreeting, \"Hello\", name);\n\n        // Both children will run concurrently.\n        GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting2 = Async.function(child2::composeGreeting, \"Bye\", name);\n\n        // Do something else here.\n        ...\n        return \"First: \" + greeting1.get() + \", second: \" + greeting2.get();\n    }\n}\n```\n\nSending a signal to a child Workflow from the parent:\n\n```java\n// Child Workflow interface\n@WorkflowInterface\npublic interface GreetingChild {\n    @WorkflowMethod\n    String composeGreeting(String greeting, String name);\n\n    @SignalMethod\n    void updateName(String name);\n}\n\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n        GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n        child.updateName(\"Temporal\");\n        return greeting.get();\n    }\n}\n```\n\n### ParentClosePolicy\n\nWhen creating a Child Workflow, you can define a `ParentClosePolicy` that terminates, cancels, or abandons the Workflow Execution if the child's parent stops execution.\n\n- `ABANDON`: When the parent stops, don't do anything with the Child Workflow.\n- `TERMINATE`: When the parent stops, terminate the Child Workflow\n- `REQUEST_CANCEL`: When the parent stops, terminate the Child Workflow\n\nYou can set policies per child, which means you can opt out of propagating terminates / cancels on a per-child basis.\nThis is useful for starting Child Workflows asynchronously:\n\n```java\n public void parentWorkflow() {\n     ChildWorkflowOptions options =\n        ChildWorkflowOptions.newBuilder()\n            .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)\n            .build();\n     MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, options);\n     Async.procedure(child::<workflowMethod>, <args>...);\n     Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(child);\n     // Wait for child to start\n     childExecution.get()\n}\n```\n\n1. Set `ChildWorkflowOptions.ParentClosePolicy` to `ABANDON` when creating a Child Workflow stub.\n2. Start Child Workflow Execution asynchronously using `Async.function` or `Async.procedure`.\n3. Call `Workflow.getWorkflowExecution(…)` on the child stub\n4. Wait for the Promise returned by `getWorkflowExecution` to complete.\n   This indicates that the child successfully started (or start failed).\n5. Complete Parent Workflow Execution asynchronously\n\nSteps 3 and 4 are needed to ensure that a Child Workflow Execution starts before the parent closes.\nIf the parent initiates a Child Workflow Execution and then immediately completes, the child would never execute.\n\n## Starting Workflow Executions\n\nIn the Temporal Java SDK, Workflows can be started both synchronously and asynchronously.\nTo do either, you must initialize an instance of a `WorkflowClient`, create a client side Workflow stub,\nand then call a Workflow method (annotated with the `@WorkflowMethod` annotation).\n\n### Asynchronous start\n\nAn asynchronous start initiates a Workflow Execution and immediately returns to the caller.\nThis is the most common way to start Workflows in a live environment.\n\n<!--SNIPSTART money-transfer-project-template-java-workflow-initiator-->\n<!--SNIPEND-->\n\nIf you need to wait for the completion of a Workflow after an asynchronous start, the most straightforward way is to call the blocking Workflow instance again.\n\nIf `WorkflowOptions.WorkflowIdReusePolicy` is not set to `AllowDuplicate`, then instead of throwing `DuplicateWorkflowException`,\nit reconnects to an existing Workflow and waits for its completion.\n\nThe following example shows how to do this from a different process than the one that started the Workflow Execution.\n\n```java\nYourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflow.yourMethod();\n```\n\nAnother way to connect to an existing Workflow and wait for its completion from another process is to use `UntypedWorkflowStub`.\nFor example:\n\n```java\nWorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflowStub.getResult(String.class);\n```\n\n### Synchronous start\n\nA Synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the invocation process and will continue executing even if the waiting process crashes or was stopped.\n\n<!--SNIPSTART hello-world-project-template-java-workflow-initiator-->\n<!--SNIPEND-->\n\n### Recurring start\n\nYou can start a Workflow Execution on a regular schedule with [the CronSchedule option](distributed-cron).\n\n### External Workflows\n\nWorkflows can execute (and signal to) other workflows purely by name.\nThis helps particularly for executing workflows from other language SDKs.\nSee our [Temporal Polyglot example](https://github.com/tsurdilo/temporal-polyglot) for more.\n\n## Large Event Histories\n\nTemporal SDK allows you to manually use [Continue-As-New](/concepts/what-is-continue-as-new) in a number of ways:\n\nIf you are continuing execution of the same Workflow that is currently running, you can do the following:\n\n```java\nWorkflow.continueAsNew(input1, ...);\n```\n\nIt is also possible to continue execution as a completely different Workflow Type.\nIn a Workflow class called `YourWorkflow` for example, we can create a Workflow Stub with a different type and\ncall its Workflow method to continue execution as that type:\n\n```java\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class);\ncontinueAsNew.greet(input);\n```\n\n`Workflow.newContinueAsNewStub` also allows to provide `ContinueAsNewOptions` options, for example:\n\n```java\nContinueAsNewOptions options = ContinueAsNewOptions.newBuilder()\n        .setTaskQueue(\"newTaskQueueName\")\n        .build();\n\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class, options);\n// ...\ncontinueAsNew.greet(input);\n```\n\nThis allows you to continue Workflow Execution as a new Workflow run with a different Workflow Type and on a different Task Queue.\n\nAnother way to deal with the Event History size limits is to use Child Workflows; however,\nthey themselves could eventually, if long running, experience the same issue in which case you can again\napply the \"ContinueAsNew\" feature if needed.\n\n\"ContinueAsNew\" can also be used in [child Workflows](#child-workflows). Note that in this case the parent Workflow\nis not aware if its child Workflows called \"ContinueAsNew\". This way a child Workflow can call \"ContinueAsNew\" as many times\nas it needs, and the parent Workflow will get notified when the last run of the child Workflow completes or fails.\n\nIf you need to know whether a Workflow was started via `continueAsNew`, you can check `Workflow.getInfo().getContinuedExecutionRunId().isPresent()`.\n","is_empty":false},{"file_name":"cluster-plugins.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/security/cluster-plugins.md","id":"security/cluster-plugins","title":"Temporal Cluster plugins conceptual context","description":"Temporal Clusters support some pluggable components.","label":"Plugins","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal Clusters support some pluggable components.\n","is_empty":false},{"file_name":"data-converter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/security/data-converter.md","id":"security/data-converter","title":"Data Converter","description":"Use a Data Converter with a custom Payload Codec to encode and decode your data.","label":"Data Converter","tags":["guide-context","security"],"ssdi":[],"markdown_content":"\nEach Temporal SDK provides a [Data Converter](/concepts/what-is-a-data-converter) that can be customized with a custom [Payload Codec](/concepts/what-is-a-payload-codec) to encode and secure your data.\n\nFor details on what data can be encoded, how to secure it, and what to consider when using encryption, see [Data encryption](/production-readiness/develop#securing-your-data).\n\n#### Codec Server\n\nYou can use a [Codec Server](/concepts/what-is-a-codec-server) with your custom Payload Codec to decode the data you see on your Web UI and CLI locally through remote endpoints.\nHowever, ensure that you consider all security implications of [remote data encoding](/concepts/what-is-remote-data-encoding) before using a Codec Server.\n\nFor details on how to set up a Codec Server, see [Codec Server setup](/production-readiness/develop#codec-server-setup).\n","is_empty":false},{"file_name":"how-to-authorize-sdk-api-calls.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/security/how-to-authorize-sdk-api-calls.md","id":"security/how-to-authorize-sdk-api-calls","title":"How to authorize SDK API calls","description":"When authentication is enabled, you can authorize API calls made to the Frontend Service.","label":"Authorize API calls","tags":["security","guide-context"],"ssdi":[],"markdown_content":"\nWhen authentication is enabled, you can authorize API calls made to the Frontend Service.\n","is_empty":false},{"file_name":"intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/security/intro.md","id":"security/intro","title":"Temporal Platform security overview","description":"The security guide provides a comprehensive overview of the security related features and how to implement them.","tags":["security","guide-context"],"ssdi":[],"markdown_content":"\n:::info Work in progress\n\nThis guide is a work in progress. Some sections may be incomplete. Information may change at any time.\n\n:::\n\n:::info General company security\n\nFor information about the general security habits of Temporal Technologies see our [company security page](/temporal-technologies-inc-security).\n\n:::\n\nThe Temporal Plaform is designed with security in mind, and there are many features that you can use to keep both the Platform itself and your user's data secure.\n\nA secured Temporal Server has its network communication encrypted and has authentication and authorization protocols set up for API calls made to it.\nWithout these, your server could be accessed by unwanted entities.\n\nWhat is documented on this page are the built-in opt-in security measures that come with Temporal.\nHowever users may also choose to design their own security architecture with reverse proxies or run unsecured instances inside of a VPC environment.\n\n### Server Samples\n\nThe https://github.com/temporalio/samples-server repo offers two examples, which are further explained below:\n\n- **TLS**: how to configure Transport Layer Security (TLS) to secure network communication with and within a Temporal cluster.\n- **Authorizer**: how to inject a low-level authorizer component that can control access to all API calls.\n\n### Encryption in transit with mTLS\n\nTemporal supports Mutual Transport Layer Security (mTLS) as a way of encrypting network traffic between the services of a cluster and also between application processes and a Cluster.\nSelf-signed or properly minted certificates can be used for mTLS.\nmTLS is set in Temporal's [TLS configuration](/references/configuration/#tls).\nThe configuration includes two sections such that intra-Cluster and external traffic can be encrypted with different sets of certificates and settings:\n\n- `internode`: Configuration for encrypting communication between nodes in the cluster.\n- `frontend`: Configuration for encrypting the Frontend's public endpoints.\n\nA customized configuration can be passed using either the [WithConfig](/references/server-options#withconfig) or [WithConfigLoader](/references/server-options#withconfigloader) Server options.\n\nSee [TLS configuration reference](/references/configuration/#tls) for more details.\n\n### Authentication\n\nThere are a few authentication protocols available to prevent unwanted access such as authentication of servers, clients, and users.\n\n### Servers\n\nTo prevent spoofing and [MITM attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) you can specify the `serverName` in the `client` section of your respective mTLS configuration.\nThis enables established connections to authenticate the endpoint, ensuring that the server certificate presented to any connecting Client has the appropriate server name in its CN property.\nIt can be used for both `internode` and `frontend` endpoints.\n\nMore guidance on mTLS setup can be found in [the `samples-server` repo](https://github.com/temporalio/samples-server/tree/main/tls) and you can reach out to us for further guidance.\n\n### Client connections\n\nTo restrict a client's network access to cluster endpoints you can limit it to clients with certificates issued by a specific Certificate Authority (CA).\nUse the `clientCAFiles`/ `clientCAData` and `requireClientAuth` properties in both the `internode` and `frontend` sections of the [mTLS configuration](/references/configuration/#tls).\n\n### Users\n\nTo restrict access to specific users, authentication and authorization is performed through extensibility points and plugins as described in the [Authorization](#authorization) section below.\n\n#### Authorization\n\n:::note\nInformation regarding [`Authorizer`](/concepts/what-is-an-authorizer-plugin) and [`ClaimMapper`](/concepts/what-is-a-claimmapper-plugin) has been moved to another location.\n:::\n\nTemporal offers two plugin interfaces for implementing API call authorization:\n\n- [`ClaimMapper`](/concepts/what-is-a-claimmapper-plugin)\n- [`Authorizer`](/concepts/what-is-an-authorizer-plugin)\n\nThe authorization and claim mapping logic is customizable, making it available to a variety of use cases and identity schemes.\nWhen these are provided the frontend invokes the implementation of these interfaces before executing the requested operation.\n\nSee https://github.com/temporalio/samples-server/blob/main/extensibility/authorizer for a sample implementation.\n\n![](/diagrams/frontend-authorization-order-of-operations.png)\n\n### Single sign-on integration\n\nTemporal can be integrated with a single sign-on (SSO) experience by utilizing the `ClaimMapper` and `Authorizer` plugins.\nThe default JWT `ClaimMapper` implementation can be used as is or as a base for a custom implementation of a similar plugin.\n\n#### Temporal Web\n\nTo enable SSO for the Temporal Web UI edit the web service's configuration per the [Temporal Web README](https://github.com/temporalio/web#configuring-authentication-optional).\n","is_empty":false},{"file_name":"activity-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/activity-heartbeats.md","id":"python/activity-heartbeats","title":"How to Heartbeat an Activity","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.","label":"Activity Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn [Activity Heartbeat](/concepts/what-is-an-activity-heartbeat) is a ping from the [Worker Process](/concepts/what-is-a-worker-process) that is executing the Activity to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nEach Heartbeat informs the Temporal Cluster that the [Activity Execution](/concepts/what-is-an-activity-execution) is making progress and the Worker has not crashed.\nIf the Cluster does not receive a Heartbeat within a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) time period, the Activity will be considered failed and another [Activity Task Execution](/concepts/what-is-an-activity-task-execution) may be scheduled according to the Retry Policy.\n\nHeartbeats may not always be sent to the Cluster—they may be [throttled](/concepts/what-is-an-activity-heartbeat#throttling) by the Worker.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\nHeartbeats can contain a `details` field describing the Activity's current progress.\nIf an Activity gets retried, the Activity can access the `details` from the last Heartbeat that was sent to the Cluster.\n","is_empty":false},{"file_name":"activity-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/activity-parameters.md","id":"python/activity-parameters","title":"How to develop Activity Parameters","description":"When it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.","label":"Activity parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThere is no explicit limit to the total number of parameters that an [Activity Definition](/concepts/what-is-an-activity-definition) may support.\nHowever, there is a limit of the total size of the data ends up encoded into a gRPC message Payload.\n\nA single argument is limited to a maximum size of 2 MB.\nAnd the total size of a gRPC message, which includes all the arguments, is limited to a maximum of 4 MB.\n\nAlso, keep in mind that all Payload data is recorded in the [Workflow Execution Event History](/concepts/what-is-an-event-history) and large Event Histories can affect Worker performance.\nThis is because the entire Event History could be transferred to a Worker Process with a [Workflow Task](/concepts/what-is-a-workflow-task).\n\n<!--TODO link to gRPC limit section when available -->\n\nSome SDKs require that you pass context objects, others do not.\nWhen it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.\nThis is so that you can change what data is passed to the Activity without breaking a function or method signature.\n","is_empty":false},{"file_name":"activity-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/activity-retries.md","id":"python/activity-retries","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/activity-retry-policy.md","id":"python/activity-retry-policy","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-simulator.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/activity-retry-simulator.md","id":"python/activity-retry-simulator","title":"How to visualize an Activity Retry Policy with timeouts","description":"Use this tool to visualize total Activity Execution times and experiment with various Activity timeouts and Retry Policies.","label":"Activity retry simulator","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse this tool to visualize total Activity Execution times and experiment with different Activity timeouts and Retry Policies.\n\nThe simulator is based on a common Activity use-case, which is to call a third party HTTP API and return the results.\nSee the example code snippets below.\n\nUse the Activity Retries settings to configure how long the API request takes to succeed or fail.\nThere is an option to generate scenarios.\nThe _Task Time in Queue_ simulates the time the Activity Task might be waiting in the Task Queue.\n\nUse the Activity Timeouts and Retry Policy settings to see how they impact the success or failure of an Activity Execution.\n\nimport RetrySimulator from '/docs/components/RetrySimulator/RetrySimulator';\n\n<RetrySimulator />\n","is_empty":false},{"file_name":"activity-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/activity-return-values.md","id":"python/activity-return-values","title":"How to define Activity return values","description":"All data returned from an Activity must be serializable.","label":"Activity return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll data returned from an Activity must be serializable.\n\nThere is no explicit limit to the amount of data that can be returned by an Activity, but keep in mind that all return values are recorded in a [Workflow Execution Event History](/concepts/what-is-an-event-history).\n","is_empty":false},{"file_name":"activity-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/activity-timeouts-and-retries.md","id":"python/activity-timeouts-and-retries","title":"How to set Activity timeouts and retries","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts and retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"activity-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/activity-timeouts.md","id":"python/activity-timeouts","title":"How to set Activity timeouts","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\n\nThe following timeouts are available in the Activity Options.\n\n- **[Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout)**: is the maximum amount of time allowed for the overall [Activity Execution](/concepts/what-is-an-activity-execution).\n- **[Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout)**: is the maximum time allowed for a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n- **[Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout)**: is the maximum amount of time that is allowed from when an [Activity Task](/concepts/what-is-an-activity-task) is scheduled to when a [Worker](/concepts/what-is-a-worker) starts that Activity Task.\n\nAn Activity Execution must have either the Start-To-Close or the Schedule-To-Close Timeout set.\n","is_empty":false},{"file_name":"activity-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/activity-type.md","id":"python/activity-type","title":"How to customize your Activity Type","description":"You can set a custom name for your Activity Type.","label":"Activity Type","tags":["guide-context"],"ssdi":[],"markdown_content":"\nActivities have a Type that are referred to as the Activity name.\nThe following examples demonstrate how to set a custom name for your Activity Type.\n","is_empty":false},{"file_name":"add-sdk.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/add-sdk.md","id":"python/add-sdk","title":"How to install a Temporal SDK","description":"A Temporal SDK provides a framework for Temporal Application development.","label":"Install a Temporal SDK","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal SDK](/concepts/what-is-a-temporal-sdk) provides a framework for [Temporal Application](/concepts/what-is-a-temporal-application) development.\n\nAn SDK provides you with the following:\n\n- A [Temporal Client](/concepts/what-is-a-temporal-client) to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n- APIs to develop [Workflows](/concepts/what-is-a-workflow).\n- APIs to create and manage [Worker Processes](/concepts/what-is-a-worker).\n- APIs to author [Activities](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"api-reference-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/api-reference-python.md","id":"python/api-reference-python","title":"How to find the Python SDK API reference","description":"The Python SDK API reference is published at python.temporal.io","label":"API reference","ssdi":[],"markdown_content":"\nThe Temporal Python SDK API reference is published on [python.temporal.io](https://python.temporal.io/index.html).\n","is_empty":false},{"file_name":"assert-in-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/assert-in-workflows.md","id":"python/assert-in-workflows","title":"Assert in Workflows","description":"How to Assert in Workflows","label":"Assert in Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\n<!-- not used -->\n\nIn some cases it's useful to assert directly in the Workflow context.\n\nFor example, TypeScript and Python, can use `assert` in Workflow code.\n","is_empty":false},{"file_name":"async-activity-completion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/async-activity-completion.md","id":"python/async-activity-completion","title":"How to asynchronously complete an Activity","description":"Asynchronous Activity Completion enables the Activity Function to return without the Activity Execution completing.","label":"Asynchronous Activity Completion","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Asynchronous Activity Completion](/concepts/what-is-asynchronous-activity-completion) enables the Activity Function to return without the Activity Execution completing.\n\nThere are three steps to follow:\n\n1. The Activity provides the external system with identifying information needed to complete the Activity Execution.\n   Identifying information can be a [Task Token](/concepts/what-is-a-task-token), or a combination of Namespace, Workflow Id, and Activity Id.\n2. The Activity Function completes in a way that identifies it as waiting to be completed by an external system.\n3. The Temporal Client is used to Heartbeat and complete the Activity.\n","is_empty":false},{"file_name":"cancel-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/cancel-activity.md","id":"python/cancel-activity","title":"Cancel an Activity from a Workflow","description":"An Activity can be canceled from within a Workflow if the Activity sends Heartbeats.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCanceling an Activity from within a Workflow requires that the Activity Execution sends Heartbeats and sets a Heartbeat Timeout.\nIf the Heartbeat is not invoked, the Activity cannot receive a cancellation request.\nWhen any non-immediate Activity is executed, the Activity Execution should send Heartbeats and set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) to ensure that the server knows it is still working.\n\nWhen an Activity is canceled, an error is raised in the Activity at the next available opportunity.\nIf cleanup logic needs to be performed, it can be done in a `finally` clause or inside a caught cancel error.\nHowever, for the Activity to appear canceled the exception needs to be re-raised.\n\n:::note\n\nUnlike regular Activities, [Local Activities](/concepts/what-is-a-local-activity) can be canceled if they don't send Heartbeats.\nLocal Activities are handled locally, and all the information needed to handle the cancellation logic is available in the same Worker process.\n\n:::\n","is_empty":false},{"file_name":"cancel-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/cancel-an-activity.md","id":"python/cancel-an-activity","title":"Cancel an Activity","description":"If an Activity is supposed to react to Cancellation, you can test whether it reacts correctly by canceling it.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity is supposed to react to a Cancellation, you can test whether it reacts correctly by canceling it.\n","is_empty":false},{"file_name":"child-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/child-workflows.md","id":"python/child-workflows","title":"How to start a Child Workflow Execution","description":"A Child Workflow Execution is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.","label":"Child Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.\n\nWhen using a Child Workflow API, Child Workflow related Events ([StartChildWorkflowExecutionInitiated](/references/events#startchildworkflowexecutioninitiated), [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted), [ChildWorkflowExecutionCompleted](/references/events#childworkflowexecutioncompleted), etc...) are logged in the Workflow Execution Event History.\n\nAlways block progress until the [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted) Event is logged to the Event History to ensure the Child Workflow Execution has started.\nAfter that, Child Workflow Executions may be abandoned using the default _Abandon_ [Parent Close Policy](/concepts/what-is-a-parent-close-policy) set in the Child Workflow Options.\n\nTo be sure that the Child Workflow Execution has started, first call the Child Workflow Execution method on the instance of Child Workflow future, which returns a different future.\n\nThen get the value of an object that acts as a proxy for a result that is initially unknown, which is what waits until the Child Workflow Execution has spawned.\n","is_empty":false},{"file_name":"code-samples-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/code-samples-python.md","id":"python/code-samples-python","title":"Code samples","label":"Code samples","ssdi":[],"markdown_content":"\n- [Python samples library](https://github.com/temporalio/samples-python)\n","is_empty":false},{"file_name":"code-samples.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/code-samples.md","id":"python/code-samples","title":"Where are SDK-specific code examples?","description":"You can find a complete list of executable code samples in Temporal's GitHub repository.","label":"Code samples","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can find a complete list of executable code samples in [Temporal's GitHub repository](https://github.com/temporalio?q=samples-&type=all&language=&sort=).\n\nAdditionally, several of the [Tutorials](https://learn.temporal.io) are backed by a fully executable template application.\n","is_empty":false},{"file_name":"connect-to-a-dev-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/connect-to-a-dev-cluster.md","id":"python/connect-to-a-dev-cluster","title":"How to connect a Temporal Client to a Temporal Cluster","description":"When connecting a Temporal Client to a Temporal Cluster, you must provide the address and port number of the Temporal Cluster.","label":"Connect to a dev Cluster","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal Client](/concepts/what-is-a-temporal-client) enables you to communicate with the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nCommunication with a Temporal Cluster includes, but isn't limited to, the following:\n\n- Starting Workflow Executions.\n- Sending Signals to Workflow Executions.\n- Sending Queries to Workflow Executions.\n- Getting the results of a Workflow Execution.\n- Providing an Activity Task Token.\n\n:::caution\n\nA Temporal Client cannot be initialized and used inside a Workflow.\nHowever, it is acceptable and common to use a Temporal Client inside an Activity to communicate with a Temporal Cluster.\n\n:::\n\nWhen you are running a Cluster locally (such as [Temporalite](/kb/all-the-ways-to-run-a-cluster#temporalite)), the number of connection options you must provide is minimal.\nMany SDKs default to the local host or IP address and port that Temporalite and [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose) serve (`127.0.0.1:7233`).\n","is_empty":false},{"file_name":"connect-to-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/connect-to-temporal-cloud.md","id":"python/connect-to-temporal-cloud","title":"How to connect to Temporal Cloud","description":"Use a compatible mTLS CA certificate and mTLS private key and your Cloud Namespace to connect to Temporal Cloud.","label":"Connect to Temporal Cloud","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen you connect to [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"continue-as-new.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/continue-as-new.md","id":"python/continue-as-new","title":"How to Continue-As-New","description":"Continue-As-New enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.","label":"Continue-As-New","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Continue-As-New](/concepts/what-is-continue-as-new) enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.\nThe Workflow Execution spawned from the use of Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\n","is_empty":false},{"file_name":"cron-jobs.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/cron-jobs.md","id":"python/cron-jobs","title":"How to use Temporal Cron Jobs","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Jobs","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.\n","is_empty":false},{"file_name":"custom-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/custom-logging.md","id":"python/custom-logging","title":"How to provide a custom logger","description":"Use a custom logger for logging.","label":"Custom logger","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a custom logger for logging.\n","is_empty":false},{"file_name":"custom-payload-conversion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/custom-payload-conversion.md","id":"python/custom-payload-conversion","title":"How to use custom payload conversion","description":"Create your custom `PayloadConverter` and set it on a `DataConverter` in your Client options.","label":"Custom payload conversion","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal SDKs provide a [Payload Converter](/concepts/what-is-a-payload-converter) that can be customized to convert a custom data type to [Payload](/concepts/what-is-a-payload) and back.\n\nImplementing custom Payload conversion is optional.\nIt is needed only if the [default Data Converter](/concepts/what-is-a-default-data-converter) does not support your custom values.\n\nTo support custom Payload conversion, create a [custom Payload Converter](/concepts/what-is-a-payload-converter#custom-payload-conversion) and configure the Data Converter to use it in your Client options.\n\nThe order in which your encoding Payload Converters are applied depend on the order given to the Data Converter.\nYou can set multiple encoding Payload Converters to run your conversions.\nWhen the Data Converter receives a value for conversion, it passes through each Payload Converter in sequence until the converter that handles the data type does the conversion.\n","is_empty":false},{"file_name":"debug-environment-development.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/debug-environment-development.md","id":"python/debug-environment-development","title":"How to debug in a development environment","description":"In addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the Web UI and tctl.","label":"Debug in a development environment","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the [Web UI](/web-ui) or [`tctl`](/tctl-v1).\n","is_empty":false},{"file_name":"debug-environment-production.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/debug-environment-production.md","id":"python/debug-environment-production","title":"How to debug in a development production","description":"Debug production Workflows using the Web UI, tctl, Replays, Tracing, or Logging.","label":"Debug in a development production","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can debug production Workflows using:\n\n- [Web UI](/web-ui)\n- [tctl](/tctl-v1)\n- [Replay](#replay)\n- [Tracing](/python/tracing)\n- [Logging](/python/logging)\n\nYou can debug and tune Worker performance with metrics and the [Worker performance guide](/dev-guide/worker-performance).\nFor more information, see [Observability ▶️ Metrics](/dev-guide/python/observability#metrics) for setting up SDK metrics.\n\nDebug Server performance with [Cloud metrics](/cloud/how-to-monitor-temporal-cloud-metrics) or [self-hosted Server metrics](/kb/legacy-oss-prod-deploy#scaling-and-metrics).\n","is_empty":false},{"file_name":"debugging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/debugging.md","id":"python/debugging","title":"Debugging","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Debug","tags":["guide-context"],"ssdi":[],"markdown_content":"","is_empty":false},{"file_name":"define-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/define-query.md","id":"python/define-query","title":"How to define a Query","description":"A Query has a name and can have arguments.","label":"Define Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Query has a name and can have arguments.\n\n- The name, also called a Query type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"define-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/define-signal.md","id":"python/define-signal","title":"How to define a Signal","description":"A Signal has a name and can have arguments.","label":"Define Signal","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"developing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/developing-activities.md","id":"python/developing-activities","title":"How to develop a basic Activity","description":"One of the primary things that Workflows do is orchestrate the execution of Activities.","label":"Develop Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nOne of the primary things that Workflows do is orchestrate the execution of Activities.\nAn Activity is a normal function or method execution that's intended to execute a single, well-defined action (either short or long-running), such as querying a database, calling a third-party API, or transcoding a media file.\nAn Activity can interact with world outside the Temporal Platform or use a Temporal Client to interact with a Cluster.\nFor the Workflow to be able to execute the Activity, we must define the [Activity Definition](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"developing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/developing-workflows.md","id":"python/developing-workflows","title":"How to develop a basic Workflow","description":"Workflows are the fundamental unit of a Temporal Application, and it all starts with the development of a Workflow Definition.","label":"Develop Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/concepts/what-is-a-workflow-definition).\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/environment-variables.md","id":"python/environment-variables","title":"How to read and pass environment variables","description":"Environment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.","label":"Environment variables","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEnvironment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.\nThey can't be used normally with Workflow code, as that would be [non-deterministic](workflows#intrinsic-non-deterministic-logic) (if the environment variables changed between Workflow replays, the code that used them would behave differently).\n\nMost of the time, you can provide environment variables in your Activity function; however, if you need them in your Workflow functions, you can use the following options:\n\n- Provide environment variables as arguments when starting the Workflow.\n- Call a Local Activity at the beginning of the Workflow that returns environment variables.\n\nIn either case, the environment variables will appear in Event History, so you may want to use an [encryption Data Converter](/concepts/what-is-a-data-converter#encryption).\n","is_empty":false},{"file_name":"features.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/features.md","id":"python/features","title":"How to use Workflow and Activity features","description":"The Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.","label":"Features","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\n\nIn this section you can find the following:\n\n- [How to develop Signals](#signals)\n- [How to develop Queries](#queries)\n- [How to start a Child Workflow Execution](#child-workflows)\n- [How to start a Temporal Cron Job](#temporal-cron-jobs)\n- [How to use Continue-As-New](#continue-as-new)\n- [How to set Workflow timeouts & retries](#workflow-timeouts)\n- [How to set Activity timeouts & retries](#activity-timeouts)\n- [How to Heartbeat an Activity](#activity-heartbeats)\n- [How to Asynchronously complete an Activity](#asynchronous-activity-completion)\n- [How to register Namespaces](#namespaces)\n- [How to use custom payload conversion](#custom-payload-conversion)\n","is_empty":false},{"file_name":"foundations.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/foundations.md","id":"python/foundations","title":"How to build a basic Temporal Application","description":"The Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application—that is, all the relevant steps to start a Workflow Execution that executes an Activity.","label":"Foundations","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a [Temporal Application](/concepts/what-is-a-temporal-application)—that is, all the relevant steps to start a [Workflow Execution](#develop-workflows) that executes an [Activity](#develop-activities).\n\nIn this section you can find the following:\n\n- [Run a development Cluster](/clusters/how-to-install-temporal-cli)\n- [Install your SDK](/python/add-sdk)\n- [Connect to a dev Cluster](/python/connect-to-a-dev-cluster)\n- [Connect to Temporal Cloud](/python/connect-to-temporal-cloud)\n- [Develop a Workflow](/python/developing-workflows)\n- [Develop an Activity](/python/developing-activities)\n- [Start an Activity Execution](/python/spawning-activities)\n- [Run a dev Worker](/python/run-a-dev-worker)\n- [Run a Temporal Cloud Worker](/python/run-a-dev-worker)\n- [Start a Workflow Execution](/python/spawning-workflows)\n","is_empty":false},{"file_name":"get-activity-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/get-activity-results.md","id":"python/get-activity-results","title":"How to get the results of an Activity Execution","description":"The call to spawn an Activity Execution generates the ScheduleActivityTask Command and provides the Workflow with an Awaitable.","label":"Get Activity results","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe call to spawn an [Activity Execution](/concepts/what-is-an-activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.\n","is_empty":false},{"file_name":"get-workflow-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/get-workflow-results.md","id":"python/get-workflow-results","title":"How to get the results of a Workflow Execution","description":"If the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.","label":"Get Workflow results","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.\n\nThe Workflow Id, Run Id, and Namespace may be used to uniquely identify a Workflow Execution in the system and get its result.\n\nIt's possible to both block progress on the result (synchronous execution) or get the result at some other point in time (asynchronous execution).\n\nIn the Temporal Platform, it's also acceptable to use Queries as the preferred method for accessing the state and results of Workflow Executions.\n","is_empty":false},{"file_name":"handle-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/handle-query.md","id":"python/handle-query","title":"How to handle a Query","description":"Queries are handled by your Workflow.","label":"Handle Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are handled by your Workflow.\n\nDon’t include any logic that causes [Command](/concepts/what-is-a-command) generation within a Query handler (such as executing Activities).\nIncluding such logic causes unexpected behavior.\n","is_empty":false},{"file_name":"handle-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/handle-signal.md","id":"python/handle-signal","title":"How to handle a Signal","description":"Workflows listen for Signals by the Signal's name.","label":"Handle Signal","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows listen for Signals by the Signal's name.\n","is_empty":false},{"file_name":"heartbeat-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/heartbeat-timeout.md","id":"python/heartbeat-timeout","title":"How to set a Heartbeat Timeout","description":"A Heartbeat Timeout works in conjunction with Activity Heartbeats.","label":"Heartbeat Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) works in conjunction with [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python.md","id":"python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python","title":"How to set custom Search Attributes in Python","description":"To set custom Search Attributes, use the `search_attributes` parameter of 'start_workflow()'.","label":"Set custom Search Attributes","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nTo set custom Search Attributes, use the `search_attributes` parameter of the ['start_workflow()'](https://python.temporal.io/temporalio.client.Client.html#start_workflow) method.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    search_attributes={\"Your-Custom-Keyword-Field\": [\"value\"]},\n)\n```\n","is_empty":false},{"file_name":"how-to-backfill-a-scheduled-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-backfill-a-scheduled-workflow-execution-in-python.md","id":"python/how-to-backfill-a-scheduled-workflow-execution-in-python","title":"How to backfill a Scheduled Workflow Execution in Python","description":"Use the `backfill()` asynchronous method on the Schedule Handler.","label":"Backfill a Scheduled Workflow Execution","ssdi":[],"markdown_content":"\nTo Backfill a Scheduled Workflow Execution in Python, use the [backfill()](https://python.temporal.io/temporalio.client.ScheduleHandle.html#backfill) asynchronous\nmethod on the Schedule Handle.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/schedule_your_workflow/backfill_schedule_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    handle = client.get_schedule_handle(\n        \"workflow-schedule-id\",\n    )\n    now = datetime.utcnow()\n    await handle.backfill(\n        ScheduleBackfill(\n            start_at=now - timedelta(minutes=10),\n            end_at=now - timedelta(minutes=9),\n            overlap=ScheduleOverlapPolicy.ALLOW_ALL,\n        ),\n    ),\n```\n","is_empty":false},{"file_name":"how-to-cancel-a-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-cancel-a-workflow-execution-in-python.md","id":"python/how-to-cancel-a-workflow-execution-in-python","title":"How to Cancel a Workflow Execution in Python","description":"Cancel a Workflow Execution with Retry Policies.","label":"Cancel a Workflow Execution","ssdi":[],"markdown_content":"\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/workflow_failures/workflow_dacx.py\">View source code</a>\n\n```python\nfrom temporalio.common import RetryPolicy\n```\n","is_empty":false},{"file_name":"how-to-cancel-an-activity-from-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-cancel-an-activity-from-a-workflow-in-python.md","id":"python/how-to-cancel-an-activity-from-a-workflow-in-python","title":"How to Cancel an Activity from a Workflow in Python","description":"To cancel an Activity from a Workflow in Python, use `cancel()` on the Task.","label":"Cancel an Activity from a Workflow","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nTo cancel an Activity from a Workflow Execution, call the [cancel()](https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel) method on the Activity handle that is returned from [start_activity()](https://python.temporal.io/temporalio.workflow.html#start_activity).\n\n```python\n@activity.defn\nasync def cancellable_activity(input: ComposeArgsInput) -> NoReturn:\n    try:\n        while True:\n            print(\"Heartbeating cancel activity\")\n            await asyncio.sleep(0.5)\n            activity.heartbeat(\"some details\")\n    except asyncio.CancelledError:\n        print(\"Activity cancelled\")\n        raise\n\n\n@activity.defn\nasync def run_activity(input: ComposeArgsInput):\n    print(\"Executing activity\")\n    return input.arg1 + input.arg2\n\n@workflow.defn\n class GreetingWorkflow:\n     @workflow.run\n     async def run(self, input: ComposeArgsInput) -> None:\n        activity_handle = workflow.start_activity(\n            cancel_activity,\n            ComposeArgsInput(input.arg1, input.arg2),\n            start_to_close_timeout=timedelta(minutes=5),\n            heartbeat_timeout=timedelta(seconds=30),\n        )\n    \n        await asyncio.sleep(3)\n        activity_handle.cancel()\n```\n\n:::note\n\nThe Activity handle is a Python task.\nBy calling `cancel()`, you're essentially requesting the task to be canceled.\n\n:::\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-configure-tracing-in-python.md","id":"python/how-to-configure-tracing-in-python","title":"How to configure tracing in Python","description":"To configure tracing in Python, install the `opentelemetry` dependencies.","label":"Configure tracing","tags":["python","how-to"],"ssdi":[],"markdown_content":"\nTo configure tracing in Python, install the `opentelemetry` dependencies.\n\n```bash\n# This command installs the `opentelemetry` dependencies.\npip install temporalio[opentelemetry]\n```\n\nThen the [`temporalio.contrib.opentelemetry.TracingInterceptor`](https://python.temporal.io/temporalio.contrib.opentelemetry.TracingInterceptor.html) class can be set as an interceptor as an argument of [`Client.connect()`](https://python.temporal.io/temporalio.client.Client.html#connect).\n\nWhen your Client is connected, spans are created for all Client calls, Activities, and Workflow invocations on the Worker.\nSpans are created and serialized through the server to give one trace for a Workflow Execution.\n","is_empty":false},{"file_name":"how-to-connect-to-a-cluster-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-connect-to-a-cluster-in-python.md","id":"python/how-to-connect-to-a-cluster-in-python","title":"How to connect to a Temporal Cluster in Python","description":"Connect a Temporal Client to a Cluster in the Python SDK.","label":"Connect a Temporal Client","ssdi":[],"markdown_content":"\nUse the `connect()` method on the Client class to create and connect to a Temporal Client to the Temporal Cluster.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/run_workflow_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    result = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your name\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n","is_empty":false},{"file_name":"how-to-connect-to-temporal-cloud-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-connect-to-temporal-cloud-in-python.md","id":"python/how-to-connect-to-temporal-cloud-in-python","title":"How to connect to Temporal Cloud","description":"Use a certificate key pair and your Temporal Cloud Namespace to connect to Temporal Cloud.","label":"Connect to Temporal Cloud","ssdi":[],"markdown_content":"\nUse the `connect()` method on the Client class to create and connect to a Temporal Client to the Temporal Cluster.\nThen specify the [TLSConfig](https://python.temporal.io/temporalio.service.TLSConfig.html) arguments to connect to a Temporal Cluster with TLS enabled.\nThe `client_cert` must be combined with `client_private_key` to authenticate the Client.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/connect_cloud_dacx.py\">View source code</a>\n\n```python\nfrom temporalio.client import Client, TLSConfig\n# ...\n# ...\nasync def main():\n    with open(\"client-cert.pem\", \"rb\") as f:\n        client_cert = f.read()\n    with open(\"client-private-key.pem\", \"rb\") as f:\n        client_private_key = f.read()\n    client = await Client.connect(\n        \"your-custom-namespace.tmprl.cloud:7233\",\n        namespace=\"your-custom-namespace\",\n        tls=TLSConfig(\n            client_cert=client_cert,\n            client_private_key=client_private_key,\n            # domain=domain, # TLS domain\n            # server_root_ca_cert=server_root_ca_cert, # ROOT CA to validate the server cert\n        ),\n    )\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-continue-as-new-in-python.md","id":"python/how-to-continue-as-new-in-python","title":"How to Continue-As-New in Python","description":"Continue-As-New","label":"Continue-As-New","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nTo Continue-As-New in Python, call the [`continue_as_new()`](https://python.temporal.io/temporalio.workflow.html#continue_as_new) function from inside your Workflow, which will stop the Workflow immediately and Continue-As-New.\n\n```python\nworkflow.continue_as_new(\"your-workflow-name\")\n```\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-create-a-temporal-client-in-python.md","id":"python/how-to-create-a-temporal-client-in-python","title":"How to create a Temporal Client in Python","description":"Create a Temporal Client","label":"Create a Temporal Client","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nUse [`connect()`](https://python.temporal.io/temporalio.client.Client.html#connect) method on the [`Client`](https://python.temporal.io/temporalio.client.Client.html) class to create and connect to a Temporal Server at a given address and Namespace.\n\nSpecify the `target_host` parameter as a string.\n\n**Connect to Docker**\n\n```python\nawait Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n```\n\n**Connect to your Cluster**\n\n```python\nawait Client.connect(\n    \"web.<Namespace_ID>.tmprl.cloud\", namespace=\"your-custom-namespace\"\n)\n```\n\nA `Client` does not have an explicit close.\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-customize-activity-type-in-python.md","id":"python/how-to-customize-activity-type-in-python","title":"How to customize Activity Type in Python","description":"Customize your Activity Type.","label":"Customize Activity Type","ssdi":[],"markdown_content":"\nYou can customize the Activity name with a custom name in the decorator argument. For example, `@activity.defn(name=\"your-activity\")`.\nIf the name parameter is not specified, the Activity name defaults to the function name.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_activities_dacx.py\">View source code</a>\n\n```python\n# ...\n@activity.defn(name=\"your_activity\")\nasync def your_activity(input: YourParams) -> str:\n    return f\"{input.greeting}, {input.name}!\"\n```\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-customize-workflow-type-in-python.md","id":"python/how-to-customize-workflow-type-in-python","title":"How to customize Workflow types in Python","description":"Customize Workflow types.","label":"Customize Workflow types","ssdi":[],"markdown_content":"\nYou can customize the Workflow name with a custom name in the decorator argument. For example, `@workflow.defn(name=\"your-workflow-name\")`. If the name parameter is not specified, the Workflow name defaults to the function name.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_workflows_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import workflow\n# ...\n# ...\n@workflow.defn(name=\"YourWorkflow\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            YourParams(\"Hello\", name),\n            start_to_close_timeout=timedelta(seconds=10),\n        )\n```\n","is_empty":false},{"file_name":"how-to-define-a-query-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-define-a-query-in-python.md","id":"python/how-to-define-a-query-in-python","title":"How to define a Query in Python","description":"Use the `@workflow.query` decorator to define a Query.","label":"Define a Query","ssdi":[],"markdown_content":"\nTo define a Query, set the Query decorator [`@workflow.query`](https://python.temporal.io/temporalio.workflow.html#query) on the Query function inside your Workflow.\n\n**Customize names**\n\nYou can have a name parameter to customize the Query's name, otherwise it defaults to the unqualified method `__name__`.\n\n:::note\n\nYou can either set the `name` or the `dynamic` parameter in a Query's decorator, but not both.\n\n:::\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/query_your_workflow/wf_query_dacx.py\">View source code</a>\n\n```python\n# ...\n    @workflow.query\n    def greeting(self) -> str:\n        return self._greeting\n```\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-define-a-signal-in-python.md","id":"python/how-to-define-a-signal-in-python","title":"How to define a Signal in Python","description":"Use the `@workflow.signal` decorator to define a Signal.","label":"Define a Signal","ssdi":[],"markdown_content":"\nA Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be serializable.\n  To define a Signal, set the Signal decorator [`@workflow.signal`](https://python.temporal.io/temporalio.workflow.html#signal) on the Signal function inside your Workflow.\n\n**Customize name**\n\nNon-dynamic methods can only have positional arguments.\nTemporal suggests taking a single argument that is an object or data class of fields that can be added to as needed.\n\nReturn values from Signal methods are ignored.\n\nYou can have a name parameter to customize the Signal's name, otherwise it defaults to the unqualified method `__name__`.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/signal_your_workflow/wf_signal_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import workflow\n# ...\n# ...\n    @workflow.signal\n    async def submit_greeting(self, name: str) -> None:\n        await self._pending_greetings.put(name)\n\n    @workflow.signal\n    def exit(self) -> None:\n# ...\n    @workflow.signal(name=\"Custom Signal Name\")\n    async def custom_signal(self, name: str) -> None:\n        await self._pending_greetings.put(name)\n```\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-define-activity-parameters-in-python.md","id":"python/how-to-define-activity-parameters-in-python","title":"How to do define Activity parameters in Python","description":"The only required parameter is `context.Context`, but Activities can support many custom parameters.","label":"Activity parameters","ssdi":[],"markdown_content":"\nActivity parameters are the function parameters of the function decorated with `@activity.defn`.\nThese can be any data type Temporal can convert, including dataclasses when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single dataclass parameter containing all input fields.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_activities_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import activity\nfrom your_dataobject_dacx import YourParams\n\n# ...\n# ...\n@activity.defn(name=\"your_activity\")\nasync def your_activity(input: YourParams) -> str:\n    return f\"{input.greeting}, {input.name}!\"\n```\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-define-activity-return-values-in-python.md","id":"python/how-to-define-activity-return-values-in-python","title":"How to define Activity return values in Python","description":"To return a value of the Workflow, use `return` to return an object.","label":"Activity return values","ssdi":[],"markdown_content":"\nAn Activity Execution can return inputs and other Activity values.\n\nThe following example defines an Activity that takes a string as input and returns a string.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_activities_dacx.py\">View source code</a>\n\n```python\n# ...\n@activity.defn(name=\"your_activity\")\nasync def your_activity(input: YourParams) -> str:\n    return f\"{input.greeting}, {input.name}!\"\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-define-workflow-parameters-in-python.md","id":"python/how-to-define-workflow-parameters-in-python","title":"How to define Workflow parameters","description":"Define Workflow parameters.","label":"Define Workflow parameters","ssdi":[],"markdown_content":"\nWorkflow parameters are the method parameters of the singular method decorated with `@workflow.run`.\nThese can be any data type Temporal can convert, including [`dataclasses`](https://docs.python.org/3/library/dataclasses.html) when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single `dataclass` parameter containing all input fields.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_dataobject_dacx.py\">View source code</a>\n\n```python\nfrom dataclasses import dataclass\n# ...\n# ...\n@dataclass\nclass YourParams:\n    greeting: str\n    name: str\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-define-workflow-return-values-in-python.md","id":"python/how-to-define-workflow-return-values-in-python","title":"How to define Workflow return values","description":"Define Workflow return values.","label":"Define Workflow return values","ssdi":[],"markdown_content":"\nTo return a value of the Workflow, use `return` to return an object.\n\nTo return the results of a Workflow Execution, use either `start_workflow()` or `execute_workflow()` asynchronous methods.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_workflows_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import workflow\n# ...\n# ...\n@workflow.defn(name=\"YourWorkflow\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            YourParams(\"Hello\", name),\n            start_to_close_timeout=timedelta(seconds=10),\n        )\n```\n","is_empty":false},{"file_name":"how-to-delete-a-scheduled-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-delete-a-scheduled-workflow-execution-in-python.md","id":"python/how-to-delete-a-scheduled-workflow-execution-in-python","title":"How to delete a Scheduled Workflow Execution in Python","description":"Use the `delete()` asynchronous method on the Schedule Handler.","label":"Delete a Scheduled Workflow Execution","ssdi":[],"markdown_content":"\nTo delete a Scheduled Workflow Execution in Python, use the [delete()](https://python.temporal.io/temporalio.client.ScheduleHandle.html#delete) asynchronous method on the Schedule Handle.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/schedule_your_workflow/delete_schedule_dacx.py\">View source code</a>\n\n```python\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    handle = client.get_schedule_handle(\n        \"workflow-schedule-id\",\n    )\n\n    await handle.delete()\n```\n","is_empty":false},{"file_name":"how-to-describe-a-scheduled-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-describe-a-scheduled-workflow-execution-in-python.md","id":"python/how-to-describe-a-scheduled-workflow-execution-in-python","title":"How to describe a Scheduled Workflow Execution in Python","description":"Use the `describe()` asynchronous method on the Schedule Handler.","label":"Describe a Scheduled Workflow Execution","ssdi":[],"markdown_content":"\nTo describe a Scheduled Workflow Execution in Python, use the [describe()](https://python.temporal.io/temporalio.client.ScheduleHandle.html#delete) asynchronous method on the Schedule Handle.\nYou can get a complete list of the attributes of the Scheduled Workflow Execution from the [ScheduleDescription](https://python.temporal.io/temporalio.client.ScheduleDescription.html) class.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/schedule_your_workflow/describe_schedule_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    handle = client.get_schedule_handle(\n        \"workflow-schedule-id\",\n    )\n\n    desc = await handle.describe()\n\n    print(f\"Returns the note: {desc.schedule.state.note}\")\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-develop-a-worker-program-in-python.md","id":"python/how-to-develop-a-worker-program-in-python","title":"How to develop a Worker Program in Python","description":"Create a new instance of a Worker.","label":"Worker Program","ssdi":[],"markdown_content":"\nTo develop a Worker, use the `Worker()` constructor and add your Client, Task Queue, Workflows, and Activities as arguments.\nThe following code example creates a Worker that polls for tasks from the Task Queue and executes the Workflow.\nWhen a Worker is created, it accepts a list of Workflows in the workflows parameter, a list of Activities in the activities parameter, or both.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/run_worker_dacx.py\">View source code</a>\n\n```python\nfrom temporalio.client import Client\nfrom temporalio.worker import Worker\n# ...\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    worker = Worker(\n        client,\n        task_queue=\"your-task-queue\",\n        workflows=[YourWorkflow],\n        activities=[your_activity],\n    )\n    await worker.run()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-develop-a-workflow-definition-in-python.md","id":"python/how-to-develop-a-workflow-definition-in-python","title":"How to develop a Workflow Definition in Python","description":"To develop a Workflow Definition, specify the `@workflow.defn` decorator on the Workflow class and use `@workflow.run` to mark the entry point.","label":"Develop a Workflow Definition","ssdi":[],"markdown_content":"\nIn the Temporal Python SDK programming model, Workflows are defined as classes.\n\nSpecify the `@workflow.defn` decorator on the Workflow class to identify a Workflow.\n\nUse the `@workflow.run` to mark the entry point method to be invoked. This must be set on one asynchronous method defined on the same class as `@workflow.defn`. Run methods have positional parameters.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_workflows_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import workflow\n# ...\n# ...\n@workflow.defn(name=\"YourWorkflow\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            YourParams(\"Hello\", name),\n            start_to_close_timeout=timedelta(seconds=10),\n        )\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-develop-an-activity-definition-in-python.md","id":"python/how-to-develop-an-activity-definition-in-python","title":"How to develop an Activity Definition in Python","description":"In the Temporal Go SDK programming model, an Activity Definition is an exportable function or a struct method.","label":"Activity Definition","ssdi":[],"markdown_content":"\nYou can develop an Activity Definition by using the `@activity.defn` decorator.\nRegister the function as an Activity with a custom name through a decorator argument, for example `@activity.defn(name=\"your_activity\")`.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_activities_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import activity\n# ...\n# ...\n@activity.defn(name=\"your_activity\")\nasync def your_activity(input: YourParams) -> str:\n    return f\"{input.greeting}, {input.name}!\"\n```\n","is_empty":false},{"file_name":"how-to-emit-metrics-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-emit-metrics-in-python.md","id":"python/how-to-emit-metrics-in-python","title":"How to emit metrics in Python","description":"Metrics are configured globally be setting a Prometheus endpoint before any other Temporal code.","label":"Emit metrics","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nMetrics in Python are configured globally; therefore, you should set a Prometheus endpoint before any other Temporal code.\n\nThe following example exposes a Prometheus endpoint on port `9000`.\n\n```python\nfrom temporalio.runtime import Runtime, TelemetryConfig, PrometheusConfig\n\n# Create a new runtime that has telemetry enabled. Create this first to avoid\n# the default Runtime from being lazily created.\nnew_runtime = Runtime(telemetry=TelemetryConfig(metrics=PrometheusConfig(bind_address=\"0.0.0.0:9000\")))\nmy_client = await Client.connect(\"my.temporal.host:7233\", runtime=new_runtime)\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-get-the-result-of-a-workflow-execution-in-python.md","id":"python/how-to-get-the-result-of-a-workflow-execution-in-python","title":"How to get the result of a Workflow Execution in Python","description":"Workflow Execution result.","label":"Workflow Execution result","ssdi":[],"markdown_content":"\nUse [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.Client.html#get_workflow_handle) to return a Workflow handle.\nThen use the [`result`](https://python.temporal.io/temporalio.client.WorkflowHandle.html#result) method to await on the result of the Workflow.\n\nTo get a handle for an existing Workflow by its Id, you can use [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.Client.html#get_workflow_handle), or use [`get_workflow_handle_for()`](https://python.temporal.io/temporalio.client.Client.html#get_workflow_handle_for) for type safety.\n\nThen use [`describe()`](https://python.temporal.io/temporalio.client.workflowhandle#describe) to get the current status of the Workflow.\nIf the Workflow does not exist, this call fails.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/get_workflow_results_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    handle = client.get_workflow_handle(\n        workflow_id=\"your-workflow-id\",\n    )\n    results = await handle.result()\n    print(f\"Result: {results}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-get-the-result-of-an-activity-execution-in-python.md","id":"python/how-to-get-the-result-of-an-activity-execution-in-python","title":"How to get the result of an Activity Execution in Python","description":"Get the result of an Activity Execution.","label":"Get the result of an Activity Execution","ssdi":[],"markdown_content":"\nUse [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) to start an Activity and return its handle, [`ActivityHandle`](https://python.temporal.io/temporalio.workflow.ActivityHandle.html). Use [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) to return the results.\n\nYou must provide either `schedule_to_close_timeout` or `start_to_close_timeout`.\n\n`execute_activity()` is a shortcut for `await start_activity()`. An asynchronous `execute_activity()` helper is provided which takes the same arguments as `start_activity()` and `await`s on the result. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_workflows_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import workflow\n# ...\n# ...\n@workflow.defn(name=\"YourWorkflow\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            YourParams(\"Hello\", name),\n            start_to_close_timeout=timedelta(seconds=10),\n        )\n```\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-handle-a-query-in-a-workflow-in-python.md","id":"python/how-to-handle-a-query-in-a-workflow-in-python","title":"How to handle a Query in a Workflow","description":"To send a Query to a Workflow, use the `query` method from the `WorkflowHandle` class.","label":"Handle a Query in a Workflow","ssdi":[],"markdown_content":"\nTo send a Query to the Workflow, use the [`query`](https://python.temporal.io/temporalio.client.WorkflowHandle.html#query) method from the [`WorkflowHandle`](https://python.temporal.io/temporalio.client.WorkflowHandle.html) class.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/query_your_workflow/query_dacx.py\">View source code</a>\n\n```python\n# ...\n    result = await handle.query(GreetingWorkflow.greeting)\n```\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-handle-a-signal-in-a-workflow-in-python.md","id":"python/how-to-handle-a-signal-in-a-workflow-in-python","title":"How to handle a Signal in Python","description":"Set the Signal on the Workflow Handle.","label":"Handle a Signal","ssdi":[],"markdown_content":"\nWorkflows listen for Signals by the Signal's name.\n\nTo send a Signal to the Workflow, use the [signal](https://python.temporal.io/temporalio.client.WorkflowHandle.html#signal) method from the [WorkflowHandle](https://python.temporal.io/temporalio.client.WorkflowHandle.html) class.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/signal_your_workflow/signal_dacx.py\">View source code</a>\n\n```python\nfrom temporalio.client import Client\n# ...\n# ...\n    await handle.signal(GreetingWorkflow.submit_greeting, \"User 1\")\n```\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-handle-workflow-logic-requirements-in-python.md","id":"python/how-to-handle-workflow-logic-requirements-in-python","title":"How to handle Workflow logic requirements in Python","description":"Handle Workflow logic requirements","label":"Handle Workflow logic requirements","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nWorkflow code must be deterministic. This means:\n\n- no threading\n- no randomness\n- no external calls to processes\n- no network I/O\n- no global state mutation\n- no system date or time\n\nAll API safe for Workflows used in the [`temporalio.workflow`](https://python.temporal.io/temporalio.workflow.html) must run in the implicit [`asyncio` event loop](https://docs.python.org/3/library/asyncio-eventloop.html) and be _deterministic_.\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-heartbeat-an-activity-in-python.md","id":"python/how-to-heartbeat-an-activity-in-python","title":"How to heartbeat an Activity in Python","description":"Heartbeat an Activity","label":"Heartbeat an Activity","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nTo Heartbeat an Activity Execution in Python, use the [`heartbeat()`](https://python.temporal.io/temporalio.activity.html#heartbeat) API.\n\n```python\n@activity.defn\nasync def your_activity_definition() -> str:\n    activity.heartbeat(\"heartbeat details!\")\n```\n\nIn addition to obtaining cancellation information, Heartbeats also support detail data that persists on the server for retrieval during Activity retry.\nIf an Activity calls `heartbeat(123, 456)` and then fails and is retried, `heartbeat_details` returns an iterable containing `123` and `456` on the next Run.\n","is_empty":false},{"file_name":"how-to-list-scheduled-workflow-executions-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-list-scheduled-workflow-executions-in-python.md","id":"python/how-to-list-scheduled-workflow-executions-in-python","title":"How to list Scheduled Workflow Executions in Python","description":"Use `list_schedules()` on the Client to list all Workflow Execution in the Python SDK.","label":"List Scheduled Workflow Executions","ssdi":[],"markdown_content":"\nTo list all schedules, use the [list_schedules()](https://python.temporal.io/temporalio.client.Client.html#list_schedules) asynchronous method on the Client.\nIf a schedule is added or deleted, it may not be available in the list immediately.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/schedule_your_workflow/list_schedule_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main() -> None:\n    client = await Client.connect(\"localhost:7233\")\n    async for schedule in await client.list_schedules():\n        print(f\"List Schedule Info: {schedule.info}.\")\n```\n","is_empty":false},{"file_name":"how-to-list-workflow-executions-using-the-client-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-list-workflow-executions-using-the-client-in-python.md","id":"python/how-to-list-workflow-executions-using-the-client-in-python","title":"How to list Workflows in Python","description":"List Workflows from the Client using `list_workflows()`.","label":"List Workflows","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nUse the [list_workflows()](https://python.temporal.io/temporalio.client.Client.html#list_workflows) method on the Client handle and pass a [List Filter](/concepts/what-is-a-list-filter) as an argument to filter the listed Workflows.\n\n```python\nasync for workflow in client.list_workflows('WorkflowType=\"MyWorkflowClass\"'):\n    print(f\"Workflow: {workflow.id}\")\n```\n","is_empty":false},{"file_name":"how-to-listen-to-heartbeats-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-listen-to-heartbeats-in-python.md","id":"python/how-to-listen-to-heartbeats-in-python","title":"How to heartbeat an Activity in a test in Python","description":"To listen to a Heartbeat in a test, use the on_heartbeat property.","label":"Heartbeat an Activity in a test","tags":["developer-guide","sdk","python","testing"],"ssdi":[],"markdown_content":"\nTo test a Heartbeat in an Activity, use the [`on_heartbeat()`](https://python.temporal.io/temporalio.testing.ActivityEnvironment.html#on_heartbeat) property of the [`ActivityEnvironment`](https://python.temporal.io/temporalio.testing.ActivityEnvironment.html) class.\nThis property sets a custom function that is called every time the `activity.heartbeat()` function is called within the Activity.\n\n```python\n@activity.defn\nasync def activity_with_heartbeats(param: str):\n    activity.heartbeat(f\"param: {param}\")\n    activity.heartbeat(\"second heartbeat\")\n\nenv = ActivityEnvironment()\nheartbeats = []\n# Set the `on_heartbeat` property to a callback function that will be called for each Heartbeat sent by the Activity.\nenv.on_heartbeat = lambda *args: heartbeats.append(args[0])\n# Use the run method to start the Activity, passing in the function that contains the Heartbeats and any necessary parameters.\nawait env.run(activity_with_heartbeats, \"test\")\n# Verify that the expected Heartbeats are received by the callback function.\nassert heartbeats == [\"param: test\", \"second heartbeat\"]\n```\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-log-from-a-workflow-in-python.md","id":"python/how-to-log-from-a-workflow-in-python","title":"How to log from a Workflow in Python","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nYou can log from a Workflow using Python's standard library, by importing the logging module `import logging`.\n\nSet your logging configuration to a level you want to expose logs to.\nThe following example sets the logging information level to `INFO`.\n\n```python\nlogging.basicConfig(level=logging.INFO)\n```\n\nThen in your Workflow, set your [`logger`](https://python.temporal.io/temporalio.workflow.html#logger) and level on the Workflow. The following example logs the Workflow.\n\n```python\n@workflow.defn\nclass SayHelloWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        workflow.logger.info(f\"Running workflow with parameter {name}\")\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=10)\n        )\n```\n\nThe following is an example output:\n\n```\nINFO:temporalio.workflow:Running workflow with parameter Temporal ({'attempt': 1, 'your-custom-namespace': 'default', 'run_id': 'your-run-id', 'task_queue': 'your-task-queue', 'workflow_id': 'your-workflow-id', 'workflow_type': 'SayHelloWorkflow'})\n```\n\n:::note\n\nLogs are skipped during replay by default.\n\n:::\n","is_empty":false},{"file_name":"how-to-mark-a-workflow-definition-as-deprecated-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-mark-a-workflow-definition-as-deprecated-in-python.md","id":"python/how-to-mark-a-workflow-definition-as-deprecated-in-python","title":"How to mark a Workflow Definition as deprecated in Python","description":"Set the deprecated_patch() function on the Workflow.","label":"Mark a Workflow Definition as deprecated","ssdi":[],"markdown_content":"\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/version_your_workflows/workflow_3_patch_deprecated_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import workflow\n# ...\n@workflow.defn\nclass MyWorkflow:\n    @workflow.run\n    async def run(self) -> None:\n        workflow.deprecate_patch(\"my-patch\")\n        self._result = await workflow.execute_activity(\n            post_patch_activity,\n            schedule_to_close_timeout=timedelta(minutes=5),\n        )\n```\n","is_empty":false},{"file_name":"how-to-mock-activities-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-mock-activities-in-python.md","id":"python/how-to-mock-activities-in-python","title":"How to mock Activities in Python","description":"Mock Activities for testing in Python.","label":"Mock Activities for testing","tags":["python","how-to","testing"],"ssdi":[],"markdown_content":"\nProvide mock Activity implementations to the Worker.\n\n```python\nimport uuid\nfrom temporalio.client import Client\nfrom temporalio.worker import Worker\n\n# Import your Activity Definition and real implementation\nfrom hello.hello_activity import (\n    ComposeGreetingInput,\n    GreetingWorkflow,\n    compose_greeting,\n)\n\n# Define your mocked Activity implementation\n@activity.defn(name=\"compose_greeting\")\nasync def compose_greeting_mocked(input: ComposeGreetingInput) -> str:\n    return f\"{input.greeting}, {input.name} from mocked activity!\"\n\nasync def test_mock_activity(client: Client):\n    task_queue_name = str(uuid.uuid4())\n    # Provide the mocked Activity implementation to the Worker\n    async with Worker(\n        client,\n        task_queue=task_queue_name,\n        workflows=[GreetingWorkflow],\n        activities=[compose_greeting_mocked],\n    ):\n        # Execute your Workflow as usual\n        assert \"Hello, World from mocked activity!\" == await client.execute_workflow(\n            GreetingWorkflow.run,\n            \"World\",\n            id=str(uuid.uuid4()),\n            task_queue=task_queue_name,\n        )\n```\n\nThe mocked Activity implementation should have the same signature as the real implementation (including the input and output types) and the same name.\nWhen the Workflow invokes the Activity, it invokes the mocked implementation instead of the real one, allowing you to test your Workflow isolated.\n","is_empty":false},{"file_name":"how-to-patch-a-workflow-definition-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-patch-a-workflow-definition-in-python.md","id":"python/how-to-patch-a-workflow-definition-in-python","title":"How to Patch a Workflow Definition in Python","description":"Set the patched() function on the Workflow.","label":"Patch a Workflow Definition","ssdi":[],"markdown_content":"\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/version_your_workflows/workflow_2_patched_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import workflow\n# ...\n@workflow.defn\nclass MyWorkflow:\n    @workflow.run\n    async def run(self) -> None:\n        if workflow.patched(\"my-patch\"):\n            self._result = await workflow.execute_activity(\n                post_patch_activity,\n                schedule_to_close_timeout=timedelta(minutes=5),\n            )\n```\n","is_empty":false},{"file_name":"how-to-pause-a-scheduled-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-pause-a-scheduled-workflow-execution-in-python.md","id":"python/how-to-pause-a-scheduled-workflow-execution-in-python","title":"How to Pause Scheduled Workflow Execution in Python","description":"Use the `pause()` asynchronous method on the Schedule Handle.","label":"Pause a Scheduled Workflow Execution","ssdi":[],"markdown_content":"\nTo pause a Scheduled Workflow Execution in Python, use the [pause()](https://python.temporal.io/temporalio.client.ScheduleHandle.html#pause) asynchronous method on the Schedule Handle.\nYou can pass a `note` to the `pause()` method to provide a reason for pausing the schedule.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/schedule_your_workflow/pause_schedule_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    handle = client.get_schedule_handle(\n        \"workflow-schedule-id\",\n    )\n\n    await handle.pause(note=\"Pausing the schedule for now\")\n```\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-register-types-with-a-worker-in-python.md","id":"python/how-to-register-types-with-a-worker-in-python","title":"How to register types with a Worker in Python","description":"Register types with a Worker.","label":"Register types with a Worker","ssdi":[],"markdown_content":"\nWhen a `Worker` is created, it accepts a list of Workflows in the `workflows` parameter, a list of Activities in the `activities` parameter, or both.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/run_worker_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    worker = Worker(\n        client,\n        task_queue=\"your-task-queue\",\n        workflows=[YourWorkflow],\n        activities=[your_activity],\n    )\n    await worker.run()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-remove-search-attributes-from-a-workflow-in-python.md","id":"python/how-to-remove-search-attributes-from-a-workflow-in-python","title":"How to remove Search Attributes in Python","description":"To remove a Search Attribute, use `upsert_search_attributes()` with an empty list as its value.","label":"Remove Search Attributes","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nTo remove a Search Attribute, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) function with an empty list as its value.\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": []})\n```\n","is_empty":false},{"file_name":"how-to-replay-a-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-replay-a-workflow-execution-in-python.md","id":"python/how-to-replay-a-workflow-execution-in-python","title":"How to replay a Workflow Execution in Python","description":"To replay a Workflow Execution, use the `replay_workflow()` method and pass a Workflow History as an argument.","label":"Replay a Workflow Execution","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nTo replay Workflow Executions, use the [`replay_workflows`](https://python.temporal.io/temporalio.worker.Replayer.html#replay_workflows) or [`replay_workflow`](https://python.temporal.io/temporalio.worker.Replayer.html#replay_workflow) methods, passing one or more Event Histories as arguments.\n\nIn the following example (which, as of server v1.18, requires Advanced Visibility to be enabled), Event Histories are downloaded from the server and then replayed.\nIf any replay fails, the code raises an exception.\n\n```python\nworkflows = client.list_workflows(f\"TaskQueue=foo and StartTime > '2022-01-01T12:00:00'\")\nhistories = workflows.map_histories()\nreplayer = Replayer(\n    workflows=[MyWorkflowA, MyWorkflowB, MyWorkflowC]\n)\nawait replayer.replay_workflows(histories)\n```\n\nIn the next example, a single history is loaded from a JSON string:\n\n```python\nreplayer = Replayer(workflows=[YourWorkflow])\nawait replayer.replay_workflow(WorkflowHistory.from_json(history_json_str))\n```\n\nIn both examples, if Event History is non-deterministic, an error is thrown.\nYou can choose to wait until all histories have been replayed with `replay_workflows` by setting the `fail_fast` option to `false`.\n\n:::note\n\nIf the Workflow History is exported by [Temporal Web UI](/web-ui) or through [tctl](/tctl-v1), you can pass the JSON file history object as a JSON string or as a Python dictionary through the `json.load()` function, which takes a file object and returns the JSON object.\n\n:::\n","is_empty":false},{"file_name":"how-to-run-an-activity-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-run-an-activity-in-python.md","id":"python/how-to-run-an-activity-in-python","title":"How to run an Activity in a test in Python","description":"To run an Activity in a test for Python, use the `ActivityEnvironment` class.","label":"Run an Activity in a test","tags":["developer-guide","sdk","python","testing"],"ssdi":[],"markdown_content":"\nTo run an Activity in a test, use the [`ActivityEnvironment`](https://python.temporal.io/temporalio.testing.ActivityEnvironment.html) class.\n\nThis class allows you to run any callable inside an Activity context.\nUse it to test the behavior of your code under various conditions.\n","is_empty":false},{"file_name":"how-to-schedule-a-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-schedule-a-workflow-execution-in-python.md","id":"python/how-to-schedule-a-workflow-execution-in-python","title":"How to Schedule a Workflow Execution in Python","description":"Schedule a Workflow Execution in the Python SDK.","label":"Schedule a Workflow Execution","ssdi":[],"markdown_content":"\nTo create a Scheduled Workflow Execution in Python, use the [create_schedule()](https://python.temporal.io/temporalio.client.Client.html#create_schedule)\nasynchronous method on the Client.\nThen pass the Schedule ID and the Schedule object to the method to create a Scheduled Workflow Execution.\nSet the `action` parameter to `ScheduleActionStartWorkflow` to start a Workflow Execution.\nOptionally, you can set the `spec` parameter to `ScheduleSpec` to specify the schedule or set the `intervals` parameter to `ScheduleIntervalSpec` to specify the interval.\nOther options include: `cron_expressions`, `skip`, `start_at`, and `jitter`.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/schedule_your_workflow/start_schedule_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    await client.create_schedule(\n        \"workflow-schedule-id\",\n        Schedule(\n            action=ScheduleActionStartWorkflow(\n                YourSchedulesWorkflow.run,\n                \"my schedule arg\",\n                id=\"schedules-workflow-id\",\n                task_queue=\"schedules-task-queue\",\n            ),\n            spec=ScheduleSpec(\n                intervals=[ScheduleIntervalSpec(every=timedelta(minutes=2))]\n            ),\n            state=ScheduleState(note=\"Here's a note on my Schedule.\"),\n        ),\n    )\n```\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-send-a-query-to-a-workflow-execution-in-python.md","id":"python/how-to-send-a-query-to-a-workflow-execution-in-python","title":"How to send a Query to a Workflow Execution in Python","description":"Use the `query` method to send a Query.","label":"Sending Queries","ssdi":[],"markdown_content":"\nTo send a Query to a Workflow Execution from Client code, use the `query()` method on the Workflow handle.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/query_your_workflow/query_dacx.py\">View source code</a>\n\n```python\n# ...\n    result = await handle.query(GreetingWorkflow.greeting)\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-send-a-signal-from-a-client-in-python.md","id":"python/how-to-send-a-signal-from-a-client-in-python","title":"How to send a Signal from a Client in Python","description":"To send a Signal to a Workflow Execution from Client code, use the signal() method on the Workflow handle.","label":"Send a Signal from a Client","ssdi":[],"markdown_content":"\nTo send a Signal from the Client, use the [signal()](https://python.temporal.io/temporalio.client.WorkflowHandle.html#signal) function on the Workflow handle.\n\nTo get the Workflow handle, you can use any of the following options.\n\n- Use the [get_workflow_handle()](https://python.temporal.io/temporalio.client.Client.html#get_workflow_handle) method.\n- Use the [get_workflow_handle_for()](https://python.temporal.io/temporalio.client.Client.html#get_workflow_handle_for) method to get a type-safe Workflow handle by its Workflow Id.\n- Use the [start_workflow()](https://python.temporal.io/temporalio.client.Client.html#start_workflow) to start a Workflow and return its handle.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/signal_your_workflow/signal_dacx.py\">View source code</a>\n\n```python\nfrom temporalio.client import Client\n# ...\n# ...\n    client = await Client.connect(\"localhost:7233\")\n    handle = await client.start_workflow(\n        GreetingWorkflow.run,\n        id=\"your-greeting-workflow\",\n        task_queue=\"signal-tq\",\n    )\n    await handle.signal(GreetingWorkflow.submit_greeting, \"User 1\")\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-send-a-signal-from-a-workflow-in-python.md","id":"python/how-to-send-a-signal-from-a-workflow-in-python","title":"How to Send a Signal from a Workflow in Python","description":"Use `get_external_workflow_handle_for` to get a typed Workflow handle to an existing Workflow by its identifier.","label":"Signal","ssdi":[],"markdown_content":"\nUse [`get_external_workflow_handle_for`](https://python.temporal.io/temporalio.workflow.html#get_external_workflow_handle_for) to get a typed Workflow handle to an existing Workflow by its identifier.\nUse [`get_external_workflow_handle`](https://python.temporal.io/temporalio.workflow.html#get_external_workflow_handle) when you don't know the type of the other Workflow.\n\n:::note\n\nThe Workflow Type passed is only for type annotations and not for validation.\n\n:::\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/signal_your_workflow/signal_external_wf_dacx.py\">View source code</a>\n\n```python\n# ...\n@workflow.defn\nclass WorkflowB:\n    @workflow.run\n    async def run(self) -> None:\n        handle = workflow.get_external_workflow_handle_for(WorkflowA.run, \"workflow-a\")\n        await handle.signal(WorkflowA.your_signal, \"signal argument\")\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-send-a-signal-with-start-in-python.md","id":"python/how-to-send-a-signal-with-start-in-python","title":"How to send a Signal-With-Start in Python","description":"To Signal-With-Start use the `start_workflow()` method and pass the `start_signal` argument with the name of your Signal.","label":"Signal-With-Start","ssdi":[],"markdown_content":"\nTo send a Signal-With-Start in Python, use the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) method and pass the `start_signal` argument with the name of your Signal.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/signal_your_workflow/signal_with_start_dacx.py\">View source code</a>\n\n```python\nfrom temporalio.client import Client\n# ...\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    await client.start_workflow(\n        GreetingWorkflow.run,\n        id=\"your-signal-with-start-workflow\",\n        task_queue=\"signal-tq\",\n        start_signal=\"submit_greeting\",\n        start_signal_args=[\"User Signal with Start\"],\n    )\n```\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-a-cron-schedule-in-python.md","id":"python/how-to-set-a-cron-schedule-in-python","title":"How to set a Cron Schedule in Python","description":"Set a Cron Scheduler in Python","label":"Cron Schedule","tags":["python","how-to"],"ssdi":[],"markdown_content":"\nYou can set each Workflow to repeat on a schedule with the `cron_schedule` option from either the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods:\n\n```python\nawait client.start_workflow(\n    \"your_workflow_name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    cron_schedule=\"* * * * *\",\n)\n```\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-a-custom-logger-in-python.md","id":"python/how-to-set-a-custom-logger-in-python","title":"How to set a custom Logger in Python","description":"Use the built-in Logging facility for Python.","label":"Custom Logger","tags":["python","how-to"],"ssdi":[],"markdown_content":"\nUse the built-in [Logging facility for Python](https://docs.python.org/3/library/logging.html) to set a custom logger.\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-a-heartbeat-timeout-in-python.md","id":"python/how-to-set-a-heartbeat-timeout-in-python","title":"How to set a Heartbeat Timeout in Python","description":"Set a Heartbeat Timeout","label":"Set a Heartbeat Timeout","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\n[`heartbeat_timeout`](https://python.temporal.io/temporalio.worker.StartActivityInput.html#heartbeat_timeout) is a class variable for the [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) function used to set the maximum time between Activity Heartbeats.\n\n```python\nworkflow.start_activity(\n    activity=\"your-activity\",\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n```python\nworkflow.execute_activity(\n    activity=\"your-activity\",\n    name,\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-a-parent-close-policy-in-python.md","id":"python/how-to-set-a-parent-close-policy-in-python","title":"How to set a Parent Close Policy in Python","description":"Create an instance of the `ParentClosePolicy` class.","label":"Parent Close Policy","tags":["python","developer-guide","how-to"],"ssdi":[],"markdown_content":"\nSet the `parent_close_policy` parameter inside the [`start_child_workflow`](https://python.temporal.io/temporalio.workflow.html#start_child_workflow) function or the [`execute_child_workflow()`](https://python.temporal.io/temporalio.workflow.html#execute_child_workflow) function to specify the behavior of the Child Workflow when the Parent Workflow closes.\n\n```python\nasync def run(self, name: str) -> str:\n    return await workflow.execute_child_workflow(\n        ComposeGreeting.run,\n        ComposeGreetingInput(\"Hello\", name),\n        id=\"hello-child-workflow-workflow-child-id\",\n        parent_close_policy=TERMINATE,\n    )\n```\n\n:::note\n\n`execute_child_workflow()` is a shortcut function for `temporalio.workflow.start_child_workflow()` plus `handle.result()`.\n\n:::\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-a-schedule-to-close-timeout-in-python.md","id":"python/how-to-set-a-schedule-to-close-timeout-in-python","title":"How to set a schedule to close timeout in Python","description":"Set a schedule to close timeout","label":"Set a schedule to close timeout","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code example sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_close_timeout` to 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-a-schedule-to-start-timeout-in-python.md","id":"python/how-to-set-a-schedule-to-start-timeout-in-python","title":"How to set a schedule to start timeout in Python","description":"Set a schedule to start timeout","label":"Set a schedule to start timeout","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_start_timeout` to 1 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            name,\n            schedule_to_close_timeout=5000,\n            schedule_to_start_timeout=1000,\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-a-start-to-close-timeout-in-python.md","id":"python/how-to-set-a-start-to-close-timeout-in-python","title":"How to set a start to close timeout in Python","description":"Set a start to close timeout","label":"Set a start to close timeout","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\n```python\nstart_to_close_timeout = timedelta(seconds=5)\n```\n\nThe following code example executes an Activity with a `start_to_close_timeout` of 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-a-workflow-id-in-python.md","id":"python/how-to-set-a-workflow-id-in-python","title":"How to set a Workflow Id in Python","description":"Set a Workflow Id","label":"Set a Workflow Id","ssdi":[],"markdown_content":"\nTo set a Workflow Id in Python, specify the `id` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) methods.\n\nThe `id` argument should be a unique identifier for the Workflow Execution.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/run_workflow_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    result = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your name\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-a-workflow-task-queue-in-python.md","id":"python/how-to-set-a-workflow-task-queue-in-python","title":"How to set the Task Queue for Workflow Execution in Python","description":"Task Queue","label":"Set the Task Queue for Workflow Execution","ssdi":[],"markdown_content":"\nTo set a Task Queue in Python, specify the `task_queue` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) methods.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/run_workflow_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    result = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your name\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-activity-timeouts-in-python.md","id":"python/how-to-set-activity-timeouts-in-python","title":"How to set Activity Timeouts in Python","description":"Set Activity Timeouts","label":"Set Activity Timeouts","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments.\n\nAvailable timeouts are:\n\n- schedule_to_close_timeout\n- schedule_to_start_timeout\n- start_to_close_timeout\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            name,\n            schedule_to_close_timeout=timedelta(seconds=5),\n            # schedule_to_start_timeout=timedelta(seconds=5),\n            # start_to_close_timeout=timedelta(seconds=5),\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-an-activity-retry-policy-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-an-activity-retry-policy-in-python.md","id":"python/how-to-set-an-activity-retry-policy-in-python","title":"How to set an Activity Retry Policy in Python","description":"Create an instance of an Activity Retry Policy in Python.","label":"Retry Policy","tags":["python","how-to"],"ssdi":[],"markdown_content":"\nTo create an Activity Retry Policy in Python, set the [RetryPolicy](https://python.temporal.io/temporalio.common.RetryPolicy.html) class within the [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) or [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) function.\n\nThe following example sets the maximum interval to 2 seconds.\n\n```python\nworkflow.execute_activity(\n    your_activity,\n    name,\n    start_to_close_timeout=timedelta(seconds=10),\n    retry_policy=RetryPolicy(maximum_interval=timedelta(seconds=2)),\n)\n```\n","is_empty":false},{"file_name":"how-to-set-asynchronous-activity-completion-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-asynchronous-activity-completion-in-python.md","id":"python/how-to-set-asynchronous-activity-completion-in-python","title":"How to set an Asynchronous Activity Completion in Python","description":"To set the completion status of an asynchronous Activity, get the handle of the Activity and call the appropriate method of `get_async_activity_handle()`.","label":"Set an Asynchronous Activity Completion","tags":["python","how-to"],"ssdi":[],"markdown_content":"\nTo mark an Activity as completing asynchoronus, do the following inside the Activity.\n\n```python\n# Capture token for later completion\ncaptured_token = activity.info().task_token\nactivity.raise_complete_async()\n```\n\nTo update an Activity outside the Activity, use the [get_async_activity_handle()](https://python.temporal.io/temporalio.client.Client.html#get_async_activity_handle) method to get the handle of the Activity.\n\n```python\nhandle = my_client.get_async_activity_handle(task_token=captured_token)\n```\n\nThen, on that handle, you can call the results of the Activity, `heartbeat`, `complete`, `fail`, or `report_cancellation` method to update the Activity.\n\n```python\nawait handle.complete(\"Completion value.\")\n```\n","is_empty":false},{"file_name":"how-to-set-cluster-address-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-cluster-address-in-python.md","id":"python/how-to-set-cluster-address-in-python","title":"How to set a Cluster address in Python","description":"Set Cluster address","label":"Set Cluster address","tags":["python","how-to"],"ssdi":[],"markdown_content":"\nTo use a custom Cluster address, set the `target_url` parameter of the [`Client`](https://python.temporal.io/temporalio.client.Client.html) class.\n\n```python\nclient = await Client.connect(\n    \"foo.bar.tmprl.cloud\",\n    # ...\n)\n```\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-mtls-configuration-in-python.md","id":"python/how-to-set-mtls-configuration-in-python","title":"How to set mTLS configuration in Python","description":"Use the `tls_config` parameter from the `Client` class to connect a Client with mTLS.","label":"Set mTLS configuration","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nUse the `tls_config` parameter from the [`Client`](https://python.temporal.io/temporalio.client.Client.html) class to connect a Client with mTLS.\n\nThe following example connects your Client to your address. The `tls_config` options uses variables that reference the certificate and private key.\n\n```python\nawait Client.connect(\n    \"foo.bar.tmprl.cloud\",\n    namespace=\"foo.bar\",\n    tls_config=TLSConfig(\n        client_cert=client_cert,\n        client_private_key=client_private_key,\n    ),\n)\n```\n\n[The Hello World mTLS sample](https://github.com/temporalio/samples-python/blob/main/hello/hello_mtls.py) demonstrates sample code used to connect to a Temporal Cloud account with the `argparse` library.\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-the-namespace-for-a-temporal-client-in-python.md","id":"python/how-to-set-the-namespace-for-a-temporal-client-in-python","title":"How to set a Namespace for a Temporal Client in Python","description":"Set Namespace","label":"Set Namespace","tags":["python","how-to"],"ssdi":[],"markdown_content":"\nTo specify a Namespace, set the `namespace` parameter from the [`connect()`](https://python.temporal.io/temporalio.client.Client.html#connect) method.\n\n```python\nawait Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n```\n\n`Client` can be directly instantiated with a service of another, such as when you need to create another Client to use an additional Namespace.\n\nClients also provide a shallow copy of their config for use in making slightly different Clients backed by the same connection with [`config`](https://python.temporal.io/temporalio.client.Client.html#config). The following example creates a new Client with the same connection but a different Namespace.\n\n```python\nconfig = client.config()\nconfig[\"namespace\"] = \"your-other-namespace\"\nother_ns_client = Client(**config)\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-timers-in-python.md","id":"python/how-to-set-timers-in-python","title":"How to set Timers in Python","description":"To set a Timer in Python, set the `asyncio.sleep()` function.","label":"Python","tags":["timers","sleep"],"ssdi":[],"markdown_content":"\nTo set a Timer in Python, call the [`asyncio.sleep()`](https://docs.python.org/3/library/asyncio-task.html#sleeping) function and pass the duration in seconds you want to wait before continuing.\n\n```python\nawait asyncio.sleep(5)\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-retry-options-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-workflow-retry-options-in-python.md","id":"python/how-to-set-workflow-retry-options-in-python","title":"How to set Workflow Retry Options in Python","description":"Set the Retry Policy from either start_workflow() or execute_workflow().","label":"Workflow Retry Options","tags":["python","how-to"],"ssdi":[],"markdown_content":"\nSet the Retry Policy from either the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    start_signal=\"your-signal-name\",\n    retry_policy=RetryPolicy(maximum_interval=timedelta(seconds=2)),\n)\n```\n\n```python\nhandle = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    start_signal=\"your-signal-name\",\n    retry_policy=RetryPolicy(maximum_interval=timedelta(seconds=2)),\n)\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-set-workflow-timeouts-in-python.md","id":"python/how-to-set-workflow-timeouts-in-python","title":"How to set Workflow Timeouts in Python","description":"Set the timeout from either start_workflow() or execute_workflow().","label":"Workflow Timeouts","tags":["python","how-to"],"ssdi":[],"markdown_content":"\nSet the timeout from either the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods.\n\nAvailable timeouts are:\n\n- `execution_timeout`\n- `run_timeout`\n- `task_timeout`\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    start_signal=\"your-signal-name\",\n    # Set Workflow Timeout duration\n    execution_timeout=timedelta(seconds=2),\n    # run_timeout=timedelta(seconds=2),\n    # task_timeout=timedelta(seconds=2),\n)\n```\n\n```python\nhandle = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    start_signal=\"your-signal-name\",\n    # Set Workflow Timeout duration\n    execution_timeout=timedelta(seconds=2),\n    # run_timeout=timedelta(seconds=2),\n    # task_timeout=timedelta(seconds=2),\n)\n```\n","is_empty":false},{"file_name":"how-to-skip-time-skip-automatically-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-skip-time-skip-automatically-in-python.md","id":"python/how-to-skip-time-skip-automatically-in-python","title":"How to skip time automatically in Python","description":"Skip time from the test server automatically.","label":"Skip time automatically","tags":["python","how-to","time-skipping"],"ssdi":[],"markdown_content":"\nUse the [`start_time_skipping()`](https://python.temporal.io/temporalio.testing.WorkflowEnvironment.html#start_time_skipping) method to start a test server process and skip time automatically.\n\nUse the [`start_local()`](https://python.temporal.io/temporalio.testing.WorkflowEnvironment.html#start_local) method for a full local Temporal Server.\n\nUse the [`from_client()`](https://python.temporal.io/temporalio.testing.WorkflowEnvironment.html#from_client) method for an existing Temporal Server.\n","is_empty":false},{"file_name":"how-to-skip-time-skip-manually-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-skip-time-skip-manually-in-python.md","id":"python/how-to-skip-time-skip-manually-in-python","title":"How to skip time manually in Python","description":"To implement time skipping, use the `start_time_skipping()` static method.","label":"Skip time manually","tags":["python","how-to","time-skipping"],"ssdi":[],"markdown_content":"\nTo implement time skipping, use the [`start_time_skipping()`](https://python.temporal.io/temporalio.testing.WorkflowEnvironment.html#start_time_skipping) static method.\n\n```python\nfrom temporalio.testing import WorkflowEnvironment\n\nasync def test_manual_time_skipping():\n    async with await WorkflowEnvironment.start_time_skipping() as env:\n        # Your code here\n        # You can use the env.sleep(seconds) method to manually advance time\n        await env.sleep(3) # This will advance time by 3 seconds\n        # Your code here\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-spawn-a-child-workflow-execution-in-python.md","id":"python/how-to-spawn-a-child-workflow-execution-in-python","title":"How to spawn a Child Workflow Execution in Python","label":"Child Workflow Execution","tags":["developer-guide","python"],"ssdi":[],"markdown_content":"\nTo spawn a Child Workflow Execution in Python, use the [`execute_child_workflow()`](https://python.temporal.io/temporalio.workflow.html#execute_child_workflow) function. `execute_child_workflow()` starts the Child Workflow and waits for completion.\n\n```python\nawait workflow.execute_child_workflow(MyWorkflow.run, \"my child arg\", id=\"my-child-id\")\n```\n\nAlternatively, use the [`start_child_workflow()`](https://python.temporal.io/temporalio.workflow.html#start_child_workflow) function to start a Child Workflow and return its handle. This is useful if you want to do something after it has only started, or to get the workflow/run ID, or to be able to signal it while running. To wait for completion, simply `await` the handle. `execute_child_workflow()` is a helper function for `start_child_workflow()` + `await handle`.\n\n```python\nawait workflow.start_child_workflow(MyWorkflow.run, \"my child arg\", id=\"my-child-id\")\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-spawn-a-workflow-execution-in-python.md","id":"python/how-to-spawn-a-workflow-execution-in-python","title":"How to start a Workflow Execution in Python","description":"Start a Workflow Execution in the Python SDK.","label":"Start a Workflow Execution","ssdi":[],"markdown_content":"\nTo start a Workflow Execution in Python, use either the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods in the Client.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/run_workflow_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    result = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your name\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-spawn-an-activity-execution-in-python.md","id":"python/how-to-spawn-an-activity-execution-in-python","title":"How to spawn an Activity Execution in Python","description":"Use the `execute_activity()` operation from within your Workflow Definition.","label":"Activity Execution","ssdi":[],"markdown_content":"\nTo spawn an Activity Execution, use the [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) operation from within your Workflow Definition.\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`.\nIn most cases, use `execute_activity()` unless advanced task capabilities are needed.\n\nA single argument to the Activity is positional. Multiple arguments are not supported in the type-safe form of `start_activity()` or `execute_activity()` and must be supplied by the `args` keyword argument.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/your_workflows_dacx.py\">View source code</a>\n\n```python\nfrom temporalio import workflow\n# ...\n# ...\n@workflow.defn(name=\"YourWorkflow\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            YourParams(\"Hello\", name),\n            start_to_close_timeout=timedelta(seconds=10),\n        )\n```\n","is_empty":false},{"file_name":"how-to-start-a-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-start-a-workflow-execution-in-python.md","id":"python/how-to-start-a-workflow-execution-in-python","title":"How to start a Workflow Execution in Python","description":"Start a Workflow Execution in the Python SDK.","label":"Start a Workflow Execution","ssdi":[],"markdown_content":"\nTo start a Workflow Execution in Python, use either the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods in the Client.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/your_app/run_workflow_dacx.py\">View source code</a>\n\n```python\n# . . .\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    result = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your name\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n","is_empty":false},{"file_name":"how-to-trigger-a-scheduled-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-trigger-a-scheduled-workflow-execution-in-python.md","id":"python/how-to-trigger-a-scheduled-workflow-execution-in-python","title":"How to Trigger a Scheduled Workflow Execution in Python","description":"Trigger a Scheduled Workflow Execution in the Python SDK.","label":"Trigger a Scheduled Workflow Execution","ssdi":[],"markdown_content":"\nTo trigger a Scheduled Workflow Execution in Python, use the [trigger()](https://python.temporal.io/temporalio.client.ScheduleHandle.html#trigger) asynchronous method on the Schedule Handle.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/schedule_your_workflow/trigger_schedule_dacx.py\">View source code</a>\n\n```python\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    handle = client.get_schedule_handle(\n        \"workflow-schedule-id\",\n    )\n\n    await handle.trigger()\n```\n","is_empty":false},{"file_name":"how-to-update-scheduled-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-update-scheduled-workflow-execution-in-python.md","id":"python/how-to-update-scheduled-workflow-execution-in-python","title":"How to update a Scheduled Workflow Execution in Python","description":"Create a function that takes `ScheduleUpdateInput` and returns `ScheduleUpdate`.","label":"Update a Scheduled Workflow Execution","ssdi":[],"markdown_content":"\nCreate a function that takes `ScheduleUpdateInput` and returns `ScheduleUpdate`.\nTo update a Schedule, use a callback to build the update from the description.\nThe following example updates the Schedule to use a new argument.\n\n<a class=\"dacx-source-link\" href=\"https://github.com/temporalio/documentation-samples-python/blob/main/schedule_your_workflow/update_schedule_dacx.py\">View source code</a>\n\n```python\n# ...\n    async def update_schedule_simple(input: ScheduleUpdateInput) -> ScheduleUpdate:\n        schedule_action = input.description.schedule.action\n\n        if isinstance(schedule_action, ScheduleActionStartWorkflow):\n            schedule_action.args = [\"my new schedule arg\"]\n        return ScheduleUpdate(schedule=input.description.schedule)\n```\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python.md","id":"python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python","title":"How to upsert custom Search Attributes","description":"To upsert custom Search Attributes, use the upsert_search_attributes() method.","label":"Upsert custom Search Attributes","tags":["developer-guide","sdk","python"],"ssdi":[],"markdown_content":"\nTo upsert custom Search Attributes, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) method.\n\nThe keys are added to or replace the existing Search Attributes, similar to [`dict.update()`](https://docs.python.org/3/library/stdtypes.html#dict.update).\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": [\"new-value\"]})\n```\n","is_empty":false},{"file_name":"how-to-use-assert-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-use-assert-python.md","id":"python/how-to-use-assert-python","title":"How to assert a Workflow in Python","label":"Assert a Workflow","tags":["developer-guide","python"],"ssdi":[],"markdown_content":"\nFor information about assert statements in Python, see [`assert`](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement) in the Python Language Reference.\n","is_empty":false},{"file_name":"how-to-use-test-frameworks-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/how-to-use-test-frameworks-in-python.md","id":"python/how-to-use-test-frameworks-in-python","title":"How to use test frameworks in Python","description":"Use Pytest for testing frameworks in Python.","label":"Test frameworks","tags":["developer-guide","python","testing"],"ssdi":[],"markdown_content":"\nOne recommended framework for testing in Python for the Temporal SDK is [pytest](https://docs.pytest.org/), which can help with fixtures to stand up and tear down test environments, provide useful test discovery, and make it easy to write parameterized tests.\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/index.md","id":"python/index","title":"How to add the Temporal Python SDK","description":"Add the Temporal Python SDK to your project.","tags":["developer-guide","python"],"ssdi":[],"markdown_content":"\n[![Python 3.7+](https://img.shields.io/pypi/pyversions/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n[![PyPI](https://img.shields.io/pypi/v/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n\nTo install the latest version of the Temporal Python package, run the following command.\n\n```bash\npip install temporalio\n```\n","is_empty":false},{"file_name":"listen-to-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/listen-to-heartbeats.md","id":"python/listen-to-heartbeats","title":"Listen to Heartbeats","description":"When an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.","label":"Listen to Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.\n","is_empty":false},{"file_name":"logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/logging.md","id":"python/logging","title":"How to log from a Workflow","description":"Send logs and errors to a logging service, so that when things go wrong, you can see what happened.","label":"Logging","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nThe SDK core uses `WARN` for its default logging level.\n","is_empty":false},{"file_name":"manage-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/manage-namespaces.md","id":"python/manage-namespaces","title":"How to manage Namespaces","description":"You can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.","label":"Manage Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can manage your registered Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"metrics.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/metrics.md","id":"python/metrics","title":"How to emit metrics","description":"Each Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.","label":"Metrics","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.\nFor a complete list of metrics capable of being emitted, see the [SDK metrics reference](/references/sdk-metrics).\n\nMetrics can be scraped and stored in time series databases, such as:\n\n- [Prometheus](https://prometheus.io/docs/introduction/overview/)\n- [M3db](https://m3db.io/docs/)\n- [statsd](https://github.com/statsd/statsd)\n\nTemporal also provides a dashboard you can integrate with graphing services like [Grafana](https://grafana.com/docs/). For more information, see:\n\n- Temporal's implementation of the [Grafana dashboard](https://github.com/temporalio/dashboards)\n- [How to export metrics in Grafana](https://github.com/temporalio/helm-charts#exploring-metrics-via-grafana)\n","is_empty":false},{"file_name":"mock-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/mock-activities.md","id":"python/mock-activities","title":"How to mock Activities","description":"Mock an Activity by providing mock Activity implementations to the Worker.","label":"Mock Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMock the Activity invocation when unit testing your Workflows.\n\nWhen integration testing Workflows with a Worker, you can mock Activities by providing mock Activity implementations to the Worker.\n","is_empty":false},{"file_name":"mutable-side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/mutable-side-effects.md","id":"python/mutable-side-effects","title":"Mutable Side Effects","description":"Mutable Side Effects are a method of execution to produce non-deterministic code.","label":"Mutable Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMutable Side Effects execute the provided function once, and then it looks up the History of the value with the given Workflow ID.\n\n- If there is no existing value, then it records the function result as a value with the given Workflow Id on the History.\n- If there is an existing value, then it compares whether the existing value from the History has changed from the new function results, by calling the equals function.\n  - If the values are equal, then it returns the value without recording a new Marker Event\n  - If the values aren't equal, then it records the new value with the same ID on the History.\n\n:::note\n\nDuring a Workflow Execution, every new Side Effect call results in a new Marker recorded on the Workflow History; whereas Mutable Side Effects only records a new Marker on the Workflow History if the value for the Side Effect ID changes or is set the first time.\n\nDuring a Replay, Mutable Side Effects will not execute the function again. Instead, it returns the exact same value that was returned during the Workflow Execution.\n\n:::\n","is_empty":false},{"file_name":"namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/namespaces.md","id":"python/namespaces","title":"How to create and manage Namespaces","description":"You can create, update, deprecate or delete your Namespaces using either tctl or SDK APIs..","label":"Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can create, update, deprecate or delete your [Namespaces](/concepts/what-is-a-namespace) using either tctl or SDK APIs.\n\nUse Namespaces to isolate your Workflow Executions according to your needs.\nFor example, you can use Namespaces to match the development lifecycle by having separate `dev` and `prod` Namespaces.\nYou could also use them to ensure Workflow Executions between different teams never communicate - such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) to create and manage a Namespace from the UI, or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces from the command-line interface.\n\nOn self-hosted Temporal Cluster, you can register and manage your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"observability.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/observability.md","id":"python/observability","title":"How to use Temporal Observability features","description":"The observability section of the Temporal Developer's guide covers the many ways to view the current state of your Temporal Application—that is, ways to view which Workflow Executions are tracked by the Temporal Platform and the state of any specified Workflow Execution, either currently or at points of an execution","label":"Observability","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe observability section of the Temporal Developer's guide covers the many ways to view the current state of your [Temporal Application](/concepts/what-is-a-temporal-application)—that is, ways to view which [Workflow Executions](/workflows#workflow-execution) are tracked by the [Temporal Platform](/concepts/what-is-the-temporal-platform) and the state of any specified Workflow Execution, either currently or at points of an execution.\n\nThis section covers features related to viewing the state of the application, including:\n\n- [Metrics](#metrics)\n- [Tracing](#tracing)\n- [Logging](#logging)\n- [Visibility](#visibility)\n","is_empty":false},{"file_name":"parent-close-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/parent-close-policy.md","id":"python/parent-close-policy","title":"How to set a Parent Close Policy","description":"A Parent Close Policy determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).","label":"Parent Close Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Parent Close Policy](/concepts/what-is-a-parent-close-policy) determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).\n\nThe default Parent Close Policy option is set to terminate the Child Workflow Execution.\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/queries.md","id":"python/queries","title":"How to develop with Queries","description":"A Query is a synchronous operation that is used to get the state of a Workflow Execution.","label":"Queries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Query](/concepts/what-is-a-query) is a synchronous operation that is used to get the state of a Workflow Execution.\n","is_empty":false},{"file_name":"register-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/register-namespaces.md","id":"python/register-namespaces","title":"How to register Namespaces","description":"On Temporal Cloud, use the Temporal Cloud UI or tcld commands, and on self-hosted Temporal Cluster, use `tctl namespace register` or `RegisterNamespaceRequest` API to create Namespaces.","label":"Register Namespace","tags":["guide-context"],"ssdi":[],"markdown_content":"\nRegistering a Namespace creates a Namespace on the Temporal Cluster or Temporal Cloud.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to create Namespaces.\n\nOn self-hosted Temporal Cluster, you can register your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n","is_empty":false},{"file_name":"registering-types.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/registering-types.md","id":"python/registering-types","title":"How to register types","description":"How to register Workflow and Activity Types","label":"Register types","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it fails that Task.\nHowever, the failure of the Task does not cause the associated Workflow Execution to fail.\n","is_empty":false},{"file_name":"remove-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/remove-search-attributes.md","id":"python/remove-search-attributes","title":"How to remove a Search Attribute from a Workflow","description":"To remove a Search Attribute that was previously set, set it to an empty array.","label":"Remove Search Attribute","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array: `[]`.\n","is_empty":false},{"file_name":"replays.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/replays.md","id":"python/replays","title":"How to Replay a Workflow Execution","description":"Replay recreates the exact state of a Workflow Execution.","label":"Replay","tags":["guide-context"],"ssdi":[],"markdown_content":"\nReplay recreates the exact state of a Workflow Execution.\nYou can replay a Workflow from the beginning of its Event History.\n\nReplay succeeds only if the [Workflow Definition](/concepts/what-is-a-workflow-definition) is compatible with the provided history from a deterministic point of view.\n\nWhen you test changes to your Workflow Definitions, we recommend doing the following as part of your CI checks:\n\n1. Determine which Workflow Types or Task Queues (or both) will be targeted by the Worker code under test.\n2. Download the Event Histories of a representative set of recent open and closed Workflows from each Task Queue, either programmatically using the SDK client or via `tctl`.\n3. Run the Event Histories through replay.\n4. Fail CI if any error is encountered during replay.\n\nThe following are examples of fetching and replaying Event Histories:\n","is_empty":false},{"file_name":"required-activity-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/required-activity-timeout.md","id":"python/required-activity-timeout","title":"How to set the required Activity Timeouts","description":"The only required value that needs to be set is either a Schedule-To-Close Timeout or a Start-To-Close Timeout","label":"Required timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nActivity Execution semantics rely on several parameters.\nThe only required value that needs to be set is either a [Schedule-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) or a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout).\nThese values are set in the Activity Options.\n","is_empty":false},{"file_name":"run-a-dev-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/run-a-dev-worker.md","id":"python/run-a-dev-worker","title":"How to run Worker Processes","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run a dev Worker","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe [Worker Process](/concepts/what-is-a-worker-process) is where Workflow Functions and Activity Functions are executed.\n\n- Each [Worker Entity](/concepts/what-is-a-worker-entity) in the Worker Process must register the exact Workflow Types and Activity Types it may execute.\n- Each Worker Entity must also associate itself with exactly one [Task Queue](/concepts/what-is-a-task-queue).\n- Each Worker Entity polling the same Task Queue must be registered with the same Workflow Types and Activity Types.\n\nA [Worker Entity](/concepts/what-is-a-worker-entity) is the component within a Worker Process that listens to a specific Task Queue.\n\nAlthough multiple Worker Entities can be in a single Worker Process, a single Worker Entity Worker Process may be perfectly sufficient.\nFor more information, see the [Worker tuning guide](/dev-guide/worker-performance).\n\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it can make progress for either a Workflow Execution or an Activity Execution.\n","is_empty":false},{"file_name":"run-a-temporal-cloud-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/run-a-temporal-cloud-worker.md","id":"python/run-a-temporal-cloud-worker","title":"How to run a Temporal Cloud Worker","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run a Temporal Cloud Worker","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo run a Worker that uses [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"run-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/run-an-activity.md","id":"python/run-an-activity","title":"Run an Activity","description":"If an Activity references its context, you need to mock that context when testing in isolation.","label":"Run an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity references its context, you need to mock that context when testing in isolation.\n","is_empty":false},{"file_name":"schedule-backfill.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-backfill.md","id":"python/schedule-backfill","title":"How to Backfill a Scheduled Workflow","description":null,"label":"Backfill","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe backfill action executes Actions ahead of their specified time range. This command is useful when you need to execute a missed or delayed Action, or when you want to test the Workflow before its scheduled time.\n","is_empty":false},{"file_name":"schedule-create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-create.md","id":"python/schedule-create","title":"How to Create a Scheduled Workflow","description":null,"label":"Create","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe create action enables you to create a new Schedule. When you create a new Schedule, a unique Schedule ID is generated, which you can use to reference the Schedule in other Schedule commands.\n","is_empty":false},{"file_name":"schedule-delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-delete.md","id":"python/schedule-delete","title":"How to Delete a Scheduled Workflow","description":null,"label":"Delete","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe delete action enables you to delete a Schedule. When you delete a Schedule, it does not affect any Workflows that were started by the Schedule.\n","is_empty":false},{"file_name":"schedule-describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-describe.md","id":"python/schedule-describe","title":"How to Describe a Scheduled Workflow","description":null,"label":"Describe","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe describe action shows the current Schedule configuration, including information about past, current, and future Workflow Runs. This command is helpful when you want to get a detailed view of the Schedule and its associated Workflow Runs.\n","is_empty":false},{"file_name":"schedule-list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-list.md","id":"python/schedule-list","title":"How to List a Scheduled Workflow","description":null,"label":"List","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe list action lists all the available Schedules. This command is useful when you want to view a list of all the Schedules and their respective Schedule IDs.\n","is_empty":false},{"file_name":"schedule-pause.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-pause.md","id":"python/schedule-pause","title":"How to Pause a Scheduled Workflow","description":null,"label":"Pause","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe pause action enables you to pause and unpause a Schedule. When you pause a Schedule, all the future Workflow Runs associated with the Schedule are temporarily stopped. This command is useful when you want to temporarily halt a Workflow due to maintenance or any other reason.\n","is_empty":false},{"file_name":"schedule-to-close copy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-to-close copy.md","id":"python/schedule-to-close","title":"How to set a Schedule-To-Close Timeout","description":"Use the Schedule-To-Close Timeout to limit the maximum duration of an Activity Execution.","label":"Schedule-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"schedule-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-to-close.md","id":"python/schedule-to-close","title":"How to set a Schedule-To-Close Timeout","description":"Use the Schedule-To-Close Timeout to limit the maximum duration of an Activity Execution.","label":"Schedule-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"schedule-to-start copy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-to-start copy.md","id":"python/schedule-to-start","title":"How to set a Schedule-To-Start Timeout","description":"Use the Schedule-To-Start Timeout to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","label":"Schedule-To-Start Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.\n","is_empty":false},{"file_name":"schedule-to-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-to-start.md","id":"python/schedule-to-start","title":"How to set a Schedule-To-Start Timeout","description":"Use the Schedule-To-Start Timeout to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","label":"Schedule-To-Start Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.\n","is_empty":false},{"file_name":"schedule-trigger.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-trigger.md","id":"python/schedule-trigger","title":"How to Trigger a Scheduled Workflow","description":null,"label":"Trigger","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe trigger action triggers an immediate action with a given Schedule. By default, this action is subject to the Overlap Policy of the Schedule. This command is helpful when you want to execute a Workflow outside of its scheduled time.\n","is_empty":false},{"file_name":"schedule-update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedule-update.md","id":"python/schedule-update","title":"How to Update a Scheduled Workflow","description":null,"label":"Update","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe update action enables you to update an existing Schedule. This command is useful when you need to modify the Schedule's configuration, such as changing the start time, end time, or interval.\n","is_empty":false},{"file_name":"schedules.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/schedules.md","id":"python/schedules","title":"How to Schedule a Workflow","description":"Schedule a Workflow.","label":"Schedule a Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nScheduling Workflows is a crucial aspect of any automation process, especially when dealing with time-sensitive tasks. By scheduling a Workflow, you can automate repetitive tasks, reduce the need for manual intervention, and ensure timely execution of your business processes\n\nUse any of the following action to help Schedule a Workflow Execution and take control over your automation process.\n","is_empty":false},{"file_name":"search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/search-attributes.md","id":"python/search-attributes","title":"How to use Search Attributes","description":"Search Attributes enable complex List Filters to find the exact of Workflow Executions you are looking for.","label":"Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe typical method of retrieving a Workflow Execution is by its Workflow Id.\n\nHowever, sometimes you'll want to retrieve one or more Workflow Executions based on another property. For example, imagine you want to get all Workflow Executions of a certain type that have failed within a time range, so that you can start new ones with the same arguments.\n\nYou can do this with [Search Attributes](/concepts/what-is-a-search-attribute).\n\n- [Default Search Attributes](/concepts/what-is-a-search-attribute#default-search-attributes) like `WorkflowType`, `StartTime` and `ExecutionStatus` are automatically added to Workflow Executions.\n- _Custom Search Attributes_ can contain their own domain-specific data (like `customerId` or `numItems`).\n  - A few [generic Custom Search Attributes](/concepts/what-is-a-search-attribute#custom-search-attributes) like `CustomKeywordField` and `CustomIntField` are created by default in Temporal's [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose).\n\nThe steps to using custom Search Attributes are:\n\n- Create a new Search Attribute in your Cluster in the CLI or Web UI.\n  - For example: `temporal operator search-attribute create --name CustomKeywordField --type Text`\n    - Replace `CustomKeywordField` with the name of your Search Attribute.\n    - Replace `Text` with a type value associated with your Search Attribute: `Text` | `Keyword` | `Int` | `Double` | `Bool` | `Datetime` | `KeywordList`\n- Set the value of the Search Attribute for a Workflow Execution:\n  - On the Client by including it as an option when starting the Execution.\n  - In the Workflow by calling `UpsertSearchAttributes`.\n- Read the value of the Search Attribute:\n  - On the Client by calling `DescribeWorkflow`.\n  - In the Workflow by looking at `WorkflowInfo`.\n- Query Workflow Executions by the Search Attribute using a [List Filter](/concepts/what-is-a-list-filter):\n  - [In the Temporal CLI](/cli/operator#list-2)\n  - In code by calling `ListWorkflowExecutions`.\n\nHere is how to query Workflow Executions:\n","is_empty":false},{"file_name":"send-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/send-query.md","id":"python/send-query","title":"How to send a Query","description":"Queries are sent from a Temporal Client.","label":"Send Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are sent from a Temporal Client.\n","is_empty":false},{"file_name":"send-signal-from-client.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/send-signal-from-client.md","id":"python/send-signal-from-client","title":"How to send a Signal from a Temporal Client","description":"When a Signal is sent successfully from the Temporal Client, the WorkflowExecutionSignaled Event appears in the Event History of the Workflow that receives the Signal.","label":"Send Signal from Client","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen a Signal is sent successfully from the Temporal Client, the [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Event History of the Workflow that receives the Signal.\n","is_empty":false},{"file_name":"send-signal-from-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/send-signal-from-workflow.md","id":"python/send-signal-from-workflow","title":"How to send a Signal from a Workflow","description":"A Workflow can send a Signal to another Workflow, in which case it's called an External Signal","label":"Send Signal from Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.\n\nWhen an External Signal is sent:\n\n- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.\n- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.\n","is_empty":false},{"file_name":"set-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/set-custom-search-attributes.md","id":"python/set-custom-search-attributes","title":"How to set custom Search Attributes","description":"After you've created custom Search Attributes in your Cluster (using `tctl` or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.","label":"Custom Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAfter you've created custom Search Attributes in your Cluster (using `tctl search-attribute create`or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.\n","is_empty":false},{"file_name":"set-task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/set-task-queue.md","id":"python/set-task-queue","title":"How to set a Workflow's Task Queue","description":"In most SDKs, the only Workflow Option that must be set is the name of the Task Queue.","label":"Set Task Queue","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn most SDKs, the only Workflow Option that must be set is the name of the [Task Queue](/concepts/what-is-a-task-queue).\n\nFor any code to execute, a Worker Process must be running that contains a Worker Entity that is polling the same Task Queue name.\n","is_empty":false},{"file_name":"set-workflow-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/set-workflow-id.md","id":"python/set-workflow-id","title":"How to set a Workflow Id","description":"Although it is not required, we recommend providing your own Workflow Id that maps to a business process or business entity identifier, such as an order identifier or customer identifier.","label":"Workflow Id","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAlthough it is not required, we recommend providing your own [Workflow Id](/concepts/what-is-a-workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.\n","is_empty":false},{"file_name":"side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/side-effects.md","id":"python/side-effects","title":"Side Effects","description":"A Side Effect is used to produce non-deterministic code, such as generating a UUID or a random number.","label":"Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSide Effects are used to execute non-deterministic code, such as generating a UUID or a random number, without compromising deterministic in the Workflow. This is done by storing the non-deterministic results of the Side Effect into the Workflow [Event History](/workflows/#event-history).\n\nA Side Effect does not re-execute during a Replay. Instead, it returns the recorded result from the Workflow Execution Event History.\n\nSide Effects should not fail. An exception that is thrown from the Side Effect causes failure and retry of the current Workflow Task.\n\nAn Activity or a Local Activity may also be used instead of a Side effect, as its result is also persisted in Workflow Execution History.\n\n:::note\n\nYou shouldn’t modify the Workflow state inside a Side Effect function, because it is not reexecuted during Replay. Side Effect function should be used to return a value.\n\n:::\n","is_empty":false},{"file_name":"signal-with-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/signal-with-start.md","id":"python/signal-with-start","title":"How to Signal-With-Start","description":"Signal-With-Start is used from the Client","label":"Signal-With-Start","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSignal-With-Start is used from the Client.\nIt takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.\n\nIf there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/signals.md","id":"python/signals","title":"How to develop with Signals","description":"A Signal is a message sent to a running Workflow Execution","label":"Signals","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Signal](/concepts/what-is-a-signal) is a message sent to a running Workflow Execution.\n\nSignals are defined in your code and handled in your Workflow Definition.\nSignals can be sent to Workflow Executions from a Temporal Client or from another Workflow Execution.\n","is_empty":false},{"file_name":"skip-time-set-up.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/skip-time-set-up.md","id":"python/skip-time-set-up","title":"Set up time skipping","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Setting up","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to set up the time-skipping test framework in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/skip-time-skip-activities.md","id":"python/skip-time-skip-activities","title":"Skip time in Activities","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time in Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time in Activities in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-automatically.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/skip-time-skip-automatically.md","id":"python/skip-time-skip-automatically","title":"Skip time automatically","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Automatic method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can skip time automatically in the SDK of your choice.\nStart a test server process that skips time as needed.\nFor example, in the time-skipping mode, Timers, which include sleeps and conditional timeouts, are fast-forwarded except when Activities are running.\n","is_empty":false},{"file_name":"skip-time-skip-manually.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/skip-time-skip-manually.md","id":"python/skip-time-skip-manually","title":"Skip time manually","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Manual method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time manually in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/skip-time.md","id":"python/skip-time","title":"How to skip time","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSome long-running Workflows can persist for months or even years.\nImplementing the test framework allows your Workflow code to skip time and complete your tests in seconds rather than the Workflow's specified amount.\n\nFor example, if you have a Workflow sleep for a day, or have an Activity failure with a long retry interval, you don't need to wait the entire length of the sleep period to test whether the sleep function works.\nInstead, test the logic that happens after the sleep by skipping forward in time and complete your tests in a timely manner.\n\n:::note\n\nSkipping time is not relevant to unit testing Workflow code, because in that case you’re mocking functions that take time, like sleep and Activity calls.\n\n:::\n\nThe test framework included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.\nTime is a global property of an instance of `TestWorkflowEnvironment`: skipping time (either automatically or manually) applies to all currently running tests.\nIf you need different time behaviors for different tests, run your tests in a series or with separate instances of the test server.\nFor example, you could run all tests with automatic time skipping in parallel, and then all tests with manual time skipping in series, and then all tests without time skipping in parallel.\n","is_empty":false},{"file_name":"spawning-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/spawning-activities.md","id":"python/spawning-activities","title":"How to start an Activity Execution","description":"Calls to spawn Activity Executions are written within a Workflow Definition.","label":"Activity Execution","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCalls to spawn [Activity Executions](/concepts/what-is-an-activity-execution) are written within a [Workflow Definition](/concepts/what-is-a-workflow-definition).\nThe call to spawn an Activity Execution generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nThis results in the set of three [Activity Task](/concepts/what-is-an-activity-task) related Events ([ActivityTaskScheduled](/references/events/#activitytaskscheduled), [ActivityTaskStarted](/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.\n\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the Execution history.\nThe entire Execution history is transferred from the Temporal service to Workflow Workers when a Workflow state needs to recover.\nA large Execution history can thus adversely impact the performance of your Workflow.\n\nTherefore, be mindful of the amount of data you transfer through Activity invocation parameters or Return Values.\nOtherwise, no additional limitations exist on Activity implementations.\n","is_empty":false},{"file_name":"spawning-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/spawning-workflows.md","id":"python/spawning-workflows","title":"How to start a Workflow Execution","description":"Workflow Execution semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.","label":"Start Workflow Execution","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Workflow Execution](/workflows#workflow-execution) semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.\n\nIn the examples below, all Workflow Executions are started using a Temporal Client.\nTo spawn Workflow Executions from within another Workflow Execution, use either the [Child Workflow](#child-workflows) or External Workflow APIs.\n\nSee the [Customize Workflow Type](#customize-workflow-type) section to see how to customize the name of the Workflow Type.\n\nA request to spawn a Workflow Execution causes the Temporal Cluster to create the first Event ([WorkflowExecutionStarted](/references/events/#workflowexecutionstarted)) in the Workflow Execution Event History.\nThe Temporal Cluster then creates the first Workflow Task, resulting in the first [WorkflowTaskScheduled](/references/events/#workflowtaskscheduled) Event.\n","is_empty":false},{"file_name":"start-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/start-to-close.md","id":"python/start-to-close","title":"How to set a Start-To-Close Timeout","description":"Use the Start-To-Close Timeout to limit the maximum duration of a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) to limit the maximum duration of a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n","is_empty":false},{"file_name":"test-functions-assert-in-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/test-functions-assert-in-workflow.md","id":"python/test-functions-assert-in-workflow","title":"Assert in Workflow","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Assert in Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe `assert` statement is a convenient way to insert debugging assertions into the Workflow context.\n\nThe `assert` method is available in Python and TypeScript.\n","is_empty":false},{"file_name":"test-functions-in-workflow-context.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/test-functions-in-workflow-context.md","id":"python/test-functions-in-workflow-context","title":"Test functions in Workflow context","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Workflow context","tags":["guide-context"],"ssdi":[],"markdown_content":"\nFor a function or method to run in the Workflow context (where it’s possible to get the current Workflow info, or running inside the sandbox in the case of TypeScript or Python), it needs to be run by the Worker as if it were a Workflow.\n\n:::note\n\nThis section is applicable in Python and TypeScript.\nIn Python, we allow testing of Workflows only and not generic Workflow-related code.\n\n:::\n","is_empty":false},{"file_name":"testing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/testing-activities.md","id":"python/testing-activities","title":"Testing Activities","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn Activity can be tested with a mock Activity environment, which provides a way to mock the Activity context, listen to Heartbeats, and cancel the Activity.\nThis behavior allows you to test the Activity in isolation by calling it directly, without needing to create a Worker to run the Activity.\n","is_empty":false},{"file_name":"testing-frameworks.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/testing-frameworks.md","id":"python/testing-frameworks","title":"Test frameworks","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test frameworks","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSome SDKs have support or examples for popular test frameworks, runners, or libraries.\n","is_empty":false},{"file_name":"testing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/testing-workflows.md","id":"python/testing-workflows","title":"Testing Workflows","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"","is_empty":false},{"file_name":"testing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/testing.md","id":"python/testing","title":"Testing","description":"The Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.","label":"Testing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.\n\nIn the context of Temporal, you can create these types of automated tests:\n\n- **End-to-end**: Running a Temporal Server and Worker with all its Workflows and Activities; starting and interacting with Workflows from a Client.\n- **Integration**: Anything between end-to-end and unit testing.\n  - Running Activities with mocked Context and other SDK imports (and usually network requests).\n  - Running Workers with mock Activities, and using a Client to start Workflows.\n  - Running Workflows with mocked SDK imports.\n- **Unit**: Running a piece of Workflow or Activity code (a function or method) and mocking any code it calls.\n\nWe generally recommend writing the majority of your tests as integration tests.\n\nBecause the test server supports skipping time, use the test server for both end-to-end and integration tests with Workers.\n","is_empty":false},{"file_name":"timers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/timers.md","id":"python/timers","title":"What is a Timer?","description":"A Timer lets a Workflow sleep for a fixed time period.","label":"Timers","tags":["guide-context","timers","sleep"],"ssdi":[],"markdown_content":"\nA Workflow can set a durable timer for a fixed time period.\nIn some SDKs, the function is called `sleep()`, and in others, it's called `timer()`.\n\nA Workflow can sleep for months.\nTimers are persisted, so even if your Worker or Temporal Cluster is down when the time period completes, as soon as your Worker and Cluster are back up, the `sleep()` call will resolve and your code will continue executing.\n\nSleeping is a resource-light operation: it does not tie up the process, and you can run millions of Timers off a single Worker.\n","is_empty":false},{"file_name":"tracing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/tracing.md","id":"python/tracing","title":"How to setup Tracing","description":"Tracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.","label":"Tracing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.\n\nTemporal Web's tracing capabilities mainly track Activity Execution within a Temporal context. If you need custom tracing specific for your use case, you should make use of context propagation to add tracing logic accordingly.\n\nFor information about Workflow tracing, see [Tracing Temporal Workflows with DataDog](https://spiralscout.com/blog/tracing-temporal-workflow-with-datadog).\n\nFor information about how to configure exporters and instrument your code, see [Tracing Temporal Services with OTEL](https://github.com/temporalio/temporal/blob/master/develop/docs/tracing.md).\n","is_empty":false},{"file_name":"upsert-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/upsert-custom-search-attributes.md","id":"python/upsert-custom-search-attributes","title":"How to upsert Search Attributes","description":"You can upsert Search Attributes to add or update Search Attributes from within Workflow code.","label":"Upsert Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can upsert Search Attributes to add or update Search Attributes from within Workflow code.\n","is_empty":false},{"file_name":"visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/visibility.md","id":"python/visibility","title":"How to use Visibility APIs","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n","is_empty":false},{"file_name":"workflow-execution-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-execution-timeout.md","id":"python/workflow-execution-timeout","title":"How to set a Workflow Execution Timeout","description":"Use the Workflow Execution Timeout to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n","is_empty":false},{"file_name":"workflow-logic-requirements.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-logic-requirements.md","id":"python/workflow-logic-requirements","title":"How develop Workflow logic","description":"Workflow logic is constrained by deterministic execution requirements.","label":"Workflow logic requirements","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow logic is constrained by [deterministic execution requirements](/concepts/what-is-a-workflow-definition#deterministic-constraints).\nTherefore, each language is limited to the use of certain idiomatic techniques.\nHowever, each Temporal SDK provides a set of APIs that can be used inside your Workflow to interact with external (to the Workflow) application code.\n","is_empty":false},{"file_name":"workflow-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-parameters.md","id":"python/workflow-parameters","title":"How to define Workflow parameters","description":"Temporal Workflows may have any number of custom parameters.","label":"Workflow parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal Workflows may have any number of custom parameters.\nHowever, we strongly recommend that objects are used as parameters, so that the object's individual fields may be altered without breaking the signature of the Workflow.\nAll Workflow Definition parameters must be serializable.\n","is_empty":false},{"file_name":"workflow-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-retries.md","id":"python/workflow-retries","title":"Workflow retries","description":"A Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.","label":"Workflow retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-retry-policy.md","id":"python/workflow-retry-policy","title":"How to set a Workflow Retry Policy","description":"Use a Retry Policy to retry a Workflow Execution in the event of a failure.","label":"Workflow Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-return-values.md","id":"python/workflow-return-values","title":"How to define Workflow return parameters","description":"Workflow return values must also be serializable.","label":"Workflow return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow return values must also be serializable.\nReturning results, returning errors, or throwing exceptions is fairly idiomatic in each language that is supported.\nHowever, Temporal APIs that must be used to get the result of a Workflow Execution will only ever receive one of either the result or the error.\n","is_empty":false},{"file_name":"workflow-run-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-run-timeout.md","id":"python/workflow-run-timeout","title":"How to set a Workflow Run Timeout","description":"Use the Workflow Run Timeout to restrict the maximum amount of time that a single Workflow Run can last.","label":"Workflow Run Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) to restrict the maximum amount of time that a single [Workflow Run](/concepts/what-is-a-workflow-execution#workflow-execution-chain) can last.\n","is_empty":false},{"file_name":"workflow-task-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-task-timeout.md","id":"python/workflow-task-timeout","title":"How to set a Workflow Task Timeout","description":"Use the Workflow Task Timeout to restrict the maximum amount of time that a Worker can execute a Workflow Task.","label":"Workflow Task Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout) to restrict the maximum amount of time that a Worker can execute a [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"workflow-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-timeouts-and-retries.md","id":"python/workflow-timeouts-and-retries","title":"Workflow timeouts and retries","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts & retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"workflow-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-timeouts.md","id":"python/workflow-timeouts","title":"Workflow timeouts","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\n\nWorkflow timeouts are set when [starting the Workflow Execution](/python/workflow-timeouts).\n\n- **[Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout)** - restricts the maximum amount of time that a single Workflow Execution can be executed.\n- **[Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout)**: restricts the maximum amount of time that a single Workflow Run can last.\n- **[Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout)**: restricts the maximum amount of time that a Worker can execute a Workflow Task.\n","is_empty":false},{"file_name":"workflow-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/python/workflow-type.md","id":"python/workflow-type","title":"How to customize your Workflow Type","description":"You can set a custom name for your Workflow Type.","label":"Workflow Type","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows have a Type that are referred to as the Workflow name.\n\nThe following examples demonstrate how to set a custom name for your Workflow Type.\n","is_empty":false},{"file_name":"activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activities.md","id":"php/activities","title":"Activities in PHP","label":"Activities","ssdi":[],"markdown_content":"\n:::info Try the Developer's guide\n\nThe majority of this information has moved into the [Developer's guide](/dev-guide/?lang=php).\n\nHowever, if you can't find what you are looking for there, we recommend checking this doc set as well.\n\n:::\n\n## Activity interface\n\nAn Activity is a manifestation of a particular Task in the business logic.\n\nActivities are defined as methods of a plain PHP interface annotated with `#[ActivityInterface]` (you can use PHP 8 attributes\nin PHP7 as well).\n\nEach method defines a single Activity type.\nA single Workflow can use more than one Activity interface and call more that one Activity method from the same interface.\n\nThe only requirement is that Activity method arguments and return values are serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\n\nFollowing is an example of an interface that defines four Activities:\n\n```php\n#[ActivityInterface]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName): void;\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName): void;\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName): void;\n}\n```\n\nWe recommend to use a single value type argument for Activity methods.\nIn this way, adding new arguments as fields to the value type is a backwards-compatible change.\n\nAn optional `#[ActivityMethod]` annotation can be used to override a default Activity name.\n\nOption `prefix` of `ActivityInterface` annotation will allow you to define your own prefix for all activity names (by\ndefault it's empty).\n\n```php\n#[ActivityInterface(\"file_activities.\")]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName);\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName);\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName);\n}\n```\n\n## Implementing Activities\n\nActivity implementation is an implementation of an Activity interface.\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to Workflow workers when a Workflow state needs to recover.\nA large execution history can thus adversely impact the performance of your Workflow.\nTherefore, be mindful of the amount of data you transfer via Activity invocation parameters or return values.\n\nOtherwise, no additional limitations exist on Activity implementations.\n\n```php\nclass FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n    private S3Client $s3Client;\n\n    private string $localDirectory;\n\n    public function __construct(S3Client $s3Client, string $localDirectory) {\n        $this->s3Client = $s3Client;\n        $this->localDirectory = $localDirectory;\n    }\n\n    public function upload(string $bucketName, string $localName, string $targetName): void\n    {\n        $this->s3Client->putObject(\n            $bucketName,\n            $targetName,\n            fopen($this->localDirectory . $localName, 'rb+')\n        );\n    }\n\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->s3Client->downloadObject(\n            $bucketName,\n            $remoteName,\n            fopen($this->localDirectory .$localName, 'wb+')\n        );\n    }\n\n    public function processFile(string $localName): string\n    {\n        // Implementation omitted for brevity.\n        return compressFile($this->localDirectory . $localName);\n    }\n\n    public function deleteLocalFile(string $fileName): void\n    {\n        unlink($this->localDirectory . $fileName);\n    }\n}\n```\n\n### Accessing Activity Info\n\nThe [Activity](https://github.com/temporalio/sdk-php/blob/master/src/Activity.php) class provides static getters to access information about the Workflow that invoked it.\nNote that this information is stored in a thread local variable.\nTherefore, calls to Activity accessors succeed only in the process that invoked the Activity function.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->logger->info(\"namespace=\" +  Activity.getNamespace());\n\n        $info = Activity::getInfo();\n\n        $this->logger->info(\"workflowId=\" + $info->workflowExecution->getID());\n        $this->logger->info(\"runId=\" + $info->workflowExecution->getRunID());\n        $this->logger->info(\"activityId=\" + $info->id);\n        $this->logger->info(\"activityDeadline=\" + $info->deadline);\n\n        // ...\n    }\n\n    // ...\n}\n```\n\n### Activity Heart Beating\n\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n\n## Calling Activities\n\n`Workflow::newActivityStub` returns a client-side stub an implements an Activity interface.\nThe client-side stub can be used within the Workflow code.\nIt takes the Activity's type and `ActivityOptions` as arguments.\n\nCalling (via `yield`) a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if Activity Execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\n```php\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    private $greetingActivity;\n\n    public function __construct()\n    {\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n        );\n    }\n\n    public function greet(string $name): \\Generator\n    {\n        // This is a blocking call that returns only after the activity has completed.\n        return yield $this->greetingActivity->composeGreeting('Hello', $name);\n    }\n}\n```\n\nIf different Activities need different options, like timeouts or a task queue, multiple client-side stubs can be created with different options.\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 minutes'))\n);\n```\n\n## Calling Activities Asynchronously\n\nSometimes Workflows need to perform certain operations in parallel.\n\nInvoking activity stub without the use of `yield` will return the activity result promise which can be resolved at later moment.\nCalling `yield` on promise blocks until a result is available.\n\n> Activity promise also exposes `then` method to construct promise chains.\n> Read more about Promises [here](https://github.com/reactphp/promise).\n\nAlternatively, you can explicitly wrap your code (including `yield` constucts) using `Workflow::async`, which executes nested code in parallel with main Workflow code.\nCall `yield` on the Promise returned by `Workflow::async` to merge the execution result back to the primary Workflow method.\n\n```php\npublic function greet(string $name): \\Generator\n{\n    // Workflow::async runs it's activities and child workflows in a separate coroutine. Use keyword yield to merge\n    // it back to parent process.\n\n    $first = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Bye', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    $second = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hola', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Chao', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    // blocks until $first and $second complete\n    return (yield $first) . \"\\n\" . (yield $second);\n}\n```\n\n## Async completion\n\nThere are certain scenarios when moving on from an Activity upon completion of its function is not possible or desirable.\nFor example, you might have an application that requires user input to complete the Activity.\nYou could implement the Activity with a polling mechanism, but a simpler and less resource-intensive implementation is to asynchronously complete a Temporal Activity.\n\nThere are two parts to implementing an asynchronously completed Activity:\n\n1. The Activity provides the information necessary for completion from an external system and notifies the Temporal service that it is waiting for that outside callback.\n2. The external service calls the Temporal service to complete the Activity.\n\nThe following example demonstrates the first part:\n\n<!--SNIPSTART samples-php-async-activity-completion-activity-class-->\n\n[app/src/AsyncActivityCompletion/GreetingActivity.php](https://github.com/temporalio/samples-php/blob/master/app/src/AsyncActivityCompletion/GreetingActivity.php)\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    private LoggerInterface $logger;\n\n    public function __construct()\n    {\n        $this->logger = new Logger();\n    }\n    /**\n     * Demonstrates how to implement an Activity asynchronously.\n     * When {@link Activity::doNotCompleteOnReturn()} is called,\n     * the Activity implementation function that returns doesn't complete the Activity.\n     */\n    public function composeGreeting(string $greeting, string $name): string\n    {\n        // In real life this request can be executed anywhere. By a separate service for example.\n        $this->logger->info(sprintf('GreetingActivity token: %s', base64_encode(Activity::getInfo()->taskToken)));\n        // Send the taskToken to the external service that will complete the Activity.\n        // Return from the Activity a function indicating that Temporal should wait\n        // for an async completion message.\n        Activity::doNotCompleteOnReturn();\n        // When doNotCompleteOnReturn() is invoked the return value is ignored.\n        return 'ignored';\n    }\n}\n```\n\n<!--SNIPEND-->\n\nThe following code demonstrates how to complete the Activity successfully using `WorkflowClient`:\n\n<!--SNIPSTART samples-php-async-activity-completion-completebytoken-->\n\n[app/src/AsyncActivityCompletion/CompleteCommand.php](https://github.com/temporalio/samples-php/blob/master/app/src/AsyncActivityCompletion/CompleteCommand.php)\n\n```php\n$client = $this->workflowClient->newActivityCompletionClient();\n// Complete the Activity.\n$client->completeByToken(\n    base64_decode($input->getArgument('token')),\n    $input->getArgument('message')\n);\n```\n\n<!--SNIPEND-->\n\nTo fail the Activity, you would do the following:\n\n```php\n// Fail the Activity.\n$activityClient->completeExceptionallyByToken($taskToken, new \\Error(\"activity failed\"));\n```\n\n## Local Activity\n\nTo create a Local Activity you should use `#[LocalActivityInterface]` (instead of `#[ActivityInterface]`):\n\n```php\nuse Temporal\\Activity\\LocalActivityInterface;\n\n#[LocalActivityInterface]\ninterface GreetingActivityInterface\n{\n    #[ActivityMethod(\"greet\")]\n    public function greet(): string;\n}\n```\n\nLocal Activity requires `LocalActivityOptions`:\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    LocalActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n```\n\nLocal Activities have a limited set of options, including: `ScheduleToCloseTimeout`, `StartToCloseTimeout`, `RetryPolicy`.\n","is_empty":false},{"file_name":"activity-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activity-heartbeats.md","id":"php/activity-heartbeats","title":"How to Heartbeat an Activity","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.","label":"Activity Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn [Activity Heartbeat](/concepts/what-is-an-activity-heartbeat) is a ping from the [Worker Process](/concepts/what-is-a-worker-process) that is executing the Activity to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nEach Heartbeat informs the Temporal Cluster that the [Activity Execution](/concepts/what-is-an-activity-execution) is making progress and the Worker has not crashed.\nIf the Cluster does not receive a Heartbeat within a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) time period, the Activity will be considered failed and another [Activity Task Execution](/concepts/what-is-an-activity-task-execution) may be scheduled according to the Retry Policy.\n\nHeartbeats may not always be sent to the Cluster—they may be [throttled](/concepts/what-is-an-activity-heartbeat#throttling) by the Worker.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\nHeartbeats can contain a `details` field describing the Activity's current progress.\nIf an Activity gets retried, the Activity can access the `details` from the last Heartbeat that was sent to the Cluster.\n","is_empty":false},{"file_name":"activity-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activity-parameters.md","id":"php/activity-parameters","title":"How to develop Activity Parameters","description":"When it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.","label":"Activity parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThere is no explicit limit to the total number of parameters that an [Activity Definition](/concepts/what-is-an-activity-definition) may support.\nHowever, there is a limit of the total size of the data ends up encoded into a gRPC message Payload.\n\nA single argument is limited to a maximum size of 2 MB.\nAnd the total size of a gRPC message, which includes all the arguments, is limited to a maximum of 4 MB.\n\nAlso, keep in mind that all Payload data is recorded in the [Workflow Execution Event History](/concepts/what-is-an-event-history) and large Event Histories can affect Worker performance.\nThis is because the entire Event History could be transferred to a Worker Process with a [Workflow Task](/concepts/what-is-a-workflow-task).\n\n<!--TODO link to gRPC limit section when available -->\n\nSome SDKs require that you pass context objects, others do not.\nWhen it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.\nThis is so that you can change what data is passed to the Activity without breaking a function or method signature.\n","is_empty":false},{"file_name":"activity-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activity-retries.md","id":"php/activity-retries","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activity-retry-policy.md","id":"php/activity-retry-policy","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-simulator.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activity-retry-simulator.md","id":"php/activity-retry-simulator","title":"How to visualize an Activity Retry Policy with timeouts","description":"Use this tool to visualize total Activity Execution times and experiment with various Activity timeouts and Retry Policies.","label":"Activity retry simulator","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse this tool to visualize total Activity Execution times and experiment with different Activity timeouts and Retry Policies.\n\nThe simulator is based on a common Activity use-case, which is to call a third party HTTP API and return the results.\nSee the example code snippets below.\n\nUse the Activity Retries settings to configure how long the API request takes to succeed or fail.\nThere is an option to generate scenarios.\nThe _Task Time in Queue_ simulates the time the Activity Task might be waiting in the Task Queue.\n\nUse the Activity Timeouts and Retry Policy settings to see how they impact the success or failure of an Activity Execution.\n\nimport RetrySimulator from '/docs/components/RetrySimulator/RetrySimulator';\n\n<RetrySimulator />\n","is_empty":false},{"file_name":"activity-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activity-return-values.md","id":"php/activity-return-values","title":"How to define Activity return values","description":"All data returned from an Activity must be serializable.","label":"Activity return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll data returned from an Activity must be serializable.\n\nThere is no explicit limit to the amount of data that can be returned by an Activity, but keep in mind that all return values are recorded in a [Workflow Execution Event History](/concepts/what-is-an-event-history).\n","is_empty":false},{"file_name":"activity-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activity-timeouts-and-retries.md","id":"php/activity-timeouts-and-retries","title":"How to set Activity timeouts and retries","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts and retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"activity-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activity-timeouts.md","id":"php/activity-timeouts","title":"How to set Activity timeouts","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\n\nThe following timeouts are available in the Activity Options.\n\n- **[Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout)**: is the maximum amount of time allowed for the overall [Activity Execution](/concepts/what-is-an-activity-execution).\n- **[Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout)**: is the maximum time allowed for a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n- **[Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout)**: is the maximum amount of time that is allowed from when an [Activity Task](/concepts/what-is-an-activity-task) is scheduled to when a [Worker](/concepts/what-is-a-worker) starts that Activity Task.\n\nAn Activity Execution must have either the Start-To-Close or the Schedule-To-Close Timeout set.\n","is_empty":false},{"file_name":"activity-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/activity-type.md","id":"php/activity-type","title":"How to customize your Activity Type","description":"You can set a custom name for your Activity Type.","label":"Activity Type","tags":["guide-context"],"ssdi":[],"markdown_content":"\nActivities have a Type that are referred to as the Activity name.\nThe following examples demonstrate how to set a custom name for your Activity Type.\n","is_empty":false},{"file_name":"add-sdk.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/add-sdk.md","id":"php/add-sdk","title":"How to install a Temporal SDK","description":"A Temporal SDK provides a framework for Temporal Application development.","label":"Install a Temporal SDK","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal SDK](/concepts/what-is-a-temporal-sdk) provides a framework for [Temporal Application](/concepts/what-is-a-temporal-application) development.\n\nAn SDK provides you with the following:\n\n- A [Temporal Client](/concepts/what-is-a-temporal-client) to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n- APIs to develop [Workflows](/concepts/what-is-a-workflow).\n- APIs to create and manage [Worker Processes](/concepts/what-is-a-worker).\n- APIs to author [Activities](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"assert-in-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/assert-in-workflows.md","id":"php/assert-in-workflows","title":"Assert in Workflows","description":"How to Assert in Workflows","label":"Assert in Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\n<!-- not used -->\n\nIn some cases it's useful to assert directly in the Workflow context.\n\nFor example, TypeScript and Python, can use `assert` in Workflow code.\n","is_empty":false},{"file_name":"async-activity-completion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/async-activity-completion.md","id":"php/async-activity-completion","title":"How to asynchronously complete an Activity","description":"Asynchronous Activity Completion enables the Activity Function to return without the Activity Execution completing.","label":"Asynchronous Activity Completion","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Asynchronous Activity Completion](/concepts/what-is-asynchronous-activity-completion) enables the Activity Function to return without the Activity Execution completing.\n\nThere are three steps to follow:\n\n1. The Activity provides the external system with identifying information needed to complete the Activity Execution.\n   Identifying information can be a [Task Token](/concepts/what-is-a-task-token), or a combination of Namespace, Workflow Id, and Activity Id.\n2. The Activity Function completes in a way that identifies it as waiting to be completed by an external system.\n3. The Temporal Client is used to Heartbeat and complete the Activity.\n","is_empty":false},{"file_name":"cancel-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/cancel-activity.md","id":"php/cancel-activity","title":"Cancel an Activity from a Workflow","description":"An Activity can be canceled from within a Workflow if the Activity sends Heartbeats.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCanceling an Activity from within a Workflow requires that the Activity Execution sends Heartbeats and sets a Heartbeat Timeout.\nIf the Heartbeat is not invoked, the Activity cannot receive a cancellation request.\nWhen any non-immediate Activity is executed, the Activity Execution should send Heartbeats and set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) to ensure that the server knows it is still working.\n\nWhen an Activity is canceled, an error is raised in the Activity at the next available opportunity.\nIf cleanup logic needs to be performed, it can be done in a `finally` clause or inside a caught cancel error.\nHowever, for the Activity to appear canceled the exception needs to be re-raised.\n\n:::note\n\nUnlike regular Activities, [Local Activities](/concepts/what-is-a-local-activity) can be canceled if they don't send Heartbeats.\nLocal Activities are handled locally, and all the information needed to handle the cancellation logic is available in the same Worker process.\n\n:::\n","is_empty":false},{"file_name":"cancel-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/cancel-an-activity.md","id":"php/cancel-an-activity","title":"Cancel an Activity","description":"If an Activity is supposed to react to Cancellation, you can test whether it reacts correctly by canceling it.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity is supposed to react to a Cancellation, you can test whether it reacts correctly by canceling it.\n","is_empty":false},{"file_name":"child-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/child-workflows.md","id":"php/child-workflows","title":"How to start a Child Workflow Execution","description":"A Child Workflow Execution is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.","label":"Child Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.\n\nWhen using a Child Workflow API, Child Workflow related Events ([StartChildWorkflowExecutionInitiated](/references/events#startchildworkflowexecutioninitiated), [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted), [ChildWorkflowExecutionCompleted](/references/events#childworkflowexecutioncompleted), etc...) are logged in the Workflow Execution Event History.\n\nAlways block progress until the [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted) Event is logged to the Event History to ensure the Child Workflow Execution has started.\nAfter that, Child Workflow Executions may be abandoned using the default _Abandon_ [Parent Close Policy](/concepts/what-is-a-parent-close-policy) set in the Child Workflow Options.\n\nTo be sure that the Child Workflow Execution has started, first call the Child Workflow Execution method on the instance of Child Workflow future, which returns a different future.\n\nThen get the value of an object that acts as a proxy for a result that is initially unknown, which is what waits until the Child Workflow Execution has spawned.\n","is_empty":false},{"file_name":"code-samples-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/code-samples-php.md","id":"php/code-samples-php","title":"Code samples","label":"Code samples","ssdi":[],"markdown_content":"\n- [PHP samples repo](https://github.com/temporalio/samples-php)\n\n- [Subscription-style Workflow Definition in PHP](https://github.com/temporalio/subscription-workflow-project-template-php): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n","is_empty":false},{"file_name":"code-samples.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/code-samples.md","id":"php/code-samples","title":"Where are SDK-specific code examples?","description":"You can find a complete list of executable code samples in Temporal's GitHub repository.","label":"Code samples","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can find a complete list of executable code samples in [Temporal's GitHub repository](https://github.com/temporalio?q=samples-&type=all&language=&sort=).\n\nAdditionally, several of the [Tutorials](https://learn.temporal.io) are backed by a fully executable template application.\n","is_empty":false},{"file_name":"connect-to-a-dev-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/connect-to-a-dev-cluster.md","id":"php/connect-to-a-dev-cluster","title":"How to connect a Temporal Client to a Temporal Cluster","description":"When connecting a Temporal Client to a Temporal Cluster, you must provide the address and port number of the Temporal Cluster.","label":"Connect to a dev Cluster","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal Client](/concepts/what-is-a-temporal-client) enables you to communicate with the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nCommunication with a Temporal Cluster includes, but isn't limited to, the following:\n\n- Starting Workflow Executions.\n- Sending Signals to Workflow Executions.\n- Sending Queries to Workflow Executions.\n- Getting the results of a Workflow Execution.\n- Providing an Activity Task Token.\n\n:::caution\n\nA Temporal Client cannot be initialized and used inside a Workflow.\nHowever, it is acceptable and common to use a Temporal Client inside an Activity to communicate with a Temporal Cluster.\n\n:::\n\nWhen you are running a Cluster locally (such as [Temporalite](/kb/all-the-ways-to-run-a-cluster#temporalite)), the number of connection options you must provide is minimal.\nMany SDKs default to the local host or IP address and port that Temporalite and [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose) serve (`127.0.0.1:7233`).\n","is_empty":false},{"file_name":"connect-to-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/connect-to-temporal-cloud.md","id":"php/connect-to-temporal-cloud","title":"How to connect to Temporal Cloud","description":"Use a compatible mTLS CA certificate and mTLS private key and your Cloud Namespace to connect to Temporal Cloud.","label":"Connect to Temporal Cloud","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen you connect to [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"continue-as-new.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/continue-as-new.md","id":"php/continue-as-new","title":"How to Continue-As-New","description":"Continue-As-New enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.","label":"Continue-As-New","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Continue-As-New](/concepts/what-is-continue-as-new) enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.\nThe Workflow Execution spawned from the use of Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\n","is_empty":false},{"file_name":"cron-jobs.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/cron-jobs.md","id":"php/cron-jobs","title":"How to use Temporal Cron Jobs","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Jobs","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.\n","is_empty":false},{"file_name":"custom-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/custom-logging.md","id":"php/custom-logging","title":"How to provide a custom logger","description":"Use a custom logger for logging.","label":"Custom logger","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a custom logger for logging.\n","is_empty":false},{"file_name":"custom-payload-conversion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/custom-payload-conversion.md","id":"php/custom-payload-conversion","title":"How to use custom payload conversion","description":"Create your custom `PayloadConverter` and set it on a `DataConverter` in your Client options.","label":"Custom payload conversion","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal SDKs provide a [Payload Converter](/concepts/what-is-a-payload-converter) that can be customized to convert a custom data type to [Payload](/concepts/what-is-a-payload) and back.\n\nImplementing custom Payload conversion is optional.\nIt is needed only if the [default Data Converter](/concepts/what-is-a-default-data-converter) does not support your custom values.\n\nTo support custom Payload conversion, create a [custom Payload Converter](/concepts/what-is-a-payload-converter#custom-payload-conversion) and configure the Data Converter to use it in your Client options.\n\nThe order in which your encoding Payload Converters are applied depend on the order given to the Data Converter.\nYou can set multiple encoding Payload Converters to run your conversions.\nWhen the Data Converter receives a value for conversion, it passes through each Payload Converter in sequence until the converter that handles the data type does the conversion.\n","is_empty":false},{"file_name":"debug-environment-development.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/debug-environment-development.md","id":"php/debug-environment-development","title":"How to debug in a development environment","description":"In addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the Web UI and tctl.","label":"Debug in a development environment","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the [Web UI](/web-ui) or [`tctl`](/tctl-v1).\n","is_empty":false},{"file_name":"debug-environment-production.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/debug-environment-production.md","id":"php/debug-environment-production","title":"How to debug in a development production","description":"Debug production Workflows using the Web UI, tctl, Replays, Tracing, or Logging.","label":"Debug in a development production","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can debug production Workflows using:\n\n- [Web UI](/web-ui)\n- [tctl](/tctl-v1)\n\nYou can debug and tune Worker performance with metrics and the [Worker performance guide](/dev-guide/worker-performance).\n\nDebug Server performance with [Cloud metrics](/cloud/how-to-monitor-temporal-cloud-metrics) or [self-hosted Server metrics](/kb/legacy-oss-prod-deploy#scaling-and-metrics).\n","is_empty":false},{"file_name":"debugging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/debugging.md","id":"php/debugging","title":"Debugging","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Debug","tags":["guide-context"],"ssdi":[],"markdown_content":"","is_empty":false},{"file_name":"define-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/define-query.md","id":"php/define-query","title":"How to define a Query","description":"A Query has a name and can have arguments.","label":"Define Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Query has a name and can have arguments.\n\n- The name, also called a Query type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"define-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/define-signal.md","id":"php/define-signal","title":"How to define a Signal","description":"A Signal has a name and can have arguments.","label":"Define Signal","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"developing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/developing-activities.md","id":"php/developing-activities","title":"How to develop a basic Activity","description":"One of the primary things that Workflows do is orchestrate the execution of Activities.","label":"Develop Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nOne of the primary things that Workflows do is orchestrate the execution of Activities.\nAn Activity is a normal function or method execution that's intended to execute a single, well-defined action (either short or long-running), such as querying a database, calling a third-party API, or transcoding a media file.\nAn Activity can interact with world outside the Temporal Platform or use a Temporal Client to interact with a Cluster.\nFor the Workflow to be able to execute the Activity, we must define the [Activity Definition](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"developing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/developing-workflows.md","id":"php/developing-workflows","title":"How to develop a basic Workflow","description":"Workflows are the fundamental unit of a Temporal Application, and it all starts with the development of a Workflow Definition.","label":"Develop Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/concepts/what-is-a-workflow-definition).\n","is_empty":false},{"file_name":"distributed-cron.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/distributed-cron.md","id":"php/distributed-cron","title":"Distributed CRON","ssdi":[],"markdown_content":"\n:::info Try the Developer's guide\n\nThe majority of this information has moved into the [Developer's guide](/dev-guide/?lang=php).\n\nHowever, if you can't find what you are looking for there, we recommend checking this doc set as well.\n\n:::\n\n<!-- prettier-ignore -->\n\nimport * as WhatIsATemporalCronJob from '../concepts/what-is-a-temporal-cron-job.md'\n\nThis is how you set a Cron Schedule in PHP:\n\n```php\n  $workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()\n          ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n          ->withCronSchedule('* * * * *')\n          // Execution timeout limits total time. Cron will stop executing after this timeout.\n          ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n          // Run timeout limits duration of a single workflow invocation.\n          ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n  );\n\n  $output->writeln(\"Starting <comment>CronWorkflow</comment>... \");\n\n  try {\n      $run = $this->workflowClient->start($workflow, 'Antony');\n      // ...\n  }\n```\n\nSetting `withCronSchedule` turns the Workflow Execution into a <preview page={WhatIsATemporalCronJob}>Temporal Cron Job</preview>\n\nYou can check our [PHP samples](https://github.com/temporalio/samples-php/tree/master/app/src/Cron) for example code.\n\nPHP SDK `WorkflowOptions` source code: https://github.com/temporalio/sdk-php/blob/master/src/Client/WorkflowOptions.php\n\n## Retrieve last successful result\n\nSometimes it is useful to obtain the progress of previous successful runs.\nThis is supported by two APIs in the PHP SDK:\n`Workflow::hasLastCompletionResult` and `Workflow::getLastCompletionResult`. Below is an example of how\nto use this in PHP:\n\n```php\npublic function cronWorkflow() {\n    $lastProcessedFileName = Workflow::getLastCompletionResult(Type::TYPE_STRING);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return $lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the cron schedule runs failed. The\nnext schedule will still get the last successful result if it ever successfully\ncompleted at least once. For example, for a daily cron Workflow, if the first day\nrun succeeds and the second day fails, then the third day run will still get\nthe result from first day's run using these APIs.\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/environment-variables.md","id":"php/environment-variables","title":"How to read and pass environment variables","description":"Environment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.","label":"Environment variables","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEnvironment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.\nThey can't be used normally with Workflow code, as that would be [non-deterministic](workflows#intrinsic-non-deterministic-logic) (if the environment variables changed between Workflow replays, the code that used them would behave differently).\n\nMost of the time, you can provide environment variables in your Activity function; however, if you need them in your Workflow functions, you can use the following options:\n\n- Provide environment variables as arguments when starting the Workflow.\n- Call a Local Activity at the beginning of the Workflow that returns environment variables.\n\nIn either case, the environment variables will appear in Event History, so you may want to use an [encryption Data Converter](/concepts/what-is-a-data-converter#encryption).\n","is_empty":false},{"file_name":"error-handling.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/error-handling.md","id":"php/error-handling","title":"Error handling in PHP","label":"Error handling","ssdi":[],"markdown_content":"\nAn Activity, or a Child Workflow, might fail, and you could handle errors differently based on the various error cases.\n\nIf the Activity returns throws an exception, that exception will\nbe converted to `Temporal\\Exception\\Failure\\ApplicationFailure` and wrapped\ninside `Temporal\\Exception\\Failure\\ActivityFailure` or `Temporal\\Exception\\Failure\\ChildWorkflowFailure`.\n\nIt is possible to throw `ApplicationFailure` manually with the ability to set `nonRetryable` flag.\n\nThere are other types of exceptions such as `TimeoutFailure`, `CanceledFailure` and\n`ServerFailure`.\n\n> All temporal related exceptions has suffix `Failure` for easier comprehension.\n\nHere's an example of handling Activity errors within Workflow code that differentiates between different error types.\n\n```php\nuse Temporal\\Exception\\Failure;\nuse Temporal\\Api\\Enums\\V1\\TimeoutType;\n\n$yourActivity = Workflow::newActivityStub(\n    YourActivityInterface::class,\n    ActivityOptions::new()->withScheduleToStartTimeout(60)\n);\n\ntry {\n    yield $yourActivity->doSomething();\n} catch(Failure\\ActivityFailure $e) {\n    $cause = $e->getPrevious();\n\n    if ($cause instanceof Failure\\ApplicationFailure) {\n        // domain code error\n        $originalError = $cause->getType();\n        $originalMessage = $cause->getOriginalMessage();\n\n        // optional: additional error details\n        $value = $cause->getDetails()->getValue(0, Type::TYPE_STRING);\n    }\n\n     if ($cause instanceof Failure\\TimeoutFailure) {\n        switch ($cause->getTimeoutType()) {\n            case TimeoutType::TIMEOUT_TYPE_START_TO_CLOSE:\n                // handle start to close timeout\n                break;\n            case TimeoutType::TIMEOUT_TYPE_SCHEDULE_TO_CLOSE:\n                // handle schedule to close timeout\n                break;\n            case TimeoutType::TIMEOUT_TYPE_SCHEDULE_TO_START:\n                // handle schedule to start timeout\n                break;\n            case TimeoutType::TIMEOUT_TYPE_HEARTBEAT:\n                // handle heartbeat timeout\n\n                // last recorded heartbeat (optional)\n                $heartbeatDetails = $cause->getLastHeartbeatDetails();\n                break;\n        }\n    }\n\n    if($cause instanceof Failure\\CanceledFailure){\n        // activity was canceled\n    }\n\n    if ($cause instanceof Failure\\ServerFailure) {\n        // handle server error\n    }\n}\n```\n","is_empty":false},{"file_name":"features.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/features.md","id":"php/features","title":"How to use Workflow and Activity features","description":"The Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.","label":"Features","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\n\nIn this section you can find the following:\n\n- [How to develop Signals](#signals)\n- [How to develop Queries](#queries)\n- [How to start a Child Workflow Execution](#child-workflows)\n- [How to start a Temporal Cron Job](#temporal-cron-jobs)\n- [How to use Continue-As-New](#continue-as-new)\n- [How to set Workflow timeouts & retries](#workflow-timeouts)\n- [How to set Activity timeouts & retries](#activity-timeouts)\n- [How to Heartbeat an Activity](#activity-heartbeats)\n- [How to Asynchronously complete an Activity](#asynchronous-activity-completion)\n- [How to register Namespaces](#namespaces)\n- [How to use custom payload conversion](#custom-payload-conversion)\n","is_empty":false},{"file_name":"foundations.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/foundations.md","id":"php/foundations","title":"How to build a basic Temporal Application","description":"The Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application—that is, all the relevant steps to start a Workflow Execution that executes an Activity.","label":"Foundations","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a [Temporal Application](/concepts/what-is-a-temporal-application)—that is, all the relevant steps to start a [Workflow Execution](#develop-workflows) that executes an [Activity](#develop-activities).\n\nIn this section you can find the following:\n\n- [Run a development Cluster](/clusters/how-to-install-temporal-cli)\n- [Install your SDK](/php/add-sdk)\n- [Connect to a dev Cluster](/php/connect-to-a-dev-cluster)\n- [Develop a Workflow](/php/developing-workflows)\n- [Develop an Activity](/php/developing-activities)\n- [Start an Activity Execution](/php/spawning-activities)\n- [Run a dev Worker](/php/run-a-dev-worker)\n- [Run a Temporal Cloud Worker](/php/run-a-dev-worker)\n- [Start a Workflow Execution](/php/spawning-workflows)\n\n**Resources**\n\n- Join the `#php-sdk` channel on the [Temporal Slack](https://temporal.io/slack) or [open issues on GitHub](https://github.com/temporalio/sdk-php/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc).\n- PHP SDK samples\n  - [Beginner-advanced library](https://github.com/temporalio/samples-php#samples)\n  - [Subscription Workflow sample](https://github.com/temporalio/subscription-workflow-project-template-php)\n- Talks\n  - 🆕 PHPConf 2021: [Fault tolerant workflow orchestration on PHP](https://www.youtube.com/watch?v=pdxHkIqX62A)\n  - PHPConf 2020: [Designing hybrid Go/PHP applications using RoadRunner](https://www.youtube.com/watch?v=mj6d-IGzSYE)\n  - (Slides) [Distributed Workflows on PHP](https://docs.google.com/presentation/d/1NBZlnJFCc-PgYxQk0_YYxUTmfKgzUf6Z-XHXfPETLac/edit?usp=sharing)\n  - (Russian) [Orchestrate it! Complex business processes in PHP](https://www.youtube.com/watch?v=upL8o-OXYEc) (2 hour workshop)\n  - (Russian) [Orchestration and Murphy's Law: Handling Errors-Business Processes](https://www.youtube.com/watch?v=0NCMEaFMj_M) (2 hour workshop)\n  - (Russian) PHP Russia https://phprussia.ru/moscow/2021/abstracts/7390 (video pending)\n  - (Russian) [FWDays Keynote: Fault Tolerant Workflow Orchestration on PHP](https://fwdays.com/en/event/php-fwdays-2021/review/fault-tolerant-workflow-orchestration-on-php) (video pending)\n- The PHP SDK is often used with [Roadrunner](https://roadrunner.dev/) (maintained by [SpiralScout](https://github.com/spiral?type=source), the maintainers of the PHP SDK)\n","is_empty":false},{"file_name":"get-activity-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/get-activity-results.md","id":"php/get-activity-results","title":"How to get the results of an Activity Execution","description":"The call to spawn an Activity Execution generates the ScheduleActivityTask Command and provides the Workflow with an Awaitable.","label":"Get Activity results","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe call to spawn an [Activity Execution](/concepts/what-is-an-activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.\n","is_empty":false},{"file_name":"get-workflow-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/get-workflow-results.md","id":"php/get-workflow-results","title":"How to get the results of a Workflow Execution","description":"If the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.","label":"Get Workflow results","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.\n\nThe Workflow Id, Run Id, and Namespace may be used to uniquely identify a Workflow Execution in the system and get its result.\n\nIt's possible to both block progress on the result (synchronous execution) or get the result at some other point in time (asynchronous execution).\n\nIn the Temporal Platform, it's also acceptable to use Queries as the preferred method for accessing the state and results of Workflow Executions.\n","is_empty":false},{"file_name":"handle-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/handle-query.md","id":"php/handle-query","title":"How to handle a Query","description":"Queries are handled by your Workflow.","label":"Handle Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are handled by your Workflow.\n\nDon’t include any logic that causes [Command](/concepts/what-is-a-command) generation within a Query handler (such as executing Activities).\nIncluding such logic causes unexpected behavior.\n","is_empty":false},{"file_name":"handle-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/handle-signal.md","id":"php/handle-signal","title":"How to handle a Signal","description":"Workflows listen for Signals by the Signal's name.","label":"Handle Signal","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows listen for Signals by the Signal's name.\n","is_empty":false},{"file_name":"heartbeat-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/heartbeat-timeout.md","id":"php/heartbeat-timeout","title":"How to set a Heartbeat Timeout","description":"A Heartbeat Timeout works in conjunction with Activity Heartbeats.","label":"Heartbeat Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) works in conjunction with [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-php.md","id":"php/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-php","title":"How to set Custom Search Attributes to a Workflow Execution in PHP","label":"Custom Search Attributes","ssdi":[],"markdown_content":"\nUse the `WorkflowOptions::withSearchAttributes()` method to provide Search Attributes when you start a Workflow.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    GreetingWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowExecutionTimeout(CarbonInterval::minute())\n        ->withSearchAttributes(\n            [\n                'CustomKeywordField' => 'value',\n                'CustomIntField' => 123,\n            ]\n        )\n);\n```\n","is_empty":false},{"file_name":"how-to-connect-to-a-cluster-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-connect-to-a-cluster-php.md","id":"php/how-to-connect-to-a-cluster-php","title":"How to connect to a Cluster in PHP","label":"Connect to a Cluster","ssdi":[],"markdown_content":"\nCreate an instance of the `$workflowClient` class and use the `create()` method to connect a Temporal Client to a Temporal Cluster.\n\nSpecify the target host, `localhost:7223`, parameter as a string and provide the TLS configuration for connecting to a Temporal Cluster.\n\n```php\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowOptions;\n# . . .\n$workflowClient = Temporal\\Client\\WorkflowClient::create(\n     ServiceClient::createSSL(\n         'localhost:7233',\n         'certs/ca.cert',\n         'certs/client.key',\n         'certs/client.pem',\n         'tls-sample',\n     ),\n );\n```\n\nTo provide the client options as an environmental variable, add the `tls` option to the RoadRunner configuration file and pass the path to the file.\n\n```yml\ntemporal:\n  # . . .\n  tls:\n    key: \"certs/client.key\"\n    cert: \"certs/client.pem\"\n    root_ca: \"certs/ca.cert\"\n    client_auth_type: require_and_verify_client_cert\n    server_name: \"tls-sample\"\n```\n\nThen update your application and use the SSL connection for `ServiceClient`.\n\n```php\n$workflowClient = Temporal\\Client\\WorkflowClient::create(\n     ServiceClient::createSSL(\n         'localhost:7233',\n         getenv('TEMPORAL_SERVER_ROOT_CA_CERT_PATH'),\n         getenv('TEMPORAL_CLIENT_KEY_PATH'),\n         getenv('TEMPORAL_CLIENT_CERT_PATH'),\n         getenv('TEMPORAL_SERVER_NAME_OVERRIDE')\n     ),\n );\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-continue-as-new-in-php.md","id":"php/how-to-continue-as-new-in-php","title":"How to Continue-As-New in PHP","label":"Continue-As-New","ssdi":[],"markdown_content":"\nWorkflows that need to rerun periodically could naively be implemented as a big **while** loop with a sleep where the entire logic of the Workflow is inside the body of the **while** loop.\nThe problem with this approach is that the history for that Workflow will keep growing to a point where it reaches the maximum size enforced by the service.\n\n**ContinueAsNew** is the low level construct that enables implementing such Workflows without the risk of failures down the road.\nThe operation atomically completes the current execution and starts a new execution of the Workflow with the same **Workflow Id**.\nThe new execution will not carry over any history from the old execution.\n\nTo trigger this behavior, use `Workflow::continueAsNew` or `Workflow::newContinueAsNewStub` method:\n\n```php\n#[Workflow\\WorkflowMethod]\npublic function periodic(string $name, int $value = 0)\n{\n    for ($i = 0; $i < 100; $i++) {\n        // do something\n        $value++;\n    }\n\n    // maintain $value counter between runs\n    return Workflow::newContinueAsNewStub(self::class)->periodic($name, $value);\n}\n```\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-create-a-temporal-client-in-php.md","id":"php/how-to-create-a-temporal-client-in-php","title":"How to create a Temporal Client in PHP","label":"Temporal Client","ssdi":[],"markdown_content":"\nThe following example represents a console command that starts a Workflow, prints its IDs, and then waits for its result:\n\n<!--SNIPSTART php-hello-client {\"enable_source_link\": true}-->\n\n[app/src/SimpleActivity/ExecuteCommand.php](https://github.com/temporalio/samples-php/blob/master/app/src/SimpleActivity/ExecuteCommand.php)\n\n```php\nclass ExecuteCommand extends Command\n{\n    protected const NAME = 'simple-activity';\n    protected const DESCRIPTION = 'Execute SimpleActivity\\GreetingWorkflow';\n\n    public function execute(InputInterface $input, OutputInterface $output)\n    {\n        $workflow = $this->workflowClient->newWorkflowStub(\n            GreetingWorkflowInterface::class,\n            WorkflowOptions::new()->withWorkflowExecutionTimeout(CarbonInterval::minute())\n        );\n\n        $output->writeln(\"Starting <comment>GreetingWorkflow</comment>... \");\n\n        // Start a workflow execution. Usually this is done from another program.\n        // Uses task queue from the GreetingWorkflow @WorkflowMethod annotation.\n        $run = $this->workflowClient->start($workflow, 'Antony');\n\n        $output->writeln(\n            sprintf(\n                'Started: WorkflowID=<fg=magenta>%s</fg=magenta>',\n                $run->getExecution()->getID(),\n            )\n        );\n\n        // getResult waits for workflow to complete\n        $output->writeln(sprintf(\"Result:\\n<info>%s</info>\", $run->getResult()));\n\n        return self::SUCCESS;\n    }\n}\n```\n\n<!--SNIPEND-->\n\nThe `WorkflowClientInterface` in the snippet is an entry point to get access to Workflow.\nUse an instance of `WorkflowClientInterface` to create, retrieve, or start a Workflow.\nHere we create an instance of `GreetingWorkflowInterface` with a Workflow Execution Timeout of one minute.\n\nThen we print some information and start the Workflow.\n","is_empty":false},{"file_name":"how-to-create-local-activities-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-create-local-activities-in-php.md","id":"php/how-to-execute-a-local-activity-in-php","title":"How to execute a Local Activity in PHP","label":"Local Activity","ssdi":[],"markdown_content":"\nTo execute a Local Activity, use `#[LocalActivityInterface]`.\n\n```php\nuse Temporal\\Activity\\LocalActivityInterface;\n\n#[ActivityInterface]\ninterface YourActivityInterface\n{\n    #[ActivityMethod(\"youractivity\")]\n    public function youractivity(): string;\n}\n```\n\nLocal Activities requires `LocalActivityOptions`:\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    YourActivityInterface::class,\n    LocalActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n```\n\nLocal Activity Execution options include the following:\n\n- `ScheduleToCloseTimeout`\n- `StartToCloseTimeout`\n- `RetryPolicy`.\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-customize-activity-type-in-php.md","id":"php/how-to-customize-activity-type-in-php","title":"How to customize Activity Type in PHP","description":"Customize your Activity Type.","label":"Customize Activity Type","tags":["developer-guide","sdk","php"],"ssdi":[],"markdown_content":"\nAn optional `#[ActivityMethod]` annotation can be used to override a default Activity name.\n\nYou can define your own prefix for all Activity names by adding the `prefix` option to the `YourActivityInterface` annotation.\n(The default prefix is empty.)\n\n```php\n#[YourActivityInterface(\"file_activities.\")]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName);\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName);\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName);\n}\n```\n\nThe `#[YourActivityInterface(\"file_activities.\")]` is an annotation that tells the PHP SDK to generate a class to implement the `FileProcessingActivities` interface. The functions define Activities that are used in the Workflow.\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-customize-workflow-type-in-php.md","id":"php/how-to-customize-workflow-type-in-php","title":"How to customize a Workflow Type in PHP","description":"How to customize a Workflow Type in PHP","label":"Custom Workflow Type","tags":["developer-guide","sdk","php"],"ssdi":[],"markdown_content":"\nTo customize a Workflow Type, use the `WorkflowMethod` annotation to specify the name of Workflow.\n\n```php\n#[WorkflowMethod(name)]\n```\n\nIf a Workflow Type is not specified, then Workflow Type defaults to the interface name, which is `YourWorkflowDefinitionInterface` in this case.\n\n```php\n#[WorkflowInterface]\ninterface YourWorkflowDefinitionInterface\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n}\n```\n","is_empty":false},{"file_name":"how-to-define-a-query-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-define-a-query-in-php.md","id":"php/how-to-define-a-query-in-php","title":"How to define a Query in PHP","label":"Define a Query","ssdi":[],"markdown_content":"\nWorkflows can answer synchronous [Queries](/concepts/what-is-a-query) and receive [Signals](/concepts/what-is-a-signal).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow Type defaults to `\"FileProcessingWorkflow\"`.\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-define-a-signal-in-php.md","id":"php/how-to-define-a-signal-in-php","title":"How to define a Signal in PHP","label":"Define a Signal","ssdi":[],"markdown_content":"\nWorkflows can answer synchronous [Queries](/concepts/what-is-a-query) and receive [Signals](/concepts/what-is-a-signal).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow Type defaults to `\"FileProcessingWorkflow\"`.\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-define-activity-parameters-in-php.md","id":"php/how-to-define-activity-parameters-in-php","title":"Define Activity parameters in PHP","label":"Activity parameters","ssdi":[],"markdown_content":"\nEach method defines a single Activity type.\nA single Workflow can use more than one Activity interface and call more than one Activity method from the same interface.\n\nThe only requirement is that Activity method arguments and return values are serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-define-activity-return-values-in-php.md","id":"php/how-to-define-activity-return-values-in-php","title":"How to define Activity return values in PHP","description":"Activity return values must be serializable and deserializable by the provided `DataConverter`","label":"Activity return values","tags":["developer-guide","php"],"ssdi":[],"markdown_content":"\nReturn values must be serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\nThus, you can return both primitive types:\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): string\n    {\n        return $greeting . ' ' . $name;\n    }\n}\n```\n\nAnd objects:\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): Greeting\n    {\n        return new Greeting($greeting, $name);\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-define-workflow-parameters-in-java.md","id":"php/how-to-define-workflow-parameters-in-php","title":"How to define Workflow Parameters in PHP","description":"A method annotated with `#[WorkflowMethod]` can have any number of parameters.","label":"Workflow parameters","tags":["developer-guide","php"],"ssdi":[],"markdown_content":"\nA method annotated with `#[WorkflowMethod]` can have any number of parameters.\n\nWe recommend passing a single parameter that contains all the input fields to allow for adding fields in a backward-compatible manner.\n\nNote that all inputs should be serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\nYou can create a custom object and pass it to the Workflow method, as shown in the following example:\n\n```php\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-define-workflow-return-values-in-php.md","id":"php/how-to-define-workflow-return-values-in-php","title":"Define Workflow return values in PHP","label":"Workflow return values","ssdi":[],"markdown_content":"\nA Workflow method returns a Generator.\nTo properly typecast the Workflow's return value in the client code, use the `#[ReturnType()]` annotation.\n\n```php\n#[YourWorkflowInterface]\ninterface FileProcessingWorkflow {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-develop-a-worker-program-in-php.md","id":"php/how-to-develop-a-worker-program-in-php","title":"How to develop a Worker Program in PHP","description":"Use the `newWorker()` method on an instance of a `WorkerFactory` to create a new Worker in PHP.","tags":["developer-guide","php","workers"],"ssdi":[],"markdown_content":"\nThe [RoadRunner application server](https://roadrunner.dev/) will launch multiple Temporal PHP Worker processes based on provided `.rr.yaml` configuration.\n\nEach Worker might connect to one or multiple Task Queues.\nWorker poll _Temporal service_ for tasks, performs those tasks, and communicates task execution results back to the _Temporal service_.\n\nWorker code are developed, deployed, and operated by Temporal customers.\nTo create a worker use `Temporal\\WorkerFactory`:\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nuse Temporal\\WorkerFactory;\n\nini_set('display_errors', 'stderr');\ninclude \"vendor/autoload.php\";\n\n// factory initiates and runs task queue specific activity and workflow workers\n$factory = WorkerFactory::create();\n\n// Worker that listens on a Task Queue and hosts both workflow and activity implementations.\n$worker = $factory->newWorker();\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n\n// Activities are stateless and thread safe. So a shared instance is used.\n$worker->registerActivity(App\\DemoActivity::class);\n\n// In case an activity class requires some external dependencies provide a callback - factory\n// that creates or builds a new activity instance. The factory should be a callable which accepts\n// an instance of ReflectionClass with an activity class which should be created.\n$worker->registerActivity(App\\DemoActivity::class, fn(ReflectionClass $class) => $container->create($class->getName()));\n\n// start primary loop\n$factory->run();\n```\n\nYou can configure task queue name using first argument of `WorkerFactory`->`newWorker`:\n\n```php\n$worker = $factory->newWorker('your-task-queue');\n```\n\nAs mentioned above you can create as many Task Queue connections inside a single Worker Process as you need.\n\nTo configure additional WorkerOptions use `Temporal\\Worker\\WorkerOptions`:\n\n```php\nuse Temporal\\Worker\\WorkerOptions;\n\n$worker = $factory->newWorker(\n    'your-task-queue',\n    WorkerOptions::new()\n        ->withMaxConcurrentWorkflowTaskPollers(10)\n);\n```\n\nMake sure to point the Worker file in application server configuration:\n\n```yaml\nrpc:\n  listen: tcp://127.0.0.1:6001\n\nserver:\n  command: \"php worker.php\"\n\ntemporal:\n  address: \"temporal:7233\"\n  activities:\n    num_workers: 10\n```\n\n> You can serve HTTP endpoints using the same server setup.\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-develop-a-workflow-definition-in-php.md","id":"php/how-to-develop-a-workflow-definition-in-php","title":"Develop a Workflow Definition in PHP","label":"Workflow Definition","ssdi":[],"markdown_content":"\nIn the Temporal PHP SDK programming model, Workflows are a class method. Classes must implement interfaces that are annotated with `#[WorkflowInterface]`. The method that is the Workflow must be annotated with `#[WorkflowMethod]`.\n\n```php\nuse Temporal\\Workflow\\YourWorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-develop-an-activity-definition-in-php.md","id":"php/how-to-develop-an-activity-definition-in-php","title":"Develop an Activity Definition in PHP","label":"Activity Definition","ssdi":[],"markdown_content":"\nActivities are defined as methods of a plain PHP interface annotated with `#[YourActivityInterface]`.\n(You can also use PHP 8 attributes in PHP 7.)\n\nFollowing is an example of an interface that defines four Activities:\n\n```php\n#[YourActivityInterface]\n// Defining an interface for the activities.\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName): void;\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName): void;\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName): void;\n}\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-get-the-result-of-a-workflow-execution-in-php.md","id":"php/how-to-get-the-result-of-a-workflow-execution-in-php","title":"How to get the result of an Workflow Execution in PHP","label":"Workflow Execution","ssdi":[],"markdown_content":"\nIf you need to wait for the completion of a Workflow after an asynchronous start, make a blocking call to\nthe `WorkflowRun`->`getResult` method.\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getResult());\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-get-the-result-of-an-activity-execution-in-php.md","id":"php/how-to-get-the-result-of-an-activity-execution-in-php","title":"How to get the result of an Activity Execution in PHP","label":"Activity Execution","ssdi":[],"markdown_content":"\n`Workflow::newActivityStub`returns a client-side stub an implements an Activity interface. The client-side stub can be used within the Workflow code. It takes the Activity's type and`ActivityOptions` as arguments.\n\nCalling (via `yield`) a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if Activity Execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\n```php\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    private $greetingActivity;\n\n    public function __construct()\n    {\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n        );\n    }\n\n    public function greet(string $name): \\Generator\n    {\n        // This is a blocking call that returns only after the activity has completed.\n        return yield $this->greetingActivity->composeGreeting('Hello', $name);\n    }\n}\n```\n\nIf different Activities need different options, like timeouts or a task queue, multiple client-side stubs can be created with different options.\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 minutes'))\n);\n```\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-handle-a-query-in-a-workflow-in-php.md","id":"php/how-to-handle-a-query-in-a-workflow-in-php","title":"How to handle a Query in PHP","label":"Handle a Query","ssdi":[],"markdown_content":"\nYou can add custom Query types to handle Queries such as Querying the current state of a\nWorkflow, or Querying how many Activities the Workflow has completed. To do this, you need to set\nup a Query handler using method attribute `QueryMethod` or `Workflow::registerQueryHandler`.\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\QueryMethod]\n    public function getValue()\n    {\n        return 42;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // workflow code\n    }\n\n}\n```\n\nThe handler function can receive any number of input parameters, but all input parameters must be\nserializable. The following sample code sets up a Query handler that handles the Query type of\n`currentState`:\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private string $currentState;\n\n    #[Workflow\\QueryMethod('current_state')]\n    public function getCurrentState(): string\n    {\n        return $this->currentState;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // Your normal Workflow code begins here, and you update the currentState\n        // as the code makes progress.\n        $this->currentState = 'waiting timer';\n        try{\n            yield Workflow::timer(DateInterval::createFromDateString('1 hour'));\n        } catch (\\Throwable $e) {\n            $this->currentState = 'timer failed';\n            throw $e;\n        }\n\n        $yourActivity = Workflow::newActivityStub(\n            YourActivityInterface::class,\n            ActivityOptions::new()->withScheduleToStartTimeout(60)\n        );\n\n        $this->currentState = 'waiting activity';\n        try{\n            yield $yourActivity->doSomething('some input');\n        } catch (\\Throwable $e) {\n            $this->currentState = 'activity failed';\n            throw $e;\n        }\n\n        $this->currentState = 'done';\n\n        return null;\n    }\n}\n```\n\nYou can also issue a Query from code using the `QueryWorkflow()` API on a Temporal Client object.\n\nUse `WorkflowStub` to Query Workflow instances from your Client code (can be applied to both running and closed Workflows):\n\n```php\n$workflow = $workflowClient->newWorkflowStub(\n    YourWorkflow::class,\n    WorkflowOptions::new()\n);\n\n$workflowClient->start($workflow);\n\nvar_dump($workflow->getCurrentState());\nsleep(60);\nvar_dump($workflow->getCurrentState());\n```\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-a-workflow-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-handle-a-signal-in-a-workflow-in-php.md","id":"php/how-to-handle-a-signal-in-a-workflow-in-php","title":"How to handle Signals in an Workflow in PHP","description":"Use the `#[SignalMethod]` annotation to handle Signals within the Workflow interface.","label":"Handle Signals","tags":["php","developer-guide"],"ssdi":[],"markdown_content":"\nUse the `#[SignalMethod]` annotation to handle Signals in the Workflow interface:\n\n```php\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private bool $value;\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        yield Workflow::await(fn()=> $this->value);\n        return 'OK';\n    }\n\n    #[Workflow\\SignalMethod]\n    public function setValue(bool $value)\n    {\n        $this->value = $value;\n    }\n}\n```\n\nIn the preceding example, the Workflow updates the protected value.\nThe main Workflow coroutine waits for the value to change by using the `Workflow::await()` function.\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-handle-workflow-logic-requirements-in-php.md","id":"php/how-to-handle-workflow-logic-requirements-in-php","title":"How to handle Workflow logic requirements in PHP","label":"Activity Execution","ssdi":[],"markdown_content":"\n\\*\\*Temporal uses the [Microsoft Azure Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover the state of a Workflow object including its local variable values.\n\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nWhen replaying, side effects (such as Activity invocations) are ignored because they are already recorded in the Workflow event history.\nWhen writing Workflow logic, the replay is not visible, so the code should be written since it executes only once.\nThis design puts the following constraints on the Workflow implementation:\n\n- Do not use any mutable global variables because multiple instances of Workflows are executed in parallel.\n- Do not call any non-deterministic functions like non seeded random or `UUID` directly from the Workflow code.\n\nAlways do the following in the Workflow implementation code:\n\n- Don’t perform any IO or service calls as they are not usually deterministic. Use Activities for this.\n- Only use `Workflow::now()` to get the current time inside a Workflow.\n- Call `yield Workflow::timer()` instead of `sleep()`.\n- Do not use any blocking SPL provided by PHP (i.e. `fopen`, `PDO`, etc) in **Workflow code**.\n- Use `yield Workflow::getVersion()` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already open Workflows.\n- Don’t access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\nWorkflow method arguments and return values are serializable to a byte array using the provided [DataConverter](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html) interface.\nThe default implementation uses JSON serializer, but you can use any alternative serialization mechanism.\n\nMake sure to annotate your `WorkflowMethod` using `ReturnType` to specify concrete return type.\n\n> You can not use the default return type declaration as Workflow methods are generators.\n\nThe values passed to Workflows through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to Workflow workers with every event that the Workflow logic needs to process.\nA large execution history can thus adversely impact the performance of your Workflow.\nTherefore, be mindful of the amount of data that you transfer via Activity invocation parameters or return values.\nOtherwise, no additional limitations exist on Activity implementations.\\*\\*\n","is_empty":false},{"file_name":"how-to-mock-activities-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-mock-activities-in-php.md","id":"php/how-to-mock-activities-in-php","title":"How to mock Activities in PHP","description":"To mock an Activity in PHP, follow the instructions in this article.","label":"Mock Activities","tags":["developer-guide","sdk","php"],"ssdi":[],"markdown_content":"\n**RoadRunner config**\n\nTo mock an Activity in PHP, use [RoadRunner Key-Value storage](https://github.com/spiral/roadrunner-kv) and add the following lines to your `tests/.rr.test.yaml` file.\n\n```yaml\n# tests/.rr.test.yaml\nkv:\n  test:\n    driver: memory\n    config:\n      interval: 10\n```\n\nIf you want to be able to mock Activities, use `WorkerFactory` from the `Temporal\\Testing` Namespace\nin your PHP Worker:\n\n```php\n// worker.test.php\nuse Temporal\\Testing\\WorkerFactory;\n\n$factory = WorkerFactory::create();\n$worker = $factory->newWorker();\n\n$worker->registerWorkflowTypes(MyWorkflow::class);\n$worker->registerActivity(MyActivity::class);\n$factory->run();\n```\n\nThen, in your tests to mock an Activity, use the`ActivityMocker` class.\n\nAssume we have the following Activity:\n\n```php\n#[ActivityInterface(prefix: \"SimpleActivity.\")]\ninterface SimpleActivityInterface\n{\n    #[ActivityMethod('doSomething')]\n    public function doSomething(string $input): string;\n```\n\nTo mock it in the test, you can do this:\n\n```php\nfinal class SimpleWorkflowTestCase extends TestCase\n{\n    private WorkflowClient $workflowClient;\n    private ActivityMocker $activityMocks;\n\n    protected function setUp(): void\n    {\n        $this->workflowClient = new WorkflowClient(ServiceClient::create('localhost:7233'));\n        $this->activityMocks = new ActivityMocker();\n\n        parent::setUp();\n    }\n\n    protected function tearDown(): void\n    {\n        $this->activityMocks->clear();\n        parent::tearDown();\n    }\n\n    public function testWorkflowReturnsUpperCasedInput(): void\n    {\n        $this->activityMocks->expectCompletion('SimpleActivity.doSomething', 'world');\n        $workflow = $this->workflowClient->newWorkflowStub(SimpleWorkflow::class);\n        $run = $this->workflowClient->start($workflow, 'hello');\n        $this->assertSame('world', $run->getResult('string'));\n    }\n}\n```\n\nIn the preceding test case, we do the following:\n\n1. Instantiate `ActivityMocker` in the `setUp()` method of the test.\n2. Clear the cache after each test in `tearDown()`.\n3. Mock an Activity call to return a string `world`.\n\nTo mock a failure, use the `expectFailure()` method:\n\n```php\n$this->activityMocks->expectFailure('SimpleActivity.echo', new \\LogicException('something went wrong'));\n```\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-register-types-with-a-worker-in-php.md","id":"php/how-to-register-types-with-a-worker-in-php","title":"How to register types with a Worker in PHP","description":"Use `registerWorkflowTypes()` to register Workflow Type and `registerActivity()` to register Activity implementation with Workers.","label":"Register Types","tags":["developer-guide","php","workers"],"ssdi":[],"markdown_content":"\nWorker listens on a Task Queue and hosts both Workflow and Activity implementations:\n\n```php\n// Workflows are stateful. So you need a type to create instances:\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n// Activities are stateless and thread safe:\n$worker->registerActivity(App\\DemoActivity::class);\n```\n\nIn case an activity class requires some external dependencies provide a callback - factory\nthat creates or builds a new activity instance. The factory should be a callable which accepts\nan instance of ReflectionClass with an activity class which should be created.\n\n```php\n$worker->registerActivity(\n    App\\DemoActivity::class,\n    fn(ReflectionClass $class) => $container->create($class->getName())\n);\n```\n\nIf you want to clean up some resources after activity is done, you may register a finalizer. This callback is called\nafter each activity invocation:\n\n```php\n$worker->registerActivityFinalizer(fn() => $kernel->showtdown());\n```\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-remove-search-attributes-from-a-workflow-in-php.md","id":"php/how-to-remove-search-attributes-from-a-workflow-in-php","title":"How to remove Search Attributes from a Workflow in PHP","label":"Remove Search Attributes","ssdi":[],"markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array `[]`.\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-send-a-signal-from-a-client-in-php.md","id":"php/how-to-send-a-signal-from-a-client-in-php","title":"How to send a Signal from a Client in PHP","description":"To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `#[SignalMethod]` in the Workflow interface, from the Client code.","label":"Send Signal from Client","tags":["php","developer-guide"],"ssdi":[],"markdown_content":"\nTo send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `#[SignalMethod]` in the Workflow interface, from the Client code.\n\nTo send a Signal to a Workflow, use `WorkflowClient->newWorkflowStub` or `WorkflowClient->newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient->newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with Workflow Id to send Signals to already running Workflows.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n\nSee [Handle Signal](/php/handle-signal) for details on how to handle Signals in a Workflow.\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-send-a-signal-from-a-workflow-in-php.md","id":"php/how-to-send-a-signal-from-a-workflow-in-php","title":"How to send Signal a Workflow in PHP","label":"Signal a Workflow","ssdi":[],"markdown_content":"\nTo send signal to a Workflow use `WorkflowClient`->`newWorkflowStub` or `WorkflowClient`->`newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient`->`newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with Workflow Id to send\nSignals to a running Workflow.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-send-a-signal-with-start-in-php.md","id":"php/how-to-send-a-signal-with-start-in-php","title":"How to send Signal-With-Start in PHP","label":"Signal-With-Start","ssdi":[],"markdown_content":"\nIn cases where you may not know if a Workflow is running, and want to send a Signal to it, use `startwithSignal`.\nIf a running Workflow exists, the `startwithSignal` API sends the Signal.\nIf there is no running Workflow, the API starts a new Workflow Run and delivers the Signal to it.\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->startWithSignal(\n    $workflow,\n    'setValue',\n    [true], // signal arguments\n    [] // start arguments\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-cron-schedule-in-php.md","id":"php/how-to-set-a-cron-schedule-in-php","title":"How to set a CRON schedule in PHP","label":"Activity Execution","ssdi":[],"markdown_content":"\nSet your Cron Schedule with `CronSchedule('* * * * *')`.\n\nThe following example sets a Cron Schedule in PHP:\n\n```php\n  $workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()\n          ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n          ->withCronSchedule('* * * * *')\n          // Execution timeout limits total time. Cron will stop executing after this timeout.\n          ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n          // Run timeout limits duration of a single workflow invocation.\n          ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n  );\n\n  $output->writeln(\"Starting <comment>CronWorkflow</comment>... \");\n\n  try {\n      $run = $this->workflowClient->start($workflow, 'Antony');\n      // ...\n  }\n```\n\nSetting `withCronSchedule` turns the Workflow Execution into a Temporal Cron Job.\nFor more information, see the [PHP samples](https://github.com/temporalio/samples-php/tree/master/app/src/Cron) for example code or the PHP SDK `WorkflowOptions` [source code](https://github.com/temporalio/sdk-php/blob/master/src/Client/WorkflowOptions.php).\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-for-an-activity-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-heartbeat-for-an-activity-in-php.md","id":"php/how-to-set-a-heartbeat-for-an-activity-in-php","title":"How to set a Heartbeat for an Activity in PHP","label":"Heartbeat an Activity","ssdi":[],"markdown_content":"\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-heartbeat-timeout-in-php.md","id":"php/how-to-set-a-heartbeat-timeout-in-php","title":"How to set a Heartbeat Timeout in PHP","label":"Heartbeat Timeout","ssdi":[],"markdown_content":"\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-parent-close-policy-in-php.md","id":"php/how-to-set-a-parent-close-policy-in-php","title":"How to set a Parent Close Policy in PHP","description":"Create an instance of `ChildWorkflowOptions` and use `withParentClosePolicy()` method to apply the options to a new Child Workflow object.","label":"Parent Close Policy","tags":["php","developer-guide","how-to"],"ssdi":[],"markdown_content":"\nIn PHP, a [Parent Close Policy](/concepts/what-is-a-parent-close-policy) is set via the `ChildWorkflowOptions` object and `withParentClosePolicy()` method.\nThe possible values can be obtained from the [`ParentClosePolicy`](https://github.com/temporalio/sdk-php/blob/master/src/Workflow/ParentClosePolicy.php) class.\n\n- `POLICY_TERMINATE`\n- `POLICY_ABANDON`\n- `POLICY_REQUEST_CANCEL`\n\nThen `ChildWorkflowOptions` object is used to create a new Child Workflow object:\n\n```php\n$child = Workflow::newUntypedChildWorkflowStub(\n    'child-workflow',\n    ChildWorkflowOptions::new()\n        ->withParentClosePolicy(ParentClosePolicy::POLICY_ABANDON)\n);\n\nyield $child->start();\n```\n\nIn the snippet above we:\n\n1. Create a new untyped Child Workflow stub with `Workflow::newUntypedChildWorkflowStub`.\n2. Provide `ChildWorkflowOptions` object with Parent Close Policy set to `ParentClosePolicy::POLICY_ABANDON`.\n3. Start Child Workflow Execution asynchronously using `yield` and method `start()`.\n\nWe need `yield` here to ensure that a Child Workflow Execution starts before the parent closes.\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-schedule-to-close-timeout-in-php.md","id":"php/how-to-set-a-schedule-to-close-timeout-in-php","title":"How to set Schedule-to-Close Timeout in PHP","label":"Schedule-to-Start Timeout","ssdi":[],"markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-schedule-to-start-timeout-in-php.md","id":"php/how-to-set-a-schedule-to-start-timeout-in-php","title":"How to set Schedule-to-Start Timeout in PHP","label":"Schedule-to-Start Timeout","ssdi":[],"markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToStartTimeout` set to 10 seconds.\n\n```php\n// Creating a stub for the activity.\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()\n                ->withScheduleToStartTimeout(CarbonInterval::seconds(10))\n        );\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-start-to-close-timeout-in-php.md","id":"php/how-to-set-a-start-to-close-timeout-in-php","title":"How to set Start-to-Close Timeout in PHP","label":"Start-to-Close Timeout","ssdi":[],"markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `StartToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(CarbonInterval::seconds(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-execution-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-workflow-execution-timeout-in-php.md","id":"php/how-to-set-a-workflow-execution-timeout-in-php","title":"How to set Workflow Execution Timeout in PHP","label":"Workflow Execution Timeout","ssdi":[],"markdown_content":"\nThe following code example creates a new Workflow and sets the Workflow Id.\nThen it sets the Workflow Id Reuse Policy and the Workflow Execution Timeout to 2 minutes.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    DynamicSleepWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(DynamicSleepWorkflow::WORKFLOW_ID)\n        ->withWorkflowIdReusePolicy(WorkflowIdReusePolicy::WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-workflow-id-in-php.md","id":"php/how-to-set-a-workflow-id-in-php","title":"How to set a Workflow Id in PHP","label":"Workflow Id","ssdi":[],"markdown_content":"\nThe following code example grabs the `userID` as an input and uses it to start the Workflow. The `userID` is used as Workflow Id. You can use this to cancel your Workflow later.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(string $userID);\n}\n```\n\nThe following code example, uses the input parameter `userID` as the Workflow Id.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(\n        string $userID\n    );\n}\n```\n\nYou can also set the Workflow Id as a constant, for example:\n\n```php\npublic const WORKFLOW_ID = Your-Workflow-Id\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-run-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-workflow-run-timeout-in-php.md","id":"php/how-to-set-a-workflow-run-timeout-in-php","title":"How to set Workflow Run Timeout in PHP","label":"Workflow Run Timeout","ssdi":[],"markdown_content":"\n`WorkflowRunTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-workflow-task-queue-in-php.md","id":"php/how-to-set-a-workflow-task-queue-in-php","title":"How to set a Workflow Task Queue in PHP","label":"Task Queues","ssdi":[],"markdown_content":"\nIn PHP, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```php\n// Create new Workflow Options and set the Task Queue\n$workflowOptions = WorkflowOptions::new()\n  ->withTaskQueue(\"Workflow-Task-Queue-1\")\n  // ...\n\n$yourWorkflow = $workflowClient->newWorkflowStub(\n  YourWorkflowInterface::class,\n  $workflowOptions\n);\n\n$result = $yourWorkflow->workflowMethod();\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```php\nuse Temporal\\WorkerFactory;\n\n// Create a Worker Factory\n$factory = WorkerFactory::create();\n\n// Set the Task Queue when creating the Worker\n$worker = $factory->newWorker(\"Workflow-Task-Queue-1\");\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(YourWorkflow::class);\n\n// start primary loop\n$factory->run();\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```php\nclass YourWorkflow implements YourWorkflowInterface\n{\n  private $yourActivity;\n\n  public function __construct()\n  {\n    // Create Activity options and set the Task Queue\n    $activityOptions = ActivityOptions::new()\n      ->withTaskQueue(\"Activity-Task-Queue-1\")\n      // ...\n\n    // Create a new Activity Stub and pass the options\n    $this->yourActivity = Workflow::newActivityStub(\n      YourActivityInterface::class,\n      $activityOptions\n    );\n  }\n\n  public function workflowMethod(): \\Generator\n  {\n    // Call the Activity\n    return yield $this->yourActivity->activityMethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```php\n//Create new Child Workflow Options and set the Task Queue\n$childWorkflowOptions = ChildWorkflowOptions::new()\n    ->withTaskQueue(\"Child-Workflow-Task-Queue-1\")\n    // ...\n\n// Create a new Child Workflow Stub and set the Task Queue\n$childWorkflow = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    $childWorkflowOptions\n);\n\n// Call the Child Workflow method\n$promise = $childWorkflow->workflowMethod();\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-a-workflow-task-timeout-in-php.md","id":"php/how-to-set-a-workflow-task-timeout-in-php","title":"How to set Workflow Task Timeout in PHP","label":"Workflow Task Timeout","ssdi":[],"markdown_content":"\n`WorkflowTaskTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowTaskTimeout(CarbonInterval::minute(1))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-activity-retry-options-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-activity-retry-options-in-php.md","id":"php/how-to-set-activity-retry-options-in-php","title":"How to set Activity Retry Options in PHP","label":"Activity Retry Options","ssdi":[],"markdown_content":"\nTo set an Activity Retry, set `{@link RetryOptions}` on `{@link ActivityOptions}`.\nThe follow example creates a new Activity with the given options.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(10))\n        ->withRetryOptions(\n            RetryOptions::new()\n                ->withInitialInterval(CarbonInterval::seconds(1))\n                ->withMaximumAttempts(5)\n                ->withNonRetryableExceptions([\\InvalidArgumentException::class])\n        )\n);\n}\n```\n\nFor an executable code sample, see [ActivityRetry sample](https://github.com/temporalio/samples-php/tree/master/app/src/ActivityRetry) in the PHP samples repository.\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-activity-timeouts-in-php.md","id":"php/how-to-set-activity-timeouts-in-php","title":"How to set Activity Timeouts in PHP","label":"Activity Timeouts","ssdi":[],"markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\n\nAvailable timeouts are:\n\n- withScheduleToCloseTimeout()\n- withStartToCloseTimeout()\n- withScheduleToStartTimeout()\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    // Set Activity Timeout duration\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(2))\n        // ->withStartToCloseTimeout(CarbonInterval::seconds(2))\n        // ->withScheduleToStartTimeout(CarbonInterval::seconds(10))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-asynchronous-activity-completion-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-asynchronous-activity-completion-in-php.md","id":"php/how-to-set-asynchronous-activity-completion-in-php","title":"How to set asynchronous Activity completion in PHP","description":"Set asynchronous Activity completion in PHP.","label":"Asynchronous Activity completion","tags":["php","how-to"],"ssdi":[],"markdown_content":"\nSometimes Workflows need to perform certain operations in parallel.\n\nInvoking activity stub without the use of `yield` will return the Activity result promise which can be resolved at later moment.\nCalling `yield` on promise blocks until a result is available.\n\n> Activity promise also exposes `then` method to construct promise chains.\n> Read more about Promises [here](https://github.com/reactphp/promise).\n\nAlternatively you can explicitly wrap your code (including `yield` constucts) using `Workflow::async` which will execute nested code in parallel with main Workflow code.\nCall `yeild` on Promise returned by `Workflow::async` to merge execution result back to primary Workflow method.\n\n```php\npublic function greet(string $name): \\Generator\n{\n    // Workflow::async runs it's activities and child workflows in a separate coroutine. Use keyword yield to merge\n    // it back to parent process.\n\n    $first = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Bye', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    $second = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hola', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Chao', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    // blocks until $first and $second complete\n    return (yield $first) . \"\\n\" . (yield $second);\n}\n```\n\n**Async completion**\n\nThere are certain scenarios when moving on from an Activity upon completion of its function is not possible or desirable.\nFor example, you might have an application that requires user input to complete the Activity.\nYou could implement the Activity with a polling mechanism, but a simpler and less resource-intensive implementation is to asynchronously complete a Temporal Activity.\n\nThere are two parts to implementing an asynchronously completed Activity:\n\n1. The Activity provides the information necessary for completion from an external system and notifies the Temporal service that it is waiting for that outside callback.\n2. The external service calls the Temporal service to complete the Activity.\n\nThe following example demonstrates the first part:\n\n<!--SNIPSTART samples-php-async-activity-completion-activity-class-->\n\n[app/src/AsyncActivityCompletion/GreetingActivity.php](https://github.com/temporalio/samples-php/blob/master/app/src/AsyncActivityCompletion/GreetingActivity.php)\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    private LoggerInterface $logger;\n\n    public function __construct()\n    {\n        $this->logger = new Logger();\n    }\n    /**\n     * Demonstrates how to implement an Activity asynchronously.\n     * When {@link Activity::doNotCompleteOnReturn()} is called,\n     * the Activity implementation function that returns doesn't complete the Activity.\n     */\n    public function composeGreeting(string $greeting, string $name): string\n    {\n        // In real life this request can be executed anywhere. By a separate service for example.\n        $this->logger->info(sprintf('GreetingActivity token: %s', base64_encode(Activity::getInfo()->taskToken)));\n        // Send the taskToken to the external service that will complete the Activity.\n        // Return from the Activity a function indicating that Temporal should wait\n        // for an async completion message.\n        Activity::doNotCompleteOnReturn();\n        // When doNotCompleteOnReturn() is invoked the return value is ignored.\n        return 'ignored';\n    }\n}\n```\n\n<!--SNIPEND-->\n\nThe following code demonstrates how to complete the Activity successfully using `WorkflowClient`:\n\n<!--SNIPSTART samples-php-async-activity-completion-completebytoken-->\n\n[app/src/AsyncActivityCompletion/CompleteCommand.php](https://github.com/temporalio/samples-php/blob/master/app/src/AsyncActivityCompletion/CompleteCommand.php)\n\n```php\n$client = $this->workflowClient->newActivityCompletionClient();\n// Complete the Activity.\n$client->completeByToken(\n    base64_decode($input->getArgument('token')),\n    $input->getArgument('message')\n);\n```\n\n<!--SNIPEND-->\n\nTo fail the Activity, you would do the following:\n\n```php\n// Fail the Activity.\n$activityClient->completeExceptionallyByToken($taskToken, new \\Error(\"activity failed\"));\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-timers-in-php.md","id":"php/how-to-set-timers-in-php","title":"How to set Timers in PHP","description":"To set a Timer in PHP, use `Workflow::timer()`.","label":"Timers","tags":["timers","sleep"],"ssdi":[],"markdown_content":"\nTo set a Timer in PHP, use `Workflow::timer()` and pass the number of seconds you want to wait before continuing.\n\nThe following example yields a sleep method for 5 minutes.\n\n```php\nyield Workflow::timer(300); // sleep for 5 minutes\n```\n\nYou cannot set a Timer invocation inside the `await` or `awaitWithTimeout` methods.\n","is_empty":false},{"file_name":"how-to-set-workflow-retry-options-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-workflow-retry-options-in-php.md","id":"php/how-to-set-workflow-retry-options-in-php","title":"How to set Workflow Retry Options in PHP","description":"A Retry Policy can be configured with an instance of the `RetryOptions` object.","label":"Workflow Retry Options","tags":["php","how-to","developer-guide"],"ssdi":[],"markdown_content":"\nA Retry Policy can be configured with an instance of the `RetryOptions` object.\nTo enable retries for a Workflow, you need to provide a Retry Policy object via `ChildWorkflowOptions` for Child Workflows or via `WorkflowOptions` for top-level Workflows.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()->withRetryOptions(\n        RetryOptions::new()->withInitialInterval(120)\n      )\n);\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-set-workflow-timeouts-in-php.md","id":"php/how-to-set-workflow-timeouts-in-php","title":"How to set Workflow Timeouts in PHP","description":"Create an instance of WorkflowOptions.","label":"Workflow Timeouts","tags":["php","how-to"],"ssdi":[],"markdown_content":"\nCreate an instance of `WorkflowOptions` in the Client code and set your timeout.\n\nAvailable timeouts are:\n\n- `withWorkflowExecutionTimeout()`\n- `withWorkflowRunTimeout()`\n- `withWorkflowTaskTimeout()`\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    DynamicSleepWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(DynamicSleepWorkflow::WORKFLOW_ID)\n        ->withWorkflowIdReusePolicy(WorkflowIdReusePolicy::WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n        // Set Workflow Timeout duration\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(2))\n        // ->withWorkflowRunTimeout(CarbonInterval::minute(2))\n        // ->withWorkflowTaskTimeout(CarbonInterval::minute(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-skip-time-set-up-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-skip-time-set-up-in-php.md","id":"php/how-to-skip-time-set-up-in-php","title":"How to set up time skipping in PHP","description":"To set up time skipping, create `bootstrap.php` and add it to `phpunit.xml`.","label":"Set up time skipping","tags":["developer-guide","sdk","PHP"],"ssdi":[],"markdown_content":"\n1. In the `tests` folder, create `bootstrap.php` with the following contents:\n\n```php\ndeclare(strict_types=1);\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse Temporal\\Testing\\Environment;\n\n$environment = Environment::create();\n$environment->start();\nregister_shutdown_function(fn () => $environment->stop());\n```\n\nIf you don't want to run the test server with all of your tests, you can add a condition to start a test only if the `RUN_TEMPORAL_TEST_SERVER` environment variable is present:\n\n```php\nif (getenv('RUN_TEMPORAL_TEST_SERVER') !== false) {\n    $environment = Environment::create();\n    $environment->start('./rr serve -c .rr.silent.yaml -w tests');\n    register_shutdown_function(fn() => $environment->stop());\n}\n```\n\n2. Add `bootstrap.php` and the `TEMPORAL_ADDRESS` environment variable to `phpunit.xml`:\n\n```xml\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/9.3/phpunit.xsd\"\n         bootstrap=\"tests/bootstrap.php\"\n>\n    <php>\n        <env name=\"TEMPORAL_ADDRESS\" value=\"127.0.0.1:7233\" />\n    </php>\n</phpunit>\n```\n\n3. Add the test server executable to `.gitignore`:\n\n```gitignore\ntemporal-test-server\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-spawn-a-child-workflow-execution-in-php.md","id":"php/how-to-spawn-a-child-workflow-execution-in-php","title":"How to spawn a Child Workflow Execution in PHP","label":"Child Workflow Execution","ssdi":[],"markdown_content":"\nBesides Activities, a Workflow can also start other Workflows.\n\n`Workflow::executeChildWorkflow` and `Workflow::newChildWorkflowStub` enables the scheduling of other Workflows from within a Workflow's implementation.\nThe parent Workflow has the ability to monitor and impact the lifecycle of the Child Workflow, similar to the way it does for an Activity that it invoked.\n\n```php\n// Use one stub per child workflow run\n$child = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    ChildWorkflowOptions::new()\n        // Do not specify WorkflowId if you want Temporal to generate a unique Id\n        // for the child execution.\n        ->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW')\n        ->withExecutionStartToCloseTimeout(DateInterval::createFromDateString('30 minutes'))\n);\n\n// This is a non blocking call that returns immediately.\n// Use yield $child->workflowMethod(name) to call synchronously.\n$promise = $child->workflowMethod('value');\n\n// Do something else here.\ntry{\n    $value = yield $promise;\n} catch(TemporalException $e) {\n    $logger->error('child workflow failed');\n    throw $e;\n}\n```\n\nLet's take a look at each component of this call.\n\nBefore calling `$child->workflowMethod()`, you must configure `ChildWorkflowOptions` for the invocation.\nThese options customize various execution timeouts, and are passed into the Workflow stub defined by the `Workflow::newChildWorkflowStub`.\nOnce stub created you can invoke its Workflow method based on attribute `WorkflowMethod`.\n\nThe method call returns immediately and returns a `Promise`.\nThis allows you to execute more code without having to wait for the scheduled Workflow to complete.\n\nWhen you are ready to process the results of the Workflow, call the `yield $promise` method on the returned promise object.\n\nWhen a parent Workflow is cancelled by the user, the Child Workflow can be cancelled or abandoned based on a configurable child policy.\n\nYou can also skip the stub part of Child Workflow initiation and use `Workflow::executeChildWorkflow` directly:\n\n```php\n// Use one stub per child workflow run\n$childResult = yield Workflow::executeChildWorkflow(\n    'ChildWorkflowName',\n    ['args'],\n    ChildWorkflowOptions::new()->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW'),\n    Type::TYPE_STRING // optional: defines the return type\n);\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-spawn-a-workflow-execution-in-php.md","id":"php/how-to-spawn-a-workflow-execution-in-php","title":"How to spawn a Workflow Execution in PHP","description":"Use the `Temporal\\Client\\WorkflowClient` to start a Workflow both synchronously and asynchronously.","label":"Workflow Execution","tags":["developer-guide","php"],"ssdi":[],"markdown_content":"\nWorkflows can be started both synchronously and asynchronously.\nYou can use typed or untyped Workflows stubs available via `Temporal\\Client\\WorkflowClient`.\nTo create a Workflow Client:\n\n```php\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$workflowClient = WorkflowClient::create(ServiceClient::create('localhost:7233'));\n```\n\n**Synchronous start**\n\nA synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the\ninvocation process and will continue executing even if the waiting process crashes or stops.\n\nBe sure to acquire the Workflow interface or class name you want to start.\nFor example:\n\n```php\n#[WorkflowInterface]\ninterface AccountTransferWorkflowInterface\n{\n    #[WorkflowMethod(name: \"MoneyTransfer\")]\n    #[ReturnType('int')]\n    public function transfer(\n        string $fromAccountId,\n        string $toAccountId,\n        string $referenceId,\n        int $amountCents\n    );\n}\n```\n\nTo start the Workflow in sync mode:\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$result = $accountTransfer->transfer(\n    'fromID',\n    'toID',\n    'refID',\n    1000\n);\n```\n\n**Asynchronous start**\n\nAn asynchronous start initiates a Workflow Execution and immediately returns to the caller without waiting for a result.\nThis is the most common way to start Workflows in a live environment.\n\nTo start a Workflow asynchronously, pass the Workflow stub instance and start parameters into the `WorkflowClient`->`start` method.\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$run = $this->workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n```\n\nAfter the Workflow is started, you can receive the Workflow Id via the `WorkflowRun` object returned by the `start` method:\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getExecution()->getID());\n```\n\n**Recurring start**\n\nYou can start a Workflow Execution on a regular schedule with [the CronSchedule option](/php/cron-jobs).\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-spawn-an-activity-execution-in-php.md","id":"php/how-to-spawn-an-activity-execution-in-php","title":"How to spawn an Activity Execution in PHP","label":"Spawn an Activity Execution","ssdi":[],"markdown_content":"\nActivity implementation is an implementation of an Activity interface.\nThe following code example, uses a constructor that takes an Amazon S3 client and a local directory, and uploads a file to the S3 bucket.\nThen, the code uses a function to download a file from the S3 bucket passing a bucket name, remote name, and local name as arguments.\nFinally, it uses a function that takes a local file name as an argument and returns a string.\n\n```php\n// An implementation of an Activity interface.\nclass FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n    private S3Client $s3Client;\n\n    private string $localDirectory;\n\n    public function __construct(S3Client $s3Client, string $localDirectory) {\n        $this->s3Client = $s3Client;\n        $this->localDirectory = $localDirectory;\n    }\n\n    // Uploading a file to S3.\n    public function upload(string $bucketName, string $localName, string $targetName): void\n    {\n        $this->s3Client->putObject(\n            $bucketName,\n            $targetName,\n            fopen($this->localDirectory . $localName, 'rb+')\n        );\n    }\n\n// Downloading a file from S3.\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->s3Client->downloadObject(\n            $bucketName,\n            $remoteName,\n            fopen($this->localDirectory .$localName, 'wb+')\n        );\n    }\n\n// A function that takes a local file name as an argument and returns a string.\n    public function processFile(string $localName): string\n    {\n        // Implementation omitted for brevity.\n        return compressFile($this->localDirectory . $localName);\n    }\n\n    public function deleteLocalFile(string $fileName): void\n    {\n        unlink($this->localDirectory . $fileName);\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-php.md","id":"php/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-php","title":"How to upsert Search Attributes in PHP","label":"Upsert Search Attributes","ssdi":[],"markdown_content":"\nTo upsert Search Attributes within a Workflow, use `Workflow::upsertSearchAttributes()`.\n\n```php\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    public function getGreeting(string $name)\n    {\n        Workflow::upsertSearchAttributes(\n            [\n                'CustomKeywordField' => 'attr1-value',\n                'CustomIntField' => 123,\n            ]\n        );\n\n        // ...\n    }\n}\n```\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/index.md","id":"php/index","title":"How to use the Temporal PHP SDK","description":"Add the Temporal PHP SDK to your project.","tags":["developer-guide","php"],"ssdi":[],"markdown_content":"\n[![CI Status](https://github.com/temporalio/php-sdk/workflows/Unit/badge.svg)](https://github.com/temporalio/php-sdk/actions)\n[![Stable Release](https://poser.pugx.org/temporal/sdk/version)](https://packagist.org/packages/temporal/sdk)\n[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php?ref=badge_shield)\n\nThe Temporal PHP SDK is available as composer package and can be installed using the following command in a root of your project:\n\n```bash\ncomposer require temporal/sdk\n```\n\nThe Temporal PHP SDK requires the RoadRunner 2.0 application server and supervisor to run Activities and Workflows in a scalable way.\n\nInstall RoadRunner manually by downloading its binary from the [release page](https://github.com/roadrunner-server/roadrunner/releases/tag/v1.9.2).\n\nOr install RoadRunner through the CLI:\n\n```bash\ncomposer require spiral/roadrunner:v2.0 nyholm/psr7\n./vendor/bin/rr get-binary\n```\n","is_empty":false},{"file_name":"introduction.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/introduction.md","id":"php/introduction","title":"PHP SDK introduction","label":"PHP SDK introduction","ssdi":[],"markdown_content":"\n:::info Try the Developer's guide\n\nThe majority of this information has moved into the [Developer's guide](/dev-guide/?lang=php).\n\nHowever, if you can't find what you are looking for there, we recommend checking this doc set as well.\n\n:::\n\n## Quick start\n\n1. Clone the [Temporal PHP SDK](https://github.com/temporalio/sdk-php) or add it as dependency to your project using a dependency management tool like composer:\n\n```composer\n\"require\": {\n    \"temporal/sdk\": \">=1.0\",\n  },\n```\n\n2. [Install and run the Temporal Server](/kb/all-the-ways-to-run-a-cluster) using `docker compose`.\n\n## Tutorials\n\n- You should orient yourself to the Hello World with [the PHP Hello World Walkthrough](https://learn.temporal.io/getting_started/php/hello_world_in_php/).\n- For those interested in distributed transactions, see the [Booking Saga Tutorial and code sample](https://learn.temporal.io/tutorials/php/booking_saga/).\n- For a more non-trivial discussion of an application, see [the Subscription Tutorial](https://learn.temporal.io/tutorials/php/subscriptions/) or [browse the code directly](https://github.com/temporalio/subscription-workflow-project-template-php).\n\nMuch more detailed API samples can be viewed in [the Samples Repo](https://github.com/temporalio/samples-php).\n\n## Resources\n\n- Join the `#php-sdk` channel on the [Temporal Slack](https://temporal.io/slack) or [open issues on GitHub](https://github.com/temporalio/sdk-php/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc).\n- PHP SDK samples\n  - [Beginner-advanced library](https://github.com/temporalio/samples-php#samples)\n  - [Subscription Workflow sample](https://github.com/temporalio/subscription-workflow-project-template-php)\n- Talks\n  - 🆕 PHPConf 2021: [Fault tolerant workflow orchestration on PHP](https://www.youtube.com/watch?v=pdxHkIqX62A)\n  - PHPConf 2020: [Designing hybrid Go/PHP applications using RoadRunner](https://www.youtube.com/watch?v=mj6d-IGzSYE)\n  - (Slides) [Distributed Workflows on PHP](https://docs.google.com/presentation/d/1NBZlnJFCc-PgYxQk0_YYxUTmfKgzUf6Z-XHXfPETLac/edit?usp=sharing)\n  - (Russian) [Orchestrate it! Complex business processes in PHP](https://www.youtube.com/watch?v=upL8o-OXYEc) (2 hour workshop)\n  - (Russian) [Orchestration and Murphy's Law: Handling Errors-Business Processes](https://www.youtube.com/watch?v=0NCMEaFMj_M) (2 hour workshop)\n  - (Russian) PHP Russia https://phprussia.ru/moscow/2021/abstracts/7390 (video pending)\n  - (Russian) [FWDays Keynote: Fault Tolerant Workflow Orchestration on PHP](https://fwdays.com/en/event/php-fwdays-2021/review/fault-tolerant-workflow-orchestration-on-php) (video pending)\n- The PHP SDK is often used with [Roadrunner](https://roadrunner.dev/) (maintained by [SpiralScout](https://github.com/spiral?type=source), the maintainers of the PHP SDK)\n\n## The basics\n\n- [Workflows](/php/workflows)\n\n- [Activities](/php/activities)\n\n- [Workers](/php/workers)\n\n- [Task Queues](/php/task-queues)\n\n- [Signals](/php/signals)\n\n- [Queries](/php/queries)\n","is_empty":false},{"file_name":"listen-to-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/listen-to-heartbeats.md","id":"php/listen-to-heartbeats","title":"Listen to Heartbeats","description":"When an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.","label":"Listen to Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.\n","is_empty":false},{"file_name":"logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/logging.md","id":"php/logging","title":"How to log from a Workflow","description":"Send logs and errors to a logging service, so that when things go wrong, you can see what happened.","label":"Logging","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nThe SDK core uses `WARN` for its default logging level.\n","is_empty":false},{"file_name":"manage-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/manage-namespaces.md","id":"php/manage-namespaces","title":"How to manage Namespaces","description":"You can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.","label":"Manage Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can manage your registered Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"metrics.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/metrics.md","id":"php/metrics","title":"How to emit metrics","description":"Each Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.","label":"Metrics","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.\nFor a complete list of metrics capable of being emitted, see the [SDK metrics reference](/references/sdk-metrics).\n\nMetrics can be scraped and stored in time series databases, such as:\n\n- [Prometheus](https://prometheus.io/docs/introduction/overview/)\n- [M3db](https://m3db.io/docs/)\n- [statsd](https://github.com/statsd/statsd)\n\nTemporal also provides a dashboard you can integrate with graphing services like [Grafana](https://grafana.com/docs/). For more information, see:\n\n- Temporal's implementation of the [Grafana dashboard](https://github.com/temporalio/dashboards)\n- [How to export metrics in Grafana](https://github.com/temporalio/helm-charts#exploring-metrics-via-grafana)\n","is_empty":false},{"file_name":"mock-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/mock-activities.md","id":"php/mock-activities","title":"How to mock Activities","description":"Mock an Activity by providing mock Activity implementations to the Worker.","label":"Mock Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMock the Activity invocation when unit testing your Workflows.\n\nWhen integration testing Workflows with a Worker, you can mock Activities by providing mock Activity implementations to the Worker.\n","is_empty":false},{"file_name":"mutable-side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/mutable-side-effects.md","id":"php/mutable-side-effects","title":"Mutable Side Effects","description":"Mutable Side Effects are a method of execution to produce non-deterministic code.","label":"Mutable Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMutable Side Effects execute the provided function once, and then it looks up the History of the value with the given Workflow ID.\n\n- If there is no existing value, then it records the function result as a value with the given Workflow Id on the History.\n- If there is an existing value, then it compares whether the existing value from the History has changed from the new function results, by calling the equals function.\n  - If the values are equal, then it returns the value without recording a new Marker Event\n  - If the values aren't equal, then it records the new value with the same ID on the History.\n\n:::note\n\nDuring a Workflow Execution, every new Side Effect call results in a new Marker recorded on the Workflow History; whereas Mutable Side Effects only records a new Marker on the Workflow History if the value for the Side Effect ID changes or is set the first time.\n\nDuring a Replay, Mutable Side Effects will not execute the function again. Instead, it returns the exact same value that was returned during the Workflow Execution.\n\n:::\n","is_empty":false},{"file_name":"namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/namespaces.md","id":"php/namespaces","title":"How to create and manage Namespaces","description":"You can create, update, deprecate or delete your Namespaces using either tctl or SDK APIs..","label":"Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can create, update, deprecate or delete your [Namespaces](/concepts/what-is-a-namespace) using either tctl or SDK APIs.\n\nUse Namespaces to isolate your Workflow Executions according to your needs.\nFor example, you can use Namespaces to match the development lifecycle by having separate `dev` and `prod` Namespaces.\nYou could also use them to ensure Workflow Executions between different teams never communicate - such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) to create and manage a Namespace from the UI, or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces from the command-line interface.\n\nOn self-hosted Temporal Cluster, you can register and manage your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"observability.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/observability.md","id":"php/observability","title":"How to use Temporal Observability features","description":"The observability section of the Temporal Developer's guide covers the many ways to view the current state of your Temporal Application—that is, ways to view which Workflow Executions are tracked by the Temporal Platform and the state of any specified Workflow Execution, either currently or at points of an execution","label":"Observability","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe observability section of the Temporal Developer's guide covers the many ways to view the current state of your [Temporal Application](/concepts/what-is-a-temporal-application)—that is, ways to view which [Workflow Executions](/workflows#workflow-execution) are tracked by the [Temporal Platform](/concepts/what-is-the-temporal-platform) and the state of any specified Workflow Execution, either currently or at points of an execution.\n\nThis section covers features related to viewing the state of the application, including:\n\n- [Metrics](#metrics)\n- [Tracing](#tracing)\n- [Logging](#logging)\n- [Visibility](#visibility)\n","is_empty":false},{"file_name":"parent-close-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/parent-close-policy.md","id":"php/parent-close-policy","title":"How to set a Parent Close Policy","description":"A Parent Close Policy determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).","label":"Parent Close Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Parent Close Policy](/concepts/what-is-a-parent-close-policy) determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).\n\nThe default Parent Close Policy option is set to terminate the Child Workflow Execution.\n","is_empty":false},{"file_name":"queries copy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/queries copy.md","id":"php/queries","title":"How to develop with Queries","description":"A Query is a synchronous operation that is used to get the state of a Workflow Execution.","label":"Queries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Query](/concepts/what-is-a-query) is a synchronous operation that is used to get the state of a Workflow Execution.\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/queries.md","id":"php/queries","title":"Queries in PHP","label":"Queries","tags":["php"],"ssdi":[],"markdown_content":"\n:::info Try the Developer's guide\n\nThe majority of this information has moved into the [Developer's guide](/dev-guide/?lang=php).\n\nHowever, if you can't find what you are looking for there, we recommend checking this doc set as well.\n\n:::\n\nIf a Workflow Execution has been stuck at a state for longer than an expected period of time, you\nmight want to query the current call stack. You can use the Temporal CLI to perform this query. For\nexample:\n\n`tctl --namespace samples-namespace workflow query -w your_workflow_id -r your_run_id -qt __stack_trace`\n\n> You can also access the stack trace from Temporal Web UI.\n\nThis command uses `__stack_trace`, which is a built-in query type supported by the Temporal client\nlibrary. You can add custom query types to handle queries such as querying the current state of a\nWorkflow, or querying how many Activities the Workflow has completed. To do this, you need to set\nup a query handler using method attribute `QueryMethod` or `Workflow::registerQueryHandler`.\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\QueryMethod]\n    public function getValue()\n    {\n        return 42;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // workflow code\n    }\n\n}\n```\n\nThe handler function can receive any number of input parameters, but all input parameters must be\nserializable. The following sample code sets up a query handler that handles the query type of\n`currentState`:\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private string $currentState;\n\n    #[Workflow\\QueryMethod('current_state')]\n    public function getCurrentState(): string\n    {\n        return $this->currentState;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // Your normal Workflow code begins here, and you update the currentState\n        // as the code makes progress.\n        $this->currentState = 'waiting timer';\n        try{\n            yield Workflow::timer(DateInterval::createFromDateString('1 hour'));\n        } catch (\\Throwable $e) {\n            $this->currentState = 'timer failed';\n            throw $e;\n        }\n\n        $yourActivity = Workflow::newActivityStub(\n            YourActivityInterface::class,\n            ActivityOptions::new()->withScheduleToStartTimeout(60)\n        );\n\n        $this->currentState = 'waiting activity';\n        try{\n            yield $YourActivity->doSomething('some input');\n        } catch (\\Throwable $e) {\n            $this->currentState = 'activity failed';\n            throw $e;\n        }\n\n        $this->currentState = 'done';\n\n        return null;\n    }\n}\n```\n\nYou can now query `current_state` by using the CLI:\n\n`tctl --namespace samples-namespace workflow query -w your_workflow_id -r your_run_id -qt current_state`\n\nYou can also issue a query from code using the `QueryWorkflow()` API on a Temporal client object.\n\nUse `WorkflowStub` to query Workflow instances from your client code.\n(You can apply this technique to running Workflows as well.)\n\n```php\n$workflow = $workflowClient->newWorkflowStub(\n    YourWorkflow::class,\n    WorkflowOptions::new()\n);\n\n$workflowClient->start($workflow);\n\nvar_dump($workflow->getCurrentState());\nsleep(60);\nvar_dump($workflow->getCurrentState());\n```\n","is_empty":false},{"file_name":"register-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/register-namespaces.md","id":"php/register-namespaces","title":"How to register Namespaces","description":"On Temporal Cloud, use the Temporal Cloud UI or tcld commands, and on self-hosted Temporal Cluster, use `tctl namespace register` or `RegisterNamespaceRequest` API to create Namespaces.","label":"Register Namespace","tags":["guide-context"],"ssdi":[],"markdown_content":"\nRegistering a Namespace creates a Namespace on the Temporal Cluster or Temporal Cloud.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to create Namespaces.\n\nOn self-hosted Temporal Cluster, you can register your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n","is_empty":false},{"file_name":"registering-types.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/registering-types.md","id":"php/registering-types","title":"How to register types","description":"How to register Workflow and Activity Types","label":"Register types","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it fails that Task.\nHowever, the failure of the Task does not cause the associated Workflow Execution to fail.\n","is_empty":false},{"file_name":"remove-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/remove-search-attributes.md","id":"php/remove-search-attributes","title":"How to remove a Search Attribute from a Workflow","description":"To remove a Search Attribute that was previously set, set it to an empty array.","label":"Remove Search Attribute","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array: `[]`.\n","is_empty":false},{"file_name":"replays.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/replays.md","id":"php/replays","title":"How to Replay a Workflow Execution","description":"Replay recreates the exact state of a Workflow Execution.","label":"Replay","tags":["guide-context"],"ssdi":[],"markdown_content":"\nReplay recreates the exact state of a Workflow Execution.\nYou can replay a Workflow from the beginning of its Event History.\n\nReplay succeeds only if the [Workflow Definition](/concepts/what-is-a-workflow-definition) is compatible with the provided history from a deterministic point of view.\n\nWhen you test changes to your Workflow Definitions, we recommend doing the following as part of your CI checks:\n\n1. Determine which Workflow Types or Task Queues (or both) will be targeted by the Worker code under test.\n2. Download the Event Histories of a representative set of recent open and closed Workflows from each Task Queue, either programmatically using the SDK client or via `tctl`.\n3. Run the Event Histories through replay.\n4. Fail CI if any error is encountered during replay.\n\nThe following are examples of fetching and replaying Event Histories:\n","is_empty":false},{"file_name":"required-activity-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/required-activity-timeout.md","id":"php/required-activity-timeout","title":"How to set the required Activity Timeouts","description":"The only required value that needs to be set is either a Schedule-To-Close Timeout or a Start-To-Close Timeout","label":"Required timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nActivity Execution semantics rely on several parameters.\nThe only required value that needs to be set is either a [Schedule-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) or a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout).\nThese values are set in the Activity Options.\n","is_empty":false},{"file_name":"retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/retries.md","id":"php/retries","title":"Activity and Workflow Retries","ssdi":[],"markdown_content":"\n:::info Try the Developer's guide\n\nThe majority of this information has moved into the [Developer's guide](/dev-guide/?lang=php).\n\nHowever, if you can't find what you are looking for there, we recommend checking this doc set as well.\n\n:::\n\nActivities and Workflows can fail for a number of expected and unexpected reasons.\nIn most failure cases, we want to retry the failed Activity or Child Workflow or even the parent Workflow.\nBy default, Temporal retries Activities, but not Workflows.\nTo change the default behavior, a custom Retry Policy can be provided.\n\nTo change the default behavior, a custom Retry Policy can be provided.\n\nA Retry Policy is defined as a `Temporal\\Common\\RetryOptions` object:\n\n```php\nuse Temporal\\Common\\RetryOptions;\n\n$retry = RetryOptions::new()\n\n    // Backoff interval for the first retry. If coefficient is 1.0\n    // then it is used for all retries. Required, no default value.\n    ->withInitialInterval(120) // seconds or DateInterval\n\n    // Coefficient used to calculate the next retry backoff interval.\n    // The next retry interval is previous interval multiplied\n    // by this coefficient.\n    // Must be 1 or larger. Default is 2.0.\n    ->withBackoffCoefficient(1)\n\n    // Maximum backoff interval between retries. Exponential backoff\n    // leads to interval increase. This value is the cap of the interval.\n    // Default is 100x of initial interval.\n    ->withMaximumInterval(600) // seconds or DateInterval\n\n    // Maximum number of attempts. When exceeded the retries stop even\n    // if not expired yet. If not set or set to 0, it means unlimited\n    ->withMaximumAttempts(10)\n\n    // Non-Retriable errors. This is optional. Temporal server will stop\n    // retry if error type matches this list.\n    //\n    // Note:\n    //  - cancellation is not a failure, so it won't be retried,\n    //  - only StartToClose or Heartbeat timeouts are retryable.\n    ->withNonRetryableExceptions([\\App\\DatabaseException::class]);\n```\n\nTo enable or customize retries, provide a custom Retry Policy as part of `ActivityOptions` or `ChildWorkflowOptions`.\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(10))\n        ->withRetryOptions(\n            RetryOptions::new()->withMaximumAttempts(10)\n        )\n);\n```\n\nIf an Activity heartbeat its progress before it failed, the retry attempt will have access to the progress information,\nso that the Activity implementation could resume from the failed step. Here's an example of how this can be implemented:\n\n```php\nuse Temporal\\Activity;\nuse Temporal\\DataConverter\\Type;\n// ...\n\n#[Activity\\ActivityInterface('YourActivity_')]\nclass YourActivity\n{\n  public function sampleActivity(int $startIndex, int $lastIndex)\n  {\n      if (Activity::hasHeartbeatDetails()) {\n          // Recover from finished progress.\n          $lastIndex = Activity::getHeartbeatDetails(Type::TYPE_INT);\n          $startIndex = $lastIndex + 1;// Start from next one.\n      }\n\n      // Normal Activity logic...\n      for ($i = $startIndex; $i < $lastIndex; $i++) {\n          // Code for processing item i goes here...\n          Activity::recordHeartbeat($i); // Report progress.\n      }\n  }\n}\n```\n\nTo enable retries for a Workflow, you need to provide a Retry Policy via `ChildWorkflowOptions` for Child Workflows or via `WorkflowOptions` for top-level Workflows.\n\nThere are some subtle nuances to how Workflow's history events are recorded when a `RetryOptions` is used.\nFor an Activity with a `RetryOptions`:\n\n- The `ActivityTaskScheduledEvent` will have extended `ScheduleToStartTimeout` and `ScheduleToCloseTimeout`.\n- The `ActivityTaskStartedEvent` will not show up in history until the Activity is completed or failed with no more retry.\n  This is to avoid filling the history with noise records of intermittent failures and retries.\n  For Activities being retried, `DescribeWorkflowExecution` will return a `PendingActivityInfo` that includes `attemptCount`.\n\nFor a Workflow with `RetryOptions`:\n\n- If a Workflow fails and a Retry Policy is configured for it, the Workflow Execution will be closed with a `ContinueAsNew` event.\n  This event will have the `ContinueAsNewInitiator` field set to `RetryOptions` and the new `RunId` for the next retry attempt.\n- The new attempt is created immediately.\n  But the first Workflow Task won't be scheduled until the end of the backoff duration.\n  That duration is recorded as the `firstWorkflowTaskBackoff` field of the new run's `WorkflowExecutionStartedEventAttributes` event.\n","is_empty":false},{"file_name":"run-a-dev-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/run-a-dev-worker.md","id":"php/run-a-dev-worker","title":"How to run Worker Processes","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run a dev Worker","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe [Worker Process](/concepts/what-is-a-worker-process) is where Workflow Functions and Activity Functions are executed.\n\n- Each [Worker Entity](/concepts/what-is-a-worker-entity) in the Worker Process must register the exact Workflow Types and Activity Types it may execute.\n- Each Worker Entity must also associate itself with exactly one [Task Queue](/concepts/what-is-a-task-queue).\n- Each Worker Entity polling the same Task Queue must be registered with the same Workflow Types and Activity Types.\n\nA [Worker Entity](/concepts/what-is-a-worker-entity) is the component within a Worker Process that listens to a specific Task Queue.\n\nAlthough multiple Worker Entities can be in a single Worker Process, a single Worker Entity Worker Process may be perfectly sufficient.\nFor more information, see the [Worker tuning guide](/dev-guide/worker-performance).\n\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it can make progress for either a Workflow Execution or an Activity Execution.\n","is_empty":false},{"file_name":"run-a-temporal-cloud-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/run-a-temporal-cloud-worker.md","id":"php/run-a-temporal-cloud-worker","title":"How to run a Temporal Cloud Worker","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run a Temporal Cloud Worker","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo run a Worker that uses [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"run-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/run-an-activity.md","id":"php/run-an-activity","title":"Run an Activity","description":"If an Activity references its context, you need to mock that context when testing in isolation.","label":"Run an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity references its context, you need to mock that context when testing in isolation.\n","is_empty":false},{"file_name":"schedule-backfill.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-backfill.md","id":"php/schedule-backfill","title":"How to Backfill a Scheduled Workflow","description":null,"label":"Backfill","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe backfill action executes Actions ahead of their specified time range. This command is useful when you need to execute a missed or delayed Action, or when you want to test the Workflow before its scheduled time.\n","is_empty":false},{"file_name":"schedule-create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-create.md","id":"php/schedule-create","title":"How to Create a Scheduled Workflow","description":null,"label":"Create","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe create action enables you to create a new Schedule. When you create a new Schedule, a unique Schedule ID is generated, which you can use to reference the Schedule in other Schedule commands.\n","is_empty":false},{"file_name":"schedule-delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-delete.md","id":"php/schedule-delete","title":"How to Delete a Scheduled Workflow","description":null,"label":"Delete","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe delete action enables you to delete a Schedule. When you delete a Schedule, it does not affect any Workflows that were started by the Schedule.\n","is_empty":false},{"file_name":"schedule-describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-describe.md","id":"php/schedule-describe","title":"How to Describe a Scheduled Workflow","description":null,"label":"Describe","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe describe action shows the current Schedule configuration, including information about past, current, and future Workflow Runs. This command is helpful when you want to get a detailed view of the Schedule and its associated Workflow Runs.\n","is_empty":false},{"file_name":"schedule-list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-list.md","id":"php/schedule-list","title":"How to List a Scheduled Workflow","description":null,"label":"List","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe list action lists all the available Schedules. This command is useful when you want to view a list of all the Schedules and their respective Schedule IDs.\n","is_empty":false},{"file_name":"schedule-pause.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-pause.md","id":"php/schedule-pause","title":"How to Pause a Scheduled Workflow","description":null,"label":"Pause","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe pause action enables you to pause and unpause a Schedule. When you pause a Schedule, all the future Workflow Runs associated with the Schedule are temporarily stopped. This command is useful when you want to temporarily halt a Workflow due to maintenance or any other reason.\n","is_empty":false},{"file_name":"schedule-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-to-close.md","id":"php/schedule-to-close","title":"How to set a Schedule-To-Close Timeout","description":"Use the Schedule-To-Close Timeout to limit the maximum duration of an Activity Execution.","label":"Schedule-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"schedule-to-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-to-start.md","id":"php/schedule-to-start","title":"How to set a Schedule-To-Start Timeout","description":"Use the Schedule-To-Start Timeout to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","label":"Schedule-To-Start Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.\n","is_empty":false},{"file_name":"schedule-trigger.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-trigger.md","id":"php/schedule-trigger","title":"How to Trigger a Scheduled Workflow","description":null,"label":"Trigger","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe trigger action triggers an immediate action with a given Schedule. By default, this action is subject to the Overlap Policy of the Schedule. This command is helpful when you want to execute a Workflow outside of its scheduled time.\n","is_empty":false},{"file_name":"schedule-update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedule-update.md","id":"php/schedule-update","title":"How to Update a Scheduled Workflow","description":null,"label":"Update","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe update action enables you to update an existing Schedule. This command is useful when you need to modify the Schedule's configuration, such as changing the start time, end time, or interval.\n","is_empty":false},{"file_name":"schedules.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/schedules.md","id":"php/schedules","title":"How to Schedule a Workflow","description":"Schedule a Workflow.","label":"Schedule a Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nScheduling Workflows is a crucial aspect of any automation process, especially when dealing with time-sensitive tasks. By scheduling a Workflow, you can automate repetitive tasks, reduce the need for manual intervention, and ensure timely execution of your business processes\n\nUse any of the following action to help Schedule a Workflow Execution and take control over your automation process.\n","is_empty":false},{"file_name":"search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/search-attributes.md","id":"php/search-attributes","title":"How to use Search Attributes","description":"Search Attributes enable complex List Filters to find the exact of Workflow Executions you are looking for.","label":"Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe typical method of retrieving a Workflow Execution is by its Workflow Id.\n\nHowever, sometimes you'll want to retrieve one or more Workflow Executions based on another property. For example, imagine you want to get all Workflow Executions of a certain type that have failed within a time range, so that you can start new ones with the same arguments.\n\nYou can do this with [Search Attributes](/concepts/what-is-a-search-attribute).\n\n- [Default Search Attributes](/concepts/what-is-a-search-attribute#default-search-attributes) like `WorkflowType`, `StartTime` and `ExecutionStatus` are automatically added to Workflow Executions.\n- _Custom Search Attributes_ can contain their own domain-specific data (like `customerId` or `numItems`).\n  - A few [generic Custom Search Attributes](/concepts/what-is-a-search-attribute#custom-search-attributes) like `CustomKeywordField` and `CustomIntField` are created by default in Temporal's [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose).\n\nThe steps to using custom Search Attributes are:\n\n- Create a new Search Attribute in your Cluster using `tctl search-attribute create` or the Cloud UI.\n- Set the value of the Search Attribute for a Workflow Execution:\n  - On the Client by including it as an option when starting the Execution.\n  - In the Workflow by calling `UpsertSearchAttributes`.\n- Read the value of the Search Attribute:\n  - On the Client by calling `DescribeWorkflow`.\n  - In the Workflow by looking at `WorkflowInfo`.\n- Query Workflow Executions by the Search Attribute using a [List Filter](/concepts/what-is-a-list-filter):\n  - [In `tctl`](/tctl-v1/workflow/list).\n  - In code by calling `ListWorkflowExecutions`.\n\nHere is how to query Workflow Executions:\n","is_empty":false},{"file_name":"send-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/send-query.md","id":"php/send-query","title":"How to send a Query","description":"Queries are sent from a Temporal Client.","label":"Send Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are sent from a Temporal Client.\n","is_empty":false},{"file_name":"send-signal-from-client.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/send-signal-from-client.md","id":"php/send-signal-from-client","title":"How to send a Signal from a Temporal Client","description":"When a Signal is sent successfully from the Temporal Client, the WorkflowExecutionSignaled Event appears in the Event History of the Workflow that receives the Signal.","label":"Send Signal from Client","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen a Signal is sent successfully from the Temporal Client, the [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Event History of the Workflow that receives the Signal.\n","is_empty":false},{"file_name":"send-signal-from-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/send-signal-from-workflow.md","id":"php/send-signal-from-workflow","title":"How to send a Signal from a Workflow","description":"A Workflow can send a Signal to another Workflow, in which case it's called an External Signal","label":"Send Signal from Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.\n\nWhen an External Signal is sent:\n\n- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.\n- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.\n","is_empty":false},{"file_name":"set-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/set-custom-search-attributes.md","id":"php/set-custom-search-attributes","title":"How to set custom Search Attributes","description":"After you've created custom Search Attributes in your Cluster (using `tctl` or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.","label":"Custom Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAfter you've created custom Search Attributes in your Cluster (using `tctl search-attribute create`or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.\n","is_empty":false},{"file_name":"set-task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/set-task-queue.md","id":"php/set-task-queue","title":"How to set a Workflow's Task Queue","description":"In most SDKs, the only Workflow Option that must be set is the name of the Task Queue.","label":"Set Task Queue","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn most SDKs, the only Workflow Option that must be set is the name of the [Task Queue](/concepts/what-is-a-task-queue).\n\nFor any code to execute, a Worker Process must be running that contains a Worker Entity that is polling the same Task Queue name.\n","is_empty":false},{"file_name":"set-workflow-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/set-workflow-id.md","id":"php/set-workflow-id","title":"How to set a Workflow Id","description":"Although it is not required, we recommend providing your own Workflow Id that maps to a business process or business entity identifier, such as an order identifier or customer identifier.","label":"Workflow Id","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAlthough it is not required, we recommend providing your own [Workflow Id](/concepts/what-is-a-workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.\n","is_empty":false},{"file_name":"side-effect.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/side-effect.md","id":"php/side-effect","title":"SideEffect","ssdi":[],"markdown_content":"\n`Workflow::sideEffect` is useful for short, non-deterministic code snippets, such as getting a random\nvalue or generating a UUID. It executes the provided function once and records its result into the\nWorkflow history. `Workflow::sideEffect` does not re-execute upon replay, but instead returns the\nrecorded result. It can be seen as an \"inline\" Activity.\n\nSomething to note about `Workflow::sideEffect`\nis that, unlike the Temporal guarantee of at-most-once execution for Activities, there is no such\nguarantee with `Workflow::sideEffect` . Under certain failure conditions, `Workflow::sideEffect` can\nend up executing a function more than once.\n\nThe only way to fail `sideEffect` is to throw an exception, which causes a Workflow Task failure.\nAfter the timeout, Temporal reschedules and then re-executes the Workflow Task, giving `SideEffect` another chance to succeed.\nDo not return any data from `sideEffect` other than through its recorded return value.\n\nThe following sample demonstrates how to use `SideEffect`:\n\n```php\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        $random = yield Workflow::sideEffect(fn()=> return random_int(0, 100));\n        if ($random < 100) {\n            // ...\n        } else {\n            // ...\n        }\n    }\n}\n```\n","is_empty":false},{"file_name":"side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/side-effects.md","id":"php/side-effects","title":"Side Effects","description":"A Side Effect is used to produce non-deterministic code, such as generating a UUID or a random number.","label":"Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSide Effects are used to execute non-deterministic code, such as generating a UUID or a random number, without compromising deterministic in the Workflow. This is done by storing the non-deterministic results of the Side Effect into the Workflow [Event History](/workflows/#event-history).\n\nA Side Effect does not re-execute during a Replay. Instead, it returns the recorded result from the Workflow Execution Event History.\n\nSide Effects should not fail. An exception that is thrown from the Side Effect causes failure and retry of the current Workflow Task.\n\nAn Activity or a Local Activity may also be used instead of a Side effect, as its result is also persisted in Workflow Execution History.\n\n:::note\n\nYou shouldn’t modify the Workflow state inside a Side Effect function, because it is not reexecuted during Replay. Side Effect function should be used to return a value.\n\n:::\n","is_empty":false},{"file_name":"signal-with-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/signal-with-start.md","id":"php/signal-with-start","title":"How to Signal-With-Start","description":"Signal-With-Start is used from the Client","label":"Signal-With-Start","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSignal-With-Start is used from the Client.\nIt takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.\n\nIf there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.\n","is_empty":false},{"file_name":"signals copy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/signals copy.md","id":"php/signals","title":"How to develop with Signals","description":"A Signal is a message sent to a running Workflow Execution","label":"Signals","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Signal](/concepts/what-is-a-signal) is a message sent to a running Workflow Execution.\n\nSignals are defined in your code and handled in your Workflow Definition.\nSignals can be sent to Workflow Executions from a Temporal Client or from another Workflow Execution.\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/signals.md","id":"php/signals","title":"Signals in PHP","label":"Signals","tags":["php"],"ssdi":[],"markdown_content":"\n:::info Try the Developer's guide\n\nThe majority of this information has moved into the [Developer's guide](/dev-guide/?lang=php).\n\nHowever, if you can't find what you are looking for there, we recommend checking this doc set as well.\n\n:::\n\nimport {RelatedReadContainer, RelatedReadItem} from '../components/RelatedReadList.js'\n\n<!-- prettier-ignore -->\n\nimport * as WhatIsASignal from '../concepts/what-is-a-signal.md'\n\n<RelatedReadContainer>\n  <RelatedReadItem page={WhatIsASignal} />\n</RelatedReadContainer>\n\n```php\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private bool $value;\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        yield Workflow::await(fn()=> $this->value);\n        return 'OK';\n    }\n\n    #[Workflow\\SignalMethod]\n    public function setValue(bool $value)\n    {\n        $this->value = $value;\n    }\n}\n```\n\nIn the preceding example, the Workflow updates the protected value.\nThe Main Workflow coroutine waits for the value to change by using the `Workflow::await` function.\n\nTo send a Signal to a Workflow, use `WorkflowClient->newWorkflowStub` or `WorkflowClient->newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient->newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with Workflow Id to send Signals to already running Workflows.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n\n## SignalWithStart\n\nYou may not know if a Workflow is running and can accept a signal. The\n`WorkflowClient`->`startWithSignal` API\nallows you to send a signal to the current Workflow instance if one exists or to create a new\nrun and then send the signal.\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->startWithSignal(\n    $workflow,\n    'setValue',\n    [true], // signal arguments\n    [] // start arguments\n);\n```\n","is_empty":false},{"file_name":"skip-time-set-up.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/skip-time-set-up.md","id":"php/skip-time-set-up","title":"Set up time skipping","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Setting up","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to set up the time-skipping test framework in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/skip-time-skip-activities.md","id":"php/skip-time-skip-activities","title":"Skip time in Activities","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time in Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time in Activities in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-automatically.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/skip-time-skip-automatically.md","id":"php/skip-time-skip-automatically","title":"Skip time automatically","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Automatic method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can skip time automatically in the SDK of your choice.\nStart a test server process that skips time as needed.\nFor example, in the time-skipping mode, Timers, which include sleeps and conditional timeouts, are fast-forwarded except when Activities are running.\n","is_empty":false},{"file_name":"skip-time-skip-manually.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/skip-time-skip-manually.md","id":"php/skip-time-skip-manually","title":"Skip time manually","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Manual method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time manually in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/skip-time.md","id":"php/skip-time","title":"How to skip time","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSome long-running Workflows can persist for months or even years.\nImplementing the test framework allows your Workflow code to skip time and complete your tests in seconds rather than the Workflow's specified amount.\n\nFor example, if you have a Workflow sleep for a day, or have an Activity failure with a long retry interval, you don't need to wait the entire length of the sleep period to test whether the sleep function works.\nInstead, test the logic that happens after the sleep by skipping forward in time and complete your tests in a timely manner.\n\n:::note\n\nSkipping time is not relevant to unit testing Workflow code, because in that case you’re mocking functions that take time, like sleep and Activity calls.\n\n:::\n\nThe test framework included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.\nTime is a global property of an instance of `TestWorkflowEnvironment`: skipping time (either automatically or manually) applies to all currently running tests.\nIf you need different time behaviors for different tests, run your tests in a series or with separate instances of the test server.\nFor example, you could run all tests with automatic time skipping in parallel, and then all tests with manual time skipping in series, and then all tests without time skipping in parallel.\n","is_empty":false},{"file_name":"spawning-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/spawning-activities.md","id":"php/spawning-activities","title":"How to start an Activity Execution","description":"Calls to spawn Activity Executions are written within a Workflow Definition.","label":"Activity Execution","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCalls to spawn [Activity Executions](/concepts/what-is-an-activity-execution) are written within a [Workflow Definition](/concepts/what-is-a-workflow-definition).\nThe call to spawn an Activity Execution generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nThis results in the set of three [Activity Task](/concepts/what-is-an-activity-task) related Events ([ActivityTaskScheduled](/references/events/#activitytaskscheduled), [ActivityTaskStarted](/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.\n\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the Execution history.\nThe entire Execution history is transferred from the Temporal service to Workflow Workers when a Workflow state needs to recover.\nA large Execution history can thus adversely impact the performance of your Workflow.\n\nTherefore, be mindful of the amount of data you transfer through Activity invocation parameters or Return Values.\nOtherwise, no additional limitations exist on Activity implementations.\n","is_empty":false},{"file_name":"spawning-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/spawning-workflows.md","id":"php/spawning-workflows","title":"How to start a Workflow Execution","description":"Workflow Execution semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.","label":"Start Workflow Execution","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Workflow Execution](/workflows#workflow-execution) semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.\n\nIn the examples below, all Workflow Executions are started using a Temporal Client.\nTo spawn Workflow Executions from within another Workflow Execution, use either the [Child Workflow](#child-workflows) or External Workflow APIs.\n\nSee the [Customize Workflow Type](#customize-workflow-type) section to see how to customize the name of the Workflow Type.\n\nA request to spawn a Workflow Execution causes the Temporal Cluster to create the first Event ([WorkflowExecutionStarted](/references/events/#workflowexecutionstarted)) in the Workflow Execution Event History.\nThe Temporal Cluster then creates the first Workflow Task, resulting in the first [WorkflowTaskScheduled](/references/events/#workflowtaskscheduled) Event.\n","is_empty":false},{"file_name":"start-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/start-to-close.md","id":"php/start-to-close","title":"How to set a Start-To-Close Timeout","description":"Use the Start-To-Close Timeout to limit the maximum duration of a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) to limit the maximum duration of a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n","is_empty":false},{"file_name":"task-queues.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/task-queues.md","id":"php/task-queues","title":"Task Queues in PHP","label":"Task Queues","ssdi":[],"markdown_content":"\n:::info Try the Developer's guide\n\nThe majority of this information has moved into the [Developer's guide](/dev-guide/?lang=php).\n\nHowever, if you can't find what you are looking for there, we recommend checking this doc set as well.\n\n:::\n\nIn PHP, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```php\n// Create new Workflow Options and set the Task Queue\n$workflowOptions = WorkflowOptions::new()\n  ->withTaskQueue(\"Workflow-Task-Queue-1\")\n  // ...\n\n$yourWorkflow = $workflowClient->newWorkflowStub(\n  YourWorkflowInterface::class,\n  $workflowOptions\n);\n\n$result = $yourWorkflow->workflowMethod();\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```php\nuse Temporal\\WorkerFactory;\n\n// Create a Worker Factory\n$factory = WorkerFactory::create();\n\n// Set the Task Queue when creating the Worker\n$worker = $factory->newWorker(\"Workflow-Task-Queue-1\");\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(YourWorkflow::class);\n\n// start primary loop\n$factory->run();\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```php\nclass YourWorkflow implements YourWorkflowInterface\n{\n  private $yourActivity;\n\n  public function __construct()\n  {\n    // Create Activity options and set the Task Queue\n    $activityOptions = ActivityOptions::new()\n      ->withTaskQueue(\"Activity-Task-Queue-1\")\n      // ...\n\n    // Create a new Activity Stub and pass the options\n    $this->yourActivity = Workflow::newActivityStub(\n      YourActivityInterface::class,\n      $activityOptions\n    );\n  }\n\n  public function workflowMethod(): \\Generator\n  {\n    // Call the Activity\n    return yield $this->yourActivity->activityMethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```php\n//Create new Child Workflow Options and set the Task Queue\n$childWorkflowOptions = ChildWorkflowOptions::new()\n    ->withTaskQueue(\"Child-Workflow-Task-Queue-1\")\n    // ...\n\n// Create a new Child Workflow Stub and set the Task Queue\n$childWorkflow = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    $childWorkflowOptions\n);\n\n// Call the Child Workflow method\n$promise = $childWorkflow->workflowMethod();\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.\n","is_empty":false},{"file_name":"test-functions-assert-in-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/test-functions-assert-in-workflow.md","id":"php/test-functions-assert-in-workflow","title":"Assert in Workflow","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Assert in Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe `assert` statement is a convenient way to insert debugging assertions into the Workflow context.\n\nThe `assert` method is available in Python and TypeScript.\n","is_empty":false},{"file_name":"test-functions-in-workflow-context.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/test-functions-in-workflow-context.md","id":"php/test-functions-in-workflow-context","title":"Test functions in Workflow context","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Workflow context","tags":["guide-context"],"ssdi":[],"markdown_content":"\nFor a function or method to run in the Workflow context (where it’s possible to get the current Workflow info, or running inside the sandbox in the case of TypeScript or Python), it needs to be run by the Worker as if it were a Workflow.\n\n:::note\n\nThis section is applicable in Python and TypeScript.\nIn Python, we allow testing of Workflows only and not generic Workflow-related code.\n\n:::\n","is_empty":false},{"file_name":"testing copy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/testing copy.md","id":"php/testing","title":"Testing","description":"The Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.","label":"Testing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.\n\nIn the context of Temporal, you can create these types of automated tests:\n\n- **End-to-end**: Running a Temporal Server and Worker with all its Workflows and Activities; starting and interacting with Workflows from a Client.\n- **Integration**: Anything between end-to-end and unit testing.\n  - Running Activities with mocked Context and other SDK imports (and usually network requests).\n  - Running Workers with mock Activities, and using a Client to start Workflows.\n  - Running Workflows with mocked SDK imports.\n- **Unit**: Running a piece of Workflow or Activity code (a function or method) and mocking any code it calls.\n\nWe generally recommend writing the majority of your tests as integration tests.\n\nBecause the test server supports skipping time, use the test server for both end-to-end and integration tests with Workers.\n","is_empty":false},{"file_name":"testing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/testing-activities.md","id":"php/testing-activities","title":"Testing Activities","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn Activity can be tested with a mock Activity environment, which provides a way to mock the Activity context, listen to Heartbeats, and cancel the Activity.\nThis behavior allows you to test the Activity in isolation by calling it directly, without needing to create a Worker to run the Activity.\n","is_empty":false},{"file_name":"testing-frameworks.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/testing-frameworks.md","id":"php/testing-frameworks","title":"Test frameworks","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test frameworks","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSome SDKs have support or examples for popular test frameworks, runners, or libraries.\n","is_empty":false},{"file_name":"testing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/testing-workflows.md","id":"php/testing-workflows","title":"Testing Workflows","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"","is_empty":false},{"file_name":"testing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/testing.md","id":"php/testing","title":"Testing PHP Workflows","label":"Testing","ssdi":[],"markdown_content":"\n## Testing Workflows\n\nThe PHP SDK provides tools for testing Workflows without running a regular Temporal Cluster. Instead, it uses a light-weight testing server.\n\n### Quick start\n\n1. Create `bootstrap.php` in `tests` folder with the following contents:\n\n```php\ndeclare(strict_types=1);\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse Temporal\\Testing\\Environment;\n\n$environment = Environment::create();\n$environment->start();\nregister_shutdown_function(fn () => $environment->stop());\n```\n\n2. Add `bootstrap.php` to your `phpunit.xml`:\n\n```xml\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/9.3/phpunit.xsd\"\n         bootstrap=\"tests/bootstrap.php\"\n>\n</phpunit>\n```\n\n3. Add test server executable to `.gitignore`:\n\n```gitignore\ntemporal-test-server\n```\n\n### How it works\n\nFor testing workflows there is no need to run a full Temporal server (with storage and UI interface).\nInstead, we can use a light-weight test server.\n\nThe code in `bootstrap.php` will start and stop (and download if it doesn't exist) the Temporal test server and RoadRunner for every phpunit run.\nThe test server runs as a regular server on 7233 port.\nThus, if you use default connection settings, there is no need to change them.\n\nUnder the hood RoadRunner is started with `rr serve` command. You can specify your own command in `bootstrap.php`:\n\n```php\n$environment->start('./rr serve -c .rr.test.yaml -w tests');\n```\n\nThe snippet above will start Temporal test server and RoadRunner with `.rr.test.yaml` config and `tests` working\n\ndirectory. Having a separate RoadRunner config file for tests can be useful to mock you activities. For\nexample, you can create a separate _worker_ that registers activity implementations mocks:\n\n```yaml\n# test/.rr.test.yaml\nserver:\n  command: \"php worker.test.php\"\n```\n\nAnd within the worker you register your Workflows and mock Activities:\n\n```php\n// worker.test.php\n$factory = WorkerFactory::create();\n\n$worker = $factory->newWorker();\n$worker->registerWorkflowTypes(YourWorkflow::class);\n$worker->registerActivity(MyActvivityMock::class);\n$factory->run();\n```\n\nYou can test Workflows by running them with a Workflow Client like this:\n\n```php\nfinal class SimpleWorkflowTestCase extends TestCase\n{\n    private WorkflowClient $workflowClient;\n\n    protected function setUp(): void\n    {\n        $this->workflowClient = new WorkflowClient(\n            ServiceClient::create('localhost:7233')\n        );\n\n        parent::setUp();\n    }\n\n    public function testWorkflowReturnsUpperCasedInput(): void\n    {\n        $workflow = $this->workflowClient->newWorkflowStub(SimpleWorkflow::class);\n        $run = $this->workflowClient->start($workflow, 'hello');\n        $this->assertSame('HELLO', $run->getResult('string'));\n    }\n}\n```\n\n### Time management\n\nIf we consider Activities as some external code that can be mocked than unit-testing your Workflows becomes\nstraight-forward:\n\n1. Register activity mocks in a separate \"test\" worker.\n2. In your test create a `WorkflowClient`.\n3. Use `WorkflowClient` to run the Workflow and assert the result.\n\nThe problem may occur when your Workflow depends on some time changes: it waits for timeout or some other conditions.\nIn unit tests, we don't want to waste time waiting for timeouts.\n\nThus, by default, the test server starts with a _\"time-skipping\"_ option.\nIt means that if the Workflow has a timer, the server doesn't wait for it and continues immediately.\nFor example, when testing such a Workflow the test server will not wait for a minute:\n\n```php\n#[WorkflowInterface]\nfinal class WaitWorkflow\n{\n    #[WorkflowMethod]\n    public function run(string $input)\n    {\n        $simple = Workflow::newActivityStub(\n            SimpleActivity::class,\n            ActivityOptions::new()->withStartToCloseTimeout(5)\n        );\n\n        yield Workflow::timer('1 minute');\n\n        return yield $simple->echo($input);\n    }\n}\n```\n\nThe activity will be called immediately. But, there may be cases when you do need to wait. So, to change this behaviour\nyou can use `TestService` class:\n\n```php\n$testService = TestService::create('localhost:7233');\n$testService->lockTimeSkipping();\n\n// ...\n$testService->unlockTimeSkipping();\n```\n\nClass `TestService` communicates with a test server and provides method for _time management_. Time skipping\ncan be switched on/off with `unlockTimeSkipping()` and `lockTimeSkipping()` method:\n\n```php\nfinal class WaitTestCase extends TestCase\n{\n    private WorkflowClient $workflowClient;\n\n    protected function setUp(): void\n    {\n        $this->workflowClient = new WorkflowClient(\n            ServiceClient::create('localhost:7233')\n        );\n\n        parent::setUp();\n    }\n\n    public function testSimpleAwait()\n    {\n        $testService = TestService::create('localhost:7233');\n        $testService->lockTimeSkipping();\n\n        $wait = $this->workflowClient->newWorkflowStub(WaitWorkflow::class);\n        $run = $this->workflowClient->start($wait, 'hello');\n\n        $testService->unlockTimeSkipping();\n        $this->assertSame('HELLO', $run->getResult('string'));\n    }\n}\n```\n\nFor convenience if you don't want to skip time in the whole `TestCase` class use `WithoutTimeSkipping`:\n\n```php\nfinal class WaitTestCase extends TestCase\n{\n    use WithoutTimeSkipping;\n\n    // ...\n}\n```\n\nIn case you need to emulate some \"waiting\" on a test server, you can use `sleep(int seconds)` or `sleepUntil(int $timestamp)` methods.\n\nCurrent server time can be retrieved with `getCurrentTime(): Carbon` method.\n","is_empty":false},{"file_name":"timers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/timers.md","id":"php/timers","title":"What is a Timer?","description":"A Timer lets a Workflow sleep for a fixed time period.","label":"Timers","tags":["guide-context","timers","sleep"],"ssdi":[],"markdown_content":"\nA Workflow can set a durable timer for a fixed time period.\nIn some SDKs, the function is called `sleep()`, and in others, it's called `timer()`.\n\nA Workflow can sleep for months.\nTimers are persisted, so even if your Worker or Temporal Cluster is down when the time period completes, as soon as your Worker and Cluster are back up, the `sleep()` call will resolve and your code will continue executing.\n\nSleeping is a resource-light operation: it does not tie up the process, and you can run millions of Timers off a single Worker.\n","is_empty":false},{"file_name":"tracing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/tracing.md","id":"php/tracing","title":"How to setup Tracing","description":"Tracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.","label":"Tracing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.\n\nTemporal Web's tracing capabilities mainly track Activity Execution within a Temporal context. If you need custom tracing specific for your use case, you should make use of context propagation to add tracing logic accordingly.\n\nFor information about Workflow tracing, see [Tracing Temporal Workflows with DataDog](https://spiralscout.com/blog/tracing-temporal-workflow-with-datadog).\n\nFor information about how to configure exporters and instrument your code, see [Tracing Temporal Services with OTEL](https://github.com/temporalio/temporal/blob/master/develop/docs/tracing.md).\n","is_empty":false},{"file_name":"upsert-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/upsert-custom-search-attributes.md","id":"php/upsert-custom-search-attributes","title":"How to upsert Search Attributes","description":"You can upsert Search Attributes to add or update Search Attributes from within Workflow code.","label":"Upsert Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can upsert Search Attributes to add or update Search Attributes from within Workflow code.\n","is_empty":false},{"file_name":"versioning.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/versioning.md","id":"php/versioning","title":"Versioning","ssdi":[],"markdown_content":"\nThe definition code of a Temporal Workflow must be deterministic because Temporal uses event sourcing\nto reconstruct the Workflow state by replaying the saved history event data on the Workflow\ndefinition code. This means that any incompatible update to the Workflow Definition code could cause\na non-deterministic issue if not handled correctly.\n\n## Workflow::getVersion()\n\nConsider the following Workflow Definition:\n\n```php\npublic function yourWorkflow(string $data)\n{\n    $yourActivity = Workflow::newActivityStub(\n        YourActivityInterface::class,\n        ActivityOptions::new()\n            ->withScheduleToStartTimeout(60)\n    );\n\n    $result1 = yield $yourActivity->activityA($data);\n    $result2 = yield $yourActivity->activityB($result1);\n\n    return $result2;\n}\n```\n\nNow let's say we have replaced `ActivityA` with `ActivityC`, and deployed the updated code. If there\nis an existing Workflow Execution that was started by the original version of the Workflow code, where\n`ActivityA` had already completed and the result was recorded to history, the new version of the Workflow\ncode will pick up that Workflow Execution and try to resume from there. However, the Workflow **will fail**\nbecause the new code expects a result for `ActivityC` from the history data, but instead it gets the\nresult for `ActivityA`. This causes the Workflow to fail on the non-deterministic error.\n\nThus we use `Workflow::getVersion()`.\n\n```php\n$yourActivity = Workflow::newActivityStub(\n    YourActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToStartTimeout(60)\n);\n\n$v = yield Workflow::getVersion('Step1', Workflow::DEFAULT_VERSION, 1);\n\nif ($v === Workflow::DEFAULT_VERSION) {\n    $result1 = yield $yourActivity->activityA($data);\n} else {\n    $result1 = yield $yourActivity->activityC($data);\n}\n\n$result2 = yield $yourActivity->activityB($result1);\n\nreturn $result2;\n```\n\nWhen `Workflow::getVersion()` is run for the new Workflow Execution, it records a marker in the Workflow history so that all future calls to `GetVersion` for this change Id—`Step 1` in the example—on this Workflow Execution will always return the given version number, which is `1` in the example.\n\nIf you make an additional change, such as replacing ActivityC with ActivityD, you need to\nadd some additional code:\n\n```php\n$v = yield Workflow::getVersion('Step1', Workflow::DEFAULT_VERSION, 2);\n\nif ($v === Workflow::DEFAULT_VERSION) {\n    $result1 = yield $yourActivity->activityA($data);\n} elseif ($v === 1) {\n    $result1 = yield $yourActivity->activityC($data);\n} else {\n    $result1 = yield $yourActivity->activityD($data);\n}\n```\n\nNote that we have changed `maxSupported` from 1 to 2. A Workflow that had already passed this\n`GetVersion()` call before it was introduced will return `DEFAULT_VERSION`. A Workflow that was run\nwith `maxSupported` set to 1, will return 1. New Workflows will return 2.\n\nAfter you are sure that all of the Workflow Executions prior to version 1 have completed, you can remove the code for that version.\nIt should now look like the following:\n\n```php\n$v = yield Workflow::getVersion('Step1', 1, 2);\n\nif ($v === 1) {\n    $result1 = yield $yourActivity->activityC($data);\n} else {\n    $result1 = yield $yourActivity->activityD($data);\n}\n```\n\nYou'll note that `minSupported` has changed from `DEFAULT_VERSION` to `1`.\nIf an older version of the Workflow Execution history is replayed on this code, it fails because the minimum expected version is 1.\nAfter you are sure that all Workflow Executions for version 1 have completed, you can remove version 1 so that your code looks like the following:\n\n```php\nyield Workflow::getVersion('Step1', 2, 2);\n\n$result1 = yield $yourActivity->activityD($data);\n```\n\nNote that we have preserved the call to `GetVersion()`. There are two reasons to preserve this call:\n\n1. This ensures that if there is a Workflow Execution still running for an older version, it will\n   fail here and not proceed.\n2. If you need to make additional changes for `Step1`, such as changing ActivityD to ActivityE, you\n   only need to update `maxVersion` from 2 to 3 and branch from there.\n\nYou only need to preserve the first call to `GetVersion()` for each `changeID`. All subsequent calls to\n`GetVersion()` with the same change Id are safe to remove. If necessary, you can remove the first\n`GetVersion()` call, but you need to ensure the following:\n\n- All executions with an older version are completed.\n- You can no longer use `Step1` for the changeId. If you need to make changes to that same part in\n  the future, such as change from ActivityD to ActivityE, you would need to use a different changeId\n  like `Step1-fix2`, and start minVersion from DefaultVersion again. The code would look like the\n  following:\n\n```php\n$v = yield Workflow::getVersion('Step1-fix2', Workflow::DEFAULT_VERSION, 1);\n\nif ($v === Workflow::DEFAULT_VERSION) {\n    $result1 = yield $yourActivity->activityD($data);\n} else {\n    $result1 = yield $yourActivity->activityE($data);\n}\n```\n\nUpgrading a Workflow is straightforward if you don't need to preserve your currently running Workflow Executions.\nYou can simply terminate all of the currently running Workflow Executions and suspend new ones from being created while you deploy the new version of your Workflow code, which does not use `GetVersion()`, and then resume Workflow creation.\nHowever, that is often not the case, and you need to take care of the currently running Workflow Executions, so using `GetVersion()` to update your code is the method to use.\n\nHowever, if you want your currently running Workflows to proceed based on the current Workflow logic,\nbut you want to ensure new Workflows are running on new logic, you can define your Workflow as a\nnew `WorkflowType`, and change your start path (calls to `StartWorkflow()`) to start the new Workflow\ntype.\n\n## Sanity checking\n\nThe Temporal client SDK performs a sanity check to help prevent obvious incompatible changes.\nThe sanity check verifies whether a Command made in replay matches the event recorded in history,\nin the same order. The Command is generated by calling any of the following methods:\n\n- Workflow::executeActivity()\n- Workflow::executeChildWorkflow()\n- Workflow::timer()\n- Workflow::sideEffect()\n- Workflow::newActivityStub() execute\n- Workflow::newChildWorkflowStub() start and signal\n- Workflow::newExternalWorkflowStub() start and signal\n\nAdding, removing, or reordering any of the above methods triggers the sanity check and results in\na non-deterministic error.\n\nThe sanity check does not perform a thorough check. For example, it does not check on the Activity's\ninput arguments or the timer duration. If the check is enforced on every property, then it becomes\ntoo restricted and harder to maintain the Workflow code. For example, if you move your Activity code\nfrom one package to another package, that changes the `ActivityType`, which technically becomes a different\nActivity. But, we don't want to fail on that change, so we only check the function name part of the\n`ActivityType`.\n","is_empty":false},{"file_name":"visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/visibility.md","id":"php/visibility","title":"How to use Visibility APIs","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n","is_empty":false},{"file_name":"workers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workers.md","id":"php/workers","title":"Workers in PHP","label":"Workers","ssdi":[],"markdown_content":"\n:::info Try the Developer's guide\n\nThe majority of this information has moved into the [Developer's guide](/dev-guide/?lang=php).\n\nHowever, if you can't find what you are looking for there, we recommend checking this doc set as well.\n\n:::\n\nThe [RoadRunner application server](https://roadrunner.dev/) will launch multiple Temporal PHP worker processes based on provided `.rr.yaml` configuration.\n\nEach worker might connect to one or multiple task queues. Worker poll _Temporal service_ for tasks, performs those tasks,\nand communicates task execution results back to the _Temporal service_.\n\nWorker code are developed, deployed, and operated by Temporal customers. To create a worker use `Temporal\\WorkerFactory`:\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nuse Temporal\\WorkerFactory;\n\nini_set('display_errors', 'stderr');\ninclude \"vendor/autoload.php\";\n\n// factory initiates and runs task queue specific activity and workflow workers\n$factory = WorkerFactory::create();\n\n// Worker that listens on a task queue and hosts both workflow and activity implementations.\n$worker = $factory->newWorker();\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n\n// Activities are stateless and thread safe.\n$worker->registerActivity(App\\DemoActivity::class);\n// In case an activity class requires some external dependencies provide a callback - factory\n// that creates or builds a new activity instance. The factory should be a callable which accepts\n// an instance of ReflectionClass with an activity class which should be created.\n$worker->registerActivity(App\\DemoActivity::class, fn(ReflectionClass $class) => $container->create($class->getName()));\n// If you want to clean up some resources after activity is done, you may register\n// a finalizer. This callback is called after each activity invocation.\n$worker->registerActivityFinalizer(fn () => $kernel->showtdown());\n\n// start primary loop\n$factory->run();\n```\n\nYou can configure task queue name using first argument of `WorkerFactory`->`newWorker`:\n\n```php\n$worker = $factory->newWorker('your-task-queue');\n```\n\nAs mentioned above you can create as many task queue connections inside a single worker as you need.\n\nTo configure additional worker options use `Temporal\\Worker\\WorkerOptions`:\n\n```php\nuse Temporal\\Worker\\WorkerOptions;\n\n$worker = $factory->newWorker(\n    'your-task-queue',\n    WorkerOptions::new()\n        ->withMaxConcurrentWorkflowTaskPollers(10)\n);\n```\n\nMake sure to point the worker file in application server configuration:\n\n```yaml\nrpc:\n  listen: tcp://127.0.0.1:6001\n\nserver:\n  command: \"php worker.php\"\n\ntemporal:\n  address: \"temporal:7233\"\n  activities:\n    num_workers: 10\n```\n\n> You can serve HTTP endpoints using the same server setup.\n","is_empty":false},{"file_name":"workflow-execution-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-execution-timeout.md","id":"php/workflow-execution-timeout","title":"How to set a Workflow Execution Timeout","description":"Use the Workflow Execution Timeout to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n","is_empty":false},{"file_name":"workflow-logic-requirements.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-logic-requirements.md","id":"php/workflow-logic-requirements","title":"How develop Workflow logic","description":"Workflow logic is constrained by deterministic execution requirements.","label":"Workflow logic requirements","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow logic is constrained by [deterministic execution requirements](/concepts/what-is-a-workflow-definition#deterministic-constraints).\nTherefore, each language is limited to the use of certain idiomatic techniques.\nHowever, each Temporal SDK provides a set of APIs that can be used inside your Workflow to interact with external (to the Workflow) application code.\n","is_empty":false},{"file_name":"workflow-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-parameters.md","id":"php/workflow-parameters","title":"How to define Workflow parameters","description":"Temporal Workflows may have any number of custom parameters.","label":"Workflow parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal Workflows may have any number of custom parameters.\nHowever, we strongly recommend that objects are used as parameters, so that the object's individual fields may be altered without breaking the signature of the Workflow.\nAll Workflow Definition parameters must be serializable.\n","is_empty":false},{"file_name":"workflow-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-retries.md","id":"php/workflow-retries","title":"Workflow retries","description":"A Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.","label":"Workflow retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-retry-policy.md","id":"php/workflow-retry-policy","title":"How to set a Workflow Retry Policy","description":"Use a Retry Policy to retry a Workflow Execution in the event of a failure.","label":"Workflow Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-return-values.md","id":"php/workflow-return-values","title":"How to define Workflow return parameters","description":"Workflow return values must also be serializable.","label":"Workflow return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow return values must also be serializable.\nReturning results, returning errors, or throwing exceptions is fairly idiomatic in each language that is supported.\nHowever, Temporal APIs that must be used to get the result of a Workflow Execution will only ever receive one of either the result or the error.\n","is_empty":false},{"file_name":"workflow-run-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-run-timeout.md","id":"php/workflow-run-timeout","title":"How to set a Workflow Run Timeout","description":"Use the Workflow Run Timeout to restrict the maximum amount of time that a single Workflow Run can last.","label":"Workflow Run Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) to restrict the maximum amount of time that a single [Workflow Run](/concepts/what-is-a-workflow-execution#workflow-execution-chain) can last.\n","is_empty":false},{"file_name":"workflow-task-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-task-timeout.md","id":"php/workflow-task-timeout","title":"How to set a Workflow Task Timeout","description":"Use the Workflow Task Timeout to restrict the maximum amount of time that a Worker can execute a Workflow Task.","label":"Workflow Task Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout) to restrict the maximum amount of time that a Worker can execute a [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"workflow-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-timeouts-and-retries.md","id":"php/workflow-timeouts-and-retries","title":"Workflow timeouts and retries","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts & retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"workflow-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-timeouts.md","id":"php/workflow-timeouts","title":"Workflow timeouts","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\n\nWorkflow timeouts are set when [starting the Workflow Execution](/php/workflow-timeouts).\n\n- **[Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout)** - restricts the maximum amount of time that a single Workflow Execution can be executed.\n- **[Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout)**: restricts the maximum amount of time that a single Workflow Run can last.\n- **[Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout)**: restricts the maximum amount of time that a Worker can execute a Workflow Task.\n","is_empty":false},{"file_name":"workflow-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflow-type.md","id":"php/workflow-type","title":"How to customize your Workflow Type","description":"You can set a custom name for your Workflow Type.","label":"Workflow Type","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows have a Type that are referred to as the Workflow name.\n\nThe following examples demonstrate how to set a custom name for your Workflow Type.\n","is_empty":false},{"file_name":"workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/php/workflows.md","id":"php/workflows","title":"Workflows in PHP","description":"The core abstraction of the Temporal solution is a fault-oblivious stateful Workflow.","label":"Workflows","ssdi":[],"markdown_content":"\nimport RelatedReadList from '../components/RelatedReadList.js'\n\n:::info Try the Developer's guide\n\nThe majority of this information has moved into the [Developer's guide](/dev-guide/?lang=php).\n\nHowever, if you can't find what you are looking for there, we recommend checking this doc set as well.\n\n:::\n\n## What is a Workflow?\n\nIn PHP, a Workflow is a class method.\nClasses must implement interfaces that are annotated with `#[WorkflowInterface]`.\nThe method that is the Workflow must be annotated with `#[WorkflowMethod]`.\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n}\n```\n\nWorkflow methods return a `Generator`.\nTo properly typecast the Workflow's return value in the client code use the `#[ReturnType()]` annotation.\n\n```php\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n}\n```\n\nWorkflows can also answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, signal and query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow Type defaults to `\"FileProcessingWorkflow\"`.\n\n## Workflow Interface Inheritance\n\nWorkflow interfaces can form inheritance hierarchies.\nIt may be useful for creating components reusable across multiple Workflow types.\nFor example imaging a UI or CLI button that allows to call `retryNow` signal on any Workflow.\nTo implement this feature you can redesign the above interface to:\n\n```php\n#[WorkflowInterface\ninterface Retryable {\n    #[SignalMethod]\n    public function retryNow(): void;\n}\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow extends Retryable {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nThen some other Workflow can implement it as well:\n\n```php\n#[WorkflowInterface]\ninterface MediaProcessingWorkflow extends Retryable {\n    #[WorkflowMethod]\n    public function processBlob(Argument $args);\n}\n```\n\nThen it would be possible to send signal to both of them using the Retryable interface only:\n\n```php\n$r = $workflowClient->newRunningWorkflowStub(Retryable::class, $workflowId);\n$r->retryNow();\n```\n\nThe same technique can be used to query Workflows through a base interface.\n\nNote that an attempt to start Workflow through a base interface annotated with `#[WorkflowInterface]` is not going to work.\nLet's look at the following **invalid** example:\n\n```php\n// INVALID CODE!\n\n#[WorkflowInterface]\ninterface BaseWorkflow {\n    #[WorkflowMethod]\n    public function start();\n}\n\n#[WorkflowInterface]\ninterface Workflow1 extends BaseWorkflow {}\n\n#[WorkflowInterface]\ninterface Workflow2 extends BaseWorkflow {}\n```\n\nAn attempt to register implementations of Workflow1 and Workflow2 are going to fail as they are going to use the same Workflow Type.\nThe type is defined by the type of the class which is annotated with `#[WorkflowInterface]`.\nIn this case `BaseWorkflow`.\nThe solution is to remove `#[WorkflowInterface]` annotation from BaseWorkflow.\nThe following is valid code:\n\n```php\ninterface BaseWorkflow {\n    #[WorkflowMethod]\n    public function start();\n}\n\n#[WorkflowInterface]\ninterface Workflow1 extends BaseWorkflow {}\n\n#[WorkflowInterface]\ninterface Workflow2 extends BaseWorkflow {}\n```\n\nImplementations of Workflow1 and Workflow2 can registered with the same worker as they will have types defined by their interfaces.\n\n## Implementing Workflows\n\nA Workflow implementation implements a Workflow interface.\nEach time a new Workflow Execution is started, a new instance of the Workflow implementation object is created.\nThen, one of the methods (depending on which Workflow Type has been started) annotated with `#[WorkflowMethod]` is invoked.\nAs soon as this method returns, the Workflow Execution is closed.\nWhile Workflow Execution is open, it can receive calls to signal and query methods.\nNo additional calls to Workflow methods are allowed.\nThe Workflow object is stateful, so query and signal methods can communicate with the other parts of the Workflow through Workflow object fields.\n\n### Constraints\n\nTemporal uses the [Microsoft Azure Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover the state of a Workflow object including its local variable values.\n\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nWhen replaying, side effects (such as Activity invocations) are ignored because they are already recorded in the Workflow event history.\nWhen writing Workflow logic, the replay is not visible, so the code should be written since it executes only once.\nThis design puts the following constraints on the Workflow implementation:\n\n- Do not use any mutable global variables because multiple instances of Workflows are executed in parallel.\n- Do not call any non-deterministic functions like non seeded random or `UUID` directly from the Workflow code.\n\nAlways do the following in the Workflow implementation code:\n\n- Don’t perform any IO or service calls as they are not usually deterministic. Use Activities for this.\n- Only use `Workflow::now()` to get the current time inside a Workflow.\n- Call `yield Workflow::timer()` instead of `sleep()`.\n- Do not use any blocking SPL provided by PHP (i.e. `fopen`, `PDO`, etc) in **Workflow code**.\n- Use `yield Workflow::getVersion()` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already open Workflows.\n- Don’t access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\nWorkflow method arguments and return values are serializable to a byte array using the provided [DataConverter](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html) interface.\nThe default implementation uses JSON serializer, but you can use any alternative serialization mechanism.\n\nMake sure to annoate your `WorkflowMethod` using `ReturnType` to specify concrete return type.\n\n> You can not use the default return type declaration as Workflow methods are generators.\n\nThe values passed to Workflows through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to Workflow workers with every event that the Workflow logic needs to process.\nA large execution history can thus adversely impact the performance of your Workflow.\nTherefore, be mindful of the amount of data that you transfer via Activity invocation parameters or return values.\nOtherwise, no additional limitations exist on Activity implementations.\n\n## Awaits\n\nUse specialized construct `Workflow::await` and `Workflow::awaitWithTimeout` to wait for Closure function become positive.\n\n```php\n$done = false;\nWorkflow::async(\n    function () use (&$done) {\n        $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n\n        $done = true;\n    }\n);\n\n// wait for $done to become true\nyield Workflow::await(fn() => $done);\n```\n\nYou cannot use any Activity, timer, or Child Workflow invocations inside the `await` or `awaitWithTimeout` method.\nHowever, you can use variables referenced by other coroutines.\n\n## Timers\n\nUse `Workflow::timer()` to yield long sleeps:\n\n```php\nyield Workflow::timer(300); // sleep for 5 minutes\n```\n\n## Starting Workflows\n\nWorkflows can be started both synchronously and asynchronously.\nYou can use typed or untyped workflows stubs available via `Temporal\\Client\\WorkflowClient`.\nTo create a Workflow Client:\n\n```php\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$workflowClient = WorkflowClient::create(ServiceClient::create('localhost:7233'));\n```\n\n### Synchronous start\n\nA Synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the\ninvocation process and will continue executing even if the waiting process crashes or stops.\n\nBe sure to acquire the Workflow interface or class name you want to start.\nFor example:\n\n```php\n#[WorkflowInterface]\ninterface AccountTransferWorkflowInterface\n{\n    #[WorkflowMethod(name: \"MoneyTransfer\")]\n    #[ReturnType('int')]\n    public function transfer(\n        string $fromAccountId,\n        string $toAccountId,\n        string $referenceId,\n        int $amountCents\n    );\n}\n```\n\nTo start the Workflow in sync mode:\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$result = $accountTransfer->transfer(\n    'fromID',\n    'toID',\n    'refID',\n    1000\n);\n```\n\n### Asynchronous start\n\nAn asynchronous start initiates a Workflow Execution and immediately returns to the caller without waiting for a result.\nThis is the most common way to start Workflows in a live environment.\n\nTo start a Workflow asynchronously, pass the Workflow stub instance and start parameters into the `WorkflowClient->start` method.\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$run = $this->workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n```\n\nWhen started, you can receive the Workflow Id and Run Id via the `WorkflowRun` object returned by the `start` method:\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getExecution()->getID());\n```\n\n### Recurring start\n\nYou can start a Workflow Execution on a regular schedule with [the CronSchedule option](distributed-cron).\n\n## Connect to Running Workflows\n\nIf you need to wait for the completion of a Workflow after an asynchronous start, make a blocking call to\nthe `WorkflowRun`->`getResult` method.\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getResult());\n```\n\nYou can always connect to an existing Workflow and wait for its completion from another process by using Workflow Id.\nUse `WorkflowClient->newUntypedRunningWorkflowStub` for such purposes.\n\n```php\n$workflow = $workflowClient->newUntypedRunningWorkflowStub('workflowID');\n\nvar_dump($workflow->getResult());\n```\n\n## Child Workflows\n\nBesides Activities, a Workflow can also start other Workflows.\n\n<RelatedReadList\nreadlist={[\n[\"What is a Child Workflow Execution?\",\"/concepts/what-is-a-child-workflow-execution\",\"explanation\"],\\\n]}\n/>\n\n## PHP Child Workflow API\n\n`Workflow::executeChildWorkflow` and `Workflow::newChildWorkflowStub` enables the scheduling of other Workflows from within a Workflow's implementation.\nThe parent Workflow has the ability to monitor and impact the lifecycle of the Child Workflow, similar to the way it does for an Activity that it invoked.\n\n```php\n// Use one stub per child workflow run\n$child = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    ChildWorkflowOptions::new()\n        // Do not specify WorkflowId if you want Temporal to generate a unique Id\n        // for the child execution.\n        ->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW')\n        ->withExecutionStartToCloseTimeout(DateInterval::createFromDateString('30 minutes'))\n);\n\n// This is a non blocking call that returns immediately.\n// Use yield $child->workflowMethod(name) to call synchronously.\n$promise = $child->workflowMethod('value');\n\n// Do something else here.\ntry{\n    $value = yield $promise;\n} catch(TemporalException $e) {\n    $logger->error('child workflow failed');\n    throw $e;\n}\n```\n\nLet's take a look at each component of this call.\n\nBefore calling `$child->workflowMethod()`, you must configure `ChildWorkflowOptions` for the invocation.\nThese options customize various execution timeouts and are passed into the Workflow stub defined by the `Workflow::newChildWorkflowStub`.\nAfter the stub is created, you can invoke its Workflow method based on the `WorkflowMethod` attribute.\n\nThe method call returns immediately and returns a `Promise`.\nThis allows you to execute more code without having to wait for the scheduled Workflow to complete.\n\nWhen you are ready to process the results of the Workflow, call the `yield $promise` method on the returned promise object.\n\nWhen a parent Workflow is cancelled by the user, the Child Workflow can be cancelled or abandoned based on a configurable child policy.\n\nYou can also skip the stub part of Child Workflow initiation and use `Workflow::executeChildWorkflow` directly:\n\n```php\n// Use one stub per child workflow run\n$childResult = yield Workflow::executeChildWorkflow(\n    'ChildWorkflowName',\n    ['args'],\n    ChildWorkflowOptions::new()->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW'),\n    Type::TYPE_STRING // optional: defines the return type\n);\n```\n\n## Large event histories\n\nWorkflows that need to rerun periodically could naively be implemented as a big **while** loop with a sleep where the entire logic of the Workflow is inside the body of the **while** loop.\nThe problem with this approach is that the history for that Workflow will keep growing to a point where it reaches the maximum size enforced by the service.\n\n**ContinueAsNew** is the low level construct that enables implementing such Workflows without the risk of failures down the road.\nThe operation atomically completes the current execution and starts a new execution of the Workflow with the same **Workflow Id**.\nThe new execution will not carry over any history from the old execution.\n\nTo trigger this behavior, use `Workflow::continueAsNew` or `Workflow::newContinueAsNewStub` method:\n\n```php\n#[Workflow\\WorkflowMethod]\npublic function periodic(string $name, int $value = 0)\n{\n    for ($i = 0; $i < 100; $i++) {\n        // do something\n        $value++;\n    }\n\n    // maintain $value counter between runs\n    return Workflow::newContinueAsNewStub(self::class)->periodic($name, $value);\n}\n```\n","is_empty":false},{"file_name":"activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activities.md","id":"typescript/activities","title":"Activities in TypeScript","description":"Activities are the only way to interact with external resources in Temporal, like making an HTTP request or accessing the file system. Unlike Workflows, Activities execute in the standard Node.js environment.","label":"Activities","ssdi":[],"markdown_content":"\n**`@temporalio/activity`** [![NPM](https://img.shields.io/npm/v/@temporalio/activity)](https://www.npmjs.com/package/@temporalio/activity) [API reference](https://typescript.temporal.io/api/namespaces/activity) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/activity)\n\n> _Background reading: [Activities in Temporal](/activities)_\n\n**Activities are the only way to interact with external resources in Temporal**, such as making an HTTP request or accessing the file system.\n\n- Unlike [Workflows](/typescript/determinism), Activities execute in the standard Node.js environment. Any code that needs to talk to the outside world needs to be in an Activity, not a Workflow.\n- **Separate from Workflows**: Activities cannot be in the same file as Workflows and must be separately registered (see below for [How to register an Activity on a Worker](#how-to-register-an-activity-on-a-worker))\n- **Idempotency**: Activities may be retried repeatedly, so you may need to use [idempotency keys](https://stripe.com/blog/idempotency) for critical side effects.\n- The `'@temporalio/activity'` package offers useful utilities for Activity functions such as sleeping, Heartbeating, cancellation, and retrieving metadata (see [docs on Activity Context utilities](#activity-context-utilities) below).\n\n## How to write an Activity Function\n\nActivities are _simply functions_.\nBelow is a simple Activity that accepts a string parameter and returns a string:\n\n<!--SNIPSTART typescript-hello-activity {\"enable_source_link\": false}-->\n\n```ts\nexport async function greet(name: string): Promise<string> {\n  return `Hello, ${name}!`;\n}\n```\n\n<!--SNIPEND-->\n\n## How to import and use Activities in a Workflow\n\nYou must first retrieve an Activity from an \"Activity Handle\" before you can call it.\nNote that we only import the type of our activities, the TypeScript compiler will drop the import statement on compilation.\n\n<!--SNIPSTART typescript-hello-workflow {\"enable_source_link\": false}-->\n\n```ts\nimport { proxyActivities } from '@temporalio/workflow';\n// Only import the activity types\nimport type * as activities from './activities';\n\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\n/** A workflow that simply calls an activity */\nexport async function example(name: string): Promise<string> {\n  return await greet(name);\n}\n```\n\n<!--SNIPEND-->\n\n:::danger Wrong way to import activities\n\nYou may be tempted to import activities directly instead of using `proxyActivities`:\n\n```ts\nimport { greet } from './activities';\n// error when you try to use the function in your code\ngreet('Hello world');\n```\n\nThis will result in a Webpack error, because the Temporal Worker will try to bundle this as part of the Workflow.\nMake sure you're using `proxyActivities` to retrieve an Activity rather than calling the function directly.\nThis indirection comes from the fact that Activities are run in the regular Node.js environment, not the deterministic `vm` where Workflows are run.\n\nSee also our [docs on Webpack troubleshooting](/typescript/troubleshooting/).\n\n:::\n\nThe return value of `proxyActivities` is not a normal object, it is a [`Proxy`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) object that calls the TypeScript SDK's internal `scheduleActivity()` function when you reference an activity.\nThis is necessary due to the decoupled nature of Workflows and Activities, but also allows strong typing from a single import, and some nice patterns we explain below.\n\n### Activity Options\n\nWhen you call `proxyActivities` in a Workflow function, there are [a range of ActivityOptions](https://typescript.temporal.io/api/interfaces/common.ActivityOptions) you can set:\n\n```ts\n// Sample of typical options you can set while creating a proxy for the `greet` Activity\nconst { greet } = proxyActivities<typeof activities>({\n  // recommended\n  startToCloseTimeout: '30s',\n  // useful\n  scheduleToCloseTimeout: '5m',\n  // The below is a Retry Policy. It is used to retry the Activity if it fails.\n  retry: {\n    // These are the values of the Default Retry Policy\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n\nWe explain the Timeouts and Retries below. You can also specify `taskQueue`, `cancellationType`, and `activityId`, but most users will not need these.\n\n### Activity Timeouts\n\nTimeouts and Retries are the most immediate benefit of moving code onto Temporal.\nThere are [four Activity Timeouts](https://temporal.io/blog/activity-timeouts) you can set.\nWhen a Timeout happens, your activity will be retried according to your [`RetryPolicy`](/concepts/what-is-a-retry-policy/).\n\n- `startToCloseTimeout`: Maximum time of a single Activity Execution attempt. **We recommend always setting this**. [More info](/concepts/what-is-a-start-to-close-timeout/)\n- `scheduleToCloseTimeout`: Total time that a Workflow is willing to wait for Activity to complete. [More info](/concepts/what-is-a-schedule-to-close-timeout/)\n- `heartbeatTimeout`: A best practice to set for long-running activities. [More info](/concepts/what-is-a-heartbeat-timeout/)\n- `scheduleToStartTimeout`: Not recommended; Only for task routing. [More info](/concepts/what-is-a-schedule-to-start-timeout/)\n\nYou can specify timeouts as number of milliseconds, or a string to be parsed to number of milliseconds by the [`ms`](https://www.npmjs.com/package/ms) package:\n\n```ts\n// Example 1\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute', // translates to 60000 ms\n});\n\n// Example 2\nconst { longRunningActivity } = proxyActivities<typeof activities>({\n  // translates to 300000 ms\n  scheduleToCloseTimeout: '5m',\n  // translates to 30000 ms\n  startToCloseTimeout: '30s',\n  // equivalent to '10 seconds'\n  heartbeatTimeout: 10000,\n});\n```\n\n### Activity Retry Policy\n\nYou can set a `retry` policy with [RetryPolicy](https://typescript.temporal.io/api/interfaces/client.RetryPolicy/) that define how activity is retried in case of failure.\n\n```ts\n// Example 1 - default\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '20s',\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n\n// Example 2 - no retries\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '20s',\n  retry: {\n    // guarantee no retries\n    maximumAttempts: 1,\n  },\n});\n\n// Example 3 - linear retries up to 5x\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '20s',\n  retry: {\n    // retry every 1s, no exponential backoff\n    backoffCoefficient: 1,\n    // max 5 attempts\n    maximumAttempts: 5,\n  },\n});\n```\n\nFor a proper guide to each Retry Option, see the [RetryPolicy API Reference](https://typescript.temporal.io/api/interfaces/client.RetryPolicy/).\n\nAs you customize your Workflow errors to be more descriptive, advanced users will want to become familiar with [Temporal's Failure classes](/typescript/handling-failure).\n\n## How to register an Activity on a Worker\n\nAll activities must be registered by a Worker, or you will get an error that looks like `\"Activity function yourActivity is not registered on this Worker\"` when you try to invoke it from a Workflow.\n\n```ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\n// ...\nconst worker = await Worker.create({\n  // ...\n  activities,\n});\n```\n\n:::tip Sticky Activities\n\n**Any matching Worker can pick up your Activity**, meaning your Activities are not guaranteed to execute on the same machine if you have a fleet of Workers.\nYou can route tasks to specific machines with the [Sticky Queues pattern](/typescript/workers#example-sticky-queues).\n\n:::\n\nAdvanced users can also register [Activity Interceptors](/typescript/how-to-implement-interceptors-in-typescript) here.\nFor more on Activity and Workflow registration, see [the Worker docs](/typescript/workers) for more details.\n\n### Using pure ESM Node Modules\n\nThe JavaScript ecosystem is increasingly moving towards publishing ES Modules over CommonJS, for example `node-fetch@3` is ESM while `node-fetch@2` is CJS.\n\n**If you are importing a pure ESM dependency, see our [fetch ESM](https://github.com/temporalio/samples-typescript/tree/main/fetch-esm) sample** for necessary config changes you will need:\n\n- `package.json` must have `\"type\": \"module\"` attribute\n- `tsconfig.json` should output in `esnext` format\n- Imports [must](https://nodejs.org/api/esm.html#esm_mandatory_file_extensions) include the `.js` file extension\n\n## Important Design Patterns\n\nHere are some important (and frequently asked) patterns for using our Activities APIs, to illustrate common needs and usecases.\n\n### Sharing dependencies in Activity functions (Dependency Injection)\n\nBecause Activities are \"just\" functions, you can also create functions that create Activities.\nThis is a helpful pattern for using closures to:\n\n- store expensive dependencies for sharing, such as database connections\n- injecting secret keys (such as environment variables) from the Worker to the Activity\n\n<!--SNIPSTART typescript-activity-with-deps-->\n\n[activities-dependency-injection/src/activities.ts](https://github.com/temporalio/samples-typescript/blob/master/activities-dependency-injection/src/activities.ts)\n\n```ts\nexport interface DB {\n  get(key: string): Promise<string>;\n}\n\nexport const createActivities = (db: DB) => ({\n  async greet(msg: string): Promise<string> {\n    const name = await db.get('name'); // simulate read from db\n    return `${msg}: ${name}`;\n  },\n  async greet_es(mensaje: string): Promise<string> {\n    const name = await db.get('name'); // simulate read from db\n    return `${mensaje}: ${name}`;\n  },\n});\n```\n\n<!--SNIPEND-->\n\n<details>\n  <summary>See full example</summary>\n\nWhen you register these in the Worker, pass your shared dependencies accordingly:\n\n<!--SNIPSTART typescript-activity-deps-worker {\"enable_source_link\": false}-->\n\n```ts\nimport { createActivities } from './activities';\n\nasync function run() {\n  // Mock DB connection initialization in Worker\n  const db = {\n    async get(_key: string) {\n      return 'Temporal';\n    },\n  };\n\n  const worker = await Worker.create({\n    taskQueue: 'dependency-injection',\n    workflowsPath: require.resolve('./workflows'),\n    activities: createActivities(db),\n  });\n\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n<!--SNIPEND-->\n\nSince Activities are always referenced by name, inside the Workflow they can be proxied as normal, though the types need some adjustment:\n\n<!--SNIPSTART typescript-activity-deps-workflow-->\n\n[activities-dependency-injection/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/activities-dependency-injection/src/workflows.ts)\n\n```ts\nimport type { createActivities } from './activities';\n\n// Note usage of ReturnType<> generic since createActivities is a factory function\nconst { greet, greet_es } = proxyActivities<\n  ReturnType<typeof createActivities>\n>({\n  startToCloseTimeout: '30 seconds',\n});\n```\n\n<!--SNIPEND-->\n\n</details>\n\n### Importing multiple Activities at once\n\nYou may proxy multiple Activities from the same `proxyActivities` call if you want them to share the same timeouts/retries/options:\n\n```ts\nexport async function Workflow(name: string): Promise<string> {\n  // destructuring multiple activities with the same options\n  const { act1, act2, act3 } = proxyActivities<typeof activities>();\n  /* activityOptions */\n  await act1();\n  await Promise.all([act2, act3]);\n}\n```\n\n### Dynamically referencing Activities\n\nSince, under the hood, Activities are only referenced by their string name, you can reference them dynamically if needed:\n\n```js\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts['activity1']();\n\n  // dynamic reference to activities using activityName\n  let result = await acts[activityName](...args);\n}\n```\n\nType safety is still supported here, but you are encouraged to validate and handle mismatches in Activity names. An invalid Activity name will lead to a `NotFoundError` with a message that looks like:\n\n```\nApplicationFailure: Activity function actC is not registered on this Worker, available activities: [\"actA\", \"actB\"]\n```\n\n## Activity Context utilities\n\nTemporal SDK also exports a [`Context`](https://typescript.temporal.io/api/classes/activity.Context/) class with useful features for activities: `import { Context } from '@temporalio/activity'`\n\n| Activity Context properties            | Description                                                                                                                                                                                    |\n| -------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `Context.current().cancellationSignal` | An `AbortSignal` which can be used to cancel requests on Activity cancellation. Typically used by the `fetch` and `child_process` libraries but is supported by a few other libraries as well. |\n| `Context.current().cancelled`          | Await this promise in an Activity to get notified of cancellation. This promise will never be resolved; it will only be rejected with a `CancelledFailure`.                                    |\n| `Context.current().heartbeat()`        | Send a Heartbeat from an Activity.                                                                                                                                                             |\n| `Context.current().info`               | Holds [information](https://typescript.temporal.io/api/interfaces/activity.Info) about the current executing Activity                                                                          |\n| `Context.current().sleep()`            | Helper function for sleeping in an Activity - resolves when deadline is reached or rejects when the Context is cancelled. Prefer this to `setTimeout`.                                         |\n\n### Heartbeating\n\nLong running activities should Heartbeat their progress back to the Workflow for earlier detection of stalled activities (with Heartbeat timeouts) and resuming stalled activities from checkpoints (with Heartbeat details).\n\n<details>\n<summary>\nWhat activities should Heartbeat?\n</summary>\n\nHeartbeating is best thought about not in terms of time, but in terms of \"How do you know you are making progress\"? If an operation is so short that it doesn't make any sense to say \"I am still working on this\", then don't heartbeat. Vice versa for longer operations.\n\n- If your underlying task can report definite progress, that is ideal.\n  - However, do note that your Workflow cannot read this progress information while the Activity is still executing (or it would have to store it in Event History). You may report progress to external sources if you need it exposed to the user.\n- Even without a \"progress you may get something useful from just verifying that the Worker processing your Activity is at the very least \"still alive\" (has not run out of memory or silently crashed).\n\nSuitable for Heartbeating:\n\n- Read a large file from S3\n- Run a ML training job on some local GPUs\n\nNot suitable for Heartbeating:\n\n- Reading a small file from disk\n- Making a quick API call\n\n</details>\n\n```ts\n// activity implementation\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  for (let progress = 1; progress <= 1000; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    Context.current().heartbeat();\n  }\n}\n\n// workflow code calling activity\nconst { example } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 hour',\n  heartbeatTimeout: '10s',\n});\n```\n\nWithout Heartbeating, if your activity `StartToCloseTimeout` is 1 hour and the activity stalled, or activity worker died, Temporal would have to wait out the 1 hour before retrying.\nBut if you used the Heartbeat API, set a `heartbeatTimeout` for 10 seconds, the absence of Heartbeats in the `heartbeatTimeout` window would inform the Server that the Activity has stalled and should be retried right away rather than at the end of the `StartToCloseTimeout`.\n\nThe second major benefit of Heartbeating is being able to resume from failure by check pointing data as `heartbeatDetails`.\nExtending the example above:\n\n```ts\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  const startingPoint = Context.current().info.heartbeatDetails || 1; // allow for resuming from heartbeat\n  for (let progress = startingPoint; progress <= 100; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    Context.current().heartbeat(progress);\n  }\n}\n```\n\nThis way, if the Activity Worker experiences a `heartbeatTimeout`, when a retry happens, it will pick up where the previous attempt left off.\n\n### Activity Cancellation\n\nActivity Cancellation is an optional capability that lets you do graceful cleanup if it's originating Workflow is canceled. There are some additional usage notes:\n\n- Activities may be cancelled only if they emit heartbeats.\n- A Workflow can request to cancel an Activity by cancelling its containing [cancellation scope](/typescript/cancellation-scopes).\n\nThere are 3 ways to handle Activity cancellation:\n\n1. Await on [`Context.current().cancelled`](https://typescript.temporal.io/api/classes/activity.Context#cancelled)\n2. Catch a [`CancelledFailure`](/typescript/handling-failure/) while awaiting \"cancellation-aware\" APIs like `Context.current().sleep`. Errors can be validated with the `isCancellation(err)` utility function (see example below)\n3. Pass the context's abort Signal at [`Context.current().cancellationSignal`](https://typescript.temporal.io/api/classes/activity.Context#cancelled) to a library that supports it like `fetch`\n\n[`heartbeat()`](https://typescript.temporal.io/api/classes/activity.Context/#heartbeat) in the TypeScript SDK is a background operation and does not propagate errors to the caller, such as when the scheduling Workflow has already completed or the Activity has been closed by the Server (due to timeout for instance). These errors are translated into cancellation and can be handled using the methods above.\n\n#### Example: Activity that fakes progress and can be cancelled\n\nThe [`sleep`](https://typescript.temporal.io/api/classes/activity.Context#sleep) method exposed in `Context.current()` is comparable to a standard `sleep` function: `new Promise(resolve => setTimeout(resolve, sleepMS));` except that it also rejects if the Activity is cancelled.\n\n<!--SNIPSTART typescript-activity-fake-progress-->\n\n[activities-cancellation-heartbeating/src/activities.ts](https://github.com/temporalio/samples-typescript/blob/master/activities-cancellation-heartbeating/src/activities.ts)\n\n```ts\nimport { CancelledFailure, Context } from '@temporalio/activity';\n\nexport async function fakeProgress(sleepIntervalMs = 1000): Promise<void> {\n  try {\n    // allow for resuming from heartbeat\n    const startingPoint = Context.current().info.heartbeatDetails || 1;\n    console.log('Starting activity at progress:', startingPoint);\n    for (let progress = startingPoint; progress <= 100; ++progress) {\n      // simple utility to sleep in activity for given interval or throw if Activity is cancelled\n      // don't confuse with Workflow.sleep which is only used in Workflow functions!\n      console.log('Progress:', progress);\n      await Context.current().sleep(sleepIntervalMs);\n      Context.current().heartbeat(progress);\n    }\n  } catch (err) {\n    if (err instanceof CancelledFailure) {\n      console.log('Fake progress activity cancelled', err.message);\n      // Cleanup\n    }\n    throw err;\n  }\n}\n```\n\n<!--SNIPEND-->\n\n#### Example: Activity that makes a cancellable HTTP request with cancellationSignal\n\nThe [`Context.current().cancellationSignal`](https://typescript.temporal.io/api/classes/activity.Context#cancellationsignal) returns an `AbortSignal` that is typically used by the `node_fetch` and `child_process` libraries but is supported by a few other libraries as well as the Web-standard [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal).\n\n<!--SNIPSTART typescript-activity-cancellable-fetch-->\n\n[activities-examples/src/activities/cancellable-fetch.ts](https://github.com/temporalio/samples-typescript/blob/master/activities-examples/src/activities/cancellable-fetch.ts)\n\n```ts\nimport { Context } from '@temporalio/activity';\nimport fetch from 'node-fetch';\nimport type { AbortSignal as FetchAbortSignal } from 'node-fetch/externals';\n\nexport async function cancellableFetch(url: string): Promise<Uint8Array> {\n  const response = await fetch(url, {\n    signal: Context.current().cancellationSignal as FetchAbortSignal,\n  });\n  const contentLengthHeader = response.headers.get('Content-Length');\n  if (contentLengthHeader === null) {\n    throw new Error('expected Content-Length header to be set');\n  }\n  const contentLength = parseInt(contentLengthHeader);\n  let bytesRead = 0;\n  const chunks: Buffer[] = [];\n\n  for await (const chunk of response.body) {\n    if (!(chunk instanceof Buffer)) {\n      throw new TypeError('Expected Buffer');\n    }\n    bytesRead += chunk.length;\n    chunks.push(chunk);\n    Context.current().heartbeat(bytesRead / contentLength);\n  }\n  return Buffer.concat(chunks);\n}\n```\n\n<!--SNIPEND-->\n\n## Advanced Features\n\nThese are Activity features that most users will not need, but are available for advanced users.\nPlease get in touch with us if you find the need for them.\n\n### Activity Interceptors\n\nInterceptors are a mechanism for users to modify inbound and outbound SDK calls. Interceptors are commonly used to add tracing and authorization to the scheduling and execution of Workflows and Activities, but you can also use them to run code after an Activity failure (and before the next retry). See the [Interceptors docs](/typescript/how-to-implement-interceptors-in-typescript) and the [SDK API Reference](https://typescript.temporal.io/api/interfaces/worker.ActivityInboundCallsInterceptor) for more information.\n\n### Async Activity Completion\n\nNormally, an Activity is started and ended in the same Worker, for example a short HTTP call.\nHowever, sometimes you may want to record an Activity completion in a different process than when you started it.\n\n> If you are modeling human actions, we recommend using Signals rather than Async Activity Completion.\n> This is because Activities only have one timeout and, if your Activity is split into two steps, one for kicking off the process (for example, storing information in the data base), and one for human based resolution, it's best to use the timeout to detect failure in the former, so it can be retried by the system.\n\nAsync Activity completion is done through a two-step process:\n\n- Throw a `CompleteAsyncError` from an Activity\n- Use a `AsyncCompletionClient` to mark it as completed, failed, or more.\n\nYou can [read the tests](https://github.com/temporalio/sdk-typescript/blob/7d47f501cb56cced27118b5f0abb320cc0ba03ef/packages/test/src/test-async-completion.ts#L40-L98) for more information.\n\n### Local Activities (experimental)\n\nTemporal has an optimization feature called Local Activities.\n\nThis document is still a WIP. For more details, see [What is a Local Activity?](/concepts/what-is-a-local-activity/)\n\nTo call Local Activities in TS, use [`proxyLocalActivities`](https://typescript.temporal.io/api/namespaces/workflow/#proxylocalactivities).\n\n```ts\nimport * as workflow from '@temporalio/workflow';\n\nconst { getEnvVar } = workflow.proxyLocalActivities({\n  startToCloseTimeout: '2 seconds',\n});\n\nexport async function yourWorkflow(): Promise<void> {\n  const someSetting = await getEnvVar('SOME_SETTING');\n  // ...\n}\n```\n\nLocal Activities must be registered with the Worker the same way non-local Activities are.\n","is_empty":false},{"file_name":"activity-design-patterns.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-design-patterns.md","id":"typescript/activity-design-patterns","title":"Important design patterns for Activities","description":"Patterns that illustrate using Activity APIs to address common needs and use cases.","label":"Activity design patterns","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe following are some important (and frequently requested) patterns for using our Activities APIs.\nThese patterns address common needs and use cases.\n\n#### Share dependencies in Activity functions (dependency injection)\n\nBecause Activities are \"just functions,\" you can also create functions that create Activities.\nThis is a helpful pattern for using closures to do the following:\n\n- Store expensive dependencies for sharing, such as database connections.\n- Inject secret keys (such as environment variables) from the Worker to the Activity.\n\n<!--SNIPSTART typescript-activity-with-deps-->\n\n[activities-dependency-injection/src/activities.ts](https://github.com/temporalio/samples-typescript/blob/master/activities-dependency-injection/src/activities.ts)\n\n```ts\nexport interface DB {\n  get(key: string): Promise<string>;\n}\n\nexport const createActivities = (db: DB) => ({\n  async greet(msg: string): Promise<string> {\n    const name = await db.get('name'); // simulate read from db\n    return `${msg}: ${name}`;\n  },\n  async greet_es(mensaje: string): Promise<string> {\n    const name = await db.get('name'); // simulate read from db\n    return `${mensaje}: ${name}`;\n  },\n});\n```\n\n<!--SNIPEND-->\n\n<details>\n  <summary>See full example</summary>\n\nWhen you register these in the Worker, pass your shared dependencies accordingly:\n\n<!--SNIPSTART typescript-activity-deps-worker {\"enable_source_link\": false}-->\n\n```ts\nimport { createActivities } from './activities';\n\nasync function run() {\n  // Mock DB connection initialization in Worker\n  const db = {\n    async get(_key: string) {\n      return 'Temporal';\n    },\n  };\n\n  const worker = await Worker.create({\n    taskQueue: 'dependency-injection',\n    workflowsPath: require.resolve('./workflows'),\n    activities: createActivities(db),\n  });\n\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n<!--SNIPEND-->\n\nBecause Activities are always referenced by name, inside the Workflow they can be proxied as normal, although the types need some adjustment:\n\n<!--SNIPSTART typescript-activity-deps-workflow-->\n\n[activities-dependency-injection/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/activities-dependency-injection/src/workflows.ts)\n\n```ts\nimport type { createActivities } from './activities';\n\n// Note usage of ReturnType<> generic since createActivities is a factory function\nconst { greet, greet_es } = proxyActivities<\n  ReturnType<typeof createActivities>\n>({\n  startToCloseTimeout: '30 seconds',\n});\n```\n\n<!--SNIPEND-->\n\n</details>\n\n#### Import multiple Activities simultaneously\n\nYou can proxy multiple Activities from the same `proxyActivities` call if you want them to share the same timeouts, retries, and options:\n\n```ts\nexport async function Workflow(name: string): Promise<string> {\n  // destructuring multiple activities with the same options\n  const { act1, act2, act3 } = proxyActivities<typeof activities>();\n  /* activityOptions */\n  await act1();\n  await Promise.all([act2, act3]);\n}\n```\n\n#### Dynamically reference Activities\n\nBecause Activities are referenced only by their string names, you can reference them dynamically if needed:\n\n```js\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts['activity1']();\n\n  // dynamic reference to activities using activityName\n  let result = await acts[activityName](...args);\n}\n```\n\nType safety is still supported here, but we encourage you to validate and handle mismatches in Activity names.\nAn invalid Activity name leads to a `NotFoundError` with a message that looks like this:\n\n```\nApplicationFailure: Activity function actC is not registered on this Worker, available activities: [\"actA\", \"actB\"]\n```\n","is_empty":false},{"file_name":"activity-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-heartbeats.md","id":"typescript/activity-heartbeats","title":"How to Heartbeat an Activity","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.","label":"Activity Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn [Activity Heartbeat](/concepts/what-is-an-activity-heartbeat) is a ping from the [Worker Process](/concepts/what-is-a-worker-process) that is executing the Activity to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nEach Heartbeat informs the Temporal Cluster that the [Activity Execution](/concepts/what-is-an-activity-execution) is making progress and the Worker has not crashed.\nIf the Cluster does not receive a Heartbeat within a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) time period, the Activity will be considered failed and another [Activity Task Execution](/concepts/what-is-an-activity-task-execution) may be scheduled according to the Retry Policy.\n\nHeartbeats may not always be sent to the Cluster—they may be [throttled](/concepts/what-is-an-activity-heartbeat#throttling) by the Worker.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\nHeartbeats can contain a `details` field describing the Activity's current progress.\nIf an Activity gets retried, the Activity can access the `details` from the last Heartbeat that was sent to the Cluster.\n","is_empty":false},{"file_name":"activity-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-parameters.md","id":"typescript/activity-parameters","title":"How to develop Activity Parameters","description":"When it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.","label":"Activity parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThere is no explicit limit to the total number of parameters that an [Activity Definition](/concepts/what-is-an-activity-definition) may support.\nHowever, there is a limit of the total size of the data ends up encoded into a gRPC message Payload.\n\nA single argument is limited to a maximum size of 2 MB.\nAnd the total size of a gRPC message, which includes all the arguments, is limited to a maximum of 4 MB.\n\nAlso, keep in mind that all Payload data is recorded in the [Workflow Execution Event History](/concepts/what-is-an-event-history) and large Event Histories can affect Worker performance.\nThis is because the entire Event History could be transferred to a Worker Process with a [Workflow Task](/concepts/what-is-a-workflow-task).\n\n<!--TODO link to gRPC limit section when available -->\n\nSome SDKs require that you pass context objects, others do not.\nWhen it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.\nThis is so that you can change what data is passed to the Activity without breaking a function or method signature.\n","is_empty":false},{"file_name":"activity-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-retries.md","id":"typescript/activity-retries","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-retry-policy.md","id":"typescript/activity-retry-policy","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-simulator.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-retry-simulator.md","id":"typescript/activity-retry-simulator","title":"How to visualize an Activity Retry Policy with timeouts","description":"Use this tool to visualize total Activity Execution times and experiment with various Activity timeouts and Retry Policies.","label":"Activity retry simulator","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse this tool to visualize total Activity Execution times and experiment with different Activity timeouts and Retry Policies.\n\nThe simulator is based on a common Activity use-case, which is to call a third party HTTP API and return the results.\nSee the example code snippets below.\n\nUse the Activity Retries settings to configure how long the API request takes to succeed or fail.\nThere is an option to generate scenarios.\nThe _Task Time in Queue_ simulates the time the Activity Task might be waiting in the Task Queue.\n\nUse the Activity Timeouts and Retry Policy settings to see how they impact the success or failure of an Activity Execution.\n\nimport RetrySimulator from '/docs/components/RetrySimulator/RetrySimulator';\n\n<RetrySimulator />\n","is_empty":false},{"file_name":"activity-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-return-values.md","id":"typescript/activity-return-values","title":"How to define Activity return values","description":"All data returned from an Activity must be serializable.","label":"Activity return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll data returned from an Activity must be serializable.\n\nThere is no explicit limit to the amount of data that can be returned by an Activity, but keep in mind that all return values are recorded in a [Workflow Execution Event History](/concepts/what-is-an-event-history).\n","is_empty":false},{"file_name":"activity-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-timeouts-and-retries.md","id":"typescript/activity-timeouts-and-retries","title":"How to set Activity timeouts and retries","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts and retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"activity-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-timeouts.md","id":"typescript/activity-timeouts","title":"How to set Activity timeouts","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\n\nThe following timeouts are available in the Activity Options.\n\n- **[Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout)**: is the maximum amount of time allowed for the overall [Activity Execution](/concepts/what-is-an-activity-execution).\n- **[Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout)**: is the maximum time allowed for a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n- **[Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout)**: is the maximum amount of time that is allowed from when an [Activity Task](/concepts/what-is-an-activity-task) is scheduled to when a [Worker](/concepts/what-is-a-worker) starts that Activity Task.\n\nAn Activity Execution must have either the Start-To-Close or the Schedule-To-Close Timeout set.\n","is_empty":false},{"file_name":"activity-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/activity-type.md","id":"typescript/activity-type","title":"How to customize your Activity Type","description":"You can set a custom name for your Activity Type.","label":"Activity Type","tags":["guide-context"],"ssdi":[],"markdown_content":"\nActivities have a Type that are referred to as the Activity name.\nThe following examples demonstrate how to set a custom name for your Activity Type.\n","is_empty":false},{"file_name":"add-sdk.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/add-sdk.md","id":"typescript/add-sdk","title":"How to install a Temporal SDK","description":"A Temporal SDK provides a framework for Temporal Application development.","label":"Install a Temporal SDK","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal SDK](/concepts/what-is-a-temporal-sdk) provides a framework for [Temporal Application](/concepts/what-is-a-temporal-application) development.\n\nAn SDK provides you with the following:\n\n- A [Temporal Client](/concepts/what-is-a-temporal-client) to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n- APIs to develop [Workflows](/concepts/what-is-a-workflow).\n- APIs to create and manage [Worker Processes](/concepts/what-is-a-worker).\n- APIs to author [Activities](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"api-reference-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/api-reference-typescript.md","id":"typescript/api-reference-typescript","title":"How to find the TypeScript SDK API reference","description":"The Temporal TypeScript SDK API reference is published at typescript.temporal.io.","label":"API reference","tags":["how-to","typescript"],"ssdi":[],"markdown_content":"\nThe Temporal TypeScript SDK API reference is published to [typescript.temporal.io](https://typescript.temporal.io).\n","is_empty":false},{"file_name":"assert-in-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/assert-in-workflows.md","id":"typescript/assert-in-workflows","title":"Assert in Workflows","description":"How to Assert in Workflows","label":"Assert in Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\n<!-- not used -->\n\nIn some cases it's useful to assert directly in the Workflow context.\n\nFor example, TypeScript and Python, can use `assert` in Workflow code.\n","is_empty":false},{"file_name":"async-activity-completion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/async-activity-completion.md","id":"typescript/async-activity-completion","title":"How to asynchronously complete an Activity","description":"Asynchronous Activity Completion enables the Activity Function to return without the Activity Execution completing.","label":"Asynchronous Activity Completion","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Asynchronous Activity Completion](/concepts/what-is-asynchronous-activity-completion) enables the Activity Function to return without the Activity Execution completing.\n\nThere are three steps to follow:\n\n1. The Activity provides the external system with identifying information needed to complete the Activity Execution.\n   Identifying information can be a [Task Token](/concepts/what-is-a-task-token), or a combination of Namespace, Workflow Id, and Activity Id.\n2. The Activity Function completes in a way that identifies it as waiting to be completed by an external system.\n3. The Temporal Client is used to Heartbeat and complete the Activity.\n","is_empty":false},{"file_name":"async-design-patterns.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/async-design-patterns.md","id":"typescript/async-design-patterns","title":"Asynchronous design patterns in TypeScript","description":"Examples that demonstrate how to use `sleep` and `condition` to model asynchronous business logic.","label":"Asynchronous design patterns","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe real value of `sleep` and `condition` is in knowing how to use them to model asynchronous business logic.\nHere are some examples we use the most; we welcome more if you can think of them!\n\n<details>\n<summary>\nRacing Timers\n</summary>\n\nUse `Promise.race` with Timers to dynamically adjust delays.\n\n```ts\nexport async function processOrderWorkflow({\n  orderProcessingMS,\n  sendDelayedEmailTimeoutMS,\n}: ProcessOrderOptions): Promise<void> {\n  let processing = true;\n  const processOrderPromise = processOrder(orderProcessingMS).then(() => {\n    processing = false;\n  });\n\n  await Promise.race([processOrderPromise, sleep(sendDelayedEmailTimeoutMS)]);\n\n  if (processing) {\n    await sendNotificationEmail();\n    await processOrderPromise;\n  }\n}\n```\n\n</details>\n<details>\n<summary>\nRacing Signals\n</summary>\n\nUse `Promise.race` with Signals and Triggers to have a promise resolve at the earlier of either system time or human intervention.\n\n```ts\nimport { defineSignal, sleep, Trigger } from '@temporalio/workflow';\n\nconst userInteraction = new Trigger<boolean>();\nconst completeUserInteraction = defineSignal('completeUserInteraction');\n\nexport async function yourWorkflow(userId: string) {\n  setHandler(completeUserInteraction, () => userInteraction.resolve(true)); // programmatic resolve\n  const userInteracted = await Promise.race([\n    userInteraction,\n    sleep('30 days'),\n  ]);\n  if (!userInteracted) {\n    await sendReminderEmail(userId);\n  }\n}\n```\n\nYou can invert this to create a reminder pattern where the promise resolves _if_ no Signal is received.\n\n:::warning Antipattern: Racing sleep.then\n\nBe careful when racing a chained `sleep`.\nThis might cause bugs because the chained `.then` will still continue to execute.\n\n```js\nawait Promise.race([\n  sleep('5s').then(() => (status = 'timed_out')),\n  somethingElse.then(() => (status = 'processed')),\n]);\n\nif (status === 'processed') await complete(); // takes more than 5 seconds\n// status = timed_out\n```\n\n:::\n\n</details>\n\n<details>\n<summary>\nUpdatable Timer\n</summary>\n\nHere is how you can build an updatable Timer with `condition`:\n\n```ts\nimport * as wf from '@temporalio/workflow';\n\n// usage\nexport async function countdownWorkflow(): Promise<void> {\n  const target = Date.now() + 24 * 60 * 60 * 1000; // 1 day!!!\n  const timer = new UpdatableTimer(target);\n  console.log('timer set for: ' + new Date(target).toString());\n  wf.setHandler(setDeadlineSignal, (deadline) => {\n    // send in new deadlines via Signal\n    timer.deadline = deadline;\n    console.log('timer now set for: ' + new Date(deadline).toString());\n  });\n  wf.setHandler(timeLeftQuery, () => timer.deadline - Date.now());\n  await timer; // if you send in a signal with a new time, this timer will resolve earlier!\n  console.log('countdown done!');\n}\n```\n\nThis is available in the third-party package [`temporal-time-utils`](https://www.npmjs.com/package/temporal-time-utils#user-content-updatabletimer), where you can also see the implementation:\n\n```ts\n// implementation\nexport class UpdatableTimer implements PromiseLike<void> {\n  deadlineUpdated = false;\n  #deadline: number;\n\n  constructor(deadline: number) {\n    this.#deadline = deadline;\n  }\n\n  private async run(): Promise<void> {\n    /* eslint-disable no-constant-condition */\n    while (true) {\n      this.deadlineUpdated = false;\n      if (\n        !(await wf.condition(\n          () => this.deadlineUpdated,\n          this.#deadline - Date.now(),\n        ))\n      ) {\n        break;\n      }\n    }\n  }\n\n  then<TResult1 = void, TResult2 = never>(\n    onfulfilled?: (value: void) => TResult1 | PromiseLike<TResult1>,\n    onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>,\n  ): PromiseLike<TResult1 | TResult2> {\n    return this.run().then(onfulfilled, onrejected);\n  }\n\n  set deadline(value: number) {\n    this.#deadline = value;\n    this.deadlineUpdated = true;\n  }\n\n  get deadline(): number {\n    return this.#deadline;\n  }\n}\n```\n\n</details>\n","is_empty":false},{"file_name":"cancel-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/cancel-activity.md","id":"typescript/cancel-activity","title":"Cancel an Activity from a Workflow","description":"An Activity can be canceled from within a Workflow if the Activity sends Heartbeats.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCanceling an Activity from within a Workflow requires that the Activity Execution sends Heartbeats and sets a Heartbeat Timeout.\nIf the Heartbeat is not invoked, the Activity cannot receive a cancellation request.\nWhen any non-immediate Activity is executed, the Activity Execution should send Heartbeats and set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) to ensure that the server knows it is still working.\n\nWhen an Activity is canceled, an error is raised in the Activity at the next available opportunity.\nIf cleanup logic needs to be performed, it can be done in a `finally` clause or inside a caught cancel error.\nHowever, for the Activity to appear canceled the exception needs to be re-raised.\n\n:::note\n\nUnlike regular Activities, [Local Activities](/concepts/what-is-a-local-activity) can be canceled if they don't send Heartbeats.\nLocal Activities are handled locally, and all the information needed to handle the cancellation logic is available in the same Worker process.\n\n:::\n","is_empty":false},{"file_name":"cancel-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/cancel-an-activity.md","id":"typescript/cancel-an-activity","title":"Cancel an Activity","description":"If an Activity is supposed to react to Cancellation, you can test whether it reacts correctly by canceling it.","label":"Cancel an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity is supposed to react to a Cancellation, you can test whether it reacts correctly by canceling it.\n","is_empty":false},{"file_name":"cancellation-scopes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/cancellation-scopes.md","id":"typescript/cancellation-scopes","title":"Cancellation scopes in Typescript","label":"Cancellation scopes","tags":["developer-guide","typescript"],"ssdi":[],"markdown_content":"\nIn the TypeScript SDK, Workflows are represented internally by a tree of cancellation scopes, each with cancellation behaviors you can specify.\nBy default, everything runs in the \"root\" scope.\n\nScopes are created using the [CancellationScope](https://typescript.temporal.io/api/classes/workflow.CancellationScope) constructor or one of three static helpers:\n\n- [cancellable(fn)](https://typescript.temporal.io/api/classes/workflow.CancellationScope#cancellable-1): Children are automatically cancelled when their containing scope is cancelled.\n  - Equivalent to `new CancellationScope().run(fn)`.\n- [nonCancellable(fn)](https://typescript.temporal.io/api/classes/workflow.CancellationScope#noncancellable): Cancellation does not propagate to children.\n  - Equivalent to `new CancellationScope({ cancellable: false }).run(fn)`.\n- [withTimeout(timeoutMs, fn)](https://typescript.temporal.io/api/classes/workflow.CancellationScope#withtimeout): If a timeout triggers before `fn` resolves, the scope is cancelled, triggering cancellation of any enclosed operations, such as Activities and Timers.\n  - Equivalent to `new CancellationScope({ cancellable: true, timeout: timeoutMs }).run(fn)`.\n\nCancellations are applied to cancellation scopes, which can encompass an entire Workflow or just part of one.\nScopes can be nested, and cancellation propagates from outer scopes to inner ones.\nA Workflow's `main` function runs in the outermost scope.\nCancellations are handled by catching `CancelledFailure`s thrown by cancelable operations.\n\n`CancellationScope.run()` and the static helpers mentioned earlier return native JavaScript promises, so you can use the familiar Promise APIs like `Promise.all` and `Promise.race` to model your asynchronous logic.\nYou can also use the following APIs:\n\n- `CancellationScope.current()`: Get the current scope.\n- `scope.cancel()`: Cancel all operations inside a `scope`.\n- `scope.run(fn)`: Run an async function within a `scope` and return the result of `fn`.\n- `scope.cancelRequested`: A promise that resolves when a scope cancellation is requested, such as when Workflow code calls `cancel()` or the entire Workflow is cancelled by an external client.\n\nWhen a `CancellationScope` is cancelled, it propagates cancellation in any child scopes and of any cancelable operations created within it, such as the following:\n\n- Activities\n- Timers (created with the [sleep](https://typescript.temporal.io/api/namespaces/workflow#sleep) function)\n- [Triggers](https://typescript.temporal.io/api/classes/workflow.Trigger)\n\n### CancelledFailure\n\nTimers and triggers throw [CancelledFailure](https://typescript.temporal.io/api/classes/client.CancelledFailure) when cancelled; Activities and Child Workflows throw `ActivityFailure` and `ChildWorkflowFailure` with cause set to `CancelledFailure`.\nOne exception is when an Activity or Child Workflow is scheduled in an already cancelled scope (or Workflow).\nIn this case, they propagate the `CancelledFailure` that was thrown to cancel the scope.\n\nTo simplify checking for cancellation, use the [isCancellation(err)](https://typescript.temporal.io/api/namespaces/workflow#iscancellation) function.\n\n### Internal cancellation example\n\n<!--SNIPSTART typescript-cancel-a-timer-from-workflow-->\n\n[packages/test/src/workflows/cancel-timer-immediately.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/cancel-timer-immediately.ts)\n\n```ts\nimport {\n  CancellationScope,\n  CancelledFailure,\n  sleep,\n} from '@temporalio/workflow';\n\nexport async function cancelTimer(): Promise<void> {\n  // Timers and Activities are automatically cancelled when their containing scope is cancelled.\n  try {\n    await CancellationScope.cancellable(async () => {\n      const promise = sleep(1); // <-- Will be cancelled because it is attached to this closure's scope\n      CancellationScope.current().cancel();\n      await promise; // <-- Promise must be awaited in order for `cancellable` to throw\n    });\n  } catch (e) {\n    if (e instanceof CancelledFailure) {\n      console.log('Timer cancelled 👍');\n    } else {\n      throw e; // <-- Fail the workflow\n    }\n  }\n}\n```\n\n<!--SNIPEND-->\n\nAlternatively, the preceding can be written as the following.\n\n<!--SNIPSTART typescript-cancel-a-timer-from-workflow-alternative-impl-->\n\n[packages/test/src/workflows/cancel-timer-immediately-alternative-impl.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/cancel-timer-immediately-alternative-impl.ts)\n\n```ts\nimport {\n  CancellationScope,\n  CancelledFailure,\n  sleep,\n} from '@temporalio/workflow';\n\nexport async function cancelTimerAltImpl(): Promise<void> {\n  try {\n    const scope = new CancellationScope();\n    const promise = scope.run(() => sleep(1));\n    scope.cancel(); // <-- Cancel the timer created in scope\n    await promise; // <-- Throws CancelledFailure\n  } catch (e) {\n    if (e instanceof CancelledFailure) {\n      console.log('Timer cancelled 👍');\n    } else {\n      throw e; // <-- Fail the workflow\n    }\n  }\n}\n```\n\n<!--SNIPEND-->\n\n### External cancellation example\n\nThe following code shows how to handle Workflow cancellation by an external client while an Activity is running.\n\n<!-- TODO: add a sample here of how this Workflow could be cancelled using a WorkflowHandle -->\n\n<!--SNIPSTART typescript-handle-external-workflow-cancellation-while-activity-running-->\n\n[packages/test/src/workflows/handle-external-workflow-cancellation-while-activity-running.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/handle-external-workflow-cancellation-while-activity-running.ts)\n\n```ts\nimport {\n  CancellationScope,\n  isCancellation,\n  proxyActivities,\n} from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpPostJSON, cleanup } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function handleExternalWorkflowCancellationWhileActivityRunning(\n  url: string,\n  data: any,\n): Promise<void> {\n  try {\n    await httpPostJSON(url, data);\n  } catch (err) {\n    if (isCancellation(err)) {\n      console.log('Workflow cancelled');\n      // Cleanup logic must be in a nonCancellable scope\n      // If we'd run cleanup outside of a nonCancellable scope it would've been cancelled\n      // before being started because the Workflow's root scope is cancelled.\n      await CancellationScope.nonCancellable(() => cleanup(url));\n    }\n    throw err; // <-- Fail the Workflow\n  }\n}\n```\n\n<!--SNIPEND-->\n\n### nonCancellable example\n\n`CancellationScope.nonCancellable` prevents cancellation from propagating to children.\n\n<!--SNIPSTART typescript-non-cancellable-shields-children-->\n\n[packages/test/src/workflows/non-cancellable-shields-children.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/non-cancellable-shields-children.ts)\n\n```ts\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function nonCancellable(url: string): Promise<any> {\n  // Prevent Activity from being cancelled and await completion.\n  // Note that the Workflow is completely oblivious and impervious to cancellation in this example.\n  return CancellationScope.nonCancellable(() => httpGetJSON(url));\n}\n```\n\n<!--SNIPEND-->\n\n### withTimeout example\n\nA common operation is to cancel one or more Activities if a deadline elapses.\n`withTimeout` creates a `CancellationScope` that is automatically cancelled after a timeout.\n\n<!--SNIPSTART typescript-multiple-activities-single-timeout-workflow-->\n\n[packages/test/src/workflows/multiple-activities-single-timeout.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/multiple-activities-single-timeout.ts)\n\n```ts\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nexport function multipleActivitiesSingleTimeout(\n  urls: string[],\n  timeoutMs: number,\n): Promise<any> {\n  const { httpGetJSON } = proxyActivities<typeof activities>({\n    startToCloseTimeout: timeoutMs,\n  });\n\n  // If timeout triggers before all activities complete\n  // the Workflow will fail with a CancelledError.\n  return CancellationScope.withTimeout(\n    timeoutMs,\n    () => Promise.all(urls.map((url) => httpGetJSON(url))),\n  );\n}\n```\n\n<!--SNIPEND-->\n\n### scope.cancelRequested\n\nYou can await `cancelRequested` to make a Workflow aware of cancellation while waiting on `nonCancellable` scopes.\n\n<!--SNIPSTART typescript-cancel-requested-with-non-cancellable-->\n\n[packages/test/src/workflows/cancel-requested-with-non-cancellable.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/cancel-requested-with-non-cancellable.ts)\n\n```ts\nimport {\n  CancellationScope,\n  CancelledFailure,\n  proxyActivities,\n} from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function resumeAfterCancellation(url: string): Promise<any> {\n  let result: any = undefined;\n  const scope = new CancellationScope({ cancellable: false });\n  const promise = scope.run(() => httpGetJSON(url));\n  try {\n    result = await Promise.race([scope.cancelRequested, promise]);\n  } catch (err) {\n    if (!(err instanceof CancelledFailure)) {\n      throw err;\n    }\n    // Prevent Workflow from completing so Activity can complete\n    result = await promise;\n  }\n  return result;\n}\n```\n\n<!--SNIPEND-->\n\n### Cancellation scopes and callbacks\n\nCallbacks are not particularly useful in Workflows because all meaningful asynchronous operations return promises.\nIn the rare case that code uses callbacks and needs to handle cancellation, a callback can consume the `CancellationScope.cancelRequested` promise.\n\n<!--SNIPSTART typescript-cancellation-scopes-with-callbacks-->\n\n[packages/test/src/workflows/cancellation-scopes-with-callbacks.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/cancellation-scopes-with-callbacks.ts)\n\n```ts\nimport { CancellationScope } from '@temporalio/workflow';\n\nfunction doSomething(callback: () => any) {\n  setTimeout(callback, 10);\n}\n\nexport async function cancellationScopesWithCallbacks(): Promise<void> {\n  await new Promise<void>((resolve, reject) => {\n    doSomething(resolve);\n    CancellationScope.current().cancelRequested.catch(reject);\n  });\n}\n```\n\n<!--SNIPEND-->\n\n### Nesting cancellation scopes\n\nYou can achieve complex flows by nesting cancellation scopes.\n\n<!--SNIPSTART typescript-nested-cancellation-scopes-->\n\n[packages/test/src/workflows/nested-cancellation.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/nested-cancellation.ts)\n\n```ts\nimport {\n  CancellationScope,\n  isCancellation,\n  proxyActivities,\n} from '@temporalio/workflow';\n\nimport type * as activities from '../activities';\n\nconst { setup, httpPostJSON, cleanup } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function nestedCancellation(url: string): Promise<void> {\n  await CancellationScope.cancellable(async () => {\n    await CancellationScope.nonCancellable(() => setup());\n    try {\n      await CancellationScope.withTimeout(\n        1000,\n        () => httpPostJSON(url, { some: 'data' }),\n      );\n    } catch (err) {\n      if (isCancellation(err)) {\n        await CancellationScope.nonCancellable(() => cleanup(url));\n      }\n      throw err;\n    }\n  });\n}\n```\n\n<!--SNIPEND-->\n\n### Sharing promises between scopes\n\nOperations like Timers and Activities are cancelled by the cancellation scope they were created in.\nPromises returned by these operations can be awaited in different scopes.\n\n<!--SNIPSTART typescript-shared-promise-scopes-->\n\n[packages/test/src/workflows/shared-promise-scopes.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/shared-promise-scopes.ts)\n\n```ts\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function sharedScopes(): Promise<any> {\n  // Start activities in the root scope\n  const p1 = httpGetJSON('http://url1.ninja');\n  const p2 = httpGetJSON('http://url2.ninja');\n\n  const scopePromise = CancellationScope.cancellable(async () => {\n    const first = await Promise.race([p1, p2]);\n    // Does not cancel activity1 or activity2 as they're linked to the root scope\n    CancellationScope.current().cancel();\n    return first;\n  });\n  return await scopePromise;\n  // The Activity that did not complete will effectively be cancelled when\n  // Workflow completes unless the Activity is awaited:\n  // await Promise.all([p1, p2]);\n}\n```\n\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-shield-awaited-in-root-scope-->\n\n[packages/test/src/workflows/shield-awaited-in-root-scope.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/shield-awaited-in-root-scope.ts)\n\n```ts\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function shieldAwaitedInRootScope(): Promise<any> {\n  let p: Promise<any> | undefined = undefined;\n\n  await CancellationScope.nonCancellable(async () => {\n    p = httpGetJSON('http://example.com'); // <-- Start activity in nonCancellable scope without awaiting completion\n  });\n  // Activity is shielded from cancellation even though it is awaited in the cancellable root scope\n  return p;\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"child-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/child-workflows.md","id":"typescript/child-workflows","title":"How to start a Child Workflow Execution","description":"A Child Workflow Execution is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.","label":"Child Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.\n\nWhen using a Child Workflow API, Child Workflow–related Events (such as [StartChildWorkflowExecutionInitiated](/references/events#startchildworkflowexecutioninitiated), [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted), and [ChildWorkflowExecutionCompleted](/references/events#childworkflowexecutioncompleted)) are logged in the Event History of the Child Workflow Execution.\n\nAlways block progress until the [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted) Event is logged to the Event History to ensure the Child Workflow Execution has started.\nAfter that, Child Workflow Executions can be abandoned by using the default `Abandon` [Parent Close Policy](/concepts/what-is-a-parent-close-policy) set in the Child Workflow Options.\n\nTo be sure that the Child Workflow Execution has started, first call the Child Workflow Execution method on the instance of Child Workflow future, which returns a different future.\n\nThen get the value of an object that acts as a proxy for a result that is initially unknown, which is what waits until the Child Workflow Execution has spawned.\n","is_empty":false},{"file_name":"clients.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/clients.md","id":"typescript/clients","title":"Workflow Clients in TypeScript","description":"Workflow Clients are embedded in your application code, and connect to Temporal Server via gRPC. They are the only way to schedule new Workflow Executions with Temporal Server.","label":"Clients","ssdi":[],"markdown_content":"\n<!-- prettier-ignore -->\n\nimport * as WhatIsATemporalCronJob from '../concepts/what-is-a-temporal-cron-job.md'\n\n**`@temporalio/client`** [![NPM](https://img.shields.io/npm/v/@temporalio/client)](https://www.npmjs.com/package/@temporalio/client) [API reference](https://typescript.temporal.io/api/namespaces/client) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/client)\n\n**Workflow Clients are embedded in your application code and connect to Temporal Server via gRPC**.\nThey are the only way to schedule new Workflow Executions with Temporal Server.\n\n- Workflow Clients can run in any Node.js application, for example, in a serverless function, Express.js API route handler or CLI/script run.\n- The primary use of Workflow Clients is to start new Workflow Executions (including [Cron Workflows](#scheduling-cron-workflows)).\n  Given a `workflowId`, a Workflow Client can also get a Handle to a running Workflow Execution or retrieve/wait for its result.\n- **Workflow Handles** are bindings to specific Workflow Executions that expose more APIs for control.\n\n  **We strongly recommend familiarizing yourself with Workflow Handle APIs** because they are the main way you will signal, query, describe, cancel, terminate, and await the result of running Workflow Executions.\n\n- Advanced users can also use the `WorkflowService` exposed by a Workflow Client to make **raw gRPC calls** (usually for introspection).\n\nWorkflow Clients are separate from Workers, but communicate with them through Task Queues to start Workflow Executions.\nFor more information, see [Workers and Task Queues in TypeScript](/typescript/workers) and [Workflows in TypeScript](/typescript/workflows).\n\n## Full Example\n\nThe following code is a `WorkflowClient` example, from our Hello World sample:\n\n<!--SNIPSTART typescript-hello-client -->\n\n[hello-world/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/hello-world/src/client.ts)\n\n```ts\nimport { Client, Connection } from '@temporalio/client';\nimport { nanoid } from 'nanoid';\nimport { example } from './workflows';\n\nasync function run() {\n  // Connect to the default Server location (localhost:7233)\n  const connection = await Connection.connect();\n  // In production, pass options to configure TLS and other settings:\n  // {\n  //   address: 'foo.bar.tmprl.cloud',\n  //   tls: {}\n  // }\n\n  const client = new Client({\n    connection,\n    // namespace: 'foo.bar', // connects to 'default' namespace if not specified\n  });\n\n  const handle = await client.workflow.start(example, {\n    // type inference works! args: [name: string]\n    args: ['Temporal'],\n    taskQueue: 'hello-world',\n    // in practice, use a meaningful business ID, like customerId or transactionId\n    workflowId: 'workflow-' + nanoid(),\n  });\n  console.log(`Started workflow ${handle.workflowId}`);\n\n  // optional: wait for client result\n  console.log(await handle.result()); // Hello, Temporal!\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n<!--SNIPEND-->\n\nThe rest of this document explains each step in detail with practical usage tips.\n\n## Create a new Workflow Client\n\nCreate a [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.WorkflowClient) with the requisite gRPC [`Connection`](https://typescript.temporal.io/api/classes/client.Connection):\n\n```ts\nimport { Connection, WorkflowClient } from '@temporalio/client';\nconst connection = await Connection.connect({\n  address: 'temporal.prod.my.org',\n}); // to configure for production\nconst client = new WorkflowClient({ connection });\n```\n\nIf you omit the connection and just call `new WorkflowClient()`, it creates a default connection that will work locally. Just remember you will need to configure your Connection and Namespace when [deploying to production](/typescript/security#encryption-in-transit-with-mtls).\n\n## Start a Workflow Execution\n\nWhen you have a Workflow Client, you can schedule the start of a Workflow with `client.start`, specifying `workflowId`, `taskQueue`, and `args` and returning a Workflow Handle (see below) immediately after the Server acknowledges receipt.\n\n```ts\n// // STEP ONE: client.start\n// Option 1: Specifying args and workflowId\nconst handle = await client.start(example, {\n  workflowId: 'business-meaningful-id',\n  taskQueue: 'tutorial',\n  args: ['foo', 'bar', 'baz'], // this is typechecked against workflowFn's args\n});\n\n// Option 2: Just using string name; no need to import Workflow, but no type inference\nimport { WorkflowStartOptions } from '@temporalio/client';\ntype WFType = (key: number) => Promise<string>; // arg types intentionally wrong to prove a point\nconst handle = await client.start<string>('example', {\n  workflowId: 'business-meaningful-id',\n  taskQueue: 'tutorial',\n  args: [123], // typechecked, but actually wrong at runtime because wrong type signature\n} as WorkflowStartOptions<WFType>);\n\n// // STEP TWO: client.getHandle\n// Continue in a different process (such as a serverless function)\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result(); // wait for Workflow to complete and get result. See below for other Handle APIs\n\n// alternative combination of STEP ONE + TWO\nconst result = await client.execute(example /*...*/); // start and immediately wait for Workflow to complete and get result\n```\n\n<details>\n<summary>Note: Scheduling is not the same as Starting Workflows\n</summary>\n\nCalling `client.start` (or `client.execute`) merely sends a Command to Temporal Server to schedule a new Workflow Execution on the specified Task Queue; it does not actually start until a Worker (that has a matching Workflow Type) polling that Task Queue picks it up.\n\nYou can test this by executing a Workflow Client command without a matching Worker.\nTemporal Server records the command in Event History but does not make progress with the Workflow Execution until a Worker starts polling with a matching Task Queue and Workflow Definition.\n\nThis queuing mechanic makes your application tolerant to outages and horizontally scalable, but can be confusing to newcomers if they expect that calling `client.execute(YourWorkflow)` directly executes the Workflow code on the same machine as the Client.\n\n</details>\n\n### Workflow Options\n\nA brief guide to the [WorkflowOptions](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions) available to you:\n\n- `workflowId`, `taskQueue`, and `args` (if required) are the main ones you will regularly use\n- Optional features:\n  - `memo` (simple annotation of Workflows)\n  - `searchAttributes` (see [Search Attributes](/typescript/search-attributes))\n  - `cronSchedule` (see important notes in [Cron Workflows](#scheduling-cron-workflows) section below)\n- Advanced features you probably won't need: `followRuns` and `workflowIdReusePolicy`.\n\n:::caution\n\nWorkflow-level Retries and Timeouts are not recommended.\n\nYou will see that there are `workflowRunTimeout`, `workflowExecutionTimeout`, `workflowTaskTimeout`, and `retryPolicy` options in [WorkflowOptions](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions).\nWe discourage using them unless you know what you are doing.\nDo not rely on Workflows to timeout or fail - you probably want to push this logic down to an Activity instead.\n\n:::\n\n## Workflow Handle APIs\n\n**Workflow Handles** are returned after you start a Workflow (or retrieve an existing one with `client.getHandle`) and are bound to a single Workflow instance. They represent already-started Workflow Executions, and let you `signal`, `query`, `describe`, `cancel`, or `terminate` their instance:\n\n```ts\n// Get a handle if you don't already have it\nconst handle = client.getHandle(workflowId);\n\n// Handle API quick examples\nawait handle.cancel(); // cancel with cleanup\nawait handle.terminate(); // kill immediately\nconst WFdescription = await handle.describe(); // get Workflow Execution internal info\nawait handle.signal<Args>(mySignal, ...args); // see Signal docs\nconst queryResult = await handle.query<ReturnType, Args>(myQuery, ...args); // see Query docs\nconst result = await handle.result(); // block until the workflow completes and/or get return value\nconst result = await client.execute(example /*...*/); // Alternative API for starting and immediately waiting for Workflow completion\n```\n\nThe [Workflow Handle APIs](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle) let you externally control your Workflow:\n\n| Handle API            | Description                                                                                                                               |\n| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| `client`              | Readonly accessor to the underlying Workflow Client.                                                                                      |\n| `workflowId`          | The `workflowId` of the current Workflow.                                                                                                 |\n| `firstExecutionRunId` | The `runId` of the initial run of the bound Workflow (available on handles created with `start`).                                         |\n| `signaledRunId`       | The `runId` of the signalled run of the bound Workflow (available on handles created with `startWithStart`).                              |\n| `query()`             | Call to query a Workflow after it's been started even if it has already completed. `const value = await handle.query(getValue, ...args);` |\n| `signal()`            | Call to signal a _running_ Workflow. `await handle.signal(increment, ...args);`                                                           |\n| `cancel()`            | Cancels a running Workflow.                                                                                                               |\n| `terminate()`         | Terminates a running Workflow.                                                                                                            |\n| `describe()`          | Describes the current Workflow Execution.                                                                                                 |\n| `result()`            | Promise that resolves when Workflow Execution completes.                                                                                  |\n\nThe following covers how to use many of these APIs, you will want to be fluent with them as they cover the basics of Workflow manipulation.\n\n### Get a Workflow's result\n\nWorkflow functions may or may not return a result when they complete.\n\nIf you started a Workflow with `handle.start`, you can choose to wait for the result anytime with `handle.result()`.\n\n```ts\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result(); // block until the workflow completes, if you wish\n```\n\nUsing a Workflow Handle isn't necessary with `client.execute` by definition.\n\n- **Don't forget to handle errors here.**\n  If you call `result()` on a Workflow that prematurely ended for some reason, it throws a [WorkflowFailedError](https://typescript.temporal.io/api/classes/client.WorkflowFailedError) error that reflects that reason.\n\n  ```ts\n  const handle = client.getHandle(workflowId);\n  try {\n    const result = await handle.result(); // block until the workflow completes, if you wish\n  } catch (err) {\n    if (err instanceof WorkflowFailedError) {\n      throw new Error('Temporal workflow failed: ' + workflowId, {\n        cause: err,\n      });\n    } else {\n      throw new Error('error from Temporal workflow ' + workflowId, {\n        cause: err,\n      });\n    }\n  }\n  ```\n\n- You can also specify a `runId`, but you will almost never need it, because most people only want the results of the latest run (a Workflow may run multiple times if failed or continued as new).\n\n### Cancel a Workflow\n\nTo cancel a Workflow Execution, call the [`handle.cancel()`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#cancel) method on a Workflow Handle.\n\n```ts\n// Start the Workflow without waiting its completion\nawait handle.start(args);\n// ... Later on, cancel the workflow\nawait handle.cancel();\n```\n\nWith `handle.cancel()`, Timers and Child Workflows have the opportunity to execute cleanup code.\nIf you wish to skip that, you can also [`handle.terminate()`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#terminate) forcefully.\n\nTemporal gives you fine grained control over what happens when you cancel a workflow. See our docs on [Cancellation Scopes](/typescript/cancellation-scopes) for details and examples.\n\n## Scheduling Cron Workflows\n\nYou can set each Workflow to repeat on a schedule with the `cronSchedule` option:\n\n```ts\nconst handle = await client.start(scheduledWorkflow, {\n  workflowId: 'business-meaningful-id',\n  taskQueue: 'tutorial',\n  cronSchedule: '* * * * *', // start every minute\n});\n```\n\n:::info Should I use Cron Workflows or Timers?\n\nThis section is specifically about <preview page={WhatIsATemporalCronJob}>Temporal Cron Jobs</preview>, which are Workflows that have the `cronSchedule` option set in Temporal.\nBecause Temporal Workflows have [Timers](/typescript/workflows#timers), can loop indefinitely, and can spawn [Child Workflows](/typescript/workflows#child-workflows), it is natural to ask when to use which.\n\nCron Workflows are rigid and come with a lot of caveats.\nThey are a great choice if you have Workflows that need to run as rigidly as the native Linux `cron` utility (except distributed and fault tolerant).\nHowever, if you have any advanced needs (including needing overlaps, or canceling individual executions without affecting the overall schedule), use Timers.\n\n:::\n\nYou can set each Workflow to repeat on a schedule with the `cronSchedule` option:\n\n```ts\nconst handle = await client.start(scheduledWorkflow, {\n  taskQueue: 'test',\n  cronSchedule: '* * * * *', // start every minute\n});\n```\n\nFor more information, see the Typescript SDK [`workflowOptions` source code](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#cronschedule).\n\n## Note: Child Workflows and External Workflows\n\nYou can start Child Workflows only from within another Workflow, and not from a Client.\n\n**Hence the main Child Workflows documentation is on the [Workflow APIs](/typescript/workflows#child-workflows) page.**\n\nA lot of the same concepts about starting, executing, and signaling Workflow Executions apply:\n\n```ts\n// inside Workflow code\nimport { startChild } from '@temporalio/workflow';\n\nexport async function example(WFname: string, args: string[]): Promise<string> {\n  const childHandle = await startChild(WFname, {\n    // workflowId is optional only for child workflows\n    // task queue and other options inherited from parent, can override\n    args,\n  });\n  const result = await childHandle.result();\n  // // equivalent to\n  // const result = await executeChild(WFname, /* ... */)\n  return result;\n}\n```\n\nYou should use [cancellationScopes](/typescript/cancellation-scopes) if you need to cancel Child Workflows.\n\nThe same concept of \"Workflow Handles\" applies to retrieving handles for Child and External Workflows—as long as you have the Workflow Id:\n\n```ts\n// inside Workflow code\nimport { getExternalWorkflowHandle } from '@temporalio/workflow';\n\nexport async function CancelExternalWorkflow(wfId: string): void {\n  const extHandle = getExternalWorkflowHandle(wfId);\n  // ...\n}\n```\n\nAgain, see [Workflows in TypeScript](/typescript/workflows#external-workflows) for full details.\n\n## Advanced: Making raw gRPC calls\n\nUnder the hood of a `WorkflowClient`, the `Connection` is actually powered by a `WorkflowService` driver that makes the raw gRPC calls to Temporal Server.\nThis Service is capable of making a wider range of introspection calls.\n\n<!--SNIPSTART typescript-grpc-call-basic-->\n\n[grpc-calls/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/grpc-calls/src/client.ts)\n\n```ts\nconst connection = await Connection.connect();\n\n// // normal way of starting a Workflow, with a Client\n// const client = new Client({ connection });\n// await client.workflow.start(/* etc */);\n\nconst payload = defaultPayloadConverter.toPayload('Temporal');\nif (payload == null) {\n  // This should not happen with standard inputs and the defaultPayloadConverter.\n  throw new TypeError('Could not convert string to payload');\n}\n// equivalent grpc call to client.start()\nawait connection.workflowService.startWorkflowExecution({\n  namespace: 'default',\n  workflowId,\n  requestId,\n  taskQueue: { name: 'grpc-calls' },\n  workflowType: { name: 'example' },\n  input: {\n    // Client passes data through Data Converter to convert to Payloads; with gRPC calls have to do it yourself\n    // import { defaultPayloadConverter, toPayloads } from '@temporalio/common';\n    payloads: [payload],\n  },\n});\n```\n\n<!--SNIPEND-->\n\nUsing gRPC calls is often the only way to access some of the more advanced queries you can make from Temporal Server.\nWe highlight some queries of interest here:\n\n<details>\n<summary><a class=\"font-mono\" href=\"https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.WorkflowService-1#getworkflowexecutionhistory\">getWorkflowExecutionHistory</a>\n</summary>\n\n<!--SNIPSTART typescript-grpc-call-getWorkflowExecutionHistory-->\n\n[grpc-calls/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/grpc-calls/src/client.ts)\n\n```ts\n// no equivalent call in client, this is only available as an SDK call\nconst res = await connection.workflowService.getWorkflowExecutionHistory({\n  execution: { workflowId },\n  namespace: 'default',\n});\nconsole.log(res.history);\n```\n\n<!--SNIPEND-->\n\nOutputs something like:\n\n```\n{\n  events: [\n    HistoryEvent {\n      eventId: [Long],\n      eventTime: [Timestamp],\n      eventType: 1,\n      taskId: [Long],\n      workflowExecutionStartedEventAttributes: [WorkflowExecutionStartedEventAttributes]\n    },\n    HistoryEvent {\n      eventId: [Long],\n      eventTime: [Timestamp],\n      eventType: 5,\n      taskId: [Long],\n      workflowTaskScheduledEventAttributes: [WorkflowTaskScheduledEventAttributes]\n    },\n    HistoryEvent {\n      eventId: [Long],\n      eventTime: [Timestamp],\n      eventType: 6,\n      taskId: [Long],\n      workflowTaskStartedEventAttributes: [WorkflowTaskStartedEventAttributes]\n    }\n  ]\n}\n```\n\n</details>\n\n<details>\n<summary><a class=\"font-mono\" href=\"https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.WorkflowService-1#listworkflowexecutions) (requires ElasticSearch)\">listWorkflowExecutions</a>\n</summary>\n\n<!--SNIPSTART typescript-grpc-call-listWorkflowExecutions-->\n\n[grpc-calls/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/grpc-calls/src/client.ts)\n\n```ts\n// no equivalent call in client, this is only available as an SDK call\n// requires ElasticSearch\nconst results = await connection.workflowService.listWorkflowExecutions({\n  namespace: 'default',\n});\nconsole.table(results.executions);\n```\n\n<!--SNIPEND-->\n\nOutputs something like:\n\n```\n┌─────────┬───────────────────────────────────────────────────────────────────────────────────────────────────┬──────────────────────────────────┬─────────────────────────────────────────────────┬─────────────────────────────────────────────────┬────────┬───────────────┬─────────────────────────────────────────────────┬─────────────────────┬──────────────────────────────────────────────┬────────────┬──────────────────────┐\n│ (index) │                                             execution                                             │               type               │                    startTime                    │                    closeTime                    │ status │ historyLength │                  executionTime                  │        memo         │               searchAttributes               │ taskQueue  │ stateTransitionCount │\n├─────────┼───────────────────────────────────────────────────────────────────────────────────────────────────┼──────────────────────────────────┼─────────────────────────────────────────────────┼─────────────────────────────────────────────────┼────────┼───────────────┼─────────────────────────────────────────────────┼─────────────────────┼──────────────────────────────────────────────┼────────────┼──────────────────────┤\n│    0    │ WorkflowExecution { workflowId: 'your-business-id', runId: '2798482a-46d8-4f1e-ab87-1ba3f7ddda1c' } │ WorkflowType { name: 'example' } │ Timestamp { seconds: [Long], nanos: 125158275 } │ Timestamp { seconds: [Long], nanos: 263021256 } │   2    │    [Long]     │ Timestamp { seconds: [Long], nanos: 125158275 } │ Memo { fields: {} } │ SearchAttributes { indexedFields: [Object] } │ 'tutorial' │        [Long]        │\n│    1    │ WorkflowExecution { workflowId: 'your-business-id', runId: '76f1171b-7a73-46a3-ba66-b77bab0b73f8' } │ WorkflowType { name: 'example' } │ Timestamp { seconds: [Long], nanos: 841243925 } │ Timestamp { seconds: [Long], nanos: 935283589 } │   2    │    [Long]     │ Timestamp { seconds: [Long], nanos: 841243925 } │ Memo { fields: {} } │ SearchAttributes { indexedFields: [Object] } │ 'tutorial' │        [Long]        │\n│    2    │ WorkflowExecution { workflowId: 'your-business-id', runId: '6d1197b7-41b8-47be-89b4-f1ef3446de1a' } │ WorkflowType { name: 'example' } │ Timestamp { seconds: [Long], nanos: 425778697 } │ Timestamp { seconds: [Long], nanos: 523022091 } │   2    │    [Long]     │ Timestamp { seconds: [Long], nanos: 425778697 } │ Memo { fields: {} } │ SearchAttributes { indexedFields: [Object] } │ 'tutorial' │        [Long]        │\n└─────────┴───────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────────────────────────┴─────────────────────────────────────────────────┴─────────────────────────────────────────────────┴────────┴───────────────┴─────────────────────────────────────────────────┴─────────────────────┴──────────────────────────────────────────────┴────────────┴──────────────────────┘\n```\n\n</details>\n\n**For the full list of gRPC calls, see the Methods section of the [WorkflowService](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.WorkflowService-1#methods) API reference.**\n\nNote that if you are trying to do a lot of list-then-filter operations (e.g. `listClosedWorkflowExecutions`), the [Visibility APIs](/typescript/search-attributes) are a better choice for Temporal deployments with [ElasticSearch enabled](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster/) (this is enabled by default for all Temporal Cloud customers).\n","is_empty":false},{"file_name":"code-samples-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/code-samples-typescript.md","id":"typescript/code-samples-typescript","title":"Code samples","description":"Use the TypeScript samples library stored on GitHub to demonstrate various capabilities of Temporal.","label":"Code samples","tags":["how-to","typescript"],"ssdi":[],"markdown_content":"\nUse the [TypeScript samples library](https://github.com/temporalio/samples-typescript) stored on GitHub to demonstrate various capabilities of Temporal.\n\n**Where can I find video demos?**\n\n[Temporal TypeScript YouTube playlist](https://www.youtube.com/playlist?list=PLl9kRkvFJrlTavecydpk9r6cF7qBmQJvb).\n","is_empty":false},{"file_name":"code-samples.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/code-samples.md","id":"typescript/code-samples","title":"Where are SDK-specific code examples?","description":"You can find a complete list of executable code samples in Temporal's GitHub repository.","label":"Code samples","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can find a complete list of executable code samples in [Temporal's GitHub repository](https://github.com/temporalio?q=samples-&type=all&language=&sort=).\n\nAdditionally, several of the [Tutorials](https://learn.temporal.io) are backed by a fully executable template application.\n","is_empty":false},{"file_name":"connect-to-a-dev-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/connect-to-a-dev-cluster.md","id":"typescript/connect-to-a-dev-cluster","title":"How to connect a Temporal Client to a Temporal Cluster","description":"When connecting a Temporal Client to a Temporal Cluster, you must provide the address and port number of the Temporal Cluster.","label":"Connect to a dev Cluster","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal Client](/concepts/what-is-a-temporal-client) enables you to communicate with the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nCommunication with a Temporal Cluster includes, but isn't limited to, the following:\n\n- Starting Workflow Executions.\n- Sending Signals to Workflow Executions.\n- Sending Queries to Workflow Executions.\n- Getting the results of a Workflow Execution.\n- Providing an Activity Task Token.\n\n:::caution\n\nA Temporal Client cannot be initialized and used inside a Workflow.\nHowever, it is acceptable and common to use a Temporal Client inside an Activity to communicate with a Temporal Cluster.\n\n:::\n\nWhen you are running a Cluster locally (such as [Temporalite](/kb/all-the-ways-to-run-a-cluster#temporalite)), the number of connection options you must provide is minimal.\nMany SDKs default to the local host or IP address and port that Temporalite and [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose) serve (`127.0.0.1:7233`).\n","is_empty":false},{"file_name":"connect-to-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/connect-to-temporal-cloud.md","id":"typescript/connect-to-temporal-cloud","title":"How to connect to Temporal Cloud","description":"Use a compatible mTLS CA certificate and mTLS private key and your Cloud Namespace to connect to Temporal Cloud.","label":"Connect to Temporal Cloud","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen you connect to [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"continue-as-new.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/continue-as-new.md","id":"typescript/continue-as-new","title":"How to Continue-As-New","description":"Continue-As-New enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.","label":"Continue-As-New","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Continue-As-New](/concepts/what-is-continue-as-new) enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.\nThe Workflow Execution spawned from the use of Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\n","is_empty":false},{"file_name":"cron-jobs.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/cron-jobs.md","id":"typescript/cron-jobs","title":"How to use Temporal Cron Jobs","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Jobs","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.\n","is_empty":false},{"file_name":"custom-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/custom-logging.md","id":"typescript/custom-logging","title":"How to provide a custom logger","description":"Use a custom logger for logging.","label":"Custom logger","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a custom logger for logging.\n","is_empty":false},{"file_name":"data-converters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/data-converters.md","id":"typescript/data-converters","title":"Data Converters","description":"Learn and customize how data is serialized in the TypeScript SDK","label":"Data Converters","ssdi":[],"markdown_content":"\n> Background reading: [Data Converters in Temporal](/concepts/what-is-a-data-converter/)\n\nContents:\n\nimport TOCInline from '@theme/TOCInline'\n\n<TOCInline\n  toc={toc}\n  maxHeadingLevel={4}\n/>\n\n## Default Data Converter\n\nIn TypeScript, the default Data Converter supports:\n\n- `undefined`\n- `Uint8Array`\n- JSON\n\n## Custom Data Converter\n\n> API doc: [DataConverter](https://typescript.temporal.io/api/interfaces/worker.DataConverter/)\n\nTo send values that are not [JSON-serializable](https://en.wikipedia.org/wiki/JSON#Data_types) like `BigInt`s or `Date`s, provide a custom Data Converter to the Client and Worker:\n\n- [`new WorkflowClient({ ..., dataConverter })`](https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions#dataconverter)\n- [`Worker.create({ ..., dataConverter })`](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#dataconverter)\n\nData Converters have [two parts](/concepts/what-is-a-data-converter#payload-codec):\n\n- [`PayloadConverter`](#payloadconverter): sync methods that sometimes run inside the Workflow isolate (and are thus [limited](/typescript/determinism#imports-in-workflow-code))\n- [`PayloadCodec`](#payloadcodec): async methods that are run outside the isolate\n\n```ts\ninterface DataConverter {\n  payloadConverterPath?: string;\n  payloadCodecs?: PayloadCodec[];\n}\n```\n\n### `PayloadConverter`\n\n> API doc: [PayloadConverter](https://typescript.temporal.io/api/interfaces/common.PayloadConverter)\n\n```ts\ninterface PayloadConverter {\n  /**\n   * Converts a value to a {@link Payload}.\n   * @param value The value to convert. Example values include the Workflow args sent by the client and the values returned by a Workflow or Activity.\n   */\n  toPayload<T>(value: T): Payload;\n\n  /**\n   * Converts a {@link Payload} back to a value.\n   */\n  fromPayload<T>(payload: Payload): T;\n}\n```\n\n#### Custom implementation\n\nSome example implementations are in the SDK itself:\n\n- [`common/src/converter/payload-converters.ts`](https://github.com/temporalio/sdk-typescript/blob/main/packages/common/src/converter/payload-converters.ts)\n- [`common/src/converter/protobuf-payload-converters.ts`](https://github.com/temporalio/sdk-typescript/blob/main/packages/common/src/converter/protobuf-payload-converters.ts)\n\nThere's also a sample project that creates an EJSON custom `PayloadConverter`: [samples-typescript/ejson](https://github.com/temporalio/samples-typescript/tree/main/ejson)\n\nIt implements `PayloadConverterWithEncoding` instead of `PayloadConverter` so that it could be used with [`CompositePayloadConverter`](https://typescript.temporal.io/api/classes/common.CompositePayloadConverter/):\n\n<!--SNIPSTART typescript-ejson-converter-impl -->\n\n[ejson/src/ejson-payload-converter.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/ejson-payload-converter.ts)\n\n```ts\nimport {\n  EncodingType,\n  METADATA_ENCODING_KEY,\n  Payload,\n  PayloadConverterError,\n  PayloadConverterWithEncoding,\n} from '@temporalio/common';\nimport { decode, encode } from '@temporalio/common/lib/encoding';\nimport EJSON from 'ejson';\n\n/**\n * Converts between values and [EJSON](https://docs.meteor.com/api/ejson.html) Payloads.\n */\nexport class EjsonPayloadConverter implements PayloadConverterWithEncoding {\n  // Use 'json/plain' so that Payloads are displayed in the UI\n  public encodingType = 'json/plain' as EncodingType;\n\n  public toPayload(value: unknown): Payload | undefined {\n    if (value === undefined) return undefined;\n    let ejson;\n    try {\n      ejson = EJSON.stringify(value);\n    } catch (e) {\n      throw new UnsupportedEjsonTypeError(\n        `Can't run EJSON.stringify on this value: ${value}. Either convert it (or its properties) to EJSON-serializable values (see https://docs.meteor.com/api/ejson.html ), or create a custom data converter. EJSON.stringify error message: ${\n          errorMessage(\n            e,\n          )\n        }`,\n        e as Error,\n      );\n    }\n\n    return {\n      metadata: {\n        [METADATA_ENCODING_KEY]: encode('json/plain'),\n        // Include an additional metadata field to indicate that this is an EJSON payload\n        format: encode('extended'),\n      },\n      data: encode(ejson),\n    };\n  }\n\n  public fromPayload<T>(content: Payload): T {\n    return content.data ? EJSON.parse(decode(content.data)) : content.data;\n  }\n}\n\nexport class UnsupportedEjsonTypeError extends PayloadConverterError {\n  public readonly name: string = 'UnsupportedJsonTypeError';\n\n  constructor(message: string | undefined, public readonly cause?: Error) {\n    super(message ?? undefined);\n  }\n}\n```\n\n<!--SNIPEND-->\n\nThen we instantiate one and export it:\n\n<!--SNIPSTART typescript-ejson-converter -->\n\n[ejson/src/payload-converter.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/payload-converter.ts)\n\n```ts\nimport {\n  CompositePayloadConverter,\n  UndefinedPayloadConverter,\n} from '@temporalio/common';\nimport { EjsonPayloadConverter } from './ejson-payload-converter';\n\nexport const payloadConverter = new CompositePayloadConverter(\n  new UndefinedPayloadConverter(),\n  new EjsonPayloadConverter(),\n);\n```\n\n<!--SNIPEND-->\n\nWe provide it to the Worker and Client:\n\n<!--SNIPSTART typescript-ejson-worker -->\n\n[ejson/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/worker.ts)\n\n```ts\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  taskQueue: 'ejson',\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-ejson-client-setup -->\n\n[ejson/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/client.ts)\n\n```ts\nconst client = new Client({\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n\n<!--SNIPEND-->\n\nThen we can use supported data types in arguments:\n\n<!--SNIPSTART typescript-ejson-client -->\n\n[ejson/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/client.ts)\n\n```ts\nconst user: User = {\n  id: uuid(),\n  // age: 1000n, BigInt isn't supported\n  hp: Infinity,\n  matcher: /.*Stormblessed/,\n  token: Uint8Array.from([1, 2, 3]),\n  createdAt: new Date(),\n};\n\nconst handle = await client.workflow.start(example, {\n  args: [user],\n  taskQueue: 'ejson',\n  workflowId: `example-user-${user.id}`,\n});\n```\n\n<!--SNIPEND-->\n\nAnd they get parsed correctly for the Workflow:\n\n<!--SNIPSTART typescript-ejson-workflow -->\n\n[ejson/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/workflows.ts)\n\n```ts\nimport type { Result, User } from './types';\n\nexport async function example(user: User): Promise<Result> {\n  const success = user.createdAt.getTime() < Date.now()\n    && user.hp > 50\n    && user.matcher.test('Kaladin Stormblessed')\n    && user.token instanceof Uint8Array;\n  return { success, at: new Date() };\n}\n```\n\n<!--SNIPEND-->\n\n#### Protobufs\n\nTo serialize values as [Protocol Buffers](https://en.wikipedia.org/wiki/Protocol_Buffers):\n\n- Use [`protobufjs`](https://protobufjs.github.io/protobuf.js/)\n- Use runtime-loaded messages (not generated classes) and `MessageClass.create` (not `new MessageClass()`)\n- Generate `json-module.js` with a command like:\n\n  ```sh\n  pbjs -t json-module -w commonjs -o protos/json-module.js protos/*.proto\n  ```\n\n- Patch `json-module.js`:\n\n<!--SNIPSTART typescript-protobuf-root -->\n\n[protobufs/protos/root.js](https://github.com/temporalio/samples-typescript/blob/master/protobufs/protos/root.js)\n\n```js\nconst { patchProtobufRoot } = require('@temporalio/common/lib/protobufs');\nconst unpatchedRoot = require('./json-module');\nmodule.exports = patchProtobufRoot(unpatchedRoot);\n```\n\n<!--SNIPEND-->\n\n- Generate `root.d.ts` with:\n\n  ```sh\n  pbjs -t static-module protos/*.proto | pbts -o protos/root.d.ts -\n  ```\n\n- Create a [`DefaultPayloadConverterWithProtobufs`](https://typescript.temporal.io/api/classes/protobufs.DefaultPayloadConverterWithProtobufs/):\n\n<!--SNIPSTART typescript-protobuf-converter -->\n\n[protobufs/src/payload-converter.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/payload-converter.ts)\n\n```ts\nimport { DefaultPayloadConverterWithProtobufs } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new DefaultPayloadConverterWithProtobufs({\n  protobufRoot: root,\n});\n```\n\n<!--SNIPEND-->\n\nAlternatively, we can use Protobuf Payload Converters directly, or with other converters. If we know that we only use Protobuf objects, and we want them binary encoded (which saves space over proto3 JSON, but can't be viewed in the Web UI), we could do:\n\n```ts\nimport { ProtobufBinaryPayloadConverter } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new ProtobufBinaryPayloadConverter(root);\n```\n\nSimilarly, if we wanted binary encoded Protobufs in addition to the other [default types](#default-data-converter), we could do:\n\n```ts\nimport {\n  BinaryPayloadConverter,\n  CompositePayloadConverter,\n  JsonPayloadConverter,\n  UndefinedPayloadConverter,\n} from '@temporalio/common';\nimport { ProtobufBinaryPayloadConverter } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new CompositePayloadConverter(\n  new UndefinedPayloadConverter(),\n  new BinaryPayloadConverter(),\n  new ProtobufBinaryPayloadConverter(root),\n  new JsonPayloadConverter(),\n);\n```\n\n- Provide it to the Worker:\n\n<!--SNIPSTART typescript-protobuf-worker -->\n\n[protobufs/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/worker.ts)\n\n```ts\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  activities,\n  taskQueue: 'protobufs',\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n\n<!--SNIPEND-->\n\n[`WorkerOptions.dataConverter`](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#dataconverter)\n\n- Provide it to the Client:\n\n<!--SNIPSTART typescript-protobuf-client -->\n\n[protobufs/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/client.ts)\n\n```ts\nimport { Client } from '@temporalio/client';\nimport { v4 as uuid } from 'uuid';\nimport { foo, ProtoResult } from '../protos/root';\nimport { example } from './workflows';\n\nasync function run() {\n  const client = new Client({\n    dataConverter: {\n      payloadConverterPath: require.resolve('./payload-converter'),\n    },\n  });\n\n  const handle = await client.workflow.start(example, {\n    args: [foo.bar.ProtoInput.create({ name: 'Proto', age: 2 })],\n    // can't do:\n    // args: [new foo.bar.ProtoInput({ name: 'Proto', age: 2 })],\n    taskQueue: 'protobufs',\n    workflowId: 'my-business-id-' + uuid(),\n  });\n\n  console.log(`Started workflow ${handle.workflowId}`);\n\n  const result: ProtoResult = await handle.result();\n  console.log(result.toJSON());\n}\n```\n\n<!--SNIPEND-->\n\n- Use protobufs in our Workflows and Activities:\n\n<!--SNIPSTART typescript-protobuf-workflow -->\n\n[protobufs/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/workflows.ts)\n\n```ts\nimport { proxyActivities } from '@temporalio/workflow';\nimport { foo, ProtoResult } from '../protos/root';\nimport type * as activities from './activities';\n\nconst { protoActivity } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\nexport async function example(input: foo.bar.ProtoInput): Promise<ProtoResult> {\n  const result = await protoActivity(input);\n  return result;\n}\n```\n\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-protobuf-activity -->\n\n[protobufs/src/activities.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/activities.ts)\n\n```ts\nimport { foo, ProtoResult } from '../protos/root';\n\nexport async function protoActivity(\n  input: foo.bar.ProtoInput,\n): Promise<ProtoResult> {\n  return ProtoResult.create({\n    sentence: `${input.name} is ${input.age} years old.`,\n  });\n}\n```\n\n<!--SNIPEND-->\n\n### `PayloadCodec`\n\n> API doc: [PayloadCodec](https://typescript.temporal.io/api/interfaces/common.PayloadCodec)\n\nThe default `PayloadCodec` does nothing. To create a custom one, we implement this interface:\n\n```ts\ninterface PayloadCodec {\n  /**\n   * Encode an array of {@link Payload}s for sending over the wire.\n   * @param payloads May have length 0.\n   */\n  encode(payloads: Payload[]): Promise<Payload[]>;\n\n  /**\n   * Decode an array of {@link Payload}s received from the wire.\n   */\n  decode(payloads: Payload[]): Promise<Payload[]>;\n}\n```\n\n#### Encryption\n\n> Background: [Data Converter ➡️ Encryption](/concepts/what-is-a-data-converter#encryption)\n\nHere's an example class that implements the `PayloadCodec` interface:\n\n<!--SNIPSTART typescript-encryption-codec -->\n\n[encryption/src/encryption-codec.ts](https://github.com/temporalio/samples-typescript/blob/master/encryption/src/encryption-codec.ts)\n\n```ts\nimport {\n  METADATA_ENCODING_KEY,\n  Payload,\n  PayloadCodec,\n  ValueError,\n} from '@temporalio/common';\nimport { decode, encode } from '@temporalio/common/lib/encoding';\nimport { temporal } from '@temporalio/proto';\nimport { webcrypto as crypto } from 'node:crypto';\nimport { decrypt, encrypt } from './crypto';\n\nconst ENCODING = 'binary/encrypted';\nconst METADATA_ENCRYPTION_KEY_ID = 'encryption-key-id';\n\nexport class EncryptionCodec implements PayloadCodec {\n  constructor(\n    protected readonly keys: Map<string, crypto.CryptoKey>,\n    protected readonly defaultKeyId: string,\n  ) {}\n\n  static async create(keyId: string): Promise<EncryptionCodec> {\n    const keys = new Map<string, crypto.CryptoKey>();\n    keys.set(keyId, await fetchKey(keyId));\n    return new this(keys, keyId);\n  }\n\n  async encode(payloads: Payload[]): Promise<Payload[]> {\n    return Promise.all(\n      payloads.map(async (payload) => ({\n        metadata: {\n          [METADATA_ENCODING_KEY]: encode(ENCODING),\n          [METADATA_ENCRYPTION_KEY_ID]: encode(this.defaultKeyId),\n        },\n        // Encrypt entire payload, preserving metadata\n        data: await encrypt(\n          temporal.api.common.v1.Payload.encode(payload).finish(),\n          this.keys.get(this.defaultKeyId)!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        ),\n      })),\n    );\n  }\n\n  async decode(payloads: Payload[]): Promise<Payload[]> {\n    return Promise.all(\n      payloads.map(async (payload) => {\n        if (\n          !payload.metadata\n          || decode(payload.metadata[METADATA_ENCODING_KEY]) !== ENCODING\n        ) {\n          return payload;\n        }\n        if (!payload.data) {\n          throw new ValueError('Payload data is missing');\n        }\n\n        const keyIdBytes = payload.metadata[METADATA_ENCRYPTION_KEY_ID];\n        if (!keyIdBytes) {\n          throw new ValueError(\n            'Unable to decrypt Payload without encryption key id',\n          );\n        }\n\n        const keyId = decode(keyIdBytes);\n        let key = this.keys.get(keyId);\n        if (!key) {\n          key = await fetchKey(keyId);\n          this.keys.set(keyId, key);\n        }\n        const decryptedPayloadBytes = await decrypt(payload.data, key);\n        console.log('Decrypting payload.data:', payload.data);\n        return temporal.api.common.v1.Payload.decode(decryptedPayloadBytes);\n      }),\n    );\n  }\n}\n\nasync function fetchKey(_keyId: string): Promise<crypto.CryptoKey> {\n  // In production, fetch key from a key management system (KMS). You may want to memoize requests if you'll be decoding\n  // Payloads that were encrypted using keys other than defaultKeyId.\n  const key = Buffer.from('test-key-test-key-test-key-test!');\n  const cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    key,\n    {\n      name: 'AES-GCM',\n    },\n    true,\n    ['encrypt', 'decrypt'],\n  );\n\n  return cryptoKey;\n}\n```\n\n<!--SNIPEND-->\n\nThe encryption and decryption code is in [`src/crypto.ts`](https://github.com/temporalio/samples-typescript/tree/main/encryption/src/crypto.ts). Since encryption is CPU-intensive, and doing AES with Node's built-in crypto module blocks the main thread, we use `@ronomon/crypto-async`, which uses Node's threadpool.\n\nAs before, we provide a custom data converter to the Client and Worker:\n\n<!--SNIPSTART typescript-encryption-client -->\n\n[encryption/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/encryption/src/client.ts)\n\n```ts\nconst client = new Client({\n  dataConverter: await getDataConverter(),\n});\n\nconst handle = await client.workflow.start(example, {\n  args: ['Alice: Private message for Bob.'],\n  taskQueue: 'encryption',\n  workflowId: `my-business-id-${uuid()}`,\n});\n\nconsole.log(`Started workflow ${handle.workflowId}`);\nconsole.log(await handle.result());\n```\n\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-encryption-worker -->\n\n[encryption/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/encryption/src/worker.ts)\n\n```ts\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  taskQueue: 'encryption',\n  dataConverter: await getDataConverter(),\n});\n```\n\n<!--SNIPEND-->\n\nWhen the Client sends `'Alice: Private message for Bob.'` to the Workflow, it gets encrypted on the Client and decrypted in the Worker. The Workflow receives the decrypted message and appends another message. When it returns that longer string, the string gets encrypted by the Worker and decrypted by the Client.\n\n<!--SNIPSTART typescript-encryption-workflow -->\n\n[encryption/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/encryption/src/workflows.ts)\n\n```ts\nexport async function example(message: string): Promise<string> {\n  return `${message}\\nBob: Hi Alice, I'm Workflow Bob.`;\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"debug-environment-development.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/debug-environment-development.md","id":"typescript/debug-environment-development","title":"How to debug in a development environment","description":"In addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the Web UI and tctl.","label":"Debug in a development environment","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the [Web UI](/web-ui) or [tctl](/tctl-v1).\n","is_empty":false},{"file_name":"debug-environment-production.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/debug-environment-production.md","id":"typescript/debug-environment-production","title":"How to debug in a production environment","description":"Debug production Workflows using the Web UI, tctl, Replays, Tracing, or Logging.","label":"Debug in a production environment","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can debug production Workflows using:\n\n- [Web UI](/web-ui)\n- [tctl](/tctl-v1)\n- [Replay](/typescript/testing#replay)\n- [Tracing](/typescript/observability#tracing)\n- [Logging](/typescript/observability#logging)\n\nYou can debug and tune Worker performance with metrics and the [Worker performance guide](/dev-guide/worker-performance).\nFor information on setting up SDK metrics, see [Metrics](/dev-guide/typescript/observability#metrics) in the Observability section of the TypeScript SDK developer's guide.\n\nDebug Server performance with [Cloud metrics](/cloud/how-to-monitor-temporal-cloud-metrics) or [self-hosted Server metrics](/kb/legacy-oss-prod-deploy#scaling-and-metrics).\n","is_empty":false},{"file_name":"debugging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/debugging.md","id":"typescript/debugging","title":"Debugging","description":"Debug issues with code that uses the TypeScript SDK.","label":"Debug","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Debugging section of the Temporal TypeScript SDK developer's guide covers tools for debugging and how to troubleshoot common issues.\n","is_empty":false},{"file_name":"define-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/define-query.md","id":"typescript/define-query","title":"How to define a Query","description":"A Query has a name and can have arguments.","label":"Define Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Query has a name and can have arguments.\n\n- The name, also called a Query type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"define-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/define-signal.md","id":"typescript/define-signal","title":"How to define a Signal","description":"A Signal has a name and can have arguments.","label":"Define Signal","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter).\n","is_empty":false},{"file_name":"determinism.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/determinism.md","id":"typescript/determinism","ssdi":[],"markdown_content":"# Determinism in Workflows\n\nTemporal Workflows are executed differently than conventional code as they can be restored at any point.\nA Workflow can sleep for months, and even if your Worker crashes or Temporal Cluster is down, timers and timeouts are persisted and will fire as scheduled.\nAs soon as your Worker and Cluster are back up, your code will _appear_ to resume where it left off.\nThis also means that sleeping or retrying code does not tie up the process - you can run thousands of timers off a single Worker.\n\n```js\nimport * as wf from '@temporalio/workflow';\nconst { yourActivity } = wf.proxyActivities({\n  // persisted\n  startToCloseTimeout: '1 week',\n  retry: {\n    // persisted\n    initialInterval: '1 day',\n  },\n});\n\nexport async function ExampleWorkflow() {\n  let state = []; // mutable local state\n  while (true) {\n    await wf.sleep('30 days'); // persisted\n    state.push(yourActivity()); // activity results can be replayed\n  }\n}\n```\n\nFor this to be possible, Workflow code must be completely deterministic, meaning it does the exact same thing every time it is rerun.\nDeterminism brings limitations: you can't just call an external service, get the current time, or generate a random number, as these are all dependent on the state of the world at the time they're called, and may produce different values.\nThe Temporal SDKs come with a set of tools that allow you to overcome these limitations.\n\n### How a Workflow is executed\n\nThe Temporal TypeScript SDK runs each Workflow in a separate v8 isolate — a \"sandbox\" environment using Node's built in `vm` with its own global variables, just like in the browser.\n\n- When we need to defer execution (such as for a timer or activity), we simply destroy the `vm` context.\n- When we need to continue execution, Temporal Server sends over the Event History, and we replay through the code from the start until the end to restore state.\n  - The serialization takes time, which is why we recommend keeping Event History [under 10,000 events](/kb/temporal-platform-limits-sheet). [\"Sticky\" optimizations exist to make this faster for common situations](/concepts/what-is-a-sticky-execution).\n  - If the execution logic has changed enough to affect Event History, you need to [patch new code](/typescript/patching).\n- The Workflow runtime is completely deterministic: functions like `Math.random`, `Date`, and `setTimeout` are replaced by deterministic versions, and the only way for a Workflow to interact with the world is via Activities.\n- When an Activity completes, its result is stored in the Workflow history to be replayed in case a Workflow is restored.\n\nThe SDK does not throw an exception to suspend execution (like React Suspense), nor does it use VM snapshotting (yet), nor does it do any AST magic.\n\n### Imports in Workflow code\n\nWorkflow code is bundled on Worker creation using [Webpack](https://webpack.js.org), you may import any JS package, **as long as it doesn't reference Node or DOM APIs**.\n\n### Sources of non-determinism\n\n- `Math.random` - replaced by the runtime\n- `uuid4` - provided by the runtime\n- `Date` - replaced by the runtime\n  - `new Date()` and `Date.now()` are both set on the first invocation of the Workflow Task\n- `WeakRef | FinalizationRegistry` - cannot be used, as GC is non-deterministic and the Workflow code may observe its effect; deleted by the runtime\n- Timers - `setTimeout` and `clearTimeout` are replaced by the runtime.\n  - We recommend you use the `@temporal/workflow` package's exported `sleep` function because it plays well with [cancellation scopes](/typescript/cancellation-scopes): `import { sleep } from '@temporalio/workflow'`\n- Activities - use to run non-deterministic code; results are replayed from history\n- Node built ins:\n  - `process` global\n  - `path` module, `fs` module\n\n### Deterministic examples\n\nHow `Date` is deterministic:\n\n```js\nimport { sleep } from '@temporalio/workflow';\n\n// this prints the *exact* same timestamp repeatedly\nfor (let x = 0; x < 10; ++x) {\n  console.log(Date.now());\n}\n\n// this prints timestamps increasing roughly 1s each iteration\nfor (let x = 0; x < 10; ++x) {\n  await sleep('1 second');\n  console.log(Date.now());\n}\n```\n","is_empty":false},{"file_name":"developing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/developing-activities.md","id":"typescript/developing-activities","title":"How to develop a basic Activity","description":"One of the primary things that Workflows do is orchestrate the execution of Activities.","label":"Develop Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nOne of the primary things that Workflows do is orchestrate the execution of Activities.\nAn Activity is a normal function or method execution that's intended to execute a single, well-defined action (either short or long-running), such as querying a database, calling a third-party API, or transcoding a media file.\nAn Activity can interact with world outside the Temporal Platform or use a Temporal Client to interact with a Cluster.\nFor the Workflow to be able to execute the Activity, we must define the [Activity Definition](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"developing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/developing-workflows.md","id":"typescript/developing-workflows","title":"How to develop a basic Workflow","description":"Workflows are the fundamental unit of a Temporal Application, and it all starts with the development of a Workflow Definition.","label":"Develop Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/concepts/what-is-a-workflow-definition).\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/environment-variables.md","id":"typescript/environment-variables","title":"How to read and pass environment variables","description":"Environment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.","label":"Environment variables","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEnvironment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.\nThey can't be used normally with Workflow code, as that would be [non-deterministic](workflows#intrinsic-non-deterministic-logic) (if the environment variables changed between Workflow replays, the code that used them would behave differently).\n\nMost of the time, you can provide environment variables in your Activity function; however, if you need them in your Workflow functions, you can use the following options:\n\n- Provide environment variables as arguments when starting the Workflow.\n- Call a Local Activity at the beginning of the Workflow that returns environment variables.\n\nIn either case, the environment variables will appear in Event History, so you may want to use an [encryption Data Converter](/concepts/what-is-a-data-converter#encryption).\n","is_empty":false},{"file_name":"failures.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/failures.md","id":"typescript/handling-failure","title":"Handling Failures in TypeScript","description":"Failures in Temporal are structured and typed. They represent a variety of failure scenarios across the different SDKs and the server.","label":"Handling Failures","ssdi":[],"markdown_content":"\nFailures in Temporal are structured and typed. They represent a variety of failure scenarios across the different SDKs and the server.\n\nIn the TypeScript SDK, failures are represented by [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) classes. They can be caught in both Workflow code and non-Workflow code.\n\n<details>\n<summary>\nFailures are serializable over the network and chainable to enable root-cause analysis anywhere in the failure chain.\n</summary>\n\nIf, for example, a TypeScript Workflow starts a Java Child Workflow which calls an Activity in Golang and that activity fails, the TypeScript Workflow will throw a `ChildWorkflowFailure` with `cause` set to an `ActivityFailure`, and the `ActivityFailure`'s `cause` is set to `ApplicationFailure`, which represents the error that occurred in the Golang Activity.\n\n<!--TODO: use snipsync-->\n\n```ts\nimport {\n  ActivityFailure,\n  ApplicationFailure,\n  ChildWorkflowFailure,\n} from '@temporalio/common';\nimport { executeChild } from '@temporalio/workflow';\n\n// Define the TypeScript version of the Java Workflow interface\n// to get a type safe child WorkflowHandle\nexport type JavaWorkflow = () => Promise<void>;\n\nasync function yourWorkflow(): Promise<void> {\n  try {\n    await executeChild<JavaWorkflow>('RunAnActivityWorkflow');\n  } catch (err) {\n    if (\n      err instanceof ChildWorkflowFailure\n      && err.cause instanceof ActivityFailure\n      && err.cause.cause instanceof ApplicationFailure\n    ) {\n      console.log(\n        'Child workflow failure root cause was a failed activity',\n        err.cause.cause.message,\n      );\n    }\n    throw err;\n  }\n}\n```\n\n</details>\n\nOutside of Workflow code, failure classes are attached to the `cause` of [`WorkflowFailedError`](https://typescript.temporal.io/api/classes/client.WorkflowFailedError), which is thrown when executing a Workflow with a [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.WorkflowClient/) or [`WorkflowHandle`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle/).\n\n## Failures and retries\n\nActivities and Workflows scheduled in the system have a configurable [Retry Policy](https://typescript.temporal.io/api/interfaces/proto.temporal.api.common.v1.IRetryPolicy), which many contain an array of `nonRetryableErrorTypes`.\n\nWhen a Workflow or Activity fails with an unhandled error, Temporal checks if the error name is present in the array of `nonRetryableErrorTypes` and stops retrying if there's a match.\n\nWorkflows and Activities may also throw [`ApplicationFailure.nonRetryable`](https://typescript.temporal.io/api/classes/client.ApplicationFailure#nonretryable-1) to expressly prevent retries.\n\nPropagated Activity and Child Workflow failures are considered retryable and will be retried according to the parent Workflow's Retry Policy.\n\nThe expected behavior is:\n\n- Non retryable application failure -> fails the Workflow and cannot be retried\n- Retryable application failure -> fails the Workflow and can be retried according to the Retry Policy\n- Other TemporalFailures -> same as retryable application failure\n- Any other error -> fails the Workflow Task and can be retried\n\n> Note: Before TypeScript SDK v0.17.0, throwing any error in a Workflow would cause the Workflow Execution to fail - in other words, all errors were Application Failures. The semantics were corrected in v0.17.\n\n### Pattern: Wrapping Errors with Interceptors\n\nTo make other error types fail the workflow, use the `WorkflowInboundCallsInterceptor` methods (`execute` and `handleSignal`) to catch errors thrown from the Workflow and convert them to `ApplicationFailures`, e.g:\n\n```ts\nasync function wrapError<T>(fn: () => Promise<T>): Promise<T> {\n  try {\n    return await fn();\n  } catch (err) {\n    if (err instanceof MySpecialRetryableError) {\n      throw ApplicationFailure.retryable(\n        err.message,\n        'MySpecialRetryableError',\n      ); // can also make this nonRetryable if that is the intent. remember to change the error name.\n    }\n    throw err;\n  }\n}\n\nclass WorkflowErrorInterceptor implements WorkflowInboundCallsInterceptor {\n  async execute(\n    input: WorkflowExecuteInput,\n    next: Next<WorkflowInboundCallsInterceptor, 'execute'>,\n  ): Promise<unknown> {\n    return await wrapError(() => next(input));\n  }\n\n  async handleSignal(\n    input: SignalInput,\n    next: Next<WorkflowInboundCallsInterceptor, 'handleSignal'>,\n  ): Promise<void> {\n    return await wrapError(() => next(input));\n  }\n}\n```\n\n## `isCancellation` utility\n\nFailures are also used to represent [cancellation](/typescript/cancellation-scopes#cancelledfailure) of Activities and Child Workflows.\n\nAs explained above, cancellation might not be the immediate cause of failure — it might happen further down the chain. Use the [`isCancellation`](https://typescript.temporal.io/api/namespaces/workflow/#iscancellation) helper function to inspect the chain recursively and look for a `CancelledFailure`.\n\n```ts\nimport {\n  CancellationScope,\n  isCancellation,\n  proxyActivities,\n} from '@temporalio/workflow';\nimport * as activities from '../activities';\n\nexport function yourWorkflow(\n  urls: string[],\n  timeoutMs: number,\n): Promise<any[]> {\n  const { httpGetJSON } = proxyActivities<typeof activities>({\n    scheduleToCloseTimeout: timeoutMs,\n  });\n\n  try {\n    return await CancellationScope.withTimeout(\n      timeoutMs,\n      () => Promise.all(urls.map((url) => httpGetJSON(url))),\n    );\n  } catch (err) {\n    if (isCancellation(err)) {\n      console.log('Deadline exceeded while waiting for activities to complete');\n    }\n    throw err;\n  }\n}\n```\n\n## Failure classes reference\n\n### [TemporalFailure](https://typescript.temporal.io/api/classes/client.TemporalFailure)\n\nThe base class of all other failure classes in the SDK.\n\n### [ApplicationFailure](https://typescript.temporal.io/api/classes/client.ApplicationFailure)\n\n`ApplicationFailure` is used to communicate application-specific failures between Workflows and Activities.\n\nThrow this exception to have full control over type and details of the exception delivered to the caller Workflow or client.\n\nAny unhandled exception that doesn't extend [`TemporalFailure`](#temporalfailure) is converted to an instance of `ApplicationFailure` before being returned to a caller.\n\n### [CancelledFailure](https://typescript.temporal.io/api/classes/client.CancelledFailure)\n\n`CancelledFailure` is thrown in a Workflow when a cancellation scope or the entire Workflow has been cancelled or set as the cause for when a Child Workflow or Activity has been cancelled.\n\nIn an Activity, it may be thrown if the Activity was requested to be cancelled. More on activity cancellation [here](/typescript/activities#activity-cancellation).\n\n### [ActivityFailure](https://typescript.temporal.io/api/classes/client.ActivityFailure)\n\nContains information about an Activity failure. Always contains the original reason for the failure as its cause. For example, if an Activity timed out, the cause is set to `TimeoutFailure`.\n\n**This exception is expected to be thrown only by the framework code.**\n\n### [ChildWorkflowFailure](https://typescript.temporal.io/api/classes/client.ChildWorkflowFailure)\n\nContains information about a Child Workflow failure; always contains the original reason for the failure as its cause.\nFor example, if a Child Workflow was terminated, the cause is set to `TerminatedFailure`.\n\n**This exception is expected to be thrown only by the framework code.**\n\n### [TimeoutFailure](https://typescript.temporal.io/api/classes/client.TimeoutFailure)\n\nUsed to represent timeouts of Activities and Workflows.\n\nWhen an activity times out, the last heartbeat details it emitted is attached to this failure.\n\n### [TerminatedFailure](https://typescript.temporal.io/api/classes/client.TerminatedFailure)\n\nUsed as the cause for when a Workflow has been terminated.\n\n### [ServerFailure](https://typescript.temporal.io/api/classes/client.ServerFailure)\n\nUsed for exceptions originated at the Temporal service.\n","is_empty":false},{"file_name":"features.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/features.md","id":"typescript/features","title":"How to use Workflow and Activity features","description":"The Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.","label":"Features","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\n\nIn this section you can find the following:\n\n- [How to develop Signals](#signals)\n- [How to develop Queries](#queries)\n- [How to start a Child Workflow Execution](#child-workflows)\n- [How to start a Temporal Cron Job](#temporal-cron-jobs)\n- [How to use Continue-As-New](#continue-as-new)\n- [How to set Workflow timeouts & retries](#workflow-timeouts)\n- [How to set Activity timeouts & retries](#activity-timeouts)\n- [How to Heartbeat an Activity](#activity-heartbeats)\n- [How to Asynchronously complete an Activity](#asynchronous-activity-completion)\n- [How to register Namespaces](#namespaces)\n- [How to use custom payload conversion](#custom-payload-conversion)\n","is_empty":false},{"file_name":"foundations.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/foundations.md","id":"typescript/foundations","title":"How to build a basic Temporal Application","description":"The Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application—that is, all the relevant steps to start a Workflow Execution that executes an Activity.","label":"Foundations","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a [Temporal Application](/concepts/what-is-a-temporal-application)—that is, all the relevant steps to start a [Workflow Execution](#develop-workflows) that executes an [Activity](#develop-activities).\n\nIn this section you can find the following:\n\n- [Run a development Cluster](/clusters/how-to-install-temporal-cli)\n- [Install your SDK](/typescript/add-sdk)\n- [Connect to a dev Cluster](/typescript/connect-to-a-dev-cluster)\n- [Connect to Temporal Cloud](/typescript/connect-to-temporal-cloud)\n- [Develop a Workflow](/typescript/developing-workflows)\n- [Develop an Activity](/typescript/developing-activities)\n- [Start an Activity Execution](/typescript/spawning-activities)\n- [Run a dev Worker](/typescript/run-a-dev-worker)\n- [Run a Worker on Docker](/typescript/how-to-run-a-worker-on-docker)\n- [Run a Temporal Cloud Worker](/typescript/run-a-dev-worker)\n- [Start a Workflow Execution](/typescript/spawning-workflows)\n","is_empty":false},{"file_name":"get-activity-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/get-activity-results.md","id":"typescript/get-activity-results","title":"How to get the results of an Activity Execution","description":"The call to spawn an Activity Execution generates the ScheduleActivityTask Command and provides the Workflow with an Awaitable.","label":"Get Activity results","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe call to spawn an [Activity Execution](/concepts/what-is-an-activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.\n","is_empty":false},{"file_name":"get-workflow-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/get-workflow-results.md","id":"typescript/get-workflow-results","title":"How to get the results of a Workflow Execution","description":"If the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.","label":"Get Workflow results","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.\n\nThe Workflow Id, Run Id, and Namespace may be used to uniquely identify a Workflow Execution in the system and get its result.\n\nIt's possible to both block progress on the result (synchronous execution) or get the result at some other point in time (asynchronous execution).\n\nIn the Temporal Platform, it's also acceptable to use Queries as the preferred method for accessing the state and results of Workflow Executions.\n","is_empty":false},{"file_name":"handle-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/handle-query.md","id":"typescript/handle-query","title":"How to handle a Query","description":"Queries are handled by your Workflow.","label":"Handle Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are handled by your Workflow.\n\nDon’t include any logic that causes [Command](/concepts/what-is-a-command) generation within a Query handler (such as executing Activities).\nIncluding such logic causes unexpected behavior.\n","is_empty":false},{"file_name":"handle-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/handle-signal.md","id":"typescript/handle-signal","title":"How to handle a Signal","description":"Workflows listen for Signals by the Signal's name.","label":"Handle Signal","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows listen for Signals by the Signal's name.\n","is_empty":false},{"file_name":"heartbeat-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/heartbeat-timeout.md","id":"typescript/heartbeat-timeout","title":"How to set a Heartbeat Timeout","description":"A Heartbeat Timeout works in conjunction with Activity Heartbeats.","label":"Heartbeat Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) works in conjunction with [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript.md","id":"typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript","title":"How to add custom Search Attributes to Workflow Executions at start time in TypeScript","description":"Add custom Search Attributes to Workflow Executions at start time","label":"Add custom Search Attributes to Workflow Executions at start time","tags":["developer-guide","typescript","client"],"ssdi":[],"markdown_content":"\nUse [`WorkflowOptions.searchAttributes`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions#searchattributes).\n\n<!--SNIPSTART typescript-search-attributes-client-->\n\n[search-attributes/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/search-attributes/src/client.ts)\n\n```ts\nconst handle = await client.workflow.start(example, {\n  taskQueue: 'search-attributes',\n  workflowId: 'search-attributes-example-0',\n  searchAttributes: {\n    CustomIntField: [2],\n    CustomKeywordField: ['keywordA', 'keywordB'],\n    CustomBoolField: [true],\n    CustomDatetimeField: [new Date()],\n    CustomStringField: [\n      'String field is for text. When queried, it will be tokenized for partial match. StringTypeField cannot be used in Order By',\n    ],\n  },\n});\n\nconst { searchAttributes } = await handle.describe();\n```\n\n<!--SNIPEND-->\n\nThe type of `searchAttributes` is `Record<string, string[] | number[] | boolean[] | Date[]>`.\n","is_empty":false},{"file_name":"how-to-asynchronously-complete-an-activity-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-asynchronously-complete-an-activity-in-typescript.md","id":"typescript/how-to-asynchronously-complete-an-activity-in-typescript","title":"How to asynchronously complete an Activity in TypeScript","description":"To asynchronously complete an Activity in TypeScript, set `AsyncCompletionClient` to `complete`.","label":"Asynchronously complete an Activity","tags":["typescript","how-to"],"ssdi":[],"markdown_content":"\nTo asynchronously complete an Activity, call [`AsyncCompletionClient.complete`](https://typescript.temporal.io/api/classes/client.AsyncCompletionClient#complete).\n\n<!--SNIPSTART typescript-activity-complete-async -->\n\n[activities-examples/src/activities/async-completion.ts](https://github.com/temporalio/samples-typescript/blob/master/activities-examples/src/activities/async-completion.ts)\n\n```ts\nimport { CompleteAsyncError, Context } from '@temporalio/activity';\nimport { AsyncCompletionClient } from '@temporalio/client';\n\nexport async function doSomethingAsync(): Promise<string> {\n  const taskToken = Context.current().info.taskToken;\n  setTimeout(() => doSomeWork(taskToken), 1000);\n  throw new CompleteAsyncError();\n}\n\n// this work could be done in a different process or on a different machine\nasync function doSomeWork(taskToken: Uint8Array): Promise<void> {\n  const client = new AsyncCompletionClient();\n  // does some work...\n  await client.complete(taskToken, 'Job\\'s done!');\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-configure-tracing-in-typescript.md","id":"typescript/how-to-configure-tracing-in-typescript","title":"How to configure tracing in TypeScript","description":"Call `MockActivityEnvironment.cancel()` to cancel an Activity Context.","label":"Configure tracing","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nThe [`interceptors-opentelemetry`](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry) sample shows how to use the SDK's built-in OpenTelemetry tracing to trace everything from starting a Workflow to Workflow Execution to running an Activity from that Workflow.\n\nThe built-in tracing uses protobuf message headers (like [this one](https://github.com/temporalio/api/blob/b2b8ae6592a8730dd5be6d90569d1aea84e1712f/temporal/api/workflowservice/v1/request_response.proto#L161) when starting a Workflow) to propagate the tracing information from the client to the Workflow and from the Workflow to its successors (when Continued As New), children, and Activities.\nAll of these executions are linked with a single trace identifier and have the proper `parent -> child` span relation.\n\nTracing is compatible between different Temporal SDKs as long as compatible [context propagators](https://opentelemetry.lightstep.com/core-concepts/context-propagation/) are used.\n\n**Context propagation**\n\nThe TypeScript SDK uses the global OpenTelemetry propagator.\n\nTo extend the default ([Trace Context](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#w3ctracecontextpropagator-propagator) and [Baggage](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#baggage-propagator) propagators) to also include the [Jaeger propagator](https://www.npmjs.com/package/@opentelemetry/propagator-jaeger), follow these steps:\n\n- `npm i @opentelemetry/propagator-jaeger`\n\n- At the top level of your Workflow code, add the following lines:\n\n  ```js\n  import { propagation } from '@opentelemetry/api';\n  import {\n    CompositePropagator,\n    W3CBaggagePropagator,\n    W3CTraceContextPropagator,\n  } from '@opentelemetry/core';\n  import { JaegerPropagator } from '@opentelemetry/propagator-jaeger';\n\n  propagation.setGlobalPropagator(\n    new CompositePropagator({\n      propagators: [\n        new W3CTraceContextPropagator(),\n        new W3CBaggagePropagator(),\n        new JaegerPropagator(),\n      ],\n    }),\n  );\n  ```\n\nSimilarly, you can customize the OpenTelemetry `NodeSDK` propagators by following the instructions in the [Initialize the SDK](https://github.com/open-telemetry/opentelemetry-js/tree/main/experimental/packages/opentelemetry-sdk-node#initialize-the-sdk) section of the `README.md` file.\n","is_empty":false},{"file_name":"how-to-connect-to-a-development-cluster-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-connect-to-a-development-cluster-in-typescript.md","id":"typescript/how-to-connect-to-a-development-cluster-in-typescript","title":"How to connect to a Temporal Cluster in TypeScript","description":"Connect a Temporal Client to a Cluster in the TypeScript SDK.","label":"Connect a Temporal Client","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nCreating a [Connection](https://typescript.temporal.io/api/classes/client.Connection) connects to the Temporal Cluster, and you can pass the `Connection` instance when creating the [Client](https://typescript.temporal.io/api/classes/client.Client#connection).\n\nIf you omit the `Connection` and just create a `new Client()`, it will connect to `localhost:7233`.\n\n```ts\nimport { Client } from '@temporalio/client';\n\nasync function run() {\n  const client = new Client();\n\n  // . . .\n\n  await client.connection.close();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n","is_empty":false},{"file_name":"how-to-connect-to-temporal-cloud-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-connect-to-temporal-cloud-in-typescript.md","id":"typescript/how-to-connect-to-temporal-cloud-in-typescript","title":"How to connect to Temporal Cloud in TypeScript","description":"Connect to Temporal Cloud in TypeScript","label":"Connect to Temporal Cloud","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nCreate a [`Connection`](https://typescript.temporal.io/api/classes/client.Connection) with a [`connectionOptions`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions) object that has your Cloud namespace and client certificate.\n\n```ts\nimport { Client, Connection } from '@temporalio/client';\nimport fs from 'fs-extra';\n\nconst { NODE_ENV = 'development' } = process.env;\nconst isDeployed = ['production', 'staging'].includes(NODE_ENV);\n\nasync function run() {\n  const cert = await fs.readFile('./path-to/your.pem');\n  const key = await fs.readFile('./path-to/your.key');\n\n  let connectionOptions = {};\n  if (isDeployed) {\n    connectionOptions = {\n      address: 'your-namespace.tmprl.cloud:7233',\n      tls: {\n        clientCertPair: {\n          crt: cert,\n          key,\n        },\n      },\n    };\n\n    const connection = await Connection.connect(connectionOptions);\n\n    const client = new Client({\n      connection,\n      namespace: 'your-namespace',\n    });\n\n    // . . .\n\n    await client.connection.close();\n  }\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-continue-as-new-in-typescript.md","id":"typescript/how-to-continue-as-new-in-typescript","title":"How to Continue-As-New in TypeScript","description":"To Continue-As-New, use `continueAsNew`.","label":"Continue-As-New","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTo cause a Workflow Execution to [Continue-As-New](/concepts/what-is-continue-as-new), the Workflow function should return the result of the [`continueAsNew`](https://typescript.temporal.io/api/namespaces/workflow#continueasnew).\n\n<!--SNIPSTART typescript-continue-as-new-workflow -->\n\n[continue-as-new/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/continue-as-new/src/workflows.ts)\n\n```ts\nimport { continueAsNew, sleep } from '@temporalio/workflow';\n\nexport async function loopingWorkflow(iteration = 0): Promise<void> {\n  if (iteration === 10) {\n    return;\n  }\n  console.log('Running Workflow iteration:', iteration);\n  await sleep(1000);\n  // Must match the arguments expected by `loopingWorkflow`\n  await continueAsNew<typeof loopingWorkflow>(iteration + 1);\n  // Unreachable code, continueAsNew is like `process.exit` and will stop execution once called.\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-create-a-temporal-client-in-typescript.md","id":"typescript/how-to-create-a-temporal-client-in-typescript","title":"How to create a Temporal Client in TypeScript","description":"Create a Temporal Client","label":"Create a Temporal Client","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nUse a new `WorkflowClient()` with the requisite gRPC [`Connection`](https://typescript.temporal.io/api/classes/client.Connection#service) to create a new Client.\n\n```typescript\nimport { Connection, WorkflowClient } from '@temporalio/client';\nconst connection = await Connection.connect(); // to configure for production\nconst client = new WorkflowClient({ connection });\n```\n\nDeclaring the `WorkflowClient()` creates a new connection to the Temporal service.\n\nIf you omit the connection and just call the `new WorkflowClient()`, you create a default connection that works locally.\nHowever, always configure your connection and Namespace when [deploying to production](/typescript/connect-to-temporal-cloud).\n\nThe following example, creates a Client, connects to an account, and declares your Namespace.\n\n```typescript\nimport { Connection, WorkflowClient } from '@temporalio/client';\n\nconst connection = await Connection.connect({\n  address: '<Namespace_ID>.tmprl.cloud',\n});\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'your.namespace',\n});\n```\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-customize-activity-type-in-typescript.md","id":"typescript/how-to-customize-activity-type-in-typescript","title":"How to customize Activity Type in TypeScript","description":"Customize Activity Type","label":"Customize Activity Type","tags":["developer-guide","typescript"],"ssdi":[],"markdown_content":"\nYou can customize the name of the Activity when you register it with the Worker.\nIn the following example, the Activity Name is `activityFoo`.\n\n<!--SNIPSTART typescript-custom-activity-type -->\n\n[snippets/src/worker-activity-type-custom.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/worker-activity-type-custom.ts)\n\n```ts\nimport { Worker } from '@temporalio/worker';\nimport { greet } from './activities';\n\nasync function run() {\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'snippets',\n    activities: {\n      activityFoo: greet,\n    },\n  });\n\n  await worker.run();\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-customize-workflow-type-in-typescript.md","id":"typescript/how-to-customize-workflow-type-in-typescript","title":"How to customize Workflow Type in TypeScript","description":"Customize Workflow Type","label":"Customize Workflow Type","tags":["developer-guide","typescript"],"ssdi":[],"markdown_content":"\nIn TypeScript, the Workflow Type is the Workflow function name and there isn't a mechanism to customize the Workflow Type.\n\nIn the following example, the Workflow Type is the name of the function, `helloWorld`.\n\n<!--SNIPSTART typescript-workflow-type -->\n\n[snippets/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/workflows.ts)\n\n```ts\nexport async function helloWorld(): Promise<string> {\n  return '👋 Hello World!';\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-define-a-query-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-define-a-query-in-typescript.md","id":"typescript/how-to-define-a-query-in-typescript","title":"How to define a Query in TypeScript","description":"Use `defineQuery` to define a Query method for a Workflow.","label":"Define Query","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nUse [`defineQuery`](https://typescript.temporal.io/api/namespaces/workflow/#definequery) to define the name, parameters, and return value of a Query.\n\n<!--SNIPSTART typescript-define-query -->\n\n[state/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/state/src/workflows.ts)\n\n```ts\nimport { defineQuery } from '@temporalio/workflow';\n\nexport const getValueQuery = defineQuery<number | undefined, [string]>(\n  'getValue',\n);\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-define-a-signal-in-typescript.md","id":"typescript/how-to-define-a-signal-in-typescript","title":"How to define a Signal in TypeScript","description":"Define Signal","label":"Define Signal","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n[`defineSignal`](https://typescript.temporal.io/api/namespaces/workflow/#definesignal)\n\n```ts\nimport { defineSignal } from '@temporalio/workflow';\n\ninterface JoinInput {\n  userId: string;\n  groupId: string;\n}\n\nexport const joinSignal = defineSignal<[JoinInput]>('join');\n```\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-define-activity-parameters-in-typescript.md","id":"typescript/how-to-define-activity-parameters-in-typescript","title":"How to define Activity Parameters in TypeScript","description":"Activity Parameters.","label":"Activity Parameters","tags":["developer-guide","go"],"ssdi":[],"markdown_content":"\nThis Activity takes a single `name` parameter of type `string`.\n\n<!--SNIPSTART typescript-activity-fn -->\n\n[snippets/src/activities.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/activities.ts)\n\n```ts\nexport async function greet(name: string): Promise<string> {\n  return `👋 Hello, ${name}!`;\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-define-activity-return-values-in-typescript.md","id":"typescript/how-to-define-activity-return-values-in-typescript","title":"How to define Activity Return Values in TypeScript","description":"Define Activity Return Values","label":"Define Activity Return Values","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nIn TypeScript, the return value is always a Promise.\n\nIn the following example, `Promise<string>` is the return value.\n\n```typescript\nexport async function greet(name: string): Promise<string> {\n  return `👋 Hello, ${name}!`;\n}\n```\n","is_empty":false},{"file_name":"how-to-define-signals-and-queries-statically-or-dynamically.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-define-signals-and-queries-statically-or-dynamically.md","id":"typescript/how-to-define-signals-and-queries-statically-or-dynamically","title":"How to define Signals and Queries statically or dynamically","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Static and dynamic Signals and Queries","tags":["guide-context"],"ssdi":[],"markdown_content":"\n- Handlers for both Signals and Queries can take arguments, which can be used inside `setHandler` logic.\n- Only Signal Handlers can mutate state, and only Query Handlers can return values.\n\n### Define Signals and Queries statically\n\nIf you know the name of your Signals and Queries upfront, we recommend declaring them outside the Workflow Definition.\n\n<!--SNIPSTART typescript-blocked-workflow-->\n\n[signals-queries/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/signals-queries/src/workflows.ts)\n\n```ts\nimport * as wf from '@temporalio/workflow';\n\nexport const unblockSignal = wf.defineSignal('unblock');\nexport const isBlockedQuery = wf.defineQuery<boolean>('isBlocked');\n\nexport async function unblockOrCancel(): Promise<void> {\n  let isBlocked = true;\n  wf.setHandler(unblockSignal, () => void (isBlocked = false));\n  wf.setHandler(isBlockedQuery, () => isBlocked);\n  console.log('Blocked');\n  try {\n    await wf.condition(() => !isBlocked);\n    console.log('Unblocked');\n  } catch (err) {\n    if (err instanceof wf.CancelledFailure) {\n      console.log('Cancelled');\n    }\n    throw err;\n  }\n}\n```\n\n<!--SNIPEND-->\n\nThis technique helps provide type safety because you can export the type signature of the Signal or Query to be called by the Client.\n\n### Define Signals and Queries dynamically\n\nFor more flexible use cases, you might want a dynamic Signal (such as a generated ID).\nYou can handle it in two ways:\n\n- Avoid making it dynamic by collapsing all Signals into one handler and move the ID to the payload.\n- Actually make the Signal name dynamic by inlining the Signal definition per handler.\n\n```ts\nimport * as wf from '@temporalio/workflow';\n\n// \"fat handler\" solution\nwf.setHandler(`genericSignal`, (payload) => {\n  switch (payload.taskId) {\n    case taskAId:\n      // do task A things\n      break;\n    case taskBId:\n      // do task B things\n      break;\n    default:\n      throw new Error('Unexpected task.');\n  }\n});\n\n// \"inline definition\" solution\nwf.setHandler(wf.defineSignal(`task-${taskAId}`), (payload) => {\n  /* do task A things */\n});\nwf.setHandler(wf.defineSignal(`task-${taskBId}`), (payload) => {\n  /* do task B things */\n});\n\n// utility \"inline definition\" helper\nconst inlineSignal = (signalName, handler) =>\n  wf.setHandler(wf.defineSignal(signalName), handler);\ninlineSignal(`task-${taskBId}`, (payload) => {\n  /* do task B things */\n});\n```\n\n<details>\n  <summary>\n    API Design FAQs\n  </summary>\n\n**Why not \"new Signal\" and \"new Query\"?**\n\nThe semantic of `defineSignal` and `defineQuery` is intentional.\nThey return Signal and Query **definitions**, not unique instances of Signals and Queries themselves\nThe following is their [entire source code](https://github.com/temporalio/sdk-typescript/blob/fc658d3760e6653aec47732ab17a0062b7dd23fc/packages/workflow/src/workflow.ts#L883-L907):\n\n```ts\n/**\n * Define a signal method for a Workflow.\n */\nexport function defineSignal<Args extends any[] = []>(\n  name: string,\n): SignalDefinition<Args> {\n  return {\n    type: 'signal',\n    name,\n  };\n}\n\n/**\n * Define a query method for a Workflow.\n */\nexport function defineQuery<Ret, Args extends any[] = []>(\n  name: string,\n): QueryDefinition<Ret, Args> {\n  return {\n    type: 'query',\n    name,\n  };\n}\n```\n\nSignals and Queries are instantiated only in `setHandler` and are specific to particular Workflow Executions.\n\nThese distinctions might seem minor, but they model how Temporal works under the hood, because Signals and Queries are messages identified by \"just strings\" and don't have meaning independent of the Workflow having a listener to handle them.\nThis will be clearer if you refer to the Client-side APIs.\n\n**Why setHandler and not OTHER_API?**\n\nWe named it `setHandler` instead of `subscribe` because a Signal or Query can have only one \"handler\" at a time, whereas `subscribe` could imply an Observable with multiple consumers and is a higher-level construct.\n\n```ts\nwf.setHandler(MySignal, handlerFn1);\nwf.setHandler(MySignal, handlerFn2); // replaces handlerFn1\n```\n\nIf you are familiar with [RxJS](https://rxjs.dev/), you are free to wrap your Signals and Queries into Observables if you want, or you could dynamically reassign the listener based on your business logic or Workflow state.\n\n</details>\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-define-workflow-parameters-in-typescript.md","id":"typescript/how-to-define-workflow-parameters-in-typescript","title":"How to define Workflow parameters in TypeScript","description":"Define Workflow parameters","label":"Define Workflow parameters","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nYou can define and pass parameters in your Workflow. In this example, you define your arguments in your `client.ts` file and pass those parameters to `workflow.ts` through your Workflow function.\n\nStart a Workflow with the parameters that are in the `client.ts` file. In this example we set the `name` parameter to `Temporal` and `born` to `2019`. Then set the Task Queue and Workflow Id.\n\n`client.ts`\n\n```typescript\nimport { example } from './workflows';\n\n...\nawait client.start(example, {\n  args: [{ name: 'Temporal', born: 2019 }],\n  taskQueue: 'your-queue',\n  workflowId: 'business-meaningful-id',\n});\n```\n\nIn `workflows.ts` define the type of the parameter that the Workflow function takes in. The interface `ExampleParam` is a name we can now use to describe the requirement in the previous example. It still represents having the two properties called `name` and `born` that is of the type `string`. Then define a function that takes in a parameter of the type `ExampleParam` and return a `Promise<string>`. The `Promise` object represents the eventual completion, or failure, of `await client.start()` and its resulting value.\n\n```ts\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({ name, born }: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-define-workflow-return-values-in-typescript.md","id":"typescript/how-to-define-workflow-return-values-in-typescript","title":"How to define Workflow return values in TypeScript","description":"Define Workflow return values","label":"Define Workflow return values","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTo return a value of the Workflow function, use `Promise<something>`. The `Promise` is used to make asynchronous calls and comes with guarantees.\n\nThe following example uses a `Promise<string>` to eventually return a `name` and `born` parameter.\n\n```typescript\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({ name, born }: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-develop-a-worker-program-in-typescript.md","id":"typescript/how-to-develop-a-worker-program-in-typescript","title":"How to develop a Worker program in TypeScript","description":"Develop a Worker program","label":"Run a dev Worker","tags":["dev-guide","workers","typescript"],"ssdi":[],"markdown_content":"\nCreate a Worker with `Worker.create()` (which establishes the initial gRPC connection), then call `worker.run()` on it (to start polling the Task Queue).\n\nBelow is an example of starting a Worker that polls the Task Queue named `tutorial`.\n\n<!--SNIPSTART typescript-hello-worker {\"enable_source_link\": false}-->\n\n```ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  // Step 1: Register Workflows and Activities with the Worker and connect to\n  // the Temporal server.\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    activities,\n    taskQueue: 'hello-world',\n  });\n  // Worker connects to localhost by default and uses console.error for logging.\n  // Customize the Worker by passing more options to create():\n  // https://typescript.temporal.io/api/classes/worker.Worker\n  // If you need to configure server connection parameters, see docs:\n  // https://docs.temporal.io/typescript/security#encryption-in-transit-with-mtls\n\n  // Step 2: Start accepting tasks on the `hello-world` queue\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n<!--SNIPEND-->\n\n`taskQueue` is the only required option, but you will also use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nA full example for Workers looks like this:\n\n```typescript\nimport { NativeConnection, Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  const connection = await NativeConnection.connect({\n    // defaults port to 7233 if not specified\n    address: 'foo.bar.tmprl.cloud',\n    tls: {\n      // set to true if TLS without mTLS\n      // See docs for other TLS options\n      clientCertPair: {\n        crt: clientCert,\n        key: clientKey,\n      },\n    },\n  });\n\n  const worker = await Worker.create({\n    connection,\n    namespace: 'foo.bar', // as explained in Namespaces section\n    // ...\n  });\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\nSee below for more Worker options.\n\n**Workflow and Activity registration**\n\nWorkers bundle Workflow code and `node_modules` using Webpack v5 and execute them inside V8 isolates.\nActivities are directly required and run by Workers in the Node.js environment.\n\nWorkers are very flexible – you can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers in a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker. Not the path.\n- Workflow bundle:\n- Either specify a `workflowsPath` to your `workflows.ts` file to pass to Webpack, e.g., `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n- Or pass a prebuilt bundle to `workflowBundle` instead if you prefer to handle the bundling yourself.\n\n**Additional Worker Options**\n\nThis is a selected subset of options you are likely to use. Even more advanced options, particularly for performance tuning, are available in [the API reference](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions).\n\n| Options         | Description                                                                                                                                                          |\n| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `dataConverter` | Encodes and decodes data entering and exiting a Temporal Server. Supports `undefined`, `UintBArray`, and JSON.                                                       |\n| `sinks`         | Allows injection of Workflow Sinks. See [Logging](/typescript/how-to-log-from-a-workflow-in-typescript)                                                              |\n| `interceptors`  | A mapping of interceptor type to a list of factories or module paths (Advanced feature: see [Interceptors](/typescript/how-to-implement-interceptors-in-typescript)) |\n\n**Operation guides:**\n\n- [How to tune Workers](/dev-guide/worker-performance)\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-develop-a-workflow-definition-in-typescript.md","id":"typescript/how-to-develop-a-workflow-definition-in-typescript","title":"How to develop a Workflow Definition in TypeScript","description":"Workflow Definitions are exported async functions in Typescript.","label":"Develop a Workflow Definition","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nIn the Temporal TypeScript SDK programming model, Workflow Definitions are _just functions_, which can store state and orchestrate Activity Functions.\nThe following code snippet uses `proxyActivities` to schedule a `greet` Activity in the system to say hello.\n\nA Workflow Definition can have multiple parameters; however, we recommend using a single object parameter.\n\n```typescript\ntype ExampleArgs = {\n  name: string;\n};\n\nexport async function example(\n  args: ExampleArgs,\n): Promise<{ greeting: string }> {\n  const greeting = await greet(args.name);\n  return { greeting };\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-develop-an-activity-definition-in-typescript.md","id":"typescript/how-to-develop-an-activity-definition-in-typescript","title":"How to develop an Activity Definition in TypeScript","description":"Develop an Activity Definition","label":"Develop an Activity Definition","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n- Activities execute in the standard Node.js environment.\n- Activities cannot be in the same file as Workflows and must be separately registered.\n- Activities may be retried repeatedly, so you may need to use idempotency keys for critical side effects.\n\nActivities are _just functions_. The following is an Activity that accepts a string parameter and returns a string.\n\n<!--SNIPSTART typescript-activity-fn -->\n\n[snippets/src/activities.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/activities.ts)\n\n```ts\nexport async function greet(name: string): Promise<string> {\n  return `👋 Hello, ${name}!`;\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-emit-metrics-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-emit-metrics-typescript.md","id":"typescript/how-to-emit-metrics-typescript","title":"How to emit metrics in TypeScript","description":"Emit metrics","label":"Emit metrics","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nWorkers can emit metrics and traces. There are a few [telemetry options](https://typescript.temporal.io/api/interfaces/worker.TelemetryOptions) that can be provided to [`Runtime.install`](https://typescript.temporal.io/api/classes/worker.Runtime/#install). The common options are:\n\n- `metrics: { otel: { url } }`: The URL of a gRPC [OpenTelemetry collector](https://opentelemetry.io/docs/collector/).\n- `metrics: { prometheus: { bindAddress } }`: Address on the Worker host that will have metrics for [Prometheus](https://prometheus.io/) to scrape.\n\nTo set up tracing of Workflows and Activities, use our `opentelemetry-interceptors` package.\n(For details, see the next section.)\n\n```typescript\ntelemetryOptions: {\n    metrics: {\n      prometheus: { bindAddress: '0.0.0.0:9464' },\n    },\n    logging: { forward: { level: 'DEBUG' } },\n  },\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript.md","id":"typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript","title":"How to get the result of a Workflow Execution in TypeScript","description":"Get the result of a Workflow Execution","label":"Workflow result","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTo return the results of a Workflow Execution:\n\n```typescript\nreturn (\n  'Completed '\n  + wf.workflowInfo().workflowId\n  + ', Total Charged: '\n  + totalCharged\n);\n```\n\n`totalCharged` is just a function declared in your code. For a full example, see [subscription-workflow-project-template-typescript/src/workflows.ts](https://github.com/temporalio/subscription-workflow-project-template-typescript/blob/main/src/workflows.ts).\n\nA Workflow function may return a result. If it doesn’t (in which case the return type is `Promise<void>`), the result will be `undefined`.\n\nIf you started a Workflow with `handle.start()`, you can choose to wait for the result anytime with `handle.result()`.\n\n```typescript\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nUsing a Workflow Handle isn't necessary with `client.execute()`.\n\nWorkflows that prematurely end will throw a `WorkflowFailedError` if you call `result()`.\n\nIf you call `result()` on a Workflow that prematurely ended for some reason, it throws a [`WorkflowFailedError` error](https://typescript.temporal.io/api/classes/client.WorkflowFailedError/) that reflects the reason. For that reason, it is recommended to catch that error.\n\n```typescript\nconst handle = client.getHandle(workflowId);\ntry {\n  const result = await handle.result();\n} catch (err) {\n  if (err instanceof WorkflowFailedError) {\n    throw new Error('Temporal workflow failed: ' + workflowId, {\n      cause: err,\n    });\n  } else {\n    throw new Error('error from Temporal workflow ' + workflowId, {\n      cause: err,\n    });\n  }\n}\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-get-the-result-of-an-activity-execution-in-typescript.md","id":"typescript/how-to-get-the-result-of-an-activity-execution-in-typescript","title":"How to get the result of an Activity Execution in TypeScript","description":"Get the result of an Activity Execution","label":"Get the result of an Activity Execution","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nSince Activities are referenced by their string name, you can reference them dynamically to get the result of an Activity Execution.\n\n```typescript\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts['activity1']();\n\n  let result = await acts[activityName](...args);\n  return result;\n}\n```\n\nThe `proxyActivities()` returns an object that calls the Activities in the function. `acts[activityName]()` references the Activity using the Activity name, then it returns the results.\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-handle-a-query-in-a-workflow-in-typescript.md","id":"typescript/how-to-handle-a-query-in-a-workflow-in-typescript","title":"How to handle a Query in a Workflow in TypeScript","description":"To handle a Query in a Workflow, define a Query handler method using the `handle.query(query, ...args)` annotation in the Workflow interface.","label":"Handle Query","tags":["typescript","developer-guide"],"ssdi":[],"markdown_content":"\nUse [`handleQuery`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInboundCallsInterceptor/#handlequery) to handle Queries inside a Workflow.\n\nYou make a Query with `handle.query(query, ...args)`. A Query needs a return value, but can also take arguments.\n\n<!--SNIPSTART typescript-handle-query -->\n\n[state/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/state/src/workflows.ts)\n\n```ts\nexport async function trackState(): Promise<void> {\n  const state = new Map<string, number>();\n  setHandler(setValueSignal, (key, value) => void state.set(key, value));\n  setHandler(getValueQuery, (key) => state.get(key));\n  await CancellationScope.current().cancelRequested;\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-handle-a-signal-in-typescript.md","id":"typescript/how-to-handle-a-signal-in-typescript","title":"How to handle a Signal in TypeScript","description":"Handle Signal","label":"Handle Signal","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n[`setHandler`](https://typescript.temporal.io/api/namespaces/workflow/#sethandler)\n\n```ts\nimport { setHandler } from '@temporalio/workflow';\n\nexport async function yourWorkflow() {\n  const groups = new Map<string, Set<string>>();\n\n  setHandler(joinSignal, ({ userId, groupId }: JoinInput) => {\n    const group = groups.get(groupId);\n    if (group) {\n      group.add(userId);\n    } else {\n      groups.set(groupId, new Set([userId]));\n    }\n  });\n}\n```\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-handle-workflow-logic-requirements-in-typescript.md","id":"typescript/how-to-handle-workflow-logic-requirements-in-typescript","title":"How to handle Workflow logic requirements in TypeScript","description":"Handle Signal","label":"Workflow logic requirements","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nIn the Temporal TypeScript SDK, Workflows run in a deterministic sandboxed environment.\nThe code is bundled on Worker creation using Webpack, and can import any package as long as it does not reference Node.js or DOM APIs.\n\n:::note\n\nIf you **must** use a library that references a Node.js or DOM API and you are certain that those APIs are not used at runtime, add that module to the [ignoreModules](https://typescript.temporal.io/api/interfaces/worker.BundleOptions#ignoremodules) list.\n\n:::\n\nThe Workflow sandbox can run only deterministic code, so side effects and access to external state must be done through Activities because Activity outputs are recorded in the Event History and can read deterministically by the Workflow.\n\nThis limitation also means that Workflow code cannot directly import the [Activity Definition](/concepts/what-is-an-activity-definition).\n[Activity Types](/concepts/what-is-an-activity-definition#activity-type) can be imported, so they can be invoked in a type-safe manner.\n\nTo make the Workflow runtime deterministic, functions like `Math.random()`, `Date`, and `setTimeout()` are replaced by deterministic versions.\n\n[FinalizationRegistry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry) and [WeakRef](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef) are removed because v8's garbage collector is not deterministic.\n\n<details><summary>Expand to see the implications of the deterministic Date API</summary>\n\n```typescript\nimport { sleep } from '@temporalio/workflow';\n\n// this prints the *exact* same timestamp repeatedly\nfor (let x = 0; x < 10; ++x) {\n  console.log(Date.now());\n}\n\n// this prints timestamps increasing roughly 1s each iteration\nfor (let x = 0; x < 10; ++x) {\n  await sleep('1 second');\n  console.log(Date.now());\n}\n```\n\n</details>\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-heartbeat-an-activity-in-typescript.md","id":"typescript/how-to-heartbeat-an-activity-in-typescript","title":"How to Heartbeat an Activity in TypeScript","description":"Heartbeat Activities to track their progress and get details of the Activity Execution.","label":"Activity Heartbeat","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nLong-running Activities should Heartbeat their progress back to the Workflow for earlier detection of stalled Activities (with [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout)) and resuming stalled Activities from checkpoints (with Heartbeat details).\n\nTo set Activity Heartbeat, use `Context.current().heartbeat()` in your Activity implementation, and set `heartbeatTimeout` in your Workflow.\n\n```ts\n// activity implementation\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  for (let progress = 1; progress <= 1000; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    // record activity heartbeat\n    Context.current().heartbeat();\n  }\n}\n\n// ...\n\n// workflow code calling activity\nconst { example } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 hour',\n  heartbeatTimeout: '10s',\n});\n```\n\nIn the previous example, setting the Heartbeat informs the Temporal Server of the Activity's progress at regular intervals.\nIf the Activity stalls or the Activity Worker becomes unavailable, the absence of Heartbeats prompts the Temporal Server to retry the Activity immediately, without waiting for `startToCloseTimeout` to complete.\n\nYou can also add `heartbeatDetails` as a checkpoint to collect data about failures during the execution, and use it to resume the Activity from that point.\n\nThe following example extends the previous sample to include a `heartbeatDetails` checkpoint.\n\n```ts\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  const startingPoint = Context.current().info.heartbeatDetails || 1; // allow for resuming from heartbeat\n  for (let progress = startingPoint; progress <= 100; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    Context.current().heartbeat(progress);\n  }\n}\n```\n\nIn this example, when the `heartbeatTimeout` is reached and the Activity is retried, the Activity Worker picks up the execution from where the previous attempt left off.\n","is_empty":false},{"file_name":"how-to-implement-interceptors-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-implement-interceptors-in-typescript.md","id":"typescript/how-to-implement-interceptors-in-typescript","title":"How to implement interceptors in TypeScript","description":"Interceptors are a mechanism for modifying inbound and outbound SDK calls, commonly used to add tracing and authorization.","label":"Interceptors","tags":["guide-context"],"ssdi":[],"markdown_content":"\nInterceptors are a mechanism for modifying inbound and outbound SDK calls.\nInterceptors are commonly used to add tracing and authorization to the scheduling and execution of Workflows and Activities.\nYou can compare these to \"middleware\" in other frameworks.\n\nThe TypeScript SDK comes with an optional interceptor package that adds tracing with [OpenTelemetry](https://www.npmjs.com/package/@temporalio/interceptors-opentelemetry).\nSee how to use it in the [interceptors-opentelemetry](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry) code sample.\n\n### Interceptor types\n\n- [WorkflowInboundCallsInterceptor](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInboundCallsInterceptor/): Intercept Workflow inbound calls like execution, Signals, and Queries.\n- [WorkflowOutboundCallsInterceptor](https://typescript.temporal.io/api/interfaces/workflow.WorkflowOutboundCallsInterceptor/): Intercept Workflow outbound calls to Temporal APIs like scheduling Activities and starting Timers.\n- [ActivityInboundCallsInterceptor](https://typescript.temporal.io/api/interfaces/worker.ActivityInboundCallsInterceptor): Intercept inbound calls to an Activity (such as `execute`).\n- [WorkflowClientCallsInterceptor](https://typescript.temporal.io/api/interfaces/client.WorkflowClientCallsInterceptor/): Intercept methods of [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.WorkflowClient/) and [`WorkflowHandle`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle) like starting or signaling a Workflow.\n\n### How interceptors work\n\nInterceptors are run in a chain, and all interceptors work similarly.\nThey accept two arguments: `input` and `next`, where `next` calls the next interceptor in the chain.\nAll interceptor methods are optional—it's up to the implementor to choose which methods to intercept.\n\n### Interceptor examples\n\n<!--TODO use snipsync-->\n\n**Log start and completion of Activities**\n\n```ts\nimport {\n  ActivityInput,\n  Next,\n  WorkflowOutboundCallsInterceptor,\n} from '@temporalio/workflow';\n\nexport class ActivityLogInterceptor\n  implements WorkflowOutboundCallsInterceptor\n{\n  constructor(public readonly workflowType: string) {}\n\n  async scheduleActivity(\n    input: ActivityInput,\n    next: Next<WorkflowOutboundCallsInterceptor, 'scheduleActivity'>,\n  ): Promise<unknown> {\n    console.log('Starting activity', { activityType: input.activityType });\n    try {\n      return await next(input);\n    } finally {\n      console.log('Completed activity', {\n        workflow: this.workflowType,\n        activityType: input.activityType,\n      });\n    }\n  }\n}\n```\n\n**Authorization**\n\n```ts\nimport {\n  defaultDataConverter,\n  Next,\n  WorkflowInboundCallsInterceptor,\n  WorkflowInput,\n} from '@temporalio/workflow';\n\n/**\n * WARNING: This demo is meant as a simple auth example.\n * Do not use this for actual authorization logic.\n * Auth headers should be encrypted and credentials\n * stored outside of the codebase.\n */\nexport class DumbWorkflowAuthInterceptor\n  implements WorkflowInboundCallsInterceptor\n{\n  public async execute(\n    input: WorkflowInput,\n    next: Next<WorkflowInboundCallsInterceptor, 'execute'>,\n  ): Promise<unknown> {\n    const authHeader = input.headers.auth;\n    const { user, password } = authHeader\n      ? await defaultDataConverter.fromPayload(authHeader)\n      : undefined;\n\n    if (!(user === 'admin' && password === 'admin')) {\n      throw new Error('Unauthorized');\n    }\n    return await next(input);\n  }\n}\n```\n\nTo properly do authorization from Workflow code, the Workflow would need to access encryption keys and possibly authenticate against an external user database, which requires the Workflow to break isolation.\nPlease contact us if you need to discuss this further.\n\n### Interceptor registration\n\n**Activity and client interceptors registration**\n\n- Activity interceptors are registered on Worker creation by passing an array of [ActivityInboundCallsInterceptor factory functions](https://typescript.temporal.io/api/interfaces/worker.ActivityInboundCallsInterceptorFactory) through [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#interceptors).\n\n- Client interceptors are registered on `WorkflowClient` construction by passing an array of [WorkflowClientCallsInterceptor factory functions](https://typescript.temporal.io/api/interfaces/client.WorkflowClientCallsInterceptorFactory) via [WorkflowClientOptions](https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions#interceptors).\n\n**Workflow interceptors registration**\n\nWorkflow interceptor registration is different from the other interceptors because they run in the Workflow isolate.\nTo register Workflow interceptors, export an `interceptors` function from a file located in the `workflows` directory and provide the name of that file to the Worker on creation via [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#interceptors).\n\nAt the time of construction, the Workflow context is already initialized for the current Workflow.\nUse [`workflowInfo`](https://typescript.temporal.io/api/namespaces/workflow#workflowinfo) to add Workflow-specific information in the interceptor.\n\n`src/workflows/your-interceptors.ts`\n\n```ts\nimport { workflowInfo } from '@temporalio/workflow';\n\nexport const interceptors = () => ({\n  outbound: [new ActivityLogInterceptor(workflowInfo().workflowType)],\n  inbound: [],\n});\n```\n\n`src/worker/index.ts`\n\n```ts\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  interceptors: {\n    workflowModules: [require.resolve('./workflows/your-interceptors')],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-import-an-ecmascript-module.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-import-an-ecmascript-module.md","id":"typescript/how-to-import-an-ecmascript-module","title":"How to import an ECMAScript module","description":"See our Fetch ESM sample for the necessary configuration changes.","label":"ECMAScript modules","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe JavaScript ecosystem is quickly moving toward publishing ECMAScript modules (ESM) instead of CommonJS modules.\nFor example, `node-fetch@3` is ESM, but `node-fetch@2` is CommonJS.\n\nFor more information about importing a pure ESM dependency, see our [Fetch ESM](https://github.com/temporalio/samples-typescript/tree/main/fetch-esm) sample for the necessary configuration changes:\n\n- `package.json` must have include the `\"type\": \"module\"` attribute.\n- `tsconfig.json` should output in `esnext` format.\n- Imports must include the `.js` file extension.\n","is_empty":false},{"file_name":"how-to-list-search-attributes-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-list-search-attributes-in-typescript.md","id":"typescript/how-to-list-search-attributes-in-typescript","title":"How to list Search Attributes in TypeScript","description":"List Search Attributes","label":"List Search Attributes","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n**Listing**\n\nFor now, we can call [`client.service.listWorkflowExecutions()`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.WorkflowService-1#listworkflowexecutions). A friendlier `client.listWorkflows()` function that does Payload decoding is planned.\n\n```ts\nconst { executions, nextPageToken } = await client.service\n  .listWorkflowExecutions(\n    {\n      namespace: 'default',\n      ...(input || {}),\n    },\n  );\nconst decodedWorkflows = executions.map(\n  ({\n    execution,\n    type,\n    startTime,\n    closeTime,\n    status,\n    historyLength,\n    parentNamespaceId,\n    parentExecution,\n    executionTime,\n    memo: memoRaw,\n    searchAttributes: searchAttributesRaw,\n    // autoResetPoints,\n    taskQueue,\n    stateTransitionCount,\n  }) => {\n    let memo: Record<string, unknown> | undefined | null = null;\n    let searchAttributes: Record<string, unknown> | undefined | null = null;\n\n    try {\n      memo = mapFromPayloads(defaultConverter, memoRaw?.fields);\n      searchAttributes = mapFromPayloads(\n        searchAttributeConverter,\n        searchAttributesRaw?.indexedFields,\n      );\n    } catch (e) {\n      // unable to convert with default converter\n    }\n\n    return {\n      id: execution!.workflowId,\n      runId: execution!.runId,\n      type: type!.name,\n      status: status!,\n      taskQueue: taskQueue!,\n      historyLength: historyLength!.toInt(),\n      startTime: tsToDate(startTime!),\n      executionTime: tsToDate(executionTime!),\n      closeTime: optionalTsToDate(closeTime),\n      parentExecution,\n      parentNamespace: parentNamespaceId || null, // convert empty string to null\n      memo: memo && Object.keys(memo!).length === 0 ? null : memo, // convert empty object to null\n      searchAttributes,\n      stateTransitionCount: stateTransitionCount!.toInt(),\n    } as unknown as Workflow;\n  },\n);\n```\n","is_empty":false},{"file_name":"how-to-list-workflow-executions-using-the-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-list-workflow-executions-using-the-client-in-typescript.md","id":"typescript/how-to-list-workflow-executions-using-the-client-in-typescript","title":"How to list Workflow Executions using the Client in TypeScript","description":"List Workflow Executions using the Client","label":"List Workflow Executions using the Client","tags":["developer-guide","typescript","client"],"ssdi":[],"markdown_content":"\nUse [`WorkflowService.listWorkflowExecutions`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#listworkflowexecutions):\n\n```typescript\nimport { Connection } from '@temporalio/client';\n\nconst connection = await Connection.connect();\nconst response = await connection.workflowService.listWorkflowExecutions({\n  query: `ExecutionStatus = \"Running\"`,\n});\n```\n\nwhere `query` is a [List Filter](/concepts/what-is-a-list-filter).\n","is_empty":false},{"file_name":"how-to-listen-to-heartbeats-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-listen-to-heartbeats-in-typescript.md","id":"typescript/how-to-listen-to-heartbeats-in-typescript","title":"How to listen to Heartbeats in TypeScript","description":"Listen to Heartbeats","label":"Listen to Heartbeats","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n[`MockActivityEnvironment`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment) is an [`EventEmitter`](https://nodejs.org/api/events.html#class-eventemitter) that emits a `heartbeat` event that you can use to listen for Heartbeats emitted by the Activity.\n\nWhen an Activity is run by a Worker, Heartbeats are throttled to avoid overloading the server.\n`MockActivityEnvironment`, however, does not throttle Heartbeats.\n\n```ts\nimport { Context } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport assert from 'assert';\n\nasync function activityFoo(): Promise<void> {\n  Context.current().heartbeat(6);\n}\n\nconst env = new MockActivityEnvironment();\n\nenv.on('heartbeat', (d: unknown) => {\n  assert(d === 6);\n});\n\nawait env.run(activityFoo);\n```\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-log-from-a-workflow-in-typescript.md","id":"typescript/how-to-log-from-a-workflow-in-typescript","title":"How to log from a Workflow in TypeScript","description":"Send logs and errors to a logging service, so that when things go wrong, you can see what happened.","label":"Logging","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nThe SDK core uses `WARN` for its default logging level.\n\n:::note Sample available\n\nA complete sample for setting up the instrumentation for the different components of the SDK is available in our samples repo: [Instrumentation demo](https://github.com/temporalio/samples-typescript/tree/main/instrumentation).\n\n:::\n\n### Logging from Activities\n\nActivities run in the standard Node.js environment and can use any Node.js logger.\n\n<details>\n<summary>\nInject Activity context via interceptor and log all Activity Executions\n</summary>\n\n<!--SNIPSTART typescript-activity-logging-interceptor-->\n\n[instrumentation/src/activities/interceptors.ts](https://github.com/temporalio/samples-typescript/blob/master/instrumentation/src/activities/interceptors.ts)\n\n```ts\nimport { Context } from '@temporalio/activity';\nimport {\n  ActivityExecuteInput,\n  ActivityInboundCallsInterceptor,\n  Next,\n} from '@temporalio/worker';\nimport { Logger } from 'winston';\n\n/** An Activity Context with an attached logger */\nexport interface ContextWithLogger extends Context {\n  logger: Logger;\n}\n\n/** Get the current Activity context with an attached logger */\nexport function getContext(): ContextWithLogger {\n  return Context.current() as ContextWithLogger;\n}\n\n/** Logs Activity executions and their duration */\nexport class ActivityInboundLogInterceptor\n  implements ActivityInboundCallsInterceptor\n{\n  public readonly logger: Logger;\n\n  constructor(ctx: Context, logger: Logger) {\n    this.logger = logger.child({\n      activity: ctx.info,\n    });\n\n    // Set a logger instance on the current Activity Context to provide\n    // contextual logging information to each log entry generated by the Activity.\n    (ctx as ContextWithLogger).logger = this.logger;\n  }\n\n  async execute(\n    input: ActivityExecuteInput,\n    next: Next<ActivityInboundCallsInterceptor, 'execute'>,\n  ): Promise<unknown> {\n    let error: any = undefined;\n    const startTime = process.hrtime.bigint();\n    try {\n      return await next(input);\n    } catch (err: any) {\n      error = err;\n      throw err;\n    } finally {\n      const durationNanos = process.hrtime.bigint() - startTime;\n      const durationMs = Number(durationNanos / 1_000_000n);\n      if (error) {\n        this.logger.error('activity failed', { error, durationMs });\n      } else {\n        this.logger.debug('activity completed', { durationMs });\n      }\n    }\n  }\n}\n```\n\n<!--SNIPEND-->\n\n</details>\n\n<details>\n<summary>\nUse the injected logger from an Activity\n</summary>\n\n<!--SNIPSTART typescript-activity-use-injected-logger -->\n\n[instrumentation/src/activities/index.ts](https://github.com/temporalio/samples-typescript/blob/master/instrumentation/src/activities/index.ts)\n\n```ts\nimport { getContext } from './interceptors';\n\nexport async function greet(name: string): Promise<string> {\n  const { logger } = getContext();\n  logger.info('Log from activity', { name });\n  return `Hello, ${name}!`;\n}\n```\n\n<!--SNIPEND-->\n\n</details>\n\n### Logging from Workflows with Workflow sinks\n\nLogging from Workflows is tricky for two reasons:\n\n1. Workflows run in a sandboxed environment and cannot do any I/O.\n1. Workflow code might get replayed at any time, generating duplicate log messages.\n\nTo work around these limitations, we recommend using the sinks feature in the TypeScript SDK.\nSinks enable one-way export of logs, metrics, and traces from the Workflow isolate to the Node.js environment.\n\n<!--\nWorkflows in Temporal may be replayed from the beginning of their history when resumed. In order for Temporal to recreate the exact state Workflow code was in, the code is required to be fully deterministic. To prevent breaking determinism, in the TypeScript SDK, Workflow code runs in an isolated execution environment and may not use any of the Node.js APIs or communicate directly with the outside world. -->\n\nSinks are written as objects with methods.\nSimilar to Activities, they are declared in the Worker and then proxied in Workflow code, and it helps to share types between both.\n\n#### Comparing Sinks, Activities, and interceptors\n\nSinks are similar to Activities in that they are both registered on the Worker and proxied into the Workflow.\nHowever, they differ from Activities in important ways:\n\n- A sink function doesn't return any value back to the Workflow and cannot be awaited.\n- A sink call isn't recorded in the Event History of a Workflow Execution (no timeouts or retries).\n- A sink function _always_ runs on the same Worker that runs the Workflow Execution it's called from.\n\n#### Declare the sink interface\n\nExplicitly declaring a sink's interface is optional but is useful for ensuring type safety in subsequent steps:\n\n<!--SNIPSTART typescript-logger-sink-interface-->\n\n[sinks/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/sinks/src/workflows.ts)\n\n```ts\nimport { LoggerSinks, proxySinks, Sinks } from '@temporalio/workflow';\n\nexport interface AlertSinks extends Sinks {\n  alerter: {\n    alert(message: string): void;\n  };\n}\n\nexport type MySinks = AlertSinks & LoggerSinks;\n```\n\n<!--SNIPEND-->\n\n#### Implement sinks\n\nImplementing sinks is a two-step process.\n\nImplement and inject the Sink function into a Worker\n\n<!--SNIPSTART typescript-logger-sink-worker-->\n\n[sinks/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/sinks/src/worker.ts)\n\n```ts\nimport { defaultSinks, InjectedSinks, Worker } from '@temporalio/worker';\nimport { MySinks } from './workflows';\n\nasync function main() {\n  const sinks: InjectedSinks<MySinks> = {\n    ...defaultSinks(),\n    alerter: {\n      alert: {\n        fn(workflowInfo, message) {\n          console.log(`sending SMS alert!\nworkflow: ${workflowInfo.runId}\nmessage: ${message}`);\n        },\n        callDuringReplay: false, // The default\n      },\n    },\n  };\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'sinks',\n    sinks,\n  });\n  await worker.run();\n  console.log('Worker gracefully shutdown');\n}\n\nmain().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n<!--SNIPEND-->\n\n- Sink function implementations are passed as an object into [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions/#sinks).\n- You can specify whether you want the injected function to be called during Workflow replay by setting the `callDuringReplay` option.\n\n#### Proxy and call a sink function from a Workflow\n\n<!--SNIPSTART typescript-logger-sink-workflow-->\n\n[sinks/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/sinks/src/workflows.ts)\n\n```ts\nconst { alerter, defaultWorkerLogger } = proxySinks<MySinks>();\n\nexport async function sinkWorkflow(): Promise<string> {\n  defaultWorkerLogger.info('default logger: Workflow Execution started', {});\n  alerter.alert('alerter: Workflow Execution started');\n  return 'Hello, Temporal!';\n}\n```\n\n<!--SNIPEND-->\n\nSome important features of the [InjectedSinkFunction](https://typescript.temporal.io/api/interfaces/worker.InjectedSinkFunction) interface:\n\n- **Injected WorkflowInfo argument**: The first argument of a Sink function implementation is a [`workflowInfo` object](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo/) that contains useful metadata.\n- **Limited arguments types**: The remaining Sink function arguments are copied between the sandbox and the Node.js environment using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n- **No return value**: To prevent breaking determinism, Sink functions cannot return values to the Workflow.\n\n### Advanced: Performance considerations and non-blocking sinks\n\nThe injected sink function contributes to the overall Workflow Task processing duration.\n\n- If you have a long-running sink function, such as one that tries to communicate with external services, you might start seeing Workflow Task timeouts.\n- The effect is multiplied when using `callDuringReplay: true` and replaying long Workflow histories because the Workflow Task timer starts when the first history page is delivered to the Worker.\n","is_empty":false},{"file_name":"how-to-mock-activities-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-mock-activities-in-typescript.md","id":"typescript/how-to-mock-activities-in-typescript","title":"How to mock Activities in TypeScript","description":"Mock Activities","label":"Mock Activities","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nImplement only the relevant Activities for the Workflow being tested.\n\n```ts\nimport type * as activities from './activities';\n\n// Creating a mock object of the activities.\nconst mockActivities: Partial<typeof activities> = {\n  makeHTTPRequest: async () => '99',\n};\n\n// Creating a worker with the mocked activities.\nconst worker = await Worker.create({\n  activities: mockActivities,\n  // ...\n});\n```\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-register-types-with-a-worker-in-typescript.md","id":"typescript/how-to-register-types-with-a-worker-in-typescript","title":"How to register types with a Worker in TypeScript","description":"Register types.","label":"Register Types","tags":["developer-guide","typescript","workers"],"ssdi":[],"markdown_content":"\nIn development, use [`workflowsPath`](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions/#workflowspath):\n\n<!--SNIPSTART typescript-worker-create -->\n\n[snippets/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/worker.ts)\n\n```ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'snippets',\n    activities,\n  });\n\n  await worker.run();\n}\n```\n\n<!--SNIPEND-->\n\nIn this snippet, the Worker bundles the Workflow code at runtime.\n\nIn production, you can improve your Worker's startup time by bundling in advance: as part of your production build, call `bundleWorkflowCode`:\n\n<!--SNIPSTART typescript-bundle-workflow -->\n\n[production/src/scripts/build-workflow-bundle.ts](https://github.com/temporalio/samples-typescript/blob/master/production/src/scripts/build-workflow-bundle.ts)\n\n```ts\nimport { bundleWorkflowCode } from '@temporalio/worker';\nimport { writeFile } from 'fs/promises';\nimport path from 'path';\n\nasync function bundle() {\n  const { code } = await bundleWorkflowCode({\n    workflowsPath: require.resolve('../workflows'),\n  });\n  const codePath = path.join(__dirname, '../../workflow-bundle.js');\n\n  await writeFile(codePath, code);\n  console.log(`Bundle written to ${codePath}`);\n}\n```\n\n<!--SNIPEND-->\n\nThen the bundle can be passed to the Worker:\n\n<!--SNIPSTART typescript-production-worker-->\n\n[production/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/production/src/worker.ts)\n\n```ts\nconst workflowOption = () =>\n  process.env.NODE_ENV === 'production'\n    ? {\n      workflowBundle: {\n        codePath: require.resolve('../workflow-bundle.js'),\n      },\n    }\n    : { workflowsPath: require.resolve('./workflows') };\n\nasync function run() {\n  const worker = await Worker.create({\n    ...workflowOption(),\n    activities,\n    taskQueue: 'production-sample',\n  });\n\n  await worker.run();\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript.md","id":"typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript","title":"How to remove Search Attributes from a Workflow in TypeScript","description":"How to remove Search Attributes from a Workflow","label":"Remove Search Attributes from a Workflow","tags":["developer-guide","typescript","client"],"ssdi":[],"markdown_content":"\n```typescript\nimport { upsertSearchAttributes } from '@temporalio/workflow';\n\nasync function yourWorkflow() {\n  upsertSearchAttributes({ CustomIntField: [1, 2, 3] });\n\n  // ... later, to remove:\n  upsertSearchAttributes({ CustomIntField: [] });\n}\n```\n","is_empty":false},{"file_name":"how-to-replay-a-workflow-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-replay-a-workflow-execution-in-typescript.md","id":"typescript/how-to-replay-a-workflow-execution-in-typescript","title":"How to replay a Workflow Execution in TypeScript","description":"Replay a Workflow Execution","label":"Replay a Workflow Execution","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTo replay a single Event History, use [worker.runReplayHistory](https://typescript.temporal.io/api/classes/worker.Worker#runreplayhistory).\n\nWhen an Event History is replayed and non-determinism is detected (that is, the Workflow code is incompatible with the History), [DeterminismViolationError](https://typescript.temporal.io/api/classes/workflow.DeterminismViolationError) is thrown.\nIf replay fails for any other reason, [ReplayError](https://typescript.temporal.io/api/classes/worker.ReplayError) is thrown.\n\nIn the following example, a single Event History is loaded from a JSON file on disk (as obtained from the [Web UI](/web-ui) or the [Temporal CLI](/cli/workflow#show)):\n\n```ts\nconst filePath = './history_file.json';\nconst history = await JSON.parse(fs.promises.readFile(filePath, 'utf8'));\nawait Worker.runReplayHistory(\n  {\n    workflowsPath: require.resolve('./your/workflows'),\n  },\n  history,\n);\n```\n\nAlternatively, we can download the Event History programmatically using a Client:\n\n```ts\nconst connection = await Connection.connect({ address });\nconst client = new Client({ connection, namespace: 'your-namespace' });\nconst handle = client.workflow.getHandle('your-workflow-id');\nconst history = await handle.fetchHistory();\nawait Worker.runReplayHistory(\n  {\n    workflowsPath: require.resolve('./your/workflows'),\n  },\n  history,\n);\n```\n\nTo gain confidence that changes to a Workflow are safe to deploy, we recommend that you obtain Event Histories from the relevant Task Queue and replay them in bulk.\nYou can do so by combining the [workflow.list](https://typescript.temporal.io/api/classes/client.WorkflowClient#list) and [worker.runReplayHistories](https://typescript.temporal.io/api/classes/worker.Worker#runreplayhistories) APIs.\n\nIn the following example (which, as of server 1.18, requires [Advanced Visibility](/concepts/what-is-advanced-visibility) to be enabled), Event Histories are downloaded from the server and then replayed by passing in a client and a set of Workflows Executions.\nThe [results](https://typescript.temporal.io/api/interfaces/worker.ReplayResult) returned by the async iterator contain information about the Workflow Execution and whether an error occurred during replay.\n\n```ts\nconst executions = client.workflow.list({\n  query: 'TaskQueue=foo and StartTime > \"2022-01-01T12:00:00\"',\n});\nconst histories = executions.intoHistories();\nconst results = Worker.runReplayHistories(\n  {\n    workflowsPath: require.resolve('./your/workflows'),\n  },\n  histories,\n);\nfor await (const result of results) {\n  if (result.error) {\n    console.error('Replay failed', result);\n  }\n}\n```\n","is_empty":false},{"file_name":"how-to-run-a-worker-on-docker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-run-a-worker-on-docker.md","id":"typescript/how-to-run-a-worker-on-docker","title":"How to run a Worker on Docker in TypeScript","description":"Workers based on the TypeScript SDK can be deployed and run as Docker containers.","label":"Run a Worker on Docker","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nWorkers based on the TypeScript SDK can be deployed and run as Docker containers.\n\nAt this moment, we recommend using Node.js 18.\n(Node.js 20 has known issues.)\nBoth `amd64` and `arm64` platforms are supported.\nA glibc-based image is required; musl-based images are _not_ supported (see below).\n\nThe easiest way to deploy a TypeScript SDK Worker on Docker is to start with the `node:18-bullseye` image.\nFor example:\n\n```dockerfile\nFROM node:18-bullseye\n\nCOPY . /app\nWORKDIR /app\n\nRUN npm install --only=production \\\n    && npm run build\n\nCMD [\"build/worker.js\"]\n```\n\nFor smaller images and/or more secure deployments, it is also possible to use `-slim` Docker image variants (like `node:18-bullseye-slim`) or `distroless/nodejs` Docker images (like `gcr.io/distroless/nodejs:18`) with the following caveats.\n\n### Using `node:slim` images\n\n`node:slim` images do not contain some of the common packages found in regular images. This results in significantly smaller images.\n\nHowever, TypeScript SDK requires the presence of root TLS certificates (the `ca-certificates` package), which are not included in `slim` images.\nThe `ca-certificates` package is required even when connecting to a local Temporal Server or when using a server connection config that doesn't explicitly use TLS.\n\nFor this reason, the `ca-certificates` package must be installed during the construction of the Docker image.\nFor example:\n\n```dockerfile\nFROM node:18-bulleyes-slim\n\nRUN apt-get update \\\n    && apt-get install -y ca-certificates \\\n    && rm -rf /var/lib/apt/lists/*\n\n# ... same as with regular image\n```\n\nFailure to install this dependency results in a `[TransportError: transport error]` runtime error, because the certificates cannot be verified.\n\n### Using `distroless/nodejs` images\n\n`distroless/nodejs` images include only the files that are strictly required to execute `node`.\nThis results in even smaller images (approximately half the size of `node:slim` images).\nIt also significantly reduces the surface of potential security issues that could be exploited by a hacker in the resulting Docker images.\n\nIt is generally possible and safe to execute TypeScript SDK Workers using `distroless/nodejs` images (unless your code itself requires dependencies that are not included in `distroless/nodejs`).\n\nHowever, some tools required for the build process (notably the `npm` command) are _not_ included in the `distroless/nodejs` image.\nThis might result in various error messages during the Docker build.\n\nThe recommanded solution is to use a multi-step Dockerfile.\nFor example:\n\n```dockerfile\n# -- BUILD STEP --\n\nFROM node:18-bulleyes AS builder\n\nCOPY . /app\nWORKDIR /app\n\nRUN npm install --only=production \\\n    && npm run build\n\n# -- RESULTING IMAGE --\n\nFROM gcr.io/distroless/nodejs:18\n\nCOPY --from=builder /app /app\nWORKDIR /app\n\nCMD [\"build/worker.js\"]\n```\n\n### Properly configure Node.js memory in Docker\n\nBy default, `node` configures its maximum old-gen memory to 25% of the _physical memory_ of the machine on which it is executing, with a maximum of 4 GB.\nThis is likely inappropriate when running Node.js in a Docker environment and can result in either underusage of available memory (`node` only uses a fraction of the memory allocated to the container) or overusage (`node` tries to use more memory than what is allocated to the container, which will eventually lead to the process being killed by the operating system).\n\nTherefore we recommended that you always explicitly set the `--max-old-space-size` `node` argument to approximately 80% of the maximum size (in megabytes) that you want to allocate the `node` process.\nYou might need some experimentation and adjustment to find the most appropriate value based on your specific application.\n\nIn practice, it is generally easier to provide this argument through the [`NODE_OPTIONS` environment variable](https://nodejs.org/api/cli.html#node_optionsoptions).\n\n### Do not use Alpine\n\nAlpine replaces glibc with musl, which is incompatible with the Rust core of the TypeScript SDK.\nIf you receive errors like the following, it's probably because you are using Alpine.\n\n```sh\nError: Error loading shared library ld-linux-x86-64.so.2: No such file or directory (needed by /opt/app/node_modules/@temporalio/core-bridge/index.node)\n```\n\nOr like this:\n\n```sh\nError: Error relocating /opt/app/node_modules/@temporalio/core-bridge/index.node: __register_atfork: symbol not found\n```\n","is_empty":false},{"file_name":"how-to-run-an-activity-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-run-an-activity-in-typescript.md","id":"typescript/how-to-run-an-activity-in-typescript","title":"How to Run an Activity when testing in isolation in TypeScript","description":"Use `MockActivityEnvironment.run()` to run a function in an Activity Context.","label":"Run an Activity when testing in isolation","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nFirst, create a [`MockActivityEnvironment`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment).\nThe constructor accepts an optional partial Activity [`Info`](https://typescript.temporal.io/api/classes/activity.Info) object in case any info fields are needed for the test.\n\nThen use [`MockActivityEnvironment.run()`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment#run) to run a function in an Activity [Context](https://typescript.temporal.io/api/classes/activity.Context).\n\n```ts\nimport { Context } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport assert from 'assert';\n\n// A function that takes two numbers and returns a promise that resolves to the sum of the two numbers\n// and the current attempt.\nasync function activityFoo(a: number, b: number): Promise<number> {\n  return a + b + Context.current().info.attempt;\n}\n\n// Create a MockActivityEnvironment with attempt set to 2. Run the activityFoo\n// function with parameters 5 and 35. Assert that the result is 42.\nconst env = new MockActivityEnvironment({ attempt: 2 });\nconst result = await env.run(activityFoo, 5, 35);\nassert.equal(result, 42);\n```\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-send-a-query-to-a-workflow-in-typescript.md","id":"typescript/how-to-send-a-query-to-a-workflow-in-typescript","title":"How to send a Query to a Workflow in TypeScript","description":"Use `WorkflowHandle.query` to query a running or completed Workflow.","label":"Send a Query","tags":["typescript","developer-guide"],"ssdi":[],"markdown_content":"\nUse [`WorkflowHandle.query`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle/#query) to query a running or completed Workflow.\n\n<!--SNIPSTART typescript-send-query -->\n\n[state/src/query-workflow.ts](https://github.com/temporalio/samples-typescript/blob/master/state/src/query-workflow.ts)\n\n```ts\nimport { Client } from '@temporalio/client';\nimport { getValueQuery } from './workflows';\n\nasync function run(): Promise<void> {\n  const client = new Client();\n  const handle = client.workflow.getHandle('state-id-0');\n  const meaning = await handle.query(getValueQuery, 'meaning-of-life');\n  console.log({ meaning });\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-send-a-signal-from-a-client-in-typescript.md","id":"typescript/how-to-send-a-signal-from-a-client-in-typescript","title":"How to send a Signal from a Client in TypeScript","description":"Send a Signal from Client","label":"Send a Signal from Client","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n[`WorkflowHandle.signal`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#signal)\n\n```typescript\nimport { WorkflowClient } from '@temporalio/client';\nimport { joinSignal } from './workflows';\n\nconst client = new WorkflowClient();\n\nconst handle = client.getHandle('workflow-id-123');\n\nawait handle.signal(joinSignal, { userId: 'user-1', groupId: 'group-1' });\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-send-a-signal-from-a-workflow-in-typescript.md","id":"typescript/how-to-send-a-signal-from-a-workflow-in-typescript","title":"How to send a Signal from Workflow in TypeScript","description":"Send a Signal from Workflow","label":"Send a Signal from Workflow","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n[`getExternalWorkflowHandle`](https://typescript.temporal.io/api/namespaces/workflow#getexternalworkflowhandle)\n\n```typescript\nimport { getExternalWorkflowHandle } from '@temporalio/workflow';\nimport { joinSignal } from './other-workflow';\n\nexport async function yourWorkflowThatSignals() {\n  const handle = getExternalWorkflowHandle('workflow-id-123');\n  await handle.signal(joinSignal, { userId: 'user-1', groupId: 'group-1' });\n}\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-send-a-signal-with-start-in-typescript.md","id":"typescript/how-to-send-a-signal-with-start-in-typescript","title":"How to send a Signal with Start in TypeScript","description":"Send a Signal with Start","label":"Send a Signal with Start","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n[`WorkflowClient.signalWithStart`](https://typescript.temporal.io/api/classes/client.WorkflowClient#signalwithstart)\n\n```typescript\nimport { WorkflowClient } from '@temporalio/client';\nimport { joinSignal, yourWorkflow } from './workflows';\n\nconst client = new WorkflowClient();\n\nawait client.signalWithStart(yourWorkflow, {\n  workflowId: 'workflow-id-123',\n  args: [{ foo: 1 }],\n  signal: joinSignal,\n  signalArgs: [{ userId: 'user-1', groupId: 'group-1' }],\n});\n```\n","is_empty":false},{"file_name":"how-to-send-logs-from-activities-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-send-logs-from-activities-in-typescript.md","id":"typescript/how-to-send-logs-from-activities-in-typescript","title":"How to send logs from Activities in TypeScript","description":"Send logs from Activities","label":"Send logs from Activities","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nActivities run in the standard Node.js environment and can use any Node.js logger.\n\n<details>\n<summary>\nInject Activity context via interceptor and log all Activity Executions\n</summary>\n\n<!--SNIPSTART typescript-activity-logging-interceptor-->\n\n[instrumentation/src/activities/interceptors.ts](https://github.com/temporalio/samples-typescript/blob/master/instrumentation/src/activities/interceptors.ts)\n\n```ts\nimport { Context } from '@temporalio/activity';\nimport {\n  ActivityExecuteInput,\n  ActivityInboundCallsInterceptor,\n  Next,\n} from '@temporalio/worker';\nimport { Logger } from 'winston';\n\n/** An Activity Context with an attached logger */\nexport interface ContextWithLogger extends Context {\n  logger: Logger;\n}\n\n/** Get the current Activity context with an attached logger */\nexport function getContext(): ContextWithLogger {\n  return Context.current() as ContextWithLogger;\n}\n\n/** Logs Activity executions and their duration */\nexport class ActivityInboundLogInterceptor\n  implements ActivityInboundCallsInterceptor\n{\n  public readonly logger: Logger;\n\n  constructor(ctx: Context, logger: Logger) {\n    this.logger = logger.child({\n      activity: ctx.info,\n    });\n\n    // Set a logger instance on the current Activity Context to provide\n    // contextual logging information to each log entry generated by the Activity.\n    (ctx as ContextWithLogger).logger = this.logger;\n  }\n\n  async execute(\n    input: ActivityExecuteInput,\n    next: Next<ActivityInboundCallsInterceptor, 'execute'>,\n  ): Promise<unknown> {\n    let error: any = undefined;\n    const startTime = process.hrtime.bigint();\n    try {\n      return await next(input);\n    } catch (err: any) {\n      error = err;\n      throw err;\n    } finally {\n      const durationNanos = process.hrtime.bigint() - startTime;\n      const durationMs = Number(durationNanos / 1_000_000n);\n      if (error) {\n        this.logger.error('activity failed', { error, durationMs });\n      } else {\n        this.logger.debug('activity completed', { durationMs });\n      }\n    }\n  }\n}\n```\n\n<!--SNIPEND-->\n\n</details>\n\n<details>\n<summary>\nUse the injected logger from an Activity\n</summary>\n\n<!--SNIPSTART typescript-activity-use-injected-logger -->\n\n[instrumentation/src/activities/index.ts](https://github.com/temporalio/samples-typescript/blob/master/instrumentation/src/activities/index.ts)\n\n```ts\nimport { getContext } from './interceptors';\n\nexport async function greet(name: string): Promise<string> {\n  const { logger } = getContext();\n  logger.info('Log from activity', { name });\n  return `Hello, ${name}!`;\n}\n```\n\n<!--SNIPEND-->\n\n</details>\n","is_empty":false},{"file_name":"how-to-send-logs-in-workers-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-send-logs-in-workers-in-typescript.md","id":"typescript/how-to-send-logs-from-workflows-in-typescript","title":"How to send logs from Workflows in TypeScript","description":"Send logs from Workflows","label":"Send logs from Workflows","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n**Logging in Workers and Clients**\n\nThe Worker comes with a default logger which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThere are 5 levels in total:\n\n- `TRACE`\n- `DEBUG`\n- `INFO`\n- `WARN`\n- `ERROR`\n\nThe reason we only offer a default logger is to minimize Worker dependencies and allow SDK users to bring their own logger.\n\n**Customizing the default logger**\n\nTemporal ships a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.DefaultLogger/) that implements the basic interface.\n\n**Set Default logger level**\n\nThe following example creates a new logger that will log all messages with a level `WARN` and higher.\n\n```ts\nimport { DefaultLogger, Runtime } from '@temporalio/worker';\n\n// Creating a new logger that will log all messages with level WARN and higher.\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\nRuntime.install({ logger });\n```\n\n**Example: Accumulate logs for testing/reporting**\n\nThe following example creates a logger that will log all the messages to an array.\n\n```ts\nimport { DefaultLogger, LogEntry } from '@temporalio/worker';\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger('TRACE', (entry) => logs.push(entry));\nlog.debug('hey', { a: 1 });\nlog.info('ho');\nlog.warn('lets', { a: 1 });\nlog.error('go');\n```\n\nThe log levels are [listed here](https://typescript.temporal.io/api/namespaces/worker#loglevel) in increasing order of severity.\n","is_empty":false},{"file_name":"how-to-set-a-cron-job-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-a-cron-job-in-typescript.md","id":"typescript/how-to-set-a-cron-job-in-typescript","title":"How to set a cron job in TypeScript","description":"Set a cron job","label":"Set a cron job","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nYou can set each Workflow to repeat on a schedule with the `cronSchedule` option:\n\n```typescript\nconst handle = await client.start(scheduledWorkflow, {\n  // ...\n  cronSchedule: '* * * * *', // start every minute\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-a-custom-logger-in-typescript.md","id":"typescript/how-to-set-a-custom-logger-in-typescript","title":"How to set a custom logger in TypeScript","description":"Set a custom logger","label":"Set a custom logger","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n#### Logging in Workers and Clients\n\nThe Worker comes with a default logger, which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThe following [log levels](https://typescript.temporal.io/api/namespaces/worker#loglevel) are listed in increasing order of severity.\n\n#### Customizing the default logger\n\nTemporal uses a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.DefaultLogger/) that implements the basic interface:\n\n```ts\nimport { DefaultLogger, Runtime } from '@temporalio/worker';\n\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\nRuntime.install({ logger });\n```\n\nThe previous code example sets the default logger to log only messages with level `WARN` and higher.\n\n#### Accumulate logs for testing and reporting\n\n```ts\nimport { DefaultLogger, LogEntry } from '@temporalio/worker';\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger('TRACE', (entry) => logs.push(entry));\nlog.debug('hey', { a: 1 });\nlog.info('ho');\nlog.warn('lets', { a: 1 });\nlog.error('go');\n```\n\nA common logging use case is logging to a file to be picked up by a collector like the [Datadog Agent](https://docs.datadoghq.com/logs/log_collection/nodejs/?tab=winston30).\n\n```ts\nimport { Runtime } from '@temporalio/worker';\nimport winston from 'winston';\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  transports: [new transports.File({ filename: '/path/to/worker.log' })],\n});\nRuntime.install({ logger });\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-a-heartbeat-timeout-in-typescript.md","id":"typescript/how-to-set-a-heartbeat-timeout-in-typescript","title":"How to set a Heartbeat Timeout in TypeScript","description":"Set a Heartbeat Timeout","label":"Set a Heartbeat Timeout","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTo set a Heartbeat Timeout, use [`ActivityOptions.heartbeatTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#heartbeattimeout). If the Activity takes longer than that between heartbeats, the Activity is failed.\n\n```typescript\n// Creating a proxy for the activity.\nconst { longRunningActivity } = proxyActivities<typeof activities>({\n  // translates to 300000 ms\n  scheduleToCloseTimeout: '5m',\n  // translates to 30000 ms\n  startToCloseTimeout: '30s',\n  // equivalent to '10 seconds'\n  heartbeatTimeout: 10000,\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-a-parent-close-policy-in-typescript.md","id":"typescript/how-to-set-a-parent-close-policy-in-typescript","title":"How to set Parent Close Policy in Typescript","description":"Use the `parentClosePolicy` property.","label":"Parent Close Policy","tags":["typescript","developer-guide","how-to"],"ssdi":[],"markdown_content":"\nTo specify how a Child Workflow reacts to a Parent Workflow reaching a Closed state, use the [`parentClosePolicy`](https://typescript.temporal.io/api/interfaces/workflow.ChildWorkflowOptions#parentclosepolicy) option.\n\n<!--SNIPSTART typescript-child-workflow -->\n\n[child-workflows/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/child-workflows/src/workflows.ts)\n\n```ts\nimport { executeChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(...names: string[]): Promise<string> {\n  const responseArray = await Promise.all(\n    names.map((name) =>\n      executeChild(childWorkflow, {\n        args: [name],\n        // workflowId, // add business-meaningful workflow id here\n        // // regular workflow options apply here, with two additions (defaults shown):\n        // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n        // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n      })\n    ),\n  );\n  return responseArray.join('\\n');\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-a-schedule-to-close-timeout-in-typescript.md","id":"typescript/how-to-set-a-schedule-to-close-timeout-in-typescript","title":"How to set a Schedule to Close Timeout in TypeScript","description":"Set a Schedule to Close Timeout","label":"Set a Schedule to Close Timeout","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault: ∞ (infinity – no limit)\n\nIn this example, you can set the `scheduleToCloseTimeout` to 5 m.\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: '5m',\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-a-schedule-to-start-timeout-in-typescript.md","id":"typescript/how-to-set-a-schedule-to-start-timeout-in-typescript","title":"How to set a Schedule to Start Timeout in TypeScript","description":"Set a Schedule to Start Timeout","label":"Set a Schedule to Start Timeout","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault: ∞ (infinity – no limit)\n\nIn this example, you can set the `scheduleToStartTimeout` to 60 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: '5m',\n  scheduleToStartTimeout: '60s',\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-a-start-to-close-timeout-in-typescript.md","id":"typescript/how-to-set-a-start-to-close-timeout-in-typescript","title":"How to set a Start to Close Timeout in TypeScript","description":"Set a Start to Close Timeout","label":"Set a Start to Close Timeout","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault: ∞ (infinity – no limit)\n\nIn this example, you can set the `startToCloseTimeout` to 30 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '30s', // recommended\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-a-workflow-id-in-typescript.md","id":"typescript/how-to-set-a-workflow-id-in-typescript","title":"How to set a Workflow Id in TypeScript","description":"Set a Workflow Id","label":"Set a Workflow Id","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nConnect to a Client with `client.start()` and any arguments. Then specify your `taskQueue` and set your `workflowId` to a meaningful business identifier.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: 'yourWorkflowId',\n  taskQueue: 'yourTaskQueue',\n  args: ['your', 'arg', 'uments'],\n});\n```\n\nThis starts a new Client with the given Workflow Id, Task Queue name, and an argument.\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-a-workflow-task-queue-in-typescript.md","id":"typescript/how-to-set-a-workflow-task-queue-in-typescript","title":"How to set a Workflow Task Queue in TypeScript","description":"Set a Workflow Task Queue","label":"Set a Workflow Task Queue","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nA Task Queue is a dynamic queue in Temporal polled by one or more Workers.\n\nWorkers bundle Workflow code and node modules using Webpack v5 and execute them inside V8 isolates. Activities are directly required and run by Workers in the Node.js environment.\n\nWorkers are flexible. You can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers on a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker.\n- Workflow bundle, specify one of the following options:\n  - a `workflowsPath` to your `workflows.ts` file to pass to Webpack. For example, `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n  - Or pass a prebuilt bundle to `workflowBundle`, if you prefer to handle the bundling yourself.\n\n```ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  // Step 1: Register Workflows and Activities with the Worker and connect to\n  // the Temporal server.\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    activities,\n    taskQueue: 'hello-world',\n  });\n  // Worker connects to localhost by default and uses console.error for logging.\n  // Customize the Worker by passing more options to create():\n  // https://typescript.temporal.io/api/classes/worker.Worker\n  // If you need to configure server connection parameters, see docs:\n  // /typescript/security#encryption-in-transit-with-mtls\n\n  // Step 2: Start accepting tasks on the `tutorial` queue\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n`taskQueue` is the only required option; however, use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nWhen scheduling a Workflow, a `taskQueue` must be specified.\n\n```ts\nimport { Connection, WorkflowClient } from '@temporalio/client';\n// This is the code that is used to start a workflow.\nconst connection = await Connection.create();\nconst client = new WorkflowClient({ connection });\nconst result = await client.execute(yourWorkflow, {\n  // required\n  taskQueue: 'your-task-queue',\n  // required\n  workflowId: 'your-workflow-id',\n});\n```\n\nWhen creating a Worker, you must pass the `taskQueue` option to the `Worker.create()` function.\n\n```ts\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: 'your-task-queue',\n});\n```\n\nOptionally, in Workflow code, when calling an Activity, you can specify the Task Queue by passing the `taskQueue` option to `proxyActivities()`, `startChild()`, or `executeChild()`. If you do not specify a `taskQueue`, then the TypeScript SDK places Activity and Child Workflow Tasks in the same Task Queue as the Workflow Task Queue.\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-activity-timeouts-in-typescript.md","id":"typescript/how-to-set-activity-timeouts-in-typescript","title":"How to set Activity Timeouts in TypeScript","description":"Set Activity Timeouts","label":"Set Activity Timeouts","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nAvailable timeouts are:\n\n- [`scheduleToCloseTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions/#scheduletoclosetimeout)\n- [`startToCloseTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions/#starttoclosetimeout)\n- [`scheduleToStartTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions/#scheduletostarttimeout)\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: '5m',\n  // startToCloseTimeout: \"30s\", // recommended\n  // scheduleToStartTimeout: \"60s\",\n\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-an-activity-retry-policy-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-an-activity-retry-policy-in-typescript.md","id":"typescript/how-to-set-an-activity-retry-policy-in-typescript","title":"How to set an Activity Retry Policy in TypeScript","description":"Set an Activity Retry Policy","label":"Set an Activity Retry Policy","ssdi":[],"markdown_content":"\nTo set Activity Retry Policies in TypeScript, pass [`ActivityOptions.retry`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#retry) to [`proxyActivities`](https://typescript.temporal.io/api/namespaces/workflow/#proxyactivities).\n\n```typescript\n// Sample of typical options you can set\nconst { yourActivity } = proxyActivities<typeof activities>({\n  // ...\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-cluster-address-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-cluster-address-in-typescript.md","id":"typescript/how-to-set-cluster-address-in-typescript","title":"How to set a Cluster address in TypeScript","description":"Set Cluster address","label":"Set Cluster address","tags":["TypeScript","how-to"],"ssdi":[],"markdown_content":"\nUse the [`address`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions/#address) connection option from the [`Client`](https://typescript.temporal.io/api/namespaces/client).\n\n```typescript\nconst connection = await Connection.connect({\n  address: 'foo.bar.tmprl.cloud',\n  // ...\n});\n```\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-mtls-configuration-in-typescript.md","id":"typescript/how-to-set-mtls-configuration-in-typescript","title":"How to set mTLS configuration in TypeScript","description":"To set the mTLS configuration in TypeScript, use the `tls` connection option from the `Client` class to connect to a Temporal Client with mTLS.","label":"Set mTLS configuration","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTo set the mTLS configuration in TypeScript, use the [`tls`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions/#tls) connection option from the [`Client`](https://typescript.temporal.io/api/namespaces/client) class to connect to a Temporal Client with mTLS.\n\n```typescript\nconst connection = await Connection.connect({\n  address: 'foo.bar.tmprl.cloud',\n  tls: {\n    clientCertPair: {\n      crt: clientCertPath,\n      key: clientKeyPath,\n    },\n  },\n});\nconst client = new WorkflowClient({ connection, namespace: 'foo.bar' });\n```\n\n[The Hello World mTLS sample](https://github.com/temporalio/samples-typescript/tree/main/hello-world-mtls/) demonstrates sample code used to connect to a Temporal Cloud account.\nWhen signing up to Temporal Cloud, you should receive a Namespace, a Server address, and a Client certificate and key. Use the following environment variables to set up the sample:\n\n- **TEMPORAL_ADDRESS**: looks like `foo.bar.tmprl.cloud` (NOT web.foo.bar.tmprl.cloud)\n- **TEMPORAL_NAMESPACE**: looks like `foo.bar`\n- **TEMPORAL_CLIENT_CERT_PATH**: `/tls/ca.pem` (file contents start with -----BEGIN CERTIFICATE-----)\n- **TEMPORAL_CLIENT_KEY_PATH**: `/tls/ca.key` (file contents start with -----BEGIN PRIVATE KEY-----)\n\nYou can leave the remaining variables, like `TEMPORAL_SERVER_NAME_OVERRIDE` and `TEMPORAL_SERVER_ROOT_CA_CERT_PATH`, blank.\nIf needed, you can customize `TEMPORAL_TASK_QUEUE`; the following example defaults to `hello-world-mtls`.\n\n```typescript\nexport function getEnv(): Env {\n  return {\n    // NOT web.foo.bar.tmprl.cloud\n    address: 'web.<Namespace_ID>.tmprl.cloud',\n    // as assigned\n    namespace: 'your.namespace',\n    // in project root\n    clientCertPath: 'foobar.pem',\n    clientKeyPath: 'foobar.key',\n    // just to ensure task queue is same on client and worker, totally optional\n    taskQueue: process.env.TEMPORAL_TASK_QUEUE || 'hello-world-mtls',\n    // not usually needed:\n    // serverNameOverride: process.env.TEMPORAL_SERVER_NAME_OVERRIDE,\n    // serverRootCACertificatePath: process.env.TEMPORAL_SERVER_ROOT_CA_CERT_PATH,\n  };\n}\n```\n\nIf you are using mTLS, it is completely up to you how to get the `clientCert` and `clientKey` pair into your code, whether it is reading from file system, secrets manager, or both. Just keep in mind that they are whitespace sensitive, and some environment variable systems have been known to cause frustration because they modify whitespace.\n\nThe following code example works for local development and for certifications hosted in an Amazon S3 bucket.\n\n```typescript\nlet serverRootCACertificate: Buffer | undefined;\nlet clientCertificate: Buffer | undefined;\nlet clientKey: Buffer | undefined;\nif (certificateS3Bucket) {\n  const s3 = new S3client({ region: certificateS3BucketRegion });\n  serverRootCACertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: serverRootCACertificatePath,\n  });\n  clientCertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientCertPath,\n  });\n  clientKey = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientKeyPath,\n  });\n} else {\n  serverRootCACertificate = fs.readFileSync(serverRootCACertificatePath);\n  clientCertificate = fs.readFileSync(clientCertPath);\n  clientKey = fs.readFileSync(clientKeyPath);\n}\n```\n","is_empty":false},{"file_name":"how-to-set-search-attributes-from-the-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-search-attributes-from-the-client-in-typescript.md","id":"typescript/how-to-set-search-attributes-from-the-client-in-typescript","title":"How to set Search Attributes from the Client in TypeScript","description":"Use Search Attributes from the Client","label":"Use Search Attributes from the Client","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nWe can set [`WorkflowOptions.searchAttributes`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions#searchattributes) during `client.start()` or `client.execute()` and read with [`handle.describe()`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#describe):\n\n<!--SNIPSTART typescript-search-attributes-client -->\n\n[search-attributes/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/search-attributes/src/client.ts)\n\n```ts\nconst handle = await client.workflow.start(example, {\n  taskQueue: 'search-attributes',\n  workflowId: 'search-attributes-example-0',\n  searchAttributes: {\n    CustomIntField: [2],\n    CustomKeywordField: ['keywordA', 'keywordB'],\n    CustomBoolField: [true],\n    CustomDatetimeField: [new Date()],\n    CustomStringField: [\n      'String field is for text. When queried, it will be tokenized for partial match. StringTypeField cannot be used in Order By',\n    ],\n  },\n});\n\nconst { searchAttributes } = await handle.describe();\n```\n\n<!--SNIPEND-->\n\nThe type of `searchAttributes` is `Record<string, string[] | number[] | boolean[] | Date[]>`.\n","is_empty":false},{"file_name":"how-to-set-search-attributes-in-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-search-attributes-in-a-workflow-in-typescript.md","id":"typescript/how-to-set-search-attributes-in-a-workflow-in-typescript","title":"How to set Search Attributes in a Workflow in TypeScript","description":"Use Search Attributes in a Workflow","label":"Use Search Attributes in a Workflow","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nInside a Workflow, we can read from [`WorkflowInfo.searchAttributes`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo#searchattributes) and call [`upsertSearchAttributes`](https://typescript.temporal.io/api/namespaces/workflow#upsertsearchattributes):\n\n<!--SNIPSTART typescript-search-attributes-workflow -->\n\n[search-attributes/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/search-attributes/src/workflows.ts)\n\n```ts\nexport async function example(): Promise<SearchAttributes> {\n  const customInt =\n    (workflowInfo().searchAttributes.CustomIntField?.[0] as number) || 0;\n  upsertSearchAttributes({\n    // overwrite the existing CustomIntField: [2]\n    CustomIntField: [customInt + 1],\n\n    // delete the existing CustomBoolField: [true]\n    CustomBoolField: [],\n\n    // add a new value\n    CustomDoubleField: [3.14],\n  });\n  return workflowInfo().searchAttributes;\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-set-the-default-logger-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-the-default-logger-in-typescript.md","id":"typescript/how-to-set-the-default-logger-in-typescript","title":"How to set the default logger in TypeScript","description":"Set the default logger","label":"Set the default logger","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nSet the [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.DefaultLogger) to one of the following log levels: `'TRACE'` | `'DEBUG'` | `'INFO'` | `'WARN'` | `'ERROR'`.\n\nThe following is an example of setting the `DefaultLogger` to `'Debug'`.\n\n```typescript\nRuntime.install({\n  logger: new DefaultLogger('DEBUG'),\n  telemetryOptions: {\n    tracingFilter: 'temporal_sdk_core=DEBUG',\n    logging: { forward: { level: 'DEBUG' } },\n  },\n});\n```\n\nThe following code sets the `DefaultLogger` to `'Debug'` and creates a Worker that can execute Activities or Workflows.\n\n```typescript\nimport { DefaultLogger, Runtime, Worker } from '@temporalio/worker';\nimport * as activities from './activities';\nasync function main() {\n  const argv = arg({\n    '--debug': Boolean,\n  });\n  /* Setting the log level to DEBUG. */\n  if (argv['--debug']) {\n    Runtime.install({\n      logger: new DefaultLogger('DEBUG'),\n      telemetryOptions: {\n        tracingFilter: 'temporal_sdk_core=DEBUG',\n        logging: { forward: { level: 'DEBUG' } },\n      },\n    });\n  }\n  const worker = await Worker.create({\n    activities,\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'test',\n  });\n  await worker.run();\n  console.log('Worker gracefully shutdown');\n}\n```\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-the-namespace-for-a-temporal-client-in-typescript.md","id":"typescript/how-to-set-the-namespace-for-a-temporal-client-in-typescript","title":"How to set a Namespace for a Temporal Client in TypeScript","description":"Set the Namespace in Workflow Client Options Builder.","label":"Set Namespace","tags":["how-to","typescript"],"ssdi":[],"markdown_content":"\nSet the [`namespace`](https://typescript.temporal.io/api/namespaces/client/) field on the options object.\n\n```ts\nconst connection = await Connection.connect();\n// https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'your-custom-namespace',\n});\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-timers-in-typescript.md","id":"typescript/how-to-set-timers-in-typescript","title":"How to set Timers in TypeScript","description":"To set a Timer in TypeScript, use the `sleep()` function.","label":"Timers","tags":["timers","sleep"],"ssdi":[],"markdown_content":"\nTo set a Timer in TypeScript, use the [`sleep()`](https://typescript.temporal.io/api/namespaces/workflow/#sleep) function and pass how long you want to wait before continuing (using an [ms-formatted string](https://www.npmjs.com/package/ms) or number of milliseconds).\n\n```typescript\nimport { sleep } from '@temporalio/workflow';\n\nexport async function sleepWorkflow(): Promise<void> {\n  await sleep('2 months');\n  console.log('done sleeping');\n}\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-retry-options-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-workflow-retry-options-in-typescript.md","id":"typescript/how-to-set-workflow-retry-options-in-typescript","title":"How to set Workflow Retry Options in TypeScript","description":"Set Workflow Retry Options","label":"Set Workflow Retry Options","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nCreate an instance of the Retry Policy, known as [`retry`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#retry) in TypeScript, from the [`WorkflowOptions`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions) of the Client interface.\n\n<!--SNIPSTART typescript-retry-workflow -->\n\n[snippets/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/client.ts)\n\n```ts\nconst handle = await client.workflow.start(example, {\n  taskQueue,\n  workflowId,\n  retry: {\n    maximumAttempts: 3,\n  },\n});\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-set-workflow-timeouts-in-typescript.md","id":"typescript/how-to-set-workflow-timeouts-in-typescript","title":"How to set Workflow Timeouts in TypeScript","description":"Set Workflow Timeouts","label":"Set Workflow Timeouts","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nCreate an instance of `WorkflowOptions` from the Client and set your Workflow Timeout.\n\nAvailable timeouts are:\n\n- [`workflowExecutionTimeout​`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#workflowexecutiontimeout)\n- [`workflowRunTimeout`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#workflowruntimeout)\n- [`workflowTaskTimeout`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#workflowtasktimeout)\n\n<!--SNIPSTART typescript-execution-timeout -->\n\n[snippets/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/client.ts)\n\n```ts\nawait client.workflow.start(example, {\n  taskQueue,\n  workflowId,\n  workflowExecutionTimeout: '1 day',\n});\n```\n\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-run-timeout -->\n\n[snippets/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/client.ts)\n\n```ts\nawait client.workflow.start(example, {\n  taskQueue,\n  workflowId,\n  workflowRunTimeout: '1 minute',\n});\n```\n\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-task-timeout -->\n\n[snippets/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/client.ts)\n\n```ts\nawait client.workflow.start(example, {\n  taskQueue,\n  workflowId,\n  workflowTaskTimeout: '1 minute',\n});\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-shut-down-a-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-shut-down-a-worker.md","id":"typescript/how-to-shut-down-a-worker","title":"How to shut down a Worker and track its state","description":"To shut down a Worker, send a shutdown Signal to the Worker or call `Worker.shutdown()`.","label":"Shut down a worker","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkers shut down if they receive any of the Signals enumerated in [shutdownSignals](https://typescript.temporal.io/api/interfaces/worker.RuntimeOptions#shutdownsignals): `'SIGINT'`, `'SIGTERM'`, `'SIGQUIT'`, and `'SIGUSR2'`.\n\nIn development, we shut down Workers with `Ctrl+C` (`SIGINT`) or [nodemon](https://github.com/temporalio/samples-typescript/blob/c37bae3ea235d1b6956fcbe805478aa46af973ce/hello-world/package.json#L10) (`SIGUSR2`). In production, you usually want to give Workers time to finish any in-progress Activities by setting [shutdownGraceTime](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#shutdowngracetime).\n\nAs soon as a Worker receives a shutdown Signal or request, the Worker stops polling for new Tasks and allows in-flight Tasks to complete until `shutdownGraceTime` is reached.\nAny Activities that are still running at that time will stop running and will be rescheduled by Temporal Server when an Activity timeout occurs.\n\nIf you must guarantee that the Worker eventually shuts down, you can set [shutdownForceTime](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#shutdownforcetime).\n\nYou might want to programmatically shut down Workers (with [Worker.shutdown()](https://typescript.temporal.io/api/classes/worker.Worker#shutdown)) in integration tests or when automating a fleet of Workers.\n\n### Worker states\n\nAt any time, you can Query Worker state with [Worker.getState()](https://typescript.temporal.io/api/classes/worker.Worker#getstate).\nA Worker is always in one of seven states:\n\n- `INITIALIZED`: The initial state of the Worker after calling [Worker.create()](https://typescript.temporal.io/api/classes/worker.Worker#create) and successfully connecting to the server.\n- `RUNNING`: [Worker.run()](https://typescript.temporal.io/api/classes/worker.Worker#run) was called and the Worker is polling Task Queues.\n- `FAILED`: The Worker encountered an unrecoverable error; `Worker.run()` should reject with the error.\n- The last four states are related to the Worker shutdown process:\n  - `STOPPING`: The Worker received a shutdown Signal or `Worker.shutdown()` was called.\n    The Worker will forcefully shut down after `shutdownGraceTime` expires.\n  - `DRAINING`: All Workflow Tasks have been drained; waiting for Activities and cached Workflows eviction.\n  - `DRAINED`: All Activities and Workflows have completed; ready to shut down.\n  - `STOPPED`: Shutdown complete; `worker.run()` resolves.\n\nIf you need more visibility into internal Worker state, see the [Worker class](https://typescript.temporal.io/api/classes/worker.Worker) in the API reference.\n","is_empty":false},{"file_name":"how-to-skip-time-set-up-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-skip-time-set-up-in-typescript.md","id":"typescript/how-to-skip-time-set-up-in-typescript","title":"How to set up time skipping in TypeScript","description":"To set up time skipping, use `TestWorkflowEnvironment.createTimeSkipping`.","label":"Set up time skipping","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n```bash\nnpm install @temporalio/testing\n```\n\nThe `@temporalio/testing` package downloads the test server and exports [`TestWorkflowEnvironment`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment), which you use to connect the Client and Worker to the test server and interact with the test server.\n\n[`TestWorkflowEnvironment.createTimeSkipping`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#createtimeskipping) starts the test server.\nA typical test suite should set up a single instance of the test environment to be reused in all tests (for example, in a [Jest](https://jestjs.io/) `beforeAll` hook or a [Mocha](https://mochajs.org/) `before()` hook).\n\n```typescript\nimport { TestWorkflowEnvironment } from '@temporalio/testing';\n\nlet testEnv: TestWorkflowEnvironment;\n\n// beforeAll and afterAll are injected by Jest\nbeforeAll(async () => {\n  testEnv = await TestWorkflowEnvironment.createTimeSkipping();\n});\n\nafterAll(async () => {\n  await testEnv?.teardown();\n});\n```\n\n`TestWorkflowEnvironment` has a [`client.workflow`](https://typescript.temporal.io/api/classes/testing.testworkflowenvironment/#workflowclient) and [`nativeConnection`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#nativeconnection) for creating Workers:\n\n```typescript\nimport { Worker } from '@temporalio/worker';\nimport { v4 as uuid4 } from 'uuid';\nimport { workflowFoo } from './workflows';\n\ntest('workflowFoo', async () => {\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    ...\n  });\n  const result = await worker.runUntil(\n    testEnv.client.workflow.execute(workflowFoo, {\n      workflowId: uuid4(),\n      taskQueue: 'test',\n    })\n  );\n  expect(result).toEqual('foo');\n});\n```\n\nThis test uses the test connection to create a Worker, runs the Worker until the Workflow is complete, and then makes an assertion about the Workflow’s result.\nThe Workflow is executed using `testEnv.workflowClient`, which is connected to the test server.\n","is_empty":false},{"file_name":"how-to-skip-time-skip-activities-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-skip-time-skip-activities-in-typescript.md","id":"typescript/how-to-skip-time-skip-activities-in-typescript","title":"How to skip time in Activities in TypeScript","description":"To skip time in an Activity, call `TestWorkflowEnvironment.sleep` from the mock Activity.","label":"Skip time in Activities","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nCall [`TestWorkflowEnvironment.sleep`](https://typescript.temporal.io/api/classes/testing.testworkflowenvironment/#sleep) from the mock Activity.\n\nIn the following test, `processOrderWorkflow` sends a notification to the user after one day.\nThe `processOrder` mocked Activity calls `testEnv.sleep(‘2 days’)`, during which the Workflow sends email (by calling the `sendNotificationEmail` Activity).\n\nThen, after the Workflow completes, we assert that `sendNotificationEmail` was called.\n\n<details>\n<summary>\nWorkflow implementation\n</summary>\n\n<!--SNIPSTART typescript-timer-reminder-workflow-->\n\n[timer-examples/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/timer-examples/src/workflows.ts)\n\n```ts\nexport async function processOrderWorkflow({\n  orderProcessingMS,\n  sendDelayedEmailTimeoutMS,\n}: ProcessOrderOptions): Promise<string> {\n  let processing = true;\n  // Dynamically define the timeout based on given input\n  const { processOrder } = proxyActivities<ReturnType<typeof createActivities>>(\n    {\n      startToCloseTimeout: orderProcessingMS,\n    },\n  );\n\n  const processOrderPromise = processOrder().then(() => {\n    processing = false;\n  });\n\n  await Promise.race([processOrderPromise, sleep(sendDelayedEmailTimeoutMS)]);\n\n  if (processing) {\n    await sendNotificationEmail();\n\n    await processOrderPromise;\n  }\n\n  return 'Order completed!';\n}\n```\n\n<!--SNIPEND-->\n\n</details>\n\n<!--SNIPSTART typescript-timer-reminder-test-->\n\n[timer-examples/src/test/workflows.test.ts](https://github.com/temporalio/samples-typescript/blob/master/timer-examples/src/test/workflows.test.ts)\n\n```ts\nit('sends reminder email if processOrder does not complete in time', async () => {\n  // This test doesn't actually take days to complete: the TestWorkflowEnvironment starts the\n  // Test Server, which automatically skips time when there are no running Activities.\n  let emailSent = false;\n  const mockActivities: ReturnType<typeof createActivities> = {\n    async processOrder() {\n      // Test server switches to \"normal\" time while an Activity is executing.\n      // Call `env.sleep` to skip ahead 2 days, by which time sendNotificationEmail\n      // should have been called.\n      await env.sleep('2 days');\n    },\n    async sendNotificationEmail() {\n      emailSent = true;\n    },\n  };\n  const worker = await Worker.create({\n    connection: env.nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('../workflows'),\n    activities: mockActivities,\n  });\n  await worker.runUntil(\n    env.client.workflow.execute(processOrderWorkflow, {\n      workflowId: uuid(),\n      taskQueue: 'test',\n      args: [{\n        orderProcessingMS: ms('3 days'),\n        sendDelayedEmailTimeoutMS: ms('1 day'),\n      }],\n    }),\n  );\n  assert.ok(emailSent);\n});\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-skip-time-skip-automatically-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-skip-time-skip-automatically-in-typescript.md","id":"typescript/how-to-skip-time-skip-automatically-in-typescript","title":"How to skip time automatically in TypeScript","description":"Use `TestWorkflowEnvironment.workflowClient.execute()` or `.result()` to switch the test server to \"skipped\" time mode until the Workflow completes.","label":"Skip time automatically","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nThe test server starts in \"normal\" time.\nWhen you use `TestWorkflowEnvironment.workflowClient.execute()` or `.result()`, the test server switches to \"skipped\" time mode until the Workflow completes.\nIn \"skipped\" mode, timers (`sleep()` calls and `condition()` timeouts) are fast-forwarded except when Activities are running.\n\n`workflows.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\n\nexport async function sleeperWorkflow() {\n  await sleep('1 day');\n}\n```\n\n`test.ts`\n\n```ts\nimport { sleeperWorkflow } from './workflows';\n\ntest('sleep completes almost immediately', async () => {\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('./workflows'),\n  });\n  // Does not wait an entire day\n  await worker.runUntil(\n    testEnv.workflowClient.execute(sleeperWorkflow, {\n      workflowId: uuid(),\n      taskQueue: 'test',\n    }),\n  );\n});\n```\n","is_empty":false},{"file_name":"how-to-skip-time-skip-manually-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-skip-time-skip-manually-in-typescript.md","id":"typescript/how-to-skip-time-skip-manually-in-typescript","title":"How to skip time manually in TypeScript","description":"Call `testEnv.sleep()` from your test code to advance the test server's time.","label":"Skip time manually","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nYou can call `testEnv.sleep()` from your test code to advance the test server's time.\nThis is useful for testing intermediate states or indefinitely long-running Workflows.\nHowever, to use `testEnv.sleep()`, you need to avoid automatic time skipping by starting the Workflow with `.start()` instead of `.execute()` (and not calling `.result()`).\n\n`workflow.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\nimport { defineQuery, setHandler } from '@temporalio/workflow';\n\nexport const daysQuery = defineQuery('days');\n\nexport async function sleeperWorkflow() {\n  let numDays = 0;\n\n  setHandler(daysQuery, () => numDays);\n\n  for (let i = 0; i < 100; i++) {\n    await sleep('1 day');\n    numDays++;\n  }\n}\n```\n\n`test.ts`\n\n```ts\ntest('sleeperWorkflow counts days correctly', async () => {\n  // `start()` starts the test server in \"normal\" mode, not skipped time mode.\n  // If you don't advance time using `testEnv.sleep()`, then `sleeperWorkflow()`\n  // will run for days.\n  handle = await testEnv.workflowClient.start(sleeperWorkflow, {\n    workflowId: uuid4(),\n    taskQueue,\n  });\n\n  let numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 0);\n\n  // Advance the test server's time by 25 hours\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 1);\n\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 2);\n});\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-spawn-a-child-workflow-execution-in-typescript.md","id":"typescript/how-to-spawn-a-child-workflow-execution-in-typescript","title":"How to spawn a Child Workflow Execution in Typescript","label":"Child Workflow Execution","tags":["developer-guide","typescript"],"ssdi":[],"markdown_content":"\nTo start a Child Workflow Execution and return a [handle](https://typescript.temporal.io/api/interfaces/workflow.ChildWorkflowHandle/) to it, use [startChild](https://typescript.temporal.io/api/namespaces/workflow/#startchild).\n\n```ts\nimport { startChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(names: string[]) {\n  const childHandle = await startChild(childWorkflow, {\n    args: [name],\n    // workflowId, // add business-meaningful workflow id here\n    // // regular workflow options apply here, with two additions (defaults shown):\n    // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n    // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n  });\n  // you can use childHandle to signal or get result here\n  await childHandle.signal('anySignal');\n  const result = childHandle.result();\n  // you can use childHandle to signal, query, cancel, terminate, or get result here\n}\n```\n\nTo start a Child Workflow Execution and await its completion, use [executeChild](https://typescript.temporal.io/api/namespaces/workflow/#executechild).\n\nBy default, a child is scheduled on the same Task Queue as the parent.\n\n<!--SNIPSTART typescript-child-workflow -->\n\n[child-workflows/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/child-workflows/src/workflows.ts)\n\n```ts\nimport { executeChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(...names: string[]): Promise<string> {\n  const responseArray = await Promise.all(\n    names.map((name) =>\n      executeChild(childWorkflow, {\n        args: [name],\n        // workflowId, // add business-meaningful workflow id here\n        // // regular workflow options apply here, with two additions (defaults shown):\n        // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n        // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n      })\n    ),\n  );\n  return responseArray.join('\\n');\n}\n```\n\n<!--SNIPEND-->\n\nTo control any running Workflow from inside a Workflow, use [getExternalWorkflowHandle(workflowId)](https://typescript.temporal.io/api/namespaces/workflow/#getexternalworkflowhandle).\n\n```ts\nimport { getExternalWorkflowHandle, workflowInfo } from '@temporalio/workflow';\n\nexport async function terminateWorkflow() {\n  const { workflowId } = workflowInfo(); // no await needed\n  const handle = getExternalWorkflowHandle(workflowId); // sync function, not async\n  await handle.cancel();\n}\n```\n\nIf the Child Workflow options aren't explicitly set, they inherit their values from the Parent Workflow options.\nTwo advanced options are unique to Child Workflows:\n\n- [cancellationType](https://typescript.temporal.io/api/enums/proto.coresdk.child_workflow.ChildWorkflowCancellationType): Controls when to throw the `CanceledFailure` exception when a Child Workflow is canceled.\n- `parentClosePolicy`: Explained in the next section.\n\nIf you need to cancel a Child Workflow Execution, use [cancellation scopes](/dev-guide/typescript/foundations#cancellation-scopes).\nA Child Workflow Execution is automatically cancelled when its containing scope is cancelled.\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-spawn-a-workflow-execution-in-typescript.md","id":"typescript/how-to-spawn-a-workflow-execution-in-typescript","title":"How to spawn a Workflow Execution in TypeScript","description":"Spawn a Workflow Execution","label":"Spawn a Workflow Execution","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nWhen you have a Workflow Client, you can schedule the start of a Workflow with `client.start()`, specifying `workflowId`, `taskQueue`, and `args` and returning a Workflow handle immediately after the Server acknowledges the receipt.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: 'your-workflow-id',\n  taskQueue: 'your-task-queue',\n  args: ['argument01', 'argument02', 'argument03'], // this is typechecked against workflowFn's args\n});\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nCalling `client.start()` and `client.execute()` send a command to Temporal Server to schedule a new Workflow Execution on the specified Task Queue. It does not actually start until a Worker that has a matching Workflow Type, polling that Task Queue, picks it up.\n\nYou can test this by executing a Workflow Client command without a matching Worker. Temporal Server records the command in Event History, but does not make progress with the Workflow Execution until a Worker starts polling with a matching Task Queue and Workflow Definition.\n\nWorkflow Execution run in a separate V8 isolate context in order to provide a [deterministic runtime](/concepts/what-is-a-workflow-definition#deterministic-constraints).\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-spawn-an-activity-execution-in-typescript.md","id":"typescript/how-to-spawn-an-activity-execution-in-typescript","title":"How to spawn an Activity Execution in TypeScript","description":"Spawn an Activity Execution","label":"Spawn an Activity Execution","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTo spawn an Activity Execution, you must retrieve the _Activity handle_ in your Workflow.\n\n```typescript\nimport { proxyActivities } from '@temporalio/workflow';\n// Only import the activity types\nimport type * as activities from './activities';\n\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\n// A workflow that calls an activity\nexport async function example(name: string): Promise<string> {\n  return await greet(name);\n}\n```\n\nThis imports the individual Activities and declares the type alias for each Activity.\n","is_empty":false},{"file_name":"how-to-strucutre-a-project-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-strucutre-a-project-in-typescript.md","id":"typescript/how-to-structure-a-project-in-typescript","title":"How to structure a project in TypeScript","description":"Structure a project","label":"Structure a project","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nA typical Temporal project written in TypeScript consists of the following components:\n\n```\nproject-root/\n  activities/\n      activity.ts\n  workflows/\n      workerflow.ts\n  workers/\n      worker.ts\n  starter-script.ts\n```\n\nActivities cannot be in the same file as Workflows and must be separately registered.\nActivities may be retried, so you may need to use [idempotency keys](https://stripe.com/blog/idempotency) for critical side effects.\n","is_empty":false},{"file_name":"how-to-test-cancel-an-activity-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-test-cancel-an-activity-in-typescript.md","id":"typescript/how-to-test-cancel-an-activity-in-typescript","title":"How to test whether an Activity reacts to a Cancellation in TypeScript","description":"Call `MockActivityEnvironment.cancel()` to cancel an Activity Context.","label":"Configure tracing","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n[`MockActivityEnvironment`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment) exposes a [`.cancel()`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment#cancel) method that cancels the Activity Context.\n\n```ts\nimport { CancelledFailure, Context } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport assert from 'assert';\n\nasync function activityFoo(): Promise<void> {\n  Context.current().heartbeat(6);\n  // .sleep() is Cancellation-aware, which means that on Cancellation,\n  // CancelledFailure will be thrown from it.\n  await Context.current().sleep(100);\n}\n\nconst env = new MockActivityEnvironment();\n\nenv.on('heartbeat', (d: unknown) => {\n  assert(d === 6);\n});\n\nawait assert.rejects(env.run(activityFoo), (err) => {\n  assert.ok(err instanceof CancelledFailure);\n});\n```\n","is_empty":false},{"file_name":"how-to-test-functions-in-workflow-context-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-test-functions-in-workflow-context-in-typescript.md","id":"typescript/how-to-test-functions-in-workflow-context-in-typescript","title":"How to test functions in the Workflow context in TypeScript","description":"To test a function in your Workflow code that isn’t a Workflow, put the file it’s exported from in `WorkerOptions.workflowsPath`.","label":"Test functions in Workflow context","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTo test a function in your Workflow code that isn’t a Workflow, put the file it’s exported from in [WorkerOptions.workflowsPath](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#workflowspath).\nThen execute the function as if it were a Workflow:\n\n`workflows/file-with-workflow-function-to-test.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\n\nexport async function functionToTest(): Promise<number> {\n  await sleep('1 day');\n  return 42;\n}\n```\n\n`test.ts`\n\n```ts\nconst worker = await Worker.create({\n  connection: testEnv.nativeConnection,\n  workflowsPath: require.resolve(\n    './workflows/file-with-workflow-function-to-test',\n  ),\n});\n\nconst result = await worker.runUntil(\n  testEnv.workflowClient.execute(functionToTest, workflowOptions),\n);\n\nassert.equal(result, 42);\n```\n\nIf `functionToTest` starts a Child Workflow, that Workflow must be exported from the same file (so that the Worker knows about it):\n\n```ts\nimport { sleep } from '@temporalio/workflow';\nimport { someWorkflowToRunAsChild } from './some-workflow';\n\nexport { someWorkflowToRunAsChild };\n\nexport async function functionToTest(): Promise<number> {\n  const result = await wf.executeChild(someWorkflowToRunAsChild);\n  return result + 42;\n}\n```\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript.md","id":"typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript","title":"How to upsert custom Search Attributes to Workflow during Execution in TypeScript","label":"How to upsert custom Search Attributes to Workflow during Execution","tags":["developer-guide","typescript"],"ssdi":[],"markdown_content":"\nInside a Workflow, we can read from [`WorkflowInfo.searchAttributes`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo#searchattributes) and call [`upsertSearchAttributes`](https://typescript.temporal.io/api/namespaces/workflow#upsertsearchattributes):\n\n<!--SNIPSTART typescript-search-attributes-workflow -->\n\n[search-attributes/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/search-attributes/src/workflows.ts)\n\n```ts\nexport async function example(): Promise<SearchAttributes> {\n  const customInt =\n    (workflowInfo().searchAttributes.CustomIntField?.[0] as number) || 0;\n  upsertSearchAttributes({\n    // overwrite the existing CustomIntField: [2]\n    CustomIntField: [customInt + 1],\n\n    // delete the existing CustomBoolField: [true]\n    CustomBoolField: [],\n\n    // add a new value\n    CustomDoubleField: [3.14],\n  });\n  return workflowInfo().searchAttributes;\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-use-a-custom-payload-converter-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-use-a-custom-payload-converter-in-typescript.md","id":"typescript/how-to-use-a-custom-payload-converter-in-typescript","title":"How to use a custom payload converter in TypeScript","description":"Create your custom `PayloadConverter` and set it on a `DataConverter` in your Client options.","label":"Custom payload conversion","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal SDKs provide a [Payload Converter](/concepts/what-is-a-payload-converter) that can be customized to convert a custom data type to a [Payload](/concepts/what-is-a-payload) and back.\n\nImplementing custom Payload conversion is optional.\nIt is needed only if the [default Data Converter](/concepts/what-is-a-default-data-converter) does not support your custom values.\n\nTo support custom Payload conversion, create a [custom Payload Converter](/concepts/what-is-a-payload-converter#custom-payload-conversion) and configure the Data Converter to use it in your Client options.\n\nThe order in which your encoding Payload Converters are applied depend on the order given to the Data Converter.\nYou can set multiple encoding Payload Converters to run your conversions.\nWhen the Data Converter receives a value for conversion, it passes through each Payload Converter in sequence until the converter that handles the data type does the conversion.\n\nTo send values that are not [JSON-serializable](https://en.wikipedia.org/wiki/JSON#Data_types) like a `BigInt` or `Date`, provide a custom [Data Converter](https://typescript.temporal.io/api/interfaces/worker.DataConverter/) to the Client and Worker:\n\n- [new WorkflowClient({ ..., dataConverter })](https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions#dataconverter)\n- [Worker.create({ ..., dataConverter })](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#dataconverter)\n\nA Data Converter has two parts:\n\n- [Payload Converter](#payload-converter): Sync methods that sometimes run inside the Workflow isolate (and are thus limited).\n- [Payload Codec](#payload-codec): Async methods that run outside the isolate.\n\n```ts\ninterface DataConverter {\n  payloadConverterPath?: string;\n  payloadCodecs?: PayloadCodec[];\n}\n```\n\n### Payload Converter\n\n> API documentation: [PayloadConverter](https://typescript.temporal.io/api/interfaces/common.PayloadConverter)\n\n```ts\ninterface PayloadConverter {\n  /**\n   * Converts a value to a {@link Payload}.\n   * @param value The value to convert. Example values include the Workflow args sent by the client and the values returned by a Workflow or Activity.\n   */\n  toPayload<T>(value: T): Payload;\n\n  /**\n   * Converts a {@link Payload} back to a value.\n   */\n  fromPayload<T>(payload: Payload): T;\n}\n```\n\n#### Custom implementation\n\nSome example implementations are in the SDK itself:\n\n- [common/src/converter/payload-converters.ts](https://github.com/temporalio/sdk-typescript/blob/main/packages/common/src/converter/payload-converters.ts)\n- [common/src/converter/protobuf-payload-converters.ts](https://github.com/temporalio/sdk-typescript/blob/main/packages/common/src/converter/protobuf-payload-converters.ts)\n\nThe sample project [samples-typescript/ejson](https://github.com/temporalio/samples-typescript/tree/main/ejson) creates an EJSON custom `PayloadConverter`.\nIt implements `PayloadConverterWithEncoding` instead of `PayloadConverter` so that it could be used with [CompositePayloadConverter](https://typescript.temporal.io/api/classes/common.CompositePayloadConverter/):\n\n<!--SNIPSTART typescript-ejson-converter-impl -->\n\n[ejson/src/ejson-payload-converter.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/ejson-payload-converter.ts)\n\n```ts\nimport {\n  EncodingType,\n  METADATA_ENCODING_KEY,\n  Payload,\n  PayloadConverterError,\n  PayloadConverterWithEncoding,\n} from '@temporalio/common';\nimport { decode, encode } from '@temporalio/common/lib/encoding';\nimport EJSON from 'ejson';\n\n/**\n * Converts between values and [EJSON](https://docs.meteor.com/api/ejson.html) Payloads.\n */\nexport class EjsonPayloadConverter implements PayloadConverterWithEncoding {\n  // Use 'json/plain' so that Payloads are displayed in the UI\n  public encodingType = 'json/plain' as EncodingType;\n\n  public toPayload(value: unknown): Payload | undefined {\n    if (value === undefined) return undefined;\n    let ejson;\n    try {\n      ejson = EJSON.stringify(value);\n    } catch (e) {\n      throw new UnsupportedEjsonTypeError(\n        `Can't run EJSON.stringify on this value: ${value}. Either convert it (or its properties) to EJSON-serializable values (see https://docs.meteor.com/api/ejson.html ), or create a custom data converter. EJSON.stringify error message: ${\n          errorMessage(\n            e,\n          )\n        }`,\n        e as Error,\n      );\n    }\n\n    return {\n      metadata: {\n        [METADATA_ENCODING_KEY]: encode('json/plain'),\n        // Include an additional metadata field to indicate that this is an EJSON payload\n        format: encode('extended'),\n      },\n      data: encode(ejson),\n    };\n  }\n\n  public fromPayload<T>(content: Payload): T {\n    return content.data ? EJSON.parse(decode(content.data)) : content.data;\n  }\n}\n\nexport class UnsupportedEjsonTypeError extends PayloadConverterError {\n  public readonly name: string = 'UnsupportedJsonTypeError';\n\n  constructor(message: string | undefined, public readonly cause?: Error) {\n    super(message ?? undefined);\n  }\n}\n```\n\n<!--SNIPEND-->\n\nThen we instantiate one and export it:\n\n<!--SNIPSTART typescript-ejson-converter -->\n\n[ejson/src/payload-converter.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/payload-converter.ts)\n\n```ts\nimport {\n  CompositePayloadConverter,\n  UndefinedPayloadConverter,\n} from '@temporalio/common';\nimport { EjsonPayloadConverter } from './ejson-payload-converter';\n\nexport const payloadConverter = new CompositePayloadConverter(\n  new UndefinedPayloadConverter(),\n  new EjsonPayloadConverter(),\n);\n```\n\n<!--SNIPEND-->\n\nWe provide it to the Worker and Client:\n\n<!--SNIPSTART typescript-ejson-worker -->\n\n[ejson/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/worker.ts)\n\n```ts\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  taskQueue: 'ejson',\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-ejson-client-setup -->\n\n[ejson/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/client.ts)\n\n```ts\nconst client = new Client({\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n\n<!--SNIPEND-->\n\nThen we can use supported data types in arguments:\n\n<!--SNIPSTART typescript-ejson-client -->\n\n[ejson/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/client.ts)\n\n```ts\nconst user: User = {\n  id: uuid(),\n  // age: 1000n, BigInt isn't supported\n  hp: Infinity,\n  matcher: /.*Stormblessed/,\n  token: Uint8Array.from([1, 2, 3]),\n  createdAt: new Date(),\n};\n\nconst handle = await client.workflow.start(example, {\n  args: [user],\n  taskQueue: 'ejson',\n  workflowId: `example-user-${user.id}`,\n});\n```\n\n<!--SNIPEND-->\n\nAnd they get parsed correctly for the Workflow:\n\n<!--SNIPSTART typescript-ejson-workflow -->\n\n[ejson/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/ejson/src/workflows.ts)\n\n```ts\nimport type { Result, User } from './types';\n\nexport async function example(user: User): Promise<Result> {\n  const success = user.createdAt.getTime() < Date.now()\n    && user.hp > 50\n    && user.matcher.test('Kaladin Stormblessed')\n    && user.token instanceof Uint8Array;\n  return { success, at: new Date() };\n}\n```\n\n<!--SNIPEND-->\n\n#### Protobufs\n\nTo serialize values as [Protocol Buffers](https://protobuf.dev/) (protobufs):\n\n- Use [protobufjs](https://protobufjs.github.io/protobuf.js/).\n- Use runtime-loaded messages (not generated classes) and `MessageClass.create` (not `new MessageClass()`).\n- Generate `json-module.js` with a command like the following:\n\n  ```sh\n  pbjs -t json-module -w commonjs -o protos/json-module.js protos/*.proto\n  ```\n\n- Patch `json-module.js`:\n\n  <!--SNIPSTART typescript-protobuf-root -->\n\n[protobufs/protos/root.js](https://github.com/temporalio/samples-typescript/blob/master/protobufs/protos/root.js)\n\n```js\nconst { patchProtobufRoot } = require('@temporalio/common/lib/protobufs');\nconst unpatchedRoot = require('./json-module');\nmodule.exports = patchProtobufRoot(unpatchedRoot);\n```\n\n<!--SNIPEND-->\n\n- Generate `root.d.ts` with the following command:\n\n  ```sh\n  pbjs -t static-module protos/*.proto | pbts -o protos/root.d.ts -\n  ```\n\n- Create a [`DefaultPayloadConverterWithProtobufs`](https://typescript.temporal.io/api/classes/protobufs.DefaultPayloadConverterWithProtobufs/):\n\n  <!--SNIPSTART typescript-protobuf-converter -->\n\n[protobufs/src/payload-converter.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/payload-converter.ts)\n\n```ts\nimport { DefaultPayloadConverterWithProtobufs } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new DefaultPayloadConverterWithProtobufs({\n  protobufRoot: root,\n});\n```\n\n<!--SNIPEND-->\n\nAlternatively, we can use Protobuf Payload Converters directly, or with other converters.\nIf we know that we only use Protobuf objects, and we want them binary encoded (which saves space over proto3 JSON, but can't be viewed in the Web UI), we could do the following:\n\n```ts\nimport { ProtobufBinaryPayloadConverter } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new ProtobufBinaryPayloadConverter(root);\n```\n\nSimilarly, if we wanted binary-encoded Protobufs in addition to the other default types, we could do the following:\n\n```ts\nimport {\n  BinaryPayloadConverter,\n  CompositePayloadConverter,\n  JsonPayloadConverter,\n  UndefinedPayloadConverter,\n} from '@temporalio/common';\nimport { ProtobufBinaryPayloadConverter } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new CompositePayloadConverter(\n  new UndefinedPayloadConverter(),\n  new BinaryPayloadConverter(),\n  new ProtobufBinaryPayloadConverter(root),\n  new JsonPayloadConverter(),\n);\n```\n\n- Provide it to the Worker:\n\n  <!--SNIPSTART typescript-protobuf-worker -->\n\n[protobufs/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/worker.ts)\n\n```ts\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  activities,\n  taskQueue: 'protobufs',\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n\n<!--SNIPEND-->\n\n[WorkerOptions.dataConverter](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#dataconverter)\n\n- Provide it to the Client:\n\n  <!--SNIPSTART typescript-protobuf-client -->\n\n[protobufs/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/client.ts)\n\n```ts\nimport { Client } from '@temporalio/client';\nimport { v4 as uuid } from 'uuid';\nimport { foo, ProtoResult } from '../protos/root';\nimport { example } from './workflows';\n\nasync function run() {\n  const client = new Client({\n    dataConverter: {\n      payloadConverterPath: require.resolve('./payload-converter'),\n    },\n  });\n\n  const handle = await client.workflow.start(example, {\n    args: [foo.bar.ProtoInput.create({ name: 'Proto', age: 2 })],\n    // can't do:\n    // args: [new foo.bar.ProtoInput({ name: 'Proto', age: 2 })],\n    taskQueue: 'protobufs',\n    workflowId: 'my-business-id-' + uuid(),\n  });\n\n  console.log(`Started workflow ${handle.workflowId}`);\n\n  const result: ProtoResult = await handle.result();\n  console.log(result.toJSON());\n}\n```\n\n<!--SNIPEND-->\n\n- Use protobufs in your Workflows and Activities:\n\n  <!--SNIPSTART typescript-protobuf-workflow -->\n\n[protobufs/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/workflows.ts)\n\n```ts\nimport { proxyActivities } from '@temporalio/workflow';\nimport { foo, ProtoResult } from '../protos/root';\nimport type * as activities from './activities';\n\nconst { protoActivity } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\nexport async function example(input: foo.bar.ProtoInput): Promise<ProtoResult> {\n  const result = await protoActivity(input);\n  return result;\n}\n```\n\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-protobuf-activity -->\n\n[protobufs/src/activities.ts](https://github.com/temporalio/samples-typescript/blob/master/protobufs/src/activities.ts)\n\n```ts\nimport { foo, ProtoResult } from '../protos/root';\n\nexport async function protoActivity(\n  input: foo.bar.ProtoInput,\n): Promise<ProtoResult> {\n  return ProtoResult.create({\n    sentence: `${input.name} is ${input.age} years old.`,\n  });\n}\n```\n\n<!--SNIPEND-->\n\n### Payload Codec\n\n> API documentation: [PayloadCodec](https://typescript.temporal.io/api/interfaces/common.PayloadCodec)\n\nThe default `PayloadCodec` does nothing. To create a custom one, we implement the following interface:\n\n```ts\ninterface PayloadCodec {\n  /**\n   * Encode an array of {@link Payload}s for sending over the wire.\n   * @param payloads May have length 0.\n   */\n  encode(payloads: Payload[]): Promise<Payload[]>;\n\n  /**\n   * Decode an array of {@link Payload}s received from the wire.\n   */\n  decode(payloads: Payload[]): Promise<Payload[]>;\n}\n```\n\n#### Encryption\n\n> Background: [Encryption](/dataconversion#encryption)\n\nThe following is an example class that implements the `PayloadCodec` interface:\n\n<!--SNIPSTART typescript-encryption-codec -->\n\n[encryption/src/encryption-codec.ts](https://github.com/temporalio/samples-typescript/blob/master/encryption/src/encryption-codec.ts)\n\n```ts\nimport {\n  METADATA_ENCODING_KEY,\n  Payload,\n  PayloadCodec,\n  ValueError,\n} from '@temporalio/common';\nimport { decode, encode } from '@temporalio/common/lib/encoding';\nimport { temporal } from '@temporalio/proto';\nimport { webcrypto as crypto } from 'node:crypto';\nimport { decrypt, encrypt } from './crypto';\n\nconst ENCODING = 'binary/encrypted';\nconst METADATA_ENCRYPTION_KEY_ID = 'encryption-key-id';\n\nexport class EncryptionCodec implements PayloadCodec {\n  constructor(\n    protected readonly keys: Map<string, crypto.CryptoKey>,\n    protected readonly defaultKeyId: string,\n  ) {}\n\n  static async create(keyId: string): Promise<EncryptionCodec> {\n    const keys = new Map<string, crypto.CryptoKey>();\n    keys.set(keyId, await fetchKey(keyId));\n    return new this(keys, keyId);\n  }\n\n  async encode(payloads: Payload[]): Promise<Payload[]> {\n    return Promise.all(\n      payloads.map(async (payload) => ({\n        metadata: {\n          [METADATA_ENCODING_KEY]: encode(ENCODING),\n          [METADATA_ENCRYPTION_KEY_ID]: encode(this.defaultKeyId),\n        },\n        // Encrypt entire payload, preserving metadata\n        data: await encrypt(\n          temporal.api.common.v1.Payload.encode(payload).finish(),\n          this.keys.get(this.defaultKeyId)!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        ),\n      })),\n    );\n  }\n\n  async decode(payloads: Payload[]): Promise<Payload[]> {\n    return Promise.all(\n      payloads.map(async (payload) => {\n        if (\n          !payload.metadata\n          || decode(payload.metadata[METADATA_ENCODING_KEY]) !== ENCODING\n        ) {\n          return payload;\n        }\n        if (!payload.data) {\n          throw new ValueError('Payload data is missing');\n        }\n\n        const keyIdBytes = payload.metadata[METADATA_ENCRYPTION_KEY_ID];\n        if (!keyIdBytes) {\n          throw new ValueError(\n            'Unable to decrypt Payload without encryption key id',\n          );\n        }\n\n        const keyId = decode(keyIdBytes);\n        let key = this.keys.get(keyId);\n        if (!key) {\n          key = await fetchKey(keyId);\n          this.keys.set(keyId, key);\n        }\n        const decryptedPayloadBytes = await decrypt(payload.data, key);\n        console.log('Decrypting payload.data:', payload.data);\n        return temporal.api.common.v1.Payload.decode(decryptedPayloadBytes);\n      }),\n    );\n  }\n}\n\nasync function fetchKey(_keyId: string): Promise<crypto.CryptoKey> {\n  // In production, fetch key from a key management system (KMS). You may want to memoize requests if you'll be decoding\n  // Payloads that were encrypted using keys other than defaultKeyId.\n  const key = Buffer.from('test-key-test-key-test-key-test!');\n  const cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    key,\n    {\n      name: 'AES-GCM',\n    },\n    true,\n    ['encrypt', 'decrypt'],\n  );\n\n  return cryptoKey;\n}\n```\n\n<!--SNIPEND-->\n\nThe encryption and decryption code is in [src/crypto.ts](https://github.com/temporalio/samples-typescript/tree/main/encryption/src/crypto.ts).\nBecause encryption is CPU intensive, and doing AES with the crypto module built into Node.js blocks the main thread, we use `@ronomon/crypto-async`, which uses the Node.js thread pool.\n\nAs before, we provide a custom Data Converter to the Client and Worker:\n\n<!--SNIPSTART typescript-encryption-client -->\n\n[encryption/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/encryption/src/client.ts)\n\n```ts\nconst client = new Client({\n  dataConverter: await getDataConverter(),\n});\n\nconst handle = await client.workflow.start(example, {\n  args: ['Alice: Private message for Bob.'],\n  taskQueue: 'encryption',\n  workflowId: `my-business-id-${uuid()}`,\n});\n\nconsole.log(`Started workflow ${handle.workflowId}`);\nconsole.log(await handle.result());\n```\n\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-encryption-worker -->\n\n[encryption/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/encryption/src/worker.ts)\n\n```ts\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  taskQueue: 'encryption',\n  dataConverter: await getDataConverter(),\n});\n```\n\n<!--SNIPEND-->\n\nWhen the Client sends `'Alice: Private message for Bob.'` to the Workflow, it gets encrypted on the Client and decrypted in the Worker.\nThe Workflow receives the decrypted message and appends another message.\nWhen it returns that longer string, the string gets encrypted by the Worker and decrypted by the Client.\n\n<!--SNIPSTART typescript-encryption-workflow -->\n\n[encryption/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/encryption/src/workflows.ts)\n\n```ts\nexport async function example(message: string): Promise<string> {\n  return `${message}\\nBob: Hi Alice, I'm Workflow Bob.`;\n}\n```\n\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-use-a-prebuilt-workflow-bundle-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-use-a-prebuilt-workflow-bundle-in-typescript.md","id":"typescript/how-to-use-a-prebuilt-workflow-bundle-in-typescript","title":"How to use a prebuilt Workflow bundle in TypeScript","description":"Pass a prebuilt bundle instead of `workflowsPath`. or use the `bundleWorkflowCode` helper.","label":"Prebuilt workflow bundles","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf you're an advanced user, you can pass a prebuilt bundle instead of `workflowsPath`, or you can use the `bundleWorkflowCode` helper:\n\n```ts\nimport { bundleWorkflowCode, Worker } from '@temporalio/worker';\n\n// Option 1: passing path to prebuilt bundle\nconst worker = await Worker.create({\n  taskQueue,\n  workflowBundle: {\n    codePath: './path-to-bundle.js',\n    sourceMapPath: './path-to-bundle.js.map',\n  },\n});\n\n// Option 2: bundling code using Temporal's bundler settings\nconst workflowBundle = await bundleWorkflowCode({\n  workflowsPath: require.resolve('./path-to-your-workflows'),\n});\nconst worker = await Worker.create({\n  taskQueue,\n  workflowBundle,\n});\n```\n","is_empty":false},{"file_name":"how-to-use-assert-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-use-assert-typescript.md","id":"typescript/how-to-use-assert-typescript","title":"How to assert a Workflow in TypeScript","label":"Assert a Workflow","tags":["developer-guide","typescript"],"ssdi":[],"markdown_content":"\nThe Node.js [`assert`](https://nodejs.org/api/assert.html) module is included in Workflow bundles.\n\nBy default, a failed `assert` statement throws `AssertionError`, which causes a [Workflow Task](/concepts/what-is-a-workflow-task) to fail and be indefinitely retried.\n\nTo prevent this behavior, use [`workflowInterceptorModules`](https://typescript.temporal.io/api/namespaces/testing/#workflowinterceptormodules) from `@temporalio/testing`.\nThese interceptors catch an `AssertionError` and turn it into an `ApplicationFailure` that fails the entire Workflow Execution (not just the Workflow Task).\n\n`workflows/file-with-workflow-function-to-test.ts`\n\n```ts\nimport assert from 'assert';\n\nexport async function functionToTest() {\n  assert.ok(false);\n}\n```\n\n`test.ts`\n\n```ts\nimport {\n  TestWorkflowEnvironment,\n  workflowInterceptorModules,\n} from '@temporalio/testing';\n\nconst worker = await Worker.create({\n  connection: testEnv.nativeConnection,\n  interceptors: {\n    workflowModules: workflowInterceptorModules,\n  },\n  workflowsPath: require.resolve(\n    './workflows/file-with-workflow-function-to-test',\n  ),\n});\n\nawait worker.runUntil(\n  testEnv.workflowClient.execute(functionToTest, workflowOptions), // throws WorkflowFailedError\n);\n```\n","is_empty":false},{"file_name":"how-to-use-environment-variables-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-use-environment-variables-in-typescript.md","id":"typescript/how-to-use-environment-variables-in-typescript","title":"How to use environment variables in TypeScript","description":"Use Environment Variables","label":"Use Environment Variables","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n**Using in Activity code**\n\n```ts\nasync function runWorker(): Promise<void> {\n  const activities = createActivities({ apiKey: process.env.MAILGUN_API_KEY });\n\n  const worker = await Worker.create({\n    taskQueue: 'example',\n    activities,\n    workflowsPath: require.resolve('./workflows'),\n  });\n  await worker.run();\n}\n\nconst createActivities = (envVars: { apiKey: string }) => ({\n  async sendNotificationEmail(): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: 'post',\n      params: { to, from, subject, html },\n      auth: {\n        username: 'api',\n        password: envVars.apiKey,\n      },\n    });\n  },\n});\n```\n\n**Getting into Workflow**\n\nIf you need environment variables in your Workflow, use a Local Activity:\n\n```ts\nconst worker = await Worker.create({\n  taskQueue: 'example',\n  activities: createActivities(process.env),\n  workflowsPath: require.resolve('./workflows'),\n});\n\ntype EnvVars = Record<string, string>;\n\nconst createActivities = (envVars: EnvVars) => ({\n  async getEnvVars(): Promise<EnvVars> {\n    return envVars;\n  },\n  async sendNotificationEmail(apiKey: string): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: 'post',\n      params: { to, from, subject, html },\n      auth: {\n        username: 'api',\n        password: apiKey,\n      },\n    });\n  },\n});\n```\n\n```ts\nconst { getEnvVars } = proxyLocalActivities({\n  startToCloseTimeout: '1m',\n});\n\nconst { sendNotificationEmail } = proxyActivities({\n  startToCloseTimeout: '1m',\n});\n\nasync function yourWorkflow() {\n  const envVars = await getEnvVars();\n  if (!envVars.apiKey) {\n    throw new Error('missing env var apiKey');\n  }\n  await sendNotificationEmail(envVars.apiKey);\n}\n```\n\nIf your environment variables are sensitive, use a [custom Data Converter](/typescript/data-converters#encryption) to encrypt Activity return values and parameters.\n","is_empty":false},{"file_name":"how-to-use-signals-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-use-signals-in-typescript.md","id":"typescript/how-to-use-signals-in-typescript","title":"How to use Signals in TypeScript","description":"Use Signals","label":"Use Signals","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTo add a Signal to a Workflow, call `defineSignal()` with a name, and then attach a listener with `setHandler()`.\n\n- Handlers to take arguments, which can be used inside `setHandler()` logic.\n- Signal handlers can mutate state, Signal handlers cannot return values.\n\n**Declare your Signal as constants outside the Workflow Definition**\n\n```typescript\nimport * as wf from '@temporalio/workflow';\n\nexport const unblockSignal = wf.defineSignal('unblock');\n let isBlocked = true;\n wf.setHandler(unblockSignal, () => void (isBlocked = false));\n console.log('Blocked');\n try {\n   await wf.condition(() => !isBlocked);\n   console.log('Unblocked');\n } catch (err) {\n   if (err instanceof wf.CancelledFailure) {\n     console.log('Cancelled');\n   }\n   throw err;\n }\n}\n```\n\nThis code defines a Signal as _unblock_ and declares the variable as _isBlocked_ as true. Then the code tries to execute the condition and print _Unblocked_ to the console if it becomes unblocked. Finally, the code catches any errors, and if the error is `CancelledFailure`, then it prints `Cancelled` to the console.\n\nThis helps provide type safety, since you can export the type signature of the Signal or Query to be called on the client side.\n\n##### Declare your Signals dynamically\n\nFor more flexible usecases, you may want a dynamic Signal, such as a generated identifier. You may handle it in two ways:\n\n- avoid making it dynamic by collapsing all signals in one handler and move the identifier to the payload.\n- actually make the Signal name dynamic by inlining the Signal definition per handler.\n\n```typescript\nimport * as wf from '@temporalio/workflow';\n\nwf.setHandler(`genericSignal`, (payload) => {\n  switch (payload.taskId) {\n    case taskAId:\n      // do task A things\n      break;\n    case taskBId:\n      // do task B things\n      break;\n    default:\n      throw new Error('Unexpected task.');\n  }\n});\n\n// \"inline definition\" solution\nwf.setHandler(wf.defineSignal(`task-${taskAId}`), (payload) => {\n  /* do task A things */\n});\nwf.setHandler(wf.defineSignal(`task-${taskBId}`), (payload) => {\n  /* do task B things */\n});\n\n// utility \"inline definition\" helper\nconst inlineSignal = (signalName, handler) =>\n  wf.setHandler(wf.defineSignal(signalName), handler);\ninlineSignal(`task-${taskBId}`, (payload) => {\n  /* do task B things */\n});\n```\n\n:::note\n\nThe semantics of `defineSignal()` and `defineQuery()` is intentional, in that they return Signal/Query Definitions, not unique instances of Signals and Queries themselves.\nSignals and Queries are only instantiated in `setHandler()` and are specific to a particular Workflow Execution.\n\nThese distinctions may seem minor, but they model how Temporal works under the hood, because Signals and Queries are messages identified by _just strings_ and don't have meaning independent of the Workflow having a listener to handle them.\n\nWe named it `setHandler` instead of `subscribe` because Signals and Queries can only have one handler at a time, whereas `subscribe` could imply an observable with multiple consumers, and is a higher level construct.\n:::\n\n#### Start a Signal from the Client\n\nSending Signals requires a Workflow handle from a Temporal Client.\n\n- You send a Signal with `handle.signal(signal, ...args)`. A Signal has no return value by definition.\n- You can refer to a Signal by string name, which is useful for dynamic reference, but you will lose type inference\n\nThe following code is from inside the Client code.\n\n```typescript\nimport { count, increment } from './workflow';\n\n// init client code omitted - see Client docs\nconst handle = client.getHandle(workflowId);\n\n// these three are equivalent\nawait handle.signal(increment, 1);\nawait handle.signal<[number]>('increment', 1);\nawait client.getHandle(workflowId).signal(increment, 1);\n```\n","is_empty":false},{"file_name":"how-to-use-test-frameworks-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/how-to-use-test-frameworks-in-typescript.md","id":"typescript/how-to-use-test-frameworks-in-typescript","title":"How to use test frameworks in TypeScript","description":"TypeScript has sample tests for Jest and Mocha.","label":"Test frameworks","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nTypeScript has sample tests for [Jest](https://jestjs.io/) and [Mocha](https://mochajs.org/).\n\n**Jest**\n\n- Minimum Jest version: `27.0.0`\n- [Sample test file](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/workflows.test.ts)\n- [`jest.config.js`](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/jest.config.js) (must use [`testEnvironment: 'node'`](https://jestjs.io/docs/configuration#testenvironment-string); `testEnvironment: 'jsdom'` is not supported)\n\n**Mocha**\n\n- [Sample test file](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/mocha/workflows.test.ts)\n- Test coverage library: [`@temporalio/nyc-test-coverage`](https://github.com/temporalio/sdk-typescript/tree/main/packages/nyc-test-coverage)\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/index.md","id":"typescript/index","title":"How to use the Temporal TypeScript SDK","description":"Add the Temporal TypeScript SDK to your project.","label":"Temporal TypeScript SDK","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\n[![NPM](https://img.shields.io/npm/v/temporalio.svg?style=for-the-badge)](https://www.npmjs.com/search?q=author%3Atemporal-sdk-team)\n\nThis project requires Node.js 14.18 or later.\n\n**Create a project**\n\n```bash\nnpx @temporalio/create@latest ./your-app\n```\n\n**Add to an existing project**\n\n```bash\nnpm install @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity @temporalio/common\n```\n\n:::note\n\nThe TypeScript SDK is designed with TypeScript-first developer experience in mind, but it works equally well with JavaScript.\n\n:::\n","is_empty":false},{"file_name":"interceptors.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/interceptors.md","id":"typescript/interceptors","title":"Interceptors in TypeScript SDK","description":"Interceptors are a mechanism for users to modify inbound and outbound SDK calls. Interceptors are commonly used to add tracing and authorization to the scheduling and execution of Workflows and Activities. You can compare these to \"middleware\" in other frameworks.","label":"Interceptors","ssdi":[],"markdown_content":"\nInterceptors are a mechanism for users to modify inbound and outbound SDK calls.\nInterceptors are commonly used to add tracing and authorization to the scheduling and execution of Workflows and Activities.\nYou can compare these to \"middleware\" in other frameworks.\n\nThe TypeScript SDK comes with an optional interceptor package that adds tracing with [opentelemetry](https://www.npmjs.com/package/@temporalio/interceptors-opentelemetry). See how to use it in this [sample](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry).\n\n## Interceptor types\n\n- [WorkflowInboundCallsInterceptor](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInboundCallsInterceptor/) - Intercept Workflow inbound calls like execution, signals, and queries.\n- [WorkflowOutboundCallsInterceptor](https://typescript.temporal.io/api/interfaces/workflow.WorkflowOutboundCallsInterceptor/) - Intercept Workflow outbound calls to Temporal APIs like scheduling Activities and starting Timers.\n- [ActivityInboundCallsInterceptor](https://typescript.temporal.io/api/interfaces/worker.ActivityInboundCallsInterceptor) - Intercept inbound calls to an Activity (for example, `execute`).\n- [WorkflowClientCallsInterceptor](https://typescript.temporal.io/api/interfaces/client.WorkflowClientCallsInterceptor/) - Intercept methods of [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.WorkflowClient/) and [`WorkflowHandle`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle) like starting or signaling a Workflow.\n\n## How interceptors work\n\nInterceptors are run in a chain, all the interceptors work similarly, they accept 2 arguments: `input` and `next` where `next` calls the next interceptor in the chain.\nAll interceptor methods are optional—it's up to the implementor to choose which methods to intercept.\n\n## Interceptor examples\n\n<!--TODO use snipsync-->\n\n### Log start and completion of Activities\n\n```ts\nimport {\n  ActivityInput,\n  Next,\n  WorkflowOutboundCallsInterceptor,\n} from '@temporalio/workflow';\n\nexport class ActivityLogInterceptor\n  implements WorkflowOutboundCallsInterceptor\n{\n  constructor(public readonly workflowType: string) {}\n\n  async scheduleActivity(\n    input: ActivityInput,\n    next: Next<WorkflowOutboundCallsInterceptor, 'scheduleActivity'>,\n  ): Promise<unknown> {\n    console.log('Starting activity', { activityType: input.activityType });\n    try {\n      return await next(input);\n    } finally {\n      console.log('Completed activity', {\n        workflow: this.workflowType,\n        activityType: input.activityType,\n      });\n    }\n  }\n}\n```\n\n### Authorization\n\n```ts\nimport {\n  defaultDataConverter,\n  Next,\n  WorkflowInboundCallsInterceptor,\n  WorkflowInput,\n} from '@temporalio/workflow';\n\n/**\n * WARNING: This demo is meant as a simple auth example.\n * Do not use this for actual authorization logic.\n * Auth headers should be encrypted and credentials\n * stored outside of the codebase\n */\nexport class DumbWorkflowAuthInterceptor\n  implements WorkflowInboundCallsInterceptor\n{\n  public async execute(\n    input: WorkflowInput,\n    next: Next<WorkflowInboundCallsInterceptor, 'execute'>,\n  ): Promise<unknown> {\n    const authHeader = input.headers.auth;\n    const { user, password } = authHeader\n      ? await defaultDataConverter.fromPayload(authHeader)\n      : undefined;\n\n    if (!(user === 'admin' && password === 'admin')) {\n      throw new Error('Unauthorized');\n    }\n    return await next(input);\n  }\n}\n```\n\nTo properly do authorization from Workflow code, the Workflow would need to access encryption keys and possibly authenticate against an external user database, which requires the Workflow to break isolation.\nPlease contact us if you need to discuss this further.\n\n## Interceptor registration\n\n### Activity and client interceptors registration\n\n- Activity interceptors are registered on Worker creation by passing an array of [`ActivityInboundCallsInterceptor` factory functions](https://typescript.temporal.io/api/interfaces/worker.ActivityInboundCallsInterceptorFactory) through [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#interceptors).\n\n- Client interceptors are registered on `WorkflowClient` construction by passing an array of [`WorkflowClientCallsInterceptor` factory functions](https://typescript.temporal.io/api/interfaces/client.WorkflowClientCallsInterceptorFactory) via [WorkflowClientOptions](https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions#interceptors).\n\n### Workflow interceptors registration\n\nWorkflow interceptor registration is different from the other interceptors because they run in the Workflow isolate. To register Workflow interceptors, export an `interceptors` function from a file located in the `workflows` directory and provide the name of that file to the Worker on creation via [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#interceptors).\n\nAt the time of construction, the Workflow Context is already initialized for the current Workflow.\nUse [`workflowInfo`](https://typescript.temporal.io/api/namespaces/workflow#workflowinfo) to add Workflow specific information in the interceptor.\n\n`src/workflows/your-interceptors.ts`\n\n```ts\nimport { workflowInfo } from '@temporalio/workflow';\n\nexport const interceptors = () => ({\n  outbound: [new ActivityLogInterceptor(workflowInfo().workflowType)],\n  inbound: [],\n});\n```\n\n`src/worker/index.ts`\n\n```ts\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  interceptors: {\n    workflowModules: [require.resolve('./workflows/your-interceptors')],\n  },\n});\n```\n","is_empty":false},{"file_name":"introduction.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/introduction.md","id":"typescript/introduction","title":"TypeScript SDK introduction","description":"The TypeScript SDK lets developers write highly scalable, reliable, and long-running workflows without being a distributed systems expert.","label":"Introduction","ssdi":[],"markdown_content":"\nThe Temporal TypeScript SDK lets you write highly scalable and reliable long-running Workflows without being a distributed systems expert.\nIt is designed with TypeScript-first developer experience in mind, but works equally well with JavaScript.\n\n[Introduction to Temporal](https://youtu.be/2HjnQlnA5eY)\n\nYou can view:\n\n- [Code samples on GitHub](https://github.com/temporalio/samples-typescript)\n  - Fastest way to try these out is in the browser [![Gitpod ready-to-code](https://img.shields.io/badge/Gitpod-ready--to--code-908a85?logo=gitpod)](https://gitpod.io/#https://github.com/temporalio/samples-typescript/) ([90-second demo](https://youtu.be/FdEQQC9EdfU))\n- [Searchable full API reference](https://typescript.temporal.io)\n- [SDK source on GitHub](https://github.com/temporalio/sdk-typescript) [![GitHub stars](https://img.shields.io/github/stars/temporalio/sdk-typescript)](https://github.com/temporalio/sdk-typescript/stargazers) (give us a star!)\n- [See version diffs on our Changelog](https://github.com/temporalio/sdk-typescript/blob/HEAD/CHANGELOG.md)\n\n## Getting started\n\nChoose your own adventure:\n\n<details>\n<summary>\nRun \"Hello Temporal\" in the cloud (~2 minutes)\n</summary>\n\n[Open our Samples repo in Gitpod](https://gitpod.io/#https://github.com/temporalio/samples-typescript/) and login to try out our Hello World example with no need for local Docker setup.\n\nWhen you click on that link above and log in (there is a generous free tier), Gitpod will launch 4 terminals:\n\n- Pane 1: Temporal Cluster\n  - Left: [Temporal Server](https://github.com/temporalio/docker-compose) - always running\n  - Right: [Temporal Web](/web-ui) and [Temporal `tctl` CLI](/tctl-v1)\n- Pane 2: Hello World\n  - Left: [Temporal Worker](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/worker.ts) - running and hot reloading\n  - Right: [Temporal Client](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/client.ts) - run `npm run workflow`\n\nIt takes ~3 minutes for the Docker Compose setup to start up.\nOnce you have it up and running (Temporal Web should show the first Workflow Execution), you can use our [Hello World Walkthrough](https://learn.temporal.io/getting_started/typescript/hello_world_in_typescript/) tutorial to orient you to the sample file structure.\n\n</details>\n\n<details>\n<summary>\nRun \"Hello Temporal\" locally (~10 minutes)\n</summary>\n\n:::note Prerequisites\n\n<strong>Node.js 14+</strong>: this project requires Node.js version 14 or later.\n\n<details>\n<summary>\n<strong>Temporal Server</strong>: make sure it is running locally!\n</summary>\n\nRun Temporal Server (requires [Docker](https://docs.docker.com/engine/install) and [Docker Compose](https://docs.docker.com/compose/install/)):\n\n```bash\ngit clone https://github.com/temporalio/docker-compose.git temporal\ncd temporal\ndocker compose up\n```\n\nIf you want to run Temporal without Docker, [Temporalite](https://github.com/temporalio/temporalite) is a distribution of Temporal that runs as a single process with zero runtime dependencies.\n\n</details>\n\n:::\n\n### Step 1: Create a new project\n\nUse the [package initializer](/typescript/package-initializer) to create a new project:\n\n```bash\nnpx @temporalio/create@latest ./example\ncd example\n```\n\nThis will set up with [the basic Hello World sample](https://github.com/temporalio/samples-typescript/tree/main/hello-world) using our [Package Initializer](/typescript/package-initializer) (think of it like `create-temporal-app`!)\n\n### Step 2: Run your Workflow\n\nRun the Worker:\n\n```bash\n# this runs ts-node src/worker.ts with nodemon to auto-reload on changes\n$ npm run start.watch\n```\n\n<details>\n<summary>Expected Terminal Output</summary>\n\n```bash\n# this runs ts-node src/worker.ts with nodemon to auto-reload on changes\n$ npm run start.watch\n\n> temporal-hello-world@0.1.0 start.watch\n> nodemon src/worker.ts\n\n[nodemon] 2.0.13\n[nodemon] to restart at any time, enter `rs`\n[nodemon] watching path(s): src/**/*\n[nodemon] watching extensions: ts\n[nodemon] starting `ts-node src/worker.ts`\n2022-06-17T23:47:12.854Z [INFO] asset main.js 352 KiB [emitted] (name: main) 1 related asset\n2022-06-17T23:47:12.855Z [INFO] runtime modules 2.03 KiB 5 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./packages/test/lib/workflows/*.js 91.7 KiB 95 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./packages/workflow/lib/*.js 90.9 KiB\n2022-06-17T23:47:12.855Z [INFO]   ./packages/workflow/lib/worker-interface.js 11.2 KiB [built] [code generated]\n2022-06-17T23:47:12.855Z [INFO]   + 10 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./packages/common/lib/ 46.9 KiB\n2022-06-17T23:47:12.855Z [INFO]   modules by path ./packages/common/lib/converter/*.js 27 KiB 8 modules\n2022-06-17T23:47:12.855Z [INFO]   modules by path ./packages/common/lib/*.js 19.9 KiB 2 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./packages/internal-workflow-common/lib/*.js 13.5 KiB\n2022-06-17T23:47:12.855Z [INFO]   ./packages/internal-workflow-common/lib/index.js 1.3 KiB [built] [code generated]\n2022-06-17T23:47:12.855Z [INFO]   + 9 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./node_modules/ 43.5 KiB\n2022-06-17T23:47:12.855Z [INFO]   modules by path ./node_modules/ramda/src/ 1.42 KiB 3 modules\n2022-06-17T23:47:12.855Z [INFO]   + 2 modules\n2022-06-17T23:47:12.855Z [INFO] __temporal_custom_payload_converter (ignored) 15 bytes [built] [code generated]\n2022-06-17T23:47:12.855Z [INFO] webpack 5.72.0 compiled successfully in 351 ms\n2022-06-17T23:47:12.857Z [INFO] Workflow bundle created { size: '0.34MB' }\n2022-06-17T23:47:12.987Z [INFO] Worker state changed { state: 'RUNNING' }\n```\n\n</details>\n\n> If this step fails, make sure you have the correct version of Node and other prerequisites listed above.\n\nThen start your Workflow:\n\n```bash\n$ npm run workflow # runs ts-node src/client.ts\nHello, Temporal! # success!\n```\n\nThis \"Hello, Temporal!\" message comes from the combination of:\n\n- [`client.ts`](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/client.ts) passing `'Temporal'` as an argument to the Workflow.\n- The [Workflow](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/workflows.ts) passing the argument to the Activity.\n- The [Activity](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/activities.ts) taking the argument as `name` and returning `Hello, ${name}!`.\n\n<details>\n<summary>Viewing your Workflow Execution in Temporal Web\n</summary>\n\nYou can verify execution in Temporal Web (available at [localhost:8080](http://localhost:8080/) on the default [`docker-compose`](https://github.com/temporalio/docker-compose)):\n\n![image](https://user-images.githubusercontent.com/6764957/118865735-d7255f80-b913-11eb-8ace-a7dbdc351f8e.png)\n\n</details>\n\n## Next Steps\n\nFor a full code walkthrough of our Hello World example, see our [Hello World documentation](https://learn.temporal.io/getting_started/typescript/hello_world_in_typescript/).\n\nIf you want an example of what it's like to integrate Temporal into an existing full-stack app, check our [Next.js One-Click Buy Tutorial](/typescript/nextjs-tutorial).\n\n</details>\n\n<details>\n<summary>Read through the core API docs (~20 minutes)\n</summary>\n\nThese are the essential pages to have a passing knowledge of our Core APIs:\n\n- [Workflows](/typescript/workflows): How to write Temporal's core orchestration code\n  - Workflows use [Activities](/typescript/activities) to act on the outside world (e.g. call an API with retries and timeouts, or access the filesystem)\n  - see [Workflow APIs](/typescript/workflows) for Signals, Queries, Timers, Child Workflows, Infinite Workflows, and more!\n- [Workers and Task Queues](/typescript/workers): How Workflows and Activities are routed to and executed on machines you control\n- [Clients](/typescript/clients): How to start, signal, query, cancel, or otherwise handle Workflows.\n\n</details>\n\n## Getting Help\n\nFor quick questions, we are always available on [the Temporal Slack](https://temporal.io/slack).\n\nFor long form/FAQs, please search and ask on [the Temporal community forum](https://community.temporal.io/) instead.\n\n## TS SDK Intro Workshop\n\nWe held a 2-hour introduction workshop explaining every core concept from scratch: [Complete Intro to Temporal Workshop - TypeScript SDK](https://www.youtube.com/watch?v=cehsmv8of_4).\n\nTimestamps:\n\n- [00:00:00](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=0s) Part 1: TS SDK Intro\n- [00:12:15](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=735s) Part 2: Your First Workflow\n- [00:16:42](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=1002s) Part 3: Workflows vs Activities\n- [00:23:52](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=1432s) Live Code Demo\n- [00:36:00](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=2160s) Part 4: Timeouts and Retries\n- [00:57:00](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=3420s) Part 5: Workflow APIs\n- [01:24:00](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=5040s) Signals and Queries\n- [01:29:40](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=5380s) Fullstack Next.js App\n- [01:41:50](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=6110s) Part 6: Workers and Task Queues\n- [01:45:19](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=6319s) Recap and Q&A\n\nAnd of course you can [join the #typescript-sdk channel](https://temporal.io/slack) to ask any questions as you get set up.\nDesign partners are already [putting us in production](https://youtu.be/GpbOkDjpeYU), and we are eager to hear your feedback.\n","is_empty":false},{"file_name":"linting-and-types.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/linting-and-types.md","id":"typescript/linting-and-types","title":"Linting and types in TypeScript","description":"Set up linting and types in your TypeScript project.","label":"Linting and types","tags":["developer-guide","sdk","typescript"],"ssdi":[],"markdown_content":"\nIf you started your project with `@temporalio/create`, you already have our recommended TypeScript and ESLint configurations.\n\nIf you incrementally added Temporal to an existing app, we do recommend setting up linting and types because they help catch bugs well before you ship them to production, and they improve your development feedback loop.\nTake a look at our recommended [.eslintrc](https://github.com/temporalio/samples-typescript/blob/main/.shared/.eslintrc.js) file and tweak to suit your needs.\n","is_empty":false},{"file_name":"listen-to-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/listen-to-heartbeats.md","id":"typescript/listen-to-heartbeats","title":"Listen to Heartbeats","description":"When an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.","label":"Listen to Heartbeats","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.\n","is_empty":false},{"file_name":"local-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/local-activities.md","id":"typescript/local-activities","title":"Local Activities","description":"To call Local Activities in TypeScript, use proxyLocalActivities.","label":"Local Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo call [Local Activities](/concepts/what-is-a-local-activity) in TypeScript, use [`proxyLocalActivities`](https://typescript.temporal.io/api/namespaces/workflow/#proxylocalactivities).\n\n```ts\nimport * as workflow from '@temporalio/workflow';\n\nconst { getEnvVar } = workflow.proxyLocalActivities({\n  startToCloseTimeout: '2 seconds',\n});\n\nexport async function yourWorkflow(): Promise<void> {\n  const someSetting = await getEnvVar('SOME_SETTING');\n  // ...\n}\n```\n\nLocal Activities must be registered with the Worker the same way non-local Activities are.\n","is_empty":false},{"file_name":"logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/logging.md","id":"typescript/logging","title":"Logging and Sinks in TypeScript SDK","description":"Workflow Sinks allow you to export information from the Workflow back to the Node.js environment, often used for logging, metrics, tracing.","label":"Logging and Sinks","ssdi":[],"markdown_content":"\n:::note Sample available\n\nA complete sample for setting up the instrumentation for the different components of the SDK is available on our [samples repo](https://github.com/temporalio/samples-typescript/tree/main/instrumentation).\n:::\n\n## Logging from Activities\n\nActivities run in the standard Node.js environment and can use any Node.js logger.\n\n<details>\n<summary>\nInject Activity context via interceptor and log all Activity Executions\n</summary>\n\n<!--SNIPSTART typescript-activity-logging-interceptor-->\n\n[instrumentation/src/activities/interceptors.ts](https://github.com/temporalio/samples-typescript/blob/master/instrumentation/src/activities/interceptors.ts)\n\n```ts\nimport { Context } from '@temporalio/activity';\nimport {\n  ActivityExecuteInput,\n  ActivityInboundCallsInterceptor,\n  Next,\n} from '@temporalio/worker';\nimport { Logger } from 'winston';\n\n/** An Activity Context with an attached logger */\nexport interface ContextWithLogger extends Context {\n  logger: Logger;\n}\n\n/** Get the current Activity context with an attached logger */\nexport function getContext(): ContextWithLogger {\n  return Context.current() as ContextWithLogger;\n}\n\n/** Logs Activity executions and their duration */\nexport class ActivityInboundLogInterceptor\n  implements ActivityInboundCallsInterceptor\n{\n  public readonly logger: Logger;\n\n  constructor(ctx: Context, logger: Logger) {\n    this.logger = logger.child({\n      activity: ctx.info,\n    });\n\n    // Set a logger instance on the current Activity Context to provide\n    // contextual logging information to each log entry generated by the Activity.\n    (ctx as ContextWithLogger).logger = this.logger;\n  }\n\n  async execute(\n    input: ActivityExecuteInput,\n    next: Next<ActivityInboundCallsInterceptor, 'execute'>,\n  ): Promise<unknown> {\n    let error: any = undefined;\n    const startTime = process.hrtime.bigint();\n    try {\n      return await next(input);\n    } catch (err: any) {\n      error = err;\n      throw err;\n    } finally {\n      const durationNanos = process.hrtime.bigint() - startTime;\n      const durationMs = Number(durationNanos / 1_000_000n);\n      if (error) {\n        this.logger.error('activity failed', { error, durationMs });\n      } else {\n        this.logger.debug('activity completed', { durationMs });\n      }\n    }\n  }\n}\n```\n\n<!--SNIPEND-->\n\n</details>\n\n<details>\n<summary>\nUse the injected logger from an Activity\n</summary>\n\n<!--SNIPSTART typescript-activity-use-injected-logger -->\n\n[instrumentation/src/activities/index.ts](https://github.com/temporalio/samples-typescript/blob/master/instrumentation/src/activities/index.ts)\n\n```ts\nimport { getContext } from './interceptors';\n\nexport async function greet(name: string): Promise<string> {\n  const { logger } = getContext();\n  logger.info('Log from activity', { name });\n  return `Hello, ${name}!`;\n}\n```\n\n<!--SNIPEND-->\n\n</details>\n\n## Logging from Workflows with Workflow Sinks\n\nLogging from Workflows is tricky for two reasons:\n\n1. Workflows run in a sandboxed environment and cannot do any I/O.\n1. Workflow code might get replayed at any time, generating duplicate log messages.\n\nTo work around these limitations, we recommend using the Sinks feature in the TypeScript SDK.\nSinks enable one-way export of logs, metrics, and traces from the Workflow isolate to the Node.js environment.\n\n<!--\nWorkflows in Temporal may be replayed from the beginning of their history when resumed. In order for Temporal to recreate the exact state Workflow code was in, the code is required to be fully deterministic. To prevent breaking [determinism](/typescript/determinism), in the TypeScript SDK, Workflow code runs in an isolated execution environment and may not use any of the Node.js APIs or communicate directly with the outside world. -->\n\nSinks are written as objects with methods. Similar to Activities, they are declared in the Worker and then proxied in Workflow code, and it helps to share types between both.\n\n<details>\n  <summary>Comparing Sinks, Activities and Interceptors</summary>\n\nSinks are similar to Activities in that they are both registered on the Worker and proxied into the Workflow.\nHowever, they differ from Activities in important ways:\n\n- Sink functions don't return any value back to the Workflow and cannot not be awaited.\n- Sink calls are not recorded in Workflow histories (no timeouts or retries).\n- Sink functions are _always_ run on the same Worker that runs the Workflow they are called from.\n\n</details>\n\n### Declaring the Sink Interface\n\nExplicitly declaring a Sink's interface is optional, but is useful for ensuring type safety in subsequent steps:\n\n<!--SNIPSTART typescript-logger-sink-interface-->\n\n[sinks/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/sinks/src/workflows.ts)\n\n```ts\nimport { LoggerSinks, proxySinks, Sinks } from '@temporalio/workflow';\n\nexport interface AlertSinks extends Sinks {\n  alerter: {\n    alert(message: string): void;\n  };\n}\n\nexport type MySinks = AlertSinks & LoggerSinks;\n```\n\n<!--SNIPEND-->\n\n### Implementing Sinks\n\nImplementing Sinks is a two-step process.\n\n#### Implement and inject the Sink function into a Worker\n\n<!--SNIPSTART typescript-logger-sink-worker-->\n\n[sinks/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/sinks/src/worker.ts)\n\n```ts\nimport { defaultSinks, InjectedSinks, Worker } from '@temporalio/worker';\nimport { MySinks } from './workflows';\n\nasync function main() {\n  const sinks: InjectedSinks<MySinks> = {\n    ...defaultSinks(),\n    alerter: {\n      alert: {\n        fn(workflowInfo, message) {\n          console.log(`sending SMS alert!\nworkflow: ${workflowInfo.runId}\nmessage: ${message}`);\n        },\n        callDuringReplay: false, // The default\n      },\n    },\n  };\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'sinks',\n    sinks,\n  });\n  await worker.run();\n  console.log('Worker gracefully shutdown');\n}\n\nmain().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n<!--SNIPEND-->\n\n- Sink function implementations are passed as an object into [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions/#sinks)\n- You can specify whether you want the injected function to be called during Workflow replay by setting the `callDuringReplay` boolean option.\n\n#### Proxy and call a Sink function from a Workflow\n\n<!--SNIPSTART typescript-logger-sink-workflow-->\n\n[sinks/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/sinks/src/workflows.ts)\n\n```ts\nconst { alerter, defaultWorkerLogger } = proxySinks<MySinks>();\n\nexport async function sinkWorkflow(): Promise<string> {\n  defaultWorkerLogger.info('default logger: Workflow Execution started', {});\n  alerter.alert('alerter: Workflow Execution started');\n  return 'Hello, Temporal!';\n}\n```\n\n<!--SNIPEND-->\n\nSome important features of the [InjectedSinkFunction](https://typescript.temporal.io/api/interfaces/worker.InjectedSinkFunction) interface:\n\n- **Injected WorkflowInfo argument**: The first argument of a Sink function implementation is a [`workflowInfo` object](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo/) that contains useful metadata.\n- **Limited arguments types**: The remaining Sink function arguments are copied between the sandbox and the Node.js environment using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n- **No return value**: To prevent breaking determinism, Sink functions cannot return values to the Workflow.\n\n#### Advanced: Performance considerations and non-blocking Sinks\n\nThe injected sink function contributes to the overall Workflow Task processing duration.\n\n- If you have a long-running sink function, such as one that tries to communicate with external services, you might start seeing Workflow Task timeouts.\n- The effect is multiplied when using `callDuringReplay: true` and replaying long Workflow histories because the Workflow Task timer starts when the first history page is delivered to the Worker.\n\n## Logging in Workers and Clients\n\nThe Worker comes with a default logger which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThere are 5 levels in total: `TRACE`, `DEBUG`, `INFO`, `WARN`, and `ERROR`.\n\nThe reason we only offer a default logger is to minimize Worker dependencies and allow SDK users to bring their own logger.\n\n### Customizing the default logger\n\nTemporal ships a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.DefaultLogger/) that implements the basic interface:\n\n#### Example: Set up the DefaultLogger to only log messages with level WARN and higher\n\n```ts\nimport { DefaultLogger, Runtime } from '@temporalio/worker';\n\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\nRuntime.install({ logger });\n```\n\n#### Example: Accumulate logs for testing/reporting\n\n```ts\nimport { DefaultLogger, LogEntry } from '@temporalio/worker';\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger('TRACE', (entry) => logs.push(entry));\nlog.debug('hey', { a: 1 });\nlog.info('ho');\nlog.warn('lets', { a: 1 });\nlog.error('go');\n```\n\nThe log levels are [listed here](https://typescript.temporal.io/api/namespaces/worker#loglevel) in increasing order of severity.\n\n### Using a custom logger\n\nA common logging use case is logging to a file to be picked up by a collector like the [Datadog Agent](https://docs.datadoghq.com/logs/log_collection/nodejs/?tab=winston30).\n\n```ts\nimport { Runtime } from '@temporalio/worker';\nimport winston from 'winston';\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  transports: [new transports.File({ filename: '/path/to/worker.log' })],\n});\nRuntime.install({ logger });\n```\n\n## Metrics\n\nFor information about metrics, see the [Metrics section on the Deploy Checklist](/typescript/production-deploy#metrics) page.\n\n## OpenTelemetry tracing\n\nThe [`interceptors-opentelemetry`](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry) sample shows how to use the SDK's built-in OpenTelemetry tracing to trace everything from starting a Workflow to Workflow Execution to running an Activity from that Workflow.\n\nThe built-in tracing uses protobuf message headers (like [this one](https://github.com/temporalio/api/blob/b2b8ae6592a8730dd5be6d90569d1aea84e1712f/temporal/api/workflowservice/v1/request_response.proto#L161) when starting a Workflow) to propagate the tracing information from the client to the Workflow and from the Workflow to its successors (when Continued As New), children, and Activities.\nAll of these executions are linked with a single trace identifier and have the proper parent->child span relation.\n\nTracing is compatible between different Temporal SDKs as long as compatible [context propagators](https://opentelemetry.lightstep.com/core-concepts/context-propagation/) are used.\n\n### Context propagation\n\nThe TypeScript SDK uses the global OpenTelemetry propagator.\n\nTo extend the default ([Trace Context](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#w3ctracecontextpropagator-propagator) and [Baggage](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#baggage-propagator) propagators) to also include the [Jaeger propagator](https://www.npmjs.com/package/@opentelemetry/propagator-jaeger), follow these steps:\n\n- `npm i @opentelemetry/propagator-jaeger`\n\n- At the top level of your Workflow code, add the following lines:\n\n  ```js\n  import { propagation } from '@opentelemetry/api';\n  import {\n    CompositePropagator,\n    W3CBaggagePropagator,\n    W3CTraceContextPropagator,\n  } from '@opentelemetry/core';\n  import { JaegerPropagator } from '@opentelemetry/propagator-jaeger';\n\n  propagation.setGlobalPropagator(\n    new CompositePropagator({\n      propagators: [\n        new W3CTraceContextPropagator(),\n        new W3CBaggagePropagator(),\n        new JaegerPropagator(),\n      ],\n    }),\n  );\n  ```\n\nSimilarly, you can customize the OpenTelemetry `NodeSDK` propagators by following the instructions in the [Initialize the SDK](https://github.com/open-telemetry/opentelemetry-js/tree/main/experimental/packages/opentelemetry-sdk-node#initialize-the-sdk) section of the README.\n","is_empty":false},{"file_name":"manage-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/manage-namespaces.md","id":"typescript/manage-namespaces","title":"How to manage Namespaces","description":"You can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.","label":"Manage Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can get details for your Namespaces, update Namespace configuration, and deprecate or delete your Namespaces.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can manage your registered Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"metrics.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/metrics.md","id":"typescript/metrics","title":"How to emit metrics","description":"Each Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.","label":"Metrics","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.\nFor a complete list of metrics capable of being emitted, see the [SDK metrics reference](/references/sdk-metrics).\n\nMetrics can be scraped and stored in time series databases, such as:\n\n- [Prometheus](https://prometheus.io/docs/introduction/overview/)\n- [M3db](https://m3db.io/docs/)\n- [statsd](https://github.com/statsd/statsd)\n\nTemporal also provides a dashboard you can integrate with graphing services like [Grafana](https://grafana.com/docs/). For more information, see:\n\n- Temporal's implementation of the [Grafana dashboard](https://github.com/temporalio/dashboards)\n- [How to export metrics in Grafana](https://github.com/temporalio/helm-charts#exploring-metrics-via-grafana)\n","is_empty":false},{"file_name":"mock-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/mock-activities.md","id":"typescript/mock-activities","title":"How to mock Activities","description":"Mock an Activity by providing mock Activity implementations to the Worker.","label":"Mock Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMock the Activity invocation when unit testing your Workflows.\n\nWhen integration testing Workflows with a Worker, you can mock Activities by providing mock Activity implementations to the Worker.\n","is_empty":false},{"file_name":"mutable-side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/mutable-side-effects.md","id":"typescript/mutable-side-effects","title":"Mutable Side Effects","description":"Mutable Side Effects are a method of execution to produce non-deterministic code.","label":"Mutable Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nMutable Side Effects execute the provided function once, and then it looks up the History of the value with the given Workflow ID.\n\n- If there is no existing value, then it records the function result as a value with the given Workflow Id on the History.\n- If there is an existing value, then it compares whether the existing value from the History has changed from the new function results, by calling the equals function.\n  - If the values are equal, then it returns the value without recording a new Marker Event\n  - If the values aren't equal, then it records the new value with the same ID on the History.\n\n:::note\n\nDuring a Workflow Execution, every new Side Effect call results in a new Marker recorded on the Workflow History; whereas Mutable Side Effects only records a new Marker on the Workflow History if the value for the Side Effect ID changes or is set the first time.\n\nDuring a Replay, Mutable Side Effects will not execute the function again. Instead, it returns the exact same value that was returned during the Workflow Execution.\n\n:::\n","is_empty":false},{"file_name":"namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/namespaces.md","id":"typescript/namespaces","title":"How to create and manage Namespaces","description":"You can create, update, deprecate or delete your Namespaces using either tctl or SDK APIs..","label":"Namespaces","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can create, update, deprecate or delete your [Namespaces](/concepts/what-is-a-namespace) using either tctl or SDK APIs.\n\nUse Namespaces to isolate your Workflow Executions according to your needs.\nFor example, you can use Namespaces to match the development lifecycle by having separate `dev` and `prod` Namespaces.\nYou could also use them to ensure Workflow Executions between different teams never communicate - such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) to create and manage a Namespace from the UI, or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces from the command-line interface.\n\nOn self-hosted Temporal Cluster, you can register and manage your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"nextjs.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/nextjs.md","id":"typescript/nextjs-tutorial","title":"Integrating Temporal into an Existing Next.js Application","description":"In this tutorial, we'll talk about how Temporal integrates into an existing Next.js application using Next.js API routes. This gives you the ability to write full-stack, long-running applications end to end in TypeScript.","label":"Next.js Tutorial","ssdi":[],"markdown_content":"\nIn this tutorial, we'll talk about how Temporal integrates into an **existing Next.js application** using Next.js API routes.\nThis gives you the ability to write full-stack, long-running applications end to end in TypeScript.\n\n:::info Notes to user\n\nThis tutorial is written for a reasonably experienced TypeScript/Next.js developer.\nWhether you are using [Gatsby Functions](https://www.gatsbyjs.com/docs/reference/functions/), [Blitz.js API Routes](https://blitzjs.com/docs/api-routes) or just have a standard Express.js app, you should be able to adapt this tutorial with only minor modifications.\nIf you run into trouble, you are welcome to reach out on the [Temporal Slack](https://temporal.io/slack) for help, but we cannot promise help with non-Temporal build tooling related questions.\n\n**To skip straight to a fully working example, you can check our [samples-typescript repo](https://github.com/temporalio/samples-typescript/tree/main/nextjs-ecommerce-oneclick)**, which you can also clone from scratch with [package initializer](/typescript/package-initializer) skeleton:\n\n```bash\nnpx @temporalio/create@latest nextjs-temporal-app --sample nextjs-ecommerce-oneclick\n```\n\n- We go through the setup assuming you want to use TypeScript.\n  You should be able to skip some steps if you want to use vanilla JavaScript.\n- We also assume that you have [Temporal's prerequisites](/typescript/introduction#getting-started) already set up.\n- Temporal doesn't prescribe folder structure; feel free to ignore or modify these instructions per your own needs.\n\n:::\n\n## Add Temporal to your Next.js project\n\nYou can install Temporal's packages with a single dependency, then set up folders and files for your Workflow, Activity, and Worker code:\n\n```bash\nnpm i @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity # in Next.js project root\nmkdir -p temporal/src # create folder, recursively\ncd temporal\ntouch src/worker.ts src/workflows.ts src/activities.ts\n```\n\n<details>\n<summary>\n\nConfigure TypeScript to compile from `temporal/src` to `temporal/lib` with a `tsconfig.json`.\n\n</summary>\n\nSample `tsconfig.json` to get you started:\n\n```js\n// /temporal/tsconfig.json\n{\n  \"extends\": \"@tsconfig/node16/tsconfig.json\", // optional but nice to have\n  \"version\": \"4.4.2\",\n  \"compilerOptions\": {\n    \"emitDecoratorMetadata\": false,\n    \"experimentalDecorators\": false,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"composite\": true,\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./lib\"\n  },\n  \"include\": [\"src/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n</details>\n\n<details>\n<summary>\n\nFor convenience, you may want to set up some npm scripts to run the builds in your project root `package.json`.\n\n</summary>\n\n```js\n// /package.json\n  \"scripts\": {\n    \"dev\": \"npm-run-all -l build:temporal --parallel dev:temporal dev:next start:worker\",\n    \"dev:next\": \"next dev\",\n    \"dev:temporal\": \"tsc --build --watch ./temporal/tsconfig.json\",\n    \"build:next\": \"next build\",\n    \"build:temporal\": \"tsc --build ./temporal/tsconfig.json\",\n    \"start\": \"npm run dev\",\n    \"start:worker\": \"nodemon ./temporal/lib/worker\",\n    \"lint\": \"eslint .\"\n  },\n```\n\nIn the above example we use `npm-run-all` and `nodemon` so that we are able to do 4 things:\n\n- build Temporal once\n- start Next.js locally\n- start a Temporal Worker\n- rebuild Temporal files on change\n\nin a single `npm run dev` command.\n\n</details>\n\n## Write your first Workflow, Activity and Worker\n\nInside of `/temporal/src/activities.ts` we'll write a simple Activity function to start with:\n\n```ts\n// /temporal/src/activities.ts\nimport { Context } from '@temporalio/activity';\n\nexport async function purchase(id: string): Promise<string> {\n  console.log(`Purchased ${id}!`);\n  return Context.current().info.activityId;\n}\n```\n\nActivities are the only way to interact with the outside world in Temporal (e.g. making API requests, or accessing the filesystem).\nSee the [Activities docs](/typescript/activities) for more info.\n\nInside of `/temporal/src/workflows.ts` we'll write a Workflow function that calls this Activity:\n\n```ts\n// /temporal/src/workflows.ts\nimport { proxyActivities, sleep } from '@temporalio/workflow';\nimport type * as activities from './activities'; // purely for type safety\n\nconst { purchase } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\nexport async function OneClickBuy(id: string): Promise<string> {\n  const result = await purchase(id); // calling the activity\n  await sleep('10 seconds'); // demo use of timer\n  console.log(`Activity ID: ${result} executed!`);\n}\n```\n\nWorkflow code is bundled and run inside a [deterministic v8 isolate](/typescript/determinism), so we can persist and replay every state change.\nThis is why Workflow code must be separate from Activity code, and why we have to `proxyActivities` instead of directly importing them.\nWorkflows also have access to a special set of [Workflow APIs](/typescript/workflows#workflow-apis) which we recommend exploring next.\n\nWith your Workflows and Activities done, you can now write the Worker that will host both and poll the `tutorial` Task Queue:\n\n```ts\n// /temporal/src/worker.ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nrun().catch((err) => console.log(err));\n\nasync function run() {\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'), // passed to Webpack for bundling\n    activities, // directly imported in Node.js\n    taskQueue: 'tutorial',\n  });\n  await worker.run();\n}\n```\n\nSee the full [Worker docs](/typescript/workers) for more info.\nYou should now be able to run your Worker with `npm run build:temporal && npm run start:worker`, but it's not very exciting because you have no way to start a Workflow yet.\n\n:::tip Pro tip\n\nYou actually _can_ start a Workflow with [`tctl`](/tctl-v1/workflow#start) with just a Worker running, and no Client code written!\nIt is out of scope for this tutorial but try to `brew install tctl` and then `tctl workflow run --tq tutorial --wt OneClickBuy --et 60 -i '\"Temporal CLI\"'` if you enjoy developing with CLIs.\n\n:::\n\n## Write a Temporal Client inside a Next.js API Route\n\nWe will use Next.js API routes to expose a serverless endpoint that can be called by our frontend and then communicate with Temporal on the backend:\n\n```bash\n# in Next.js project root\nmkdir pages/api\ntouch pages/api/startBuy.ts\n```\n\nNow we will create a Client and start a Workflow Execution:\n\n```ts\n// pages/api/startBuy.ts\nimport { Connection, WorkflowClient } from '@temporalio/client';\nimport { OneClickBuy } from '../../temporal/lib/workflows.js';\n\nexport default async function startBuy(req, res) {\n  const { itemId } = req.body; // TODO: validate itemId and req.method\n  const client = new WorkflowClient();\n  const handle = await client.start(OneClickBuy, {\n    workflowId: 'business-meaningful-id',\n    // must match the taskQueue polled by Worker above\n    taskQueue: 'tutorial',\n    args: [itemId],\n    // workflowId: // TODO: use business-meaningful user/transaction ID here\n  }); // kick off the purchase async\n\n  res.status(200).json({ workflowId: handle.workflowId });\n}\n```\n\nNow if you have Next.js and Temporal running, you can at least start a Workflow Execution:\n\n```bash\nnpm run dev # start Temporal and Next.js in parallel\ncurl -d '{\"itemId\":\"item123\"}' -H \"Content-Type: application/json\" -X POST http://localhost:3000/api/startBuy\n```\n\nThe terminal that has your Temporal Worker will print `Purchased item123` if everything is working properly.\n\n## Call the API Route from the Next.js frontend\n\nIf you are an experienced React/Next.js dev you should know what to do here.\nFor tutorial purposes we will just assume you have an `itemId` to use here; in real life you are likely to pull this from some other data source like Shopify or a database.\n\n```ts\n// /pages/index.ts or whatever page you are on\n// inside event handler\nfetch('/api/startBuy', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ itemId }),\n});\n```\n\nWe recommend tracking the state of this API call and possibly toasting success, [per our sample code](https://github.com/temporalio/samples-typescript/blob/1f76cb6f78ef494074b937268c14fcc078e36956/nextjs-ecommerce-oneclick/pages/index.tsx#L143), but of course it is up to you what UX you want to provide.\n\n## Deploying your Temporal + Next.js app\n\nYour Next.js app, including Next.js API Routes with Temporal Clients in them, can be deployed anywhere Next.js can be deployed, including in serverless environments like Vercel or Netlify.\n\n:::important\n\nHowever, your Temporal Workers **must** be deployed in traditional \"serverful\" environments (e.g. with EC2, Digital Ocean or Render, not a serverless environment).\n\n:::\n\n**Both Temporal Clients and Temporal Workers must be configured to communicate with a Temporal Server instance**, whether self-hosted or Temporal Cloud.\nYou will need to configure gRPC connection address, namespace, and mTLS cert and key (strongly recommended).\n\n```ts\n// before Worker.create call in worker.ts\nconst connection = await NativeConnection.connect({\n  address,\n  tls: {\n    serverNameOverride,\n    serverRootCACertificate,\n    clientCertPair: {\n      crt: fs.readFileSync(clientCertPath),\n      key: fs.readFileSync(clientKeyPath),\n    },\n  },\n});\n\n// inside each Client call inside API Route\nconst connection = await Connection.connect({\n  address,\n  tls: {\n    serverNameOverride,\n    serverRootCACertificate,\n    clientCertPair: {\n      crt: fs.readFileSync(clientCertPath),\n      key: fs.readFileSync(clientKeyPath),\n    },\n  },\n});\n```\n\n[See the mTLS tutorial](/typescript/security#mtls-tutorial) for full details, or get in touch with us on Slack if you have reached this stage.\n\n## Production Concerns\n\nAs you move into production with your app, please review our docs on:\n\n- [Securing](/typescript/security)\n- [Testing](/typescript/testing)\n- [Patching](/typescript/patching) (aka migrating code to new versions)\n- [Logging](/typescript/how-to-log-from-a-workflow-in-typescript)\n- [Production Deploy Checklist](/typescript/production-deploy)\n\nYou will also want to have a plan for **monitoring and scaling your Temporal Workers** that host and execute your Activity and Workflow code (separately from monitoring and scaling Temporal Server itself).\n\n## Next Steps\n\nAt this point, you have a working full stack example of a Temporal Workflow running inside your Next.js app.\n\nYou can explore adding [Signals and Queries](/typescript/workflows/#signals-and-queries) to your Workflow, then adding a new API Route to call them.\nYou can choose to set up one API Route per Signal or Query, or have one API Route handle all of them, Temporal has no opinion on how you set up routing.\n\nAgain, for a fully working example, you can check our [samples-typescript repo](https://github.com/temporalio/samples-typescript/tree/main/nextjs-ecommerce-oneclick).\n","is_empty":false},{"file_name":"observability.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/observability.md","id":"typescript/observability","title":"How to use Temporal Observability features","description":"The observability section of the Temporal Developer's guide covers the many ways to view the current state of your Temporal Application—that is, ways to view which Workflow Executions are tracked by the Temporal Platform and the state of any specified Workflow Execution, either currently or at points of an execution","label":"Observability","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe observability section of the Temporal Developer's guide covers the many ways to view the current state of your [Temporal Application](/concepts/what-is-a-temporal-application)—that is, ways to view which [Workflow Executions](/workflows#workflow-execution) are tracked by the [Temporal Platform](/concepts/what-is-the-temporal-platform) and the state of any specified Workflow Execution, either currently or at points of an execution.\n\nThis section covers features related to viewing the state of the application, including:\n\n- [Metrics](#metrics)\n- [Tracing](#tracing)\n- [Logging](#logging)\n- [Visibility](#visibility)\n","is_empty":false},{"file_name":"package-initializer.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/package-initializer.md","id":"typescript/package-initializer","title":"@temporalio/create Package Initializer","description":"temporalio/create is an optional tool to set up a new Temporal project starting from our samples repo. `npx @temporalio/create@latest ./example`","label":"@temporalio/create","ssdi":[],"markdown_content":"\n> **@temporalio/create** [![NPM](https://img.shields.io/npm/v/@temporalio/create)](https://www.npmjs.com/package/@temporalio/create) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/create-project)\n\n`@temporalio/create` is an optional tool to set up a new Temporal project starting from [our samples repo](https://github.com/temporalio/samples-typescript).\n\n### Usage\n\n> See the [Getting started](/typescript/introduction/#getting-started) guide for basic usage and environment set up before running this tool.\n\n```bash\nnpx @temporalio/create@latest ./example\n```\n\n#### Optional flags\n\n- `--sample` — Which sample to bootstrap the app with. You can use the name of a sample\n  from [github.com/temporalio/samples-typescript](https://github.com/temporalio/samples-typescript) or use a GitHub URL. The URL can have a branch and/or subdirectory: for example, `https://github.com/your-org/your-app/tree/main/foo/bar`.\n- `--list-samples` — List available projects from [our samples repo](https://github.com/temporalio/samples-typescript).\n- `--use-yarn` — Use Yarn instead of npm.\n- `--[no-]git-init` - Initialize an empty git repository.\n- `--sdk-version <version>` - Specify which version of the `@temporalio/*` npm packages to use.\n\n### Project structure\n\nTypically, the generated project consists of 4 main components:\n\n- Workflows\n- Activities\n- Worker that executes Workflows and Activities\n- A script to execute a Workflow (using a Temporal Client)\n\n### Working with the created project\n\nMost sample projects come with these scripts:\n\n- `npm start` — Run the Worker with `ts-node` (does not require a compilation step)\n- `npm run start.watch` — Watch files with `nodemon` and re-run Worker on change\n- `npm run build` — Compile TypeScript\n- `npm run build.watch` — Watch files and compile on change\n- `npm run workflow` — Execute a Workflow\n\nIf you aren't familiar with the tradeoffs between these choices, we recommend primarily running `npm run start.watch` to have a live-reloading Worker good enough for most situations, and then `npm run workflow` to start individual Workflow Executions.\n","is_empty":false},{"file_name":"parent-close-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/parent-close-policy.md","id":"typescript/parent-close-policy","title":"How to set a Parent Close Policy","description":"A Parent Close Policy determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).","label":"Parent Close Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Parent Close Policy](/concepts/what-is-a-parent-close-policy) determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).\n\nThe default Parent Close Policy option is set to terminate the Child Workflow Execution.\n","is_empty":false},{"file_name":"patching.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/patching.md","id":"typescript/patching","title":"Patching TypeScript Workflows","description":"Any Workflow code change that affects the order in which commands are generated breaks this assumption. So we have to keep both the old and new code when migrating Workflows while they are still running.","label":"Patching (Migrating)","ssdi":[],"markdown_content":"\n## Alternatives\n\nBefore you explore our patching/versioning API, check if your needs can be addressed in other ways:\n\n- [Version Task Queue](#version-task-queue)\n- [Version Workflow Name](#version-workflow-name)\n\nBoth options mean that Workflows running `v1` code will never migrate to `v2` code: they will run `v1` code to completion.\nIf you would like to update Workflows running `v1` _while they are still running_, you [may need to \"patch in\" code](#do-i-need-to-patch).\n\n### Version Task Queue\n\nIf we're currently running our v1 Workflow code on Workers that poll on `queue1`, we can run v2 Workflow code on Workers that poll on `queue2`:\n\n1. Leave some Workers running your v1 `Workflow`, on the `queue1` Task Queue.\n1. Change your `Workflow` code and spin up new Workers that are polling a `queue2` Task Queue.\n1. Cut over your Clients to only call `Workflow` on `queue2` from now on.\n1. Remove your v1 Workers when all the v1 Workflows have completed.\n\n### Version Workflow Name\n\nWhile versioning the Task Queue is usually easier, we can also create a new version of a Workflow by copying it and changing its name:\n\n1. Copy `Workflow1`'s code to a `Workflow2` function and change what you need.\n1. Register `Workflow2` in your Workers alongside `Workflow1`.\n1. Cut over your Clients to only call `Workflow2` from now on.\n1. Remove `Workflow1` code when none of them are running anymore.\n\n## Do I need to Patch?\n\nYou may need to patch if:\n\n- You want to change the remaining logic of a Workflow while it is still running\n- If your new logic can result in a different execution path\n\nThis added `sleep()` can result in a different execution path:\n\n```ts\n// from v1\nexport async function yourWorkflow(value: number): Promise<number> {\n  await runActivity();\n  return 7;\n}\n\n// to v2\nexport async function yourWorkflow(value: number): Promise<number> {\n  await sleep('1 day');\n\n  await runActivity();\n  return 7;\n}\n```\n\nIf v2 is deployed while there's a Workflow on the `runActivity` step, when the Activity completes, the Worker will try to replay the Workflow (in order to continue Workflow execution), notice that the sleep command is called and doesn't match with the Workflow's Event History, and throw a non-determinism error.\n\nAdding a Signal Handler for a Signal type that has never been sent before does not need patching:\n\n```ts\n// from v1\nexport async function yourWorkflow(value: number): Promise<number> {\n  await sleep('1 days');\n  return value;\n}\n\n// to v2\nconst updateValueSignal = defineSignal<[number]>('updateValue');\n\nexport async function yourWorkflow(value: number): Promise<number> {\n  setHandler(updateValueSignal, (newValue) => (value = newValue));\n\n  await sleep('1 days');\n  return value;\n}\n```\n\n## Migrating Workflows in Patches\n\nWorkflow code has to be [deterministic](/typescript/determinism) by taking the same code path when replaying history events.\nAny Workflow code change that affects the order in which commands are generated breaks this assumption.\n\nSo we have to keep both the old and new code when migrating Workflows while they are still running:\n\n- When replaying, use the original code version that generated the ongoing event history.\n- When executing a new code path, always execute the\n  new code.\n\n<details>\n<summary>30 Min Video: Introduction to Versioning\n</summary>\n\nBecause we design for potentially long-running Workflows at scale, versioning with Temporal works differently than with other Workflow systems.\nWe explain more in this optional 30 minute introduction: [https://www.youtube.com/watch?v=kkP899WxgzY](https://www.youtube.com/watch?v=kkP899WxgzY)\n\n</details>\n\n## TypeScript SDK Patching API\n\nIn principle, the TypeScript SDK's patching mechanism works in a similar \"feature-flag\" fashion to the other SDK's, however, the \"versioning\" API has been updated to a notion of \"patching in\" code.\nThere are three steps to this reflecting three stages of migration:\n\n- Running v1 code with vFinal patched in concurrently\n- Running vFinal code with deprecation markers for vFinal patches\n- Running \"just\" vFinal code.\n\nThis is best explained in sequence (click through to follow along using our SDK sample).\n\nGiven an initial Workflow version `v1`:\n\n<!--SNIPSTART typescript-patching-1-->\n\n[patching-api/src/workflows-v1.ts](https://github.com/temporalio/samples-typescript/blob/master/patching-api/src/workflows-v1.ts)\n\n```ts\n// v1\nexport async function myWorkflow(): Promise<void> {\n  await activityA();\n  await sleep('1 days'); // arbitrary long sleep to simulate a long running workflow we need to patch\n  await activityThatMustRunAfterA();\n}\n```\n\n<!--SNIPEND-->\n\nWe decide to update our code and run `activityB` instead.\nThis is our desired end state, `vFinal`.\n\n<!--SNIPSTART typescript-patching-final-->\n\n[patching-api/src/workflows-vFinal.ts](https://github.com/temporalio/samples-typescript/blob/master/patching-api/src/workflows-vFinal.ts)\n\n```ts\n// vFinal\nexport async function myWorkflow(): Promise<void> {\n  await activityB();\n  await sleep('1 days');\n}\n```\n\n<!--SNIPEND-->\n\n**Problem: We cannot directly deploy `vFinal` until we know for sure there are no more running Workflows created using `v1` code.**\n\nInstead we must deploy `v2` (below) and use the [`patched`](https://typescript.temporal.io/api/namespaces/workflow#patched) function to check which version of the code should be executed.\n\nPatching is a three-step process:\n\n1. Patch in new code with `patched` and run it alongside old code\n2. Remove old code and `deprecatePatch`\n3. When you are sure all old Workflows are done executing, remove `deprecatePatch`\n\n### Step 1: Patch in new code\n\n`patched` inserts a marker into the Workflow history.\n\n![image](https://user-images.githubusercontent.com/6764957/139673361-35d61b38-ab94-401e-ae7b-feaa52eae8c6.png)\n\nDuring replay, when a Worker picks up a history with that marker it will fail the Workflow task when running Workflow code that does not emit the same patch marker (in this case `your-change-id`); therefore it is safe to deploy code from `v2` in a \"feature flag\" alongside the original version (`v1`).\n\n<!--SNIPSTART typescript-patching-2-->\n\n[patching-api/src/workflows-v2.ts](https://github.com/temporalio/samples-typescript/blob/master/patching-api/src/workflows-v2.ts)\n\n```ts\n// v2\nimport { patched } from '@temporalio/workflow';\nexport async function myWorkflow(): Promise<void> {\n  if (patched('my-change-id')) {\n    await activityB();\n    await sleep('1 days');\n  } else {\n    await activityA();\n    await sleep('1 days');\n    await activityThatMustRunAfterA();\n  }\n}\n```\n\n<!--SNIPEND-->\n\n### Step 2: Deprecate patch\n\nOnce we know that all Workflows started with `v1` code have completed we can [deprecate the patch](https://typescript.temporal.io/api/namespaces/workflow#deprecatepatch).\nDeprecated patches bridge between `v2` and `vFinal` (the end result), they work similarly to regular patches by recording a marker in the Workflow history, this marker does not fail replay when Workflow code does not emit it.\n\nIf while we're deploying `v3` (below) there are still live Workers running `v2` code and those Workers pick up Workflow histories generated by `v3`, they will safely use the patched branch.\n\n<!--SNIPSTART typescript-patching-3-->\n\n[patching-api/src/workflows-v3.ts](https://github.com/temporalio/samples-typescript/blob/master/patching-api/src/workflows-v3.ts)\n\n```ts\n// v3\nimport { deprecatePatch } from '@temporalio/workflow';\n\nexport async function myWorkflow(): Promise<void> {\n  deprecatePatch('my-change-id');\n  await activityB();\n  await sleep('1 days');\n}\n```\n\n<!--SNIPEND-->\n\n### Step 3: Solely deploy new code\n\n`vFinal` is safe to deploy once all `v2` or earlier Workflows are complete due to the assertion mentioned above.\n\n## Upgrading Workflow dependencies\n\nUpgrading Workflow dependencies (such as ones installed into `node_modules`) _might_ break determinism in unpredictable ways.\nWe recommended using a lock file (`package-lock.json` or `yarn.lock`) to fix Workflow dependency versions and gain control of when they're updated.\n","is_empty":false},{"file_name":"production-deploy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/production-deploy.md","id":"typescript/production-deploy","title":"Production Deploy Checklist for TypeScript SDK","description":"Recommended steps to take before deploying your Temporal app to production.","label":"Deploy Checklist","ssdi":[],"markdown_content":"\nThe following are recommended steps to take before deploying your Temporal application to production.\n\n## Production Temporal Cluster\n\nEither use Temporal Cloud ([join the waitlist](https://pages.temporal.io/cloud-early-access)) or deploy a self-hosted Temporal Cluster:\n\n- [Deployment guide](/kb/legacy-oss-prod-deploy/)\n- [Scaling checklist](/kb/legacy-oss-prod-deploy#checklist-for-scaling-temporal)\n\n## Linting and types\n\nIf you started your project with [`@temporalio/create`](/typescript/package-initializer), you already have our recommended TypeScript and ESLint configurations.\n\nIf you incrementally added Temporal to an existing app, we do recommend setting up linting and types as they will help catch bugs well before you ship them to production, and improve your development feedback loop.\nTake a look at [our recommended .eslintrc file](https://github.com/temporalio/samples-typescript/blob/main/.shared/.eslintrc.js) and tweak to taste.\n\n## Configure Connections and Namespaces\n\nTemporal Clients and Workers connect with Temporal Clusters through gRPC.\n\n- While you were developing locally, all these connections were set to their [default gRPC ports](/concepts/what-is-a-temporal-cluster) on localhost.\n- In production, you will need to configure address, Namespace, and encryption settings:\n\n  ```ts\n  export function getEnv(): Env {\n    return {\n      // NOT web.foo.bar.tmprl.cloud\n      address: 'foo.bar.tmprl.cloud',\n      namespace: 'foo.bar',\n      // in project root\n      clientCertPath: 'foobar.pem',\n      clientKeyPath: 'foobar.key',\n      // just to ensure task queue is same on client and worker, totally optional\n      taskQueue: process.env.TEMPORAL_TASK_QUEUE || 'hello-world-mtls',\n      // not usually needed:\n      // serverNameOverride: process.env.TEMPORAL_SERVER_NAME_OVERRIDE,\n      // serverRootCACertificatePath: process.env.TEMPORAL_SERVER_ROOT_CA_CERT_PATH,\n    };\n  }\n  ```\n\nFor more information, see [Connecting to Temporal Cloud (with mTLS)](/typescript/security#local-mtls-sample-tutorial).\n\n## Logging\n\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nFor more information about sending logs, see [Logging](/typescript/how-to-log-from-a-workflow-in-typescript).\n\n## Metrics and tracing\n\n### Options\n\nWorkers can emit metrics and traces. There are a few [telemetry options](https://typescript.temporal.io/api/interfaces/worker.TelemetryOptions) that can be provided to [`Runtime.install`](https://typescript.temporal.io/api/classes/worker.Runtime/#install). The common options are:\n\n- `metrics: { otel: { url } }`: The URL of a gRPC [OpenTelemetry collector](https://opentelemetry.io/docs/collector/).\n- `metrics: { prometheus: { bindAddress } }`: Address on the Worker host that will have metrics for [Prometheus](https://prometheus.io/) to scrape.\n\nTo set up tracing of Workflows and Activities, use our [opentelemetry-interceptors](/typescript/how-to-log-from-a-workflow-in-typescript#opentelemetry-tracing) package.\n\n### Monitoring\n\nHere is the [full list of SDK metrics](/references/sdk-metrics/). Some of them are used in the [Worker Tuning Guide](/dev-guide/worker-performance) to determine how to change your deployment configuration. The guide also assumes you track the host-level metrics that are important for measuring your application's load (for many applications, this is just CPU, but some applications may run into other bottlenecks—like with Activities that use a lot of memory, or open a lot of sockets). How you track host-level metrics depends on where you deploy your Workers.\n\n## Performance tuning\n\nIf you are experiencing system performance issues, make sure that you have checked that the bottleneck is not with your Temporal Cluster before turning to the performance of your Workers.\n\nWe endeavor to give you good defaults, so you don't have to worry about them, but there are a few key settings you may want to explore if you are pushing system limits:\n\n- [Worker Options](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions/#maxcachedworkflows), for example:\n  - `maxCachedWorkflows` to limit Workflow cache size and trade memory for CPU (biggest lever for Worker performance)\n  - `maxConcurrentActivityTaskExecutions` and other options for tuning concurrency\n  - `stickyQueueScheduleToStartTimeout` to determine how quickly Temporal stops trying to send work to Workers that are no longer present, via [Sticky Queues](/concepts/what-is-a-sticky-execution)\n  - See [Worker Tuning Guide](/dev-guide/worker-performance)\n- [Activity Timeouts and Retries](/typescript/activities#activity-timeouts) as you gain an understanding of Temporal and the services you rely on, you will likely want to adjust the timeouts and Retry Policy to reflect your desired behavior.\n  - Note that there are separate [Timeouts and Retry Policy](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#workflowruntimeout) at the Workflow level, but we do not encourage their usage unless you know what you are doing.\n- _to be completed as we get more user feedback_\n\n## Running in Docker\n\nWorkers based on TypeScript SDK can be deployed and run as Docker containers.\n\nAt this moment, we recommend usage of NodeJS 16 (note that there are known issues with NodeJS 18). Both `amd64` and `arm64` platforms are supported. A glibc-based image is required; musl-based images are _not_ supported (see below).\n\nThe easiest way to deploy a TypeScript SDK Worker on Docker is to start with the `node:16-bullseye` image. For example:\n\n```dockerfile\nFROM node:16-bullseye\n\nCOPY . /app\nWORKDIR /app\n\nRUN npm install --only=production \\\n    && npm run build\n\nCMD [\"build/worker.js\"]\n```\n\nFor smaller images and/or more secure deployments, it is also possible to use `-slim` Docker image variants (like `node:16-bullseye-slim`) or `distroless/nodejs` Docker images (like `gcr.io/distroless/nodejs:16`) with the below caveats.\n\n### Using `node:slim` images\n\n`node:slim` images do not contain some of the common packages found in regular images. This results in significantly smaller images.\n\nHowever, TypeScript SDK requires the presence of root TLS certificates (the `ca-certificates` package), which are not included in `slim` images. `ca-certificates` package is required even when connecting to a local Temporal Server or when using a server connection config that doesn't explicitly use TLS.\n\nFor this reason, the `ca-certificates` package must be installed during the construction of the Docker image. For example:\n\n```dockerfile\nFROM node:16-bulleyes-slim\n\nRUN apt-get update \\\n    && apt-get install -y ca-certificates \\\n    && rm -rf /var/lib/apt/lists/*\n\n# ... same as with regular image\n```\n\nFailure to install this dependency results in a `[TransportError: transport error]` runtime error, because the certificates cannot be verified.\n\n### Using `distroless/nodejs` images\n\n`distroless/nodejs` images include only the files that are strictly required to execute `node`. This results in even smaller images (approximately half the size of `node:slim` images). It also significantly reduces the surface of potential security issues that could be exploited by a hacker in the resulting Docker images.\n\nIt is generally possible and safe to execute TypeScript SDK Workers using `distroless/nodejs` images (unless your code itself requires dependencies that are not included in `distroless/nodejs`).\n\nNote however that some tools required for the build process (notably the `npm` command) are _not_ included in the `distroless/nodejs` image. This might result in various error messages during the Docker build.\n\nThe recommanded solution is to use a multi-step Dockerfile. For example:\n\n```dockerfile\n# -- BUILD STEP --\n\nFROM node:16-bulleyes AS builder\n\nCOPY . /app\nWORKDIR /app\n\nRUN npm install --only=production \\\n    && npm run build\n\n# -- RESULTING IMAGE --\n\nFROM gcr.io/distroless/nodejs:16\n\nCOPY --from=builder /app /app\nWORKDIR /app\n\nCMD [\"build/worker.js\"]\n```\n\n### Properly configure Node's memory in Docker\n\nBy default, `node` configures its maximum old-gen memory to 25% of the _physical memory_ of the machine on which it is executing, with a maximum of 4 GB. This is very likely inappropriate when running node in a Docker environment and can result in either under usage of available memory (`node` only uses a fraction of the memory allocated to the container) or overusage (`node` tries to use more memory than what is allocated to the container, which will eventually lead to the process being killed by the operating system).\n\nIt is therefore recommended that you always explicitly set the `--max-old-space-size` `node` argument to approximately 80% of the maximum size (in megabytes) that you want to allocate the `node` process. You might need some experimentation and adjustment to find the most appropriate value based on your specific application.\n\nIn practice, it is generally easier to provide this argument through the [`NODE_OPTIONS` environment variable](https://nodejs.org/api/cli.html#node_optionsoptions).\n\n### Do not use Alpine\n\nAlpine replaces glibc with musl, which is incompatible with the Rust core of the TypeScript SDK.\nIf you receive errors like below, it's probably because you are using Alpine.\n\n```sh\nError: Error loading shared library ld-linux-x86-64.so.2: No such file or directory (needed by /opt/app/node_modules/@temporalio/core-bridge/index.node)\n```\n\nOr like this:\n\n```sh\nError: Error relocating /opt/app/node_modules/@temporalio/core-bridge/index.node: __register_atfork: symbol not found\n```\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/queries.md","id":"typescript/queries","title":"How to develop with Queries","description":"A Query is a synchronous operation that is used to get the state of a Workflow Execution.","label":"Queries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Query](/concepts/what-is-a-query) is a synchronous operation that is used to get the state of a Workflow Execution.\n","is_empty":false},{"file_name":"register-namespaces.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/register-namespaces.md","id":"typescript/register-namespaces","title":"How to register Namespaces","description":"On Temporal Cloud, use the Temporal Cloud UI or tcld commands, and on self-hosted Temporal Cluster, use `tctl namespace register` or `RegisterNamespaceRequest` API to create Namespaces.","label":"Register Namespace","tags":["guide-context"],"ssdi":[],"markdown_content":"\nRegistering a Namespace creates a Namespace on the Temporal Cluster or Temporal Cloud.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to create Namespaces.\n\nOn self-hosted Temporal Cluster, you can register your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n","is_empty":false},{"file_name":"registering-types.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/registering-types.md","id":"typescript/registering-types","title":"How to register types","description":"How to register Workflow and Activity Types","label":"Register types","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it fails that Task.\nHowever, the failure of the Task does not cause the associated Workflow Execution to fail.\n","is_empty":false},{"file_name":"remove-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/remove-search-attributes.md","id":"typescript/remove-search-attributes","title":"How to remove a Search Attribute from a Workflow","description":"To remove a Search Attribute that was previously set, set it to an empty array.","label":"Remove Search Attribute","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array: `[]`.\n","is_empty":false},{"file_name":"replays.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/replays.md","id":"typescript/replays","title":"How to Replay a Workflow Execution","description":"Replay recreates the exact state of a Workflow Execution.","label":"Replay","tags":["guide-context"],"ssdi":[],"markdown_content":"\nReplay recreates the exact state of a Workflow Execution.\nYou can replay a Workflow from the beginning of its Event History.\n\nReplay succeeds only if the [Workflow Definition](/concepts/what-is-a-workflow-definition) is compatible with the provided history from a deterministic point of view.\n\nWhen you test changes to your Workflow Definitions, we recommend doing the following as part of your CI checks:\n\n1. Determine which Workflow Types or Task Queues (or both) will be targeted by the Worker code under test.\n2. Download the Event Histories of a representative set of recent open and closed Workflows from each Task Queue, either programmatically using the SDK client or via `tctl`.\n3. Run the Event Histories through replay.\n4. Fail CI if any error is encountered during replay.\n\nThe following are examples of fetching and replaying Event Histories:\n","is_empty":false},{"file_name":"required-activity-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/required-activity-timeout.md","id":"typescript/required-activity-timeout","title":"How to set the required Activity Timeouts","description":"The only required value that needs to be set is either a Schedule-To-Close Timeout or a Start-To-Close Timeout","label":"Required timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nActivity Execution semantics rely on several parameters.\nThe only required value that needs to be set is either a [Schedule-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) or a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout).\nThese values are set in the Activity Options.\n","is_empty":false},{"file_name":"run-a-dev-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/run-a-dev-worker.md","id":"typescript/run-a-dev-worker","title":"How to run Worker Processes","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run a dev Worker","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe [Worker Process](/concepts/what-is-a-worker-process) is where Workflow Functions and Activity Functions are executed.\n\n- Each [Worker Entity](/concepts/what-is-a-worker-entity) in the Worker Process must register the exact Workflow Types and Activity Types it may execute.\n- Each Worker Entity must also associate itself with exactly one [Task Queue](/concepts/what-is-a-task-queue).\n- Each Worker Entity polling the same Task Queue must be registered with the same Workflow Types and Activity Types.\n\nA [Worker Entity](/concepts/what-is-a-worker-entity) is the component within a Worker Process that listens to a specific Task Queue.\n\nAlthough multiple Worker Entities can be in a single Worker Process, a single Worker Entity Worker Process may be perfectly sufficient.\nFor more information, see the [Worker tuning guide](/dev-guide/worker-performance).\n\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it can make progress for either a Workflow Execution or an Activity Execution.\n","is_empty":false},{"file_name":"run-a-temporal-cloud-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/run-a-temporal-cloud-worker.md","id":"typescript/run-a-temporal-cloud-worker","title":"How to run a Temporal Cloud Worker","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run a Temporal Cloud Worker","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTo run a Worker that uses [Temporal Cloud](/cloud), you need to provide additional connection and client options that include the following:\n\n- An address that includes your [Cloud Namespace Name](/concepts/what-is-a-namespace) and a port number: `<Namespace>.<ID>.tmprl.cloud:<port>`.\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter- and intra-network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"run-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/run-an-activity.md","id":"typescript/run-an-activity","title":"Run an Activity","description":"If an Activity references its context, you need to mock that context when testing in isolation.","label":"Run an Activity","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIf an Activity references its context, you need to mock that context when testing in isolation.\n","is_empty":false},{"file_name":"schedule-backfill.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-backfill.md","id":"typescript/schedule-backfill","title":"How to Backfill a Scheduled Workflow","description":null,"label":"Backfill","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe backfill action executes Actions ahead of their specified time range. This command is useful when you need to execute a missed or delayed Action, or when you want to test the Workflow before its scheduled time.\n","is_empty":false},{"file_name":"schedule-create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-create.md","id":"typescript/schedule-create","title":"How to Create a Scheduled Workflow","description":null,"label":"Create","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe create action enables you to create a new Schedule. When you create a new Schedule, a unique Schedule ID is generated, which you can use to reference the Schedule in other Schedule commands.\n","is_empty":false},{"file_name":"schedule-delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-delete.md","id":"typescript/schedule-delete","title":"How to Delete a Scheduled Workflow","description":null,"label":"Delete","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe delete action enables you to delete a Schedule. When you delete a Schedule, it does not affect any Workflows that were started by the Schedule.\n","is_empty":false},{"file_name":"schedule-describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-describe.md","id":"typescript/schedule-describe","title":"How to Describe a Scheduled Workflow","description":null,"label":"Describe","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe describe action shows the current Schedule configuration, including information about past, current, and future Workflow Runs. This command is helpful when you want to get a detailed view of the Schedule and its associated Workflow Runs.\n","is_empty":false},{"file_name":"schedule-list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-list.md","id":"typescript/schedule-list","title":"How to List a Scheduled Workflow","description":null,"label":"List","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe list action lists all the available Schedules. This command is useful when you want to view a list of all the Schedules and their respective Schedule IDs.\n","is_empty":false},{"file_name":"schedule-pause.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-pause.md","id":"typescript/schedule-pause","title":"How to Pause a Scheduled Workflow","description":null,"label":"Pause","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe pause action enables you to pause and unpause a Schedule. When you pause a Schedule, all the future Workflow Runs associated with the Schedule are temporarily stopped. This command is useful when you want to temporarily halt a Workflow due to maintenance or any other reason.\n","is_empty":false},{"file_name":"schedule-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-to-close.md","id":"typescript/schedule-to-close","title":"How to set a Schedule-To-Close Timeout","description":"Use the Schedule-To-Close Timeout to limit the maximum duration of an Activity Execution.","label":"Schedule-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"schedule-to-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-to-start.md","id":"typescript/schedule-to-start","title":"How to set a Schedule-To-Start Timeout","description":"Use the Schedule-To-Start Timeout to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","label":"Schedule-To-Start Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.\n","is_empty":false},{"file_name":"schedule-trigger.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-trigger.md","id":"typescript/schedule-trigger","title":"How to Trigger a Scheduled Workflow","description":null,"label":"Trigger","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe trigger action triggers an immediate action with a given Schedule. By default, this action is subject to the Overlap Policy of the Schedule. This command is helpful when you want to execute a Workflow outside of its scheduled time.\n","is_empty":false},{"file_name":"schedule-update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedule-update.md","id":"typescript/schedule-update","title":"How to Update a Scheduled Workflow","description":null,"label":"Update","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe update action enables you to update an existing Schedule. This command is useful when you need to modify the Schedule's configuration, such as changing the start time, end time, or interval.\n","is_empty":false},{"file_name":"schedules.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/schedules.md","id":"typescript/schedules","title":"How to Schedule a Workflow","description":"Schedule a Workflow.","label":"Schedule a Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nScheduling Workflows is a crucial aspect of any automation process, especially when dealing with time-sensitive tasks. By scheduling a Workflow, you can automate repetitive tasks, reduce the need for manual intervention, and ensure timely execution of your business processes\n\nUse any of the following action to help Schedule a Workflow Execution and take control over your automation process.\n","is_empty":false},{"file_name":"search-attributes copy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/search-attributes copy.md","id":"typescript/search-attributes","title":"How to use Search Attributes","description":"Search Attributes enable complex List Filters to find the exact of Workflow Executions you are looking for.","label":"Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe typical method of retrieving a Workflow Execution is by its Workflow Id.\n\nHowever, sometimes you'll want to retrieve one or more Workflow Executions based on another property. For example, imagine you want to get all Workflow Executions of a certain type that have failed within a time range, so that you can start new ones with the same arguments.\n\nYou can do this with [Search Attributes](/concepts/what-is-a-search-attribute).\n\n- [Default Search Attributes](/concepts/what-is-a-search-attribute#default-search-attributes) like `WorkflowType`, `StartTime` and `ExecutionStatus` are automatically added to Workflow Executions.\n- _Custom Search Attributes_ can contain their own domain-specific data (like `customerId` or `numItems`).\n  - A few [generic Custom Search Attributes](/concepts/what-is-a-search-attribute#custom-search-attributes) like `CustomKeywordField` and `CustomIntField` are created by default in Temporal's [Docker Compose](/kb/all-the-ways-to-run-a-cluster#docker-compose).\n\nThe steps to using custom Search Attributes are:\n\n- Create a new Search Attribute in your Cluster using `tctl search-attribute create` or the Cloud UI.\n- Set the value of the Search Attribute for a Workflow Execution:\n  - On the Client by including it as an option when starting the Execution.\n  - In the Workflow by calling `UpsertSearchAttributes`.\n- Read the value of the Search Attribute:\n  - On the Client by calling `DescribeWorkflow`.\n  - In the Workflow by looking at `WorkflowInfo`.\n- Query Workflow Executions by the Search Attribute using a [List Filter](/concepts/what-is-a-list-filter):\n  - [In `tctl`](/tctl-v1/workflow/list).\n  - In code by calling `ListWorkflowExecutions`.\n\nHere is how to query Workflow Executions:\n","is_empty":false},{"file_name":"search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/search-attributes.md","id":"typescript/search-attributes","title":"Default and Custom Search Attributes in TypeScript Workflows","description":"Search Attributes enable eventually-consistent, business-logic-focused search and filter queries for Workflow Executions.","label":"Search Attributes","ssdi":[],"markdown_content":"\nSee: [Developer's guide ▶️ Observability ▶️ Visibility](/typescript/visibility).\n","is_empty":false},{"file_name":"security.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/security.md","id":"typescript/security","title":"Connection and Encryption in the TypeScript SDK","description":"A summary of the security features you should know as a TypeScript SDK user.","label":"Connection and Security","ssdi":[],"markdown_content":"\nTemporal Workers and Clients connect with your Temporal Cluster via gRPC, and must be configured securely for production.\nThere are three main features to know:\n\n- **Namespaces** help isolate code from each other\n- **TLS Encryption** helps encrypt code in transit\n- **Data Converter** helps encrypt code at rest (available soon)\n\nTemporal Server internally has [other Security features](/security), particularly Authorization.\n\nAn important part of Temporal's security model is that Temporal Server only manages state and time - it never actually sees or runs your Workflow/Activity code.\nCode is hosted by Temporal Workers that you run, and Temporal Server only sees inbound/outbound gRPC messages.\nThis eliminates a whole class of problems particularly when providing Temporal to multiple teams in your company, or when working with Temporal Cloud as a customer.\n\n## Namespaces\n\nimport Content from '../concepts/what-is-a-namespace.md'\n\n<Content />\n\nAll SDK connections (whether Workers or Clients) are to a specific namespace.\nIf not specified in [WorkflowClientOptions](https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions), this defaults to the `default` namespace.\n\n```ts\nconst connection = await Connection.connect();\n\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'your-custom-namespace', // defaults to 'default'\n});\n```\n\n## Encryption in transit with mTLS\n\nThere are two classes in the SDK that connect to the Temporal server, the [Worker](https://typescript.temporal.io/api/classes/worker.Worker) and the client [Connection](https://typescript.temporal.io/api/classes/client.Connection/).\nWhen instantiating either of them, you may choose whether to connect securely or not.\n\n- In order to connect to the server using TLS, set a _truthy_ value (`true` or [TLSConfig](https://typescript.temporal.io/api/interfaces/client.TLSConfig) for custom options) in the `tls` configuration option.\n- Use [`ServerOptions.tls`](https://typescript.temporal.io/api/interfaces/worker.ServerOptions#tls) when [creating](https://typescript.temporal.io/api/classes/worker.Worker/#create) a new Worker and\n  [`ConnectionOptions.tls`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions#tls) for the [`Connection`](https://typescript.temporal.io/api/classes/client.Connection) constructor.\n- The client connection also accepts [gRPC credentials](https://grpc.github.io/grpc/node/grpc.credentials.html) at [`ConnectionOptions.credentials`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions#tls) as long as `tls` is not also specified.\n\nA full example for Clients looks like this:\n\n```js\nimport { Connection, WorkflowClient } from '@temporalio/client';\n\nconst connection = await Connection.connect({\n  // defaults port to 7233 if not specified\n  address: 'foo.bar.tmprl.cloud',\n  tls: {\n    // set to true if TLS without mTLS\n    // See docs for other TLS options\n    clientCertPair: {\n      crt: clientCert,\n      key: clientKey,\n    },\n  },\n});\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'foo.bar', // as explained in Namespaces section\n});\n```\n\nA full example for Workers looks like this:\n\n```js\nimport { NativeConnection, Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  const connection = await NativeConnection.connect({\n    address: 'foo.bar.tmprl.cloud', // defaults port to 7233 if not specified\n    tls: {\n      // set to true if TLS without mTLS\n      // See docs for other TLS options\n      clientCertPair: {\n        crt: clientCert,\n        key: clientKey,\n      },\n    },\n  });\n\n  const worker = await Worker.create({\n    connection,\n    namespace: 'foo.bar', // as explained in Namespaces section\n    // ...\n  });\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\nIf you are using mTLS, is completely up to you how to get the `clientCert` and `clientKey` pair into your code, whether it is reading from filesystem, secrets manager, or both.\nJust keep in mind that they are whitespace sensitive and some environment variable systems have been known to cause frustration because they modify whitespace.\n\n<details>\n<summary>\n  Example code that works for local dev and for certs hosted on AWS S3\n</summary>\n\n```ts\nlet serverRootCACertificate: Buffer | undefined;\nlet clientCertificate: Buffer | undefined;\nlet clientKey: Buffer | undefined;\nif (certificateS3Bucket) {\n  const s3 = new S3client({ region: certificateS3BucketRegion });\n  serverRootCACertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: serverRootCACertificatePath,\n  });\n  clientCertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientCertPath,\n  });\n  clientKey = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientKeyPath,\n  });\n} else {\n  serverRootCACertificate = fs.readFileSync(serverRootCACertificatePath);\n  clientCertificate = fs.readFileSync(clientCertPath);\n  clientKey = fs.readFileSync(clientKeyPath);\n}\n```\n\n_Thanks to our Design Partner [Mina Abadir](https://twitter.com/abadir_) for sharing this.\\_\n\n</details>\n\n<span id=\"mtls-tutorial\"></span>\n\n### Connecting to Temporal Cloud (with mTLS)\n\n[The Hello World mTLS sample](https://github.com/temporalio/samples-typescript/tree/main/hello-world-mtls/) shows how to connect to a Temporal Cloud account.\nAfter signing up for Temporal Cloud, you should have a namespace, a server address, and a client certificate and key. Use the following environment variables to set up the sample:\n\n- **TEMPORAL_ADDRESS**: looks like `foo.bar.tmprl.cloud` (NOT web.foo.bar.tmprl.cloud)\n- **TEMPORAL_NAMESPACE**: looks like `foo.bar`\n- **TEMPORAL_CLIENT_CERT_PATH**: e.g. `/tls/ca.pem` (file contents start with -----BEGIN CERTIFICATE-----)\n- **TEMPORAL_CLIENT_KEY_PATH**: e.g. `/tls/ca.key` (file contents start with -----BEGIN PRIVATE KEY-----)\n\nYou can leave the remaining vars, like `TEMPORAL_SERVER_NAME_OVERRIDE` and `TEMPORAL_SERVER_ROOT_CA_CERT_PATH` blank.\nThere is another var, `TEMPORAL_TASK_QUEUE`, which the example defaults to `'hello-world-mtls'` but you can customize as needed.\n\n<details>\n<summary>Example environment settings</summary>\n\n```ts\nexport function getEnv(): Env {\n  return {\n    // NOT web.foo.bar.tmprl.cloud\n    address: 'foo.bar.tmprl.cloud',\n    namespace: 'foo.bar',\n    // in project root\n    clientCertPath: 'foobar.pem',\n    clientKeyPath: 'foobar.key',\n    // just to ensure task queue is same on client and worker, totally optional\n    taskQueue: process.env.TEMPORAL_TASK_QUEUE || 'hello-world-mtls',\n    // // not usually needed\n    // serverNameOverride: process.env.TEMPORAL_SERVER_NAME_OVERRIDE,\n    // serverRootCACertificatePath: process.env.TEMPORAL_SERVER_ROOT_CA_CERT_PATH,\n  };\n}\n```\n\n</details>\n\nIf you have misconfigured your connection somehow, you will get an opaque `[TransportError: transport error]` error. Read through your settings carefully and contact us if you are sure you have checked everything.\n\nNote the difference between the gRPC and Temporal Web endpoints:\n\n- The gRPC endpoint has a DNS address of `<Namespace_ID>.tmprl.cloud`, for example: `accounting-production.f45a2.tmprl.cloud`.\n- The Temporal Web endpoint is `web.<Namespace_ID>.tmprl.cloud`, for example: `https://web.accounting-production.f45a2.tmprl.cloud`.\n\n### Local mTLS sample tutorial\n\nFollow this tutorial for setting up mTLS (Mutual TLS authentication) with Temporal Server, Client, and Worker locally.\n**For Temporal Cloud customers, there is a separate tutorial above.**\n\n1. Set up Temporal Server with mTLS encryption locally\n   - Clone the [server samples repo](https://github.com/temporalio/samples-server/) and change to the `tls/tls-simple` directory\n   - Follow [these instructions](https://github.com/temporalio/samples-server/tree/master/tls/tls-simple#readme) to set up a local server with mTLS\n   - The sample does not register the default Namespace on startup, register it with: `docker exec -it tls-simple_temporal-admin-tools_1 tctl n re --retention 1 default`\n1. Configure your Temporal Client and Worker to connect with mTLS\n   - Scaffold a new Temporal project with `npx @temporalio/create@latest` using the `hello-world-mtls` template, or copy the relevant configuration from the snippets below into an existing project.\n   - Export the required environment variables:\n     ```bash\n     export TEMPORAL_ADDRESS=localhost\n     export TEMPORAL_NAMESPACE=default\n     export TEMPORAL_CLIENT_CERT_PATH=/path/to/samples-server/tls/tls-simple/certs/client.pem\n     export TEMPORAL_CLIENT_KEY_PATH=/path/to/samples-server/tls/tls-simple/certs/client.key\n     # just for the local mTLS sample\n     export TEMPORAL_SERVER_ROOT_CA_CERT_PATH=/path/to/samples-server/tls/tls-simple/certs/ca.cert\n     export TEMPORAL_SERVER_NAME_OVERRIDE=tls-sample\n     ```\n1. Test the connection with `npm run start.watch` and `npm run workflow`.\n   You should see everything working as per the regular Hello World tutorial.\n\nTemporal has no opinions on production deployment strategy other than the connections and architecture displayed here.\n\n## Encryption at rest with Payload Codec\n\n- [Data Converter ➡️ Encryption](/concepts/what-is-a-data-converter#encryption)\n- [Data Converters in TypeScript ➡️ Encryption](/typescript/data-converters#encryption)\n","is_empty":false},{"file_name":"send-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/send-query.md","id":"typescript/send-query","title":"How to send a Query","description":"Queries are sent from a Temporal Client.","label":"Send Query","tags":["guide-context"],"ssdi":[],"markdown_content":"\nQueries are sent from a Temporal Client.\n","is_empty":false},{"file_name":"send-signal-from-client.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/send-signal-from-client.md","id":"typescript/send-signal-from-client","title":"How to send a Signal from a Temporal Client","description":"When a Signal is sent successfully from the Temporal Client, the WorkflowExecutionSignaled Event appears in the Event History of the Workflow that receives the Signal.","label":"Send Signal from Client","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWhen a Signal is sent successfully from the Temporal Client, the [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Event History of the Workflow that receives the Signal.\n","is_empty":false},{"file_name":"send-signal-from-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/send-signal-from-workflow.md","id":"typescript/send-signal-from-workflow","title":"How to send a Signal from a Workflow","description":"A Workflow can send a Signal to another Workflow, in which case it's called an External Signal","label":"Send Signal from Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.\n\nWhen an External Signal is sent:\n\n- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.\n- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.\n","is_empty":false},{"file_name":"set-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/set-custom-search-attributes.md","id":"typescript/set-custom-search-attributes","title":"How to set custom Search Attributes","description":"After you've created custom Search Attributes in your Cluster (using `tctl` or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.","label":"Custom Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAfter you've created custom Search Attributes in your Cluster (using `tctl search-attribute create`or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.\n","is_empty":false},{"file_name":"set-task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/set-task-queue.md","id":"typescript/set-task-queue","title":"How to set a Workflow's Task Queue","description":"In most SDKs, the only Workflow Option that must be set is the name of the Task Queue.","label":"Set Task Queue","tags":["guide-context"],"ssdi":[],"markdown_content":"\nIn most SDKs, the only Workflow Option that must be set is the name of the [Task Queue](/concepts/what-is-a-task-queue).\n\nFor any code to execute, a Worker Process must be running that contains a Worker Entity that is polling the same Task Queue name.\n","is_empty":false},{"file_name":"set-workflow-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/set-workflow-id.md","id":"typescript/set-workflow-id","title":"How to set a Workflow Id","description":"Although it is not required, we recommend providing your own Workflow Id that maps to a business process or business entity identifier, such as an order identifier or customer identifier.","label":"Workflow Id","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAlthough it is not required, we recommend providing your own [Workflow Id](/concepts/what-is-a-workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.\n","is_empty":false},{"file_name":"side-effects.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/side-effects.md","id":"typescript/side-effects","title":"Side Effects","description":"A Side Effect is used to produce non-deterministic code, such as generating a UUID or a random number.","label":"Side Effects","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSide Effects are used to execute non-deterministic code, such as generating a UUID or a random number, without compromising deterministic in the Workflow. This is done by storing the non-deterministic results of the Side Effect into the Workflow [Event History](/workflows/#event-history).\n\nA Side Effect does not re-execute during a Replay. Instead, it returns the recorded result from the Workflow Execution Event History.\n\nSide Effects should not fail. An exception that is thrown from the Side Effect causes failure and retry of the current Workflow Task.\n\nAn Activity or a Local Activity may also be used instead of a Side effect, as its result is also persisted in Workflow Execution History.\n\n:::note\n\nYou shouldn’t modify the Workflow state inside a Side Effect function, because it is not reexecuted during Replay. Side Effect function should be used to return a value.\n\n:::\n","is_empty":false},{"file_name":"signal-with-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/signal-with-start.md","id":"typescript/signal-with-start","title":"How to Signal-With-Start","description":"Signal-With-Start is used from the Client","label":"Signal-With-Start","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSignal-With-Start is used from the Client.\nIt takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.\n\nIf there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/signals.md","id":"typescript/signals","title":"How to develop with Signals","description":"A Signal is a message sent to a running Workflow Execution","label":"Signals","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA [Signal](/concepts/what-is-a-signal) is a message sent to a running Workflow Execution.\n\nSignals are defined in your code and handled in your Workflow Definition.\nSignals can be sent to Workflow Executions from a Temporal Client or from another Workflow Execution.\n","is_empty":false},{"file_name":"single-entity-pattern.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/single-entity-pattern.md","id":"typescript/single-entity-pattern","title":"Single-entity design pattern in TypeScript","description":"An example that demonstrates how to represent a single entity with a Workflow.","label":"Single-entity pattern","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe following is a simple pattern that represents a single entity.\nIt tracks the number of iterations regardless of frequency, and calls `continueAsNew` while properly handling pending updates from Signals.\n\n```tsx\ninterface Input {\n  /* Define your Workflow input type here */\n}\ninterface Update {\n  /* Define your Workflow update type here */\n}\n\nconst MAX_ITERATIONS = 1;\n\nexport async function entityWorkflow(\n  input: Input,\n  isNew = true,\n): Promise<void> {\n  try {\n    const pendingUpdates = Array<Update>();\n    setHandler(updateSignal, (updateCommand) => {\n      pendingUpdates.push(updateCommand);\n    });\n\n    if (isNew) {\n      await setup(input);\n    }\n\n    for (let iteration = 1; iteration <= MAX_ITERATIONS; ++iteration) {\n      // Ensure that we don't block the Workflow Execution forever waiting\n      // for updates, which means that it will eventually Continue-As-New\n      // even if it does not receive updates.\n      await condition(() => pendingUpdates.length > 0, '1 day');\n\n      while (pendingUpdates.length) {\n        const update = pendingUpdates.shift();\n        await runAnActivityOrChildWorkflow(update);\n      }\n    }\n  } catch (err) {\n    if (isCancellation(err)) {\n      await CancellationScope.nonCancellable(async () => {\n        await cleanup();\n      });\n    }\n    throw err;\n  }\n  await continueAsNew<typeof entityWorkflow>(input, false);\n}\n```\n","is_empty":false},{"file_name":"skip-time-set-up.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/skip-time-set-up.md","id":"typescript/skip-time-set-up","title":"Set up time skipping","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Setting up","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to set up the time-skipping test framework in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/skip-time-skip-activities.md","id":"typescript/skip-time-skip-activities","title":"Skip time in Activities","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time in Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time in Activities in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-automatically.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/skip-time-skip-automatically.md","id":"typescript/skip-time-skip-automatically","title":"Skip time automatically","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Automatic method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can skip time automatically in the SDK of your choice.\nStart a test server process that skips time as needed.\nFor example, in the time-skipping mode, Timers, which include sleeps and conditional timeouts, are fast-forwarded except when Activities are running.\n","is_empty":false},{"file_name":"skip-time-skip-manually.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/skip-time-skip-manually.md","id":"typescript/skip-time-skip-manually","title":"Skip time manually","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Manual method","tags":["guide-context"],"ssdi":[],"markdown_content":"\nLearn to skip time manually in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/skip-time.md","id":"typescript/skip-time","title":"How to skip time","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSome long-running Workflows can persist for months or even years.\nImplementing the test framework allows your Workflow code to skip time and complete your tests in seconds rather than the Workflow's specified amount.\n\nFor example, if you have a Workflow sleep for a day, or have an Activity failure with a long retry interval, you don't need to wait the entire length of the sleep period to test whether the sleep function works.\nInstead, test the logic that happens after the sleep by skipping forward in time and complete your tests in a timely manner.\n\n:::note\n\nSkipping time is not relevant to unit testing Workflow code, because in that case you’re mocking functions that take time, like sleep and Activity calls.\n\n:::\n\nThe test framework included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.\nTime is a global property of an instance of `TestWorkflowEnvironment`: skipping time (either automatically or manually) applies to all currently running tests.\nIf you need different time behaviors for different tests, run your tests in a series or with separate instances of the test server.\nFor example, you could run all tests with automatic time skipping in parallel, and then all tests with manual time skipping in series, and then all tests without time skipping in parallel.\n","is_empty":false},{"file_name":"spawning-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/spawning-activities.md","id":"typescript/spawning-activities","title":"How to start an Activity Execution","description":"Calls to spawn Activity Executions are written within a Workflow Definition.","label":"Activity Execution","tags":["guide-context"],"ssdi":[],"markdown_content":"\nCalls to spawn [Activity Executions](/concepts/what-is-an-activity-execution) are written within a [Workflow Definition](/concepts/what-is-a-workflow-definition).\nThe call to spawn an Activity Execution generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nThis results in the set of three [Activity Task](/concepts/what-is-an-activity-task) related Events ([ActivityTaskScheduled](/references/events/#activitytaskscheduled), [ActivityTaskStarted](/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.\n\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the Execution history.\nThe entire Execution history is transferred from the Temporal service to Workflow Workers when a Workflow state needs to recover.\nA large Execution history can thus adversely impact the performance of your Workflow.\n\nTherefore, be mindful of the amount of data you transfer through Activity invocation parameters or Return Values.\nOtherwise, no additional limitations exist on Activity implementations.\n","is_empty":false},{"file_name":"spawning-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/spawning-workflows.md","id":"typescript/spawning-workflows","title":"How to start a Workflow Execution","description":"Workflow Execution semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.","label":"Start Workflow Execution","tags":["guide-context"],"ssdi":[],"markdown_content":"\n[Workflow Execution](/workflows#workflow-execution) semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.\n\nIn the examples below, all Workflow Executions are started using a Temporal Client.\nTo spawn Workflow Executions from within another Workflow Execution, use either the [Child Workflow](#child-workflows) or External Workflow APIs.\n\nSee the [Customize Workflow Type](#customize-workflow-type) section to see how to customize the name of the Workflow Type.\n\nA request to spawn a Workflow Execution causes the Temporal Cluster to create the first Event ([WorkflowExecutionStarted](/references/events/#workflowexecutionstarted)) in the Workflow Execution Event History.\nThe Temporal Cluster then creates the first Workflow Task, resulting in the first [WorkflowTaskScheduled](/references/events/#workflowtaskscheduled) Event.\n","is_empty":false},{"file_name":"start-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/start-to-close.md","id":"typescript/start-to-close","title":"How to set a Start-To-Close Timeout","description":"Use the Start-To-Close Timeout to limit the maximum duration of a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) to limit the maximum duration of a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n","is_empty":false},{"file_name":"test-functions-assert-in-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/test-functions-assert-in-workflow.md","id":"typescript/test-functions-assert-in-workflow","title":"Assert in Workflow","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Assert in Workflow","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe `assert` statement is a convenient way to insert debugging assertions into the Workflow context.\n\nThe `assert` method is available in Python and TypeScript.\n","is_empty":false},{"file_name":"test-functions-in-workflow-context.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/test-functions-in-workflow-context.md","id":"typescript/test-functions-in-workflow-context","title":"Test functions in Workflow context","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Workflow context","tags":["guide-context"],"ssdi":[],"markdown_content":"\nFor a function or method to run in the Workflow context (where it’s possible to get the current Workflow info, or running inside the sandbox in the case of TypeScript or Python), it needs to be run by the Worker as if it were a Workflow.\n\n:::note\n\nThis section is applicable in Python and TypeScript.\nIn Python, we allow testing of Workflows only and not generic Workflow-related code.\n\n:::\n","is_empty":false},{"file_name":"testing copy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/testing copy.md","id":"typescript/testing","title":"Testing","description":"The Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.","label":"Testing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.\n\nIn the context of Temporal, you can create these types of automated tests:\n\n- **End-to-end**: Running a Temporal Server and Worker with all its Workflows and Activities; starting and interacting with Workflows from a Client.\n- **Integration**: Anything between end-to-end and unit testing.\n  - Running Activities with mocked Context and other SDK imports (and usually network requests).\n  - Running Workers with mock Activities, and using a Client to start Workflows.\n  - Running Workflows with mocked SDK imports.\n- **Unit**: Running a piece of Workflow or Activity code (a function or method) and mocking any code it calls.\n\nWe generally recommend writing the majority of your tests as integration tests.\n\nBecause the test server supports skipping time, use the test server for both end-to-end and integration tests with Workers.\n","is_empty":false},{"file_name":"testing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/testing-activities.md","id":"typescript/testing-activities","title":"Testing Activities","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Activities","tags":["guide-context"],"ssdi":[],"markdown_content":"\nAn Activity can be tested with a mock Activity environment, which provides a way to mock the Activity context, listen to Heartbeats, and cancel the Activity.\nThis behavior allows you to test the Activity in isolation by calling it directly, without needing to create a Worker to run the Activity.\n","is_empty":false},{"file_name":"testing-frameworks.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/testing-frameworks.md","id":"typescript/testing-frameworks","title":"Test frameworks","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test frameworks","tags":["guide-context"],"ssdi":[],"markdown_content":"\nSome SDKs have support or examples for popular test frameworks, runners, or libraries.\n","is_empty":false},{"file_name":"testing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/testing-workflows.md","id":"typescript/testing-workflows","title":"Testing Workflows","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Workflows","tags":["guide-context"],"ssdi":[],"markdown_content":"","is_empty":false},{"file_name":"testing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/testing.md","id":"typescript/testing","title":"Testing TypeScript Workflows","label":"Testing","ssdi":[],"markdown_content":"\n:::note Sample available\nOur samples repo contains examples of [testing with Jest](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/workflows.test.ts) and [Mocha](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/mocha/workflows.test.ts)\n:::\n\nThe TypeScript SDK comes with an optional test framework (npm `@temporalio/testing`).\n\nUpon installation, it will automatically download a test server with time skipping support (more on that later).\n\nThe test framework provides utilities for testing both Activities and Workflows.\n\n## Testing Activities\n\nActivities can be tested with [`MockActivityEnvironment`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment)\n\nThe constructor accepts an optional partial Activity [`Info`](https://typescript.temporal.io/api/classes/activity.Info) object in case any info fields are needed for the test.\n\n### Running an activity in Context\n\n[`MockActivityEnvironment.run()`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment#run) runs a function in an Activity [Context](https://typescript.temporal.io/api/classes/activity.Context).\n\n```ts\nimport { Context } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\n\nconst env = new MockActivityEnvironment({ attempt: 2 });\nconst result = await env.run(\n  async (x) => x + Context.current().info.attempt,\n  2,\n);\nassert.equal(result, 4);\n```\n\n### Heartbeats and cancellation\n\n`MockActivityEnvironment` is an [`EventEmitter`](https://nodejs.org/api/events.html#class-eventemitter) that emits a `heartbeat` event which you can use to listen for heartbeats emitted by the Activity.\n\n> NOTE: When run by a `Worker`, heartbeats are throttled to avoid overloading the server.\n> `MockActivityEnvironment`, however, does not apply any throttling.\n\nIt also exposes a `cancel` method which cancels the Activity Context.\n\n```ts\nimport { CancelledFailure, Context } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\n\nconst env = new MockActivityEnvironment();\n\nenv.on('heartbeat', (d: unknown) => {\n  if (d === 6) {\n    env.cancel('test');\n  }\n});\n\nawait assert.rejects(\n  () =>\n    env.run(async () => {\n      Context.current().heartbeat(6);\n      await Context.current().sleep(100); // <- sleep is cancellation aware\n    }),\n  (err) => {\n    assert.ok(err instanceof CancelledFailure);\n  },\n);\n```\n\n## Testing Workflows\n\nWorkflows can be tested with [`TestWorkflowEnvironment`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment).\n\nA typical test suite would set up a single instance of the test environment to be reused in all tests (e.g. in a [Mocha](https://mochajs.org/) `before()` hook or a [Jest](https://jestjs.io/) `beforeAll` hook).\n\nWhen creating an environment, [`TestWorkflowEnvironment.create`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#create) will automatically start a test server that you can access with [`client`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#client) and [`nativeConnection`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#nativeconnection).\n\n### Example setup\n\n`beforeAll` and `afterAll` are injected by `jest`. To use mocha instead, change them to `before` and `after`, and import:\n\n```ts\nimport { after, before } from 'mocha';\n```\n\n```ts\nimport { TestWorkflowEnvironment } from '@temporalio/testing';\nimport { Worker } from '@temporalio/worker';\nimport { v4 as uuid4 } from 'uuid';\nimport type * as Activities from './activities'; // Uses types to ensure our mock signatures match\nimport { httpWorkflow } from './workflows';\n\nlet testEnv: TestWorkflowEnvironment;\n\nbeforeAll(async () => {\n  testEnv = await TestWorkflowEnvironment.create();\n});\n\nafterAll(async () => {\n  await testEnv?.teardown();\n});\n```\n\n### Mocking Activities\n\nSince the `TestWorkflowEnvironment` is meant for testing Workflows, you'd typically want to mock your Activities in tests to avoid generating side effects.\n\n```ts\ntest('httpWorkflow with mock activity', async () => {\n  const { client, nativeConnection } = testEnv;\n\n  // Implement only the relevant activities for this workflow\n  const mockActivities: Partial<typeof Activities> = {\n    makeHTTPRequest: async () => '99',\n  };\n  const worker = await Worker.create({\n    connection: nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('./workflows'),\n    activities: mockActivities,\n  });\n  const result = await worker.runUntil(\n    await client.workflow.execute(httpWorkflow, {\n      workflowId: uuid4(),\n      taskQueue: 'test',\n    }),\n  );\n  assert.strictEqual(result, 'The answer is 99');\n});\n```\n\n### Time skipping in Workflows\n\nThe built-in test server automatically \"skips\" (fast forwards) time when no Activities are executing.\nThe test server starts in \"normal\" time, using the `TestWorkflowEnvironment.client.workflow` `execute` or `result`\nmethods switch the test server to \"skipped\" time mode until the Workflow completes.\nIf a Workflow sleeps for days, running it in the test environment will cause it to complete almost immediately.\n\n`workflows.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\n\nexport async function sleeperWorkflow() {\n  await sleep('1 day');\n}\n```\n\n`test.ts`\n\n```ts\ntest('sleep completes almost immediately', async () => {\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('../workflows'),\n  });\n  // Does not wait an entire day\n  await worker.runUntil(\n    testEnv.client.workflow.execute(sleeperWorkflow, {\n      workflowId: uuid(),\n      taskQueue: 'test',\n    }),\n  );\n});\n```\n\n### Time skipping in Tests\n\nYou can also call `testEnv.sleep()` from your test code to advance the test server's time.\nThis is useful for testing intermediate state, or for testing infinite Workflows.\nHowever, to advance time using `testEnv.sleep()`, you need to start the Workflow using `start()`, not `execute()`.\n\n`workflow.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\nimport { defineQuery, setHandler } from '@temporalio/workflow';\n\nexport const daysQuery = defineQuery('days');\n\nexport async function sleeperWorkflow() {\n  let numDays = 0;\n\n  setHandler(daysQuery, () => numDays);\n\n  for (let i = 0; i < 100; ++i) {\n    await sleep('1 day');\n    ++numDays;\n  }\n}\n```\n\n`test.ts`\n\n```ts\ntest('advancing time using `testEnv.sleep()`', async () => {\n  // Important: `start()` starts the test server in \"normal\" mode,\n  // not skipped time mode. If you don't advance time using `testEnv.sleep()`,\n  // then `sleeperWorkflow()` will run for days.\n  handle = await testEnv.client.workflow.start(sleeperWorkflow, {\n    taskQueue,\n    workflowId: uuidv4(),\n  });\n\n  let numDays = await handle.query(daysQuery);\n  assert.strictEqual(numDays, 0);\n\n  // Advance the test server's time by 25 hours and assert that\n  // `sleeperWorkflow()` correctly incremented `numDays`.\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.strictEqual(numDays, 1);\n\n  // Advance the test server's time by an additional 25 hours and\n  // assert that `sleeperWorkflow()` incremented `numDays` a second time.\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.strictEqual(numDays, 2);\n});\n```\n\n### Time skipping in Activities\n\nWhen an Activity is executing time switches back to \"normal\",\n[`TestWorkflowEnvironment.sleep`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment/#sleep)\ncan be used outside of Workflow code to skip time.\n\n<details>\n<summary>\nWorkflow implementation\n</summary>\n\n<!--SNIPSTART typescript-timer-reminder-workflow-->\n\n[timer-examples/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/timer-examples/src/workflows.ts)\n\n```ts\nexport async function processOrderWorkflow({\n  orderProcessingMS,\n  sendDelayedEmailTimeoutMS,\n}: ProcessOrderOptions): Promise<string> {\n  let processing = true;\n  // Dynamically define the timeout based on given input\n  const { processOrder } = proxyActivities<ReturnType<typeof createActivities>>(\n    {\n      startToCloseTimeout: orderProcessingMS,\n    },\n  );\n\n  const processOrderPromise = processOrder().then(() => {\n    processing = false;\n  });\n\n  await Promise.race([processOrderPromise, sleep(sendDelayedEmailTimeoutMS)]);\n\n  if (processing) {\n    await sendNotificationEmail();\n\n    await processOrderPromise;\n  }\n\n  return 'Order completed!';\n}\n```\n\n<!--SNIPEND-->\n\n</details>\n\n```ts\ntest('countdownWorkflow sends reminder email if processing does not complete in time', async () => {\n  // NOTE: this tests doesn't actually take days to complete, the test environment starts a test\n  // server that automatically skips time when there are no running activities.\n  let emailSent = false;\n  // createActivities defintion omitted for brevity\n  const activities: ReturnType<typeof createActivities> = {\n    async processOrder() {\n      // test server switches to \"normal\" time while an activity is executing.\n      // Call `sleep` to skip time by \"2 days\".\n      await testEnv.sleep('2 days');\n    },\n    async sendNotificationEmail() {\n      emailSent = true;\n    },\n  };\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('../workflows'),\n    activities,\n  });\n  await worker.runUntil(\n    testEnv.client.workflow.execute(processOrderWorkflow, {\n      workflowId: uuid(),\n      taskQueue: 'test',\n      args: [\n        {\n          orderProcessingMS: ms('3 days'),\n          sendDelayedEmailTimeoutMS: ms('1 day'),\n        },\n      ],\n    }),\n  );\n  assert.strictEqual(emailSent, true);\n});\n```\n\n### Test arbitrary functions in Workflow context\n\nIn case you need to test a function in your Workflow code that's not exported in [`workflowsPath`](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions/#workflowspath), export it in a different path and register it with the Worker.\n\n`workflows/file-with-workflow-function-to-test.ts`\n\n```ts\nimport * as wf from '@temporalio/workflow';\nimport { someWorkflowToRunAsChild } from './some-workflow';\n\nexport { someWorkflowToRunAsChild }; // Must be re-exported here for Worker registration\n\nexport async function functionToTest() {\n  await wf.executeChild(someWorkflowToRunAsChild);\n  // Other test code\n}\n```\n\n`test.ts`\n\n```ts\nconst worker = await Worker.create({\n  ...someOtherOptions,\n  connection: testEnv.nativeConnection,\n  workflowsPath: require.resolve(\n    './workflows/file-with-workflow-function-to-test',\n  ),\n});\n\nawait worker.runUntil(\n  testEnv.client.workflow.execute(functionToTest, workflowOptions),\n);\n```\n\n### Asserting from Workflow code\n\nIn some cases it's useful to assert directly in Workflow context.\n\nThe Workflow context is injected with the Node.js [`assert`](https://nodejs.org/api/assert.html) module and can be imported with `import assert from 'assert'`.\n\nBy default, failed `assert` statements throw `AssertionError`s which cause Workflow Tasks to fail and be indefinitely retried.\nTo prevent this, use `workflowInterceptorModules` from `@temporalio/testing`. These interceptors catch `AssertionError`s and turn them into `ApplicationFailure`s that fail the entire Workflow Execution (not just the Workflow Task).\n\n`workflows/file-with-workflow-function-to-test.ts`\n\n```ts\nimport assert from 'assert';\n\nexport async function functionToTest() {\n  assert.ok(false);\n}\n```\n\n`test.ts`\n\n```ts\nimport {\n  TestWorkflowEnvironment,\n  workflowInterceptorModules,\n} from '@temporalio/testing';\n\nconst worker = await Worker.create({\n  ...someOtherOptions,\n  connection: testEnv.nativeConnection,\n  interceptors: {\n    workflowModules: workflowInterceptorModules,\n  },\n  workflowsPath: require.resolve(\n    './workflows/file-with-workflow-function-to-test',\n  ),\n});\n\nawait worker.runUntil(\n  testEnv.client.workflow.execute(functionToTest, workflowOptions), // Throws WorkflowFailedError\n);\n```\n\n### Testing with Jest\n\nThere are a couple of caveats for testing with Jest:\n\n1. The Temporal TypeScript SDK only supports Jest `>= 27.0.0`.\n1. Make sure you run Jest with [`testEnvironment: 'node'`](https://jestjs.io/docs/configuration#testenvironment-string). `testEnvironment: 'jsdom'` is not supported.\n","is_empty":false},{"file_name":"timers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/timers.md","id":"typescript/timers","title":"What is a Timer?","description":"A Timer lets a Workflow sleep for a fixed time period.","label":"Timers","tags":["guide-context","timers","sleep"],"ssdi":[],"markdown_content":"\nA Workflow can set a durable timer for a fixed time period.\nIn some SDKs, the function is called `sleep()`, and in others, it's called `timer()`.\n\nA Workflow can sleep for months.\nTimers are persisted, so even if your Worker or Temporal Cluster is down when the time period completes, as soon as your Worker and Cluster are back up, the `sleep()` call will resolve and your code will continue executing.\n\nSleeping is a resource-light operation: it does not tie up the process, and you can run millions of Timers off a single Worker.\n","is_empty":false},{"file_name":"tracing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/tracing.md","id":"typescript/tracing","title":"How to setup Tracing","description":"Tracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.","label":"Tracing","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.\n\nTemporal Web's tracing capabilities mainly track Activity Execution within a Temporal context. If you need custom tracing specific for your use case, you should make use of context propagation to add tracing logic accordingly.\n\nFor information about Workflow tracing, see [Tracing Temporal Workflows with DataDog](https://spiralscout.com/blog/tracing-temporal-workflow-with-datadog).\n\nFor information about how to configure exporters and instrument your code, see [Tracing Temporal Services with OTEL](https://github.com/temporalio/temporal/blob/master/develop/docs/tracing.md).\n","is_empty":false},{"file_name":"troubleshoot-issues.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/troubleshoot-issues.md","id":"typescript/troubleshoot-issues","title":"How to troubleshoot common issues in the TypeScript SDK","description":"This guide helps you troubleshoot various common issues with code that uses the TypeScript SDK.","label":"Troubleshoot common issues","tags":["guide-context"],"ssdi":[],"markdown_content":"\n<!-- The following was ported from \\docs-src\\typescript\\troubleshooting.md -->\n\n### Two locations to watch\n\n- Workflow Errors are reflected in Temporal Web.\n- Worker errors and logs are reflected in the terminal.\n\nIf something isn't behaving the way you expect, make sure to check both locations for helpful error messages.\n\n### Stale Workflows\n\nIf you are developing Workflows and finding that code isn't executing as expected, the first place to look is whether old Workflows are still running.\n\nIf those old Workflows have the same name and are on the same task queue, Temporal will try to continue executing them on your new code by design.\nYou may get errors that make no sense to you because\n\n- Temporal is trying to execute old Workflow code that no longer exists in your codebase, or\n- your new Client code is expecting Temporal to execute old Workflow/Activity code it doesn't yet know about.\n\nThe biggest sign that this is happening is if you notice Temporal is acting non-deterministically: running the same Workflow twice gets different results.\n\nStale workflows are usually a non-issue because the errors generated are just noise from code you no longer want to run.\nIf you need to terminate old stale Workflows, you can do so with Temporal Web or `tctl`.\n\n### Workflow/Activity registration errors\n\n**If your Workflows or Activities are not imported or spelled correctly**, here are some errors we've seen:\n\n- `ApplicationFailure: 'MyFunction' is not a function`\n- `Workflow did not register a handler for MyQuery`\n\nDouble check that your Workers are registering the right Workflow and Activity Definitions (function names) on the right Task Queues.\n\n**If you are running Temporal in a monorepo**, then your `node_modules` may be in a different location than where Temporal expects to find it by default, which results in errors like:\n\n```bash\n[ERROR] Module not found: Error: Can't resolve '@temporalio/workflow/lib/worker-interface.js' in '/src'\n```\n\nOur [Next.js tutorial](https://learn.temporal.io/tutorials/typescript/nextjs) is written for people setting up Temporal **within an existing monorepo**, which may be of use here.\n\nWhen you pass a `workflowsPath`, our Webpack config expects to find `node_modules` in the same or a parent/ancestor directory.\n\n**If you are custom bundling your own Workflows** you may get errors like these:\n\n```bash\n[ERROR] Failed to activate workflow {\n  runId: 'aaf84a83-51ce-462a-9ab7-6a641a703bff',\n  error: ReferenceError: exports is not defined,\n  workflowExists: false\n}\n```\n\nTemporal Workflow Bundles need to [export a set of methods that fit the compiled `worker-interface.ts` from `@temporalio/workflow`](https://github.com/temporalio/sdk-typescript/blob/eaa2d205c9bc5ff4a3b17c0b34f2dcf6b1e0264a/packages/worker/src/workflow/bundler.ts#L81) as an entry point.\nWe do offer a `bundleWorkflowCode` method to assist you with this, though it uses our Webpack settings.\nFor more information, see the [Register types](dev-guide/typescript/foundations#register-types) section.\n\n### Webpack errors\n\nThe TypeScript SDK's Worker bundles Workflows based on `workflowsPath` with [Webpack](https://webpack.js.org/) and run them inside v8 isolates.\n\nIf Webpack fails to create the bundle, the SDK will throw an error and emit webpack logs using the SDK's [logger](/typescript/observability#logging).\n\nIf you do not see Webpack output in your terminal make sure that you have not disabled SDK logging (see reference to `Runtime.install()` in the link above).\n\n**A common mistake for newcomers to the TypeScript SDK is trying to use Node.js built-ins and modules in their Workflow code.** Usually, the best thing to do is move that code to an Activity.\n\nSome common examples that will **not** work in the Workflow isolate:\n\n<details>\n<summary>\nImporting node built-in modules\n</summary>\n\n:::danger Antipattern\n\n```ts\nimport fs from 'fs';\n\nconst config = fs.readFileSync('config.json', 'utf8');\n```\n\n:::\n\nThis is invalid because reading from the filesystem is a non-deterministic operation: the file may change from the time of the original Workflow Execution to when the Workflow is replayed.\n\nYou'll typically see an error in this form in the Webpack output:\n\n```\n2021-10-14T19:22:00.606Z [INFO] Module not found: Error: Can't resolve 'fs' in '/Users/you/your-project/src'\n2021-10-14T19:22:00.606Z [INFO] resolve 'fs' in '/Users/you/your-project/src'\n2021-10-14T19:22:00.606Z [INFO]   Parsed request is a module\n2021-10-14T19:22:00.606Z [INFO]   using description file: /Users/you/your-project/package.json (relative path: ./src)\n2021-10-14T19:22:00.606Z [INFO]     Field 'browser' doesn't contain a valid alias configuration\n```\n\n</details>\n\n<details>\n<summary>\nImporting and calling Activities directly from Workflow code\n</summary>\n\n:::danger Antipattern\n\n```ts\nimport { makeHTTPRequest } from './activities';\n\nexport async function yourWorkflow(): Promise<string> {\n  return await makeHTTPRequest('https://temporal.io');\n}\n```\n\n:::\n\nThis is invalid because activity implementations should not be directly referenced by Workflow code.\nActivities are used by Workflows in order make network calls and reading from the filesystem, operations which are non-deterministic by nature because they rely on external state.\nTemporal records Activity results in the Workflow history and in case your Workflow is replayed, completed Activities will not be rerun, instead their recorded result will be delivered to the Workflow.\n\nYou'll typically see an error in this form in the Webpack output:\n\n```\n2021-10-14T19:46:52.731Z [INFO] ERROR in ./src/activities.ts 8:31-46\n2021-10-14T19:46:52.731Z [INFO] Module not found: Error: Can't resolve 'http' in '/Users/you/your-project/src'\n2021-10-14T19:46:52.731Z [INFO]\n2021-10-14T19:46:52.731Z [INFO] BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.\n2021-10-14T19:46:52.731Z [INFO] This is no longer the case. Verify if you need this module and configure a polyfill for it.\n2021-10-14T19:46:52.731Z [INFO]\n2021-10-14T19:46:52.731Z [INFO] If you want to include a polyfill, you need to:\n2021-10-14T19:46:52.731Z [INFO]         - add a fallback 'resolve.fallback: { \"http\": require.resolve(\"stream-http\") }'\n2021-10-14T19:46:52.731Z [INFO]         - install 'stream-http'\n2021-10-14T19:46:52.731Z [INFO] If you don't want to include a polyfill, you can use an empty module like this:\n2021-10-14T19:46:52.731Z [INFO]         resolve.fallback: { \"http\": false }\n```\n\nTo properly call your Activities from Workflow code use `proxyActivities` and make sure to only import the Activity types.\n\n```ts\nimport { proxyActivities } from '@temporalio/workflow';\n\nimport type * as activities from './activities';\nconst { makeHTTPRequest } = proxyActivities<typeof activities>();\n\nexport async function yourWorkflow(): Promise<string> {\n  return await makeHTTPRequest('https://temporal.io');\n}\n```\n\n</details>\n\n### Works in Dev but not in Prod\n\nThe two main sources of dev-prod discrepancies are in bundling and connecting.\n\n#### Production bundling\n\nIf you are getting errors like this:\n\n```\nError: 3 INVALID_ARGUMENT: WorkflowType is not set on request.\n```\n\nThis is due to your bundler stripping out Workflow function names, which we rely on to set the \"Workflow Type\" in Temporal. Turn it off and it should work.\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs\ndefaultValue=\"webpackterser\"\nvalues={[\n{label: 'Webpack with Terser', value: 'webpackterser'},\n{label: 'ESbuild', value: 'esbuild'},\n]\n}>\n\n<TabItem value=\"webpackterser\">\n\n```js\n// webpack.config.js\nmodule.exports = {\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          keep_fnames: true, // don't strip funciton names in production\n        },\n      }),\n    ],\n  },\n};\n```\n\n</TabItem>\n<TabItem value=\"esbuild\">\n\n```js\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  minify: true,\n  keepNames: true,\n  outfile: 'out.js',\n});\n```\n\nSee esbuild docs: https://esbuild.github.io/api/#keep-names\n\n</TabItem>\n</Tabs>\n\n#### Connecting to Temporal Server\n\nIf you are trying to connect in production and getting this:\n\n```bash\n[TransportError: transport error]\n```\n\nIt is a sign that something is wrong with your Cert/Key pair.\nLog it out and make sure it is an exact match with what is expected (often, the issue can be whitespace when injecting from your production secrets management environment).\n\n### Resetting Workflows to deal with logical bugs\n\nYou can \"rewind time\" using the `tctl` CLI, resetting Workflow History to some previous point in time. You can read the CLI docs on:\n\n- [Restarting and resetting Workflows by ID](/tctl-v1)\n- [Resetting all Workflows by binary checksum identifier](/tctl-v1)\n\nIf you need to reset programmatically, the TS SDK does not have any high level APIs for this, but you can make raw gRPC calls to [resetWorkflowExecution](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#resetworkflowexecution).\n\nResetting should only be used to deal with serious logical bugs in your code: it's not for handling transient failures, like a downstream service being unreachable. It should not be used in the course of normal application flows.\n\n### gRPC call timeouts (context deadline exceeded)\n\nThe opaque `context deadline exceeded` error comes from `gRPC`:\n\n```\nError: 4 DEADLINE_EXCEEDED: context deadline exceeded\n    at Object.callErrorFromStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/call.js:31:26)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client.js:179:52)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client-interceptors.js:336:141)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client-interceptors.js:299:181)\n    at /Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/call-stream.js:145:78\n    at processTicksAndRejections (node:internal/process/task_queues:78:11) {\n  code: 4,\n  details: 'context deadline exceeded',\n  metadata: Metadata {\n    internalRepr: Map(1) { 'content-type' => [Array] },\n    options: {}\n  },\n  page: '/api/getBuyState'\n}\n```\n\nSeveral conditions can cause this error, including network hiccups, timeouts that are too short, and an overloaded server.\nQuerying a Workflow Execution whose query handler causes an error can result in the query call timing out.\n\nSome troubleshooting actions you can take:\n\n- Verify the connection from your Worker to the Temporal Server is working and doesn't have unusually high latency.\n- If you are running Temporal Server yourself, check your [server metrics](/kb/legacy-oss-prod-deploy/#scaling-and-metrics) to ensure it's not overloaded.\n- If what's timing out is a query, check the logs of your Workers to see if they are having issues handling the query.\n\nIf none of the preceding actions help you discover why timeouts are occurring, please try to produce a minimal repro and we'll be glad to help.\n","is_empty":false},{"file_name":"troubleshooting.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/troubleshooting.md","id":"typescript/troubleshooting","title":"Troubleshooting Issues with the TypeScript SDK","description":"This document is a quick checklist of common user errors for your reference.","label":"Troubleshooting","ssdi":[],"markdown_content":"\nThis document is a quick checklist of common user errors for your reference.\n\n## Two Locations to Watch\n\n- Workflow Errors are reflected in Temporal Web\n- Worker errors and logs are reflected in the terminal.\n\nIf something isn't behaving the way you expect, make sure to check both locations for helpful error messages.\n\n## Stale Workflows\n\nIf you are developing Workflows and finding that code isn't executing as expected, the first place to look is whether old Workflows are still running.\n\nIf those old Workflows have the same name and are on the same task queue, Temporal will try to continue executing them on your new code by design.\nYou may get errors that make no sense to you because\n\n- Temporal is trying to execute old Workflow code that no longer exists in your codebase, or\n- your new Client code is expecting Temporal to execute old Workflow/Activity code it doesn't yet know about.\n\nThe biggest sign that this is happening is if you notice Temporal is acting non-deterministically: running the same Workflow twice gets different results.\n\nStale workflows are usually a non-issue because the errors generated are just noise from code you no longer want to run.\nIf you need to terminate old stale Workflows, you can do so with Temporal Web or `tctl`.\n\n## Workflow/Activity registration errors\n\n**If your Workflows or Activities are not imported or spelled correctly**, here are some errors we've seen:\n\n- `ApplicationFailure: 'MyFunction' is not a function`\n- `Workflow did not register a handler for MyQuery`\n\nDouble check that your Workers are registering the right Workflow and Activity Definitions (function names) on the right Task Queues.\n\n**If you are running Temporal in a monorepo**, then your `node_modules` may be in a different location than where Temporal expects to find it by default, which results in errors like:\n\n```bash\n[ERROR] Module not found: Error: Can't resolve '@temporalio/workflow/lib/worker-interface.js' in '/src'\n```\n\nOur [Next.js tutorial](/typescript/nextjs-tutorial) is written for people setting up Temporal **within an existing monorepo** which may be of use here.\n\nWhen you pass a `workflowsPath`, our Webpack config expects to find `node_modules` in the same or a parent/ancestor directory.\n\n**If you are custom bundling your own Workflows** you may get errors like these:\n\n```bash\n[ERROR] Failed to activate workflow {\n  runId: 'aaf84a83-51ce-462a-9ab7-6a641a703bff',\n  error: ReferenceError: exports is not defined,\n  workflowExists: false\n}\n```\n\nTemporal Workflow Bundles need to [export a set of methods that fit the compiled `worker-interface.ts` from `@temporalio/workflow`](https://github.com/temporalio/sdk-typescript/blob/eaa2d205c9bc5ff4a3b17c0b34f2dcf6b1e0264a/packages/worker/src/workflow/bundler.ts#L81) as an entry point.\nWe do offer a [bundleWorkflowCode](/typescript/workers/#prebuilt-workflow-bundles) method to assist you with this, though it uses our Webpack settings.\n\n## Webpack errors\n\nThe TypeScript SDK's [Worker](/typescript/workers) bundles Workflows based on `workflowsPath` with [Webpack](https://webpack.js.org/) and run them inside v8 isolates.\n\nIf Webpack fails to create the bundle, the SDK will throw an error and emit webpack logs using the SDK's [logger](/typescript/how-to-log-from-a-workflow-in-typescript#logs-generated-by-sdk-components).\n\nIf you do not see Webpack output in your terminal make sure that you have not disabled SDK logging (see reference to `Runtime.install()` in the link above).\n\n**A common mistake for newcomers to the TypeScript SDK is trying to use Node.js built-ins and modules in their Workflow code.** Usually, the best thing to do is move that code to an Activity.\n\nSome common examples that will **not** work in the Workflow isolate:\n\n<details>\n<summary>\nImporting node built-in modules\n</summary>\n\n:::danger Antipattern\n\n```ts\nimport fs from 'fs';\n\nconst config = fs.readFileSync('config.json', 'utf8');\n```\n\n:::\n\nThis is invalid because reading from the filesystem is a non-deterministic operation: the file may change from the time of the original Workflow Execution to when the Workflow is replayed.\n\nYou'll typically see an error in this form in the Webpack output:\n\n```\n2021-10-14T19:22:00.606Z [INFO] Module not found: Error: Can't resolve 'fs' in '/Users/you/your-project/src'\n2021-10-14T19:22:00.606Z [INFO] resolve 'fs' in '/Users/you/your-project/src'\n2021-10-14T19:22:00.606Z [INFO]   Parsed request is a module\n2021-10-14T19:22:00.606Z [INFO]   using description file: /Users/you/your-project/package.json (relative path: ./src)\n2021-10-14T19:22:00.606Z [INFO]     Field 'browser' doesn't contain a valid alias configuration\n```\n\n</details>\n\n<details>\n<summary>\nImporting and calling Activities directly from Workflow code\n</summary>\n\n:::danger Antipattern\n\n```ts\nimport { makeHTTPRequest } from './activities';\n\nexport async function yourWorkflow(): Promise<string> {\n  return await makeHTTPRequest('https://temporal.io');\n}\n```\n\n:::\n\nThis is invalid because activity implementations should not be directly referenced by Workflow code.\nActivities are used by Workflows in order make network calls and reading from the filesystem, operations which are non-deterministic by nature because they rely on external state.\nTemporal records Activity results in the Workflow history and in case your Workflow is replayed, completed Activities will not be rerun, instead their recorded result will be delivered to the Workflow.\n\nYou'll typically see an error in this form in the Webpack output:\n\n```\n2021-10-14T19:46:52.731Z [INFO] ERROR in ./src/activities.ts 8:31-46\n2021-10-14T19:46:52.731Z [INFO] Module not found: Error: Can't resolve 'http' in '/Users/you/your-project/src'\n2021-10-14T19:46:52.731Z [INFO]\n2021-10-14T19:46:52.731Z [INFO] BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.\n2021-10-14T19:46:52.731Z [INFO] This is no longer the case. Verify if you need this module and configure a polyfill for it.\n2021-10-14T19:46:52.731Z [INFO]\n2021-10-14T19:46:52.731Z [INFO] If you want to include a polyfill, you need to:\n2021-10-14T19:46:52.731Z [INFO]         - add a fallback 'resolve.fallback: { \"http\": require.resolve(\"stream-http\") }'\n2021-10-14T19:46:52.731Z [INFO]         - install 'stream-http'\n2021-10-14T19:46:52.731Z [INFO] If you don't want to include a polyfill, you can use an empty module like this:\n2021-10-14T19:46:52.731Z [INFO]         resolve.fallback: { \"http\": false }\n```\n\nTo properly call your Activities from Workflow code use `proxyActivities` and make sure to only import the Activity types.\n\n```ts\nimport { proxyActivities } from '@temporalio/workflow';\n\nimport type * as activities from './activities';\nconst { makeHTTPRequest } = proxyActivities<typeof activities>();\n\nexport async function yourWorkflow(): Promise<string> {\n  return await makeHTTPRequest('https://temporal.io');\n}\n```\n\n</details>\n\n## Works in Dev, but not in Prod\n\nThe two main sources of dev-prod discrepancies are in bundling and connecting.\n\n### Production Bundling\n\nIf you are getting errors like this:\n\n```\nError: 3 INVALID_ARGUMENT: WorkflowType is not set on request.\n```\n\nThis is due to your bundler stripping out Workflow function names, which we rely on to set the \"Workflow Type\" in Temporal. Turn it off and it should work.\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs\ndefaultValue=\"webpackterser\"\nvalues={[\n{label: 'Webpack with Terser', value: 'webpackterser'},\n{label: 'ESbuild', value: 'esbuild'},\n]\n}>\n\n<TabItem value=\"webpackterser\">\n\n```js\n// webpack.config.js\nmodule.exports = {\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          keep_fnames: true, // don't strip funciton names in production\n        },\n      }),\n    ],\n  },\n};\n```\n\n</TabItem>\n<TabItem value=\"esbuild\">\n\n```js\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  minify: true,\n  keepNames: true,\n  outfile: 'out.js',\n});\n```\n\nSee esbuild docs: https://esbuild.github.io/api/#keep-names\n\n</TabItem>\n</Tabs>\n\n### Connecting to Temporal Server\n\nIf you are trying to connect in production and getting this:\n\n```bash\n[TransportError: transport error]\n```\n\nIt is a sign that something is wrong with your Cert/Key pair.\nLog it out and make sure it is an exact match with what is expected (often, the issue can be whitespace when injecting from your production secrets management environment).\n\n## Resetting Workflows to deal with logical bugs\n\nYou can \"rewind time\" using the `tctl` CLI, resetting Workflow History to some previous point in time. You can read the CLI docs on:\n\n- [Restarting and resetting Workflows by ID](/tctl-v1)\n- [Resetting all Workflows by binary checksum identifier](/tctl-v1)\n\nIf you need to reset programmatically, the TS SDK does not have any high level APIs for this, but you can make raw gRPC calls to [resetWorkflowExecution](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#resetworkflowexecution).\n\nResetting should only be used to deal with serious logical bugs in your code: it's not for handling transient failures, like a downstream service being unreachable. It should not be used in the course of normal application flows.\n\n## gRPC call timeouts (context deadline exceeded)\n\nThe opaque `context deadline exceeded` error comes from `gRPC`:\n\n```\nError: 4 DEADLINE_EXCEEDED: context deadline exceeded\n    at Object.callErrorFromStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/call.js:31:26)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client.js:179:52)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client-interceptors.js:336:141)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client-interceptors.js:299:181)\n    at /Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/call-stream.js:145:78\n    at processTicksAndRejections (node:internal/process/task_queues:78:11) {\n  code: 4,\n  details: 'context deadline exceeded',\n  metadata: Metadata {\n    internalRepr: Map(1) { 'content-type' => [Array] },\n    options: {}\n  },\n  page: '/api/getBuyState'\n}\n```\n\nSeveral conditions can cause this error, including network hiccups, timeouts that are too short, and an overloaded server.\nQuerying a Workflow Execution whose query handler causes an error can result in the query call timing out.\n\nSome troubleshooting actions you can take:\n\n- Verify the connection from your Worker to the Temporal Server is working and doesn't have unusually high latency\n- If you are running Temporal Server yourself, check your [server metrics](/kb/legacy-oss-prod-deploy/#scaling-and-metrics) to ensure it's not overloaded\n- If what's timing out is a query, check the logs of your Workers to see if they are having issues handling the query\n\nIf none of the preceding actions help you discover why timeouts are occurring, please try to produce a minimal repro and we'll be glad to help.\n","is_empty":false},{"file_name":"upsert-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/upsert-custom-search-attributes.md","id":"typescript/upsert-custom-search-attributes","title":"How to upsert Search Attributes","description":"You can upsert Search Attributes to add or update Search Attributes from within Workflow code.","label":"Upsert Search Attributes","tags":["guide-context"],"ssdi":[],"markdown_content":"\nYou can upsert Search Attributes to add or update Search Attributes from within Workflow code.\n","is_empty":false},{"file_name":"versioning.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/versioning.md","id":"typescript/versioning","title":"Versioning","description":"Versioning lets you update Workflow Definitions without causing non-deterministic behavior in current long-running Workflows.","label":"Versioning","tags":["guide-context"],"ssdi":[],"markdown_content":"\nVersioning (known as \"patching\" in TypeScript) lets you update Workflow Definitions without causing [non-deterministic behavior](/workflows#code-changes-can-cause-non-deterministic-behavior) in current long-running Workflows.\n\n<!-- The following was ported from \\docs-src\\typescript\\patching.md -->\n\n### Alternatives\n\nBefore you explore our patching/versioning API, check if your needs can be addressed in other ways:\n\n- [Version Task Queue](#version-task-queue)\n- [Version Workflow Name](#version-workflow-name)\n\nBoth options mean that Workflows running `v1` code will never migrate to `v2` code: they will run `v1` code to completion.\nIf you would like to update Workflows running `v1` _while they are still running_, you [may need to \"patch in\" code](#do-i-need-to-patch).\n\n#### Version Task Queue\n\nIf we're currently running our v1 Workflow code on Workers that poll on `queue1`, we can run v2 Workflow code on Workers that poll on `queue2`:\n\n1. Leave some Workers running your v1 `Workflow`, on the `queue1` Task Queue.\n1. Change your `Workflow` code and spin up new Workers that are polling a `queue2` Task Queue.\n1. Cut over your Clients to only call `Workflow` on `queue2` from now on.\n1. Remove your v1 Workers when all the v1 Workflows have completed.\n\n#### Version Workflow Name\n\nWhile versioning the Task Queue is usually easier, we can also create a new version of a Workflow by copying it and changing its name:\n\n1. Copy `Workflow1`'s code to a `Workflow2` function and change what you need.\n1. Register `Workflow2` in your Workers alongside `Workflow1`.\n1. Cut over your Clients to only call `Workflow2` from now on.\n1. Remove `Workflow1` code when none of them are running anymore.\n\n### Do I need to Patch?\n\nYou may need to patch if:\n\n- You want to change the remaining logic of a Workflow while it is still running\n- If your new logic can result in a different execution path\n\nThis added `sleep()` can result in a different execution path:\n\n```ts\n// from v1\nexport async function yourWorkflow(value: number): Promise<number> {\n  await runActivity();\n  return 7;\n}\n\n// to v2\nexport async function yourWorkflow(value: number): Promise<number> {\n  await sleep('1 day');\n\n  await runActivity();\n  return 7;\n}\n```\n\nIf v2 is deployed while there's a Workflow on the `runActivity` step, when the Activity completes, the Worker will try to replay the Workflow (in order to continue Workflow execution), notice that the sleep command is called and doesn't match with the Workflow's Event History, and throw a non-determinism error.\n\nAdding a Signal Handler for a Signal type that has never been sent before does not need patching:\n\n```ts\n// from v1\nexport async function yourWorkflow(value: number): Promise<number> {\n  await sleep('1 days');\n  return value;\n}\n\n// to v2\nconst updateValueSignal = defineSignal<[number]>('updateValue');\n\nexport async function yourWorkflow(value: number): Promise<number> {\n  setHandler(updateValueSignal, (newValue) => (value = newValue));\n\n  await sleep('1 days');\n  return value;\n}\n```\n\n### Migrating Workflows in Patches\n\nWorkflow code has to be [deterministic](/workflows#deterministic-constraints) by taking the same code path when replaying history events.\nAny Workflow code change that affects the order in which commands are generated breaks this assumption.\n\nSo we have to keep both the old and new code when migrating Workflows while they are still running:\n\n- When replaying, use the original code version that generated the ongoing event history.\n- When executing a new code path, always execute the\n  new code.\n\n<details>\n<summary>30 Min Video: Introduction to Versioning\n</summary>\n\nBecause we design for potentially long-running Workflows at scale, versioning with Temporal works differently than with other Workflow systems.\nWe explain more in this optional 30 minute introduction: [https://www.youtube.com/watch?v=kkP899WxgzY](https://www.youtube.com/watch?v=kkP899WxgzY)\n\n</details>\n\n### TypeScript SDK Patching API\n\nIn principle, the TypeScript SDK's patching mechanism works in a similar \"feature-flag\" fashion to the other SDK's, however, the \"versioning\" API has been updated to a notion of \"patching in\" code.\nThere are three steps to this reflecting three stages of migration:\n\n- Running v1 code with vFinal patched in concurrently\n- Running vFinal code with deprecation markers for vFinal patches\n- Running \"just\" vFinal code.\n\nThis is best explained in sequence (click through to follow along using our SDK sample).\n\nGiven an initial Workflow version `v1`:\n\n<!--SNIPSTART typescript-patching-1-->\n\n[patching-api/src/workflows-v1.ts](https://github.com/temporalio/samples-typescript/blob/master/patching-api/src/workflows-v1.ts)\n\n```ts\n// v1\nexport async function myWorkflow(): Promise<void> {\n  await activityA();\n  await sleep('1 days'); // arbitrary long sleep to simulate a long running workflow we need to patch\n  await activityThatMustRunAfterA();\n}\n```\n\n<!--SNIPEND-->\n\nWe decide to update our code and run `activityB` instead.\nThis is our desired end state, `vFinal`.\n\n<!--SNIPSTART typescript-patching-final-->\n\n[patching-api/src/workflows-vFinal.ts](https://github.com/temporalio/samples-typescript/blob/master/patching-api/src/workflows-vFinal.ts)\n\n```ts\n// vFinal\nexport async function myWorkflow(): Promise<void> {\n  await activityB();\n  await sleep('1 days');\n}\n```\n\n<!--SNIPEND-->\n\n**Problem: We cannot directly deploy `vFinal` until we know for sure there are no more running Workflows created using `v1` code.**\n\nInstead we must deploy `v2` (below) and use the [`patched`](https://typescript.temporal.io/api/namespaces/workflow#patched) function to check which version of the code should be executed.\n\nPatching is a three-step process:\n\n1. Patch in new code with `patched` and run it alongside old code\n2. Remove old code and `deprecatePatch`\n3. When you are sure all old Workflows are done executing, remove `deprecatePatch`\n\n#### Step 1: Patch in new code\n\n`patched` inserts a marker into the Workflow history.\n\n![image](https://user-images.githubusercontent.com/6764957/139673361-35d61b38-ab94-401e-ae7b-feaa52eae8c6.png)\n\nDuring replay, when a Worker picks up a history with that marker it will fail the Workflow task when running Workflow code that does not emit the same patch marker (in this case `your-change-id`); therefore it is safe to deploy code from `v2` in a \"feature flag\" alongside the original version (`v1`).\n\n<!--SNIPSTART typescript-patching-2-->\n\n[patching-api/src/workflows-v2.ts](https://github.com/temporalio/samples-typescript/blob/master/patching-api/src/workflows-v2.ts)\n\n```ts\n// v2\nimport { patched } from '@temporalio/workflow';\nexport async function myWorkflow(): Promise<void> {\n  if (patched('my-change-id')) {\n    await activityB();\n    await sleep('1 days');\n  } else {\n    await activityA();\n    await sleep('1 days');\n    await activityThatMustRunAfterA();\n  }\n}\n```\n\n<!--SNIPEND-->\n\n#### Step 2: Deprecate patch\n\nOnce we know that all Workflows started with `v1` code have completed we can [deprecate the patch](https://typescript.temporal.io/api/namespaces/workflow#deprecatepatch).\nDeprecated patches bridge between `v2` and `vFinal` (the end result), they work similarly to regular patches by recording a marker in the Workflow history, this marker does not fail replay when Workflow code does not emit it.\n\nIf while we're deploying `v3` (below) there are still live Workers running `v2` code and those Workers pick up Workflow histories generated by `v3`, they will safely use the patched branch.\n\n<!--SNIPSTART typescript-patching-3-->\n\n[patching-api/src/workflows-v3.ts](https://github.com/temporalio/samples-typescript/blob/master/patching-api/src/workflows-v3.ts)\n\n```ts\n// v3\nimport { deprecatePatch } from '@temporalio/workflow';\n\nexport async function myWorkflow(): Promise<void> {\n  deprecatePatch('my-change-id');\n  await activityB();\n  await sleep('1 days');\n}\n```\n\n<!--SNIPEND-->\n\n#### Step 3: Solely deploy new code\n\n`vFinal` is safe to deploy once all `v2` or earlier Workflows are complete due to the assertion mentioned above.\n\n### Upgrading Workflow dependencies\n\nUpgrading Workflow dependencies (such as ones installed into `node_modules`) _might_ break determinism in unpredictable ways.\nWe recommended using a lock file (`package-lock.json` or `yarn.lock`) to fix Workflow dependency versions and gain control of when they're updated.\n","is_empty":false},{"file_name":"visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/visibility.md","id":"typescript/visibility","title":"How to use Visibility APIs","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["guide-context"],"ssdi":[],"markdown_content":"\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n","is_empty":false},{"file_name":"workers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workers.md","id":"typescript/workers","title":"Workers and Task Queues in TypeScript","description":"A Worker is a process that connects to the Temporal Server, polls Task Queues for Commands sent from Clients, and executes Workflows and Activities in response to those Commands.","label":"Workers","ssdi":[],"markdown_content":"\n**`@temporalio/worker`** [![NPM](https://img.shields.io/npm/v/@temporalio/worker)](https://www.npmjs.com/package/@temporalio/worker) [API reference](https://typescript.temporal.io/api/namespaces/worker) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/worker)\n\n> _Background reading: [Workers in Temporal](/workers)_\n\n## What is a Worker?\n\nA Worker is a process that connects to the Temporal Server, polls **Task Queues** for Tasks sent from Clients, and executes [Workflows](/typescript/workflows) and [Activities](/typescript/activities) in response.\n\n- **Workers host Workflows and Activities.**\n  - TypeScript SDK Workers bundle Workflows based on `workflowsPath` with [Webpack](https://webpack.js.org/) and run them inside v8 isolates.\n  - TypeScript SDK Workers directly run `activities` inside the normal Node.js environment.\n- **Workers are extremely scalable.**\n  - Workers connect to the Temporal Server, poll their configured **Task Queue** for Tasks, execute chunks of code in response to those Tasks, and then communicate the results back.\n  - Workers are distinct from Clients and scaled independently of Temporal Server, which has its own internal services to scale.\n  - Workers are stateless, and can be brought up and down at any time with no Temporal data loss impact.\n    To migrate to new versions of your Workflows and Activities, you restart your Workers with the new versions (and optionally use [the `patch` API to migrate](/typescript/patching) still-running Workflows of the older version).\n  - Use the `@temporalio/worker` package's [`Worker`](https://typescript.temporal.io/api/classes/worker.Worker) class to create and run as many Workers as your use case demands, across any number of hosts.\n- **Workers are run on user-controlled hosts.** This is an important security feature which means Temporal Server (or Temporal Cloud) never executes your Workflow or Activity code, and that Workers can have different hardware (e.g. custom GPUs for Machine Learning) than the rest of the system.\n\n<details>\n<summary>\nYour Workflows will only progress if there are Workers polling the right Task Queues, and they must have the right Workflows and Activities registered to execute those Tasks.\n</summary>\n\nThe TypeScript SDK uses TypeScript, but cannot completely protect you from typos.\nIf you are experiencing issues, you can check the status of Workers and the Task Queues they poll with [tctl](/tctl-v1) or the [Temporal Web UI](/web-ui).\n\n![Temporal Web Task Queues view](https://user-images.githubusercontent.com/6764957/126413160-18663430-bb7a-4d3a-874e-80598e1fa07d.png)\n\n</details>\n\n### How to develop a Worker\n\n<details>\n<summary>\nThe Worker package embeds the <a href=\"https://github.com/temporalio/sdk-core\">Temporal Rust Core SDK</a>.\nIt comes pre-compiled for most installations.\n</summary>\n\nWe've provided pre-compiled binaries for:\n\n- Mac with an Intel chip: `x86_64-apple-darwin`\n- Mac with an Apple chip: `aarch64-apple-darwin`\n- Linux with x86_64 architecture: `x86_64-unknown-linux-gnu`\n- Linux with aarch64 architecture: `aarch64-unknown-linux-gnu`\n- Windows with x86_64 architecture: `x86_64-pc-windows-gnu` (Windows is not yet supported but it is a [priority for us](https://github.com/temporalio/sdk-typescript/issues/12)).\n\nIf you need to compile the Worker yourself, set up the Rust toolchain by following the instructions [here](https://rustup.rs/).\n\n</details>\n\n### Prebuilt Workflow Bundles\n\nAdvanced users can pass a prebuilt bundle instead of `workflowsPath`, or you can use Temporal's `bundleWorkflowCode` helper:\n\n```ts\nimport { bundleWorkflowCode, Worker } from '@temporalio/worker';\n\n// Option 1: passing path to prebuilt bundle\nconst worker = await Worker.create({\n  taskQueue,\n  workflowBundle: {\n    codePath: './path-to-bundle.js',\n    sourceMapPath: './path-to-bundle.js.map',\n  },\n});\n\n// Option 2: bundling code using Temporal's bundler settings\nconst workflowBundle = await bundleWorkflowCode({\n  workflowsPath: require.resolve('./path-to-your-workflows'),\n});\nconst worker = await Worker.create({\n  taskQueue,\n  workflowBundle,\n});\n```\n\n### How to shut down a Worker and track its state\n\nWorkers shut down if they receive any of these [`shutdownSignals`](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions/#shutdownsignals): `['SIGINT', 'SIGTERM', 'SIGQUIT', 'SIGUSR2']`. In development, we shut down Workers with `Ctrl-C` (`SIGINT`) or [`nodemon`](https://github.com/temporalio/samples-typescript/blob/c37bae3ea235d1b6956fcbe805478aa46af973ce/hello-world/package.json#L10) (`SIGUSR2`). In production, we usually want to give Workers a [`shutdownGraceTime`](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions/#shutdowngracetime) long enough for them to finish any in-progress Activities. As soon as they receive a shutdown signal or request, the Worker stops polling for new Tasks and allows in-flight Tasks to complete until `shutdownGraceTime` is reached. Any Activities that are still running at that time will stop running, and will be rescheduled by Temporal Server when an [Activity timeout](/typescript/activities#activity-timeouts) occurs.\n\nWe may want to programmatically shut down Workers (with `worker.shutdown()`) in integration tests or when automating a fleet of Workers.\n\n#### Worker states\n\nAt any point in time, we can Query Worker state with `worker.getState()`.\nA Worker is in one of 7 states at any given point:\n\n- `INITIALIZED` - The initial state of the Worker after calling Worker.create and successful connection to the server\n- `RUNNING` - `worker.run()` was called, polling Task Queues\n- `FAILED` - Worker encountered an unrecoverable error, `worker.run()` should reject with the error\n- The last 4 states are related to the Worker shutdown process:\n  - `STOPPING` - `worker.shutdown()` was called or received shutdown Signal, Worker will forcefully shutdown after `shutdownGraceTime`\n  - `DRAINING` - Core has indicated that shutdown is complete and all Workflow tasks have been drained, waiting for activities and cached Workflows eviction\n  - `DRAINED` - All activities and Workflows have completed, ready to shutdown\n  - `STOPPED` - Shutdown complete, `worker.run()` resolves\n\nIf you need even more visibility into internal Worker state, [see the API reference for more](https://typescript.temporal.io/api/classes/worker.Worker).\n\n## Rust Core and Worker Networking\n\nIn development, the TypeScript SDK usually handles all of the communication between the Worker and the Temporal Server behind the scenes.\n\nIn production settings, you can configure the `address` and `namespace` the Worker speaks to via [the Rust Core SDK](https://github.com/temporalio/sdk-core) [`NativeConnection`](https://typescript.temporal.io/api/classes/worker.NativeConnection/), and configure the Core [`Runtime`](https://typescript.temporal.io/api/classes/worker.Runtime/#install) with [RuntimeOptions](https://typescript.temporal.io/api/interfaces/worker.RuntimeOptions):\n\n```js\nimport {\n  DefaultLogger,\n  NativeConnection,\n  Runtime,\n  Worker,\n} from '@temporalio/worker';\n\nconst logger = new DefaultLogger('DEBUG');\nRuntime.install({\n  logger,\n  telemetryOptions: { logForwardingLevel: 'INFO' },\n});\nconst connection = await NativeConnection.connect({\n  address: 'temporal.myorg.io',\n});\nconst worker = await Worker.create({\n  connection,\n  namespace: 'your-custom-namespace',\n  /* standard Worker options from here */\n});\n```\n\nTemporal also supports mTLS encryption (required by Temporal Cloud) this way - please read our [Security docs](/typescript/security#encryption-in-transit-with-mtls) for more information.\n\n## Task Queues\n\nimport WhatIsATaskQueue from '../concepts/what-is-a-task-queue.md'\n\n<details>\n<summary>\nA Task Queue is a dynamic queue in Temporal Server polled by one or more Workers.\n</summary>\n\n<WhatIsATaskQueue />\n\n</details>\n\n### Where Task Queues are used\n\nIn Temporal, a Task Queue is represented in code by its name as a `string`.\n\nThere are two main places where the name of the Task Queue is supplied by the developer.\n\n<details>\n<summary>\n\nWhen scheduling a Workflow, a `taskQueue` must be specified.\n\n</summary>\n\n```ts\nimport { Connection, WorkflowClient } from '@temporalio/client';\nconst connection = await Connection.connect();\nconst client = new WorkflowClient({ connection });\nconst result = await client.execute(yourWorkflow, {\n  // required\n  taskQueue: 'testhttp',\n  workflowId: 'business-meaningful-id',\n});\n```\n\n</details>\n<details>\n<summary>\n\nWhen creating a Worker, you **must** pass the `taskQueue` option to the [`Worker.create()` function](https://typescript.temporal.io/api/classes/worker.Worker#create).\n\n</summary>\n\n```ts\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: 'your-task-queue',\n});\n```\n\n</details>\n\nOptionally, in Workflow code, when calling an Activity, you can specify the Task Queue by passing the `taskQueue` option to [`proxyActivities()`](https://typescript.temporal.io/api/namespaces/workflow/#proxyActivities) or [`startChild/executeChild`](https://typescript.temporal.io/api/namespaces/workflow/#startchild).\nIf you do not specify a `taskQueue`, then the TypeScript SDK places Activity and Child Workflow Tasks in the same Task Queue as the Workflow Task Queue.\n\n### Example: Sticky Activities\n\nAny Worker that polls a Task Queue is allowed to pick up the next task; sometimes this is undesirable because you want tasks to execute sequentially on the same machine.\n\nFortunately, there is a design pattern for this we call _Sticky Activities_.\nBecause Task Queues are dynamically created and very lightweight, you can use them for task routing by creating a new Task Queue per machine.\n\nThe main strategy is:\n\n1. Create a `getUniqueTaskQueue` Activity that generates a unique Task Queue name, (for example, `uniqueWorkerTaskQueue`).\n   It doesn't matter where this Activity is run so this can be \"non sticky\" as per Temporal default behavior\n2. For Activities intended to be _sticky_, register them in one Worker, and have that be the only Worker listening on that `uniqueWorkerTaskQueue`.\n   - Multiple Workers can be created inside the same process.\n3. Execute Workflows from the Client like normal.\n   - Activities will execute in sequence on the same machine because they are all routed by the `uniqueWorkerTaskQueue`.\n\nWorkflow Code:\n\n<!--SNIPSTART typescript-sticky-queues-workflow-->\n\n[worker-specific-task-queues/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/worker-specific-task-queues/src/workflows.ts)\n\n```ts\nconst { getUniqueTaskQueue } = proxyActivities<\n  ReturnType<typeof createNormalActivities>\n>({\n  startToCloseTimeout: '1 minute',\n});\n\nexport async function fileProcessingWorkflow(maxAttempts = 5): Promise<void> {\n  for (let attempt = 1; attempt <= maxAttempts; ++attempt) {\n    try {\n      const uniqueWorkerTaskQueue = await getUniqueTaskQueue();\n      const activities = proxyActivities<\n        ReturnType<typeof createActivitiesForSameWorker>\n      >({\n        taskQueue: uniqueWorkerTaskQueue,\n        // Note the use of scheduleToCloseTimeout.\n        // The reason this timeout type is used is because this task queue is unique\n        // to a single worker. When that worker goes away, there won't be a way for these\n        // activities to progress.\n        scheduleToCloseTimeout: '1 minute',\n      });\n\n      const downloadPath = `/tmp/${uuid4()}`;\n      await activities.downloadFileToWorkerFileSystem(\n        'https://temporal.io',\n        downloadPath,\n      );\n      try {\n        await activities.workOnFileInWorkerFileSystem(downloadPath);\n      } finally {\n        await activities.cleanupFileFromWorkerFileSystem(downloadPath);\n      }\n      return;\n    } catch (err) {\n      if (attempt === maxAttempts) {\n        console.log(`Final attempt (${attempt}) failed, giving up`);\n        throw err;\n      }\n\n      console.log(`Attempt ${attempt} failed, retrying on a new Worker`);\n    }\n  }\n}\n```\n\n<!--SNIPEND-->\n\nWorker Code:\n\n<!--SNIPSTART typescript-sticky-queues-worker-->\n\n[worker-specific-task-queues/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/worker-specific-task-queues/src/worker.ts)\n\n```ts\nasync function run() {\n  const uniqueWorkerTaskQueue = uuid();\n\n  const workers = await Promise.all([\n    Worker.create({\n      workflowsPath: require.resolve('./workflows'),\n      activities: createNormalActivities(uniqueWorkerTaskQueue),\n      taskQueue: 'normal-task-queue',\n    }),\n    Worker.create({\n      // No workflows for this queue\n      activities: createActivitiesForSameWorker(),\n      taskQueue: uniqueWorkerTaskQueue,\n    }),\n  ]);\n  await Promise.all(workers.map((w) => w.run()));\n}\n```\n\n<!--SNIPEND-->\n\nThis pattern is [in use at Netflix](https://www.youtube.com/watch?v=LliBP7YMGyA&t=24s).\nNote that this is unrelated to [Sticky Queues](/concepts/what-is-a-sticky-execution), which are an internal implementation detail.\n","is_empty":false},{"file_name":"workflow-execution-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-execution-timeout.md","id":"typescript/workflow-execution-timeout","title":"How to set a Workflow Execution Timeout","description":"Use the Workflow Execution Timeout to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n","is_empty":false},{"file_name":"workflow-logic-requirements.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-logic-requirements.md","id":"typescript/workflow-logic-requirements","title":"How develop Workflow logic","description":"Workflow logic is constrained by deterministic execution requirements.","label":"Workflow logic requirements","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow logic is constrained by [deterministic execution requirements](/concepts/what-is-a-workflow-definition#deterministic-constraints).\nTherefore, each language is limited to the use of certain idiomatic techniques.\nHowever, each Temporal SDK provides a set of APIs that can be used inside your Workflow to interact with external (to the Workflow) application code.\n","is_empty":false},{"file_name":"workflow-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-parameters.md","id":"typescript/workflow-parameters","title":"How to define Workflow parameters","description":"Temporal Workflows may have any number of custom parameters.","label":"Workflow parameters","tags":["guide-context"],"ssdi":[],"markdown_content":"\nTemporal Workflows may have any number of custom parameters.\nHowever, we strongly recommend that objects are used as parameters, so that the object's individual fields may be altered without breaking the signature of the Workflow.\nAll Workflow Definition parameters must be serializable.\n","is_empty":false},{"file_name":"workflow-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-retries.md","id":"typescript/workflow-retries","title":"Workflow retries","description":"A Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.","label":"Workflow retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-retry-policy.md","id":"typescript/workflow-retry-policy","title":"How to set a Workflow Retry Policy","description":"Use a Retry Policy to retry a Workflow Execution in the event of a failure.","label":"Workflow Retry Policy","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-return-values.md","id":"typescript/workflow-return-values","title":"How to define Workflow return parameters","description":"Workflow return values must also be serializable.","label":"Workflow return values","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflow return values must also be serializable.\nReturning results, returning errors, or throwing exceptions is fairly idiomatic in each language that is supported.\nHowever, Temporal APIs that must be used to get the result of a Workflow Execution will only ever receive one of either the result or the error.\n","is_empty":false},{"file_name":"workflow-run-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-run-timeout.md","id":"typescript/workflow-run-timeout","title":"How to set a Workflow Run Timeout","description":"Use the Workflow Run Timeout to restrict the maximum amount of time that a single Workflow Run can last.","label":"Workflow Run Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) to restrict the maximum amount of time that a single [Workflow Run](/concepts/what-is-a-workflow-execution#workflow-execution-chain) can last.\n","is_empty":false},{"file_name":"workflow-task-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-task-timeout.md","id":"typescript/workflow-task-timeout","title":"How to set a Workflow Task Timeout","description":"Use the Workflow Task Timeout to restrict the maximum amount of time that a Worker can execute a Workflow Task.","label":"Workflow Task Timeout","tags":["guide-context"],"ssdi":[],"markdown_content":"\nUse the [Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout) to restrict the maximum amount of time that a Worker can execute a [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"workflow-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-timeouts-and-retries.md","id":"typescript/workflow-timeouts-and-retries","title":"Workflow timeouts and retries","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts & retries","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"workflow-timeouts.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-timeouts.md","id":"typescript/workflow-timeouts","title":"Workflow timeouts","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts","tags":["guide-context"],"ssdi":[],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\n\nWorkflow timeouts are set when [starting the Workflow Execution](/typescript/workflow-timeouts).\n\n- **[Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout)** - restricts the maximum amount of time that a single Workflow Execution can be executed.\n- **[Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout)**: restricts the maximum amount of time that a single Workflow Run can last.\n- **[Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout)**: restricts the maximum amount of time that a Worker can execute a Workflow Task.\n","is_empty":false},{"file_name":"workflow-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflow-type.md","id":"typescript/workflow-type","title":"How to customize your Workflow Type","description":"You can set a custom name for your Workflow Type.","label":"Workflow Type","tags":["guide-context"],"ssdi":[],"markdown_content":"\nWorkflows have a Type that are referred to as the Workflow name.\n\nThe following examples demonstrate how to set a custom name for your Workflow Type.\n","is_empty":false},{"file_name":"workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/typescript/workflows.md","id":"typescript/workflows","title":"Workflows in TypeScript","description":"Workflows are async functions that can orchestrate Activities and access special Workflow APIs, subject to deterministic limitations.","label":"Workflows","ssdi":[],"markdown_content":"\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\nimport RelatedReadList, {RelatedReadContainer, RelatedReadItem} from '../components/RelatedReadList.js'\n\n<!-- prettier-ignore -->\n\nimport * as WhatIsASignal from '../concepts/what-is-a-signal.md'\nimport * as WhatIsAQuery from '../concepts/what-is-a-query.md'\n\n**`@temporalio/workflow`** [![NPM](https://img.shields.io/npm/v/@temporalio/workflow)](https://www.npmjs.com/package/@temporalio/workflow) [API reference](https://typescript.temporal.io/api/namespaces/workflow) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/workflow)\n\n> _Background reading: [Workflows in Temporal](/workflows)_\n\n**Workflows are async functions that can orchestrate Activities and access special Workflow APIs, subject to deterministic limitations**.\n\nEach Workflow function has two parts:\n\n- The function name is known as the **Workflow Type**.\n- The function implementation code (body) is known as the **Workflow Definition**.\n\nEach Workflow Definition is bundled with any third party dependencies, and registered by Workflow Type in a [Worker](/typescript/workers).\nA Workflow function becomes a **Workflow Execution** (instance) only when started from a [**Workflow Client**](/typescript/clients) using its Workflow Type.\n\n<!-- todo: we need a diagram here to show the relationship -->\n\n## How to write a Workflow function\n\nWorkflow Definitions are \"just functions\", which can store state, and orchestrate [Activity functions](/typescript/activities).\n\n<!--SNIPSTART typescript-hello-workflow {\"enable_source_link\": false}-->\n\n```ts\nimport { proxyActivities } from '@temporalio/workflow';\n// Only import the activity types\nimport type * as activities from './activities';\n\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\n/** A workflow that simply calls an activity */\nexport async function example(name: string): Promise<string> {\n  return await greet(name);\n}\n```\n\n<!--SNIPEND-->\n\nThe snippet above uses `proxyActivities` to create functions that, when called, schedule a `greet` Activity in the system to say \"Hello World\".\n\nA Workflow function can have multiple parameters, but we encourage you to use a single object parameter, as that helps with backward compatibility:\n\n```ts\ntype ExampleArgs = {\n  name: string;\n};\n\nexport async function example(\n  args: ExampleArgs,\n): Promise<{ greeting: string }> {\n  const greeting = await greet(args.name);\n  return { greeting };\n}\n```\n\n### Workflow Limitations\n\nWorkflow code must be [deterministic](/typescript/determinism), and the TypeScript SDK replaces common sources of non-determinism for you, like `Date.now()`, `Math.random`, and `setTimeout` (we recommend using our [`sleep`](/typescript/workflows#sleep) API instead).\nHowever, there are other important limitations:\n\n- No Node built-ins like `process` or the `path` and `fs` modules\n- No filesystem access\n- No network access\n\nThese constraints don't apply inside Activities.\n**If you need to ping an API, or access the filesystem (e.g. for building a CI/CD system), move that code into Activities.**\n\n## How to Start and Cancel Workflows\n\nSee the [TypeScript SDK Client docs](/typescript/clients) for how to use `WorkflowHandle`s to start, cancel, signal, query, describe and more.\n\n### Workflow Options\n\nWorkflows have options that determine what Task Queue they run on, what Search Attributes they are tagged with, Cron schedule, and more, but they are only set in the Temporal Client call (i.e. when you start or execute a Workflow) rather than _inside_ the Workflow code itself.\n\nPlease see the [Temporal Client docs](/typescript/clients) or the [API Reference](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions) for more info on Workflow Options.\n\n## Workflow APIs\n\nThe `@temporalio/workflow` package exports all the useful primitives that you can use in Workflows. See the [API reference](https://typescript.temporal.io/api/namespaces/workflow) for the full list, but the main ones are:\n\n| APIs                         | Purpose                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `proxyActivities`            | Make idempotent side effects (like making a HTTP request) with Activities ([see Activities doc](/typescript/activities))                                                                                                                                                                                                                                                                                                                   |\n| `proxyLocalActivities`       | Make idempotent side effects (like making a HTTP request) with Activities ([see Activities doc](/typescript/activities))                                                                                                                                                                                                                                                                                                                   |\n| `defineSignal`/`defineQuery` | [Signal and Query](#signals-and-queries) Workflows while they are running                                                                                                                                                                                                                                                                                                                                                                  |\n| `sleep`                      | Defer execution by [sleeping](#sleep) for fixed time                                                                                                                                                                                                                                                                                                                                                                                       |\n| `condition`                  | Defer execution until a [`condition`](#condition) is true, with optional timeout                                                                                                                                                                                                                                                                                                                                                           |\n| `startChild`/`executeChild`  | Spawn new [Child Workflows](#child-workflows) with customizable ParentClosePolicy                                                                                                                                                                                                                                                                                                                                                          |\n| `continueAsNew`              | Truncate Event History for [Entity Workflows](#entity-workflows)                                                                                                                                                                                                                                                                                                                                                                           |\n| `patched`/`deprecatePatch`   | Migrate Workflows to new versions ([see Patching doc](/typescript/patching))                                                                                                                                                                                                                                                                                                                                                               |\n| `uuid4`                      | Generate an RFC compliant V4 [uuid](https://typescript.temporal.io/api/namespaces/workflow/#uuid4) without needing to call an Activity or Side Effect.                                                                                                                                                                                                                                                                                     |\n| APIs for advanced users      | including [`workflowInfo`](https://typescript.temporal.io/api/namespaces/workflow#workflowinfo) (to retrieve Workflow metadata), Workflow data [`Sinks`](/typescript/how-to-log-from-a-workflow-in-typescript), [Cancellation Scopes](/typescript/cancellation-scopes), [Failure types](/typescript/handling-failure), and [`getExternalWorkflowHandle`](https://typescript.temporal.io/api/namespaces/workflow#getexternalworkflowhandle) |\n\nYou can import them individually or as a group:\n\n```js\n// Option 1\nimport { sleep } from '@temporalio/workflow';\n\n// Option 2\nimport * as wf from '@temporalio/workflow';\n```\n\nWe fully expect that developers will bundle these into their own reusable Workflow libraries.\nIf you do, please [get in touch on Slack](https://temporal.io/slack), we would love to work with you and promote your work.\n\nThe rest of this document explains the major Workflow APIs you should know:\n\n- Signals and Queries: `defineSignal`, `defineQuery`, and `setHandler`\n- Deferred Execution: `sleep` and `condition`\n- Child Workflows: `startChild` and `executeChild`\n- Entity (indefinitely long-running) Workflows: `continueAsNew`\n\n## Signals and Queries\n\n> _Background reading: [Signals and Queries in Temporal](/workflows/#signals)_\n\n<RelatedReadContainer>\n  <RelatedReadItem page={WhatIsASignal} />\n  <RelatedReadItem page={WhatIsAQuery} />\n</RelatedReadContainer>\n\n#### How to define and receive Signals and Queries\n\n### Define Signals and Queries inside a Workflow\n\n- To add a Signal to a Workflow, call [`defineSignal`](https://typescript.temporal.io/api/namespaces/workflow/#definesignal) with a name, and then attach a listener with `setHandler`.\n- To add a Query to a Workflow, call [`defineQuery`](https://typescript.temporal.io/api/namespaces/workflow/#definequery) with a name, and then attach a listener with `setHandler`.\n- Handlers for both Signals and Queries can take arguments, which can be used inside `setHandler` logic.\n- Only Signal Handlers can mutate state, and only Query Handlers can return values.\n\n#### Define Signals and Queries Statically\n\nIf you know the name of your signals and queries upfront, we recommend declaring them outside of the Workflow Definition.\n\n<!--SNIPSTART typescript-blocked-workflow-->\n\n[signals-queries/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/signals-queries/src/workflows.ts)\n\n```ts\nimport * as wf from '@temporalio/workflow';\n\nexport const unblockSignal = wf.defineSignal('unblock');\nexport const isBlockedQuery = wf.defineQuery<boolean>('isBlocked');\n\nexport async function unblockOrCancel(): Promise<void> {\n  let isBlocked = true;\n  wf.setHandler(unblockSignal, () => void (isBlocked = false));\n  wf.setHandler(isBlockedQuery, () => isBlocked);\n  console.log('Blocked');\n  try {\n    await wf.condition(() => !isBlocked);\n    console.log('Unblocked');\n  } catch (err) {\n    if (err instanceof wf.CancelledFailure) {\n      console.log('Cancelled');\n    }\n    throw err;\n  }\n}\n```\n\n<!--SNIPEND-->\n\nThis helps provide type safety, since you can export the type signature of the signal or query to be called on the clientside.\n\n#### Define Signals and Queries Dynamically\n\nFor more flexible usecases, you may want a dynamic Signal (such as a generated ID).\nYou may handle it in two ways:\n\n- avoid making it dynamic by collapsing all signals in one handler and move the ID to the payload, or\n- actually make the Signal name dynamic by inlining the Signal definition per handler.\n\n```ts\nimport * as wf from '@temporalio/workflow';\n\n// \"fat handler\" solution\nwf.setHandler(`genericSignal`, (payload) => {\n  switch (payload.taskId) {\n    case taskAId:\n      // do task A things\n      break;\n    case taskBId:\n      // do task B things\n      break;\n    default:\n      throw new Error('Unexpected task.');\n  }\n});\n\n// \"inline definition\" solution\nwf.setHandler(wf.defineSignal(`task-${taskAId}`), (payload) => {\n  /* do task A things */\n});\nwf.setHandler(wf.defineSignal(`task-${taskBId}`), (payload) => {\n  /* do task B things */\n});\n\n// utility \"inline definition\" helper\nconst inlineSignal = (signalName, handler) =>\n  wf.setHandler(wf.defineSignal(signalName), handler);\ninlineSignal(`task-${taskBId}`, (payload) => {\n  /* do task B things */\n});\n```\n\n<details>\n  <summary>\n    API Design FAQs\n  </summary>\n\n#### Why not `new Signal` and `new Query`?\n\nThe semantic of `defineSignal`/`defineQuery` is intentional, in that they return Signal/Query **Definitions**, not unique instances of Signals and Queries themselves. [This is their entire source code](https://github.com/temporalio/sdk-typescript/blob/fc658d3760e6653aec47732ab17a0062b7dd23fc/packages/workflow/src/workflow.ts#L884-L907):\n\n```ts\n/**\n * Define a signal method for a Workflow.\n */\nexport function defineSignal<Args extends any[] = []>(\n  name: string,\n): SignalDefinition<Args> {\n  return {\n    type: 'signal',\n    name,\n  };\n}\n\n/**\n * Define a query method for a Workflow.\n */\nexport function defineQuery<Ret, Args extends any[] = []>(\n  name: string,\n): QueryDefinition<Ret, Args> {\n  return {\n    type: 'query',\n    name,\n  };\n}\n```\n\nSignals/Queries are only instantiated in `setHandler` and are specific to a particular Workflow Execution.\n\nThese distinctions may seem minor, but they model how Temporal works under the hood, because Signals and Queries are messages identified by \"just strings\" and don't have meaning independent of the Workflow having a listener to handle them.\nThis will be clearer if you refer to the Client-side APIs below.\n\n#### Why `setHandler` and not OTHER_API?\n\nWe named it `setHandler` instead of `subscribe` because Signals/Queries can only have one \"handler\" at a time, whereas `subscribe` could imply an Observable with multiple consumers, and is a higher level construct.\n\n```ts\nwf.setHandler(MySignal, handlerFn1);\nwf.setHandler(MySignal, handlerFn2); // replaces handlerFn1\n```\n\nIf you are familiar with [RxJS](https://rxjs.dev/), you are free to wrap your Signal and Query into Observables if you wish, or you could dynamically reassign the listener based on your business logic or Workflow state.\n\n</details>\n\n### Invoke Signals and Queries from a Client\n\nSending Signals and making Queries requires having a Workflow handle from a [Temporal Client](/typescript/clients).\n\n- You send a Signal with `handle.signal(signal, ...args)`. A Signal has no return value by definition.\n- You make a Query with `handle.query(query, ...args)`. A Query needs a return value, but can also take args.\n- You can refer to either by string name, which is useful for dynamic reference, but you will lose type inference.\n\n```ts\n// // inside Client code! not Workflow code!\nimport { count, increment } from './workflow';\n\n// init client code omitted - see Client docs\nconst handle = client.getHandle(workflowId);\n\n// these three are equivalent\nawait handle.signal(increment, 1);\nawait handle.signal<[number]>('increment', 1);\nawait client.getHandle(workflowId).signal(increment, 1);\n\n// these three are equivalent\nlet state = await handle.query(count);\nlet state = await handle.query<number>('count');\nlet state = await client.getHandle(workflowId).query(count);\n```\n\nBy design of these Workflow handles, two different Workflows can use the same Signal or Query and there is still no ambiguity, because you always have to specify which Workflow you are signalling (`workflowHandle1.signal(MySignal)` vs `workflowHandle2.signal(MySignal)`).\n\n### Signals and Queries design patterns\n\nBecause Signals and Queries are intentionally flexible, you can wrap them up into reusable functions:\n\n<Tabs\ndefaultValue=\"export\"\nvalues={[\n{label: 'Exportable', value: 'export'},\n{label: 'Concise', value: 'short'},\n]\n}>\n\n<TabItem value=\"export\">\n\n```ts\n// implementation of queryable + signallable State in Workflow file\nimport * as wf from '@temporalio/workflow';\n\nfunction useState<T = any>(name: string, initialValue: T) {\n  const signal = wf.defineSignal<[T]>(name);\n  const query = wf.defineQuery<T>(name);\n  let state: T = initialValue;\n  return {\n    signal,\n    query,\n    get value() {\n      // need to use closure because function doesn't rerun unlike React Hooks\n      return state;\n    },\n    set value(newVal: T) {\n      state = newVal;\n    },\n  };\n}\n\n// usage in Workflow file\nconst store = useState('your-store', 10);\nfunction YourWorkflow() {\n  wf.setHandler(store.signal, (newValue: T) => {\n    // console.log('updating', newValue) // optional but useful for debugging\n    store.value = newValue;\n  });\n  wf.setHandler(store.query, () => store.value);\n  while (true) {\n    console.log('sleeping for ', store.value);\n    wf.sleep(store.value++ * 100); // you can mutate the value as well\n  }\n}\n\n// usage in Client file\nawait handle.signal(store.signal, 30);\nconst storeState = handle.query<number>(store.query); // 30\n```\n\n</TabItem>\n<TabItem value=\"short\">\n\n```ts\n// alternative, more concise but slightly less safe implementation\nimport * as wf from '@temporalio/workflows';\n\nfunction useState<T = any>(name: string, initialValue: T) {\n  const signal = wf.defineSignal<[T]>(name);\n  const query = wf.defineQuery<T>(name);\n  let state: T = initialValue;\n  wf.setHandler(signal, (newVal: T) => void (newVal = state));\n  wf.setHandler(query, () => state);\n  return {\n    signal,\n    query,\n    get value() {\n      return state;\n    },\n    set value(newVal: T) {\n      state = newVal;\n    },\n  };\n}\n\n// usage in Workflow file\nfunction YourWorkflow() {\n  const store = useState('your-store', 10); // needs to be inside because function uses setHandler\n  while (true) {\n    console.log('sleeping for ', store.value);\n    wf.sleep(store.value++ * 100); // you can mutate the value as well\n  }\n}\n\n// usage in Client file\nawait handle.signal('your-store', 30);\nconst storeState = handle.query<number>('your-store'); // 30\n```\n\n</TabItem>\n</Tabs>\n\nYou can even conditionally set handlers, or set handlers inside handlers:\n\n```ts\nimport * as wf from '@temporalio/workflow';\nfunction YourWorkflow(signallable: boolean, signalNames: string[]) {\n  // conditional setting of handlers\n  if (signallable) {\n    wf.setHandler(MySignal, handler);\n  }\n\n  // set same handler for an array of signals by name\n  signalNames.forEach((name) => wf.setHandler(name, handler));\n\n  // signal handler that sets signal handlers\n  // // would be nice to send a function but we can't because it is not serializable\n  wf.setHandler(MySignal, (handlerName) => {\n    wf.setHandler(handlerName, handlers[handlerName]);\n  });\n}\n```\n\n### Additional Signals and Queries Notes\n\n#### Type-safety for Signals and Queries\n\nThe Signals and Queries API has been designed with type safety in mind:\n\n- `wf.defineQuery<Ret, Args>(name): QueryDefinition<Ret, Args>`\n- `wf.defineSignal<Args>(name): SignalDefinition<Args>`\n- `handle.query<Ret, Args>(def, ...args): Promise<Ret>`\n- `handle.signal<Args>(def, ...args): Promise<Ret>`\n\nYou can either:\n\n- Define the argument type (and, for Queries, the return type) up front and import it for type inference with the `WorkflowHandle`\n- Define the expected type at the call site when you invoke the Signal/Query.\n\n```ts\nconst increment = wf.defineSignal<[number /* more args can be added here */]>(\n  'increment',\n);\nconst count = wf.defineQuery<number /*, Arg[] can be added here */>('count');\n\n// type safety inferred from definitions\nawait handle.signal(increment, 1);\nawait handle.signal(increment); // Expected 2 arguments, but got 1.\nawait handle.signal(increment, '1'); // Argument of type 'string' is not assignable to parameter of type 'number'\n\n// common problems when you lack type safety\nawait handle.signal('increment'); // No TS error but insufficient arguments\nawait handle.signal('increment', '1'); // No TS error but sending in wrong type\n\n// add type safety at callsite\nawait handle.signal<[number]>('increment'); // Expected 2 arguments, but got 1.\nlet state = await handle.query<number, [string]>('print', 'Count: ');\n```\n\n#### Notes on Signals\n\n- Signal handlers are only guaranteed to be called in order **per Signal Type**, not across all of them.\n  If you need strict ordering across multiple Signals, either:\n  - Combine them into one Signal Type and use a `switch` statement.\n  - Register handlers statically (call `setHandler` outside of the Workflow function).\n- `WorkflowHandle.signal` resolves as soon as Temporal Server has persisted the Signal, before the Workflow's Signal handler is called.\n- `WorkflowHandle.signal` Promise resolves with no value; **Signal handlers cannot return data to the caller.**\n- **No Synchronous Updates**.\n  Users often want Signals to return a value, for example, a validation error.\n  However Temporal has no way to surface any error to the external invocation.\n  Signals are always asynchronous, in other words, **a Signal always succeeds**.\n  Long term, the solution to this is \"Synchronous Update\" and [it is under active development](https://github.com/temporalio/proposals/pull/53).\n\nFor now [the best workaround](https://community.temporal.io/t/signalling-system-human-driven-workflows/160/2) is to use a Query to return Workflow state after signaling.\nTemporal guarantees read-after-write consistency of Signals-followed-by-Queries.\n\n#### Notes on Queries\n\n> 🚨 WARNING: NEVER mutate Workflow state inside a query! Generating Commands in Query handlers can lead to unexpected behaviors on subsequent executions.\n\n:::danger How NOT to write a Query\n\nThis mutates Workflow state - do not do this:\n\n```ts\nexport function badExample() {\n  let someState = 123;\n  wf.setHandler(query, () => {\n    return someState++; // bad! don't do this!\n  });\n}\n```\n\n:::\n\n#### Reusing Signals and Queries in Libraries\n\nBecause Signal and Query Definitions are separate from Workflow Definitions, we can now compose them together:\n\n```ts\n// basic reusable Workflow component\nexport async function unblocked() {\n  let isBlocked = true;\n  wf.setHandler(unblockSignal, () => (isBlocked = false));\n  wf.setHandler(isBlockedQuery, () => isBlocked);\n  await wf.condition(() => !isBlocked);\n}\n\n// usage: signals can be sent to each Workflow separately\nexport async function yourWorkflow1() {\n  await unblocked();\n}\nexport async function yourWorkflow2() {\n  await unblocked();\n}\n```\n\nAnother example of componentization can be found in our [code samples](https://github.com/temporalio/samples-typescript/blob/854c78955601a6b63aa8ea412cfb5eaf61bd78ee/expense/src/workflows.ts#L19).\n\n### `signalWithStart`\n\nIf you're not sure if a Workflow is running, you can `signalWithStart` a Workflow to send it a Signal and optionally start the Workflow if it is not running.\nArguments for both are sent as needed.\n\n```ts\n// Signal With Start in Client file\nconst client = new WorkflowClient();\nawait client.signalWithStart(YourWorkflow, {\n  workflowId,\n  args: [arg1, arg2],\n  signal: MySignal,\n  signalArgs: [arg3, arg4],\n});\n```\n\nSee the [Workflow Client](/typescript/clients/#workflow-options) docs for more notes on how starting Workflows and Workflow Options look like.\n\n## Deferred Execution\n\n`sleep` and `condition` help you write durable asynchronous code in Temporal by offering an easy to use Promise-like API, but deferring, persisting, and resuming execution behind the scenes.\n\n- In other words, they do not \"lock\" the process, allowing one Worker to concurrently process hundreds of Workflows that sleep and await arbitrary conditions.\n- They are also \"cancellation aware\", allowing for graceful cleanup if the Workflow they are linked to is canceled.\n  For more information, see [Cancellation Scopes](/typescript/cancellation-scopes).\n\nThe Workflow's V8 isolate environment completely replaces the JavaScript [`setTimeout`](https://typescript.temporal.io/api/namespaces/workflow/#timers) global, including inside libraries that you use, to provide a complete JavaScript runtime.\nWe recommend using our [`sleep(timeout)`](https://typescript.temporal.io/api/namespaces/workflow/#sleep) API instead, because it is a cancellation-aware Promise wrapper for `setTimeout`.\n\n<details>\n<summary>\nWhy Durable Timers Are a Hard Problem\n</summary>\n\nJavaScript has a `setTimeout`, which seems relatively straightforward.\nHowever, they are held in memory - if your system goes down, those timers are gone.\n\nA lot of careful code is required to make these timeouts fully reliable (aka recoverable in case of outage) and cancellation aware.\n\n<!-- Note: these are rough Durable Timer notes from Maxim - we should build out examples and really hit home why you want to use us rather than write your own, in future.\nWhen writing Workflows with timers, you need to take care that it handles jumps of time.\nWhat we mean by \"handling jumps\": if you had timers that were supposed to go off at 1.15, 1.30, and 1.45pm, and your system goes down from 1pm to 2pm, then at 2pm when the system comes back up all 3 timers will fire at once. If your workflow code relies on the timers resolving in precise order, write these checks yourself.\n-->\n\nBeyond that, further engineering is needed to scale this - imagine 100,000 independently running timers in your system, firing every minute.\nThat is the kind of scale Temporal handles.\n\n</details>\n\n### `sleep`\n\n`sleep` sets a durable timer for a fixed time period (an \"Updatable Timer\" pattern is documented below).\nIt uses the [ms](https://www.npmjs.com/package/ms) package to take either a string or number of milliseconds, and returns a promise that you can `await` and `catch` when the Workflow Execution is cancelled.\n\n```ts\nimport { sleep } from '@temporalio/workflow';\n\nawait sleep('30 days'); // string API\nawait sleep(30 * 24 * 60 * 60 * 1000); // numerical API\n\n// `sleep` is cancellation-aware\n// when workflow gets canceled during sleep, promise is rejected\nawait sleep('30 days').catch(() => {\n  // clean up code if workflow is canceled during sleep\n});\n\n// NOT VALID\nawait sleep('1 month'); // ms package doesnt support \"months\" https://github.com/vercel/ms/issues/57\n// use date-fns and sleepUntil instead, see below\n```\n\nWith this primitive, you can build other abstractions. For example, a `sleepUntil` function that converts absolute time to relative time with `date-fns`:\n\n```ts\nimport * as wf from '@temporalio/workflow';\nimport differenceInMilliseconds from 'date-fns/differenceInMilliseconds';\n\nasync function sleepUntil(futureDate, fromDate = new Date()) {\n  const timeUntilDate = differenceInMilliseconds(\n    new Date(futureDate),\n    fromDate,\n  );\n  return wf.sleep(timeUntilDate);\n}\n\nsleepUntil('30 Sep ' + (new Date().getFullYear() + 1)); // wake up when September ends\nsleepUntil('5 Nov 2022 00:12:34 GMT'); // wake up at specific time and timezone\n```\n\nYou can check the valid ISO string formats on [MDN's Date docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). The upcoming [ECMAScript Temporal API](https://tc39.es/proposal-temporal/docs/index.html) will offer more time utilities natively in JavaScript, alongside unfortunate name collision for Temporal developers.\n\n:::caution Preventing Confusion: Workflow sleep vs Activity sleep\n\nThere is an unrelated [`sleep` utility function](https://typescript.temporal.io/api/classes/activity.Context/#sleep) available in **Activity Context** that is not durable, but is cancellation aware. See [the Activities docs for details](/typescript/activities).\n\n:::\n\n### `condition`\n\nThe `condition(fn, timeout?)` API returns a promise that resolves:\n\n- `true` when the given predicate function (**must be synchronous**) returns `true` or\n- (optional) `false` if a timeout (given as a string or number of milliseconds) happens first.\n\nThis API is comparable to `Workflow.await` in other SDKs and often used to wait for Signals, since Signals are the main way to asynchronously update internal Workflow state (looped Activities are another).\n\nThe timeout also uses the [ms](https://www.npmjs.com/package/ms) package to take either a string or number of milliseconds.\n\n```ts\n// type signature\nexport function condition(\n  fn: () => boolean,\n  timeout: number | string,\n): Promise<boolean>;\nexport function condition(fn: () => boolean): Promise<void>;\n\n// Usage\nimport * as wf from '@temporalio/workflow';\n\nlet x = 0;\n// do stuff with x, eg increment every time you receive a signal\nawait wf.condition(() => x > 3);\n// you only reach here when x > 3\n\n// await either x > 3 or 30 minute timeout, whichever comes first\nif (await wf.condition(() => x > 3, '30 mins')) {\n  // reach here if predicate true\n} else {\n  // reach here if timed out\n}\n\n// track user progress with condition\nexport async function trackStepChanges(): Promise<void> {\n  let step = 0;\n  wf.setHandler(updateStep, (s) => void (step = s));\n  wf.setHandler(getStep, () => step);\n  await wf.condition(() => step === 1);\n  await wf.condition(() => step === 2);\n}\n```\n\n<details>\n<summary>Example usage in our Next.js One-Click Buy code sample</summary>\n\n`condition` only returns true when the function evaluates to `true`; if the `condition` resolves as `false`, then a timeout has occurred.\nThis leads to some nice patterns, like placing `await condition` inside an `if`:\n\n<!--SNIPSTART typescript-oneclick-buy-->\n\n[nextjs-ecommerce-oneclick/temporal/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/nextjs-ecommerce-oneclick/temporal/src/workflows.ts)\n\n```ts\nexport async function OneClickBuy(itemId: string) {\n  const itemToBuy = itemId;\n  let purchaseState: PurchaseState = 'PURCHASE_PENDING';\n  wf.setHandler(\n    cancelPurchase,\n    () => void (purchaseState = 'PURCHASE_CANCELED'),\n  );\n  wf.setHandler(purchaseStateQuery, () => purchaseState);\n  if (await wf.condition(() => purchaseState === 'PURCHASE_CANCELED', '5s')) {\n    return await canceledPurchase(itemToBuy);\n  } else {\n    purchaseState = 'PURCHASE_CONFIRMED';\n    return await checkoutItem(itemToBuy);\n  }\n}\n```\n\n<!--SNIPEND-->\n\n</details>\n\n:::warning `condition` Antipatterns\n\n- No time based condition functions are allowed in your function as this is very error prone.\n  Use the optional `timeout` arg or a `sleep` timer.\n- `condition` only accepts **synchronous** functions that return a boolean.\n  Do not put async functions, like Activities, inside the `condition` function.\n\n:::\n\n<!--TODO: give an idea of what the bad code looks like and why its bad-->\n\n### Async design patterns\n\nThe real value of `sleep` and `condition` is in knowing how to use them to model asynchronous business logic.\nHere are some examples we use the most; we welcome more if you can think of them!\n\n<details>\n<summary>\nRacing Timers\n</summary>\n\nUse `Promise.race` with Timers to dynamically adjust delays.\n\n```ts\nexport async function processOrderWorkflow({\n  orderProcessingMS,\n  sendDelayedEmailTimeoutMS,\n}: ProcessOrderOptions): Promise<void> {\n  let processing = true;\n  const processOrderPromise = processOrder(orderProcessingMS).then(() => {\n    processing = false;\n  });\n\n  await Promise.race([processOrderPromise, sleep(sendDelayedEmailTimeoutMS)]);\n\n  if (processing) {\n    await sendNotificationEmail();\n    await processOrderPromise;\n  }\n}\n```\n\n</details>\n<details>\n<summary>\nRacing Signals\n</summary>\n\nUse `Promise.race` with Signals and Triggers to have a promise resolve at the earlier of either system time or human intervention.\n\n```ts\nimport { defineSignal, sleep, Trigger } from '@temporalio/workflow';\n\nconst userInteraction = new Trigger<boolean>();\nconst completeUserInteraction = defineSignal('completeUserInteraction');\n\nexport async function yourWorkflow(userId: string) {\n  setHandler(completeUserInteraction, () => userInteraction.resolve(true)); // programmatic resolve\n  const userInteracted = await Promise.race([\n    userInteraction,\n    sleep('30 days'),\n  ]);\n  if (!userInteracted) {\n    await sendReminderEmail(userId);\n  }\n}\n```\n\nYou can invert this to create a Reminder pattern where the promise resolves IF no Signal is received.\n\n:::warning Antipattern: Racing sleep.then\n\nBe careful when racing a chained `sleep`. This may cause bugs because the chained `.then` will still continue to execute.\n\n```js\nawait Promise.race([\n  sleep('5s').then(() => (status = 'timed_out')),\n  somethingElse.then(() => (status = 'processed')),\n]);\n\nif (status === 'processed') await complete(); // takes more than 5 seconds\n// status = timed_out\n```\n\n:::\n\n</details>\n\n<details>\n<summary>\nUpdatable Timer\n</summary>\n\nHere is how you can build an updatable timer with `condition`:\n\n```ts\nimport * as wf from '@temporalio/workflow';\n\n// usage\nexport async function countdownWorkflow(): Promise<void> {\n  const target = Date.now() + 24 * 60 * 60 * 1000; // 1 day!!!\n  const timer = new UpdatableTimer(target);\n  console.log('timer set for: ' + new Date(target).toString());\n  wf.setHandler(setDeadlineSignal, (deadline) => {\n    // send in new deadlines via Signal\n    timer.deadline = deadline;\n    console.log('timer now set for: ' + new Date(deadline).toString());\n  });\n  wf.setHandler(timeLeftQuery, () => timer.deadline - Date.now());\n  await timer; // if you send in a signal with a new time, this timer will resolve earlier!\n  console.log('countdown done!');\n}\n```\n\nThis is available in the third party [`temporal-time-utils`](https://www.npmjs.com/package/temporal-time-utils#user-content-updatabletimer) package where you can also see the implementation:\n\n```ts\n// implementation\nexport class UpdatableTimer implements PromiseLike<void> {\n  deadlineUpdated = false;\n  #deadline: number;\n\n  constructor(deadline: number) {\n    this.#deadline = deadline;\n  }\n\n  private async run(): Promise<void> {\n    /* eslint-disable no-constant-condition */\n    while (true) {\n      this.deadlineUpdated = false;\n      if (\n        !(await wf.condition(\n          () => this.deadlineUpdated,\n          this.#deadline - Date.now(),\n        ))\n      ) {\n        break;\n      }\n    }\n  }\n\n  then<TResult1 = void, TResult2 = never>(\n    onfulfilled?: (value: void) => TResult1 | PromiseLike<TResult1>,\n    onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>,\n  ): PromiseLike<TResult1 | TResult2> {\n    return this.run().then(onfulfilled, onrejected);\n  }\n\n  set deadline(value: number) {\n    this.#deadline = value;\n    this.deadlineUpdated = true;\n  }\n\n  get deadline(): number {\n    return this.#deadline;\n  }\n}\n```\n\n</details>\n\n### Triggers\n\n[Triggers](https://typescript.temporal.io/api/classes/workflow.Trigger) are a Promise-like concept in the TypeScript SDK.\n\nTriggers, like the [`condition()`](#condition) return value and other Promises, can be awaited and expose a `then` method.\nUnlike Promises, they export `resolve` or `reject` methods, so you can programmatically control them.\n\n<details>\n<summary>\nTrigger Code Example\n</summary>\n\n```ts\nimport { defineSignal, sleep, Trigger } from '@temporalio/workflow';\n\nconst userInteraction = new Trigger<boolean>();\nconst completeUserInteraction = defineSignal('completeUserInteraction');\n\nexport async function yourWorkflow(userId: string) {\n  setHandler(completeUserInteraction, () => userInteraction.resolve(true)); // programmatic resolve\n  const userInteracted = await Promise.race([\n    userInteraction,\n    sleep('30 days'),\n  ]);\n  if (!userInteracted) {\n    await sendReminderEmail(userId);\n  }\n}\n```\n\n`Trigger` is `CancellationScope`-aware. It is linked to the current scope on construction and throws when that scope is cancelled.\n\n</details>\n\n## Child Workflows\n\nBesides Activities, a Workflow can also start other, \"Child\" Workflows.\nChild Workflows have a subset of APIs from [Temporal Clients](/typescript/clients), including how to start/execute/handle Workflows.\n\n[`startChild`](https://typescript.temporal.io/api/namespaces/workflow/#startchild) starts a child workflow without awaiting completion, and returns a [`ChildWorkflowHandle`](https://typescript.temporal.io/api/interfaces/workflow.ChildWorkflowHandle):\n\n```ts\nimport { startChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(names: string[]) {\n  const childHandle = await startChild(childWorkflow, {\n    args: [name],\n    // workflowId, // add business-meaningful workflow id here\n    // // regular workflow options apply here, with two additions (defaults shown):\n    // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n    // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n  });\n  // you can use childHandle to signal or get result here\n  await childHandle.signal('anySignal');\n  const result = childHandle.result();\n  // you can use childHandle to signal, query, cancel, terminate, or get result here\n}\n```\n\nYou should use [cancellationScopes](/typescript/cancellation-scopes) if you need to cancel Child Workflows.\n\n[`executeChild`](https://typescript.temporal.io/api/namespaces/workflow/#executechild) starts a child workflow and awaits (blocks until) its completion:\n\n<!--SNIPSTART typescript-child-workflow-->\n\n[child-workflows/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/child-workflows/src/workflows.ts)\n\n```ts\nimport { executeChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(...names: string[]): Promise<string> {\n  const responseArray = await Promise.all(\n    names.map((name) =>\n      executeChild(childWorkflow, {\n        args: [name],\n        // workflowId, // add business-meaningful workflow id here\n        // // regular workflow options apply here, with two additions (defaults shown):\n        // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n        // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n      })\n    ),\n  );\n  return responseArray.join('\\n');\n}\n```\n\n<!--SNIPEND-->\n\nTo control any running Workflow from inside a Workflow, use [`getExternalWorkflowHandle(workflowId)`](https://typescript.temporal.io/api/namespaces/workflow/#getexternalworkflowhandle).\n\n```ts\nimport { getExternalWorkflowHandle, workflowInfo } from '@temporalio/workflow';\n\nexport async function terminateWorkflow() {\n  const { workflowId } = workflowInfo(); // no await needed\n  const handle = getExternalWorkflowHandle(workflowId); // sync function, not async\n  await handle.cancel();\n}\n```\n\nSpecial Notes:\n\n- Child Workflow options automatically inherit their values from the Parent Workflow options if they are not explicitly set. They have two advanced options unique to Child Workflows:\n  - [`cancellationType`](https://typescript.temporal.io/api/enums/proto.coresdk.child_workflow.ChildWorkflowCancellationType): Controls at which point to throw the CanceledFailure exception when a child workflow is cancelled\n  - `parentClosePolicy`: Explained below\n- Child Workflow Executions are [`CancellationScope`](/typescript/cancellation-scopes) aware and will automatically be cancelled when their containing scope is cancelled.\n\n<details>\n<summary>\nWhen to use Child Workflows vs Activities\n</summary>\n\nChild Workflows and Activities are both started from Workflows, so you may feel confused about when to use which.\nHere are some important differences:\n\n- Child Workflows have access to all Workflow APIs, but are subject to [Workflow Limitations](/typescript/workflows#workflow-limitations). Activities have the inverse pros and cons.\n- Child Workflows can continue on if their Parent is canceled, with a [ParentClosePolicy](/concepts/what-is-a-parent-close-policy/) of `ABANDON`, whereas Activities are _always_ canceled when their Workflow is canceled (they may react to a [cancellationSignal](/typescript/activities#activity-cancellation) for cleanup if canceled). The decision is roughly analogous to spawning a child process in a terminal to do work vs doing work in the same process.\n- Temporal tracks all state changes within Child Workflows in Event History, whereas only the input, output, and retry attempts of Activities are tracked.\n\nActivities usually model a single operation on the external world. Workflows are modeling composite operations that consist of multiple activities or other child workflows.\n\n**When in doubt, use Activities.**\n\n</details>\n\n<RelatedReadList\nreadlist={[\n[\"What is a Child Workflow Execution?\",\"/concepts/what-is-a-child-workflow-execution\",\"explanation\"]\n]}\n/>\n\n### Parent Close Policy\n\nimport PCP from '../concepts/what-is-a-parent-close-policy.md'\n\n<PCP />\n\n<span id=\"continueasnew\" />\n\n## `continueAsNew`\n\nWe need to call `continueAsNew` before our Workflow History exceeds 51,200 Events. [Events](../concepts/what-is-an-event) are generated when a Workflow does various things involving Temporal Server, including calling an Activity, receiving a Signal, or calling `sleep`, but not handling a Query.\n\n<details>\n<summary>More info</summary>\n\n[What is Continue-As-New?](/concepts/what-is-continue-as-new)\n\n</details>\n\n[`continueAsNew`](https://typescript.temporal.io/api/namespaces/workflow#continueasnew) stops the current Workflow Execution and starts another one with new arguments and an empty Event History. Note that this is done immediately, so make sure that your Signal handlers have finished running before calling `continueAsNew`.\n\n<!--SNIPSTART typescript-continue-as-new-workflow-->\n\n[continue-as-new/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/continue-as-new/src/workflows.ts)\n\n```ts\nimport { continueAsNew, sleep } from '@temporalio/workflow';\n\nexport async function loopingWorkflow(iteration = 0): Promise<void> {\n  if (iteration === 10) {\n    return;\n  }\n  console.log('Running Workflow iteration:', iteration);\n  await sleep(1000);\n  // Must match the arguments expected by `loopingWorkflow`\n  await continueAsNew<typeof loopingWorkflow>(iteration + 1);\n  // Unreachable code, continueAsNew is like `process.exit` and will stop execution once called.\n}\n```\n\n<!--SNIPEND-->\n\nYou can also call `continueAsNew` from a signal handler or `continueAsNew` to a different Workflow (or different Task Queue) using [`makeContinueAsNewFunc`](https://nodejs.temporal.io/api/namespaces/workflow/#makecontinueasnewfunc).\n\nIf you need to know whether a Workflow was started via `continueAsNew`, you can pass an optional last argument as true:\n\n```ts\nexport async function loopingWorkflow(foo: any, isContinued?: boolean) {\n  // some logic based on foo, branching on isContinued\n\n  (await continueAsNew)<typeof loopingWorkflow>(foo, true);\n}\n```\n\n### Don't overuse\n\nYou should not try to call `continueAsNew` too often - if at all!\nIts primary purpose is to truncate event history, which if too large may slow down your workflows and eventually cause an error. Calling it too frequently to be preemptive can cause other performance issues as each new Workflow Execution has overhead.\n\nTemporal's default limits are set to warn you after the Event History exceeds 10,240 Events in a single Workflow Execution, and error after the Event History exceeds 51,200 Events.\nThis is sufficient for:\n\n- If executing one activity a day, it can support an infinite loop for over 2 decades (27 years)\n- If executing one activity an hour, it can support an infinite loop for over 1 year (417 days)\n- If executing one activity a minute, it can support an infinite loop for over 1 week (7 days)\n\nwithout even resorting to `continueAsNew`.\n\nOur recommendation is to size it to continue as new between once a day to once a week, to ensure old version branches can be removed in a timely manner.\n\n### Example\n\nHere is a simple pattern that we recommend to represent a single entity. It keeps track of the number of iterations regardless of frequency, and calls `continueAsNew` while properly handling pending updates from Signals.\n\n```tsx\ninterface Input {\n  /* define your workflow input type here */\n}\ninterface Update {\n  /* define your workflow update type here */\n}\n\nconst MAX_ITERATIONS = 1;\n\nexport async function entityWorkflow(\n  input: Input,\n  isNew = true,\n): Promise<void> {\n  try {\n    const pendingUpdates = Array<Update>();\n    setHandler(updateSignal, (updateCommand) => {\n      pendingUpdates.push(updateCommand);\n    });\n\n    if (isNew) {\n      await setup(input);\n    }\n\n    for (let iteration = 1; iteration <= MAX_ITERATIONS; ++iteration) {\n      // Ensure that we don't block the Workflow Execution forever waiting\n      // for updates, which means that it will eventually Continue-As-New\n      // even if it does not receive updates.\n      await condition(() => pendingUpdates.length > 0, '1 day');\n\n      while (pendingUpdates.length) {\n        const update = pendingUpdates.shift();\n        await runAnActivityOrChildWorkflow(update);\n      }\n    }\n  } catch (err) {\n    if (isCancellation(err)) {\n      await CancellationScope.nonCancellable(async () => {\n        await cleanup();\n      });\n    }\n    throw err;\n  }\n  await continueAsNew<typeof entityWorkflow>(input, false);\n}\n```\n\n<span id=\"putting-it-all-together-schedule-workflow-example\" />\n\n## Workflow Utility Libraries\n\nAs you build up strong opinions of how you'd like to compose behavior, you may want to publish reusable Temporal utility function or Temporal Workflow libraries. Let us know and we'd be happy to feature them here!\n\n- [temporal-time-utils](https://www.npmjs.com/package/temporal-time-utils): Contains reusable versions of `sleepUntil`, `UpdatableTimer`, and `ScheduleWorkflow` described on this page.\n\nJust keep in mind the difference between utility functions (deterministic, uses Workflow APIs but have to be inlined into Workflows rather than used standalone) and Workflow functions (can be used standalone, and subject to all Workflow limitations, including that all args and results must be JSON-serializable.)\n","is_empty":false},{"file_name":"cluster-metrics.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/cluster-metrics.md","id":"references/cluster-metrics","title":"Temporal OSS Cluster metrics reference","description":"The Temporal Cluster emits a range of metrics to help operators get visibility into the Cluster’s performance and set up alerts.","label":"Cluster metrics","tags":["reference"],"ssdi":[],"markdown_content":"\n:::info OSS Cluster metrics\n\nThe information on this page is relevant to open source [Temporal Cluster deployments](/concepts/what-is-a-temporal-cluster).\n\nSee [Cloud metrics](/cloud/how-to-monitor-temporal-cloud-metrics) for metrics emitted by [Temporal Cloud](/concepts/what-is-temporal-cloud).\n\nSee [SDK metrics](/references/sdk-metrics) for metrics emitted by the [SDKs](/concepts/what-is-a-temporal-sdk).\n\n:::\n\nA Temporal Cluster emits a range of metrics to help operators get visibility into the Cluster’s performance and to set up alerts.\n\nAll metrics emitted by the Cluster are listed in [defs.go](https://github.com/temporalio/temporal/blob/master/common/metrics/defs.go).\n\nFor details on setting up metrics in your Cluster configuration, see [Temporal Cluster](/references/configuration#global).\n\nThe [dashboards repository](https://github.com/temporalio/dashboards) contains community-driven Grafana dashboard templates that can be used as a starting point for monitoring the Temporal Cluster and SDK metrics.\nYou can use these templates as references to build your own dashboards.\nFor any metrics that are missing in the dashboards, use [defs.go](https://github.com/temporalio/temporal/blob/master/common/metrics/defs.go) as a reference.\n\nNote that, apart from these metrics emitted by the Cluster, you should also monitor infrastructure-specific metrics like CPU, memory, and network for all hosts that are running Temporal Cluster services.\n\n## Common metrics\n\nTemporal emits metrics for each gRPC service request.\nThese metrics are emitted with `type`, `operation`, and `namespace` tags, which provide visibility into Service usage and show the request rates across Services, Namespaces, and Operations.\n\n- Use the `operation` tag in your query to get request rates, error rates, or latencies per operation.\n- Use the `service_name` tag with the [service role tag values](https://github.com/temporalio/temporal/blob/bba148cf1e1642fd39fa0174423b183d5fc62d95/common/metrics/defs.go#L108) to get details for the specific service.\n\nAll common tags that you can add in your query are defined in the [defs.go](https://github.com/temporalio/temporal/blob/master/common/metrics/defs.go) file.\n\nFor example, to see service requests by operation on the Frontend Service, use the following:\n\n`sum by (operation) (rate(service_requests{service_name=\"frontend\"}[2m]))`\n\nNote: All metrics queries in this topic are [Prometheus queries](https://prometheus.io/docs/prometheus/latest/querying/basics/).\n\nThe following list describes some metrics you can get started with.\n\n### `service_requests`\n\nShows service requests received per Task Queue.\nExample: Service requests by operation\n`sum(rate(service_requests{operation=\\\"AddWorkflowTask\\\"}[2m]))`\n\n### `service_latency`\n\nShows latencies for all Client request operations.\nUsually these are the starting point to investigate which operation is experiencing high-latency issues.\nExample: P95 service latency by operation for the Frontend Service\n`histogram_quantile(0.95, sum(rate(service_latency_bucket{service_name=\"frontend\"}[5m])) by (operation, le))`\n\n### `service_error_with_type`\n\n(Available only in v1.17.0+) Identifies errors encountered by the service.\nExample: Service errors by type for the Frontend Service\n`sum(rate(service_errors_with_type{service_name=\"frontend\"}[5m])) by (error_type)`\n\n### `client_errors`\n\nAn indicator for connection issues between different Server roles.\nExample: Client errors\n`sum(rate(client_errors{service_name=\"frontend\",service_role=\"history\"}[5m]))`\n\nIn addition to these, you can define some service-specific metrics to get performance details for each service.\nStart with the following list, and use [defs.go](https://github.com/temporalio/temporal/blob/master/common/metrics/defs.go) to define additional metrics as required.\n\n## Matching Service metrics\n\n### `poll_success`\n\nShows for Tasks that are successfully matched to a poller.\nExample: `sum(rate(poll_success{}[5m]))`\n\n### `poll_timeouts`\n\nShows when no Tasks are available for the poller within the poll timeout.\nExample: `sum(rate(poll_timeouts{}[5m]))`\n\n### `asyncmatch_latency`\n\nMeasures the time from creation to delivery for async matched Tasks.\nThe larger this latency, the longer Tasks are sitting in the queue waiting for your Workers to pick them up.\nExample: `histogram_quantile(0.95, sum(rate(asyncmatch_latency_bucket{service_name=~\"matching\"}[5m])) by (operation, le))`\n\n### `no_poller_tasks`\n\nEmitted whenever a task is added to a task queue that has no poller, and is a counter metric.\nThis is usually an indicator that either the Worker or the starter programs are using the wrong Task Queue.\nUse `no_poller_tasks_per_tl` to get data per Task Queue.\n\n## History Service metrics\n\nA History Task is an internal Task in Temporal that is created as part of a transaction to update Workflow state and is processed by the Temporal History service.\nIt is critical to ensure that the History Task processing system is healthy.\nThe following key metrics can be used to monitor the History Service health:\n\n### `task_requests`\n\nEmitted on every Task process request.\nExample: `sum(rate(task_requests{service=\"$service\",operation=~\"TransferActive.*\"}[1m]))`\n\n### `task_errors`\n\nEmitted on every Task process error.\nExample: `sum(rate(task_errors{operation=~\"TransferActive.*\"}[1m]))`\n\n### `task_attempt`\n\nNumber of attempts on each Task Execution.\nA Task is retried forever, and each retry increases the attempt count.\nExample: `histogram_quantile($percentile, sum(rate(task_attempt_bucket{service=\"$service\",operation=~\"TransferActive.*\"}[1m])) by (operation, le))`\n\n### `task_latency_processing`\n\nShows the processing latency per attempt.\nExample: `histogram_quantile($percentile, sum(rate(task_latency_processing_bucket{operation=~\"TransferActive.*\",service=\"$service\", service_name=\"history\"}[1m])) by (operation, le))`\n\n### `task_latency`\n\nMeasures the in-memory latency across multiple attempts.\n\n### `task_latency_queue`\n\nMeasures the duration, end-to-end, from when the Task should be executed (from the time it was fired) to when the Task is done.\n\n### `task_latency_load`\n\n(Available only in v1.18.0+) Measures the duration from Task generation to Task loading (Task schedule to start latency for persistence queue).\n\n### `task_latency_schedule`\n\n(Available only in v1.18.0+) Measures the duration from Task submission (to the Task scheduler) to processing (Task schedule to start latency for in-memory queue).\n\n### `queue_latency_schedule`\n\n(Available only in v1.18.0+) Measures the time to schedule 100 Tasks in one Task channel in the host-level Task scheduler.\nIf fewer than 100 Tasks are in the Task channel for 30 seconds, the latency is scaled to 100 Tasks upon emission.\nNote: This is still an experimental metric and is subject to change.\n\n### `task_latency_userlatency`\n\nShows the latency introduced because of Workflow logic.\nFor example, if you have one Workflow scheduling many Activities or Child Workflows at the same time, it can cause a per-Workflow lock contention.\nThe wait period for the per-Workflow lock is counted as `userlatency`.\n\nThe `operation` tag contains details about Task type and Active versus Standby statuses, and can be used to get request rates, error rates, or latencies per operation, which can help identify issues caused by database problems.\n\n## Persistence metrics\n\nTemporal Server emits metrics for every persistence database read and write.\nSome of the most important ones are the following:\n\n### `persistence_requests`\n\nEmitted on every persistence request.\nExamples:\n\n- Prometheus query for getting the total number of persistence requests by operation for the History Service:\n  `sum by (operation) (rate(persistence_requests{service=\"$service\",service_name=\"history\"}[1m]))`\n- Prometheus query for getting the total number of persistence requests by operation for the Matching Service:\n  `sum by (operation) (rate(persistence_requests{cluster=\"$cluster\",service_name=\"matching\"}[5m]))`\n\n### `persistence_errors`\n\nShows all persistence errors.\nThis metric is a good indicator for connection issues between Temporal Cluster and the persistence store.\nExample:\n\n- Prometheus query for getting all persistence errors by service (history)\n  `sum (rate(persistence_errors{service=\"$service\",service_name=\"history\"}[1m]))`\n\n### `persistence_error_with_type`\n\nShows all errors related to the persistence store with type, and contain an `error_type` tag.\n\n- Prometheus query for getting persistence errors with type by (history) and by error type:\n  `sum(rate(persistence_error_with_type{service=\"$service\",service_name=\"history\"}[1m])) by (error_type)`\n\n### `persistence_latency`\n\nShows the latency on persistence operations.\nExample:\n\n- Prometheus query for getting latency by percentile:\n  `histogram_quantile($percentile, sum(rate(persistence_latency_bucket{service=\"$service\" service_name=\"history\"}[1m])) by (operation, le))`\n","is_empty":false},{"file_name":"commands.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/commands.md","id":"references/commands","title":"Commands reference","description":"A Command is a requested action issued by a Worker to the Temporal Cluster after a Workflow Task Execution completes.","label":"Commands","tags":["reference"],"ssdi":[],"markdown_content":"\nA [Command](/concepts/what-is-a-command) is a requested action issued by a [Worker](/concepts/what-is-a-worker) to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) after a [Workflow Task Execution](/concepts/what-is-a-workflow-task-execution) completes.\n\nThe following is a complete list of possible Commands.\n\n### CompleteWorkflowExecution\n\nThis Command is triggered when the Workflow Function Execution returns.\nIt indicates to the Cluster that the [Workflow Execution](/workflows#workflow-execution) is complete.\nThe corresponding [Event](/concepts/what-is-an-event) for this Command is one of the few Events that will be the last in a Workflow Execution [Event History](/concepts/what-is-an-event-history).\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [WorkflowExecutionCompleted](/references/events/#workflowexecutioncompleted)\n\n### ContinueAsNewWorkflowExecution\n\nThis Command is triggered when there is a call to [Continue-As-New](/concepts/what-is-continue-as-new) from within the [Workflow](/concepts/what-is-a-workflow).\nThe corresponding Event for this Command is one of the few Events that will be the last in a Workflow Execution Event History.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [WorkflowExecutionContinuedAsNew](/references/events/#workflowexecutioncontinuedasnew)\n\n### FailWorkflowExecution\n\nThis Command is triggered when the Workflow Execution returns an error or an exception is thrown.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [WorkflowExecutionFailed](/references/events/#workflowexecutionfailed)\n\n### CancelWorkflowExecution\n\nThis Command is triggered when the Workflow has successfully cleaned up after receiving a Cancellation Request (which will be present as [WorkflowExecutionCancelRequestedEvent](/references/events/#workflowexecutioncancelrequested) in the Event History).\nThe Corresponding Event for this Command is one of the few Events that will be the last in a Workflow Execution Event History.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [WorkflowExecutionCanceled](/references/events/#workflowexecutioncanceled)\n\n### StartChildWorkflowExecution\n\nThis Command is triggered by a call to spawn a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution).\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [ChildWorkflowExecutionStarted](/references/events/#childworkflowexecutionstarted)\n\nBy default, OSS users cannot have more than 50,000 pending Child Workflows.\n\n### SignalExternalWorkflowExecution\n\nThis Command is triggered by a call to [Signal](/concepts/what-is-a-signal) another Workflow Execution.\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [SignalExternalWorkflowExecutionInitiated](/references/events/#signalexternalworkflowexecutioninitiated)\n\nBy default, OSS users cannot have more than 50,000 pending Signals to other Workflows.\n\n### RequestCancelExternalWorkflowExecution\n\nThis Command is triggered by a call to request cancellation of another Workflow Execution.\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [RequestCancelExternalWorkflowExecutionInitiated](/references/events/#requestcancelexternalworkflowexecutioninitiated)\n\nBy default, OSS users cannot have more than 50,000 pending Signals to other Workflows.\n\n### ScheduleActivityTask\n\nThis Command is triggered by a call to execute an [Activity](/concepts/what-is-an-activity).\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [ActivityTaskScheduled](/references/events/#activitytaskscheduled)\n\nBy default, OSS users cannot schedule more than 50,000 Activities.\n\n### RequestCancelActivityTask\n\nThis Command is triggered by a call to request the cancellation of an [Activity Task](/concepts/what-is-an-activity-task).\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [ActivityTaskCancelRequested](/references/events/#activitytaskcancelrequested)\n\n### StartTimer\n\nThis Command is triggered by a call to start a Timer.\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [TimerStarted](/references/events/#timerstarted)\n\n### CancelTimer\n\nThis Command is triggered by a call to cancel a Timer.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [TimerCanceled](/references/events/#timercanceled)\n\n### RecordMarker\n\nThis Command is triggered by the SDK.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [MarkerRecorded](/references/events/#markerrecorded)\n\n### UpsertWorkflowSearchAttributes\n\nThis Command is triggered by a call to \"upsert\" Workflow [Search Attributes](/concepts/what-is-a-search-attribute).\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [UpsertWorkflowSearchAttributes](/references/events/#upsertworkflowsearchattributes)\n\n### ProtocolMessageCommand\n\nThis Command helps guarantee ordering constraints for features such as Updates\n\nThis Command points at the message from which the Event is created.\nTherefore, just from the Command, you can't predict the resulting Event type.\n","is_empty":false},{"file_name":"configuration.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/configuration.md","id":"references/configuration","title":"Temporal Cluster configuration reference","description":"Much of the behavior of a Temporal Cluster is configured using the `development.yaml` file.","label":"Cluster configuration","tags":["reference"],"ssdi":[],"markdown_content":"\nMuch of the behavior of a Temporal Cluster is configured using the `development.yaml` file and may contain the following top-level sections:\n\n- [`global`](#global)\n- [`persistence`](#persistence)\n- [`log`](#log)\n- [`clusterMetadata`](#clustermetadata)\n- [`services`](#services)\n- [`publicClient`](#publicclient)\n- [`archival`](#archival)\n- [`namespaceDefaults`](#namespacedefaults)\n- [`dcRedirectionPolicy`](#dcredirectionpolicy)\n- [`dynamicConfigClient`](#dynamicconfigclient)\n\nChanging any properties in the `development.yaml` file requires a process restart for changes to take effect.\nConfiguration parsing code is available [here](https://github.com/temporalio/temporal/blob/master/common/config/config.go).\n\n## global\n\nThe `global` section contains process-wide configuration. See below for a minimal configuration (optional parameters are commented out.)\n\n```yaml\nglobal:\n  membership:\n    broadcastAddress: \"127.0.0.1\"\n  metrics:\n    prometheus:\n      framework: \"tally\"\n      listenAddress: \"127.0.0.1:8000\"\n```\n\n### membership\n\nThe `membership` section controls the following membership layer parameters.\n\n#### maxJoinDuration\n\nThe amount of time the service will attempt to join the gossip layer before failing.\n\nDefault is 10s.\n\n#### broadcastAddress\n\nUsed by gossip protocol to communicate with other hosts in the same Cluster for membership info.\nUse IP address that is reachable by other hosts in the same Cluster.\nIf there is only one host in the Cluster, you can use 127.0.0.1.\nCheck `net.ParseIP` for supported syntax, only IPv4 is supported.\n\n### metrics\n\nConfigures the Cluster's metric subsystem.\nSpecific provides are configured using provider names as the keys.\n\n- [`statsd`](#statsd)\n- `prometheus`\n- `m3`\n\n#### prefix\n\nThe prefix to be applied to all outgoing metrics.\n\n#### tags\n\nThe set of key-value pairs to be reported as part of every metric.\n\n#### excludeTags\n\nA map from tag name string to tag values string list.\nThis is useful to exclude some tags that might have unbounded cardinality.\nThe value string list can be used to whitelist values of that excluded tag to continue to be included.\nFor example, if you want to exclude `task_queue` because it has unbounded cardinality, but you still want to see a whitelisted value for `task_queue`.\n\n#### statsd\n\nThe `statsd` sections supports the following settings:\n\n- `hostPort`: The host:port of the statsd server.\n- `prefix`: Specific prefix in reporting to `statsd`.\n- `flushInterval`: Maximum interval for sending packets. (_Default_ 300ms).\n- `flushBytes`: Specifies the maximum UDP packet size you wish to send. (_Default_ 1432 bytes).\n\n#### prometheus\n\nThe `prometheus` sections supports the following settings:\n\n- `framework`: The framework to use, currently supports `opentelemetry` and `tally`, default is `tally`. We plan to switch default to `opentelemetry` once its API become stable.\n- `listenAddress`: Address for Prometheus to scrape metrics from.\n  The Temporal Server uses the Prometheus client API, and the `listenAddress` configuration is used to listen for metrics.\n- `handlerPath`: Metrics handler path for scraper; default is `/metrics`.\n\n#### m3\n\nThe `m3` sections supports the following settings:\n\n- `hostPort`: The host:port of the M3 server.\n- `service`: The service tag to that this client emits.\n- `queue`: M3 reporter queue size, default is 4k.\n- `packetSize`: M3 reporter max packet size, default is 32k.\n\n### pprof\n\n- `port`: If specified, this will initialize pprof upon process start on the listed port.\n\n### tls\n\nThe `tls` section controls the SSL/TLS settings for network communication and contains two subsections, `internode` and `frontend`.\nThe `internode` section governs internal service communication among roles where the `frontend` governs SDK client communication to the Frontend Service role.\n\nEach of these subsections contain a `server` section and a `client` section.\nThe `server` contains the following parameters:\n\n- `certFile`: The path to the file containing the PEM-encoded public key of the certificate to use.\n- `keyFile`: The path to the file containing the PEM-encoded private key of the certificate to use.\n- `requireClientAuth`: _boolean_ - Requires clients to authenticate with a certificate when connecting, otherwise known as mutual TLS.\n- `clientCaFiles`: A list of paths to files containing the PEM-encoded public key of the Certificate Authorities you wish to trust for client authentication. This value is ignored if `requireClientAuth` is not enabled.\n\n:::tip\n\nSee the [server samples repo](https://github.com/temporalio/samples-server/tree/master/tls) for sample TLS configurations.\n\n:::\n\nBelow is an example enabling Server TLS (https) between SDKs and the Frontend APIs:\n\n```yaml\nglobal:\n  tls:\n    frontend:\n      server:\n        certFile: /path/to/cert/file\n        keyFile: /path/to/key/file\n      client:\n        serverName: dnsSanInFrontendCertificate\n```\n\nNote, the `client` section generally needs to be provided to specify an expected DNS SubjectName contained in the presented server certificate via the `serverName` field; this is needed as Temporal uses IP to IP communication.\nYou can avoid specifying this if your server certificates contain the appropriate IP Subject Alternative Names.\n\nAdditionally, the `rootCaFiles` field needs to be provided when the client's host does not trust the Root CA used by the server.\nThe example below extends the above example to manually specify the Root CA used by the Frontend Services:\n\n```yaml\nglobal:\n  tls:\n    frontend:\n      server:\n        certFile: /path/to/cert/file\n        keyFile: /path/to/key/file\n      client:\n        serverName: dnsSanInFrontendCertificate\n        rootCaFiles:\n          - /path/to/frontend/server/CA/files\n```\n\nBelow is an additional example of a fully secured cluster using mutual TLS for both frontend and internode communication with manually specified CAs:\n\n```yaml\nglobal:\n  tls:\n    internode:\n      server:\n        certFile: /path/to/internode/cert/file\n        keyFile: /path/to/internode/key/file\n        requireClientAuth: true\n        clientCaFiles:\n          - /path/to/internode/serverCa\n      client:\n        serverName: dnsSanInInternodeCertificate\n        rootCaFiles:\n          - /path/to/internode/serverCa\n    frontend:\n      server:\n        certFile: /path/to/frontend/cert/file\n        keyFile: /path/to/frontend/key/file\n        requireClientAuth: true\n        clientCaFiles:\n          - /path/to/internode/serverCa\n          - /path/to/sdkClientPool1/ca\n          - /path/to/sdkClientPool2/ca\n      client:\n        serverName: dnsSanInFrontendCertificate\n        rootCaFiles:\n          - /path/to/frontend/serverCa\n```\n\n**Note:** In the case that client authentication is enabled, the `internode.server` certificate is used as the client certificate among services. This adds the following requirements:\n\n- The `internode.server` certificate must be specified on all roles, even for a frontend-only configuration.\n- Internode server certificates must be minted with either **no** Extended Key Usages or **both** ServerAuth and ClientAuth EKUs.\n- If your Certificate Authorities are untrusted, such as in the previous example, the internode server Ca will need to be specified in the following places:\n\n  - `internode.server.clientCaFiles`\n  - `internode.client.rootCaFiles`\n  - `frontend.server.clientCaFiles`\n\n## persistence\n\nThe `persistence` section holds configuration for the data store/persistence layer.\nThe following example shows a minimal specification for a password-secured Cluster using Cassandra.\n\n```yaml\npersistence:\n  defaultStore: default\n  visibilityStore: cass-visibility # The primary Visibility store.\n  secondaryVisibilityStore: es-visibility # A secondary Visibility store added to enable Dual Visibility.\n  numHistoryShards: 512\n  datastores:\n    default:\n      cassandra:\n        hosts: \"127.0.0.1\"\n        keyspace: \"temporal\"\n        user: \"username\"\n        password: \"password\"\n    cass-visibility:\n      cassandra:\n        hosts: \"127.0.0.1\"\n        keyspace: \"temporal_visibility\"\n    es-visibility:\n      elasticsearch:\n        version: \"v7\"\n        logLevel: \"error\"\n        url:\n          scheme: \"http\"\n          host: \"127.0.0.1:9200\"\n        indices:\n          visibility: temporal_visibility_v1_dev\n        closeIdleConnectionsInterval: 15s\n```\n\nThe following top level configuration items are required:\n\n### numHistoryShards\n\n_Required_ - The number of history shards to create when initializing the Cluster.\n\n**Warning**: This value is immutable and will be ignored after the first run.\nPlease ensure you set this value appropriately high enough to scale with the worst case peak load for this Cluster.\n\n### defaultStore\n\n_Required_ - The name of the data store definition that should be used by the Temporal server.\n\n### visibilityStore\n\n_Required_ - The name of the primary data store definition that should be used to set up [Visibility](/concepts/what-is-visibility) on the Temporal Cluster.\n\n### secondaryVisibilityStore\n\n_Optional_ - The name of the secondary data store definition that should be used to set up [Dual Visibility](/concepts/what-is-dual-visibility) on the Temporal Cluster.\n\n### datastores\n\n_Required_ - contains named data store definitions to be referenced.\n\nEach definition is defined with a heading declaring a name (ie: `default:` and `visibility:` above), which contains a data store definition.\n\nData store definitions must be either `cassandra` or `sql`.\n\n#### cassandra\n\nA `cassandra` data store definition can contain the following values:\n\n- `hosts`: _Required_ - \",\" separated Cassandra endpoints, e.g. \"192.168.1.2,192.168.1.3,192.168.1.4\".\n- `port`: Default: 9042 - Cassandra port used for connection by `gocql` client.\n- `user`: Cassandra username used for authentication by `gocql` client.\n- `password`: Cassandra password used for authentication by `gocql` client.\n- `keyspace`: _Required_ - the Cassandra keyspace.\n- `datacenter`: The data center filter arg for Cassandra.\n- `maxConns`: The max number of connections to this data store for a single TLS configuration.\n- `tls`: See TLS below.\n\n#### sql\n\nA `sql` data store definition can contain the following values:\n\n- `user`: Username used for authentication.\n- `password`: Password used for authentication.\n- `pluginName`: _Required_ - SQL database type.\n  - _Valid values_: `mysql` or `postgres`.\n- `databaseName` - _required_ - the name of SQL database to connect to.\n- `connectAddr` - _required_ - the remote address of the database, e.g. \"192.168.1.2\".\n- `connectProtocol` - _required_ - the protocol that goes with the `connectAddr`\n  - _Valid values_: `tcp` or `unix`\n- `connectAttributes` - a map of key-value attributes to be sent as part of connect `data_source_name` url.\n- `maxConns` - the max number of connections to this data store.\n- `maxIdleConns` - the max number of idle connections to this data store\n- `maxConnLifetime` - is the maximum time a connection can be alive.\n- `tls` - See below.\n\n#### tls\n\nThe `tls` and `mtls` sections can contain the following values:\n\n- `enabled` - _boolean_.\n- `serverName` - name of the server hosting the data store.\n- `certFile` - path to the cert file.\n- `keyFile` - path to the key file.\n- `caFile` - path to the ca file.\n- `enableHostVerification` - _boolean_ - `true` to verify the hostname and server cert (like a wildcard for Cassandra cluster). This option is basically the inverse of `InSecureSkipVerify`. See `InSecureSkipVerify` in http://golang.org/pkg/crypto/tls/ for more info.\n\nNote: `certFile` and `keyFile` are optional depending on server config, but both fields must be omitted to avoid using a client certificate.\n\n## log\n\nThe `log` section is optional and contains the following possible values:\n\n- `stdout` - _boolean_ - `true` if the output needs to go to standard out.\n- `level` - sets the logging level.\n  - _Valid values_ - debug, info, warn, error or fatal, default to info.\n- `outputFile` - path to output log file.\n\n## clusterMetadata\n\n`clusterMetadata` contains the local cluster information. The information is used in [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication).\n\nAn example `clusterMetadata` section:\n\n```yaml\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 10\n  masterClusterName: \"active\"\n  currentClusterName: \"active\"\n  clusterInformation:\n    active:\n      enabled: true\n      initialFailoverVersion: 0\n      rpcAddress: \"127.0.0.1:7233\"\n  #replicationConsumer:\n  #type: kafka\n```\n\n- `currentClusterName` - _required_ - the name of the current cluster. **Warning**: This value is immutable and will be ignored after the first run.\n- `enableGlobalNamespace` - _Default:_ `false`.\n- `replicationConsumer` - determines which method to use to consume replication tasks. The type may be either `kafka` or `rpc`.\n- `failoverVersionIncrement` - the increment of each cluster version when failover happens.\n- `masterClusterName` - the master cluster name, only the master cluster can register/update namespace. All clusters can do namespace failover.\n- `clusterInformation` - contains the local cluster name to `ClusterInformation` definition. The local cluster name should be consistent with `currentClusterName`. `ClusterInformation` sections consist of:\n  - `enabled` - _boolean_ - whether a remote cluster is enabled for replication.\n  - `initialFailoverVersion`\n  - `rpcAddress` - indicate the remote service address (host:port). Host can be DNS name. Use `dns:///` prefix to enable round-robin between IP address for DNS name.\n\n## services\n\nThe `services` section contains configuration keyed by service role type.\nThere are four supported service roles:\n\n- `frontend`\n- `matching`\n- `worker`\n- `history`\n\nBelow is a minimal example of a `frontend` service definition under `services`:\n\n```yaml\nservices:\n  frontend:\n    rpc:\n      grpcPort: 8233\n      membershipPort: 8933\n      bindOnIP: \"0.0.0.0\"\n```\n\nThere are two sections defined under each service heading:\n\n### rpc\n\n_Required_\n\n`rpc` contains settings related to the way a service interacts with other services. The following values are supported:\n\n- `grpcPort`: Port on which gRPC will listen.\n- `membershipPort`: Port used to communicate with other hosts in the same Cluster for membership info.\n  Each service should use different port.\n  If there are multiple Temporal Clusters in your environment (Kubernetes for example), and they have network access to each other, each Cluster should use a different membership port.\n- `bindOnLocalHost`: Determines whether uses `127.0.0.1` as the listener address.\n- `bindOnIP`: Used to bind service on specific IP, or `0.0.0.0`.\n  Check `net.ParseIP` for supported syntax, only IPv4 is supported, mutually exclusive with `BindOnLocalHost` option.\n\n**Note**: Port values are currently expected to be consistent among role types across all hosts.\n\n## publicClient\n\nThe `publicClient` a required section describing the configuration needed to for worker to connect to Temporal server for background server maintenance.\n\n- `hostPort` IPv4 host port or DNS name to reach Temporal frontend, [reference](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n\nExample:\n\n```yaml\npublicClient:\n  hostPort: \"localhost:8933\"\n```\n\nUse `dns:///` prefix to enable round-robin between IP address for DNS name.\n\n## archival\n\n_Optional_\n\nArchival is an optional configuration needed to set up the [Archival store](/concepts/what-is-archival).\nIt can be enabled on `history` and `visibility` data.\n\nThe following list describes supported values for each configuration on the `history` and `visibility` data.\n\n- `state`: State for Archival setting. Supported values are `enabled`, `disabled`. This value must be `enabled` to use Archival with any Namespace in your Cluster.\n  - `enabled`: Enables Archival in your Cluster setup. When set to `enabled`, `URI` and `namespaceDefaults` values must be provided.\n  - `disabled`: Disables Archival in your Cluster setup. When set to `disabled`, the `enableRead` value must be set to `false`, and under `namespaceDefaults`, `state` must be set to `disabled`, with no values set for `provider` and `URI` fields.\n- `enableRead`: Supported values are `true` or `false`. Set to `true` to allow read operations from the archived Event History data.\n- `provider`: Location where data should be archived. Subprovider configs are `filestore`, `gstorage`, `s3`, or `your_custom_provider`. Default configuration specifies `filestore`.\n\nExample:\n\n- To enable Archival in your Cluster configuration:\n\n  ```yaml\n  # Cluster-level Archival config enabled\n  archival:\n    # Event History configuration\n    history:\n      # Archival is enabled for the History Service data.\n      state: \"enabled\"\n      enableRead: true\n      # Namespaces can use either the local filestore provider or the Google Cloud provider.\n      provider:\n        filestore:\n          fileMode: \"0666\"\n          dirMode: \"0766\"\n        gstorage:\n          credentialsPath: \"/tmp/gcloud/keyfile.json\"\n    # Configuration for archiving Visibility data.\n    visibility:\n      # Archival is enabled for Visibility data.\n      state: \"enabled\"\n      enableRead: true\n      provider:\n        filestore:\n          fileMode: \"0666\"\n          dirMode: \"0766\"\n  ```\n\n- To disable Archival in your Cluster configuration:\n\n  ```yaml\n  # Cluster-level Archival config disabled\n  archival:\n    history:\n      state: \"disabled\"\n      enableRead: false\n    visibility:\n      state: \"disabled\"\n      enableRead: false\n\n  namespaceDefaults:\n    archival:\n      history:\n        state: \"disabled\"\n      visibility:\n        state: \"disabled\"\n  ```\n\nFor more details on Archival setup, see [Set up Archival](/cluster-deployment-guide#set-up-archival).\n\n## namespaceDefaults\n\n_Optional_\n\nSets default Archival configuration for each Namespace using `namespaceDefaults` for `history` and `visibility` data.\n\n- `state`: Default state of the Archival for the Namespace. Supported values are `enabled` or `disabled`.\n- `URI`: Default URI for the Namespace.\n\nFor more details on setting Namespace defaults on Archival, see [Namespace creation in Archival setup](/cluster-deployment-guide#namespace-creation)\n\nExample:\n\n```yaml\n# Default values for a Namespace if none are provided at creation.\nnamespaceDefaults:\n  # Archival defaults.\n  archival:\n    # Event History defaults.\n    history:\n      state: \"enabled\"\n      # New Namespaces will default to the local provider.\n      URI: \"file:///tmp/temporal_archival/development\"\n    visibility:\n      state: \"disabled\"\n      URI: \"file:///tmp/temporal_vis_archival/development\"\n```\n\n## dcRedirectionPolicy\n\n_Optional_\n\nContains the Frontend datacenter API redirection policy that you can use for cross-DC replication.\n\nSupported values:\n\n- `policy`: Supported values are `noop`, `selected-apis-forwarding`, and `all-apis-forwarding`.\n  - `noop`: Not setting a value or setting `noop` means no redirection. This is the default value.\n  - `selected-apis-forwarding`: Sets up forwarding for the following APIs to the active Cluster based on the Namespace.\n    - `StartWorkflowExecution`\n    - `SignalWithStartWorkflowExecution`\n    - `SignalWorkflowExecution`\n    - `RequestCancelWorkflowExecution`\n    - `TerminateWorkflowExecution`\n    - `QueryWorkflow`\n  - `all-apis-forwarding`: Sets up forwarding for all APIs on the Namespace in the active Cluster.\n\nExample:\n\n```yaml\n#...\ndcRedirectionPolicy:\n  policy: \"selected-apis-forwarding\"\n#...\n```\n\n## dynamicConfigClient\n\n_Optional_\n\nConfiguration for setting up file-based [dynamic configuration](/concepts/what-is-cluster-configuration#dynamicconfiguration) client for the Cluster.\n\nThis setting is required if specifying dynamic configuration. Supported configuration values are as follows:\n\n- `filepath`: Specifies the path where the dynamic configuration YAML file is stored. The path should be relative to the root directory.\n- `pollInterval`: Interval between the file-based client polls to check for dynamic configuration updates. The minimum period you can set is 5 seconds.\n\nExample:\n\n```yaml\ndynamicConfigClient:\n  filepath: \"config/dynamicconfig/development-cass.yaml\"\n  pollInterval: \"10s\"\n```\n","is_empty":false},{"file_name":"dynamic-configuration.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/dynamic-configuration.md","id":"references/dynamic-configuration","title":"Dynamic configuration reference","description":"Dynamic configuration key values can be set to override the default values in a Cluster configuration.","label":"Dynamic configuration","tags":["reference"],"ssdi":[],"markdown_content":"\nTemporal Cluster provides [dynamic configuration](/concepts/what-is-cluster-configuration#dynamic-configuration) keys that you can update and apply to a running Cluster without restarting your services.\n\nThe dynamic configuration keys are set with default values when you create your Cluster configuration.\nYou can override these values as you test your Cluster setup for optimal performance according to your workload requirements.\n\nFor the complete list of dynamic configuration keys, see <https://github.com/temporalio/temporal/blob/master/common/dynamicconfig/constants.go>.\nEnsure that you check server release notes for any changes to these keys and values.\n\nFor the default values of dynamic configuration keys, check the following links:\n\n- [Frontend Service](https://github.com/temporalio/temporal/blob/5783e781504d8ffac59f9848b830868f3139b980/service/frontend/service.go#L176)\n- [History Service](https://github.com/temporalio/temporal/blob/5783e781504d8ffac59f9848b830868f3139b980/service/history/configs/config.go#L309)\n- [Matching Service](https://github.com/temporalio/temporal/blob/5783e781504d8ffac59f9848b830868f3139b980/service/matching/config.go#L125)\n- [Worker Service](https://github.com/temporalio/temporal/blob/5783e781504d8ffac59f9848b830868f3139b980/service/worker/service.go#L193)\n\nSetting dynamic configuration is optional.\nChange these values only if you need to override the default values to achieve better performance on your Temporal Cluster.\nAlso, ensure that you test your changes before setting these in production.\n\n## Format\n\nTo override the default dynamic configuration values, specify your custom values and constraints for the dynamic configuration keys that you want to change in a YAML configuration file.\nUse the following format when creating your dynamic configuration file.\n\n```yaml\ntestGetBoolPropertyKey:\n  - value: false\n  - value: true\n    constraints:\n      namespace: \"your-namespace\"\n  - value: false\n    constraints:\n      namespace: \"your-other-namespace\"\ntestGetDurationPropertyKey:\n  - value: \"1m\"\n    constraints:\n      namespace: \"your-namespace\"\n      taskQueueName: \"longIdleTimeTaskqueue\"\ntestGetFloat64PropertyKey:\n  - value: 12.0\n    constraints:\n      namespace: \"your-namespace\"\ntestGetMapPropertyKey:\n  - value:\n      key1: 1\n      key2: \"value 2\"\n      key3:\n        - false\n        - key4: true\n          key5: 2.0\n```\n\n### Constraints\n\nYou can define constraints on some dynamic configuration keys to set specific values that apply on a Namespace or Task Queue level.\nNot defining constraints on a dynamic configuration key sets the values across the Cluster.\n\n- To set global values for the configuration key with no constraints, use the following:\n\n  ```yaml\n  frontend.globalNamespaceRPS: # Total per-Namespace RPC rate limit applied across the Cluster.\n    - value: 5000\n  ```\n\n- For keys that can be customized at Namespace level, you can specify multiple values for different Namespaces in addition to one default value that applies globally to all Namespaces.\n  To set values at a Namespace level, use `namespace` (String) as shown in the following example.\n\n  ```yaml\n  frontend.persistenceNamespaceMaxQPS: # Rate limit on the number of queries the Frontend sends to the Persistence store.\n    - constraints: {} # Sets default value that applies to all Namespaces\n      value: 2000 # The default value for this key is 0.\n    - constraints: {namespace: \"namespace1\"} # Sets limit on number of queries that can be sent from \"namespace1\" Namespace to the Persistence store.\n      value: 4000\n    - constraints: {namespace: \"namespace2\"}\n      value: 1000\n  ```\n\n- For keys that can be customized at a Task Queue level, you can specify Task Queue name and Task type in addition to Namespace.\n  To set values at a Task Queue level, use `taskQueueName` (String) with `taskType` (optional; supported values: `Workflow` and `Activity`).\n\n  For example if you have Workflow Executions creating a large number of Workflow and Activity tasks per second, you can add more partitions to your Task Queues (default is 4) to handle the high throughput of tasks.\n  To do this, add the following to your dynamic configuration file.\n  Note that if changing the number of partitions, you must set the same count for both read and write operations on Task Queues.\n\n  ```yaml\n  matching.numTaskqueueReadPartitions: # Number of Task Queue partitions for read operations.\n  - constraints: {namespace: \"namespace1\", taskQueueName: \"tq\"}  # Applies to the \"tq\" Task Queue for both Workflows and Activities.\n    value: 8 # The default value for this key is 4. Task Queues that need to support high traffic require higher number of partitions. Set these values in accordance to your poller count. \n  - constraints: {namespace: \"namespace1\", taskQueueName: \"other-tq\", taskType: \"Activity\"} # Applies to the \"other_tq\" Task Queue for Activities specifically.\n    value: 20 \n  - constraints: {namespace: \"namespace2\"}  # Applies to all task queues in \"namespace2\".\n    value: 10\n  - constraints: {}  # Applies to all other task queues in \"namespace1\" and all other Namespaces.\n    value: 16\n  matching.numTaskqueueWritePartitions:  # Number of Task Queue partitions for write operations.\n  - constraints: {namespace: \"namespace1\", taskQueueName: \"tq\"}  # Applies to the \"tq\" Task Queue for both Workflows and Activities.\n    value: 8 # The default value for this key is 4. Task Queues that need to support high traffic require higher number of partitions. Set these values in accordance to your poller count. \n  - constraints: {namespace: \"namespace1\", taskQueueName: \"other-tq\", taskType: \"Activity\"} # Applies to the \"other_tq\" Task Queue for Activities specifically.\n    value: 20 \n  - constraints: {namespace: \"namespace2\"}  # Applies to all task queues in \"namespace2\".\n    value: 10\n  - constraints: {}  # Applies to all other task queues in \"namespace1\" and all other Namespaces.\n    value: 16\n  ```\n\n<!-- Note that the values set with most constraints take priority over values that are set with fewer constraints, regardless of the order in which they are set in the dynamic configuration key. -->\n\nFor more examples on how dynamic configuration is set, see:\n\n- [docker-compose](https://github.com/temporalio/docker-compose/tree/main/dynamicconfig)\n- [samples-server](https://github.com/temporalio/samples-server/blob/main/tls/config/dynamicconfig/development.yaml)\n\n## Commonly used dynamic configuration keys\n\nThe following table lists commonly used dynamic configuration keys that can be used for rate limiting requests to the Temporal Cluster.\n\nSetting dynamic configuration keys is optional.\nIf you choose to update these values for your Temporal Cluster, ensure that you are provisioning enough resources to handle the load.\n\nAll values listed here are for Temporal server v1.21.\nCheck [server release notes](https://github.com/temporalio/temporal/releases) to verify any potential breaking changes when upgrading your versions.\n\n### Service-level RPS limits\n\nThe Requests Per Second (RPS) dynamic configuration keys set the rate at which requests can be made to each service in your Cluster.\n\nWhen scaling your services, tune the RPS to test your workload and set acceptable provisioning benchmarks.\nExceeding these limits results in `ResourceExhaustedError`.\n\n| Dynamic configuration key              | Type | Description                                                                                                                                                                                                                                          | Default value |\n| -------------------------------------- | ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- |\n| Frontend                               |      |                                                                                                                                                                                                                                                      |               |\n| `frontend.rps`                         | Int  | Rate limit (requests/second) for requests accepted by each Frontend Service host.                                                                                                                                                                    | 2400          |\n| `frontend.namespaceRPS`                | Int  | Rate limit (requests/second) for requests accepted by each Namespace on the Frontend Service.                                                                                                                                                        | 2400          |\n| `frontend.namespaceCount`              | Int  | Limit on the number of concurrent Task Queue polls per Namespace per Frontend Service host.                                                                                                                                                          | 1200          |\n| `frontend.globalNamespaceRPS`          | Int  | Rate limit (requests/second) for requests accepted per Namespace, applied across Cluster. The limit is evenly distributed among available Frontend Service instances. If this is set, it overrides the per-instance limit (`frontend.namespaceRPS`). | 0             |\n| `internal-frontend.globalNamespaceRPS` | Int  | Rate limit (requests/second) for requests accepted on each Internal-Frontend Service host applied across the Cluster.                                                                                                                                | 0             |\n| History                                |      |                                                                                                                                                                                                                                                      |               |\n| `history.rps`                          | Int  | Rate limit (requests/second) for requests accepted by each History Service host.                                                                                                                                                                     | 3000          |\n| Matching                               |      |                                                                                                                                                                                                                                                      |               |\n| `matching.rps`                         | Int  | Rate limit (requests/second) for requests accepted by each Matching Service host.                                                                                                                                                                    | 1200          |\n| `matching.numTaskqueueReadPartitions`  | Int  | Number of read partitions for a Task Queue. Must be set with `matching.numTaskqueueWritePartitions`.                                                                                                                                                 | 4             |\n| `matching.numTaskqueueWritePartitions` | Int  | Number of write partitions for a Task Queue.                                                                                                                                                                                                         | 4             |\n\n### QPS limits for Persistence store\n\nThe Queries Per Second (QPS) dynamic configuration keys set the maximum number of queries a service can make per second to the Persistence store.\n\nPersistence store rate limits are evaluated synchronously.\nAdjust these keys according to your database capacity and workload.\nIf the number of queries made to the Persistence store exceeds the dynamic configuration value, you will see latencies and timeouts on your tasks.\n\n| Dynamic configuration key                 | Type | Description                                                                                                                                                                                                                                             | Default value |\n| ----------------------------------------- | ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- |\n| Frontend                                  |      |                                                                                                                                                                                                                                                         |               |\n| `frontend.persistenceMaxQPS`              | Int  | Maximum number queries per second that the Frontend Service host can send to the Persistence store.                                                                                                                                                     | 2000          |\n| `frontend.persistenceNamespaceMaxQPS`     | Int  | Maximum number of queries per second that each Namespace on the Frontend Service host can send to the Persistence store. <br /> If the value set for this config is less than or equal to 0, the value set for `frontend.persistenceMaxQPS` will apply. | 0             |\n| History                                   |      |                                                                                                                                                                                                                                                         |               |\n| `history.persistenceMaxQPS`               | Int  | Maximum number of queries per second that the History host can send to the Persistence store.                                                                                                                                                           | 9000          |\n| `history.persistenceNamespaceMaxQPS`      | Int  | Maximum number of queries per second for each Namespace that the History host can send to the Persistence store. <br /> If the value set for this config is less than or equal to 0, then the value set for `history.persistenceMaxQPS` will apply.     | 0             |\n| Matching                                  |      |                                                                                                                                                                                                                                                         |               |\n| `matching.persistenceMaxQPS`              | Int  | Maximum number of queries per second that the Matching Service host can send to the Persistence store.                                                                                                                                                  | 9000          |\n| `matching.persistenceNamespaceMaxQPS`     | Int  | Maximum number of queries per second that the Matching host can send to the Persistence store for each Namespace.<br /> If the value set for this config is less than or equal to 0, the value set for `matching.persistenceMaxQPS` will apply.         | 0             |\n| Worker                                    |      |                                                                                                                                                                                                                                                         |               |\n| `worker.persistenceMaxQPS`                | Int  | Maximum number of queries per second that the Worker Service host can send to the Persistence store.                                                                                                                                                    | 100           |\n| `worker.persistenceNamespaceMaxQPS`       | Int  | Maximum number of queries per second that the Worker host can send to the Persistence store for each Namespace. <br /> If the value set for this config is less than or equal to 0, the value set for `worker.persistenceMaxQPS` will apply.            | 0             |\n| Visibility                                |      |                                                                                                                                                                                                                                                         |               |\n| `system.visibilityPersistenceMaxReadQPS`  | Int  | Maximum number queries per second that Visibility database can receive for read operations.                                                                                                                                                             | 9000          |\n| `system.visibilityPersistenceMaxWriteQPS` | Int  | Maximum number of queries per second that Visibility database can receive for write operations.                                                                                                                                                         | 9000          |\n\n### Activity and Workflow default policy setting\n\nYou can define default values for Activity and Workflow [Retry Policies](/concepts/what-is-a-retry-policy) at the Cluster level with the following dynamic configuration keys.\n\n| Dynamic configuration key            | Type                          | Description                                                                                                       | Default value                                                                      |\n| ------------------------------------ | ----------------------------- | ----------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |\n| `history.defaultActivityRetryPolicy` | Map (key-value pair elements) | Server configuration for an Activity Retry Policy when it is not explicitly set for the Activity in your code.    | [Default values for retry Policy](/retry-policies#default-values-for-retry-policy) |\n| `history.defaultWorkflowRetryPolicy` | Map (key-value pair elements) | Retry Policy for unset fields where the user has set an explicit `RetryPolicy`, but not specified all the fields. | [Default values for retry Policy](/retry-policies#default-values-for-retry-policy) |\n\n### Size limit settings\n\nThe Persistence store in the Cluster has default size limits set for optimal performance. The dynamic configuration keys relating to some of these are listed below.\n\nThe default values on these keys are based on extensive testing.\nYou can change these values, but ensure that you are provisioning enough database resources to handle the changed values.\n\nFor details on platform limits, see the [Temporal Platform limits sheet](/kb/temporal-platform-limits-sheet).\n\n| Dynamic configuration key               | Type | Description                                                                                                                                                                                                                                     | Default value            |\n| --------------------------------------- | ---- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ |\n| `limit.maxIDLength`                     | Int  | Length limit for various Ids, including: `Namespace`, `TaskQueue`, `WorkflowID`, `ActivityID`, `TimerID`, `WorkflowType`, `ActivityType`, `SignalName`, `MarkerName`, `ErrorReason`/`FailureReason`/`CancelCause`, `Identity`, and `RequestID`. | 1000                     |\n| `limit.blobSize.warn`                   | Int  | Limit, in MBs, for BLOBs size in an Event when a warning is thrown in the server logs.                                                                                                                                                          | 512 KB (512 × 1024)      |\n| `limit.blobSize.error`                  | Int  | Limit, in MBs, for BLOBs size in an Event when an error occurs in the transaction.                                                                                                                                                              | 2 MB (2 × 1024 × 1024)   |\n| `limit.historySize.warn`                | Int  | Limit, in MBs, at which a warning is thrown for the Workflow Execution Event History size.                                                                                                                                                      | 10 MB (10 × 1024 × 1024) |\n| `limit.historySize.error`               | Int  | Limit, in MBs, at which an error occurs in the Workflow Execution for exceeding allowed size.                                                                                                                                                   | 50 MB (50 × 1024 × 1024) |\n| `limit.historyCount.warn`               | Int  | Limit, in count, at which a warning is thrown for the Workflow Execution Event History size.                                                                                                                                                    | 10,240 Events            |\n| `limit.historyCount.error`              | Int  | Limit, in count, at which an error occurs in the Workflow Execution for exceeding allowed number of Events.                                                                                                                                     | 51,200 events            |\n| `limit.numPendingActivities.error`      | Int  | Maximum number of pending Activities that a Workflow Execution can have before the `ScheduleActivityTask` fails with an error.                                                                                                                  | 2000                     |\n| `limit.numPendingSignals.error`         | Int  | Maximum number of pending Signals that a Workflow Execution can have before the `SignalExternalWorkflowExecution` commands from this Workflow fail with an error.                                                                               | 2000                     |\n| `history.maximumSignalsPerExecution`    | Int  | Maximum number of Signals that a Workflow Execution can receive before it throws an `Invalid Argument` error.                                                                                                                                   | 10000                    |\n| `limit.numPendingCancelRequests.error`  | Int  | Maximum number of pending requests to cancel other Workflows that a Workflow Execution can have before the `RequestCancelExternalWorkflowExecution` commands fail with an error.                                                                | 2000                     |\n| `limit.numPendingChildExecutions.error` | Int  | Maximum number of pending Child Workflows that a Workflow Execution can have before the `StartChildWorkflowExecution` commands fail with an error.                                                                                              | 2000                     |\n| `frontend.visibilityMaxPageSize`        | Int  | Maximum number of Workflow Executions shown from the ListWorkflowExecutions API in one page.                                                                                                                                                    | 1000                     |\n\n### Secondary Visibility settings\n\nSecondary Visibility configuration keys enable Dual Visibility on your Temporal Cluster.\nThis can be useful when migrating a Visibility database or creating a backup Visibility store.\n\n| Dynamic configuration key                  | Type    | Description                                                                                                                                                                                                                                                                                                                                                                                                          | Default value |\n| ------------------------------------------ | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- |\n| `system.enableReadFromSecondaryVisibility` | Boolean | Enables reading from the [secondary Visibility store](/visibility#dual-visibility), and can be set per Namespace. Allowed values are `true` or `false`.                                                                                                                                                                                                                                                              | `false`       |\n| `system.secondaryVisibilityWritingMode`    |         | Enables writing Visibility data to the secondary Visibility store and can be set per Namespace. Setting this value to `on` disables write operations to the primary Visibility store. Allowed values:<br /> `off`: Enables writing to primary Visibility store only. <br /> `on`: Enables writing to secondary Visibility store only.<br /> `dual`: Enables writing to both primary and secondary Visibility stores. | `off`         |\n","is_empty":false},{"file_name":"events.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/events.md","id":"references/events","title":"Events reference","description":"Events are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution.","label":"Events","tags":["reference"],"ssdi":[],"markdown_content":"\n[Events](/concepts/what-is-an-event) are created by the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) in response to external occurrences and [Commands](/concepts/what-is-a-command) generated by a [Workflow Execution](/workflows#workflow-execution).\nAll possible Events that could appear in a Workflow Execution [Event History](/concepts/what-is-an-event-history) are listed below.\n\n### WorkflowExecutionStarted\n\nThis is always the first [Event](/concepts/what-is-an-event) in a Workflow Execution Event History.\nIt indicates that the Cluster received a request to spawn the Workflow Execution.\n\n| Field                              | Description                                                                                                                                                                                 |\n| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| workflow_type                      | The [Name](/concepts/what-is-a-workflow-type) of [Workflow](/concepts/what-is-a-workflow) that was initiated.                                                                               |\n| parent_workflow_namespace          | The [Namespace](/concepts/what-is-a-namespace) of the Parent [Workflow Execution](/workflows#workflow-execution), if applicable.                                                            |\n| parent_workflow_execution          | Identifies the parent Workflow and the execution run.                                                                                                                                       |\n| parent_initiated_event_id          | Id of the [StartWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to.                                                                         |\n| task_queue                         | The [Task Queue](/concepts/what-is-a-task-queue) that this [Workflow Task](/concepts/what-is-a-workflow-task) was enqueued in.                                                              |\n| input                              | Information that is deserialized by the SDK to provide arguments to the Workflow.                                                                                                           |\n| workflow_execution_timeout         | The total timeout period for a [Workflow Execution](/workflows#workflow-execution), including retries and continue-as-new.                                                                  |\n| workflow_run_timeout               | Timeout of a single Workflow run.                                                                                                                                                           |\n| workflow_task_timeout              | Timeout of a single Workflow Task.                                                                                                                                                          |\n| continued_execution_run_id         | [Run Id](/concepts/what-is-a-run-id) of the previous Workflow which continued-as-new, retried or was executed by Cron into this Workflow.                                                   |\n| initiator                          | Allows the Workflow to continue as a new Workflow Execution.                                                                                                                                |\n| continued_failure                  | Serialized result of a failure.                                                                                                                                                             |\n| last_completion_result             | Information from the previously completed [Task](/concepts/what-is-a-task), if applicable.                                                                                                  |\n| original_execution_run_id          | The [Run Id](/concepts/what-is-a-run-id) of the original Workflow started.                                                                                                                  |\n| identity                           | The Id of the [Client](/concepts/what-is-a-temporal-cluster#temporal-client-connections) or parent Workflow [Worker](/concepts/what-is-a-worker) that requested the start of this Workflow. |\n| first_execution_run_id             | The first [Run Id](/concepts/what-is-a-run-id), along the chain of [Continue-As-New](/concepts/what-is-continue-as-new) Runs and Reset.                                                     |\n| retry_policy                       | The amount of retries as determined by the service's dynamic configuration. Retries will happen until 'schedule_to_close_timeout' is reached.                                               |\n| attempt                            | The number of attempts that have been made to complete this Task.                                                                                                                           |\n| workflow_execution_expiration_time | The absolute time at which the Workflow Execution will [time out](/concepts/what-is-a-workflow-execution-timeout).                                                                          |\n| cron_schedule                      | Displays the Workflow's [Cron Schedule](/concepts/what-is-a-temporal-cron-job), if applicable.                                                                                              |\n| first_workflow_task_backoff        | Contains the amount of time between when this iteration of the Workflow was scheduled, and when it should run next. Applies to Cron Scheduling.                                             |\n| memo                               | Non-indexed information to show in the Workflow.                                                                                                                                            |\n| search_attributes                  | Provides data for setting up a Workflow's [Search Attributes](/concepts/what-is-a-search-attribute).                                                                                        |\n| prev_auto_reset_points             |                                                                                                                                                                                             |\n| header                             | Information passed by the sender of the [Signal](/concepts/what-is-a-signal) that is copied into the [Workflow Task](/concepts/what-is-a-workflow-task).                                    |\n\n### WorkflowExecutionCompleted\n\nThis indicates that the [Workflow Execution](/workflows#workflow-execution) has successfully completed. The [Event](/concepts/what-is-an-event) contains Workflow Execution results.\n\n| Field                            | Description                                                                                                                                             |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| result                           | Serialized result of completed [Workflow](/concepts/what-is-a-workflow).                                                                                |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                                                         |\n| new_execution_run_id             | The [Run Id](/concepts/what-is-a-run-id) of the new Workflow Execution started as a result of a [Cron Schedule](/concepts/what-is-a-temporal-cron-job). |\n\n### WorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) indicates that the [Workflow Execution](/workflows#workflow-execution) has unsuccessfully completed and contains the Workflow Execution error.\n\n| Field                            | Description                                                                                                                       |\n| -------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |\n| failure                          | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                                          |\n| retry_state                      | The reason provided for whether the [Task](/concepts/what-is-a-task) should or shouldn't be retried.                              |\n| workflow_task_completed_event_id | The [Run Id](/concepts/what-is-a-run-id) of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with. |\n| new_execution_run_id             | The [Run Id](/concepts/what-is-a-run-id) of the new Workflow started by Cron or [Retry](/concepts/what-is-a-retry-policy).        |\n\n### WorkflowExecutionTimedOut\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Execution](/workflows#workflow-execution) has timed out by the [Temporal Server](/concepts/what-is-the-temporal-server) due to the [Workflow](/concepts/what-is-a-workflow) having not been completed within [timeout](/concepts/what-is-a-workflow-execution-timeout) settings.\n\n| Field                | Description                                                                                                                |\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| retry_state          | The reason provided for whether the [Task](/concepts/what-is-a-task) should or shouldn't be retried.                       |\n| new_execution_run_id | The [Run Id](/concepts/what-is-a-run-id) of the new Workflow started by Cron or [Retry](/concepts/what-is-a-retry-policy). |\n\n### WorkflowExecutionCancelRequested\n\nThis [Event](/concepts/what-is-an-event) type indicates that a request has been made to cancel the [Workflow Execution](/workflows#workflow-execution).\n\n| Field                       | Description                                                                                                                                      |\n| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| cause                       | The user-provided reason for the cancelation request.                                                                                            |\n| external_initiated_event_id | The [Run Id](/concepts/what-is-a-run-id) of the Event in the [Workflow](/concepts/what-is-a-workflow) that requested cancelation, if applicable. |\n| external_workflow_execution | Identifies the external Workflow and the run of the its execution.                                                                               |\n| identity                    | Id of the [Worker](/concepts/what-is-a-worker) that requested cancelation.                                                                       |\n\n### WorkflowExecutionCanceled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the client has confirmed the cancelation request and the [Workflow Execution](/workflows#workflow-execution) has been canceled.\n\n| Field                            | Description                                                                                       |\n| -------------------------------- | ------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.   |\n| details                          | Additional information reported by the [Workflow](/concepts/what-is-a-workflow) upon cancelation. |\n\n### WorkflowExecutionSignaled\n\nThis [Event](/concepts/what-is-an-event) type indicates the [Workflow](/concepts/what-is-a-workflow) has received a [Signal](/concepts/what-is-a-signal) Event.\nThe Event type contains the Signal name, as well as a Signal payload.\n\n| Field       | Description                                                                                                                |\n| ----------- | -------------------------------------------------------------------------------------------------------------------------- |\n| signal_name | The name/type of Signal to be fired.                                                                                       |\n| input       | Information that is deserialized by the SDK to provide arguments to the Workflow function.                                 |\n| identity    | Identifies the [Worker](/concepts/what-is-a-worker) that signaled to the Workflow.                                         |\n| header      | Information passed by the sender of the Signal that is copied into the [Workflow Task](/concepts/what-is-a-workflow-task). |\n\n### WorkflowExecutionTerminated\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Execution](/workflows#workflow-execution) has been forcefully terminated and that likely the terminate Workflow API was called.\n\n| Field    | Description                                                          |\n| -------- | -------------------------------------------------------------------- |\n| reason   | Information provided by the user or client for Workflow termination. |\n| details  | Additional information reported by the Workflow upon termination.    |\n| identity | Identifies the Worker that requested termination.                    |\n\n### WorkflowExecutionContinuedAsNew\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Workflow has successfully completed, and a new Workflow has been started within the same transaction.\nThis Event type contains last [Workflow Execution](/workflows#workflow-execution) results as well as new Workflow Execution inputs.\n\n| Field                            | Description                                                                                                                    |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| new_execution_run_id             | The [Run Id](/concepts/what-is-a-run-id) of the new Workflow started by this Continue-As-New Event.                            |\n| workflow_type                    | The name/type of Workflow that was started by this Event.                                                                      |\n| task_queue                       | The [Task Queue](/concepts/what-is-a-task-queue) that this [Workflow Task](/concepts/what-is-a-workflow-task) was enqueued in. |\n| input                            | Information that is deserialized by the SDK to provide arguments to the Workflow.                                              |\n| workflow_run_timeout             | Timeout of a single Workflow run.                                                                                              |\n| workflow_task_timeout            | Timeout of a single Workflow Task.                                                                                             |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event command was reported with.                        |\n| backoff_start_interval           | The amount of time to delay the beginning of the [ContinuedAsNew](#workflowexecutioncontinuedasnew) Workflow.                  |\n| initiator                        | Allows the Workflow to continue as a new execution.                                                                            |\n| last_completion_result           | Information passed by the previously completed Task to the ongoing execution.                                                  |\n| header                           | Information passed by the sender of the Signal that is copied into the Workflow Task.                                          |\n| memo                             | Non-indexed information to show in the Workflow.                                                                               |\n| search_attributes                | Provides data for setting up a Workflow's [Search Attributes](/concepts/what-is-a-search-attribute).                           |\n\n### WorkflowTaskScheduled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) has been scheduled.\nThe SDK client should now be able to process any new history events.\n\n| Field                  | Description                                                                                           |\n| ---------------------- | ----------------------------------------------------------------------------------------------------- |\n| task_queue             | The [Task Queue](/concepts/what-is-a-task-queue) that this Workflow Task was enqueued in.             |\n| start_to_close_timeout | The time that the [Worker](/concepts/what-is-a-worker) takes to process this Task once it's received. |\n| attempt                | The number of attempts that have been made to complete this Task.                                     |\n\n### WorkflowTaskStarted\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) has started.\nThe SDK client has picked up the Workflow Task and is processing new history events.\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [WorkflowTaskScheduled](#workflowtaskscheduled) Event that this Workflow Task corresponds to. |\n| identity           | Identifies the [Worker](/concepts/what-is-a-worker) that started this Task.                                 |\n| request_id         | Identifies the Workflow Task request.                                                                       |\n\n### WorkflowTaskCompleted\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) completed.\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [WorkflowTaskScheduled](#workflowtaskscheduled) Event that this Workflow Task corresponds to. |\n| started_event_id   | The Id of the [WorkflowTaskStarted](#workflowtaskstarted) Event that this Task corresponds to.              |\n| identity           | Identity of the [Worker](/concepts/what-is-a-worker) that completed this Task.                              |\n| binary_checksum    | Binary Id of the Worker that completed this Task.                                                           |\n\nThe SDK client picked up the Workflow Task, processed new history events, and may or may not ask the [Temporal Server](/concepts/what-is-the-temporal-server) to do additional work.\nIt is possible for the following events to still occur:\n\n- [ActivityTaskScheduled](#activitytaskscheduled)\n- [TimerStarted](#timerstarted)\n- [UpsertWorkflowSearchAttributes](#upsertworkflowsearchattributes)\n- [MarkerRecorded](#markerrecorded)\n- [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated)\n- [RequestCancelExternalWorkflowExecutionInitiated](#requestcancelexternalworkflowexecutioninitiated)\n- [SignalExternalWorkflowExecutionInitiated](#signalexternalworkflowexecutioninitiated)\n- [WorkflowExecutionCompleted](#workflowexecutioncompleted)\n- [WorkflowExecutionFailed](#workflowexecutionfailed)\n- [WorkflowExecutionCanceled](#workflowexecutioncanceled)\n- [WorkflowExecutionContinuedAsNew](#workflowexecutioncontinuedasnew)\n\n### WorkflowTaskTimedOut\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) encountered a [timeout](/concepts/what-is-a-workflow-task-timeout).\nEither an SDK client with a local cache was not available at the time, or it took too long for the SDK client to process the Task.\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [WorkflowTaskScheduled](#workflowtaskscheduled) Event that this Workflow Task corresponds to. |\n| started_event_id   | The Id of the [WorkflowTaskStarted](#workflowtaskstarted) Event that this Task corresponds to.              |\n| timeout_type       | The type of timeout that has occurred.                                                                      |\n\n### WorkflowTaskFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) encountered a failure.\nUsually this means that the Workflow was non-deterministic.\nHowever, the Workflow reset functionality also uses this Event.\n\n| Field              | Description                                                                                                                                             |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [WorkflowTaskScheduled](#workflowtaskscheduled) Event that this Workflow Task corresponds to.                                             |\n| started_event_id   | The Id of the [WorkflowTaskStarted](#workflowtaskstarted) Event that this Workflow Task corresponds to.                                                 |\n| failure            | Details for the Workflow Task's failure.                                                                                                                |\n| identity           | The identity of the [Worker](/concepts/what-is-a-worker) that failed this Task. The Worker must be explicitly defined to return a value for this field. |\n| base_run_id        | The original [Run Id](/concepts/what-is-a-run-id) of the Workflow.                                                                                      |\n| new_run_id         | The Run Id of the reset Workflow.                                                                                                                       |\n| fork_event_version | Identifies the Event version that was forked off to the reset Workflow.                                                                                 |\n| binary_checksum    | The Binary Id of the Worker that failed this Task. The Worker must be explicitly defined to return a value for this field.                              |\n\n### ActivityTaskScheduled\n\nThis [Event](/concepts/what-is-an-event) type indicates that an [Activity Task](/concepts/what-is-an-activity-task) was scheduled.\nThe SDK client should pick up this Activity Task and execute.\nThis Event type contains Activity inputs, as well as Activity Timeout configurations.\n\n| Field                            | Description                                                                                                                                              |\n| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| activity_id                      | The identifier assigned to this Activity by a [Worker](/concepts/what-is-a-worker) or user.                                                              |\n| activity_type                    | The [type of Activity](/concepts/what-is-an-activity-type) that was scheduled.                                                                           |\n| namespace                        | Namespace of the Workflow that the [Activity](/concepts/what-is-an-activity) resides in.                                                                 |\n| task_queue                       | The [Task Queue](/concepts/what-is-a-task-queue) that this Activity Task was enqueued in.                                                                |\n| header                           | Information passed by the sender of the [Signal](/concepts/what-is-a-signal) that is copied into the [Workflow Task](/concepts/what-is-a-workflow-task). |\n| input                            | Information that is deserialized by the SDK to provide arguments to the [Workflow](/concepts/what-is-a-workflow) function.                               |\n| schedule_to_close_timeout        | The amount of time that a caller will wait for Activity completion. Limits the amount of time that retries will be attempted for this Activity.          |\n| schedule_to_start_timeout        | Limits the time that an Activity Task can stay in a Task Queue. This timeout cannot be retried.                                                          |\n| start_to_close_timeout           | Maximum amount of execution time that an Activity is allowed after being picked up by a Worker. This timeout is retryable.                               |\n| heartbeat_timeout                | Maximum amount of time allowed between successful Worker heartbeats.                                                                                     |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                                                          |\n| retry_policy                     | The amount of retries as determined by the service's dynamic configuration. Retries will happen until `schedule_to_close_timeout` is reached.            |\n\n### ActivityTaskStarted\n\nThis [Event](/concepts/what-is-an-event) type indicates that an [Activity Task Execution](/concepts/what-is-an-activity-task-execution) was started.\nThe SDK Worker picked up the Activity Task and started processing the [Activity](/concepts/what-is-an-activity) invocation.\nNote, however, that this Event is not written to History until the terminal Event (like [ActivityTaskCompleted](/references/events#activitytaskcompleted) or [ActivityTaskFailed](/references/events#activitytaskfailed)) occurs.\n\n| Field              | Description                                                                                                          |\n| ------------------ | -------------------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this Task corresponds to.                   |\n| identity           | Identifies the [Worker](/concepts/what-is-a-worker) that started the Task.                                           |\n| request_id         | Identifies the Activity Task request.                                                                                |\n| attempt            | The number of attempts that have been made to complete this Task.                                                    |\n| last_failure       | Details from the most recent failure Event. Only assigned values if the Task has previously failed and been retried. |\n\n### ActivityTaskCompleted\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Activity Task](/concepts/what-is-an-activity-task) has completed.\nThe SDK client has picked up and successfully completed the Activity Task.\nThis Event type contains [Activity Execution](/concepts/what-is-an-activity-execution) results.\n\n| Field              | Description                                                                                                    |\n| ------------------ | -------------------------------------------------------------------------------------------------------------- |\n| result             | Serialized result of a completed [Activity](/concepts/what-is-an-activity).                                    |\n| scheduled_event_id | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this completion Event corresponds to. |\n| started_event_id   | The Id of the [ActivityTaskStarted](#activitytaskstarted) Event that this Task corresponds to.                 |\n| identity           | Identity of the [Worker](/concepts/what-is-a-worker) that completed this Task.                                 |\n\n### ActivityTaskFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Activity Task](/concepts/what-is-an-activity-task) has failed.\nThe SDK client picked up the Activity Task but unsuccessfully completed it.\nThis Event type contains [Activity Execution](/concepts/what-is-an-activity-execution) errors.\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| failure            | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                    |\n| scheduled_event_id | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this failure Event corresponds to. |\n| started_event_id   | The Id of the [ActivityTaskStarted](#activitytaskstarted) Event that this failure corresponds to.           |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                    |\n\n### ActivityTaskTimedOut\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Activity has timed out according to the [Temporal Server](/concepts/what-is-the-temporal-server), due to one of these [Activity](/concepts/what-is-an-activity) timeouts: [Schedule-to-Close Timeout](/activities#schedule-to-close-timeout) and [Schedule-to-Start Timeout](/activities#schedule-to-start-timeout).\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| failure            | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                    |\n| scheduled_event_id | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this timeout Event corresponds to. |\n| started_event_id   | The Id of the [ActivityTaskStarted](#activitytaskstarted) Event that this timeout corresponds to.           |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                    |\n\n### ActivityTaskCancelRequested\n\nThis [Event](/concepts/what-is-an-event) type indicates that a request to [cancel](/activities#cancellation) the [Activity](/concepts/what-is-an-activity) has occurred.\n\n| Field                            | Description                                                                                                |\n| -------------------------------- | ---------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id               | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this cancel Event corresponds to. |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.            |\n\n### ActivityTaskCanceled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Activity](/concepts/what-is-an-activity) has been [canceled](/activities#cancellation).\n\n| Field                            | Description                                                                                                                |\n| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| details                          | Additional information reported by the Activity upon confirming cancelation.                                               |\n| latest_cancel_requested_event_id | Id of the most recent [ActivityTaskCancelRequested](#activitytaskcancelrequested) Event which refers to the same Activity. |\n| scheduled_event_id               | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this cancelation corresponds to.                  |\n| started_event_id                 | The Id of the [ActivityTaskStarted](#activitytaskstarted) Event that this cancelation corresponds to.                      |\n| identity                         | Identifies the [Worker](/concepts/what-is-a-worker) that requested cancelation.                                            |\n\n### TimerStarted\n\nThis [Event](/concepts/what-is-an-event) type indicates a timer has started.\n\n| Field                            | Description                                                                                     |\n| -------------------------------- | ----------------------------------------------------------------------------------------------- |\n| timer_id                         | The Id assigned for the timer by a [Worker](/concepts/what-is-a-worker) or user.                |\n| start_to_fire_timeout            | Amount of time to elapse before the timer fires.                                                |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with. |\n\n### TimerFired\n\nThis [Event](/concepts/what-is-an-event) type indicates a timer has fired.\n\n| Field            | Description                                                                      |\n| ---------------- | -------------------------------------------------------------------------------- |\n| timer_id         | The Id assigned for the timer by a [Worker](/concepts/what-is-a-worker) or user. |\n| started_event_id | The Id of the [TimerStarted](#timerstarted) Event itself.                        |\n\n### TimerCanceled\n\nThis [Event](/concepts/what-is-an-event) type indicates a Timer has been canceled.\n\n| Field                            | Description                                                                                     |\n| -------------------------------- | ----------------------------------------------------------------------------------------------- |\n| timer_id                         | The Id assigned for the timer by a [Worker](/concepts/what-is-a-worker) or user.                |\n| started_event_id                 | The Id of the [TimerStarted](#timerstarted) Event itself.                                       |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with. |\n\n### RequestCancelExternalWorkflowExecutionInitiated\n\nThis [Event](/concepts/what-is-an-event) type indicates that a [Workflow](/concepts/what-is-a-workflow) has requested that the [Temporal Server](/concepts/what-is-the-temporal-server) try to cancel another Workflow.\n\n| Field                            | Description                                                                                           |\n| -------------------------------- | ----------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.       |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Workflow that`s going to be signaled for execution. |\n| workflow_execution               | Identifies the Workflow and the run of the [Workflow Execution](/workflows#workflow-execution).       |\n| child_workflow_only              | Set to true if this Workflow is a child of the Workflow which issued the cancelation request.         |\n| reason                           | Information provided by the user or client for Workflow cancelation.                                  |\n\n### RequestCancelExternalWorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that [Temporal Server](/concepts/what-is-the-temporal-server) could not cancel the targeted [Workflow](/concepts/what-is-a-workflow).\nThis is usually because the target Workflow could not be found.\n\n| Field                            | Description                                                                                     |\n| -------------------------------- | ----------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with. |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Workflow that failed to cancel.               |\n| workflow_execution               | Identifies the Workflow and the run of the [Workflow Execution](/workflows#workflow-execution). |\n| initiated_event_id               | Id of the [RequestCancelExternalWorkflowExecutionInitiated] Event this failure corresponds to.  |\n\n### ExternalWorkflowExecutionCancelRequested\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) has successfully requested the cancelation of the target [Workflow](/concepts/what-is-a-workflow).\n\n| Field              | Description                                                                                                                                                       |\n| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| initiated_event_id | Id of the [RequestCancelExternalWorkflowExecutionInitiated](#requestcancelexternalworkflowexecutioninitiated) Event that this cancelation request corresponds to. |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Workflow that was requested to cancel.                                                                          |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/workflows#workflow-execution).                                                                   |\n\n### ExternalWorkflowExecutionSignaled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) has successfully [Signaled](/concepts/what-is-a-signal) the targeted [Workflow](/concepts/what-is-a-workflow).\n\n| Field              | Description                                                                                                                      |\n| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |\n| initiated_event_id | Id of the [SignalExternalWorkflowExecutionInitiated](#signalexternalworkflowexecutioninitiated) Event this Event corresponds to. |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Workflow that was signaled to.                                                 |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/workflows#workflow-execution).                                  |\n\n### MarkerRecorded\n\nThis [Event](/concepts/what-is-an-event) type is transparent to the [Temporal Server](/concepts/what-is-the-temporal-server) .\nThe Server will only store it and will not try to understand it.\nThe SDK client may use it for local activities or side effects.\n\n| Field                            | Description                                                                                                  |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------ |\n| marker_name                      | Identifies various markers.                                                                                  |\n| details                          | Serialized information recorded in the marker.                                                               |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.              |\n| header                           | Information passed by the sender of the [Signal](/concepts/what-is-a-signal) that is copied into the marker. |\n| failure                          | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                     |\n\n### StartChildWorkflowExecutionInitiated\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) will try to start a Child Workflow.\n\n| Field         | Description                                                       |\n| ------------- | ----------------------------------------------------------------- |\n| namespace     | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow. |\n| workflow_id   | Identifies the Child Workflow.                                    |\n| workflow_type | The name/type of Workflow that was initiated.                     |\n\n### StartChildWorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) cannot be started / triggered.\nIt is usually due to a Child Workflow Id collision.\n\n| Field                            | Description                                                                                                              |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow.                                                        |\n| workflow_id                      | Identifies the Child Workflow.                                                                                           |\n| workflow_type                    | The name/type of Workflow that has failed.                                                                               |\n| initiated_event_id               | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                          |\n\n### ChildWorkflowExecutionStarted\n\nThis [Event](/concepts/what-is-an-event) type indicates a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) has successfully started / triggered.\nThis would also cause the [WorkflowExecutionStarted](#workflowexecutionstarted) to be recorded for the Workflow that has started.\n\n| Field              | Description                                                                                                               |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------- |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow.                                                         |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to.  |\n| workflow_execution | Identifies the Workflow and the run of the Workflow Execution.                                                            |\n| workflow_type      | The name/type of Workflow that has started execution.                                                                     |\n| header             | Information passed by the sender of the [Signal](/concepts/what-is-a-signal) that is copied into the Child Workflow Task. |\n\n### ChildWorkflowExecutionCompleted\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) has successfully completed.\nThis would also cause the [WorkflowExecutionCompleted](#workflowexecutioncompleted) to be recorded for the [Workflow](/concepts/what-is-a-workflow) that has completed.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| result             | Serialized result of the completed Child Workflow.                                                                       |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the completed Child Workflow.                                              |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/workflows#workflow-execution).                          |\n| workflow_type      | The name/type of Workflow that was completed.                                                                            |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event this Event corresponds to.               |\n\n### ChildWorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) has unsuccessfully completed.\nThis would also cause the [WorkflowExecutionFailed](#workflowexecutionfailed) to be recorded for the Workflow that has failed.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| failure            | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                                 |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow that failed.                                            |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/workflows#workflow-execution).                          |\n| workflow_type      | The name/type of Workflow that has failed.                                                                               |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event this failure corresponds to.             |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                                 |\n\n### ChildWorkflowExecutionCanceled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Child Workflow Execution has been canceled.\nThis would also cause the [WorkflowExecutionCanceled](#workflowexecutioncanceled) to be recorded for the Workflow that was canceled.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| details            | Additional information reported by the Child Workflow upon cancelation.                                                  |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow that was canceled.                                      |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/workflows#workflow-execution).                          |\n| workflow_type      | The name/type of Workflow that was canceled.                                                                             |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event this cancelation corresponds to.         |\n\n### ChildWorkflowExecutionTimedOut\n\nThis Event type indicates that the [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) has timed out by the [Temporal Server](/concepts/what-is-the-temporal-server).\nThis would also cause the [WorkflowExecutionTimeOut](#workflowexecutiontimedout) to be recorded for the Workflow that timed out.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow.                                                        |\n| workflow_execution | Identifies the Workflow and the run of the Workflow Execution.                                                           |\n| workflow_type      | The name/type of Workflow that has timed out.                                                                            |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event that this timeout corresponds to.        |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                                 |\n\n### ChildWorkflowExecutionTerminated\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Child Workflow Execution has been terminated.\nThis would also cause the [WorkflowExecutionTerminated](#workflowexecutionterminated) to be recorded for the Workflow that was terminated.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow.                                                        |\n| workflow_execution | Identifies the Workflow and the run of the Workflow Execution.                                                           |\n| workflow_type      | The name/type of Workflow that was terminated.                                                                           |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event that this termination corresponds to.    |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                                 |\n\n### SignalExternalWorkflowExecutionInitiated\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) will try to [Signal](/concepts/what-is-a-signal) the targeted [Workflow](/concepts/what-is-a-workflow).\nThis Event type contains the Signal name, as well as a Signal payload.\n\n| Field                            | Description                                                                                     |\n| -------------------------------- | ----------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with. |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Workflow that's to be signaled.               |\n| workflow_execution               | Identifies the Workflow and the run of the [Workflow Execution](/workflows#workflow-execution). |\n| signal_name                      | The name/type of Signal to be fired.                                                            |\n| input                            | Information that is deserialized by the SDK to provide arguments to the Workflow Function.      |\n| child_workflow_only              | Set to true if this Workflow is a child of the Workflow which issued the cancelation request.   |\n| header                           | Information to be passed from the Signal to the targeted Workflow.                              |\n\n### SignalExternalWorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) cannot Signal the targeted [Workflow](/concepts/what-is-a-workflow), usually because the Workflow could not be found.\n\n| Field                            | Description                                                                                                                                                                           |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                                                                                       |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Workflow that failed to execute.                                                                                                    |\n| workflow_execution               | Identifies the Workflow and the run of the [Workflow Execution](/workflows#workflow-execution).                                                                                       |\n| initiated_event_id               | Id of the [RequestCancelExternalWorkflowExecutionInitiated](#requestcancelexternalworkflowexecutioninitiated) Event this failure [signal](/concepts/what-is-a-signal) corresponds to. |\n\n### UpsertWorkflowSearchAttributes\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Workflow [Search Attributes](/concepts/what-is-a-search-attribute) should be updated and synchronized with the visibility store.\n\n| Field                            | Description                                                                                          |\n| -------------------------------- | ---------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The [WorkflowTaskCompleted](#workflowtaskcompleted) Event reported the Event with this Id.           |\n| search_attributes                | Provides data for setting up a Workflow's [Search Attributes](/concepts/what-is-a-search-attribute). |\n\n### WorkflowExecutionUpdateAcceptedEvent\n\nThis [Event](/concepts/what-is-an-event) type indicates that a [Workflow Execution](/concepts/what-is-a-workflow-execution) has accepted an [Update](/concepts/what-is-an-update) for execution.\nThe original request input payload is both indicated and stored by this Event, as it generates no Event when initially requesting an Update.\n\n| Field                                | Description                                                                                                                                                            |\n| ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| protocol_instance_id                 | The instance of the Update protocol with this Id is executing this Update.                                                                                             |\n| accepted_request_message_id          | The Id of the request message sent by [Temporal Server](/concepts/what-is-the-temporal-server) to the [Worker](/concepts/what-is-a-worker).                            |\n| accepted_request_sequencing_event_id | Execute this Update after the Event with this Id.                                                                                                                      |\n| accepted_request                     | The request input and metadata initially provided by the invoker of the Update and subsequently relayed by Temporal Server to the Worker for acceptance and execution. |\n\n### WorkflowExecutionUpdateCompletedEvent\n\nThis [Event](/concepts/what-is-an-event) type indicates that a [Workflow Execution](/concepts/what-is-a-workflow-execution) has executed an [Update](/concepts/what-is-an-update) to completion.\n\n| Field             | Description                                                                                                                                  |\n| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\n| meta              | The metadata associated with this Update, sourced from the initial request.                                                                  |\n| accepted_event_id | The Id of the [WorkflowExecutionUpdateAcceptedEvent](#WorkflowExecutionUpdateAcceptedEvent) The Platform accepted this Update for execution. |\n| outcome           | The outcome of execution of this Update whether the execution resulted in a success or a failure.                                            |\n","is_empty":false},{"file_name":"sdk-metrics.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/sdk-metrics.md","id":"references/sdk-metrics","title":"SDK metrics","description":"The Temporal SDKs emit metrics from Temporal Client usage and Worker Processes.","label":"SDK metrics","tags":["reference"],"ssdi":[],"markdown_content":"\n:::info SDK metrics\n\nThe information on this page is relevant to [Temporal SDKs](/concepts/what-is-a-temporal-sdk).\n\nSee [Cloud metrics](/cloud/how-to-monitor-temporal-cloud-metrics) for metrics emitted by [Temporal Cloud](/concepts/what-is-temporal-cloud).\n\nSee [Cluster metrics](/references/cluster-metrics) for metrics emitted by the [OSS Cluster](/concepts/what-is-a-temporal-cluster).\n\n:::\n\nThe Temporal SDKs emit a set of metrics from Temporal Client usage and Worker Processes.\n\n- [How to emit metrics using the Go SDK](/go/metrics)\n- [How to emit metrics using the Java SDK](/java/metrics)\n- [How to emit metrics using the Python SDK](/python/metrics)\n- [How to emit metrics using the TypeScript SDK](/typescript/metrics)\n\n- [How to tune Worker performance based on metrics](/dev-guide/worker-performance)\n\nAll metrics are prefixed with `temporal_` before being exported to their configured destination.\n(The prefix has been removed in the following reference.)\nCurrently, some metrics are specific to certain SDKs.\n\nTypeScript, Python, .NET, and Ruby SDKs metrics are defined in the Core SDK.\n\nPHP and Go metrics are defined in the Go SDK.\n\nJava metrics are defined in the Java SDK\nMetrics are defined in the following locations.\n\n- [Core SDK Worker metrics](https://github.com/temporalio/sdk-core/blob/master/core/src/telemetry/metrics.rs)\n- [Core SDK Client metrics](https://github.com/temporalio/sdk-core/blob/master/client/src/metrics.rs)\n- [Java SDK Worker metrics](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/worker/MetricsType.java)\n- [Java SDK Client metrics](https://github.com/temporalio/sdk-java/blob/master/temporal-serviceclient/src/main/java/io/temporal/serviceclient/MetricsType.java)\n- [Go SDK Worker and Client metrics](https://github.com/temporalio/sdk-go/blob/c32b04729cc7691f80c16f80eed7f323ee5ce24f/internal/common/metrics/constants.go)\n\nEach metric may have some combination of the following keys attached to them:\n\n- `task-queue`: Task Queue that the Worker Entity is polling\n- `namespace`: Namespace the Worker is bound to\n- `poller_type`: One of the following:\n  - `workflow_task`\n  - `activity_task`\n  - `sticky_workflow_task`\n- `worker_type`: One of the following:\n  - `ActivityWorker`\n  - `WorkflowWorker`\n  - `LocalActivityWorker` (Go and Java only)\n- `activity_type`: The name of the Activity Function the metric is associated with\n- `workflow_type`: The name of the Workflow Function the metric is associated with\n- `operation`: RPC method name; available for metrics related to Temporal Client gRPC requests\n\nSome keys may not be available in every SDK, and Histogram metrics may have different buckets in each SDK.\n\n| Metric name                                                                             | Emitted by     | Metric type | Availability   |\n| --------------------------------------------------------------------------------------- | -------------- | ----------- | -------------- |\n| [activity_execution_cancelled](#activity_execution_cancelled)                           | Worker         | Counter     | Java           |\n| [activity_execution_failed](#activity_execution_failed)                                 | Worker         | Counter     | Core, Go, Java |\n| [activity_execution_latency](#activity_execution_latency)                               | Worker         | Histogram   | Core, Go, Java |\n| [activity_poll_no_task](#activity_poll_no_task)                                         | Worker         | Counter     | Core, Go, Java |\n| [activity_schedule_to_start_latency](#activity_schedule_to_start_latency)               | Worker         | Histogram   | Core, Go, Java |\n| [activity_task_error](#activity_task_error)                                             | Worker         | Counter     | Go,            |\n| [corrupted_signals](#corrupted_signals)                                                 | Worker         | Counter     | Go, Java       |\n| [local_activity_execution_cancelled](#local_activity_execution_cancelled)               | Worker         | Counter     | Go, Java       |\n| [local_activity_execution_failed](#local_activity_execution_failed)                     | Worker         | Counter     | Go, Java       |\n| [local_activity_execution_latency](#local_activity_execution_latency)                   | Worker         | Histogram   | Go, Java       |\n| [local_activity_succeeded_endtoend_latency](#local_activity_succeeded_endtoend_latency) | Worker         | Histogram   | Go, Java       |\n| [local_activity_total](#local_activity_total)                                           | Worker         | Counter     | Go, Java       |\n| [long_request](#long_request)                                                           | Service Client | Counter     | Core, Go, Java |\n| [long_request_failure](#long_request_failure)                                           | Service Client | Counter     | Core, Go, Java |\n| [long_request_latency](#long_request_latency)                                           | Service Client | Histogram   | Core, Go, Java |\n| [num_pollers](#num_pollers)                                                             | Worker         | Gauge       | Core           |\n| [poller_start](#poller_start)                                                           | Worker         | Counter     | Go, Java       |\n| [request](#request)                                                                     | Service Client | Counter     | Core, Go, Java |\n| [request_failure](#request_failure)                                                     | Service Client | Counter     | Core, Go, Java |\n| [request_latency](#request_latency)                                                     | Service Client | Histogram   | Core, Go, Java |\n| [sticky_cache_hit](#sticky_cache_hit)                                                   | Worker         | Counter     | Core, Go, Java |\n| [sticky_cache_miss](#sticky_cache_miss)                                                 | Worker         | Counter     | Core, Go, Java |\n| [sticky_cache_size](#sticky_cache_size)                                                 | Worker         | Gauge       | Core, Go, Java |\n| [sticky_cache_total_forced_eviction](#sticky_cache_total_forced_eviction)               | Worker         | Counter     | Go, Java       |\n| [unregistered_activity_invocation](#unregistered_activity_invocation)                   | Worker         | Counter     | Go,            |\n| [worker_start](#worker_start)                                                           | Worker         | Counter     | Core, Go, Java |\n| [worker_task_slots_available](#worker_task_slots_available)                             | Worker         | Gauge       | Go, Java       |\n| [workflow_active_thread_count](#workflow_active_thread_count)                           | Worker         | Gauge       | Java           |\n| [workflow_cancelled](#workflow_cancelled)                                               | Worker         | Counter     | Core, Go, Java |\n| [workflow_completed](#workflow_completed)                                               | Worker         | Counter     | Core, Go, Java |\n| [workflow_continue_as_new](#workflow_continue_as_new)                                   | Worker         | Counter     | Core, Go, Java |\n| [workflow_endtoend_latency](#workflow_endtoend_latency)                                 | Worker         | Histogram   | Core, Go, Java |\n| [workflow_failed](#workflow_failed)                                                     | Worker         | Counter     | Core, Go, Java |\n| [workflow_task_execution_failed](#workflow_task_execution_failed)                       | Worker         | Counter     | Core, Go, Java |\n| [workflow_task_execution_latency](#workflow_task_execution_latency)                     | Worker         | Histogram   | Core, Go, Java |\n| [workflow_task_queue_poll_empty](#workflow_task_queue_poll_empty)                       | Worker         | Counter     | Core, Go, Java |\n| [workflow_task_queue_poll_succeed](#workflow_task_queue_poll_succeed)                   | Worker         | Counter     | Core, Go, Java |\n| [workflow_task_replay_latency](#workflow_task_replay_latency)                           | Worker         | Histogram   | Core, Go, Java |\n| [workflow_task_schedule_to_start_latency](#workflow_task_schedule_to_start_latency)     | Worker         | Histogram   | Core, Go, Java |\n\n### activity_execution_cancelled\n\nAn Activity Execution was canceled.\n\n- Type: Counter\n- Available in: Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### activity_execution_failed\n\nAn Activity Execution failed.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### activity_execution_latency\n\nTime to complete an Activity Execution, from the time the Activity Task is generated to the time the language SDK responded with a completion (failure or success).\n\n- Type: Histogram\n- Available in: Core, Go, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### activity_poll_no_task\n\nAn Activity Worker poll for an Activity Task timed out, and no Activity Task is available to pick from the Task Queue.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### activity_schedule_to_start_latency\n\nThe Schedule-To-Start time of an Activity Task in milliseconds.\nA [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) can be set when an Activity Execution is spawned.\nThis metric is useful for ensuring Activity Tasks are being processed from the queue in a timely manner. Some SDKs may include\nthe `activity_type` label, but the metric should not vary by type, as it does not influence the rate at which tasks are pulled\nfrom the queue.\n\n- Type: Histogram\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`\n\n### activity_task_error\n\nAn internal error or panic occurred during Activity Task handling or execution.\n\n- Type: Counter\n- Available in: Go,\n- Tags: `activity_type`, `namespace`, `task_queue`, `workflow_type`\n\n### corrupted_signals\n\nNumber of Signals whose payload could not be deserialized.\n\n- Type: Counter\n- Available in: Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### local_activity_execution_cancelled\n\nA Local Activity Execution was canceled.\n\n- Type: Counter\n- Available in: Go, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### local_activity_execution_failed\n\nA Local Activity Execution failed.\n\n- Type: Counter\n- Available in: Go, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### local_activity_execution_latency\n\nTime to complete a Local Activity Execution, from the time the first Activity Task is generated to the time the SDK responds that the execution is complete.\n\n- Type: Histogram\n- Available in: Go, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### local_activity_succeeded_endtoend_latency\n\nTotal latency of successfully finished Local Activity Executions (from schedule to completion).\n\n- Type: Histogram\n- Available in: Go, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### local_activity_total\n\nTotal number of [Local Activity Executions](/concepts/what-is-a-local-activity).\n\n- Type: Counter\n- Available in: Go, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### long_request\n\nTemporal Client made an RPC long poll request.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `operation`\n\n### long_request_failure\n\nTemporal Client made an RPC long poll request that failed.\nThis number is included into the total `long_request` counter for long poll RPC requests.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `operation`\n\n### long_request_latency\n\nLatency of a Temporal Client gRPC long poll request.\n\n- Type: Histogram\n- Available in: Core, Go, Java\n- Tags: `namespace`, `operation`\n\n### num_pollers\n\nCurrent number of Worker Entities that are polling.\n\n- Type: Gauge\n- Available in: Core\n- Tags: `namespace`, `poller_type`, `task_queue`\n\n### poller_start\n\nA Worker Entity poller was started.\n\n- Type: Counter\n- Available in: Go, Java\n- Tags: `namespace`, `task_queue`\n\n### request\n\nTemporal Client made an RPC request.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `operation`\n\n### request_failure\n\nTemporal Client made an RPC request that failed.\nThis number is included into the total `request` counter for RPC requests.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `operation`\n\n### request_latency\n\nLatency of a Temporal Client gRPC request.\n\n- Type: Histogram\n- Available in: Core, Go, Java\n- Tags: `namespace`, `operation`\n\n### sticky_cache_hit\n\nA Workflow Task found a cached Workflow Execution Event History to run against.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`\n\n### sticky_cache_miss\n\nA Workflow Task did not find a cached Workflow Worker.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`\n\n### sticky_cache_size\n\nCurrent cache size, expressed in number of Workflow Executions.\n\n- Type: Gauge\n- Available in: Core, Go, Java\n- Tags: `namespace` (TypeScript, Java), `task_queue` (TypeScript)\n\n### sticky_cache_total_forced_eviction\n\nA Workflow Execution has been forced from the cache intentionally.\n\n- Type: Counter\n- Available in: Go, Java\n- Tags: `namespace`, `task_queue`\n\n### unregistered_activity_invocation\n\nA request to spawn an Activity Execution is not registered with the Worker.\n\n- Type: Counter\n- Available in: Go,\n- Tags: `activity_type`, `namespace`, `task_queue`, `workflow_type`\n\n### worker_start\n\nA Worker Entity has been registered, created, or started.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `worker_type`\n\n### worker_task_slots_available\n\nThe total number of Workflow Task and Activity Task execution slots that are currently available.\nUse the `worker_type` key to differentiate execution slots.\n(Workflow Workers execute Workflow Tasks; Activity Workers execute Activity Tasks.)\n\n- Type: Gauge\n- Available in: Go, Java\n- Tags: `namespace`, `task_queue`, `worker_type`\n\n### workflow_active_thread_count\n\nTotal amount of Workflow threads in the Worker Process.\n\n- Type: Gauge\n- Available in: Java\n\n### workflow_cancelled\n\nWorkflow Execution ended because of a cancellation request.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_completed\n\nA Workflow Execution completed successfully.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_continue_as_new\n\nA Workflow ended with Continue-As-New.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_endtoend_latency\n\nTotal Workflow Execution time from schedule to completion for a single Workflow Run. (A retried Workflow Execution is a separate Run.)\n\n- Type: Histogram\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_failed\n\nA Workflow Execution failed.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_execution_failed\n\nA Workflow Task Execution failed.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_execution_latency\n\nWorkflow Task Execution time.\n\n- Type: Histogram\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_queue_poll_empty\n\nA Workflow Worker polled a Task Queue and timed out without picking up a Workflow Task.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_queue_poll_succeed\n\nA Workflow Worker polled a Task Queue and successfully picked up a Workflow Task.\n\n- Type: Counter\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_replay_latency\n\nTime to catch up on replaying a Workflow Task.\n\n- Type: Histogram\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_schedule_to_start_latency\n\nThe Schedule-To-Start time of a Workflow Task.\n\n- Type: Histogram\n- Available in: Core, Go, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n","is_empty":false},{"file_name":"server-options.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/server-options.md","id":"references/server-options","title":"Temporal Server options","description":"You can run the Temporal Server as a Go application by including the server package `go.temporal.io/server/temporal` and using it to create and start a Temporal Server.","label":"Start options","tags":["reference","web-ui"],"ssdi":[],"markdown_content":"\nYou can run the [Temporal Server](/concepts/what-is-the-temporal-server) as a Go application by including the server package `go.temporal.io/server/temporal` and using it to create and start a Temporal Server.\n\nThe Temporal Server services can be [run in various ways](/kb/all-the-ways-to-run-a-cluster).\nWe recommend this approach for a limited number of situations.\n\n```go\ns := temporal.NewServer()\nerr := s.Start()\nif err != nil{\n\tlog.Fatal(err)\n}\n```\n\n`NewServer()` accepts functions as parameters.\nEach function returns a `ServerOption` that is applied to the instance.\nSource code for parameter reference is here: https://github.com/temporalio/temporal/blob/master/temporal/server_option.go\n\n### WithConfig\n\nOverrides the default configuration with a custom configuration that is defined in the config package `go.temporal.io/server/common/service/config`.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithConfig(cfg),\n)\n```\n\n### WithConfigLoader\n\nLoad a custom configuration from a file.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithConfigLoader(configDir, env, zone),\n)\n```\n\n### ForServices\n\nSets the list of all valid temporal services.\nThe default can be used from the `go.temporal.io/server/temporal` package.\n\n```go\ns := temporal.NewServer(\n\ttemporal.ForServices(temporal.Services),\n)\n```\n\n### InterruptOn\n\nThis option provides a channel that interrupts the server on the signal from that channel.\n\n- If `temporal.InterruptOn()` is not passed, `server.Start()` is never blocked and you need to call `server.Stop()` somewhere.\n- If `temporal.InterruptOn(nil)` is passed, `server.Start()` blocks forever until the process is killed.\n- If `temporal.InterruptOn(temporal.InterruptCh())` is passed, `server.Start()` blocks until you use Ctrl+C, which then gracefully shuts the server down.\n- If `temporal.Interrupt(someCustomChan)` is passed, `server.Start()` blocks until a signal is sent to `someCustomChan`.\n\n```go\ns := temporal.NewServer(\n\ttemporal.InterruptOn(temporal.InterruptCh()),\n)\n```\n\n### WithAuthorizer\n\nSets a low level [authorization mechanism](/concepts/what-is-an-authorizer-plugin) that determines whether to allow or deny inbound API calls.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithAuthorizer(myAuthorizer),\n)\n```\n\n### WithTLSConfigFactory\n\nOverrides the default TLS configuration provider.\n`TLSConfigProvider` is defined in the `go.temporal.io/server/common/rpc/encryption` package.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithTLSConfigFactory(yourTLSConfigProvider),\n)\n```\n\n### WithClaimMapper\n\nConfigures a [mechanism to map roles](/security/#claimmapper-plugin-interface) to `Claims` for authorization.\n\n```go\ns := temporal.NewServer(\n  temporal.WithClaimMapper(func(cfg *config.Config) authorization.ClaimMapper {\n\t\treturn authorization.NewDefaultJWTClaimMapper(\n\t\t\tauthorization.NewRSAKeyProvider(cfg),\n\t\t\tcfg\n\t\t)\n\t}),\n)\n```\n\n### WithCustomMetricsReporter\n\nSets a custom tally metric reporter.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithCustomMetricsReporter(myReporter),\n)\n```\n\nYou can see the [Uber tally docs on custom reporter](https://github.com/uber-go/tally#report-your-metrics) and see a community implementation of [a reporter for Datadog's `dogstatsd` format](https://github.com/temporalio/temporal/pull/998#issuecomment-857884983).\n","is_empty":false},{"file_name":"web-ui-configuration.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/web-ui-configuration.md","id":"references/web-ui-configuration","title":"Temporal Web UI configuration reference","description":"The Temporal Web UI Server uses a configuration file for many of the UI's settings.","label":"Web UI configuration","tags":["reference","web-ui"],"ssdi":[],"markdown_content":"\nThe Temporal Web UI Server uses a configuration file for many of the UI's settings.\n\nAn example development.yaml file can be found in the [temporalio/ui-server repo](https://github.com/temporalio/ui-server/blob/main/config/development.yaml).\n\nMultiple configuration files can be created for configuring specific areas of the UI, such as Auth or TLS.\n\n## enableUi\n\nEnables the browser UI.\nThis configuration can be set dynamically with the [TEMPORAL_UI_ENABLED](/references/web-ui-environment-variables#temporaluienabled) environment variable.\nIf disabled—that is, set to `false`—the UI server APIs remain available.\n\n```yaml\nenableUi: true\n```\n\n## enableOpenApi\n\nEnables the UI Server's Open API reference documentation at `/openapi/`.\nThis configuration can be set dynamically with the [TEMPORAL_OPEN_API_ENABLED](/references/web-ui-environment-variables#temporalopenapienabled) environment variable.\nFor example, if you are currently viewing the Web UI at `http://localhost:8080`, the page is available at [localhost:8080/openapi/](http://localhost:8080/openapi/).\n\n```yaml\nenableOpenApi: true\n```\n\n## cors\n\nThe name of the `cors` field stands for Cross-Origin Resource Sharing.\nUse this field to provide a list of domains that are authorized to access the UI Server APIs.\n\n```yaml\ncors:\n  allowOrigins:\n    - http://localhost:3000 # used at development by https://github.com/temporalio/ui\n```\n\n## refreshInterval\n\nHow often the configuration UI Server reads the configuration file for new values.\nCurrently, only [tls](#tls) configuration values are propagated during a refresh.\n\n```yaml\nrefreshInterval: 1m\n```\n\n## temporalGrpcAddress\n\nThe frontend adddress for the Temporal Cluster.\n\nThe default address is localhost (127.0.0.1:7233).\n\n```yaml\ntemporalGrpcAddress: default\n```\n\n## port\n\nThe port used by the Temporal Web UI Server and any APIs.\n\n```yaml\nport: 8080\n```\n\n## defaultNamespace\n\nThe default Namespace that the UI loads data for.\nDefaults to `default`.\n\n```yaml\ndefaultNamespace: default\n```\n\n## showTemporalSystemNamespace\n\nWhen enabled—that is, when set to `true`—the Temporal System Namespace becomes visible in the UI.\nThe Temporal System Namespace lists Workflow Executions used by the Temporal Platform.\n\n```yaml\nshowTemporalSystemNamespace: false\n```\n\n## feedbackUrl\n\nThe URL to direct users to when they click on the Feedback button in the UI.\nIf not specified, it defaults to the UI's GitHub Issue page.\n\n```yaml\nfeedbackUrl: https://github.com/temporalio/ui/issues/new/choose\n```\n\n## notifyOnNewVersion\n\nWhen enabled—that is, when set to `true`—a notification appears in the UI when a newer version of the [Temporal Server](/clusters#temporal-server) is available.\n\n```yaml\nnotifyOnNewVersion: true\n```\n\n## auth\n\nAuth configuration.\n\n```yaml\nauth:\n  enabled: false\n  providers:\n    - label: Auth0 oidc # for internal use; in future may expose as button text\n      type: oidc # for futureproofing; only oidc is supported today\n      providerUrl: https://myorg.us.auth0.com/\n      clientId: xxxxxxxxxxxxxxxxxxxx\n      clientSecret: xxxxxxxxxxxxxxxxxxxx\n      scopes:\n        - openid\n        - profile\n        - email\n      callbackUrl: http://localhost:8080/auth/sso/callback\n      passIdToken: false\n      options: # added as URL query params when redirecting to auth provider\n        audience: myorg-dev\n        organization: org_xxxxxxxxxxxx\n        invitation:\n```\n\n## tls\n\nTransport Layer Security (TLS) configuration.\n\n```yaml\ntls:\n  caFile:\n  certFile:\n  keyFile:\n  caData:\n  certData:\n  keyData:\n  enableHostVerification: false\n  serverName:\n```\n\n## codec\n\nCodec Server configuration.\n\n```yaml\ncodec:\n  endpoint: http://your-codec-server-endpoint\n  passAccessToken: false\n```\n\n## disableWriteActions\n\nPrevents the user from executing Workflow Actions on the Web UI.\n\nThis option affects Bulk Actions for Recent Workflows as well as Workflow Actions on the Workflow Details page.\n\n```yaml\ndisableWriteActions: false\n```\n\n:::note\n`disableWriteActions` overrides the configuration values of each individual Workflow Action.\nSetting this variable to `true` disables all Workflow Actions on the Web UI.\n:::\n\n## workflowTerminateDisabled\n\nPrevents the user from terminating Workflow Executions from the Web UI.\n\n```yaml\nworkflowTerminateDisabled: false\n```\n\n## workflowCancelDisabled\n\nPrevents the user from canceling Workflow Executions from the Web UI.\n\n```yaml\nworkflowCancelDisabled: false\n```\n\n## workflowSignalDisabled\n\nPrevents the user from signaling Workflow Executions from the Web UI.\n\n```yaml\nworkflowSignalDisabled: false\n```\n\n## workflowResetDisabled\n\nPrevents the user from resetting Workflows from the Web UI.\n\n```yaml\nworkflowResetDisabled: false\n```\n","is_empty":false},{"file_name":"web-ui-environment-variables.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/web-ui-environment-variables.md","id":"references/web-ui-environment-variables","title":"Temporal Web UI environmental variables","description":"How to set  environmental variables for Temporal Web UI.","label":"Web UI env var","tags":["docker","webui","ui server","reference"],"ssdi":[],"markdown_content":"\nYou can use environment variables to dynamically alter the configuration of your Temporal Web UI.\n\nThese can be used in many environments such as Docker.\nFor example:\n\n<!-- ```\ndocker run \\\n    -e TEMPORAL_ADDRESS=127.0.0.1:7233 \\\n    -e TEMPORAL_UI_PORT=8080 \\\n    -e TEMPORAL_AUTH_ENABLED=true \\\n    -e TEMPORAL_AUTH_PROVIDER_URL=https://accounts.google.com \\\n    -e TEMPORAL_AUTH_CLIENT_ID=xxxxx-xxxx.apps.googleusercontent.com \\\n    -e TEMPORAL_AUTH_CLIENT_SECRET=xxxxxxxxxxxxxxx \\\n    -e TEMPORAL_AUTH_CALLBACK_URL=https://xxxx.com:8080/auth/sso/callback \\\n    -e TEMPORAL_UI_ENABLED=true \\\n    -e TEMPORAL_OPENAPI_ENABLED=true \\\n    -e TEMPORAL_TLS_CA=../ca.cert \\\n    -e TEMPORAL_TLS_CERT=../cluster.pem \\\n    -e TEMPORAL_TLS_KEY=../cluster.key \\\n    -e TEMPORAL_TLS_ENABLE_HOST_VERIFICATION=true \\\n    -e TEMPORAL_TLS_SERVER_NAME=tls-server \\\n    temporalio/ui:<tag>\n``` -->\n\nThe environment variables are defined in the [UI server configuration template file](https://github.com/temporalio/ui-server/blob/main/docker/config_template.yaml) and described in more detail below.\n\n## `TEMPORAL_ADDRESS`\n\nThe [Frontend Service](/concepts/what-is-a-frontend-service) address for the Temporal Cluster.\nThis environmental variable can be set [in the base configuration file](/references/web-ui-configuration#temporalgrpcaddress) using `temporalGrpcAddress`.\n\nThis variable is required for setting other environmental variables.\n\n## `TEMPORAL_UI_PORT`\n\nThe port used by the Temporal WebUI Server and the HTTP API.\n\nThis variable is needed for `TEMPORAL_OPENAPI_ENABLED` and all auth-related settings to work properly.\n\n## `TEMPORAL_PUBLIC_PATH`\n\nStores a value such as \"\" or \"/custom-path\" that allows the UI to be served from a subpath.\n\n## `TEMPORAL_AUTH_ENABLED`\n\nEnables or disables Web UI authentication and authorization methods.\n\nWhen enabled, the Web UI will use the provider information in the [UI configuration file](/references/web-ui-configuration#auth) to verify the identity of users.\n\nAll auth-related variables can be defined when `TEMPORAL_AUTH_ENABLED` is set to \"true\".\nDisabling the variable will retain given values.\n\n## `TEMPORAL_AUTH_PROVIDER_URL`\n\nThe .well-known IDP discovery URL for authentication and authorization.\n\nThis can be set as in the UI server configuration with [auth](/references/web-ui-configuration#auth).\n\n## `TEMPORAL_AUTH_ISSUER_URL`\n\nThe URL for the authentication or authorization issuer.\n\nThis value is only needed when the issuer differes from the auth provider URL.\n\n## `TEMPORAL_AUTH_CLIENT_ID`\n\nThe client ID used for authentication or authorization.\n\nThis value is a required parameter.\n\n## `TEMPORAL_AUTH_CLIENT_SECRET`\n\nThe client secret used for authentication and authorization.\n\nClient Secrets are used by the oAuth Client for authentication.\n\n## `TEMPORAL_AUTH_CALLBACK_URL`\n\nThe callback URL used by Temporal for authentication and authorization.\n\nCallback URLs are invoked by IDP after user has finished authenticating in IDP.\n\n## `TEMPORAL_UI_ENABLED`\n\nEnables or disables the [browser UI](/references/web-ui-configuration#enableui) for the Temporal Cluster.\n\nEnabling the browser UI allows the Server to be accessed from your web browser.\nIf disabled, the server cannot be viewed on the web, but the UI server APIs remain available for use.\n\n## `TEMPORAL_OPENAPI_ENABLED`\n\nEnables or disables OpenAPI features for the Temporal Web UI.\n\nThis can be set initially with the [enableOpenAPI](/references/web-ui-configuration#enableopenapi) UI configuration.\nThe documentation can be found at `/openapi/` on your Temporal Cluster.\n\nThis variable requires `TEMPORAL_UI_ENABLED` to be set to 'true'.\n\n## `TEMPORAL_DEFAULT_NAMESPACE`\n\nThe default [Namespace](/concepts/what-is-a-namespace) that the Web UI opens first.\n\n## `TEMPORAL_FEEDBACK_URL`\n\nThe URL that users are directed to when they click the Feedback button in the UI.\n\nIf not specified, this variable defaults to the UI's GitHub Issue page.\n\n## `TEMPORAL_NOTIFY_ON_NEW_VERSION`\n\nEnables or disables notifications that appear in the UI whenever a newer version of the Temporal Cluster is available.\n\n## `TEMPORAL_CONFIG_REFRESH_INTERVAL`\n\nDetermines how often the UI Server reads the configuration file for new values.\n\n## `TEMPORAL_TLS_CA`\n\nThe path for the Transport Layer Security (TLS) Certificate Authority file.\n\nIn order to [configure TLS for your server](/references/web-ui-configuration#tls), you'll need a CA certificate issued by a trusted Certificate Authority.\nSet this variable to properly locate and use the file.\n\n## `TEMPORAL_TLS_CERT`\n\nThe path for the Transport Layer Security (TLS) Certificate.\n\nIn order to [configure TLS for your server](/references/web-ui-configuration#tls), you'll need a self-signed certificate.\nSet the path to allow the environment to locate and use the certificate.\n\n## `TEMPORAL_TLS_KEY`\n\nThe path for the Transport Layer Security (TLS) [key file](/references/web-ui-configuration#tls).\n\nA key file is used to create private and public keys for encryption and signing.\nTogether, these keys are used to create certificates.\n\n## `TEMPORAL_TLS_CA_DATA`\n\nStores the data for a TLS CA file.\n\nThis variable can be used instead of providing a path for `TEMPORAL_TLS_CA`.\n\n## `TEMPORAL_TLS_CERT_DATA`\n\nStores the data for a TLS cert file.\n\nThis variable can be used instead of providing a path for `TEMPORAL_TLS_CERT`.\n\n## `TEMPORAL_TLS_KEY_DATA`\n\nStores the data for a TLS key file.\n\nThis variable can be used instead of providing a path for `TEMPORAL_TLS_KEY`.\n\n## `TEMPORAL_TLS_ENABLE_HOST_VERIFICATION`\n\nEnables or disables [Transport Layer Security (TLS) host verification](/references/web-ui-configuration#tls).\n\nWhen enabled, TLS checks the Host Server to ensure that files are being sent to and from the correct URL.\n\n## `TEMPORAL_TLS_SERVER_NAME`\n\nThe server on which to operate [Transport Layer Security (TLS) protocols](/references/web-ui-configuration#tls).\n\nTLS allows the current server to transmit encrypted files to other URLs without having to reveal itself.\nBecause of this, TLS operates a go-between server.\n\n## `TEMPORAL_CODEC_ENDPOINT`\n\nThe endpoint for the [Codec Server](/concepts/what-is-a-codec-server), if configured.\n\n## `TEMPORAL_CODEC_PASS_ACCESS_TOKEN`\n\nWhether to send a JWT access token as ‘authorization’ header in requests with the Codec Server.\n\n## `TEMPORAL_FORWARD_HEADERS`\n\nForward-specified HTTP headers to direct from HTTP API requests to the Temporal gRPC backend.\n\n## `TEMPORAL_DISABLE_WRITE_ACTIONS`\n\nDisables any button in the UI that allows the user to modify Workflows or Activities.\n","is_empty":false},{"file_name":"web-ui-server-env-vars.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/web-ui-server-env-vars.md","id":"references/web-ui-server-env-vars","title":"Web UI Docker Environmental Variables","description":"How to set the docker environmental variables quickly.","label":"Web UI Docker Environmental Variables","tags":["docker","webui","reference"],"ssdi":[],"markdown_content":"\nDocker containers can be configured for use in a production setting.\nUse `docker run` to configure the Web UI environmental variables.\n\n```\ndocker run \\\n    -e TEMPORAL_ADDRESS=127.0.0.1:7233 \\\n    -e TEMPORAL_UI_PORT=8080 \\\n    -e TEMPORAL_AUTH_ENABLED=true \\\n    -e TEMPORAL_AUTH_PROVIDER_URL=https://accounts.google.com \\\n    -e TEMPORAL_AUTH_CLIENT_ID=xxxxx-xxxx.apps.googleusercontent.com \\\n    -e TEMPORAL_AUTH_CLIENT_SECRET=xxxxxxxxxxxxxxx \\\n    -e TEMPORAL_AUTH_CALLBACK_URL=https://xxxx.com:8080/auth/sso/callback \\\n    -e TEMPORAL_UI_ENABLED=true \\\n    -e TEMPORAL_OPENAPI_ENABLED=true \\\n    -e TEMPORAL_TLS_CA=../ca.cert \\\n    -e TEMPORAL_TLS_CERT=../cluster.pem \\\n    -e TEMPORAL_TLS_KEY=../cluster.key \\\n    -e TEMPORAL_TLS_ENABLE_HOST_VERIFICATION=true \\\n    -e TEMPORAL_TLS_SERVER_NAME=tls-server \\\n    temporalio/ui:<tag>\n```\n\n## Environmental Variables\n\nThe environmental variables are defined below:\n\n- `TEMPORAL_ADDRESS` : Temporal frontend address.\n- `TEMPORAL_UI_PORT` : port to serve HTTP API and UI.\n- `TEMPORAL_AUTH_ENABLED` : enable or disable authentication/authorization.\n- `TEMPORAL_AUTH_PROVIDER_URL` : Authentication/authorization OIDC provider URL.\n- `TEMPORAL_AUTH_CLIENT_ID` : authentication/authorization client ID.\n- `TEMPORAL_AUTH_CLIENT_SECRET` : authentication/authorization client secret.\n- `TEMPORAL_AUTH_CALLBACK_URL` : authentication/authorization callback URL.\n- `TEMPORAL_UI_ENABLED` : enable or disable serve UI.\n- `TEMPORAL_OPENAPI_ENABLED` : enable or disable serve open API UI.\n- `TEMPORAL_TLS_CA` : TLS Certificate Authority path.\n- `TEMPORAL_TLS_CERT` : TLS certificate path.\n- `TEMPORAL_TLS_KEY` : TLS key path.\n- `TEMPORAL_TLS_ENABLE_HOST_VERIFICATION` : enable or disable TLS host verification.\n- `TEMPORAL_TLS_SERVER_NAME` : TLS server name.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-cancel-timer-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-cancel-timer-attributes.md","id":"references/strongly-typed-errors/bad-cancel-timer-attributes","title":"Bad Cancel Timer Attributes","description":"Explanation for Bad Cancel Timer Attributes error message, and how to fix it.","label":"Bad Cancel Timer Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed while attempting to cancel a Timer.\n\n<!-- TODO add Timer term definition and link to it -->\n\nCheck your Timer attributes for a missing Timer Id value.\nAdd a valid Timer Id and redeploy the code.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-cancel-workflow-execution-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-cancel-workflow-execution-attributes.md","id":"references/strongly-typed-errors/bad-cancel-workflow-execution-attributes","title":"Bad Cancel Workflow Execution Attributes","description":"Explanation for Bad Cancel Workflow Execution Attributes error message, and how to fix it.","label":"Bad Cancel Workflow Execution Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThe [Workflow Task](/concepts/what-is-a-workflow-task) failed due to unset [CancelWorkflowExecution](/references/commands/#cancelworkflowexecution) attributes.\n\nReset any missing attributes and redeploy the Workflow Task.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-complete-workflow-execution-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-complete-workflow-execution-attributes.md","id":"references/strongly-typed-errors/bad-complete-workflow-execution-attributes","title":"Bad Complete Workflow Execution Attributes","description":"Explanation for Bad Complete Workflow Execution Attributes error message, and how to fix it.","label":"Bad Complete Workflow Execution Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed due to unset attributes on [CompleteWorkflowExecution](/references/commands/#completeworkflowexecution).\n\nReset any missing attributes.\nAdjust the size of your Payload if it exceeds size limits.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-continue-as-new-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-continue-as-new-attributes.md","id":"references/strongly-typed-errors/bad-continue-as-new-attributes","title":"Bad Continue as New Attributes","description":"Explanation for Bad Continue as New Attributes error message, and how to fix it.","label":"Bad Continue as New Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed to validate a [ContinueAsNew](/references/commands/#continueasnew) attribute.\nThe attribute could be unset or invalid.\n\nReset any missing attributes.\nIf the payload or memo exceeded size limits, adjust the input size.\n\nCheck that the [Workflow](/workflows) is validating search attributes after unaliasing keys.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-fail-workflow-execution-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-fail-workflow-execution-attributes.md","id":"references/strongly-typed-errors/bad-fail-workflow-execution-attributes","title":"Bad Fail Workflow Execution Attributes","description":"Explanation for Bad Fail Workflow Execution Attributes error message, and how to fix it.","label":"Bad Fail Workflow Execution Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed due to unset [FailWorkflowExecution](/references/commands/#failworkflowexecution) attributes.\n\nIf you encounter this error, make sure that `StartToClostTimeout` or `ScheduleToCloseTimeout` are set.\nRestart the [Worker](/workers) that the [Workflow](/workflows) and [Activity](/activities) are registered to.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-modify-workflow-properties-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-modify-workflow-properties-attributes.md","id":"references/strongly-typed-errors/bad-modify-workflow-properties-attributes","title":"Bad Modify Workflow Properties Attributes","description":"Explanation for Bad Modify Workflow Properties Attributes error message, and how to fix it.","label":"Bad Modify Workflow Properties Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed to validate attributes on a property in the Upsert Memo or in a payload.\nThese attributes are either unset or exceeding size limits.\n\nReset any unset and empty atrributes.\nAdjust the size of the [Memo](/workflows/#memo) or payload to fit within the system's limits.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-record-marker-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-record-marker-attributes.md","id":"references/strongly-typed-errors/bad-record-marker-attributes","title":"Bad Record Marker Attributes","description":"Explanation for Bad Record Marker Attributes error message, and how to fix it.","label":"Bad Record Marker Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed due to an unset or incorrect [Marker](/references/events/#markerrecorded) name.\n\nEnter a valid Marker name and redeploy the Task.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-request-cancel-activity-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-request-cancel-activity-attributes.md","id":"references/strongly-typed-errors/bad-request-cancel-activity-attributes","title":"Bad Request Cancel Activity Attributes","description":"Explanation for Bad Request Cancel Activity Attributes error message, and how to fix it.","label":"Bad Request Cancel Activity Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error either indicates the possibility of unset attributes for [RequestCancelActivity](/references/commands/#requestcancelactivity), or an invalid History Builder state.\n\nUpdate the [Temporal SDK](/temporal/#temporal-sdk) to the most recent release.\nReset any unset attributes before retrying the [Workflow Task](/concepts/what-is-a-workflow-task).\n\nIf you continue to see this error, review your code for [nondeterministic causes](/workflows/#code-changes-can-cause-non-deterministic-behavior).\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-request-cancel-external-wf-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-request-cancel-external-wf-attributes.md","id":"references/strongly-typed-errors/bad-request-cancel-external-wf-attributes","title":"Bad Request Cancel External Workflow Execution Attributes","description":"Explanation for Bad Request Cancel External Workflow Execution error message, and how to fix it.","label":"Bad Request Cancel External Workflow Execution","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed while trying to cancel an [external Workflow](/workflows/#external-workflows).\nUnset or invalid attributes can cause this to occur.\n\nReset any missing attributes, such as Workflow Id or Run Id.\nAdjust any fields that exceed length limits.\n\nIf a [Child Workflow](/workflows/#child-workflows) is set to `Start` and `RequestCancel`, remove one of these attributes.\nA Child Workflow cannot perform both actions in the same Workflow Task.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-schedule-activity-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-schedule-activity-attributes.md","id":"references/strongly-typed-errors/bad-schedule-activity-attributes","title":"Bad Schedule Activity Attributes","description":"Explanation for Bad Schedule Activity Attributes error message, and how to fix it.","label":"Bad Schedule Activity Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates unset or invalid attributes for [`ScheduleActivityTask`](/references/commands/#scheduleactivitytask) or [`CompleteWorkflowExecution`](/references/commands/#completeworkflowexecution).\n\nReset any unset or empty attributes.\nAdjust the size of the received payload to stay within the given size limit.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-search-attributes.md","id":"references/strongly-typed-errors/bad-search-attributes","title":"Bad Search Attributes","description":"Explanation for Bad Search Attributes error message, and how to fix it.","label":"Bad Search Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) has unset or invalid [Search Attributes](/concepts/what-is-a-search-attribute).\nThis can cause Workflow Tasks to continue to retry without success.\n\nMake sure that all attributes are defined before retrying the Task.\nAdjust the size of the Payload to fit within the system's size limits.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-signal-input-size.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-signal-input-size.md","id":"references/strongly-typed-errors/bad-signal-input-size","title":"Bad Signal Input Size","description":"Explanation for Bad Signal Input Size error message, and how to fix it.","label":"Bad Signal Input Size","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the Payload has exceeded the [Signal's](/concepts/what-is-a-signal) available input size.\n\nAdjust the size of the Payload, and redeploy the [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-signal-workflow-execution-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-signal-workflow-execution-attributes.md","id":"references/strongly-typed-errors/bad-signal-workflow-execution-attributes","title":"Bad Signal Workflow Execution Attributes","description":"Explanation for Bad Signal Workflow Execution Attributes error message, and how to fix it.","label":"Bad Signal Workflow Execution Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed to validate attributes for [SignalExternalWorkflowExecution](/references/commands/#signalexternalworkflowexecution).\n\nReset any unset, missing, nil, or invalid attributes.\nAdjust the input to fit within the system's size limits.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-start-child-execution-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-start-child-execution-attributes.md","id":"references/strongly-typed-errors/bad-start-child-execution-attributes","title":"Bad Start Child Execution Attributes","description":"Explanation for Bad Start Child Execution Attributes error message, and how to fix it.","label":"Bad Start Child Execution Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed to validate attributes for [`StartChildWorkflowExecution`](/references/commands/#startchildworkflowexecution)\n\nAdjust the input size of the attributes to fall within the system's size limits.\n\nMake sure that [Search Attribute](/concepts/what-is-a-search-attribute) validation is performed after unaliasing keys.\n","is_empty":false},{"file_name":"strongly-typed-errors/bad-start-timer-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/bad-start-timer-attributes.md","id":"references/strongly-typed-errors/bad-start-timer-attributes","title":"Bad Start Timer Attributes","description":"Explanation for Bad Start Timer Attributes error message, and how to fix it.","label":"Bad Start Timer Attributes","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the scheduled [Event](/concepts/what-is-an-event) is missing a Timer Id.\n\n<!-- TODO add Timer Id as anchor for term and link to it -->\n\nSet a valid Timer Id and retry the [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"strongly-typed-errors/cause-bad-binary.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/cause-bad-binary.md","id":"references/strongly-typed-errors/cause-bad-binary","title":"Cause Bad Binary","description":"Explanation for Cause Bad Binary error message, and how to fix it.","label":"Cause Bad Binary","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Worker](/workers) deployment returned a bad binary checksum.\n\n<!-- TODO: get more information about binary -->\n","is_empty":false},{"file_name":"strongly-typed-errors/cause-bad-update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/cause-bad-update.md","id":"references/strongly-typed-errors/cause-bad-update","title":"Cause Bad Update","description":"Explanation for Cause Bad Update error message.","label":"Cause Bad Update","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\n<!--TODO: add link to Workflow Update page when written -->\n\nThis error indicates that a [Workflow Execution](/concepts/what-is-a-workflow-execution) tried to complete before receiving an Update.\n\n`BadUpdate` can happen when a [Worker](/concepts/what-is-a-worker) generates a [Workflow Task Completed](/references/events#WorkflowTaskCompleted) message with missing fields or an invalid Update response format.\n\nThis error might indicate usage of an unsupported SDK.\nMake sure you're using a [supported SDK](/temporal#temporal-sdk).\n","is_empty":false},{"file_name":"strongly-typed-errors/cause-reset-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/cause-reset-workflow.md","id":"references/strongly-typed-errors/cause-reset-workflow","title":"Cause Reset Workflow","description":"Explanation for Cause Reset Workflow error message, and how to fix it.","label":"Cause Reset Workflow","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed due to a request to reset the [Workflow](/workflows).\n\nIf the system hasn't started a new Workflow, manually reset the Workflow.\n","is_empty":false},{"file_name":"strongly-typed-errors/cause-unhandled-update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/cause-unhandled-update.md","id":"references/strongly-typed-errors/cause-unhandled-update","title":"Cause Unhandled Update","description":"Explanation for Cause Unhandled Update error message.","label":"Cause Unhandled Update","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\n`UnhandledUpdate` occurs when a Workflow Update is received by the Temporal Server while a Workflow Task being processed on a Worker produces a Command that would cause the Workflow to transition to a closed state.\n\nTemporal rejects the Workflow Task completion to guarantee that the Update is eventually handled by Workflow code and rewinds the Workflow so it can handle the pending Update.\n\nThis error can happen when the Workflow receives frequent Updates.\n","is_empty":false},{"file_name":"strongly-typed-errors/cause-unspecified.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/cause-unspecified.md","id":"references/strongly-typed-errors/cause-unspecified","title":"Cause Unspecified","description":"Explanation for Cause Unspecified error message, and how to fix it.","label":"Cause Unspecified","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) has failed for an unknown reason.\n\nIf you see this error, examine your Workflow Definition.\n","is_empty":false},{"file_name":"strongly-typed-errors/failover-close-command.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/failover-close-command.md","id":"references/strongly-typed-errors/failover-close-command","title":"Failover Close Command","description":"Explanation for Failover Close Command error message, and how to fix it.","label":"Failover Close Command","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that a [Namespace](/namespaces) failover forced the [Workflow Task](/concepts/what-is-a-workflow-task) to close.\nThe system automatically schedules a retry when this error occurs.\n\n<!--TODO: troubleshooting -->\n","is_empty":false},{"file_name":"strongly-typed-errors/force-close-command.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/force-close-command.md","id":"references/strongly-typed-errors/force-close-command","title":"Force Close Command","description":"Explanation for Force Close Command error message, and how to fix it.","label":"Force Close Command","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) was forced to close.\nA retry will be scheduled if the error is recoverable.\n\n<!-- TODO: more info-->\n","is_empty":false},{"file_name":"strongly-typed-errors/intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/intro.md","id":"references/strongly-typed-errors/intro","ssdi":[],"markdown_content":"\nThis reference lists possible [Workflow Task](/concepts/what-is-a-workflow-task) errors and how to resolve them.\n\n> For other types of errors, see [Temporal Failures](https://docs.temporal.io/kb/failures).\n\nEach of the below errors corresponds with a [WorkflowTaskFailedCause](https://api-docs.temporal.io/#temporal.api.enums.v1.WorkflowTaskFailedCause), which appears in [Events](/workflows#event) under `workflow_task_failed_event_attributes`.\n","is_empty":false},{"file_name":"strongly-typed-errors/non-deterministic-error.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/non-deterministic-error.md","id":"references/strongly-typed-errors/non-deterministic-error","title":"Non-Deterministic Error","description":"Explanation for Non-Deterministic Error message, and how to fix it.","label":"Non-Deterministic Error","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThe [Workflow Task](/concepts/what-is-a-workflow-task) failed due to a [nondeterministic error](/workflows/#code-changes-can-cause-non-deterministic-behavior).\n\n<!-- TODO: info -->\n","is_empty":false},{"file_name":"strongly-typed-errors/pending-activities-limit-exceeded.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/pending-activities-limit-exceeded.md","id":"references/strongly-typed-errors/pending-activities-limit-exceeded","title":"Pending Activities Limit Exceeded","description":"Explanation for Pending Activities Limit Exceeded error message, and how to fix it.","label":"Pending Activities Limit Exceeded","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThe [Workflow](/workflows) has reached capacity for pending [Activities](/activities).\nTherefore, the [Workflow Task](/concepts/what-is-a-workflow-task) was failed to prevent the creation of another Activity.\n\nLet the Workflow complete any current Activities before redeploying the code.\n","is_empty":false},{"file_name":"strongly-typed-errors/pending-child-workflows-limit-exceeded.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/pending-child-workflows-limit-exceeded.md","id":"references/strongly-typed-errors/pending-child-workflows-limit-exceeded","title":"Pending Child Workflows Limit Exceeded","description":"Explanation for Pending Child Workflows Limit Exceeded error message, and how to fix it.","label":"Pending Child Workflows Limit Exceeded","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow](/workflows) has reached capacity for pending [Child Workflows](/workflows/#child-workflows).\nTherefore, the [Workflow Task](/concepts/what-is-a-workflow-task)was failed to prevent additional Child Workflows from being added.\n\nWait for the system to finish any currently running Child Workflows before redeploying this Task.\n","is_empty":false},{"file_name":"strongly-typed-errors/pending-request-cancel-limit-exceeded.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/pending-request-cancel-limit-exceeded.md","id":"references/strongly-typed-errors/pending-request-cancel-limit-exceeded","title":"Pending Request Cancel Limit Exceeded","description":"Explanation for Pending Request Cancel Limit Exceeded error message, and how to fix it.","label":"Pending Request Cancel Limit Exceeded","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) failed after attempting to add more cancel requests.\nThe [Workflow](/workflows) has reached capacity for pending requests to cancel other Workflows, and cannot accept more requests.\n\nIf you see this error, give the system time to process pending requests before retrying the Task.\n","is_empty":false},{"file_name":"strongly-typed-errors/pending-signals-limit-exceeded.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/pending-signals-limit-exceeded.md","id":"references/strongly-typed-errors/pending-signals-limit-exceeded","title":"Pending Signals Limit Exceeded","description":"Explanation for Pending Signals Limit Exceeded error message, and how to fix it.","label":"Pending Signals Limit Exceeded","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThe Workflow has reached capacity for pending Signals.\nTherefore, the [Workflow Task](/concepts/what-is-a-workflow-task) was failed after attempting to add more [Signals](/concepts/what-is-a-signal) to an external Workflow.\n\nWait for Signals to be processed by the Workflow before retrying the Task.\n","is_empty":false},{"file_name":"strongly-typed-errors/reset-sticky-task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/reset-sticky-task-queue.md","id":"references/strongly-typed-errors/reset-sticky-task-queue","title":"Reset Sticky Task Queue","description":"Explanation for Reset Sticky Task Queue error message, and how to fix it.","label":"Reset Sticky Task Queue","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the Sticky [Task Queue](/concepts/what-is-a-task-queue)needs to be reset.\n\nIf you see this error, reset the Sticky Task Queue.\nThe system will retry automatically.\n","is_empty":false},{"file_name":"strongly-typed-errors/resource-exhausted-cause-concurrent-limit.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/resource-exhausted-cause-concurrent-limit.md","id":"references/strongly-typed-errors/resource-exhausted-cause-concurrent-limit","title":"Resource Exhausted Cause Concurrent Limit","description":"Explanation for Resource Exhausted Cause Concurrent Limit error message, and how to fix it.","label":"Resource Exhausted Cause Concurrent Limit","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the concurrent [poller count](/dev-guide/worker-performance/#poller-count) has been exhausted.\n\n<!--TODO: more info needed -->\n\nAdjust the poller count per [Worker](/workers).\n","is_empty":false},{"file_name":"strongly-typed-errors/resource-exhausted-cause-persistence-limit.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/resource-exhausted-cause-persistence-limit.md","id":"references/strongly-typed-errors/resource-exhausted-cause-persistence-limit","title":"Resource Exhausted Cause Persistence Limit","description":"Explanation for Resource Exhausted Cause Persistence Limit error message, and how to fix it.","label":"Resource Exhausted Cause Persistence Limit","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the persistence rate limit has been reached.\n\n<!--TODO: more info needed -->\n","is_empty":false},{"file_name":"strongly-typed-errors/resource-exhausted-cause-rps-limit.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/resource-exhausted-cause-rps-limit.md","id":"references/strongly-typed-errors/resource-exhausted-cause-rps-limit","title":"Resource Exhausted Cause RPS Limit","description":"Explanation for Resource Exhausted Cause RPS Limit error message, and how to fix it.","label":"Resource Exhausted Cause RPS Limit","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow](/workflows) has exhausted its RPS limit.\n\n<!--TODO: more info needed -->\n","is_empty":false},{"file_name":"strongly-typed-errors/resource-exhausted-cause-system-overload.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/resource-exhausted-cause-system-overload.md","id":"references/strongly-typed-errors/resource-exhausted-cause-system-overload","title":"Resource Exhausted Cause System Overload","description":"Explanation for Resource Exhausted Cause System Overload error message, and how to fix it.","label":"Resource Exhausted Cause System Overload","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the system is overloaded and cannot allocate further resources to [Workflow Tasks](/concepts/what-is-a-workflow-task).\n\n<!--TODO: more info needed -->\n","is_empty":false},{"file_name":"strongly-typed-errors/resource-exhausted-cause-unspecified.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/resource-exhausted-cause-unspecified.md","id":"references/strongly-typed-errors/resource-exhausted-cause-unspecified","title":"Resource Exhausted Cause Unspecified","description":"Explanation for Resource Exhausted Cause Unspecified error message, and how to fix it.","label":"Resource Exhausted Cause Unspecified","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that an unknown cause is preventing resources from being allocated to further [Workflow Tasks](/concepts/what-is-a-workflow-task).\n\n<!--TODO: more info needed -->\n","is_empty":false},{"file_name":"strongly-typed-errors/schedule-activity-duplicate-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/schedule-activity-duplicate-id.md","id":"references/strongly-typed-errors/schedule-activity-duplicate-id","title":"Schedule Activity Duplicate Id","description":"Explanation for Schedule Activity Duplicate Id error message, and how to fix it.","label":"Schedule Activity Duplicate Id","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThe [Workflow Task](/concepts/what-is-a-workflow-task) failed because the [Activity](/activities) Id is already in use.\n\nCheck your code to see if you've already specified the same Activity Id in your [Workflow](/workflows).\nEnter another Activity Id, and try running the Workflow Task again.\n","is_empty":false},{"file_name":"strongly-typed-errors/start-timer-duplicate-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/start-timer-duplicate-id.md","id":"references/strongly-typed-errors/start-timer-duplicate-id","title":"Start Timer Duplicate Id","description":"Explanation for Start Timer Duplicate Id error message, and how to fix it.","label":"Start Timer Duplicate Id","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that a Timer with the given Timer Id has already started.\n\n<!-- TODO link to Timer term when exists -->\n\nTry entering a different Timer Id, and retry the [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"strongly-typed-errors/unhandled-command.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/unhandled-command.md","id":"references/strongly-typed-errors/unhandled-command","title":"Unhandled Command","description":"Explanation for unhandled command failure, and steps to fix it.","label":"Unhandled Command","tags":["error"],"ssdi":[],"markdown_content":"\nThis error indicates new available [Events](/references/events) since the last [Workflow Task](/concepts/what-is-a-workflow-task) started.\nThe Workflow Task was failed because the [Workflow](/concepts/what-is-a-workflow) attempted to close itself without handling the new Events.\n\n`UnhandledCommand` can happen when the Workflow is receiving a high number of [Signals](/concepts/what-is-a-signal).\nIf the Workflow doesn't have enough time to handle these Signals, a RetryWorkflow Task is scheduled to handle these new Events.\n\nTo prevent this error, drain the Signal Channel with the ReceiveAsync function.\n\nIf you continue to see this error, check your logs for failing Workflow Tasks.\nThe Workflow may have been picked up by a different [Worker](/concepts/what-is-a-worker).\n","is_empty":false},{"file_name":"strongly-typed-errors/workflow-worker-unhandled-failure.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/references/strongly-typed-errors/workflow-worker-unhandled-failure.md","id":"references/strongly-typed-errors/workflow-worker-unhandled-failure","title":"Workflow Worker Unhandled Failure","description":"Explanation for Workflow Worker Unhandled Failure error message, and how to fix it.","label":"Workflow Worker Unhandled Failure","tags":["errors","strongly-typed"],"ssdi":[],"markdown_content":"\nThis error indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) encountered an unhandled failure from the [Workflow Definition](/workflows/#workflow-definition).\n\n<!--TODO: more info needed -->\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/environment-variables.md","id":"tctl-v1/environment-variables","title":"Environment variables for tctl","description":"What are the environment variables for tctl?","label":"Environment variables","tags":["tctl"],"ssdi":[],"markdown_content":"\nSetting environment variables for repeated parameters can shorten tctl commands.\n\n### TEMPORAL_CLI_ADDRESS\n\nSpecify a host and port for the Frontend Service.\nThe default is `127.0.0.1:7233`.\n\n### TEMPORAL_CLI_AUTHORIZATION_TOKEN\n\nSpecify a token to be used by the HTTP Basic Authorization plugin.\n\n<!-- TODO: Add link to \"Securing tctl\" page or its equivalent when it exists. -->\n\n### TEMPORAL_CLI_AUTH\n\nSpecify the authorization header to be set for a gRPC request.\n\n### TEMPORAL_CLI_NAMESPACE\n\nSpecify a Namespace.\nBy setting this variable, you don't need to specify a `--namespace` modifier in a tctl command.\nThe default Namespace is `default`.\n\n### TEMPORAL_CLI_PLUGIN_DATA_CONVERTER\n\nSpecify the name of the executable for a custom Data Converter plugin.\n\n### TEMPORAL_CLI_PLUGIN_HEADERS_PROVIDER\n\nSpecify the name of the executable for a headers provider plugin.\n\n### TEMPORAL_CLI_TLS_CA\n\nSpecify the path to a server Certificate Authority (CA) certificate file.\n\n### TEMPORAL_CLI_TLS_CERT\n\nSpecify the path to a public X.509 certificate file for mutual TLS authentication.\n\n### TEMPORAL_CLI_TLS_DISABLE_HOST_VERIFICATION\n\nSet to disable verification of the server certificate (and thus host verification).\n\n### TEMPORAL_CLI_TLS_KEY\n\nSpecify the path to a private key file for mutual TLS authentication.\nIf you set this variable, you must also set the `TEMPORAL_CLI_TLS_CERT` variable.\n\n### TEMPORAL_CLI_TLS_SERVER_NAME\n\nSpecify an override for the name of the target server that is used for TLS host verification.\nThe name must be one of the DNS names listed in the server TLS certificate.\nSetting this variable also enables host verification.\n\n### TEMPORAL_CONTEXT_TIMEOUT\n\nSpecify a timeout for the context of an RPC call in seconds.\nThe default value is 5.\n","is_empty":false},{"file_name":"global-modifiers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/global-modifiers.md","id":"tctl-v1/global-modifiers","title":"tctl v1.17 global modifiers","description":"Global modifiers are provided before command modifiers.","label":"Global modifiers","tags":["operation-guide","tctl"],"ssdi":[],"markdown_content":"\nYou can supply the values for many of these modifiers by setting [environment variables](/tctl-v1/environment-variables) instead of including the modifiers in a tctl command.\n\n### --address\n\nSpecify a host and port for the Frontend Service.\nThe default is `127.0.0.1:7233`.\n\n### --auto_confirm\n\nAutomatically confirm all prompts.\n\n### --context_timeout\n\nSpecify a timeout for the context of an RPC call in seconds.\nThe default value is 5.\n\n### --data_converter_plugin\n\nSpecify the name of the executable for a custom Data Converter plugin.\n\n### --headers_provider_plugin\n\nSpecify the name of the executable for a headers provider plugin.\n\n### --help\n\nDisplay help for tctl in the CLI.\n\nAlias: `-h`\n\n### --namespace\n\nSpecify a Namespace.\nBy using this modifier, you don't need to specify a `--namespace` modifier for a sub-command.\nThe default Namespace is `default`.\n\nAlias: `--n`\n\n### --tls_ca_path\n\nSpecify the path to a server Certificate Authority (CA) certificate file.\n\n### --tls_cert_path\n\nSpecify the path to a public X.509 certificate file for mutual TLS authentication.\nIf you use this modifier, you must also use the `--tls_key_path` modifier.\n\n### --tls_disable_host_verification\n\nDisable verification of the server certificate (and thus host verification).\n\n### --tls_key_path\n\nSpecify the path to a private key file for mutual TLS authentication.\nIf you use this modifier, you must also use the `--tls_cert_path` modifier.\n\n### --tls_server_name\n\nSpecify an override for the name of the target server that is used for TLS host verification.\nThe name must be one of the DNS names listed in the server TLS certificate.\nSpecifying this modifier also enables host verification.\n\n### --version\n\nDisplay the version of tctl in the CLI.\n\n### --codec_endpoint\n\nThe URL and port number for a Codec Server.\n","is_empty":false},{"file_name":"how-to-install-tctl.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/how-to-install-tctl.md","id":"tctl-v1/how-to-install-tctl","title":"How to install tctl","description":"You can install tctl in four ways, described in this topic.","label":"Install","tags":["operation-guide","tctl"],"ssdi":[],"markdown_content":"\n> The Temporal tctl documentation covers version 1.17 of the Temporal CLI.\n\nYou can install [tctl](/tctl-v1) in the following ways.\n\n- Install locally by using [Homebrew](https://brew.sh/): `brew install tctl`\n- Run locally together with Temporal Server in [Docker Compose](https://github.com/temporalio/docker-compose): `docker exec temporal-admin-tools tctl YOUR COMMANDS HERE`\n  - To invoke [tctl](/tctl-v1) as though it is installed locally (such as `tctl namespace describe`), set an alias: `alias tctl=\"docker exec temporal-admin-tools tctl\"`\n- Run the [temporal-admin-tools](https://hub.docker.com/r/temporalio/admin-tools) Docker image:\n  - On Linux: `docker run --rm -it --entrypoint tctl --network host --env TEMPORAL_CLI_ADDRESS=localhost:7233 temporalio/admin-tools:1.14.0`\n  - On macOS or Windows: `docker run --rm -it --entrypoint tctl --env TEMPORAL_CLI_ADDRESS=host.docker.internal:7233 temporalio/admin-tools:1.14.0`\n  - If your Temporal Server is running on a remote host, change the value of `TEMPORAL_CLI_ADDRESS`.\n  - To simplify command lines, create a `tctl` alias.\n- Build it locally:\n  1. Clone the [Temporal Server repo](https://github.com/temporalio/temporal).\n  1. Run `make tctl`.\n  1. Copy the `tctl` executable to any directory that appears in the `PATH` environment variable; for example, `/usr/bin/`.\n- Install the latest version of the tctl in your `GOPATH`: `go install github.com/temporalio/tctl/cmd/tctl@latest`\n\n**Note:** To use [tctl](/tctl-v1), you must have a Temporal Server running.\n\nTo see help for [tctl](/tctl-v1) commands, enter the following commands.\n\n| Command             | Description                                                              |\n| ------------------- | ------------------------------------------------------------------------ |\n| `tctl -h`           | Display help for top-level commands and global options                   |\n| `tctl namespace -h` | Display help for [Namespace](/concepts/what-is-a-namespace) operations   |\n| `tctl workflow -h`  | Display help for [Workflow](/concepts/what-is-a-workflow) operations     |\n| `tctl taskqueue -h` | Display help for [Task Queue](/concepts/what-is-a-task-queue) operations |\n","is_empty":false},{"file_name":"workflow/cancel.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/cancel.md","id":"tctl-v1/workflow/cancel","title":"tctl workflow cancel","description":"How to cancel a Workflow Execution using tctl.","label":"cancel","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow cancel --query` command cancels a [Workflow Execution](/workflows#workflow-execution).\n\nCanceling a running Workflow Execution records a `WorkflowExecutionCancelRequested` event in the History.\nA new [Workflow Task](/concepts/what-is-a-workflow-task) will be scheduled.\nAfter cancellation, the Workflow Execution can perform cleanup work.\n\nSee also [`tctl workflow terminate --query`](/tctl-v1/workflow/terminate).\n\n`tctl workflow cancel --query <query> <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow cancel --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow cancel --run_id <id>\n```\n","is_empty":false},{"file_name":"workflow/count.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/count.md","id":"tctl-v1/workflow/count","title":"tctl workflow count","description":"How to count Workflow Executions using tctl.","label":"count","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow count` command counts [Workflow Executions](/workflows#workflow-execution).\nThis command requires Elasticsearch to be enabled.\n\n`tctl workflow count <modifiers>`\n\nThe following modifier controls the behavior of the command.\n\n### --query\n\n_Required modifier_\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute).\n\nAlias: `-q`\n\n**Example**\n\nTo count all open [Workflow Executions](/workflows#workflow-execution):\n\n```bash\ntctl workflow count --query 'ExecutionStatus=\"Running\"'\n```\n","is_empty":false},{"file_name":"workflow/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/describe.md","id":"tctl-v1/workflow/describe","title":"tctl workflow describe","description":"How to show information about a Workflow Execution using tctl.","label":"describe","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow describe` command shows information about a [Workflow Execution](/workflows#workflow-execution).\nThis information can be used to locate a failed Workflow Execution, for example.\n\nTo find a Workflow with a given Run Id, refer to [`tctl workflow describeid`](/tctl-v1/workflow/describeid).\n\n`tctl workflow describe <modifiers>`\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n### --workflow_id\n\n**This is a required modifier.**\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow describe --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\nIf a Run Id is not provided, the command will show the latest Workflow Execution of that Workflow Id.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow describe --run_id <id>\n```\n\n### --print_raw\n\nPrint properties exactly as they are stored.\n\n**Example**\n\n```bash\ntctl workflow describe --print_raw\n```\n\n### --reset_points_only\n\nShow only events that are eligible for reset.\nIf successful, the command returns the Run Id of all deployments, and the times at which the Events were created.\n\n**Example**\n\n```bash\ntctl workflow describe --reset_points_only\n```\n","is_empty":false},{"file_name":"workflow/describeid.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/describeid.md","id":"tctl-v1/workflow/describeid","title":"tctl workflow describeid","description":"How to show information about a Workflow Execution for a specified Workflow Id and optional Run Id using tctl.","label":"describeid","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow describeid` command shows information about a [Workflow Execution](/workflows#workflow-execution) for the specified [Workflow Id](/concepts/what-is-a-workflow-id) and optional [Run Id](/concepts/what-is-a-run-id).\n\n`tctl workflow describeid <workflow_id> <run_id> <modifiers>`\n\nThis command is a shortcut for `tctl workflow describe --workflow_id <workflowid> --run_id <runid>`.\n\nThe following modifiers control the behavior of the command.\n\n### --print_raw\n\nPrint properties exactly as they are stored.\n\n**Example**\n\n```bash\ntctl workflow describeid <workflow_id> <id> --print_raw\n```\n\n### --reset_points_only\n\nShow only events that are eligible for reset.\n\n**Example**\n\n```bash\ntctl workflow describeid <workflow_id> --reset_points_only\n```\n","is_empty":false},{"file_name":"workflow/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/index.md","id":"tctl-v1/workflow/index","title":"tctl workflow","description":"How to operate Workflow Executions using tctl.","label":"workflow","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow` commands enable [Workflow Execution](/workflows#workflow-execution) operations.\n\n- [tctl workflow cancel](/tctl-v1/workflow/cancel)\n- [tctl workflow count](/tctl-v1/workflow/count)\n- [tctl workflow describe](/tctl-v1/workflow/describe)\n- [tctl workflow describeid](/tctl-v1/workflow/describeid)\n- [tctl workflow list](/tctl-v1/workflow/list)\n- [tctl workflow listall](/tctl-v1/workflow/listall)\n- [tctl workflow listarchived](/tctl-v1/workflow/listarchived)\n- [tctl workflow observe](/tctl-v1/workflow/observe)\n- [tctl workflow observeid](/tctl-v1/workflow/observeid)\n- [tctl workflow query](/tctl-v1/workflow/query)\n- [tctl workflow reset](/tctl-v1/workflow/reset)\n- [tctl workflow reset-batch](/tctl-v1/workflow/reset-batch)\n- [tctl workflow run](/tctl-v1/workflow/run)\n- [tctl workflow scan](/tctl-v1/workflow/scan)\n- [tctl workflow show](/tctl-v1/workflow/show)\n- [tctl workflow showid](/tctl-v1/workflow/showid)\n- [tctl workflow signal](/tctl-v1/workflow/signal)\n- [tctl workflow stack](/tctl-v1/workflow/stack)\n- [tctl workflow start](/tctl-v1/workflow/start)\n- [tctl workflow terminate](/tctl-v1/workflow/terminate)\n","is_empty":false},{"file_name":"workflow/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/list.md","id":"tctl-v1/workflow/list","title":"tctl workflow list","description":"How to list open or closed Workflow Executions using tctl.","label":"list","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow list` command lists open or closed [Workflow Executions](/workflows#workflow-execution).\n\nBy default, this command lists a maximum of 10 closed Workflow Executions.\n\n- To set the size of a page, use the `--pagesize` option.\n- To list multiple pages, use the `--more` option.\n- To list open Workflow Executions, use the `--open` option.\n\nSee also [`tctl workflow listall`](/tctl-v1/workflow/listall), [`tctl workflow listarchived`](/tctl-v1/workflow/listarchived), and [`tctl workflow scan`](/tctl-v1/workflow/scan).\n\n`tctl workflow list <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow list --print_raw_time\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow list --print_datetime\n```\n\n### --print_memo\n\nPrint a memo.\n\n**Example**\n\n```bash\ntctl workflow list --print_memo\n```\n\n### --print_search_attr\n\nPrint the [Search Attributes](/concepts/what-is-a-search-attribute).\n\n**Example**\n\n```bash\ntctl workflow list --print_search_attr\n```\n\n### --print_full\n\nPrint the full message without table formatting.\n\n**Example**\n\n```bash\ntctl workflow list --print_full\n```\n\n### --print_json\n\nPrint the raw JSON objects.\n\n**Example**\n\n```bash\ntctl workflow list --print_json\n```\n\n### --open\n\nList open [Workflow Executions](/workflows#workflow-execution).\n(By default, the `tctl workflow list` command lists closed Workflow Executions.)\n\n**Example**\n\n```bash\ntctl workflow list --open\n```\n\n### --earliest_time\n\nSpecify the earliest start time to list.\nSupported format are as follows:\n\n- `<year>-<month>-<day>T<hour>:<minute>:<second><+|-><offsethours>:<offsetminutes>`\n- Raw Unix Epoch time (the number of milliseconds since 0000 UTC on January 1, 1970).\n- `<n><duration`, where `<n>` is a value between 0 and 1000000, and `<duration>` is one of the following:\n  - `second` or `s`\n  - `minute` or `m`\n  - `hour` or `h`\n  - `day` or `d`\n  - `week` or `w`\n  - `month` or `M`\n  - `year` or `y`\n\n**Examples**\n\nTo specify 3:04:05 PM India Standard Time on January 2, 2022:\n\n```bash\ntctl workflow list --earliest-time '2022-01-02T15:04:05+05:30'\n```\n\nTo specify 15 minutes before the current time:\n\n```bash\ntctl workflow list --earliest-time '15minute'\n```\n\n### --latest_time\n\nSpecify the latest start time to list.\nSupported formats are as follows:\n\n- `<year>-<month>-<day>T<hour>:<minute>:<second><+|-><offsethours>:<offsetminutes>`\n- Raw Unix Epoch time (the number of milliseconds since 0000 UTC on January 1, 1970).\n- `<n><duration`, where `<n>` is a value between 0 and 1000000, and `<duration>` is one of the following:\n  - `second` or `s`\n  - `minute` or `m`\n  - `hour` or `h`\n  - `day` or `d`\n  - `week` or `w`\n  - `month` or `M`\n  - `year` or `y`\n\n**Examples**\n\nTo specify 11:02:17 PM Pacific Daylight Time on April 13, 2022:\n\n```bash\ntctl workflow list --latest_time '2022-04-13T23:02:17-07:00'\n```\n\nTo specify 10s before the current time:\n\n```bash\ntctl workflow list --latest_time '10second'\n```\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow list --workflow_id <id>\n```\n\n### --workflow_type\n\nSpecify the name of a [Workflow Type](/concepts/what-is-a-workflow-type).\n\n**Example**\n\n```bash\ntctl workflow list --workflow_type <name>\n```\n\n### --status\n\nSpecify the status of a [Workflow Execution](/workflows#workflow-execution).\nSupported values are as follows:\n\n- `completed`\n- `failed`\n- `canceled`\n- `terminated`\n- `continuedasnew`\n- `timedout`\n\n**Example**\n\n```bash\ntctl workflow list --status <value>\n```\n\n### --query\n\n**How to list and filter Workflow Executions with a [List Filter](/concepts/what-is-a-list-filter) using tctl.**\n\nThe `--query` flag is supported only when [Advanced Visibility](/concepts/what-is-advanced-visibility) is configured with the Cluster.\n\nUsing the `--query` option causes tctl to ignore all other filter options, including `open`, `earliest_time`, `latest_time`, `workflow_id`, and `workflow_type`.\n\nAlias: `-q`\n\n**Example**\n\n```bashbash\ntctl workflow list --query \"WorkflowId=<your-workflow-id>\"\n```\n\nMore examples:\n\n```bashbash\ntctl workflow list \\\n  --query \"WorkflowType='main.SampleParentWorkflow' AND ExecutionStatus='Running'\"\n```\n\n```bashbash\ntctl workflow list \\\n  --query '(CustomKeywordField = \"keyword1\" and CustomIntField >= 5) or CustomKeywordField = \"keyword2\"' \\\n  --print_search_attr\n```\n\n```bashbash\ntctl workflow list \\\n  --query 'CustomKeywordField in (\"keyword2\", \"keyword1\") and CustomIntField >= 5 and CloseTime between \"2018-06-07T16:16:36-08:00\" and \"2019-06-07T16:46:34-08:00\" order by CustomDatetimeField desc' \\\n  --print_search_attr\n```\n\n```bashbash\ntctl workflow list \\\n  --query 'WorkflowType = \"main.Workflow\" and (WorkflowId = \"1645a588-4772-4dab-b276-5f9db108b3a8\" or RunId = \"be66519b-5f09-40cd-b2e8-20e4106244dc\")'\n```\n\n```bashbash\ntctl workflow list \\\n  --query 'WorkflowType = \"main.Workflow\" StartTime > \"2019-06-07T16:46:34-08:00\" and ExecutionStatus = \"Running\"'\n```\n\n### --more\n\nList more than one page.\n(By default, the `tctl workflow list` command lists one page of results.)\n\n**Example**\n\n```bash\ntctl workflow list --more\n```\n\n### --pagesize\n\nSpecify the maximum number of [Workflow Executions](/workflows#workflow-execution) to list on a page.\n(By default, the `tctl workflow list` command lists 10 Workflow Executions per page.)\n\n**Example**\n\n```bash\ntctl workflow list --pagesize <value>\n```\n","is_empty":false},{"file_name":"workflow/listall.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/listall.md","id":"tctl-v1/workflow/listall","title":"tctl workflow listall","description":"How to list all open or closed Workflow Executions using tctl.","label":"listall","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow listall` command lists all open or closed [Workflow Executions](/workflows#workflow-execution).\n\nBy default, this command lists all closed Workflow Executions.\nTo list open Workflow Executions, use the `--open` option.\n\nSee also [`tctl workflow list`](/tctl-v1/workflow/list), [`tctl workflow listarchived`](/tctl-v1/workflow/listarchived), and [`tctl workflow scan`](/tctl-v1/workflow/scan).\n\n`tctl workflow listall <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n###`--print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow listall --print_raw_time\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow listall --print_datetime\n```\n\n### --print_memo\n\nPrint a memo.\n\n**Example**\n\n```bash\ntctl workflow listall --print_memo\n```\n\n### --print_search_attr\n\nPrint the [Search Attributes](/concepts/what-is-a-search-attribute).\n\n**Example**\n\n```bash\ntctl workflow listall --print_search_attr\n```\n\n### `--print_full`\n\nPrint the full message without table formatting.\n\n**Example**\n\n```bash\ntctl workflow listall --print_full\n```\n\n### --print_json\n\nPrint the raw JSON objects.\n\n**Example**\n\n```bash\ntctl workflow listall --print_json\n```\n\n### --open\n\nList open [Workflow Executions](/workflows#workflow-execution).\n(By default, the `tctl workflow listall` command lists closed Workflow Executions.)\n\n**Example**\n\n```bash\ntctl workflow listall --open\n```\n\n### --earliest_time\n\nSpecify the earliest start time to list. Supported format are as follows:\n\n- `<year>-<month>-<day>T<hour>:<minute>:<second><+|-><offsethours>:<offsetminutes>`\n- Raw Unix Epoch time (the number of milliseconds since 0000 UTC on January 1, 1970).\n- `<n><duration`, where `<n>` is a value between 0 and 1000000, and `<duration>` is one of the following:\n  - `second` or `s`\n  - `minute` or `m`\n  - `hour` or `h`\n  - `day` or `d`\n  - `week` or `w`\n  - `month` or `M`\n  - `year` or `y`\n\n**Examples**\n\nTo specify 3:04:05 PM India Standard Time on January 2, 2022:\n\n```bash\ntctl workflow listall --earliest-time '2022-01-02T15:04:05+05:30'\n```\n\nTo specify 15 minutes before the current time:\n\n```bash\ntctl workflow listall --earliest-time '15minute'\n```\n\n### --latest_time\n\nSpecify the latest start time to list. Supported formats are as follows:\n\n- `<year>-<month>-<day>T<hour>:<minute>:<second><+|-><offsethours>:<offsetminutes>`\n- Raw Unix Epoch time (the number of milliseconds since 0000 UTC on January 1, 1970).\n- `<n><duration`, where `<n>` is a value between 0 and 1000000, and `<duration>` is one of the following:\n  - `second` or `s`\n  - `minute` or `m`\n  - `hour` or `h`\n  - `day` or `d`\n  - `week` or `w`\n  - `month` or `M`\n  - `year` or `y`\n\nAlias: `--lt`\n\n**Examples**\n\nTo specify 11:02:17 PM Pacific Daylight Time on April 13, 2022:\n\n```bash\ntctl workflow listall --latest-time '2022-04-13T23:02:17-07:00'\n```\n\nTo specify 10 seconds before the current time:\n\n```bash\ntctl workflow listall --latest-time '10second'\n```\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow listall --workflow_id <id>\n```\n\n### --workflow_type\n\nSpecify the name of a [Workflow Type](/concepts/what-is-a-workflow-type).\n\n**Example**\n\n```bash\ntctl workflow listall --workflow_type <name>\n```\n\n### --status\n\nSpecify the status of a [Workflow Execution](/workflows#workflow-execution).\nSupported values are as follows:\n\n- `completed`\n- `failed`\n- `canceled`\n- `terminated`\n- `continuedasnew`\n- `timedout`\n\n**Example**\n\n```bash\ntctl workflow listall --status <value>\n```\n\n### --query\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute).\n\nUsing the `--query` option causes tctl to ignore all other filter options, including `open`, `earliest_time`, `latest_time`, `workflow_id`, and `workflow_type`.\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl workflow listall --query <value>\n```\n","is_empty":false},{"file_name":"workflow/listarchived.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/listarchived.md","id":"tctl-v1/workflow/listarchived","title":"tctl workflow listarchived","description":"How to list archived Workflow Executions using tctl.","label":"listarchived","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow listarchived` command lists archived [Workflow Executions](/workflows#workflow-execution).\n\nBy default, this command lists a maximum of 100 Workflow Executions.\n\n- To set the size of a page, use the `--pagesize` option.\n- To list all pages, use the `--all` option.\n\nSee also [`tctl workflow list`](/tctl-v1/workflow/list), [`tctl workflow listall`](/tctl-v1/workflow/listall), and [`tctl workflow scan`](/tctl-v1/workflow/scan).\n\n`tctl workflow listarchived <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_raw_time\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_datetime\n```\n\n### --print_memo\n\nPrint a memo.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_memo\n```\n\n### --print_search_attr\n\nPrint the [Search Attributes](/concepts/what-is-a-search-attribute).\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_search_attr\n```\n\n### --print_full\n\nPrint the full message without table formatting.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_full\n```\n\n### --print_json\n\nPrint the raw JSON objects.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_json\n```\n\n### --query\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute).\n\nConsult the documentation of the visibility archiver that is used by your [Namespace](/concepts/what-is-a-namespace) for detailed instructions.\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl workflow listarchived --query <value>\n```\n\n### --pagesize\n\nSpecify the maximum number of [Workflow Executions](/workflows#workflow-execution) to list on a page.\n(By default, the `tctl workflow listarchived` command lists 100 Workflow Executions per page.)\n\n**Example**\n\n```bash\ntctl workflow listarchived --pagesize <value>\n```\n\n### --all\n\nList all pages.\n\n**Example**\n\n```bash\ntctl workflow listarchived --all\n```\n","is_empty":false},{"file_name":"workflow/observe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/observe.md","id":"tctl-v1/workflow/observe","title":"tctl workflow observe","description":"How to show the progress of the Event History of a Workflow Execution using tctl.","label":"observe","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow observe` command shows the progress of the [Event History](/concepts/what-is-an-event-history) of a [Workflow Execution](/workflows#workflow-execution).\n\nSee also [`tctl workflow observeid`](/tctl-v1/workflow/observeid).\n\n`tctl workflow observe <modifiers>`\n\nAlias: `o`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow observe --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow observe --run_id <id>\n```\n\n### --show_detail\n\nShow event details.\n\n**Example**\n\n```bash\ntctl workflow observe --show_detail\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow observe --max_field_length <length>\n```\n","is_empty":false},{"file_name":"workflow/observeid.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/observeid.md","id":"tctl-v1/workflow/observeid","title":"tctl workflow observeid","description":"How to show the progress of the Event History of a Workflow Execution for a specified Workflow Id and optional Run Id using tctl.","label":"observeid","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow observeid` command shows the progress of the [Event History](/concepts/what-is-an-event-history) of a [Workflow Execution](/workflows#workflow-execution) for the specified [Workflow Id](/concepts/what-is-a-workflow-id) and optional [Run Id](/concepts/what-is-a-run-id).\n\n`tctl workflow observeid <workflow_id> [<run_id>] <modifiers>`\n\nThis command is a shortcut for `tctl workflow observe --workflow_id <workflowid> [--run_id <runid>]`.\n\nThe following modifiers control the behavior of the command.\n\n### --show_detail\n\nShow event details.\n\n**Example**\n\n```bash\ntctl workflow observeid --show_detail\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow observeid --max_field_length <length>\n```\n","is_empty":false},{"file_name":"workflow/query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/query.md","id":"tctl-v1/workflow/query","title":"tctl workflow query","description":"How to send a Query to a Workflow Execution using tctl.","label":"query","tags":["tctl"],"ssdi":[],"markdown_content":"\nAlias: `q`\n\nThe `tctl workflow query` command sends a [Query](/concepts/what-is-a-query) to a [Workflow Execution](/workflows#workflow-execution).\n\nQueries can be used to retrieve all or part of the Workflow state with given parameters.\n\n```bash\n$ tctl workflow query --workflow_id \"HelloQuery\" --query_type \"getCount\"\nQuery result as JSON:\n3\n```\n\nQueries can also be used on completed Workflows.\nLet's complete a Workflow by updating its greeting, and then query the now-finished Workflow.\n\n```bash\n$ tctl workflow signal --workflow_id \"HelloQuery\" --name \"updateGreeting\" --input \\\"Bye\\\"\nSignal workflow succeeded.\n$ tctl workflow query --workflow_id \"HelloQuery\" --query_type \"getCount\"\nQuery result as JSON:\n4\n```\n\nQueries are written as follows:\n\n`tctl workflow query --workflow_id [modifiers]`\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id). **This modifier is required.**\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow query --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow query --run_id <id>\n```\n\n### --query_type\n\nSpecify the type of Query to run.\n\n**Example**\n\n```bash\ntctl workflow query --query_type <value>\n```\n\n### --input\n\nPass input for the Query.\nInput must be in JSON format.\nFor multiple JSON objects, concatenate them and use spaces as separators.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow query --input <json>\n```\n\n### --input_file\n\nPass input for the Query from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nInput from the command line overwrites input from the file.\n\n**Example**\n\n```bash\ntctl workflow query --input_file <filename>\n```\n\n### --query_reject_condition\n\nReject Queries based on Workflow state.\nValid values are `not_open` and `not_completed_cleanly`.\n\n**Example**\n\n```bash\ntctl workflow query --query_reject_condition <value>\n```\n","is_empty":false},{"file_name":"workflow/reset-batch.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/reset-batch.md","id":"tctl-v1/workflow/reset-batch","title":"tctl workflow reset-batch","description":"How to reset a batch of Workflow Executions using tctl.","label":"reset-batch","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow reset-batch` command resets a batch of [Workflow Executions](/workflows#workflow-execution) by [`resetType`](#resettype).\n\nResetting a Workflow allows the process to be resumed from a certain point without losing your parameters or Event History.\n\nTo reset individual Workflows, see [`tctl workflow reset`](/tctl-v1/workflow/reset).\n\n`tctl workflow reset-batch <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --input_file\n\nProvide an input file that specifies [Workflow Execution](/workflows#workflow-execution) to reset.\n\nEach line contains one [Workflow Id](/concepts/what-is-a-workflow-id) as the base Run and, optionally, a [Run Id](/concepts/what-is-a-run-id).\nIf a Run Id is not specified, the current Run Id is used.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --input_file <filename>\n```\n\n### --query\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute) describing the [Workflow Executions](/workflows#workflow-execution) to reset.\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl workflow reset-batch --query <value>\n```\n\n### --exclude_file\n\nProvide an input file that specifies [Workflow Executions](/workflows#workflow-execution) to exclude from resetting.\n\nEach line contains one [Workflow Id](/concepts/what-is-a-workflow-id).\n\n**Example**\n\n```bash\ntctl workflow reset-batch --exclude_file <filename>\n```\n\n### --input_separator\n\nSpecify the separator for the input file.\nThe default is a tab (`\\t`).\n\n**Example**\n\n```bash\ntctl workflow reset-batch --input_separator <string>\n```\n\n### --reason\n\nSpecify a reason for resetting the [Workflow Executions](/workflows#workflow-execution).\n\n**Example**\n\n```bash\ntctl workflow reset-batch --reason <string>\n```\n\n### --input_parallism\n\nSpecify the number of goroutines to run in parallel.\nEach goroutine processes one line for every second.\nThe default is 1.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --input_parallism <value>\n```\n\n### --skip_current_open\n\nIndicate that a [Workflow Execution](/workflows#workflow-execution) should be skipped if the current Run is open for the same [Workflow Id](/concepts/what-is-a-workflow-id) as the base Run.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --skip_current_open\n```\n\n### --skip_base_is_not_current\n\nIndicate that a [Workflow Execution](/workflows#workflow-execution) should be skipped if the base Run is not the current Run.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --skip_base_is_not_current\n```\n\n### --only_non_deterministic\n\nIndicate that a [Workflow Execution](/workflows#workflow-execution) should be reset only if its last event is `WorkflowTaskFailed` with a non-deterministic error.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --only_non_deterministic\n```\n\n### --dry_run\n\nSimulate use of the `tctl workflow reset-batch` command without resetting any [Workflow Executions](/workflows#workflow-execution).\nOutput is logged to `stdout`.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --dry_run\n```\n\n### --reset_type\n\nSpecify the event type to which you want to reset.\n\n| Value                | Description                                                 |\n| -------------------- | ----------------------------------------------------------- |\n| `FirstWorkflowTask`  | Reset to the beginning of the Event History.                |\n| `LastWorkflowTask`   | Reset to the end of the Event History.                      |\n| `LastContinuedAsNew` | Reset to the end of the Event History for the previous Run. |\n| `BadBinary`          | Reset to the point where a bad binary was used.             |\n\n**Example**\n\n```bash\ntctl workflow reset-batch --reset_type <value>\n```\n\n### --reset_bad_binary_checksum\n\nSpecify the binary checksum when using `--reset_type BadBinary`.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --reset_bad_binary_checksum <value>\n```\n","is_empty":false},{"file_name":"workflow/reset.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/reset.md","id":"tctl-v1/workflow/reset","title":"tctl workflow reset","description":"How to reset a Workflow Execution using tctl.","label":"reset","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow reset` command resets a [Workflow Execution](/workflows#workflow-execution) by either [`eventId`](#eventid)or [`resetType`](#resettype).\n\nResetting a Workflow allows the process to be resumed from a certain point without losing your parameters or Event History.\n\nTo run multiple Reset operations at once, see [`tctl workflow reset-batch`](/tctl-v1/workflow/reset-batch).\n\n`tctl workflow reset <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow reset --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow reset --run_id <id>\n```\n\n### --event_id\n\nSpecify the `eventId` of any event after `WorkflowTaskStarted` to which you want to reset.\nValid values are `WorkflowTaskCompleted`, `WorkflowTaskFailed`, and `WorkflowTaskTimeout`.\n\n**Example**\n\n```bash\ntctl workflow reset --event_id <id>\n```\n\n### --reason\n\nSpecify a reason for resetting the [Workflow Execution](/workflows#workflow-execution).\n\n**Example**\n\n```bash\ntctl workflow reset --reason <string>\n```\n\n### --reset_type\n\nSpecify the event type to which you want to reset.\n\n| Value                | Description                                                 |\n| -------------------- | ----------------------------------------------------------- |\n| `FirstWorkflowTask`  | Reset to the beginning of the Event History.                |\n| `LastWorkflowTask`   | Reset to the end of the Event History.                      |\n| `LastContinuedAsNew` | Reset to the end of the Event History for the previous Run. |\n| `BadBinary`          | Reset to the point where a bad binary was used.             |\n\n**Example**\n\n```bash\ntctl workflow reset --reset_type <value>\n```\n\n### --reset_reapply_type\n\nSpecify the types of events to reapply after the reset point.\nValid values are `All`, `Signal`, and `None`. The default is `All`.\n\n**Example**\n\n```bash\ntctl workflow reset --reset_reapply_type <value>\n```\n\n### --reset_bad_binary_checksum\n\nSpecify the binary checksum when using `--reset_type BadBinary`.\n\n**Example**\n\n```bash\ntctl workflow reset --reset_bad_binary_checksum <value>\n```\n","is_empty":false},{"file_name":"workflow/run.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/run.md","id":"tctl-v1/workflow/run","title":"tctl workflow run","description":"How to start a new Workflow Execution and get Workflow progress using tctl.","label":"run","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow run` command starts a new [Workflow Execution](/workflows#workflow-execution) and can show the progress of a Workflow Execution.\nThe command is entered in the following format:\n\n`tctl workflow run <modifiers>`\n\nTo run a Workflow, the user must specify the following:\n\n- Task queue name (`--taskqueue`)\n- Workflow Type (`--workflow_type`)\n\n```bash\ntctl workflow run --taskqueue your-task-queue-name --workflow_type YourWorkflowDefinitionName\n```\n\nSingle quotes (`''`) are used to wrap input as JSON.\nThis command doesn't finish until the Workflow completes.\n\nThe following modifiers control the behavior of the command.\n\n### --taskqueue\n\nSpecify a [Task Queue](/concepts/what-is-a-task-queue).\n\nAlias: `--t`\n\n**Example**\n\n```bash\ntctl workflow run --taskqueue <name>\n```\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow run --workflow_id <id>\n```\n\n### --workflow_type\n\nSpecify the name of a [Workflow Type](/concepts/what-is-a-workflow-type).\n\n**Example**\n\n```bash\ntctl workflow run --workflow_type <name>\n```\n\n### --execution_timeout\n\nSpecify the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) of the [Workflow Execution](/workflows#workflow-execution) in seconds.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow run --execution_timeout <seconds>\n```\n\n### --workflow_task_timeout\n\nSpecify the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) of the [Workflow Task](/concepts/what-is-a-workflow-task) in seconds.\nThe default value is 10.\n\n**Example**\n\n```bash\ntctl workflow run --workflow_task_timeout <seconds>\n```\n\n### --cron\n\nSpecify a [Cron Schedule](/concepts/what-is-a-temporal-cron-job#cron-schedules).\n\n**Example**\n\n```bash\ntctl workflow run --cron <string>\n```\n\n### --workflowidreusepolicy\n\nSpecify a [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy).\nConfigure if the same [Workflow Id](/concepts/what-is-a-workflow-id) is allowed for use in new [Workflow Execution](/workflows#workflow-execution).\n\nThere are three allowed values:\n\n- [AllowDuplicateFailedOnly](/concepts/what-is-a-workflow-id-reuse-policy)\n- [AllowDuplicate](/concepts/what-is-a-workflow-id-reuse-policy)\n- [RejectDuplicate](/concepts/what-is-a-workflow-id-reuse-policy)\n\n**Examples**\n\n```bash\ntctl workflow run --workflowidreusepolicy AllowDuplicate\ntctl workflow run --workflowidreusepolicy AllowDuplicateFailedOnly\ntctl workflow run --workflowidreusepolicy RejectDuplicate\n```\n\n### --input\n\nPass input for the Workflow.\nInput must be in JSON format.\nFor multiple JSON objects, pass each in a separate `--input` option. Use `null` for null values.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow run --input <json>\n```\n\n### --input_file\n\nPass input for the Workflow from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nInput from the command line overwrites input from the file.\n\n**Example**\n\n```bash\ntctl workflow run --input_file <filename>\n```\n\n### --memo_key\n\nPass a key for a memo.\nFor multiple keys, concatenate them and use spaces as separators.\n\n**Example**\n\n```bash\ntctl workflow run --memo_key <key>\n```\n\n### --memo\n\nPass a memo.\nA memo is information in JSON format that can be shown when the Workflow is listed.\nFor multiple memos, concatenate them and use spaces as separators.\nThe order must match the order of keys in `--memo_key`.\n\n**Example**\n\n```bash\ntctl workflow run --memo <json>\n```\n\n### --memo_file\n\nPass information for a memo from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nThe order must match the order of keys in `--memo_key`.\n\n**Example**\n\n```bash\ntctl workflow run --memo_file <filename>\n```\n\n### --search_attr_key\n\nSpecify a [Search Attribute](/concepts/what-is-a-search-attribute) key.\nFor multiple keys, concatenate them and use pipes (`|`) as separators.\n\nTo list valid keys, use the `tctl cluster get-search-attributes` command.\n\n**Example**\n\n```bash\ntctl workflow run --search_attr_key <key>\n```\n\n### --search_attr_value\n\nSpecify a [Search Attribute](/concepts/what-is-a-search-attribute) value.\nFor multiple values, concatenate them and use pipes (`|`) as separators.\nIf a value is an array, use JSON format, such as `[\"a\",\"b\"]`, `[1,2]`, `[\"true\",\"false\"]`, or `[\"2022-06-07T17:16:34-08:00\",\"2022-06-07T18:16:34-08:00\"]`.\n\nTo list valid keys and value types, use the `tctl cluster get-search-attributes` command.\n\n**Example**\n\n```bash\ntctl workflow run --search_attr_value <value>\n```\n\n### --show_detail\n\nGet event details.\n\n**Example**\n\n```bash\ntctl workflow run --show_detail\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow run --max_field_length <length>\n```\n","is_empty":false},{"file_name":"workflow/scan.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/scan.md","id":"tctl-v1/workflow/scan","title":"tctl workflow scan","description":"How to quickly list Workflow Executions without sorting using tctl.","label":"scan","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow scan` command lists [Workflow Executions](/workflows#workflow-execution).\nIt is faster than the `tctl workflow listall` command, but the results are not sorted.\n\nBy default, this command lists a maximum of 2000 Workflow Executions.\nTo set the size of a page, use the `--pagesize` option.\n\nSee also [`tctl workflow list`](/tctl-v1/workflow/list), [`tctl workflow listall`](/tctl-v1/workflow/listall), and [`tctl workflow listarchived`](/tctl-v1/workflow/listarchived).\n\n`tctl workflow scan <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow scan --print_raw_time\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow scan --print_datetime\n```\n\n### --print_memo\n\nPrint a memo.\n\n**Example**\n\n```bash\ntctl workflow scan --print_memo\n```\n\n### --print_search_attr\n\nPrint the [Search Attributes](/concepts/what-is-a-search-attribute).\n\n**Example**\n\n```bash\ntctl workflow scan --print_search_attr\n```\n\n### --print_full\n\nPrint the full message without table formatting.\n\n**Example**\n\n```bash\ntctl workflow scan --print_full\n```\n\n### --print_json\n\nPrint the raw JSON objects.\n\n**Example**\n\n```bash\ntctl workflow scan --print_json\n```\n\n### --pagesize\n\nSpecify the maximum number of [Workflow Execution](/workflows#workflow-execution) to list on a page.\n(By default, the `tctl workflow scan` command lists 2000 Workflow Executions per page.)\n\n**Example**\n\n```bash\ntctl workflow scan --pagesize <value>\n```\n\n### --query\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute).\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl workflow scan --query <value>\n```\n","is_empty":false},{"file_name":"workflow/show.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/show.md","id":"tctl-v1/workflow/show","title":"tctl workflow show","description":"How to show Workflow History using tctl.","label":"show","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow show` command shows the [Event History](/concepts/what-is-an-event-history) for the specified [Workflow Execution](/workflows#workflow-execution).\n\n`tctl workflow show <modifiers>`\n\nSee also [`tctl workflow showid`](/tctl-v1/workflow/showid).\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nShow the History of a [Workflow Execution](/workflows#workflow-execution) by specifying a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow show --workflow_id <id>\n```\n\n### --run_id\n\nShow the History of a [Workflow Execution](/workflows#workflow-execution) by specifying a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow show --run_id <id>\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow show --print_datetime\n```\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow show --print_raw_time\n```\n\n### --output_filename\n\nSerialize an event to a file.\n\n**Example**\n\n```bash\ntctl workflow show --output_filename <filename>\n```\n\n### --print_full\n\nPrint full event details.\n\n**Example**\n\n```bash\ntctl workflow show --print_full\n```\n\n### --print_event_version\n\nPrint the event version.\n\n**Example**\n\n```bash\ntctl workflow show --print_event_version\n```\n\n### --event_id\n\nPrint the details of a specified event.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow show --event_id <id>\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 500.\n\n**Example**\n\n```bash\ntctl workflow show --max_field_length <length>\n```\n\n### --reset_points_only\n\nShow only events that are eligible for reset.\n\n**Example**\n\n```bash\ntctl workflow show --reset_points_only\n```\n","is_empty":false},{"file_name":"workflow/showid.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/showid.md","id":"tctl-v1/workflow/showid","title":"tctl workflow showid","description":"How to show Workflow History for a specified Workflow Id and optional Run Id using tctl.","label":"showid","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow showid` command shows the Workflow Execution Event History for the specified [Workflow Id](/concepts/what-is-a-workflow-id) and optional [Run Id](/concepts/what-is-a-run-id).\n\n`tctl workflow showid <workflow_id> [<run_id>] <modifiers>`\n\nThis command is a shortcut for `tctl workflow show --workflow_id <workflowid> [--run_id <runid>]`.\n\nExample:\n\n```bashbash\ntctl workflow showid <workflow_id>\n```\n\nExample output:\n\n```bashtext\n1  WorkflowExecutionStarted    {WorkflowType:{Name:HelloWorld}, ParentInitiatedEventId:0,\n                                TaskQueue:{Name:HelloWorldTaskQueue, Kind:Normal},\n                                Input:[Temporal], WorkflowExecutionTimeout:1h0m0s,\n                                WorkflowRunTimeout:1h0m0s, WorkflowTaskTimeout:10s,\n                                Initiator:Unspecified, LastCompletionResult:[],\n                                OriginalExecutionRunId:f0c04163-833f-490b-99a9-ee48b6199213,\n                                Identity:tctl@z0mb1e,\n                                FirstExecutionRunId:f0c04163-833f-490b-99a9-ee48b6199213,\n                                Attempt:1, WorkflowExecutionExpirationTime:2020-10-13\n                                21:41:06.349 +0000 UTC, FirstWorkflowTaskBackoff:0s}\n2  WorkflowTaskScheduled       {TaskQueue:{Name:HelloWorldTaskQueue,\n                                Kind:Normal},\n                                StartToCloseTimeout:10s, Attempt:1}\n3  WorkflowTaskStarted         {ScheduledEventId:2, Identity:15079@z0mb1e,\n                                RequestId:731f7b41-5ae4-42e4-9695-ecd857d571f1}\n4  WorkflowTaskCompleted       {ScheduledEventId:2,\n                                StartedEventId:3,\n                                Identity:15079@z0mb1e}\n5  WorkflowExecutionCompleted  {Result:[],\n                                WorkflowTaskCompletedEventId:4}\n```\n\nThe following modifiers control the behavior of the command.\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --print_datetime\n```\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --print_raw_time\n```\n\n### --output_filename\n\nSerialize an event to a file.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --output_filename <filename>\n```\n\n### --print_full\n\nPrint full event details.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --print_full\n```\n\n### --print_event_version\n\nPrint the event version.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --print_event_version\n```\n\n### --event_id\n\nPrint the details of a specified event.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --event_id <id>\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 500.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --max_field_length <length>\n```\n\n### --reset_points_only\n\nShow only events that are eligible for reset.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --reset_points_only\n```\n","is_empty":false},{"file_name":"workflow/signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/signal.md","id":"tctl-v1/workflow/signal","title":"tctl workflow signal","description":"How to Signal a Workflow Execution using tctl.","label":"signal","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow signal` command [Signals](/concepts/what-is-a-signal) a [Workflow Execution](/workflows#workflow-execution).\n\nWorkflows listen for Signals by their Signal name, and can be made to listen to one or more Signal names.\nWorkflows can also listen for SQL queries.\n\nThe Workflow below listens for instances of \"HelloSignal\":\n\n```bash\ntctl workflow start  --workflow_id \"HelloSignal\" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\\"World\\\"\n```\n\nThe Worker would return this output upon receiving the Signal:\n\n```text\n13:57:44.258 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 1: Hello World!\n```\n\nSignals can also be used to change variable values.\n\n```bash\ntctl workflow signal --workflow_id \"HelloSignal\" --name \"updateGreeting\" --input \\\"Hi\\\"\n```\n\nThe output would change from the first Signal received.\n\n```text\n13:57:44.258 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 1: Hello World!\n13:58:22.352 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 2: Hi World!\n```\n\nWhen a Signal is sent, an await condition is made to block any Signals that contain the same input value.\nHowever, changing the greeting in our example unblocks it:\n\n```bash\ntctl workflow signal --workflow_id \"HelloSignal\" --name \"updateGreeting\" --input \\\"Welcome\\\"\n```\n\nWorker output:\n\n```text\n13:57:44.258 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 1: Hello World!\n13:58:22.352 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 2: Hi World!\n13:59:29.097 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 3: Welcome World!\n```\n\nSending Signals does not require a running Worker.\n\n```bash\ntctl workflow signal --workflow_id \"HelloSignal\" --name \"updateGreeting\" --input \\\"Welcome\\\"\n```\n\nCLI output:\n\n```text\nSignal workflow succeeded.\n```\n\nThe Signal request is queued inside the Temporal Server until the Worker is restarted.\nIf the given Signal contains the same input as before, the queued Signal will be ignored.\n\nComplete the Workflow by sending a Signal with a \"Bye\" greeting:\n\n```bash\ntctl workflow signal --workflow_id \"HelloSignal\" --name \"updateGreeting\" --input \\\"Bye\\\"\n```\n\nCheck that the Workflow Execution has been completed.\n\n```bash\ntctl workflow showid HelloSignal\n```\n\nSignals are written as follows:\n\n```bash\ntctl workflow signal --workflow_id <id> <modifiers>\n```\n\nor\n\n```bash\ntctl workflow signal --query <query> <modifiers>\n```\n\nThe following modifiers control the behavior of the command.\nMake sure to include required modifiers in all command executions.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id). **This modifier is required.**\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow signal --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow signal --run_id <id>\n```\n\n### --name\n\nSpecify the name of a [Signal](/concepts/what-is-a-signal).\n\n**Example**\n\n```bash\ntctl workflow signal --query <query> --name <name>\n```\n\n### --input\n\nPass input for the [Signal](/concepts/what-is-a-signal).\nInput must be in JSON format.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow signal --query <query> --input <json>\n```\n\n### --input_file\n\nPass input for the [Signal](/concepts/what-is-a-signal) from a JSON file.\n\n**Example**\n\n```bash\ntctl workflow signal --query <query> --input_file <filename>\n```\n","is_empty":false},{"file_name":"workflow/stack.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/stack.md","id":"tctl-v1/workflow/stack","title":"tctl workflow stack","description":"How to query Workflow Executions with __stack_trace using tctl.","label":"stack","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow stack` command queries [Workflow Execution](/workflows#workflow-execution) with `__stack_trace` as the query type.\n\nThis command can be used to locate errors and blocks in a [Workflow Definition](/concepts/what-is-a-workflow-definition).\n\n`tctl workflow stack <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\n**This is a required modifier.**\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow stack --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow stack --run_id <id>\n```\n\n### --input\n\nPass input for the query.\nInput must be in JSON format.\nFor multiple JSON objects, concatenate them and use spaces as separators.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow stack --input <json>\n```\n\n### --input_file\n\nPass input for the query from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nInput from the command line overwrites input from the file.\n\n**Example**\n\n```bash\ntctl workflow stack --input_file <filename>\n```\n\n### --query_reject_condition\n\nReject queries based on Workflow state.\nValid values are `not_open` and `not_completed_cleanly`.\n\n**Example**\n\n```bash\ntctl workflow stack --query_reject_condition <value>\n```\n","is_empty":false},{"file_name":"workflow/start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/start.md","id":"tctl-v1/workflow/start","title":"tctl workflow start","description":"How to start a new Workflow Execution using tctl.","label":"start","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow start` command starts a new [Workflow Execution](/workflows#workflow-execution).\nUnlike `run`, this command returns the Workflow Id and Run Id immediately after starting the Workflow.\n\n`tctl workflow start <modifiers>`\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n### --taskqueue\n\nSpecify a [Task Queue](/concepts/what-is-a-task-queue).\n\nAlias: `--t`\n\n**Example**\n\n```bash\ntctl workflow start --taskqueue <name>\n```\n\n### --workflow_id\n\n**This is a required modifier.**\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow start --workflow_id <id>\n```\n\nIf a Workflow is started without providing an Id, the Client generates one in the form of a UUID.\nTemporal recommends using a business id rather than the client-generated UUID.\n\n**Example**\n\n```bash\ntctl workflow start  --workflow_id \"HelloTemporal1\" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\\"Temporal\\\"\n```\n\n### --workflow_type\n\nSpecify the name of a [Workflow Type](/concepts/what-is-a-workflow-type).\n\n**Example**\n\n```bash\ntctl workflow start --workflow_type <name>\n```\n\n### --execution_timeout\n\nSpecify the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) of the [Workflow Execution](/workflows#workflow-execution) in seconds.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow start --execution_timeout <seconds>\n```\n\n### --workflow_task_timeout\n\nSpecify the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) of the [Workflow Task](/concepts/what-is-a-workflow-task) in seconds.\nThe default value is 10.\n\n**Example**\n\n```bash\ntctl workflow start --workflow_task_timeout <seconds>\n```\n\n### --cron\n\nSpecify a [Cron Schedule](/concepts/what-is-a-temporal-cron-job#cron-schedules).\n\n**Example**\n\n```bash\ntctl workflow start --cron <string>\n```\n\n### --workflowidreusepolicy\n\nSpecify a [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy).\nConfigure if the same [Workflow Id](/concepts/what-is-a-workflow-id) is allowed for use in new [Workflow Execution](/workflows#workflow-execution).\n\nThere are three allowed values:\n\n- [AllowDuplicateFailedOnly](/concepts/what-is-a-workflow-id-reuse-policy)\n- [AllowDuplicate](/concepts/what-is-a-workflow-id-reuse-policy)\n- [RejectDuplicate] (/concepts/what-is-a-workflow-id-reuse-policy)\n\n**Examples**\n\n```bash\ntctl workflow start --workflowidreusepolicy AllowDuplicate\ntctl workflow start --workflowidreusepolicy AllowDuplicateFailedOnly\ntctl workflow start --workflowidreusepolicy RejectDuplicate\n```\n\n:::note\n\nMultiple Workflows with the same Id cannot be run at the same time\n\n:::\n\n### --input\n\nPass input for the Workflow.\nInput must be in JSON format.\nFor multiple JSON objects, pass each in a separate `--input` option.\nUse `null` for null values.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow start --input <json>\n```\n\n### --input_file\n\nPass input for the Workflow from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nInput from the command line overwrites input from the file.\n\n**Example**\n\n```bash\ntctl workflow start --input_file <filename>\n```\n\n### --memo_key\n\nPass a key for a memo.\nFor multiple keys, concatenate them and use spaces as separators.\n\n**Example**\n\n```bash\ntctl workflow start --memo_key <key>\n```\n\n### --memo\n\nPass information for a [memo](/concepts/what-is-a-memo) from a JSON file.\n\nMemos are immutable key/value pairs that can be attached to a workflow run when starting the workflow.\nMemos are visible when listing workflows.\n\nFor multiple memos, concatenate them and use spaces as separators.\nThe order must match the order of keys in `--memo_key`.\n\n**Example**\n\n```bash\ntctl workflow start \\\n  -tq your-task-queue \\\n  -wt your-workflow \\\n  -et 60 \\\n  -i '\"temporal\"' \\\n  -memo_key '<key values>' \\\n  -memo '<value>'\n```\n\n### --memo_file\n\nPass information for a memo from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nThe order must match the order of keys in `--memo_key`.\n\n**Example**\n\n```bash\ntctl workflow start --memo_file <filename>\n```\n\n### --search_attr_key\n\nSpecify a [Search Attribute](/concepts/what-is-a-search-attribute) name.\nFor multiple names, concatenate them and use pipes (`|`) as separators.\n\nTo list valid Search Attributes, use the `tctl cluster get-search-attributes` command.\n\n**Example**\n\n```bash\ntctl workflow start --search_attr_key <key>\n```\n\n### --search_attr_value\n\nSpecify a [Search Attribute](/concepts/what-is-a-search-attribute) value.\nFor multiple values, concatenate them and use pipes (`|`) as separators.\nIf a value is an array, use JSON format, such as `[\"a\",\"b\"]`, `[1,2]`, `[\"true\",\"false\"]`, or `[\"2022-06-07T17:16:34-08:00\",\"2022-06-07T18:16:34-08:00\"]`.\n\nTo list valid Search Attributes and value types, use the `tctl cluster get-search-attributes` command.\n\n**Example**\n\n```bash\ntctl workflow start --search_attr_value <value>\n```\n","is_empty":false},{"file_name":"workflow/terminate.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/workflow/terminate.md","id":"tctl-v1/workflow/terminate","title":"tctl workflow terminate","description":"How to terminate a Workflow Execution using tctl.","label":"terminate","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl workflow terminate` command terminates a [Workflow Execution](/workflows#workflow-execution).\n\nTerminating a running Workflow Execution records a `WorkflowExecutionTerminated` event as the closing event in the History.\nNo more [Workflow Task](/concepts/what-is-a-workflow-task) will be scheduled.\n\nSee also [`tctl workflow cancel`](/tctl-v1/workflow/cancel).\n\n`tctl workflow terminate --query <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\n_Required modifier_\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow terminate --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nIf `run_id` is not specified, `tctl` terminates the last Workflow Execution for the specified `workflow_id`.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow terminate --run_id <id>\n```\n\n### --reason\n\nSpecify a reason for terminating the [Workflow Execution](/workflows#workflow-execution).\n\n**Example**\n\n```bash\ntctl workflow terminate --workflow_id --reason <string>\n```\n","is_empty":false},{"file_name":"taskqueue/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/taskqueue/describe.md","id":"tctl-v1/taskqueue/describe","title":"tctl taskqueue describe","description":"How to describe the poller information of a Task Queue using tctl.","label":"describe","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl taskqueue describe` command describes the poller information of a [Task Queue](/concepts/what-is-a-task-queue).\n\n`tctl taskqueue describe <modifiers> <value>`\n\nThe following modifiers control the behavior of the command.\n\n### --taskqueue\n\n_Required modifier_\n\nSpecify a [Task Queue](/concepts/what-is-a-task-queue).\n\nAlias: `--t`\n\n**Example**\n\n```bash\ntctl taskqueue describe --taskqueue <value>\n```\n\n### --taskqueuetype\n\nSpecify the type of a [Task Queue](/concepts/what-is-a-task-queue).\nThe type can be `workflow` or `activity`.\nThe default is `workflow`.\n\n**Example**\n\n```bash\ntctl taskqueue describe --taskqueue <value> --taskqueuetype <type>\n```\n","is_empty":false},{"file_name":"taskqueue/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/taskqueue/index.md","id":"tctl-v1/taskqueue/index","title":"tctl taskqueue","description":"How to operate Task Queues using tctl.","label":"taskqueue","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl taskqueue` command enables [Task Queue](/concepts/what-is-a-task-queue) operations.\n\nAlias: `t`\n\n- [tctl taskqueue describe](/tctl-v1/taskqueue/describe)\n- [tctl taskqueue list-partition](/tctl-v1/taskqueue/list-partition)\n","is_empty":false},{"file_name":"taskqueue/list-partition.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/taskqueue/list-partition.md","id":"tctl-v1/taskqueue/list-partition","title":"tctl taskqueue list-partition","description":"How to list Task Queue partitions and the hostname for partitions using tctl.","label":"list-partition","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl taskqueue list-partition` command lists the partitions of a [Task Queue](/concepts/what-is-a-task-queue) and the hostname for the partitions.\n\n`tctl taskqueue list-partition --taskqueue <value>`\n\nThe following modifier controls the behavior of the command.\n\n### --taskqueue\n\n_Required modifier_\n\nSpecify a [Task Queue](/concepts/what-is-a-task-queue) description.\n\nAlias: `--t`\n\n**Example**\n\n```bash\ntctl taskqueue list-partition --taskqueue <value>\n```\n","is_empty":false},{"file_name":"schedule/backfill.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/schedule/backfill.md","id":"tctl-v1/schedule/backfill","title":"tctl schedule backfill","description":"How to backfill a Schedule using tctl.","label":"backfill","tags":["tctl"],"ssdi":[],"markdown_content":"\nBackfilling a Schedule means having it do now what it would have done over a specified time range (generally in the past, although it won't prevent you from giving a time range in the future).\nYou might use this to fill in runs from a time period when the Schedule was paused due to an external condition that's now resolved, or a period before the Schedule was created.\n\n```shell\ntctl schedule backfill --sid 'your-schedule-id' \\\n  --overlap-policy 'BufferAll'                \\\n  --start-time '2022-05-01T00:00:00Z'         \\\n  --end-time   '2022-05-31T23:59:59Z'\n```\n\nNote that, similar to [tctl schedule trigger](/tctl-v1/schedule/trigger) immediately, you probably want to override the Overlap Policy.\nSpecifying `AllowAll` runs all the backfilled Workflows at once; `BufferAll` runs them sequentially.\nThe other policies don't make much sense in this context.\n","is_empty":false},{"file_name":"schedule/create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/schedule/create.md","id":"tctl-v1/schedule/create","title":"tctl schedule create","description":"How to create a Schedule using tctl.","label":"create","tags":["tctl"],"ssdi":[],"markdown_content":"\nWith tctl, create a Schedule like this:\n\n```shell\n$ tctl config set version next   # ensure you're using the new tctl\n$ tctl schedule create \\\n    --sid 'your-schedule-id' \\\n    --interval '5h/15m' \\\n    --cal '{\"dayOfWeek\":\"Fri\",\"hour\":\"11\",\"minute\":\"3\"}' \\\n    --overlap-policy 'BufferAll' \\\n    --wid 'your-workflow-id' \\\n    --tq 'your-task-queue' \\\n    --type 'YourWorkflowType'\n```\n\nThis Schedule takes action every 5 hours at 15 minutes past the hour and also at 11:03 on Fridays.\nIt starts a Workflow `YourWorkflowType` on Task Queue `your-task-queue`, giving it a Workflow Id like `your-workflow-id-2022-06-17T11:03:00Z`.\nWorkflows do not run in parallel.\nIf they would otherwise overlap, they are buffered to run sequentially.\n\nYou can also use traditional cron strings, including all features that are supported by `CronSchedule` today, such as `@weekly` and other shorthands, `@every`, and `CRON_TZ`.\n\n```shell\n$ tctl schedule create \\\n    --sid 'your-schedule-id' \\\n    --cron '3 11 * * Fri' \\\n    --wid 'your-workflow-id' \\\n    --tq 'your-task-queue' \\\n    --type 'YourWorkflowType'\n```\n\nAny combination of `--cal`, `--interval`, and `--cron` is supported and Actions will happen at any of the specified times.\nIf you use both `--time-zone` and also `CRON_TZ`, they must agree.\n\nSee `tctl schedule create --help` for the full set of available options.\n","is_empty":false},{"file_name":"schedule/delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/schedule/delete.md","id":"tctl-v1/schedule/delete","title":"tctl schedule delete","description":"How to delete a Schedule using tctl","label":"delete","tags":["tctl"],"ssdi":[],"markdown_content":"\nA Schedule can be deleted.\n\nDeleting a Schedule **does not** affect any Workflows started by the Schedule.\nWorkflow Executions started by Schedules can be cancelled or terminated using the same methods as any others.\nHowever, Workflow Executions started by a Schedule can be identified by the Search Attributes added to them and can be targeted by a [batch](/tctl-v1/batch/) command for termination.\n\n```shell\n$ tctl schedule delete --sid 'your-schedule-id'\n```\n","is_empty":false},{"file_name":"schedule/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/schedule/describe.md","id":"tctl-v1/schedule/describe","title":"tctl schedule describe","description":"How to describe a Schedule using tctl","label":"describe","tags":["tctl"],"ssdi":[],"markdown_content":"\nDisplay the current Schedule configuration as well as extra information about past, current, and future Runs.\n\n```shell\ntctl schedule describe --sid 'your-schedule-id'\n```\n\nBecause the Schedule Spec is converted to canonical representations, the output might not be in the same form as it was input.\n","is_empty":false},{"file_name":"schedule/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/schedule/index.md","id":"tctl-v1/schedule/index","title":"tctl schedule","description":"How to operate Schedules using tctl.","label":"schedule","tags":["tctl"],"ssdi":[],"markdown_content":"\nA [Schedule](/concepts/what-is-a-schedule) is an experimental feature available in `tctl 1.17` and `tctl next`.\n\n- [Backfill a Schedule using tctl](/tctl-v1/schedule/backfill)\n- [Create a Schedule using tctl](/tctl-v1/schedule/create)\n- [Delete a Schedule using tctl](/tctl-v1/schedule/delete)\n- [Describe a Schedule using tctl](/tctl-v1/schedule/describe)\n- [List Schedules using tctl](/tctl-v1/schedule/list)\n- [Toggle Pause on Schedule using tctl](/tctl-v1/schedule/toggle)\n- [Trigger an Action on a Schedule using tctl](/tctl-v1/schedule/trigger)\n- [Update a Schedule using tctl](/tctl-v1/schedule/update)\n","is_empty":false},{"file_name":"schedule/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/schedule/list.md","id":"tctl-v1/schedule/list","title":"tctl schedule list","description":"How to list Schedules using tctl","label":"list","tags":["tctl"],"ssdi":[],"markdown_content":"\n```shell\ntctl schedule list\n```\n\nNote that if you're using standard Visibility, listing Schedules will currently only include Schedule Ids and no other information.\n\nBecause the Schedule Spec is converted to canonical representations, the output might not be in the same form as it was input.\n","is_empty":false},{"file_name":"schedule/toggle.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/schedule/toggle.md","id":"tctl-v1/schedule/toggle","title":"tctl schedule toggle","description":"How to toggle (pause/unpause) a Schedule using tctl.","label":"toggle","tags":["tctl"],"ssdi":[],"markdown_content":"\n```shell\n$ tctl schedule toggle --sid 'your-schedule-id' --pause --reason \"paused because the database is down\"\n$ tctl schedule toggle --sid 'your-schedule-id' --unpause --reason \"the database is back up\"\n```\n","is_empty":false},{"file_name":"schedule/trigger.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/schedule/trigger.md","id":"tctl-v1/schedule/trigger","title":"tctl schedule trigger","description":"How to trigger a Schedule Action using tctl","label":"trigger","tags":["tctl"],"ssdi":[],"markdown_content":"\nStarting a Workflow Run immediately with a Schedule, regardless of its configured Spec, is a common use case.\n\n```shell\n$ tctl schedule trigger --sid 'your-schedule-id'\n```\n\nNote that the action that it takes is subject to the Overlap Policy of the Schedule by default: if the overlap policy is `Skip` and a Workflow is already running, the triggered Action to start the next Workflow Run is skipped!\nLikewise, if the overlap policy is `BufferAll`, the triggered run is buffered behind one or more runs.\n\nIf you really want it to run right now, you can override the overlap policy for this request:\n\n```shell\n$ tctl schedule trigger --sid 'your-schedule-id' --overlap-policy 'AllowAll'\n```\n","is_empty":false},{"file_name":"schedule/update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/schedule/update.md","id":"tctl-v1/schedule/update","title":"tctl schedule update","description":"How to update a Schedule using tctl.","label":"update","tags":["tctl"],"ssdi":[],"markdown_content":"\nAny part of the Schedule configuration can be updated at any time.\n\n`tctl schedule update` takes the same options as `tctl schedule create` and replaces the entire configuration of the schedule with what's provided.\n\nThis means if you want to change just one value, you have to provide everything else again.\n","is_empty":false},{"file_name":"namespace/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/namespace/describe.md","id":"tctl-v1/namespace/describe","title":"tctl namespace describe","description":"How to describe a Namespace using tctl.","label":"describe","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl namespace describe` command describes a [Namespace](/namespaces).\n\n`tctl namespace describe`\n\nThe following modifier controls the behavior of the command.\n\n### --namespace_id\n\nSpecify the ID of a Namespace to describe.\n\nThis modifier is required unless the global `--namespace` modifier is specified (`tctl --namespace <name> describe`).\n\n**Example**\n\n```bash\ntctl namespace describe --namespace_id <id>\n```\n\nExample results for a [Global Namespace](/namespaces/#global-namespaces)\n\n```bash\n$ tctl --ns canary-namespace n desc\nName: canary-namespace\nDescription: testing namespace\nOwnerEmail: dev@yourtech.io\nNamespaceData:\nStatus: REGISTERED\nRetentionInDays: 7\nEmitMetrics: true\nActiveClusterName: dc1\nClusters: dc1, dc2\n```\n","is_empty":false},{"file_name":"namespace/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/namespace/index.md","id":"tctl-v1/namespace/index","title":"tctl namespace","description":"How to operate Namespaces using tctl.","label":"namespace","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl namespace` commands enable [Namespace](/concepts/what-is-a-namespace) operations.\n\nAlias: `n`\n\n- [tctl namespace describe](/tctl-v1/namespace/describe)\n- [tctl namespace list](/tctl-v1/namespace/list)\n- [tctl namespace register](/tctl-v1/namespace/register)\n- [tctl namespace update](/tctl-v1/namespace/update)\n","is_empty":false},{"file_name":"namespace/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/namespace/list.md","id":"tctl-v1/namespace/list","title":"tctl namespace list","description":"How to list all Namespaces using tctl.","label":"list","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl namespace list` command lists all [Namespaces](/concepts/what-is-a-namespace).\n\n`tctl namespace list`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"namespace/register.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/namespace/register.md","id":"tctl-v1/namespace/register","title":"tctl namespace register","description":"How to register a Namespace using tctl.","label":"register","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl namespace register` command registers a [Namespace](/concepts/what-is-a-namespace).\n\n`tctl namespace register`\n\nBy default, Temporal uses a \"default\" Namespace.\nCreate and register a new Namespace with the following command:\n\n```bash\ntctl --namespace your-namespace namespace register\n# OR using short alias\ntctl --ns your-namespace n re\n```\n\nThe following modifiers control the behavior of the command.\n\n### --active_cluster\n\nSpecify the name of the active [Temporal Cluster](/concepts/what-is-a-temporal-cluster) when registering a [Namespace](/concepts/what-is-a-namespace).\nThis value changes for Global Namespaces when a failover occurs.\n\n**Example**\n\n```bash\ntctl namespace register --active_cluster <name>\n```\n\n### --clusters\n\nSpecify a list of [Temporal Clusters](/concepts/what-is-a-temporal-cluster) when registering a [Namespace](/concepts/what-is-a-namespace).\n\nThe list contains the names of Clusters (separated by spaces) to which the Namespace can fail over.\nMake sure to include to the currently active Cluster.\nThis is a read-only setting and cannot be changed.\n\nThis modifier is valid only when the `--global_namespace` modifier is set to true.\n\n**Example**\n\n```bash\ntctl namespace register --clusters <names>\n```\n\n### --description\n\nSpecify a description when registering a [Namespace](/concepts/what-is-a-namespace).\n\n**Example**\n\n```bash\ntctl namespace register --description <value>\n```\n\n### --global_namespace\n\nSpecifies whether a [Namespace](/concepts/what-is-a-namespace) is a [Global Namespace](/namespaces/#global-namespace).\nWhen enabled, it controls the creation of replication tasks on updates allowing the state to be replicated across Clusters.\nThis is a read-only setting and cannot be changed.\n\n**Example**\n\n```bash\ntctl namespace register --global_namespace <boolean>\n```\n\n### --history_archival_state\n\nSet the state of [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n\n**Example**\n\n```bash\ntctl namespace register --history_archival_state <value>\n```\n\n### --history_uri\n\nSpecify the URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n\n**Example**\n\n```bash\ntctl namespace register --history_uri <uri>\n```\n\n### --namespace_data\n\nSpecify data for a [Namespace](/concepts/what-is-a-namespace) in the form of key-value pairs (such as `k1:v1,k2:v2,k3:v3`).\n\n**Example**\n\n```bash\ntctl namespace register --namespace_data <data>\n```\n\n### --owner_email\n\nSpecify the email address of the [Namespace](/concepts/what-is-a-namespace) owner.\n\n**Example**\n\n```bash\ntctl namespace register --owner_email <value>\n```\n\n### --retention\n\nSet the [Retention Period](/clusters#retention-period) for the [Namespace](/concepts/what-is-a-namespace).\n\nThe Retention Period applies to Closed [Workflow Executions](/workflows#workflow-execution).\n\n**Example**\n\n```bash\ntctl namespace register --retention <value>\n```\n\n### --visibility_archival_state\n\nSet the visibility state for [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n\n**Example**\n\n```bash\ntctl namespace register --visibility_archival_state <value>\n```\n\n### --visibility_uri\n\nSpecify the visibility URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n\n**Example**\n\n```bash\ntctl namespace register --visibility_uri <uri>\n```\n","is_empty":false},{"file_name":"namespace/update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/namespace/update.md","id":"tctl-v1/namespace/update","title":"tctl namespace update","description":"How to update a Namespace using tctl.","label":"update","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl namespace update` command updates a [Namespace](/concepts/what-is-a-namespace).\n\n`tctl namespace update`\n\nThe following modifiers control the behavior of the command.\n\n### --active_cluster\n\nSpecify the name of the active [Temporal Cluster](/concepts/what-is-a-temporal-cluster) when updating a [Namespace](/concepts/what-is-a-namespace).\n\n**Example**\n\n```bash\ntctl namespace update --active_cluster <name>\n```\n\n### --add_bad_binary\n\nAdd a binary checksum to use when resetting a [Workflow Execution](/workflows#workflow-execution).\nTemporal will not dispatch any [Commands](/concepts/what-is-a-command) to the given binary.\n\nSee also [`--remove_bad_binary`](#--remove_bad_binary).\n\n**Example**\n\n```bash\ntctl namespace update --add_bad_binary <value>\n```\n\n### --clusters\n\nSpecify a list of [Temporal Clusters](/concepts/what-is-a-temporal-cluster) when updating a [Namespace](/concepts/what-is-a-namespace).\n\nThe list contains the names of Clusters (separated by spaces) to which the Namespace can fail over.\n\nThis modifier is valid only when the `--global_namespace` modifier is set to true.\n\n**Example**\n\n```bash\ntctl namespace update --clusters <names>\n```\n\n### --description\n\nSpecify a description when updating a [Namespace](/concepts/what-is-a-namespace).\n\n**Example**\n\n```bash\ntctl namespace update --description <value>\n```\n\n### --history_archival_state\n\nSet the state of [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n\n**Example**\n\n```bash\ntctl namespace update --history_archival_state <value>\n```\n\n### --history_uri\n\nSpecify the URI for URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n\n**Example**\n\n```bash\ntctl namespace update --history_uri <uri>\n```\n\n### --namespace_data\n\nSpecify data for a [Namespace](/concepts/what-is-a-namespace) in the form of key-value pairs (such as `k1:v1,k2:v2,k3:v3`).\n\n**Example**\n\n```bash\ntctl namespace update --namespace_data <data>\n```\n\n### --owner_email\n\nSpecify the email address of the [Namespace](/concepts/what-is-a-namespace) owner.\n\n**Example**\n\n```bash\ntctl namespace update --owner_email <value>\n```\n\n### --reason\n\nSpecify a reason for updating a [Namespace](/concepts/what-is-a-namespace).\n\n**Example**\n\n```bash\ntctl namespace update --reason <value>\n```\n\n### --remove_bad_binary\n\nRemove a binary checksum.\n\nSee also [`--add_bad_binary`](#--add_bad_binary).\n\n**Example**\n\n```bash\ntctl namespace update --remove_bad_binary <value>\n```\n\n### --retention\n\nSpecify the number of days to retain [Workflow Executions](/workflows#workflow-execution).\n\n**Example**\n\n```bash\ntctl namespace update --retention <value>\n```\n\n### --visibility_archival_state\n\nSet the visibility state for [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n\n**Example**\n\n```bash\ntctl namespace update --visibility_archival_state <value>\n```\n\n### --visibility_uri\n\nSpecify the visibility URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n\n**Example**\n\n```bash\ntctl namespace update --visibility_uri <uri>\n```\n","is_empty":false},{"file_name":"dataconverter/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/dataconverter/index.md","id":"tctl-v1/dataconverter/index","title":"tctl dataconverter","description":"How to operate custom Data Converters using tctl.","label":"dataconverter","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl dataconverter` command enables custom [Data Converter](/concepts/what-is-a-data-converter) operations.\n\n- [tctl dataconverter web](/tctl-v1/dataconverter/web)\n","is_empty":false},{"file_name":"dataconverter/web.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/dataconverter/web.md","id":"tctl-v1/dataconverter/web","title":"tctl dataconverter web","description":"How to specify the WebSocket URL of a custom Data Converter using tctl.","label":"web","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl dataconverter web` command specifies the WebSocket URL of a custom [Data Converter](/concepts/what-is-a-data-converter) to use with Temporal Web.\n\n`tctl dataconverter web --web_ui_url <url>`\n\nThe following modifiers control the behavior of the command.\n\n### --port\n\nSpecify a port for the WebSocket URL of a custom [Data Converter](/concepts/what-is-a-data-converter).\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl dataconverter web --web_ui_url <url> --port <value>\n```\n\n### --web_ui_url\n\n_Required modifier_\n\nSpecify the WebSocket URL of a custom [Data Converter](/concepts/what-is-a-data-converter).\n\n**Example**\n\n```bash\ntctl dataconverter web --web_ui_url <url>\n```\n","is_empty":false},{"file_name":"cluster/get-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/cluster/get-search-attributes.md","id":"tctl-v1/cluster/get-search-attributes","title":"tctl cluster get-search-attributes","description":"How to list all Search Attributes using tctl.","label":"get-search-attributes","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl cluster get-search-attributes` command lists all [Search Attributes](/concepts/what-is-a-search-attribute) that can be used in the `--query` modifier of the [`tctl workflow list`](/tctl-v1/workflow/list) command and the `--search_attr_key` and `--search_attr_value` modifiers of the [`tctl workflow run`](/tctl-v1/workflow/run) and [`tctl workflow start`](/tctl-v1/workflow/start) commands.\n\n**Example:**\n\n```bash\ntctl cluster get-search-attributes\n```\n\nThe command has no modifiers.\n\nExample output:\n\n```text\n+-----------------------+----------+\n|         NAME          |   TYPE   |\n+-----------------------+----------+\n| BinaryChecksums       | Keyword  |\n| CloseTime             | Int      |\n| CustomBoolField       | Bool     |\n| CustomDatetimeField   | Datetime |\n| CustomDoubleField     | Double   |\n| CustomIntField        | Int      |\n| CustomKeywordField    | Keyword  |\n| CustomNamespace       | Keyword  |\n| CustomStringField     | String   |\n| ExecutionStatus       | Int      |\n| ExecutionTime         | Int      |\n| Operator              | Keyword  |\n| RunId                 | Keyword  |\n| StartTime             | Int      |\n| TaskQueue             | Keyword  |\n| TemporalChangeVersion | Keyword  |\n| WorkflowId            | Keyword  |\n| WorkflowType          | Keyword  |\n+-----------------------+----------+\n```\n\nThe admin version of this command displays default and custom Search Attributes separately, and also shows the underlying Elasticsearch index schema and system Workflow status.\n","is_empty":false},{"file_name":"cluster/health.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/cluster/health.md","id":"tctl-v1/cluster/health","title":"tctl cluster health","description":"How to check the health of the Frontend Service using tctl.","label":"health","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl cluster health` command checks the health of the [Frontend Service](/concepts/what-is-a-temporal-cluster#frontend-service).\n\n`tctl cluster health`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"cluster/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/cluster/index.md","id":"tctl-v1/cluster/index","title":"tctl cluster","description":"How to operate Temporal Clusters using tctl.","label":"cluster","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl cluster` command enables [Temporal Cluster](/concepts/what-is-a-temporal-cluster) operations.\n\n- [tctl cluster health](/tctl-v1/cluster/health)\n- [tctl cluster get-search-attributes](/tctl-v1/cluster/get-search-attributes)\n","is_empty":false},{"file_name":"batch/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/batch/describe.md","id":"tctl-v1/batch/describe","title":"tctl batch describe","description":"How to describe the progress of a batch job using tctl.","label":"describe","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl batch describe` command describes the progress of a batch job.\n\n`tctl batch describe --job_id <id>`\n\n:::note\n\n`tctl` can run `batch` and `batch-v2` commands.\n\n:::\n\nThe following modifier controls the behavior of the command.\n\n### --job_id\n\n_Required modifier_\n\nSpecify the job ID of a batch job.\n\n**Example**\n\n```bash\ntctl batch describe --job_id <id>\n```\n","is_empty":false},{"file_name":"batch/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/batch/index.md","id":"tctl-v1/batch/index","title":"tctl batch","description":"A tctl batch command enables you to affect multiple existing Workflow Executions with a single command.","label":"batch","tags":["tctl"],"ssdi":[],"markdown_content":"\n**How to run a tctl batch command.**\n\nA `tctl batch` command enables you to affect multiple existing [Workflow Executions](/workflows#workflow-execution) with a single command.\nA batch job runs in the background and affects Workflow Executions one at a time.\n\nUse [tctl batch start](/tctl-v1/batch/start) to start a batch job.\n\n:::note\n\n`tctl-v1` can run `batch` and `batch-v2` commands.\n\n:::\n\nWhen starting a batch job, you must provide a [List Filter](/concepts/what-is-a-list-filter) and the type of batch job that should occur.\nBatch jobs run in the background and affect Workflow Executions one at a time.\n\nThe List Filter identifies the set of Workflow Executions to be affected by the batch job.\nThe `tctl batch start` command shows you how many Workflow Executions will be affected by the batch job and asks you to confirm before proceeding.\n\nThe batch type determines what other parameters you must provide and what is being affected.\nThere are three types of batch jobs:\n\n- Signal: Send a Signal to the set of Workflow Executions that the List Filter specifies.\n- Cancel: Cancel the set of Workflow Executions that the List Filter specifies.\n- Terminate: Terminate the set of Workflow Executions that the List Filter specifies.\n\nA successfully started batch job returns a Job ID.\nYou can use this Job ID in the `tctl batch describe` command, which describes the progress of a specific batch job.\n\nYou can also use the Job ID to terminate the batch job itself.\nTerminating a batch job does not roll back the operations already performed by the batch job.\n\n### tctl batch commands\n\n- [tctl batch describe](/tctl-v1/batch/describe)\n- [tctl batch list](/tctl-v1/batch/list)\n- [tctl batch start](/tctl-v1/batch/start)\n- [tctl batch terminate](/tctl-v1/batch/terminate)\n","is_empty":false},{"file_name":"batch/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/batch/list.md","id":"tctl-v1/batch/list","title":"tctl batch list","description":"How to list batch jobs using tctl.","label":"list","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl batch list` command lists all batch jobs.\n\n`tctl batch list <modifiers>`\n\n:::note\n\n`tctl-v1` can run `batch` and `batch-v2` commands.\n\n:::\n\nThe following modifier controls the behavior of the command.\n\n### --pagesize\n\nSpecify the maximum number of batch jobs to list on a page. The default value is 30.\n\n**Example**\n\n```bash\ntctl batch list --pagesize <value>\n```\n","is_empty":false},{"file_name":"batch/start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/batch/start.md","id":"tctl-v1/batch/start","title":"tctl batch start","description":"How to start a batch job using tctl.","label":"start","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl batch start` command starts a batch job.\n\n`tctl batch start --query <value> <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### `--query`\n\n_Required modifier_\n\nSpecify the [Workflow Executions](/workflows#workflow-execution) that this batch job should operate.\n\nThe SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute) is the same as used by the `tctl workflow list --query` command.\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl batch start --query <value>\n```\n\n### `--reason`\n\nSpecify a reason for running this batch job.\n\n**Example**\n\n```bash\ntctl batch start --query <value> --reason <string>\n```\n\n### `--batch_type`\n\nSpecify the operation that this batch job performs. The supported operations are `signal`, `cancel`, and `terminate`.\n\n**Example**\n\n```bash\ntctl batch start --query <value> --batch_type <operation>\n```\n\n### `--signal_name`\n\nSpecify the name of a [Signal](/concepts/what-is-a-signal). This modifier is required when `--batch_type` is `signal`.\n\n**Example**\n\n```bash\ntctl batch start --query <value> --batch_type signal --signal_name <name>\n```\n\n### `--input`\n\nPass input for the [Signal](/concepts/what-is-a-signal). Input must be in JSON format.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl batch start --query <value> --input <json>\n```\n\n### `--rps`\n\nSpecify RPS of processing. The default value is 50.\n\n**Example**\n\n```bash\ntctl batch start --query <value> --rps <value>\n```\n\n### `--yes`\n\nDisable the confirmation prompt.\n\nAlias: `y`\n\n**Example**\n\n```bash\ntctl batch start --query <value> --yes\n```\n","is_empty":false},{"file_name":"batch/terminate.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/batch/terminate.md","id":"tctl-v1/batch/terminate","title":"tctl batch terminate","description":"How to terminate a batch job using tctl.","label":"terminate","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl batch terminate` command terminates a batch job.\n\n`tctl batch terminate --job_id <id> <modifiers>`\n\n:::note\n\n`tctl-v1` can run `batch` and `batch-v2` commands.\n\n:::\n\nThe following modifiers control the behavior of the command.\n\n### `--job_id`\n\n_Required modifier_\n\nSpecify the job ID of a batch job.\n\n**Example**\n\n```bash\ntctl batch terminate --job_id <id>\n```\n\n### `--reason`\n\nSpecify a reason for terminating this batch job.\n\n**Example**\n\n```bash\ntctl batch terminate --job_id <id> --reason <string>\n```\n","is_empty":false},{"file_name":"admin/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/index.md","id":"tctl-v1/admin/index","title":"tctl admin","description":"How to run admin-level tctl commands.","label":"admin","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nA `tctl admin` command allows the user to run admin operations.\n\nModifiers:\n\n#### --help\n\n`tctl admin [--help | -h]`\n","is_empty":false},{"file_name":"admin/workflow/delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/workflow/delete.md","id":"tctl-v1/admin/workflow/delete","title":"tctl admin workflow delete","description":"Deleting the Workflow Execution.","label":"delete","tags":["tctl","admin","workflow"],"ssdi":[],"markdown_content":"\nThe `tctl admin workflow delete` command deletes the current [Workflow Execution](/workflows/#workflow-execution) and the mutableState record.\n\n#### --db_engine value\n\nThe type of database (DB) engine to use.\n\nDefault: \"cassandra\"\nValues: \"cassandra\", \"mysql\", \"postgres\"\n\n#### --db_address value\n\nPersistence address for the database.\n\nDefault: 127.0.0.1\n\n#### --db_port value\n\nPersistence port for the database.\n\nDefault: 9042\n\n#### --username value\n\nUsername entered into the database.\n\n#### --password value\n\nPassword entered into the database.\n\n#### --keyspace value\n\nKeyspace for the database.\n\ndefault: \"temporal\"\n\n#### --url value\n\nURL of the Elasticsearch cluster.\n\nDefault: \"http://127.0.0.1:9200\"\n\n#### --es-username value\n\nUsername for the Elasticsearch cluster.\n\n#### --es-password value\n\nPassword for the Elasticsearch cluster.\n\n#### --version value\n\nThe version of the Elasticsearch cluster for the Workflow.\n\nDefault: v7\n\nValues: v6, v7\n\n#### --index value\n\nElasticsearch index name.\n\n#### --workflow_id value\n\nAlias: `-w`\n\nThe Id of the current Workflow.\n\n#### --run_id value\n\nAlias: `-r`\n\nThe Id of the current run.\n\n#### --skip_errors\n\nSkip any errors that occur in the Workflow Execution.\n\n#### --tls\n\nEnables TLS over the database connection.\n\n:::note\n\nTLS must be enabled to use the following modifiers.\n\n:::\n\n#### --tls_cert_path value\n\nDB tls client cert path.\n\nNote: tls must be enabled\n\n#### --tls_key_path value\n\nDB tls client key path\n\nNote: tls must be enabled\n\n#### --tls_ca_path value\n\nDB tls client ca path\n\nNote: tls must be enabled\n\n#### --tls_server_name value\n\nDB tls server name\n\nNote: tls must be enabled\n\n#### --tls_disable_host_verification\n\nDB tls verify hostname and server cert\n\nNote: tls must be enabled\n","is_empty":false},{"file_name":"admin/workflow/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/workflow/describe.md","id":"tctl-v1/admin/workflow/describe","title":"tctl admin workflow describe","description":"Description of Workflow Execution.","label":"describe","tags":["tctl","admin","workflow"],"ssdi":[],"markdown_content":"\nThe `tctl admin workflow describe` command describes internal information of the current [Workflow Execution](/workflows/#workflow-execution).\n\n#### --workflow_id value\n\nAlias: `-w`\n\nThe Id of the current Workflow.\n\n#### --run_id value\n\nAlias: `-r`\n\nThe Id of the current run.\n","is_empty":false},{"file_name":"admin/workflow/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/workflow/index.md","id":"tctl-v1/admin/workflow/index","title":"tctl admin workflow","description":"Operating admin-level Workflow Executions.","label":"workflow","tags":["tctl","admin","workflow"],"ssdi":[],"markdown_content":"\nThe `tctl admin workflow` commands enable administrator-level operations on Workflow Executions.\n\n`tctl admin workflow command [modifiers] [arguments...]`\n\n- [show](/tctl-v1/admin/workflow/show)\n\n- [describe](/tctl-v1/admin/workflow/describe)\n\n- [refresh_tasks](/tctl-v1/admin/workflow/refresh_tasks)\n\n- [delete](/tctl-v1/admin/workflow/delete)\n","is_empty":false},{"file_name":"admin/workflow/refresh_tasks.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/workflow/refresh_tasks.md","id":"tctl-v1/admin/workflow/refresh_tasks","title":"tctl admin workflow refresh_tasks","description":"Refreshing Workflow Tasks.","label":"refresh_tasks","tags":["tctl","admin","workflow"],"ssdi":[],"markdown_content":"\nThe `tctl admin workflow refresh_tasks` command updates all [Tasks](/concepts/what-is-a-task) in a [Workflow](/concepts/what-is-a-workflow), provided that the command can fetch new information for Tasks.\n\n#### --workflow_id value\n\nAlias: `-w`\n\nThe Id of the current Workflow.\n\n#### --run_id value\n\nAlias: `-r`\n\nThe Id of the current run.\n","is_empty":false},{"file_name":"admin/workflow/show.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/workflow/show.md","id":"tctl-v1/admin/workflow/show","title":"tctl admin workflow show","description":"Showing Workflow history.","label":"show","tags":["tctl","admin","workflow"],"ssdi":[],"markdown_content":"\nThe `tctl admin workflow show` command displays Workflow history from the database.\n\n#### --workflow_id value\n\nAlias: `-w`\n\nThe current Workflow.\n\n#### --run_id value\n\nAlias: `-r`\n\nThe current RunId.\n\n#### --min_event_id value\n\nThe minimum Event Id to include in the history.\n\nDefault: 0\n\n#### --max_event_id value\n\nThe maximum Event Id to include in the history.\n\nDefault: 0\n\n#### --min_event_version value\n\nThe start Event version to be included in the history.\n\nDefault: 0\n\n#### --max_event_version value\n\nThe end Event version to be included in the history.\n\nDefault: 0\n\n#### --output_filename value\n\nThe file where the output is sent to.\n","is_empty":false},{"file_name":"admin/shard/close_shard.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/shard/close_shard.md","id":"tctl-v1/admin/shard/close_shard","title":"tctl admin shard close_shard","description":"closing a shard with a given shard Id","label":"close_shard","tags":["tctl","admin","shard"],"ssdi":[],"markdown_content":"\nThe `tctl admin shard close_shard` command closes a shard with an Id that corresponds to the value given in the command.\n\n`tctl admin shard close_shard [command options] [arguments...]`\n\nThe modifier below will change the behavior and output of the command.\n\n#### --share_id value\n\nShareId managed by the Temporal Cluster.\n","is_empty":false},{"file_name":"admin/shard/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/shard/describe.md","id":"tctl-v1/admin/shard/describe","title":"tctl admin shard describe","description":"Describes Id of shard.","label":"describe","tags":["tctl","admin","shard"],"ssdi":[],"markdown_content":"\nThe `tctl admin shard describe` command shows the Id for the specified shard.\n\nThe modifier below controls the behavior of the command.\n\n#### --share_id value\n\nThe Id of the shard to describe\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/shard/describe_task.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/shard/describe_task.md","id":"tctl-v1/admin/shard/describe_task","title":"tctl admin shard describe_task","description":"displaying information on a Task within a shard","label":"describe_task","tags":["tctl","admin","shard"],"ssdi":[],"markdown_content":"\nThe `tctl admin shard describe_task` command describes a specified Task's Task Id, Task type, shard Id, and task visibility timestamp.\n\nThe modifiers below control the output and behavior of the command. Enter all modifiers after the command as such:\n\n`tctl admin shard describe_task <modifiers>`\n\n#### --db_engine\n\nThe type of database (DB) engine for the shard to use.\n\nDefault: \"cassandra\"\n\nValues: \"cassandra\", \"mysql\", \"postgres\"\n\n<!-- todo: examples -->\n\n#### --db_address\n\nPersistence address for the database.\n\nDefault: 127.0.0.1\n\n#### --db_port\n\nPersistence port for the database.\n\nDefault: 9042\n\n#### --username\n\nUsername entered into the database.\n\n#### --password\n\nPassword entered into the database.\n\n#### --keyspace\n\nKeyspace for the database.\n\ndefault: \"temporal\"\n\n#### --tls\n\nEnables TLS over the database connection.\n\n#### --tls_cert_path\n\nDB tls client cert path.\n\nNote: tls must be enabled\n\n#### --tls_server_name\n\nDB tls server name\n\nNote: tls must be enabled\n\n#### --tls_disable_host_verification\n\nDB tls verify hostname and server cert\n\nNote: tls must be enabled\n\n#### --shard_id\n\nIdentifies the specified shard.\n\nDefault: 0\n\n#### --task_id\n\nDescribes the task.\n\nDefault: 0\n\n#### --task_type\n\nThe kind of Task that is targeted within a shard.\n\nDefault: transfer\n\nValues: transfer, timer, replication\n\n#### --task_timestamp\n\nTask visibility timestamp in nanoseconds\n\nDefault: 0\n\n#### --target_cluster\n\nTemporal cluster for the shard to use.\n\nDefault: \"active\"\n","is_empty":false},{"file_name":"admin/shard/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/shard/index.md","id":"tctl-v1/admin/shard/index","title":"tctl admin shard","description":"Admin-level operations on a specific shard","label":"shard","tags":["tctl","admin","shard"],"ssdi":[],"markdown_content":"\nThe `tctl admin shard` commands enable admin-level operations on a specified shard.\n\n#### tctl admin shard commands\n\n- [describe](/tctl-v1/admin/shard/describe)\n- [describe_task](/tctl-v1/admin/shard/describe_task)\n- [list_tasks](/tctl-v1/admin/shard/list_tasks)\n- [close_shard](/tctl-v1/admin/shard/close_shard)\n- [remove_task](/tctl-v1/admin/shard/remove_task)\n","is_empty":false},{"file_name":"admin/shard/list_tasks.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/shard/list_tasks.md","id":"tctl-v1/admin/shard/list_tasks","title":"tctl admin shard list_tasks","description":"listing tasks for a given shard Id and Task type","label":"list_tasks","tags":["tctl","admin","shard"],"ssdi":[],"markdown_content":"\nThe `tctl admin shard list_tasks` command will list the Tasks available for a given shard Id and Task type.\n\nThe modifiers below affect the output and behavior of the command.\n\n#### --more\n\nLists more pages of list tasks.\nThe default setting is to list one page of 10 list tasks.\n\n#### --pagesize value\n\nThe size of the result page.\nDefault: 10\n\n#### --target_cluster value\n\nTemporal cluster to use.\nDefault: \"active\"\n\n#### --shard_id value\n\nThe ID of the shard\n\nDefault: 0\n\n#### --task_type value\n\nThe type of Task.\n\nDefault: transfer\nValues: transfer, timer, replication, visibility\n\n#### --min_visibility_ts value\n\nThe minimum value that can be set as a Task Visibility timestamp.\n\nSupported formats include:\n\n- '2006-01-02T15:04:05+07:00'\n- Raw UnixNano\n- Time range (N-duration), where 0 < N < 1000000 and duration (full-notation/short-notation) can be:\n  - second/s\n  - minute/m\n  - week/w\n  - month/m\n  - year/y\n\n#### --max_visibility_ts value\n\nThe maximum value that can be set as a Task Visibility timestamp.\n\nSupported formats:\n\n- '2006-01-02T15:04:05+07:00'\n- Raw UnixNano\n- Time range (N-duration), where 0 < N < 1000000 and duration (full-notation/short-notation) can be:\n  - second/s\n  - minute/m\n  - week/w\n  - month/m\n  - year/y\n","is_empty":false},{"file_name":"admin/shard/remove_task.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/shard/remove_task.md","id":"tctl-v1/admin/shard/remove_task","title":"tctl admin shard remove_task","description":"removing a Task with given information","label":"remove_task","tags":["tctl","admin","shard"],"ssdi":[],"markdown_content":"\nThe `tctl admin shard remove_task` command removes a Task from the shard.\n\n`tctl admin shard remove_task [command options] [arguments...]`\n\nThe Task removed must have values that matches what is given in the command line.\n\nThe modifiers below change the behavior of the command.\n\n#### --shard_id value\n\nThe shardId for the Task to be removed.\n\nDefault: 0\n\n#### --task_id value\n\nThe taskId for the Task to be removed.\n\nDefault: 0\n\n#### --task_type value\n\nThe type of Task to remove.\n\nDefault: transfer\n\nValues: transfer, timer, replication\n\n#### --task_timestamp value\n\nThe task visibility timestamp, given in nanoseconds.\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/membership/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/membership/index.md","id":"tctl-v1/admin/membership/index","title":"tctl admin membership","description":"Run admin operations on membership","label":"membership","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl admin membership` command allows admin operations to be run on membership items.\n\n### Usage\n\n`tctl admin membership command [command modifiers] [arguments...]`\n\n### Commands\n\n- [list_gossip](/tctl-v1/admin/membership/list_gossip)\n- [list_db](/tctl-v1/admin/membership/list_db)\n","is_empty":false},{"file_name":"admin/membership/list_db.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/membership/list_db.md","id":"tctl-v1/admin/membership/list_db","title":"tctl admin membership list_db","description":"How to describe Cluster membership items","label":"list_db","tags":["operation-guide","tctl"],"ssdi":[],"markdown_content":"\nThe `tctl admin membership list_db` command lists the Cluster items in a targeted membership.\n\nThe following modifiers change the behavior of the command.\n\n#### --heartbeated_within\n\nFilters the list by last Heartbeat time.\n\n<!-- todo: add supported format list-->\n\n#### --role\n\nFilters the results by membership role.\n\nDefault: all\nValues: all, frontend, history, matching, worker\n","is_empty":false},{"file_name":"admin/membership/list_gossip.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/membership/list_gossip.md","id":"tctl-v1/admin/membership/list_gossip","title":"tctl admin membership list_gossip","description":"How to describe ringpop membership items","label":"list_gossip","tags":["operation-guide","tctl"],"ssdi":[],"markdown_content":"\nThe `tctl admin membership list_gossip` command lists the ringpop membership items present on the targeted membership.\n\nThe following modifier changes the behavior of the command:\n\n#### --role value\n\nFilters the results by membership role\n\nDefault: all\nValues: all, frontend, history, matching, worker\n","is_empty":false},{"file_name":"admin/history_host/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/history_host/describe.md","id":"tctl-v1/admin/history_host/describe","title":"tctl admin history_host describe","description":"Describing the information in a history host","label":"describe","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl admin history_host describe` command describes the internal information of history host.\n\nThe following modifiers change the behavior of the command.\n\n#### --workflow_id\n\nAlias: `-w`\n\nThe WorkflowId of the Workflow whose history host is to be described.\n\n#### --history_address\n\nThe history address of the history host.\n\n#### --shard_id\n\nThe Id of the shard that belongs to the history host.\n\n#### --print_full\n\nPrint a full and detailed summary of the history host.\n","is_empty":false},{"file_name":"admin/history_host/get_shardid.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/history_host/get_shardid.md","id":"tctl-v1/admin/history_host/get_shardid","title":"tctl admin history_host get_shardid","description":"Providing the shardId on command","label":"get_shardid","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl admin history_host get_shardid` command gets the `shardId` for a given `namespaceId` and `workflowId`.\n\nThe following modifiers change the behavior of this command.\n\n#### --namespace_id\n\nThe `namespaceId` of the history host where we're getting the `shardId`.\n\n#### --workflow_id\n\nAlias: `-w`\n\nThe WorkflowId of the history host where we're getting the shardId.\n\n#### --number_of_shards\n\nThe total amount of shards for the Temporal Cluster.\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/history_host/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/history_host/index.md","id":"tctl-v1/admin/history_host/index","title":"tctl admin history_host","description":"Overview of history_host commands","label":"history_host","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl admin history_host` command runs an admin-level operation on the history host.\n\n## Usage\n\n`tctl admin history_host command [command options] [arguments...]`\n\n## Commands\n\n- [tctl admin history_host describe](/tctl-v1/admin/history_host/describe)\n- [tctl admin history_host get_shardid](/tctl-v1/admin/history_host/get_shardid)\n","is_empty":false},{"file_name":"admin/dlq/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/dlq/index.md","id":"tctl-v1/admin/dlq/index","title":"tctl admin dlq","description":"Running admin operations on DLQ.","label":"dlq","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin dlq` commands run admin operations on a given dead-letter queue (DLQ).\n\n`tctl admin dlq command [command modifiers] [arguments...]`\n\n- [tctl admin dlq read](/tctl-v1/admin/dlq/read)\n- [tctl admin dlq purge](/tctl-v1/admin/dlq/purge)\n- [tctl admin dlq merge](/tctl-v1/admin/dlq/merge)\n","is_empty":false},{"file_name":"admin/dlq/merge.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/dlq/merge.md","id":"tctl-v1/admin/dlq/merge","title":"tctl admin dlq merge","description":"Merging DLQ messages.","label":"merge","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admib dlq merge` command allows dead-letter queue (DLQ) messages to be merged.\n\nThe messages must have TaskIds with an equal or lesser value than the given TaskId.\n\n#### --dlq_type\n\nThe type of DLQ to manage.\n\nOptions: namespace, history\n\n#### --cluster\n\nSource cluster for the DLQ.\n\n#### --shard_id\n\nShardId provided for the command.\n\n#### --last_message_id\n\nIdentifies the last read message.\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/dlq/purge.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/dlq/purge.md","id":"tctl-v1/admin/dlq/purge","title":"tctl admin dlq purge","description":"Deleting DLQ messages.","label":"purge","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin dlq purge` command deletes DLQ messages that have a Task Id equal to or less than the provided Task Id.\n\n#### --dlq_type\n\nThe type of DLQ to manage.\n\nOptions: namespace, history\n\n#### --cluster\n\nSource cluster for the DLQ.\n\n#### --shard_id\n\nShardId provided for the command.\n\n#### --last_message_id\n\nIdentifies the last read message.\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/dlq/read.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/dlq/read.md","id":"tctl-v1/admin/dlq/read","title":"tctl admin dlq read","description":"Reading DLQ messages.","label":"read","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin dlq read` command reads out messages from the dead-letter queue (DLQ).\n\n---\n\n#### --dlq_type\n\nThe type of DLQ to manage.\n\nOptions: namespace, history\n\n#### --cluster\n\nSource cluster for the DLQ.\n\n#### --shard_id\n\nShardId provided for the command.\n\n#### --max_message_count\n\nThe maximum number of messages to fethc.\n\nDefault: 0\n\n#### --last_message_id\n\nIdentifies the last read message.\n\nDefault: 0\n\n#### --output_filename\n\nProvides a file to write output to.\n\nOutput is written to stdout on default.\n","is_empty":false},{"file_name":"admin/decode/base64.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/decode/base64.md","id":"tctl-v1/admin/decode/base64","title":"tctl admin decode base64","description":"Decoding Payloads to Base64.","label":"base64","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin decode base64` command decodes base64 Payloads.\n\n#### --base64_data\n\nDecoded data in base64 format.\n\n#### --base64_file\n\nCreates a file with data in base64 format.\n","is_empty":false},{"file_name":"admin/decode/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/decode/index.md","id":"tctl-v1/admin/decode/index","title":"tctl admin decode","description":"Decoding payloads.","label":"decode","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin decode` command allows the user to decode payloads sent and received from executed Activities.\n\n`tctl admin decode command [command modifiers] [arguments...]`\n\n- [proto](/tctl-v1/admin/decode/proto)\n- [base64](/tctl-v1/admin/decode/base64)\n","is_empty":false},{"file_name":"admin/decode/proto.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/decode/proto.md","id":"tctl-v1/admin/decode/proto","title":"tctl admin decode proto","description":"Decoding proto payloads.","label":"proto","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin decode proto` command decodes the Payload to proto format.\n\n#### --type\n\nThe full name of the proto type to decode the Payload to.\n\n#### --hex_data\n\nDecodes the data to hex format.\n\n#### --hex_file\n\nCreates a file with the decoded hex data.\n\n#### --binary_file\n\nCreates a file with the decoded binary data.\n","is_empty":false},{"file_name":"admin/db/clean.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/db/clean.md","id":"tctl-v1/admin/db/clean","title":"tctl admin db clean","description":"How to clean up corrupted Workflows using tctl.","label":"clean","tags":["tctl","admin","db"],"ssdi":[],"markdown_content":"\nThe `tctl admin db clean` command cleans corrupted [Workflow Executions](/workflows/#workflow-executions) from the targeted database.\n\nThe modifiers below change the behavior of the command.\n\n#### --db_engine\n\nType of DB engine to use\n\nDefault: `cassandra`\nValue: `cassandra` | `mysql` | `postgres`\n\n#### --db_address\n\nPersistence address for the database.\n\nDefault: 127.0.0.1\n\n#### --db_port\n\nPersistence port for the DB.\n\nDefault: 9042\n\n#### --username\n\nDatabase username.\n\n#### --password\n\nDatabase password.\n\n#### --keyspace\n\nDatabase keyspace\n\nDefault: \"temporal\"\n\n#### --input_directory\n\nThe directory which contains the corrupted [Workflow Execution](/workflows/#workflow-executions) files from running [`scan`](/tctl-v1/admin/db/scan).\n\n#### --lower_shard_bound\n\nThe minimum amount (inclusive) of corrupt shards to handle.\n\nDefault: 0\n\n#### --upper_shard_bound\n\nThe maximum amount (exclusive) of corrupt shards to handle.\n\nDefault: 16384\n\n#### --starting_rps\n\nstarting rps of database queries.\n\nDefault: 100\n\n#### --rps\n\nTarget rps of database queries.\n\nDefault: 7000\n\n#### --concurrency\n\nNumber of threads to handle a scan.\n\nDefault: 1000\n\n#### --report_rate\n\nThe number of shards handled between each emittance of progress.\n\nDefault: 10\n\n:::note\n\nEnable `--tls` before using any of the following modifiers.\n\n:::\n\n#### --tls_cert_path\n\nWhere the tls client cert is located.\n\n#### --tls_key_path\n\nWhere the tls key is located.\n\n#### --tls_ca_pat\n\nWhere the tls ca is located.\n\n#### --tls_server_name\n\nThe name of the Db tls server.\n\n#### --tls_disable_host_verification\n\nDisables verification of the DB tls hostname and server cert.\n","is_empty":false},{"file_name":"admin/db/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/db/index.md","id":"tctl-v1/admin/db/index","title":"tctl admin db","description":"Running admin operations on database - tctl - admin - db","label":"db","ssdi":[],"markdown_content":"\nThe `tctl admin db` command runs administrator-level operations on a given database.\n\n### Usage\n\n`tctl admin db command [command modifiers] [arguments...]`\n\n### Commands\n\n- [tctl admin db scan](/tctl-v1/admin/db/scan)\n- [tctl admin db clean](/tctl-v1/admin/db/clean)\n","is_empty":false},{"file_name":"admin/db/scan.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/db/scan.md","id":"tctl-v1/admin/db/scan","title":"tctl admin db scan","description":"Scanning for corrupted executions in a database","label":"scan","tags":["tctl","admin","db"],"ssdi":[],"markdown_content":"\nThe `tctl admin db scan` command scans concrete Workflow Executions in a given database, and detects corrupted ones.\n\n#### --db_engine\n\nType of DB engine to use\n\nDefault: `cassandra`\nValue: `cassandra` | `mysql` | `postgres`\n\n#### --db_address\n\nPersistence address for the DB.\n\nDefault: 127.0.0.1\n\n#### --db_port\n\nPersistence port for the DB.\n\nDefault: 9042\n\n#### --username\n\nDB username.\n\n#### --password\n\nDB password.\n\n#### --keyspace\n\nDB keyspace\n\nDefault: \"temporal\"\n\n#### --lower_shard_bound value\n\nThe minimum amount (inclusive) of corrupt shards to handle.\n\nDefault: 0\n\n#### --upper_shard_bound\n\nThe maximum amount (exclusive) of corrupt shards to handle.\n\nDefault: 16384\n\n#### --starting_rps\n\nstarting rps of database queries.\n\nDefault: 100\n\n#### --rps value\n\nTarget rps of database queries.\n\nDefault: 7000\n\n#### --pagesize\n\nThe size of the page used to query database executions.\n\nDefault: 500\n\n#### --concurrency\n\nNumber of threads to handle a scan.\n\nDefault: 1000\n\n#### --report_rate\n\nThe number of shards handled between each emittance of progress.\n\nDefault: 10\n\n#### --tls\n\nEnable TLS over the DB connection.\n\n:::note\n\nEnable `--tls` before using any of the following modifiers.\n\n:::\n\n#### --tls_cert_path\n\nWhere the tls client cert is located.\n\n#### --tls_key_path\n\nWhere the tls key is located.\n\n#### --tls_ca_path\n\nWhere the tls ca is located.\n\n#### --tls_server_name\n\nThe name of the Db tls server.\n\n#### --tls_disable_host_verification\n\nDisables verification of the DB tls hostname and server cert.\n","is_empty":false},{"file_name":"admin/cluster/add-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/cluster/add-search-attributes.md","id":"tctl-v1/admin/cluster/add-search-attributes","title":"tctl admin cluster add_search_attributes","description":"Adding custom Search Attributes to a Cluster.","label":"add_search_attributes","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin cluster add-search-attributes` command allows Search Attributes to be added to a Cluster.\nCustom Search Attributes can be used to make a Cluster more identifiable.\n\n:::note\nDue to Elasticsearch limitations, you can only add new custom Search Attributes. Existing Search Attributes cannot be renamed or removed from the Elasticsearch index.\n:::\n\nUse this command to add custom Search Attributes to your Temporal Cluster:\n\n```bash\ntctl admin cluster add-search-attributes --name <SearchAttributeName> --type <SearchAttributeValueType>\n```\n\n:::note\nIf you are adding custom Search Attributes to a Cluster running from the `docker-compose-es.yml` file in the [temporalio/docker-compose](https://github.com/temporalio/docker-compose) repo, make sure to increase the Docker memory to more than 6 GB.\n:::\n\n#### --skip_schema_update\n\nAllows the user to skip the Elasticsearch index schema update.\n\n:::note\nThis will only register in metadata.\n:::\n\n#### --name\n\nThe name of the Search Attribute to add. Names can have multiple values.\n\nSearch Attribute names are case sensitive.\n\n#### --type\n\nThe type of Search Attribute to add.\nMultiple values can be added at once.\n\nValues: Text, Keyword, Int, Double, Bool, Datetime\n","is_empty":false},{"file_name":"admin/cluster/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/cluster/describe.md","id":"tctl-v1/admin/cluster/describe","title":"tctl admin cluster describe","description":"Displaying Cluster information.","label":"describe","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin cluster describe` command provides information for the current Cluster.\n\nThe following modifier changes the behavior of the command:\n\n#### --cluster_value\n\nThe name of the remote Cluster within the current Cluster.\n\nThis modifier is optional, and can default to the return of current Cluster information.\n","is_empty":false},{"file_name":"admin/cluster/get-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/cluster/get-search-attributes.md","id":"tctl-v1/admin/cluster/get-search-attributes","title":"tctl admin cluster get_search_attributes","description":"Showing existing search attributes.","label":"get_search_attributes","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin cluster get_search_attributes` command retrieves existing Search Attributes for a given Cluster.\n\nThe following modifier will change the behavior of the command:\n\n#### --print_json\n\nPrints the existing search attributes in JSON format.\n","is_empty":false},{"file_name":"admin/cluster/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/cluster/index.md","id":"tctl-v1/admin/cluster/index","title":"tctl admin cluster","description":"Running admin-level operations on clusters.","label":"cluster","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin cluster` command runs the administrator-level operations on a given Cluster.\n\n`tctl admin cluster command [command modifiers] [arguments...]`\n\n- [add_search_attributes](/tctl-v1/admin/cluster/add-search-attributes)\n- [remove_search_attributes](/tctl-v1/admin/cluster/remove-search-attributes)\n- [get_search_attributes](/tctl-v1/admin/cluster/get-search-attributes)\n- [describe](/tctl-v1/admin/cluster/describe)\n- [list](/tctl-v1/admin/cluster/list)\n- [upsert_remote_cluster](/tctl-v1/admin/cluster/upsert-remote-cluster)\n- [remove_remote_cluster](/tctl-v1/admin/cluster/upsert-remote-cluster)\n","is_empty":false},{"file_name":"admin/cluster/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/cluster/list.md","id":"tctl-v1/admin/cluster/list","title":"tctl admin cluster list","description":"Listing Cluster information.","label":"list","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin cluster list` command lists Cluster information on the given Cluster.\n\nDefault: 100\n\nThe modifier below changes the behavior of the command:\n\n#### --pagesize\n\nThe size of the page that the list is printed on.\n","is_empty":false},{"file_name":"admin/cluster/remove-remote-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/cluster/remove-remote-cluster.md","id":"tctl-v1/admin/cluster/remove-remote-cluster","title":"tctl admin cluster remove_remote_cluster","description":"Removing remote Clusters.","label":"remove_remote_cluster","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin cluster remove_remote_cluster` command removes remote Cluster information on the given Cluster.\n\nThe modifier below changes the behavior of the operation:\n\n#### --cluster\n\nThe name of the remote Cluster to remove.\n","is_empty":false},{"file_name":"admin/cluster/remove-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/cluster/remove-search-attributes.md","id":"tctl-v1/admin/cluster/remove-search-attributes","title":"tctl admin cluster remove_search_attributes","description":"Removing custom search metadat from a Cluster.","label":"remove_search_attributes","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\n> The Temporal tctl documentation covers version 1.17 of the Temporal CLI.\n\nThe `tctl admin cluster remove-search-attributes` command removes custom Search Attribute metadata from a Cluster.\nThis operation has no effect on Elasticsearch index schema.\n\nUse the following command to remove a [Search Attribute](/concepts/what-is-a-search-attribute) from a Cluster's metadata:\n\n```bash\ntctl admin cluster remove-search-attributes --name <SearchAttributeKey>\n```\n\nOnly custom Search Attributes can be removed from a Cluster's metadata.\nDefault Search Attributes cannot be removed.\n\nRemoving a Search Attribute removes it from the Cluster's metadata but does not remove it from the Elasticsearch index.\nThis means that the Search Attribute can be added back later as the same type.\nAfter a Search Attribute has been added to the Elasticsearch index, it cannot be changed.\n\nThe following modifier changes the behavior of the operation:\n\n#### --name\n\nName of the Search Attribute to remove.\n","is_empty":false},{"file_name":"admin/cluster/upsert-remote-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/admin/cluster/upsert-remote-cluster.md","id":"tctl-v1/admin/cluster/upsert-remote-cluster","title":"tctl admin cluster upsert_remote_cluster","description":"How to run admin-level tctl commands.","label":"upsert_remote_cluster","tags":["tctl","admin"],"ssdi":[],"markdown_content":"\nThe `tctl admin cluster upsert_remote_cluster` command adds or updates remote Cluster information in the current Cluster.\n\n#### --frontend_address\n\nThe remote Cluster frontend address.\n\n#### --enable_connection\n\nEnables remote Cluster connection.\n","is_empty":false},{"file_name":"activity/complete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/activity/complete.md","id":"tctl-v1/activity/complete","title":"tctl activity complete","description":"How to provide a result and complete an Activity Execution using tctl.","label":"complete","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl activity complete` command completes an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n`tctl activity complete <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify the [Workflow Id](/concepts/what-is-a-workflow-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to complete.\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl activity complete --workflow_id <id>\n```\n\n### --run_id\n\nSpecify the [Run Id](/concepts/what-is-a-run-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to complete.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl activity complete --run_id <id>\n```\n\n### --activity_id\n\nSpecify the [Activity Id](/concepts/what-is-an-activity-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to complete.\n\n**Example**\n\n```bash\ntctl activity complete --activity_id <id>\n```\n\n### --result\n\nSpecify the result of an [Activity Execution](/concepts/what-is-an-activity-execution) when using tctl to complete the Activity Execution.\n\n**Example**\n\n```bash\ntctl activity complete --result <value>\n```\n\n### --identity\n\nSpecify the identity of the operator when using tctl to complete an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n**Example**\n\n```bash\ntctl activity complete --identity <value>\n```\n","is_empty":false},{"file_name":"activity/fail.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/activity/fail.md","id":"tctl-v1/activity/fail","title":"tctl activity fail","description":"How to fail an Activity Execution using tctl.","label":"fail","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl activity fail` command fails an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n`tctl activity fail [<modifiers>]`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify the [Workflow Id](/concepts/what-is-a-workflow-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to fail.\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl activity fail --workflow_id <id>\n```\n\n### --run_id\n\nSpecify the [Run Id](/concepts/what-is-a-run-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to fail.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl activity fail --run_id <id>\n```\n\n### --activity_id\n\nSpecify the [Activity Id](/concepts/what-is-an-activity-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to fail.\n\n**Example**\n\n```bash\ntctl activity fail --activity_id <id>\n```\n\n### --reason\n\nSpecify the reason for failing an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n**Example**\n\n```bash\ntctl activity fail --reason <value>\n```\n\n### --detail\n\nSpecify details of the reason for failing an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n**Example**\n\n```bash\ntctl activity fail --detail <value>\n```\n\n### --identity\n\nSpecify the identity of the operator when using tctl to fail an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n**Example**\n\n```bash\ntctl activity complete --identity <value>\n```\n","is_empty":false},{"file_name":"activity/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/tctl-v1/activity/index.md","id":"tctl-v1/activity/index","title":"tctl activity","description":"How to operate Activity Executions using tctl.","label":"activity","tags":["tctl"],"ssdi":[],"markdown_content":"\nThe `tctl activity` commands enable [Activity Execution](/concepts/what-is-an-activity-execution) operations.\n\n- [tctl activity complete](/tctl-v1/activity/complete)\n- [tctl activity fail](/tctl-v1/activity/fail)\n","is_empty":false},{"file_name":"release-message.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/release-message.md","id":"cli/release-message","title":"Temporal CLI is now available","description":"Temporal CLI is now available for use.","label":"CLI (temporal)","ssdi":[],"markdown_content":"\n:::success Temporal CLI is now available!\n\nThe new [Temporal CLI](/cli) is available for use.\n\ntctl v1.17 can still be used with Temporal Server version 1.20 and is expected to be compatible with Temporal Server version 1.21.\n\ntctl is expected to be fully deprecated by Temporal Server version 1.22\n\n:::\n","is_empty":false},{"file_name":"workflow/cancel.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/cancel.md","id":"cli/workflow/cancel","title":"temporal workflow cancel","description":"Cancel a Workflow Execution.","label":"cancel","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow cancel` command cancels a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nCanceling a running Workflow Execution records a [`WorkflowExecutionCancelRequested` event](/references/events#workflow-execution-cancel-requested) in the [Event History](/concepts/what-is-an-event-history).\nA new [Workflow Task](/concepts/what-is-a-workflow-task) will be scheduled, and the Workflow Execution performs cleanup work.\n\n`temporal workflow cancel --workflow-id=meaningful-business-id`\n\nIn addition to Workflow IDs, Workflows can also be [Signaled](/concepts/what-is-a-signal) by a [Query](/concepts/what-is-a-query).\n`temporal workflow cancel --query=MyQuery`\n\nUse the options listed below to change the behavior of this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--query](/cli/cmd-options/query)\n\n- [--reason](/cli/cmd-options/reason)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n\n- [--yes](/cli/cmd-options/yes)\n","is_empty":false},{"file_name":"workflow/count.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/count.md","id":"cli/workflow/count","title":"temporal workflow count","description":"Count Workflow Executions (requires ElasticSearch to be enabled).","label":"count","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow count` command returns a count of [Workflow Executions](/concepts/what-is-a-workflow-execution).\nThis command requires Elasticsearch to be enabled.\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--query](/cli/cmd-options/query)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"workflow/delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/delete.md","id":"cli/workflow/delete","title":"temporal workflow delete","description":"Deletes a Workflow Execution.","label":"delete","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow delete` command deletes the specified [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"workflow/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/describe.md","id":"cli/workflow/describe","title":"temporal workflow describe","description":"Show information about a Workflow Execution.","label":"describe","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow describe` command shows information about a given [Workflow Execution](/concepts/what-is-a-workflow-execution).\nThis information can be used to locate Workflow Executions that weren't able to run successfully.\n\n`temporal workflow describe --workflow-id=meaningful-business-id`\n\nThe output of this command can be changed to show as printed ('raw') or to only show the Workflow Execution's auto-reset points.\n\n`temporal workflow describe --workflow-id=meaningful-business-id --raw=true --reset-points=true`\n\nUse the command options listed below to change the information returned by this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--raw](/cli/cmd-options/raw)\n\n- [--reset-points](/cli/cmd-options/reset-points)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"workflow/execute.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/execute.md","id":"cli/workflow/execute","title":"temporal workflow execute","description":"Start a new Workflow Execution and prints its progress.","label":"execute","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow execute` command starts a new [Workflow Execution](/concepts/what-is-a-workflow-execution) and prints its progress.\nThe command doesn't finish until the Workflow Execution completes.\n\nTo execute a [Workflow](/concepts/what-is-a-workflow) from the CLI:\n`temporal workflow execute --workflow-id=meaningful-business-id --type=MyWorkflow --task-queue=MyTaskQueue`\n\nSingle quotes('') are used to wrap input as JSON.\n\n`temporal workflow execute --workflow-id=meaningful-business-id --type-MyWorkflow --task-queue-MyTaskQueue --input='{\"JSON\": \"Input\"}'`\n\nUse the command options listed below to change how the Workflow Execution behaves during its run.\n\n- [--cron](/cli/cmd-options/cron)\n\n- [--execution-timeout](/cli/cmd-options/execution-timeout)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--id-reuse-policy](/cli/cmd-options/id-reuse-policy)\n\n- [--input](/cli/cmd-options/input)\n\n- [--input-file](/cli/cmd-options/input-file)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--max-field-length](/cli/cmd-options/max-field-length)\n\n- [--memo](/cli/cmd-options/memo)\n\n- [--memo-file](/cli/cmd-options/memo-file)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--run-timeout](/cli/cmd-options/run-timeout)\n\n- [--search-attribute](/cli/cmd-options/search-attribute)\n\n- [--task-queue](/cli/cmd-options/task-queue)\n\n- [--task-timeout](/cli/cmd-options/task-timeout)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--type](/cli/cmd-options/type)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"workflow/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/index.md","id":"cli/workflow/index","title":"temporal workflow index","description":"Operations that can be performed on Workflows.","label":"workflow","tags":["cli"],"ssdi":[],"markdown_content":"\n[Workflow](/concepts/what-is-a-workflow) commands allow operations to be performed on [Workflow Executions](/concepts/what-is-a-workflow-execution).\n","is_empty":false},{"file_name":"workflow/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/list.md","id":"cli/workflow/list","title":"temporal workflow list","description":"List Workflow Executions based on a Query.","label":"list","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow list` command provides a list of [Workflow Executions](/concepts/what-is-a-workflow-execution) that meet the criteria of a given [Query](/concepts/what-is-a-query).\nBy default, this command returns a list of up to 10 closed Workflow Executions.\n\n`temporal workflow list --query=MyQuery`\n\nThe command can also return a list of archived Workflow Executions.\n\n`temporal workflow list --archived=true`\n\nUse the command options listed below to change the information returned by this command.\n\n- [--archived](/cli/cmd-options/archived)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--query](/cli/cmd-options/query)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"workflow/query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/query.md","id":"cli/workflow/query","title":"temporal workflow query","description":"Query a Workflow Execution.","label":"query","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow query` command sends a [Query](/concepts/what-is-a-query) to a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nQueries can retrieve all or part of the Workflow state within given parameters.\nQueries can also be used on completed [Workflows](/concepts/what-is-a-workflow-execution).\n\n`temporal workflow query --workflow-id=meaningful-business-id --type=MyQueryType`\n\nUse the command options listed below to change the information returned by this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--input](/cli/cmd-options/input)\n\n- [--input-file](/cli/cmd-options/input-file)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--reject-condition](/cli/cmd-options/reject-condition)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--type](/cli/cmd-options/type)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"workflow/reset-batch.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/reset-batch.md","id":"cli/workflow/reset-batch","title":"temporal workflow reset-batch","description":"Reset a batch of Workflow Executions by reset type (FirstWorkflowTask), LastWorkflowTask), LastContinuedAsNew","label":"reset-batch","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow reset-batch` command resets a batch of [Workflow Executions](/concepts/what-is-a-workflow-execution) by `resetType`.\nResetting a [Workflow](/concepts/what-is-a-workflow) allows the process to resume from a certain point without losing your parameters or [Event History](/concepts/what-is-an-event-history).\n\nThe set of Workflow Executions to reset can be specified in an input file.\nThe input file must have a [Workflow ID](/concepts/what-is-a-workflow-id) on each line.\n\n`temporal workflow reset-batch --input-file=MyInput --input-separator=\"\\t\"`\n\nWorkflow Executions can also be found by [Query](/concepts/what-is-a-query).\n`temporal workflow reset-batch --query=MyQuery\n\nUse the options listed below to change reset behavior.\n\n- [--dry-run](/cli/cmd-options/dry-run)\n\n- [--exclude-file](/cli/cmd-options/exclude-file)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--input-file](/cli/cmd-options/input-file)\n\n- [--input-parallelism](/cli/cmd-options/input-parallelism)\n\n- [--input-separator](/cli/cmd-options/input-separator)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--non-deterministic](/cli/cmd-options/non-deterministic)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--query](/cli/cmd-options/query)\n\n- [--reason](/cli/cmd-options/reason)\n\n- [--skip-base-is-not-current](/cli/cmd-options/skip-base-is-not-current)\n\n- [--skip-current-open](/cli/cmd-options/skip-current-open)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--type](/cli/cmd-options/type)\n","is_empty":false},{"file_name":"workflow/reset.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/reset.md","id":"cli/workflow/reset","title":"temporal workflow reset","description":"Resets a Workflow Execution by Event Id or reset type.","label":"reset","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow reset` command resets a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nA reset allows the Workflow to be resumed from a certain point without losing your parameters or [Event History](/concepts/what-is-an-event-history).\n\nThe Workflow Execution can be set to a given [Event Type](/concepts/what-is-an-event).\n`temporal workflow reset --workflow-id=meaningful-business-id --type=LastContinuedAsNew`\n\nAlternatively, the Workflow Execution can be reset to any Event after WorkflowTaskStarted.\n`temporal workflow reset --workflow-id=meaningful-business-id --event-id=MyLastEvent`\n\nUse the options listed below to change reset behavior.\n\n- [--event-id](/cli/cmd-options/event-id)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--reapply-type](/cli/cmd-options/reapply-type)\n\n- [--reason](/cli/cmd-options/reason)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--type](/cli/cmd-options/type)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"workflow/show.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/show.md","id":"cli/workflow/show","title":"temporal workflow show","description":"Show Event History for a Workflow Execution.","label":"show","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow show` command provides the [Event History](/concepts/what-is-an-event-history) for a specified [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--follow](/cli/cmd-options/follow)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--max-field-length](/cli/cmd-options/max-field-length)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--output-filename](/cli/cmd-options/output-filename)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--reset-points](/cli/cmd-options/reset-points)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"workflow/signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/signal.md","id":"cli/workflow/signal","title":"temporal workflow signal","description":"Signal Workflow Execution by Id or List Filter.","label":"signal","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow signal` command is used to [Signal](/concepts/what-is-a-signal) a [Workflow Execution](/concepts/what-is-a-workflow-execution) by ID or [List Filter](/concepts/what-is-a-list-filter).\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--input](/cli/cmd-options/input)\n\n- [--input-file](/cli/cmd-options/input-file)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--name](/cli/cmd-options/name)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--query](/cli/cmd-options/query)\n\n- [--reason](/cli/cmd-options/reason)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n\n- [--yes](/cli/cmd-options/yes)\n","is_empty":false},{"file_name":"workflow/stack.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/stack.md","id":"cli/workflow/stack","title":"temporal workflow stack","description":"Query a Workflow Execution with __stack_trace as the query type.","label":"stack","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow stack` command queries a [Workflow Execution](/concepts/what-is-a-workflow-execution) with `--stack-trace` as the [Query](/concepts/what-is-a-query#stack-trace-query) type.\nReturning the stack trace of all the threads owned by a Workflow Execution can be great for troubleshooting in production.\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--input](/cli/cmd-options/input)\n\n- [--input-file](/cli/cmd-options/input-file)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--reject-condition](/cli/cmd-options/reject-condition)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"workflow/start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/start.md","id":"cli/workflow/start","title":"temporal workflow start","description":"Starts a new Workflow Execution.","label":"start","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow start` command starts a new [Workflow Execution](/concepts/what-is-a-workflow-execution).\nWhen invoked successfully, the Workflow and Run ID are returned immediately after starting the [Workflow](/concepts/what-is-a-workflow).\n\n`temporal workflow start --task-queue=MyTaskQueue --type=MyWorkflow`\n\nUse the command options listed below to change how the Workflow Execution behaves upon starting.\n\n- [--cron](/cli/cmd-options/cron)\n\n- [--execution-timeout](/cli/cmd-options/execution-timeout)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--id-reuse-policy](/cli/cmd-options/id-reuse-policy)\n\n- [--input](/cli/cmd-options/input)\n\n- [--input-file](/cli/cmd-options/input-file)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--max-field-length](/cli/cmd-options/max-field-length)\n\n- [--memo](/cli/cmd-options/memo)\n\n- [--memo-file](/cli/cmd-options/memo-file)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--run-timeout](/cli/cmd-options/run-timeout)\n\n- [--search-attribute](/cli/cmd-options/search-attribute)\n\n- [--task-queue](/cli/cmd-options/task-queue)\n\n- [--task-timeout](/cli/cmd-options/task-timeout)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--type](/cli/cmd-options/type)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"workflow/terminate.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/terminate.md","id":"cli/workflow/terminate","title":"temporal workflow terminate","description":"Terminate Workflow Execution by Id or List Filter.","label":"terminate","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow terminate` command terminates a [Workflow Execution](/concepts/what-is-a-workflow-execution)\n\nTerminating a running Workflow Execution records a [`WorkflowExecutionTerminated` event](/references/events#workflowexecutionterminated) as the closing Event in the [Event History](/concepts/what-is-an-event-history).\nAny further [Command](/concepts/what-is-a-command) Tasks cannot be scheduled after running this command.\n\nWorkflow terminations require a valid [Workflow ID](/concepts/what-is-a-workflow-id) to function.\n`temporal workflow terminate --workflow-id=meaningful-business-id`\n\nUse the options listed below to change termination behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--query](/cli/cmd-options/query)\n\n- [--reason](/cli/cmd-options/reason)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n\n- [--yes](/cli/cmd-options/yes)\n","is_empty":false},{"file_name":"workflow/trace.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/workflow/trace.md","id":"cli/workflow/trace","title":"temporal workflow trace","description":"Trace progress of a Workflow Execution and its children.","label":"trace","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal workflow trace` command tracks the progress of a [Workflow Execution](/concepts/what-is-a-workflow-execution) and any [Child Workflows](/concepts/what-is-a-child-workflow-execution) it generates.\n\nUse the options listed below to change the command's behavior.\n\n- [--concurrency](/cli/cmd-options/concurrency)\n\n- [--depth](/cli/cmd-options/depth)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--fold](/cli/cmd-options/fold)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-fold](/cli/cmd-options/no-fold)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"task-queue/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/task-queue/describe.md","id":"cli/task-queue/describe","title":"temporal task-queue describe","description":"Describes the Workers that have recently polled on this Task Queue.","label":"describe","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal task-queue describe` command provides [poller](/dev-guide/worker-performance#poller-count) information for a given [Task Queue](/concepts/what-is-a-task-queue).\n\nThe [Server](/concepts/what-is-the-temporal-server) records the last time of each poll request.\nShould `LastAccessTime` exceeds one minute, it's likely that the Worker is at capacity (all Workflow and Activity slots are full) or that the Worker has shut down.\n[Workers](/concepts/what-is-a-worker) are removed if 5 minutes have passed since the last poll request.\n\nWith this command, information about the Task Queue can be returned to troubleshoot server issues.\n\n`temporal task-queue describe --task-queue=MyTaskQueue --task-queue-type=\"activity\"`\n\nUse the options listed below to modify what this command returns.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--task-queue](/cli/cmd-options/task-queue)\n\n- [--task-queue-type](/cli/cmd-options/task-queue-type)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"task-queue/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/task-queue/index.md","id":"cli/task-queue/index","title":"temporal task-queue index","description":"Operations performed on Task Queues.","label":"task-queue","tags":["cli"],"ssdi":[],"markdown_content":"\nTask Queue commands allow operations to be performed on [Task Queues](/concepts/what-is-a-task-queue).\nTo run a Task Queue command, run `temporal task-queue [command] [command options]`\n","is_empty":false},{"file_name":"task-queue/list-partition.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/task-queue/list-partition.md","id":"cli/task-queue/list-partition","title":"temporal task-queue list-partition","description":"Lists the Task Queue's partitions and which matching node they are assigned to.","label":"list-partition","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal task-queue list-partition` command displays the partitions of a [Task Queue](/concepts/what-is-a-task-queue), along with the matching node they are assigned to.\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--task-queue](/cli/cmd-options/task-queue)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"server/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/server/index.md","id":"cli/server/index","title":"temporal server","description":"Commands for managing the Temporal Server.","label":"server","tags":["cli"],"ssdi":[],"markdown_content":"\nServer commands allow you to start and manage the [Temporal Server](/concepts/what-is-the-temporal-server) from the command line.\n\nCurrently, `cli` server functionality extends to starting the Server.\n","is_empty":false},{"file_name":"server/start-dev.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/server/start-dev.md","id":"cli/server/start-dev","title":"temporal server start-dev","description":"Start Temporal development server.","label":"start-dev","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal server start-dev` command starts the Temporal Server on `localhost:7233`.\n\nThe results of any command run on the Server can be viewed at http://localhost:7233.\n\n- [--config](/cli/cmd-options/config)\n\n- [--db-filename](/cli/cmd-options/db-filename)\n\n- [--dynamic-config-value](/cli/cmd-options/dynamic-config-value)\n\n- [--headless](/cli/cmd-options/headless)\n\n- [--ip](/cli/cmd-options/ip)\n\n- [--log-format](/cli/cmd-options/log-format)\n\n- [--log-level](/cli/cmd-options/log-level)\n\n- [--metrics-port](/cli/cmd-options/metrics-port)\n\n- [--namespace](/cli/cmd-options/namespace)\n\n- [--port](/cli/cmd-options/port)\n\n- [--sqlite-pragma](/cli/cmd-options/sqlite-pragma)\n\n- [--ui-asset-path](/cli/cmd-options/ui-asset-path)\n\n- [--ui-codec-endpoint](/cli/cmd-options/ui-codec-endpoint)\n\n- [--ui-ip](/cli/cmd-options/ui-ip)\n\n- [--ui-port](/cli/cmd-options/ui-port)\n","is_empty":false},{"file_name":"schedule/backfill.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/schedule/backfill.md","id":"cli/schedule/backfill","title":"temporal schedule backfill","description":"Backfills a past time range of actions.","label":"backfill","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal schedule backfill` command executes Actions ahead of their specified time range.\nBackfilling can be used to fill in [Workflow Runs](/concepts/what-is-a-run-id) from a time period when the Schedule was paused, or from before the Schedule was created.\n\nSchedule backfills require a valid Schedule ID, along with the time in which to run the Schedule and a change to the overlap policy.\n\n```\ntemporal schedule backfill --sid 'your-schedule-id' \\\n--overlap-policy 'BufferAll' \t\t\t\t\\\n--start-time '2022-05-0101T00:00:00Z'\t\t\\\n--end-time '2022-05-31T23:59:59Z'\n```\n\nUse the options provided below to change this command's behavior.\n\n- [--end-time](/cli/cmd-options/end-time)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--overlap-policy](/cli/cmd-options/overlap-policy)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--schedule-id](/cli/cmd-options/schedule-id)\n\n- [--start-time](/cli/cmd-options/start-time)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"schedule/create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/schedule/create.md","id":"cli/schedule/create","title":"temporal schedule create","description":"Create a new Schedule.","label":"create","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal schedule create` command creates a new [Schedule](/concepts/what-is-a-schedule).\nNewly created Schedules return a Schedule ID to be used in other Schedule commands.\n\nSchedules need to follow a format like the example shown here:\n\n```\ntemporal schedule create \\\n--sid 'your-schedule-id' \\\n--wid 'your-workflow-id' \\\n--tq 'your-task-queue' \\\n--type 'YourWorkflowType'\n```\n\nAny combination of `--cal`, `--interval`, and `--cron` is supported.\nActions will be executed at any time specified in the Schedule.\n\nUse the options provided below to change the command's behavior.\n\n- [--calendar](/cli/cmd-options/calendar)\n\n- [--catchup-window](/cli/cmd-options/catchup-window)\n\n- [--cron](/cli/cmd-options/cron)\n\n- [--end-time](/cli/cmd-options/end-time)\n\n- [--execution-timeout](/cli/cmd-options/execution-timeout)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--input](/cli/cmd-options/input)\n\n- [--input-file](/cli/cmd-options/input-file)\n\n- [--interval](/cli/cmd-options/interval)\n\n- [--jitter](/cli/cmd-options/jitter)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--max-field-length](/cli/cmd-options/max-field-length)\n\n- [--memo](/cli/cmd-options/memo)\n\n- [--memo-file](/cli/cmd-options/memo-file)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--notes](/cli/cmd-options/notes)\n\n- [--output](/cli/cmd-options/output)\n\n- [--overlap-policy](/cli/cmd-options/overlap-policy)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--pause](/cli/cmd-options/pause)\n\n- [--pause-on-failure](/cli/cmd-options/pause-on-failure)\n\n- [--remaining-actions](/cli/cmd-options/remaining-actions)\n\n- [--run-timeout](/cli/cmd-options/run-timeout)\n\n- [--schedule-id](/cli/cmd-options/schedule-id)\n\n- [--search-attribute](/cli/cmd-options/search-attribute)\n\n- [--start-time](/cli/cmd-options/start-time)\n\n- [--task-queue](/cli/cmd-options/task-queue)\n\n- [--task-timeout](/cli/cmd-options/task-timeout)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--time-zone](/cli/cmd-options/time-zone)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n\n- [--workflow-type](/cli/cmd-options/workflow-type)\n","is_empty":false},{"file_name":"schedule/delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/schedule/delete.md","id":"cli/schedule/delete","title":"temporal schedule delete","description":"Deletes a Schedule.","label":"delete","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal schedule delete` command deletes a [Schedule](/concepts/what-is-a-schedule).\nDeleting a Schedule does not affect any [Workflows](/concepts/what-is-a-workflow) started by the Schedule.\n\n[Workflow Executions](/concepts/what-is-a-workflow-execution) started by Schedules can be cancelled or terminated like other Workflow Executions.\nHowever, Workflow Executions started by a Schedule can be identified by their [Search Attributes](/concepts/what-is-a-search-attribute), making them targetable by batch command for termination.\n\n`temporal schedule delete --sid 'your-schedule-id' [command options]`\n\nUse the options below to change the behavior of this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--schedule-id](/cli/cmd-options/schedule-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"schedule/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/schedule/describe.md","id":"cli/schedule/describe","title":"temporal schedule describe","description":"Get Schedule configuration and current state.","label":"describe","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal schedule describe` command shows the current [Schedule](/concepts/what-is-a-schedule) configuration.\nThis command also provides information about past, current, and future [Workflow Runs](/concepts/what-is-a-run-id).\n\n`temporal schedule describe --sid 'your-schedule-id' [command options]`\n\nUse the options below to change this command's output.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--raw](/cli/cmd-options/raw)\n\n- [--schedule-id](/cli/cmd-options/schedule-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"schedule/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/schedule/index.md","id":"cli/schedule/index","title":"temporal schedule index","description":"Operations performed on Schedules.","label":"schedule","tags":["cli"],"ssdi":[],"markdown_content":"\nSchedule commands allow the user to create, use, and update [Schedules](/concepts/what-is-a-schedule).\nSchedules control when certain Actions for a [Workflow Execution](/concepts/what-is-a-workflow-execution) are performed, making it a useful tool for automation.\n\nTo run a Schedule command, run `temporal schedule [command] [command options]`.\n","is_empty":false},{"file_name":"schedule/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/schedule/list.md","id":"cli/schedule/list","title":"temporal schedule list","description":"Lists Schedules.","label":"list","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal schedule list` command lists all [Schedule](/concepts/what-is-a-schedule) configurations.\nListing Schedules in [Standard Visibility](/concepts/what-is-standard-visibility) will only provide Schedule IDs.\n\n`temporal schedule list`\n\nUse the options below to change the behavior of this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"schedule/toggle.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/schedule/toggle.md","id":"cli/schedule/toggle","title":"temporal schedule toggle","description":"Pauses or unpauses a Schedule.","label":"toggle","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal schedule toggle` command can pause and unpause a [Schedule](/concepts/what-is-a-schedule).\n\nToggling a Schedule requires a reason to be entered on the command line.\nUse `--reason` to note the issue leading to the pause or unpause.\n\nSchedule toggles are passed in this format:\n`temporal schedule toggle --sid 'your-schedule-id' --pause --reason \"paused because the database is down\"`\n`temporal schedule toggle --sid 'your-schedule-id' --unpause --reason \"the database is back up\"`\n\nUse the options provided below to change this command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--pause](/cli/cmd-options/pause)\n\n- [--reason](/cli/cmd-options/reason)\n\n- [--schedule-id](/cli/cmd-options/schedule-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--unpause](/cli/cmd-options/unpause)\n","is_empty":false},{"file_name":"schedule/trigger.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/schedule/trigger.md","id":"cli/schedule/trigger","title":"temporal schedule trigger","description":"Triggers an immediate action.","label":"trigger","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal schedule trigger` command triggers an immediate action with a given [Schedule](/concepts/what-is-a-schedule).\nBy default, this action is subject to the Overlap Policy of the Schedule.\n\nSchedule triggers are passed in this format:\n`temporal schedule trigger` can be used to start a Workflow Run immediately.\n`temporal schedule trigger --sid 'your-schedule-id'`\n\nThe Overlap Policy of the Schedule can be overridden as well.\n`temporal schedule trigger --sid 'your-schedule-id' --overlap-policy 'AllowAll'`\n\nUse the options provided below to change this command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--overlap-policy](/cli/cmd-options/overlap-policy)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--schedule-id](/cli/cmd-options/schedule-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"schedule/update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/schedule/update.md","id":"cli/schedule/update","title":"temporal schedule update","description":"Updates a Schedule with a new definition (full replacement, not patch).","label":"update","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal schedule update` command updates an existing [Schedule](/concepts/what-is-a-schedule).\n\nLike `temporal schedule create`, updated Schedules need to follow a certain format:\n\n```\ntemporal schedule update \t\t\t\\\n--sid 'your-schedule-id' \t\\\n--wid 'your-workflow-id' \t\\\n--tq 'your-task-queue' \t\t\\\n--type 'YourWorkflowType'\n```\n\nUpdating a Schedule takes the given options and replaces the entire configuration of the Schedule with what's provided.\nIf you only change one value of the Schedule, be sure to provide the other unchanged fields to prevent them from being overwritten.\n\nUse the options provided below to change the command's behavior.\n\n- [--calendar](/cli/cmd-options/calendar)\n\n- [--catchup-window](/cli/cmd-options/catchup-window)\n\n- [--cron](/cli/cmd-options/cron)\n\n- [--end-time](/cli/cmd-options/end-time)\n\n- [--execution-timeout](/cli/cmd-options/execution-timeout)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--input](/cli/cmd-options/input)\n\n- [--input-file](/cli/cmd-options/input-file)\n\n- [--interval](/cli/cmd-options/interval)\n\n- [--jitter](/cli/cmd-options/jitter)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--max-field-length](/cli/cmd-options/max-field-length)\n\n- [--memo](/cli/cmd-options/memo)\n\n- [--memo-file](/cli/cmd-options/memo-file)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--notes](/cli/cmd-options/notes)\n\n- [--output](/cli/cmd-options/output)\n\n- [--overlap-policy](/cli/cmd-options/overlap-policy)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--pause](/cli/cmd-options/pause)\n\n- [--pause-on-failure](/cli/cmd-options/pause-on-failure)\n\n- [--remaining-actions](/cli/cmd-options/remaining-actions)\n\n- [--run-timeout](/cli/cmd-options/run-timeout)\n\n- [--schedule-id](/cli/cmd-options/schedule-id)\n\n- [--search-attribute](/cli/cmd-options/search-attribute)\n\n- [--start-time](/cli/cmd-options/start-time)\n\n- [--task-queue](/cli/cmd-options/task-queue)\n\n- [--task-timeout](/cli/cmd-options/task-timeout)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--time-zone](/cli/cmd-options/time-zone)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n\n- [--workflow-type](/cli/cmd-options/workflow-type)\n","is_empty":false},{"file_name":"operator/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/index.md","id":"cli/operator/index","title":"temporal operator index","description":"Operations performed on the Temporal Server.","label":"operator","tags":["cli"],"ssdi":[],"markdown_content":"\nOperator commands enable actions on [Namespaces](/concepts/what-is-a-namespace), [Search Attributes](/concepts/what-is-a-search-attribute), and [Temporal Clusters](/concepts/what-is-a-temporal-cluster).\nThese actions are performed through subcommands.\n\nTo run an Operator command, run `temporal operator [command] [subcommand] [command options]`.\n","is_empty":false},{"file_name":"operator/search-attribute/create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/search-attribute/create.md","id":"cli/operator/search-attribute/create","title":"temporal operator search-attribute create","description":"Adds one or more custom Search Attributes.","label":"create","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator search-attribute create` command adds one or more custom [Search Attributes](/concepts/what-is-a-search-attribute).\nThese Search Attributes can be used to [filter a list](/concepts/what-is-a-list-filter) of [Workflow Executions](/concepts/what-is-a-workflow-execution) that contain the given Search Attributes in their metadata.\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--name](/cli/cmd-options/name)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--type](/cli/cmd-options/type)\n","is_empty":false},{"file_name":"operator/search-attribute/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/search-attribute/index.md","id":"cli/operator/search-attribute/index","title":"temporal operator search-attribute","description":"Operations applying to Search Attributes.","label":"search-attribute","tags":["cli"],"ssdi":[],"markdown_content":"\nSearch Attribute commands enable operations for the creation, listing, and removal of [Search Attributes](/concepts/what-is-a-search-attribute).\n","is_empty":false},{"file_name":"operator/search-attribute/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/search-attribute/list.md","id":"cli/operator/search-attribute/list","title":"temporal operator search-attribute list","description":"Lists all Search Attributes that can be used in list Workflow Queries.","label":"list","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator search-attribute list` command displays a list of all [Search Attributes](/concepts/what-is-a-search-attribute) that can be used in `temporal workflow list --query`.\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"operator/search-attribute/remove.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/search-attribute/remove.md","id":"cli/operator/search-attribute/remove","title":"temporal operator search-attribute remove","description":"Removes custom search attribute metadata only (Elasticsearch index schema is not modified).","label":"remove","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator search-attribute remove` command removes custom [Search Attribute](/concepts/what-is-a-search-attribute) metadata.\nThis command does not remove custom Search Attributes from Elasticsearch.\nThe index schema is not modified.\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--name](/cli/cmd-options/name)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--yes](/cli/cmd-options/yes)\n","is_empty":false},{"file_name":"operator/namespace/create.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/namespace/create.md","id":"cli/operator/namespace/create","title":"temporal operator namespace create","description":"Registers a new Namespace.","label":"create","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator namespace create` command creates a new [Namespace](/concepts/what-is-a-namespace).\nThe Namespace can be created on the active [Cluster](/concepts/what-is-a-temporal-cluster), or any named Cluster within the system.\n`temporal operator namespace --cluster=MyCluster`\n\nGlobal Namespaces can also be created.\n`temporal operator namespace create --global`\n\nOther settings, such as [retention](/concepts/what-is-a-retention-period) and [Visibility Archival State](/concepts/what-is-visibility), can be configured according to the application's needs.\nThe Visibility Archive can be set on a separate URI.\n`temporal operator namespace create --retention=RetentionMyWorkflow --visibility-archival-state=\"enabled\" --visibility-uri=\"some-uri\"`\n\nUse the options listed below to change the command's behavior.\n\n- [--active-cluster](/cli/cmd-options/active-cluster)\n\n- [--cluster](/cli/cmd-options/cluster)\n\n- [--data](/cli/cmd-options/data)\n\n- [--description](/cli/cmd-options/description)\n\n- [--email](/cli/cmd-options/email)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--global](/cli/cmd-options/global)\n\n- [--history-archival-state](/cli/cmd-options/history-archival-state)\n\n- [--history-uri](/cli/cmd-options/history-uri)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--retention](/cli/cmd-options/retention)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--visibility-archival-state](/cli/cmd-options/visibility-archival-state)\n\n- [--visibility-uri](/cli/cmd-options/visibility-uri)\n","is_empty":false},{"file_name":"operator/namespace/delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/namespace/delete.md","id":"cli/operator/namespace/delete","title":"temporal operator namespace delete","description":"Deletes an existing Namespace.","label":"delete","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator namespace delete` command deletes a given [Namespace](/concepts/what-is-a-namespace) from the system.\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--yes](/cli/cmd-options/yes)\n","is_empty":false},{"file_name":"operator/namespace/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/namespace/describe.md","id":"cli/operator/namespace/describe","title":"temporal operator namespace describe","description":"Describe a Namespace by its name or Id.","label":"describe","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator namespace describe` command provides a description of a [Namespace](/concepts/what-is-a-namespace).\nNamespaces are identified by Namespace ID.\n\n`temporal operator namespace describe --namespace-id=meaningful-business-id`\n\nUse the options listed below to change the command's output.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--namespace-id](/cli/cmd-options/namespace-id)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"operator/namespace/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/namespace/index.md","id":"cli/operator/namespace/index","title":"temporal operator namespace","description":"Operations applying to Namespaces.","label":"namespace","tags":["cli"],"ssdi":[],"markdown_content":"\nNamespace commands allow [Namespace](/concepts/what-is-a-namespace) operations to be performed on the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n","is_empty":false},{"file_name":"operator/namespace/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/namespace/list.md","id":"cli/operator/namespace/list","title":"temporal operator namespace list","description":"List all Namespaces.","label":"list","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator namespace list` command lists all [Namespaces](/namespaces) on the [Server](/concepts/what-is-a-frontend-service).\n\n`temporal operator namespace list`\n\nUse the options listed below to change the command's output.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"operator/namespace/update.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/namespace/update.md","id":"cli/operator/namespace/update","title":"temporal operator namespace update","description":"Updates a Namespace.","label":"update","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator namespace update` command updates a given [Namespace](/concepts/what-is-a-namespace).\n\nNamespaces can be assigned a different active [Cluster](/concepts/what-is-a-temporal-cluster).\n`temporal operator namespace update --active-cluster=NewActiveCluster`\n\nNamespaces can also be promoted to global Namespaces.\n`temporal operator namespace --promote-global=true`\n\nAny [Archives](/concepts/what-is-archival) that were previously enabled or disabled can be changed through this command.\nHowever, URI values for archival states cannot be changed after the states are enabled.\n`temporal operator namespace update --history-archival-state=\"enabled\" --visibility-archival-state=\"disabled\"`\n\nUse the options listed below to change the command's behavior.\n\n- [--active-cluster](/cli/cmd-options/active-cluster)\n\n- [--cluster](/cli/cmd-options/cluster)\n\n- [--data](/cli/cmd-options/data)\n\n- [--description](/cli/cmd-options/description)\n\n- [--email](/cli/cmd-options/email)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--history-archival-state](/cli/cmd-options/history-archival-state)\n\n- [--history-uri](/cli/cmd-options/history-uri)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--promote-global](/cli/cmd-options/promote-global)\n\n- [--reason](/cli/cmd-options/reason)\n\n- [--retention](/cli/cmd-options/retention)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--visibility-archival-state](/cli/cmd-options/visibility-archival-state)\n\n- [--visibility-uri](/cli/cmd-options/visibility-uri)\n","is_empty":false},{"file_name":"operator/cluster/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/cluster/describe.md","id":"cli/operator/cluster/describe","title":"temporal operator cluster describe","description":"Show information about the Cluster.","label":"describe","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator cluster describe` command shows information about the [Cluster](/concepts/what-is-a-temporal-cluster).\nThis information can include information about other connected services, such as a remote [Codec Server](/concepts/what-is-a-codec-server).\n\nUse the options listed below to change the output of this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"operator/cluster/health.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/cluster/health.md","id":"cli/operator/cluster/health","title":"temporal operator cluster health","description":"Checks the health of the Frontend Service.","label":"health","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator cluster health` command checks the health of the [Frontend Service](/concepts/what-is-a-frontend-service).\nA successful execution returns a list of [Cluster](/concepts/what-is-a-temporal-cluster) metrics.\n\nUse the options listed below to change the behavior and output of this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"operator/cluster/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/cluster/index.md","id":"cli/operator/cluster/index","title":"temporal operator cluster","description":"Operations performed on the Temporal Server.","label":"cluster","tags":["cli"],"ssdi":[],"markdown_content":"\nOperator commands enable actions on [Namespaces](/concepts/what-is-a-namespace), [Search Attributes](/concepts/what-is-a-search-attribute), and [Temporal Clusters](/concepts/what-is-a-temporal-cluster).\nThese actions are performed through subcommands for each Operator area.\n\nTo run an Operator command, run `temporal operator [command] [subcommand] [command options]`.\n","is_empty":false},{"file_name":"operator/cluster/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/cluster/list.md","id":"cli/operator/cluster/list","title":"temporal operator cluster list","description":"List all remote Clusters.","label":"list","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator cluster list` command prints a list of all remote [Clusters](/concepts/what-is-a-temporal-cluster) on the system.\n\n`temporal operator cluster list`\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"operator/cluster/remove.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/cluster/remove.md","id":"cli/operator/cluster/remove","title":"temporal operator cluster remove","description":"Remove a remote Cluster.","label":"remove","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator cluster remove` command removes a remote [Cluster](/concepts/what-is-a-temporal-cluster) from the system.\n\n`temporal operator cluster remove --name=SomeCluster`\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--name](/cli/cmd-options/name)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"operator/cluster/system.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/cluster/system.md","id":"cli/operator/cluster/system","title":"temporal operator cluster system","description":"Shows information about the system and its capabilities.","label":"system","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator cluster system` command provides information about the system the [Cluster](/concepts/what-is-a-temporal-cluster) is running on.\nThis information can be used to diagnose problems occurring in the [Temporal Server](/concepts/what-is-the-temporal-server).\n\n`temporal operator cluster system`\n\nUse the options listed below to change this command's output.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"operator/cluster/upsert.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/operator/cluster/upsert.md","id":"cli/operator/cluster/upsert","title":"temporal operator cluster upsert","description":"Add or update a remote Cluster.","label":"upsert","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal operator cluster upsert` command allows the user to add or update a remote [Cluster](/concepts/what-is-a-temporal-cluster).\n`temporal operator cluster upsert --frontend-address=\"127.0.2.1\"`\n\nUpserting can also be used to enable or disabled cross-cluster connection.\n`temporal operator cluster upsert --enable-connection=true`\n\nUse the options listed below to change the behavior of this command.\n\n- [--enable-connection](/cli/cmd-options/enable-connection)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--frontend-address](/cli/cmd-options/frontend-address)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"env/delete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/env/delete.md","id":"cli/env/delete","title":"temporal env delete","description":"Delete an environment or environmental property.","label":"delete","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal env delete` command deletes a given environment or environmental property.\n\nDeleting a given environment (such as 'local') and its saved values is achieved by passing a valid [Namespace](/concepts/what-is-a-namespace) name.\n\n`temporal env delete local`\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"env/get.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/env/get.md","id":"cli/env/get","title":"temporal env get","description":"Prints environmental properties.","label":"get","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal env get` command prints the environmental properties for the environment in use.\n\nFor example, passing the 'local' [Namespace](/concepts/what-is-a-namespace) returns the name, address, and certificate paths for the local environment.\n`temporal env get local`\n`Output: tls-cert-path  /home/my-user/certs/cluster.cert tls-key-path   /home/my-user/certs/cluster.key address        127.0.0.1:7233 namespace      accounting`\n\nOutput can be narrowed down to a specific option.\n`temporal env get local.tls-key-path`\n`tls-key-path  /home/my-user/certs/cluster.key`\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"env/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/env/index.md","id":"cli/env/index","title":"temporal env index","description":"Manage environmental configurations on Temporal Client.","label":"env","tags":["cli"],"ssdi":[],"markdown_content":"\nEnvironment (or 'env') commands allow the user to configure the properties for the environment in use.\n","is_empty":false},{"file_name":"env/set.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/env/set.md","id":"cli/env/set","title":"temporal env set","description":"Set environmental properties.","label":"set","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal env set` command sets the value for an environmental property.\n\nProperties can be set for the entire system, such as the frontend address:\n`temporal env set local.address 127.0.0.1:7233`\n\nUse the options listed below to change the command's behavior.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"completion/bash.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/completion/bash.md","id":"cli/completion/bash","title":"temporal completion bash","description":"bash completion output","label":"bash","tags":["cli"],"ssdi":[],"markdown_content":"\nsource <(temporal completion bash)\n","is_empty":false},{"file_name":"completion/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/completion/index.md","id":"cli/completion/index","title":"temporal completion index","description":"Output shell completion code for the specified shell (zsh, bash).","label":"completion","tags":["cli"],"ssdi":[],"markdown_content":"","is_empty":false},{"file_name":"completion/zsh.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/completion/zsh.md","id":"cli/completion/zsh","title":"temporal completion zsh","description":"zsh completion output","label":"zsh","tags":["cli"],"ssdi":[],"markdown_content":"\nsource <(temporal completion zsh)\n","is_empty":false},{"file_name":"cmd-options/active-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/active-cluster.md","id":"cli/cmd-options/active-cluster","title":"temporal  active-cluster","description":"Active cluster name","label":"active-cluster","tags":["cli"],"ssdi":[],"markdown_content":"\nActive cluster name.\n","is_empty":false},{"file_name":"cmd-options/activity-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/activity-id.md","id":"cli/cmd-options/activity-id","title":"temporal  activity-id","description":"Identifies the Activity Execution.","label":"activity-id","tags":["cli"],"ssdi":[],"markdown_content":"\nIdentifies the Activity Execution.\n","is_empty":false},{"file_name":"cmd-options/address.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/address.md","id":"cli/cmd-options/address","title":"temporal  address","description":"The host and port for the Temporal Frontend Service.","label":"address","tags":["cli"],"ssdi":[],"markdown_content":"\nThe host and port (formatted as host:port) for the Temporal Frontend Service.\n","is_empty":false},{"file_name":"cmd-options/archived.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/archived.md","id":"cli/cmd-options/archived","title":"temporal  archived","description":"List archived Workflow Executions.","label":"archived","tags":["cli"],"ssdi":[],"markdown_content":"\nList archived Workflow Executions.\nCurrently an experimental feature.\n","is_empty":false},{"file_name":"cmd-options/calendar.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/calendar.md","id":"cli/cmd-options/calendar","title":"temporal  calendar","description":"Calendar specification in JSON.","label":"calendar","tags":["cli"],"ssdi":[],"markdown_content":"\nCalendar specification in JSON ({\"dayOfWeek\":\"Fri\",\"hour\":\"17\",\"minute\":\"5\"}) or as a Cron string (\"30 2 * * 5\" or \"@daily\").\n","is_empty":false},{"file_name":"cmd-options/catchup-window.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/catchup-window.md","id":"cli/cmd-options/catchup-window","title":"temporal  catchup-window","description":"Maximum allowed catch-up time if server is down.","label":"catchup-window","tags":["cli"],"ssdi":[],"markdown_content":"\nMaximum allowed catch-up time if server is down.\n","is_empty":false},{"file_name":"cmd-options/cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/cluster.md","id":"cli/cmd-options/cluster","title":"temporal  cluster","description":"Cluster name","label":"cluster","tags":["cli"],"ssdi":[],"markdown_content":"\nCluster name.\n","is_empty":false},{"file_name":"cmd-options/codec-auth.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/codec-auth.md","id":"cli/cmd-options/codec-auth","title":"temporal  codec-auth","description":"Sets the authorization header on requests to the Codec Server.","label":"codec-auth","tags":["cli"],"ssdi":[],"markdown_content":"\nSets the authorization header on requests to the Codec Server.\n","is_empty":false},{"file_name":"cmd-options/codec-endpoint.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/codec-endpoint.md","id":"cli/cmd-options/codec-endpoint","title":"temporal  codec-endpoint","description":"Endpoint for a remote Codec Server.","label":"codec-endpoint","tags":["cli"],"ssdi":[],"markdown_content":"\nEndpoint for a remote Codec Server.\n","is_empty":false},{"file_name":"cmd-options/color.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/color.md","id":"cli/cmd-options/color","title":"temporal  color","description":"When to use color","label":"color","tags":["cli"],"ssdi":[],"markdown_content":"\nwhen to use color: auto, always, never. (default: auto)\n","is_empty":false},{"file_name":"cmd-options/concurrency.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/concurrency.md","id":"cli/cmd-options/concurrency","title":"temporal  concurrency","description":"Request concurrency.","label":"concurrency","tags":["cli"],"ssdi":[],"markdown_content":"\nRequest concurrency.\n","is_empty":false},{"file_name":"cmd-options/config.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/config.md","id":"cli/cmd-options/config","title":"temporal  config","description":"Path to config directory.","label":"config","tags":["cli"],"ssdi":[],"markdown_content":"\nPath to config directory.\n","is_empty":false},{"file_name":"cmd-options/context-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/context-timeout.md","id":"cli/cmd-options/context-timeout","title":"temporal  context-timeout","description":"An optional timeout for the context of an RPC call.","label":"context-timeout","tags":["cli"],"ssdi":[],"markdown_content":"\nAn optional timeout for the context of an RPC call (in seconds). (default: 5)\n","is_empty":false},{"file_name":"cmd-options/cron.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/cron.md","id":"cli/cmd-options/cron","title":"temporal  cron","description":"Optional Cron Schedule for the Workflow.","label":"cron","tags":["cli"],"ssdi":[],"markdown_content":"\nOptional Cron Schedule for the Workflow.\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12)\n│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n\n---\n","is_empty":false},{"file_name":"cmd-options/data.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/data.md","id":"cli/cmd-options/data","title":"temporal  data","description":"Namespace data in a key=value format","label":"data","tags":["cli"],"ssdi":[],"markdown_content":"\nNamespace data in a key=value format.\n","is_empty":false},{"file_name":"cmd-options/db-filename.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/db-filename.md","id":"cli/cmd-options/db-filename","title":"temporal  db-filename","description":"File in which to persist Temporal state.","label":"db-filename","tags":["cli"],"ssdi":[],"markdown_content":"\nFile in which to persist Temporal state (by default, Workflows are lost when the process dies).\n","is_empty":false},{"file_name":"cmd-options/depth.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/depth.md","id":"cli/cmd-options/depth","title":"temporal  depth","description":"Number of Child Workflows to expand.","label":"depth","tags":["cli"],"ssdi":[],"markdown_content":"\nNumber of Child Workflows to expand, -1 to expand all Child Workflows.\n","is_empty":false},{"file_name":"cmd-options/description.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/description.md","id":"cli/cmd-options/description","title":"temporal  description","description":"Namespace description","label":"description","tags":["cli"],"ssdi":[],"markdown_content":"\nNamespace description.\n","is_empty":false},{"file_name":"cmd-options/detail.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/detail.md","id":"cli/cmd-options/detail","title":"temporal  detail","description":"Detail to fail the Activity.","label":"detail","tags":["cli"],"ssdi":[],"markdown_content":"\nDetail to fail the Activity.\n","is_empty":false},{"file_name":"cmd-options/dry-run.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/dry-run.md","id":"cli/cmd-options/dry-run","title":"temporal  dry-run","description":"Simulate reset without resetting any Workflow Executions.","label":"dry-run","tags":["cli"],"ssdi":[],"markdown_content":"\nSimulate reset without resetting any Workflow Executions.\n","is_empty":false},{"file_name":"cmd-options/dynamic-config-value.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/dynamic-config-value.md","id":"cli/cmd-options/dynamic-config-value","title":"temporal  dynamic-config-value","description":"Dynamic config value, as KEY=JSON_VALUE.","label":"dynamic-config-value","tags":["cli"],"ssdi":[],"markdown_content":"\nDynamic config value, as KEY=JSON_VALUE (string values need quotes).\n","is_empty":false},{"file_name":"cmd-options/email.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/email.md","id":"cli/cmd-options/email","title":"temporal  email","description":"Owner email","label":"email","tags":["cli"],"ssdi":[],"markdown_content":"\nOwner email.\n","is_empty":false},{"file_name":"cmd-options/enable-connection.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/enable-connection.md","id":"cli/cmd-options/enable-connection","title":"temporal  enable-connection","description":"Enable cross-cluster connection","label":"enable-connection","tags":["cli"],"ssdi":[],"markdown_content":"\nEnable cross-cluster connection.\n","is_empty":false},{"file_name":"cmd-options/end-time.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/end-time.md","id":"cli/cmd-options/end-time","title":"temporal  end-time","description":"Backfill end time.","label":"end-time","tags":["cli"],"ssdi":[],"markdown_content":"\nBackfill end time.\n","is_empty":false},{"file_name":"cmd-options/env.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/env.md","id":"cli/cmd-options/env","title":"temporal  env","description":"Name of the environment to read environmental variables from.","label":"env","tags":["cli"],"ssdi":[],"markdown_content":"\nName of the environment to read environmental variables from. (default: default)\n","is_empty":false},{"file_name":"cmd-options/event-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/event-id.md","id":"cli/cmd-options/event-id","title":"temporal  event-id","description":"The Event Id for any Event after WorkflowTaskStarted you want to reset to (exclusive).","label":"event-id","tags":["cli"],"ssdi":[],"markdown_content":"\nThe Event Id for any Event after WorkflowTaskStarted you want to reset to (exclusive).\nIt can be WorkflowTaskCompleted, WorkflowTaskFailed or others.\n","is_empty":false},{"file_name":"cmd-options/exclude-file.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/exclude-file.md","id":"cli/cmd-options/exclude-file","title":"temporal  exclude-file","description":"Input file that specifies Workflow Executions to exclude from resetting.","label":"exclude-file","tags":["cli"],"ssdi":[],"markdown_content":"\nInput file that specifies Workflow Executions to exclude from resetting.\n","is_empty":false},{"file_name":"cmd-options/execution-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/execution-timeout.md","id":"cli/cmd-options/execution-timeout","title":"temporal  execution-timeout","description":"Timeout (in seconds) for a WorkflowExecution, including retries and continue-as-new tasks.","label":"execution-timeout","tags":["cli"],"ssdi":[],"markdown_content":"\nTimeout (in seconds) for a WorkflowExecution, including retries and continue-as-new tasks.\n","is_empty":false},{"file_name":"cmd-options/fields.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/fields.md","id":"cli/cmd-options/fields","title":"temporal  fields","description":"Customize fields to print.","label":"fields","tags":["cli"],"ssdi":[],"markdown_content":"\nCustomize fields to print.\nSet to 'long' to automatically print more of main fields.\n","is_empty":false},{"file_name":"cmd-options/fold.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/fold.md","id":"cli/cmd-options/fold","title":"temporal  fold","description":"Statuses for which Child Workflows will be folded in (this will reduce the number of information fetched and displayed).","label":"fold","tags":["cli"],"ssdi":[],"markdown_content":"\nStatuses for which Child Workflows will be folded in (this will reduce the number of information fetched and displayed).\nCase-insensitive and ignored if --no-fold supplied.\n","is_empty":false},{"file_name":"cmd-options/follow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/follow.md","id":"cli/cmd-options/follow","title":"temporal  follow","description":"Follow the progress of a Workflow Execution.","label":"follow","tags":["cli"],"ssdi":[],"markdown_content":"\nFollow the progress of a Workflow Execution.\n","is_empty":false},{"file_name":"cmd-options/frontend-address.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/frontend-address.md","id":"cli/cmd-options/frontend-address","title":"temporal  frontend-address","description":"Frontend address of the remote Cluster.","label":"frontend-address","tags":["cli"],"ssdi":[],"markdown_content":"\nFrontend address of the remote Cluster.\n","is_empty":false},{"file_name":"cmd-options/global.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/global.md","id":"cli/cmd-options/global","title":"temporal  global","description":"Flag to indicate whether namespace is a global namespace","label":"global","tags":["cli"],"ssdi":[],"markdown_content":"\nFlag to indicate whether namespace is a global namespace.\n","is_empty":false},{"file_name":"cmd-options/grpc-meta.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/grpc-meta.md","id":"cli/cmd-options/grpc-meta","title":"temporal  grpc-meta","description":"Contains gRPC metadata to send with requests.","label":"grpc-meta","tags":["cli"],"ssdi":[],"markdown_content":"\nContains gRPC metadata to send with requests (format: key=value). Values must be in a valid JSON format.\n","is_empty":false},{"file_name":"cmd-options/headless.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/headless.md","id":"cli/cmd-options/headless","title":"temporal  headless","description":"Disable the Web UI.","label":"headless","tags":["cli"],"ssdi":[],"markdown_content":"\nDisable the Web UI.\n","is_empty":false},{"file_name":"cmd-options/history-archival-state.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/history-archival-state.md","id":"cli/cmd-options/history-archival-state","title":"temporal  history-archival-state","description":"Flag to set history archival state, valid values are \"disabled\" and \"enabled\"","label":"history-archival-state","tags":["cli"],"ssdi":[],"markdown_content":"\nFlag to set history archival state, valid values are \"disabled\" and \"enabled\".\n","is_empty":false},{"file_name":"cmd-options/history-uri.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/history-uri.md","id":"cli/cmd-options/history-uri","title":"temporal  history-uri","description":"Optionally specify history archival URI","label":"history-uri","tags":["cli"],"ssdi":[],"markdown_content":"\nOptionally specify history archival URI (cannot be changed after first time archival is enabled).\n","is_empty":false},{"file_name":"cmd-options/id-reuse-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/id-reuse-policy.md","id":"cli/cmd-options/id-reuse-policy","title":"temporal  id-reuse-policy","description":"Allows the same Workflow Id to be used in a new Workflow Execution.","label":"id-reuse-policy","tags":["cli"],"ssdi":[],"markdown_content":"\nAllows the same Workflow Id to be used in a new Workflow Execution (AllowDuplicate, AllowDuplicateFailedOnly, RejectDuplicate, TerminateIfRunning).\n","is_empty":false},{"file_name":"cmd-options/identity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/identity.md","id":"cli/cmd-options/identity","title":"temporal  identity","description":"Specify operator's identity.","label":"identity","tags":["cli"],"ssdi":[],"markdown_content":"\nSpecify operator's identity.\n","is_empty":false},{"file_name":"cmd-options/input-file.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/input-file.md","id":"cli/cmd-options/input-file","title":"temporal  input-file","description":"Passes optional input for the Workflow from a JSON file.","label":"input-file","tags":["cli"],"ssdi":[],"markdown_content":"\nPasses optional input for the Workflow from a JSON file.\nIf there are multiple JSON files, concatenate them and separate by space or newline.\nInput from the command line will overwrite file input.\n","is_empty":false},{"file_name":"cmd-options/input-parallelism.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/input-parallelism.md","id":"cli/cmd-options/input-parallelism","title":"temporal  input-parallelism","description":"Number of goroutines to run in parallel.","label":"input-parallelism","tags":["cli"],"ssdi":[],"markdown_content":"\nNumber of goroutines to run in parallel.\nEach goroutine processes one line for every second.\n","is_empty":false},{"file_name":"cmd-options/input-separator.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/input-separator.md","id":"cli/cmd-options/input-separator","title":"temporal  input-separator","description":"Separator for the input file.","label":"input-separator","tags":["cli"],"ssdi":[],"markdown_content":"\nSeparator for the input file. The default is a tab ('\\t'). (default: '\\t')\n","is_empty":false},{"file_name":"cmd-options/input.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/input.md","id":"cli/cmd-options/input","title":"temporal  input","description":"Optional JSON input to provide to the Workflow.","label":"input","tags":["cli"],"ssdi":[],"markdown_content":"\nOptional JSON input to provide to the Workflow.\nPass \"null\" for null values.\n","is_empty":false},{"file_name":"cmd-options/interval.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/interval.md","id":"cli/cmd-options/interval","title":"temporal  interval","description":"Interval duration to include phase offset.","label":"interval","tags":["cli"],"ssdi":[],"markdown_content":"\nInterval duration, e.g. 90m, or 90m/13m to include phase offset.\n","is_empty":false},{"file_name":"cmd-options/ip.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/ip.md","id":"cli/cmd-options/ip","title":"temporal  ip","description":"IPv4 address to bind the frontend service to.","label":"ip","tags":["cli"],"ssdi":[],"markdown_content":"\nIPv4 address to bind the frontend service to.\n(default: 127.0.0.1)\n","is_empty":false},{"file_name":"cmd-options/jitter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/jitter.md","id":"cli/cmd-options/jitter","title":"temporal  jitter","description":"Jitter duration.","label":"jitter","tags":["cli"],"ssdi":[],"markdown_content":"\nJitter duration.\n","is_empty":false},{"file_name":"cmd-options/job-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/job-id.md","id":"cli/cmd-options/job-id","title":"temporal  job-id","description":"Batch Job Id","label":"job-id","tags":["cli"],"ssdi":[],"markdown_content":"\nBatch Job Id.\n","is_empty":false},{"file_name":"cmd-options/limit.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/limit.md","id":"cli/cmd-options/limit","title":"temporal  limit","description":"Number of items to print.","label":"limit","tags":["cli"],"ssdi":[],"markdown_content":"\nNumber of items to print on a page.\nBy default, `--limit` is set to 0, allowing all results to print to one page.\n","is_empty":false},{"file_name":"cmd-options/log-format.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/log-format.md","id":"cli/cmd-options/log-format","title":"temporal  log-format","description":"Set the log formatting.","label":"log-format","tags":["cli"],"ssdi":[],"markdown_content":"\nSet the log formatting.\nOptions: [\"json\", \"pretty\"].\n","is_empty":false},{"file_name":"cmd-options/log-level.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/log-level.md","id":"cli/cmd-options/log-level","title":"temporal  log-level","description":"Set the log level.","label":"log-level","tags":["cli"],"ssdi":[],"markdown_content":"\nSet the log level.\nOptions: [\"debug\" \"info\" \"warn\" \"error\" \"fatal\"].\n","is_empty":false},{"file_name":"cmd-options/max-field-length.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/max-field-length.md","id":"cli/cmd-options/max-field-length","title":"temporal  max-field-length","description":"Maximum length for each attribute field.","label":"max-field-length","tags":["cli"],"ssdi":[],"markdown_content":"\nMaximum length for each attribute field.\n","is_empty":false},{"file_name":"cmd-options/memo-file.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/memo-file.md","id":"cli/cmd-options/memo-file","title":"temporal  memo-file","description":"Set a memo from a file.","label":"memo-file","tags":["cli"],"ssdi":[],"markdown_content":"\nSet a memo from a file.\nEach line should follow the format key=value.\nUse valid JSON formats for value.\n","is_empty":false},{"file_name":"cmd-options/memo.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/memo.md","id":"cli/cmd-options/memo","title":"temporal  memo","description":"Set a memo on a schedule (in key=value format).","label":"memo","tags":["cli"],"ssdi":[],"markdown_content":"\nSet a memo on a schedule (format: key=value).\nUse valid JSON formats for value.\n","is_empty":false},{"file_name":"cmd-options/metrics-port.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/metrics-port.md","id":"cli/cmd-options/metrics-port","title":"temporal  metrics-port","description":"Port for /metrics","label":"metrics-port","tags":["cli"],"ssdi":[],"markdown_content":"\nPort for /metrics (default: 0).\n","is_empty":false},{"file_name":"cmd-options/name.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/name.md","id":"cli/cmd-options/name","title":"temporal  name","description":"Frontend address of the remote Cluster.","label":"name","tags":["cli"],"ssdi":[],"markdown_content":"\nFrontend address of the remote Cluster.\n","is_empty":false},{"file_name":"cmd-options/namespace-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/namespace-id.md","id":"cli/cmd-options/namespace-id","title":"temporal  namespace-id","description":"Namespace Id","label":"namespace-id","tags":["cli"],"ssdi":[],"markdown_content":"\nNamespace Id.\n","is_empty":false},{"file_name":"cmd-options/namespace.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/namespace.md","id":"cli/cmd-options/namespace","title":"temporal  namespace","description":"Identifies a Namespace in the Temporal Workflow.","label":"namespace","tags":["cli"],"ssdi":[],"markdown_content":"\nSpecify namespaces that should be pre-created (namespace \"default\" is always created).\n","is_empty":false},{"file_name":"cmd-options/no-fold.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/no-fold.md","id":"cli/cmd-options/no-fold","title":"temporal  no-fold","description":"Disable folding","label":"no-fold","tags":["cli"],"ssdi":[],"markdown_content":"\nDisable folding.\nAll Child Workflows within the set depth will be fetched and displayed.\n","is_empty":false},{"file_name":"cmd-options/no-pager.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/no-pager.md","id":"cli/cmd-options/no-pager","title":"temporal  no-pager","description":"Disables the interactive pager.","label":"no-pager","tags":["cli"],"ssdi":[],"markdown_content":"\nDisables the interactive pager.\n","is_empty":false},{"file_name":"cmd-options/non-deterministic.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/non-deterministic.md","id":"cli/cmd-options/non-deterministic","title":"temporal  non-deterministic","description":"Reset Workflow Execution only if its last Event is WorkflowTaskFailed with a nondeterministic error.","label":"non-deterministic","tags":["cli"],"ssdi":[],"markdown_content":"\nReset Workflow Execution only if its last Event is WorkflowTaskFailed with a nondeterministic error.\n","is_empty":false},{"file_name":"cmd-options/notes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/notes.md","id":"cli/cmd-options/notes","title":"temporal  notes","description":"Initial value of notes field.","label":"notes","tags":["cli"],"ssdi":[],"markdown_content":"\nInitial value of notes field.\n","is_empty":false},{"file_name":"cmd-options/output-filename.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/output-filename.md","id":"cli/cmd-options/output-filename","title":"temporal  output-filename","description":"Serializes Event History to a file.","label":"output-filename","tags":["cli"],"ssdi":[],"markdown_content":"\nSerializes Event History to a file.\n","is_empty":false},{"file_name":"cmd-options/output.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/output.md","id":"cli/cmd-options/output","title":"temporal  output","description":"Output format.","label":"output","tags":["cli"],"ssdi":[],"markdown_content":"\nformat output as: table, json, card.\n","is_empty":false},{"file_name":"cmd-options/overlap-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/overlap-policy.md","id":"cli/cmd-options/overlap-policy","title":"temporal  overlap-policy","description":"Overlap policy.","label":"overlap-policy","tags":["cli"],"ssdi":[],"markdown_content":"\nOverlap policy (options: Skip, BufferOne, BufferAll, CancelOther, TerminateOther, AllowAll).\n","is_empty":false},{"file_name":"cmd-options/pager.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/pager.md","id":"cli/cmd-options/pager","title":"temporal  pager","description":"Sets the pager for Temporal CLI to use.","label":"pager","tags":["cli"],"ssdi":[],"markdown_content":"\nSets the pager for Temporal CLI to use (options: less, more, favoritePager).\n","is_empty":false},{"file_name":"cmd-options/pause-on-failure.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/pause-on-failure.md","id":"cli/cmd-options/pause-on-failure","title":"temporal  pause-on-failure","description":"Pause schedule after any workflow failure.","label":"pause-on-failure","tags":["cli"],"ssdi":[],"markdown_content":"\nPause schedule after any workflow failure.\n","is_empty":false},{"file_name":"cmd-options/pause.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/pause.md","id":"cli/cmd-options/pause","title":"temporal  pause","description":"Pauses the Schedule.","label":"pause","tags":["cli"],"ssdi":[],"markdown_content":"\nPauses the Schedule.\n","is_empty":false},{"file_name":"cmd-options/port.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/port.md","id":"cli/cmd-options/port","title":"temporal  port","description":"Port for the frontend gRPC service.","label":"port","tags":["cli"],"ssdi":[],"markdown_content":"\nPort for the frontend gRPC service.\n","is_empty":false},{"file_name":"cmd-options/promote-global.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/promote-global.md","id":"cli/cmd-options/promote-global","title":"temporal  promote-global","description":"Promote local namespace to global namespace","label":"promote-global","tags":["cli"],"ssdi":[],"markdown_content":"\nPromote local namespace to global namespace.\n","is_empty":false},{"file_name":"cmd-options/query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/query.md","id":"cli/cmd-options/query","title":"temporal  query","description":"Visibility Query of Search Attributes describing the Workflow Executions to reset.","label":"query","tags":["cli"],"ssdi":[],"markdown_content":"\nVisibility Query of Search Attributes describing the Workflow Executions to reset.\nSee https://docs.\ntemporal.\nio/docs/tctl/workflow/list#--query.\n","is_empty":false},{"file_name":"cmd-options/raw.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/raw.md","id":"cli/cmd-options/raw","title":"temporal  raw","description":"Print raw data as json (prefer this over -o json for scripting).","label":"raw","tags":["cli"],"ssdi":[],"markdown_content":"\nPrint raw data as json (prefer this over -o json for scripting).\n","is_empty":false},{"file_name":"cmd-options/reapply-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/reapply-type.md","id":"cli/cmd-options/reapply-type","title":"temporal  reapply-type","description":"Event types to reapply after the reset point.","label":"reapply-type","tags":["cli"],"ssdi":[],"markdown_content":"\nEvent types to reapply after the reset point: Signal, None.\n","is_empty":false},{"file_name":"cmd-options/reason.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/reason.md","id":"cli/cmd-options/reason","title":"temporal  reason","description":"Reason for the operation","label":"reason","tags":["cli"],"ssdi":[],"markdown_content":"\nReason for the operation.\n","is_empty":false},{"file_name":"cmd-options/reject-condition.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/reject-condition.md","id":"cli/cmd-options/reject-condition","title":"temporal  reject-condition","description":"Optional flag for rejecting Queries based on Workflow state.","label":"reject-condition","tags":["cli"],"ssdi":[],"markdown_content":"\nOptional flag for rejecting Queries based on Workflow state.\nValid values are \"not_open\" and \"not_completed_cleanly\".\n","is_empty":false},{"file_name":"cmd-options/remaining-actions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/remaining-actions.md","id":"cli/cmd-options/remaining-actions","title":"temporal  remaining-actions","description":"Total number of actions allowed.","label":"remaining-actions","tags":["cli"],"ssdi":[],"markdown_content":"\nTotal number of actions allowed.\n","is_empty":false},{"file_name":"cmd-options/reset-points.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/reset-points.md","id":"cli/cmd-options/reset-points","title":"temporal  reset-points","description":"Only show Workflow Events that are eligible for reset.","label":"reset-points","tags":["cli"],"ssdi":[],"markdown_content":"\nOnly show Workflow Events that are eligible for reset.\n","is_empty":false},{"file_name":"cmd-options/result.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/result.md","id":"cli/cmd-options/result","title":"temporal  result","description":"Set the result value of Activity completion.","label":"result","tags":["cli"],"ssdi":[],"markdown_content":"\nSet the result value of Activity completion.\n","is_empty":false},{"file_name":"cmd-options/retention.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/retention.md","id":"cli/cmd-options/retention","title":"temporal  retention","description":"Workflow Execution retention","label":"retention","tags":["cli"],"ssdi":[],"markdown_content":"\nWorkflow Execution retention.\n","is_empty":false},{"file_name":"cmd-options/run-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/run-id.md","id":"cli/cmd-options/run-id","title":"temporal  run-id","description":"Identifies the current Workflow Run.","label":"run-id","tags":["cli"],"ssdi":[],"markdown_content":"\nIdentifies the current Workflow Run.\n","is_empty":false},{"file_name":"cmd-options/run-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/run-timeout.md","id":"cli/cmd-options/run-timeout","title":"temporal  run-timeout","description":"Timeout (in seconds) of a single Workflow run.","label":"run-timeout","tags":["cli"],"ssdi":[],"markdown_content":"\nTimeout (in seconds) of a single Workflow run.\n","is_empty":false},{"file_name":"cmd-options/schedule-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/schedule-id.md","id":"cli/cmd-options/schedule-id","title":"temporal  schedule-id","description":"Schedule Id","label":"schedule-id","tags":["cli"],"ssdi":[],"markdown_content":"\nSchedule Id.\n","is_empty":false},{"file_name":"cmd-options/search-attribute.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/search-attribute.md","id":"cli/cmd-options/search-attribute","title":"temporal  search-attribute","description":"Set Search Attribute on a schedule.","label":"search-attribute","tags":["cli"],"ssdi":[],"markdown_content":"\nSet Search Attribute on a schedule (format: key=value).\nUse valid JSON formats for value.\n","is_empty":false},{"file_name":"cmd-options/skip-base-is-not-current.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/skip-base-is-not-current.md","id":"cli/cmd-options/skip-base-is-not-current","title":"temporal  skip-base-is-not-current","description":"Skip a Workflow Execution if the base Run is not the current Run.","label":"skip-base-is-not-current","tags":["cli"],"ssdi":[],"markdown_content":"\nSkip a Workflow Execution if the base Run is not the current Run.\n","is_empty":false},{"file_name":"cmd-options/skip-current-open.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/skip-current-open.md","id":"cli/cmd-options/skip-current-open","title":"temporal  skip-current-open","description":"Skip a Workflow Execution if the current Run is open for the same Workflow Id as the base Run.","label":"skip-current-open","tags":["cli"],"ssdi":[],"markdown_content":"\nSkip a Workflow Execution if the current Run is open for the same Workflow Id as the base Run.\n","is_empty":false},{"file_name":"cmd-options/sqlite-pragma.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/sqlite-pragma.md","id":"cli/cmd-options/sqlite-pragma","title":"temporal  sqlite-pragma","description":"Specify sqlite pragma statements in pragma=value format.","label":"sqlite-pragma","tags":["cli"],"ssdi":[],"markdown_content":"\nSpecify sqlite pragma statements in pragma=value format.\nPragma options: [\"journal_mode\" \"synchronous\"].\n","is_empty":false},{"file_name":"cmd-options/start-time.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/start-time.md","id":"cli/cmd-options/start-time","title":"temporal  start-time","description":"Backfill start time.","label":"start-time","tags":["cli"],"ssdi":[],"markdown_content":"\nBackfill start time.\n","is_empty":false},{"file_name":"cmd-options/task-queue-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/task-queue-type.md","id":"cli/cmd-options/task-queue-type","title":"temporal  task-queue-type","description":"Task Queue type [workflow|activity].","label":"task-queue-type","tags":["cli"],"ssdi":[],"markdown_content":"\nTask Queue type [workflow|activity] (default: workflow).\n","is_empty":false},{"file_name":"cmd-options/task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/task-queue.md","id":"cli/cmd-options/task-queue","title":"temporal  task-queue","description":"Task Queue","label":"task-queue","tags":["cli"],"ssdi":[],"markdown_content":"\nTask Queue.\n","is_empty":false},{"file_name":"cmd-options/task-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/task-timeout.md","id":"cli/cmd-options/task-timeout","title":"temporal  task-timeout","description":"Start-to-close timeout for a Workflow Task (in seconds).","label":"task-timeout","tags":["cli"],"ssdi":[],"markdown_content":"\nStart-to-close timeout for a Workflow Task (in seconds).\n","is_empty":false},{"file_name":"cmd-options/time-format.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/time-format.md","id":"cli/cmd-options/time-format","title":"temporal  time-format","description":"Format time as either relative, iso, raw.","label":"time-format","tags":["cli"],"ssdi":[],"markdown_content":"\nFormat time as: relative, iso, raw.\n","is_empty":false},{"file_name":"cmd-options/time-zone.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/time-zone.md","id":"cli/cmd-options/time-zone","title":"temporal  time-zone","description":"Time zone (IANA name).","label":"time-zone","tags":["cli"],"ssdi":[],"markdown_content":"\nTime zone (IANA name).\n","is_empty":false},{"file_name":"cmd-options/tls-ca-path.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/tls-ca-path.md","id":"cli/cmd-options/tls-ca-path","title":"temporal  tls-ca-path","description":"Path to server CA certificate.","label":"tls-ca-path","tags":["cli"],"ssdi":[],"markdown_content":"\nPath to server CA certificate.\n","is_empty":false},{"file_name":"cmd-options/tls-cert-path.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/tls-cert-path.md","id":"cli/cmd-options/tls-cert-path","title":"temporal  tls-cert-path","description":"Path to x509 certificate.","label":"tls-cert-path","tags":["cli"],"ssdi":[],"markdown_content":"\nPath to x509 certificate.\n","is_empty":false},{"file_name":"cmd-options/tls-disable-host-verification.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/tls-disable-host-verification.md","id":"cli/cmd-options/tls-disable-host-verification","title":"temporal  tls-disable-host-verification","description":"Disables TLS host name verification if already enabled.","label":"tls-disable-host-verification","tags":["cli"],"ssdi":[],"markdown_content":"\nDisables TLS host name verification if already enabled.\n","is_empty":false},{"file_name":"cmd-options/tls-key-path.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/tls-key-path.md","id":"cli/cmd-options/tls-key-path","title":"temporal  tls-key-path","description":"Path to private certificate key.","label":"tls-key-path","tags":["cli"],"ssdi":[],"markdown_content":"\nPath to private certificate key.\n","is_empty":false},{"file_name":"cmd-options/tls-server-name.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/tls-server-name.md","id":"cli/cmd-options/tls-server-name","title":"temporal  tls-server-name","description":"Provides an override for the target TLS server name.","label":"tls-server-name","tags":["cli"],"ssdi":[],"markdown_content":"\nProvides an override for the target TLS server name.\n","is_empty":false},{"file_name":"cmd-options/type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/type.md","id":"cli/cmd-options/type","title":"temporal  type","description":"Search attribute type.","label":"type","tags":["cli"],"ssdi":[],"markdown_content":"\nSearch attribute type: [Text Keyword Int Double Bool Datetime KeywordList].\n","is_empty":false},{"file_name":"cmd-options/ui-asset-path.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/ui-asset-path.md","id":"cli/cmd-options/ui-asset-path","title":"temporal  ui-asset-path","description":"UI Custom Assets path.","label":"ui-asset-path","tags":["cli"],"ssdi":[],"markdown_content":"\nUI Custom Assets path.\n","is_empty":false},{"file_name":"cmd-options/ui-codec-endpoint.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/ui-codec-endpoint.md","id":"cli/cmd-options/ui-codec-endpoint","title":"temporal  ui-codec-endpoint","description":"UI Remote data converter HTTP endpoint.","label":"ui-codec-endpoint","tags":["cli"],"ssdi":[],"markdown_content":"\nUI Remote data converter HTTP endpoint.\n","is_empty":false},{"file_name":"cmd-options/ui-ip.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/ui-ip.md","id":"cli/cmd-options/ui-ip","title":"temporal  ui-ip","description":"IPv4 address to bind the Web UI to.","label":"ui-ip","tags":["cli"],"ssdi":[],"markdown_content":"\nIPv4 address to bind the Web UI to.\n","is_empty":false},{"file_name":"cmd-options/ui-port.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/ui-port.md","id":"cli/cmd-options/ui-port","title":"temporal  ui-port","description":"Port for the Web UI.","label":"ui-port","tags":["cli"],"ssdi":[],"markdown_content":"\nPort for the Web UI.\n","is_empty":false},{"file_name":"cmd-options/unpause.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/unpause.md","id":"cli/cmd-options/unpause","title":"temporal  unpause","description":"Unpauses the Schedule.","label":"unpause","tags":["cli"],"ssdi":[],"markdown_content":"\nUnpauses the Schedule.\n","is_empty":false},{"file_name":"cmd-options/visibility-archival-state.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/visibility-archival-state.md","id":"cli/cmd-options/visibility-archival-state","title":"temporal  visibility-archival-state","description":"Flag to set visibility archival state.","label":"visibility-archival-state","tags":["cli"],"ssdi":[],"markdown_content":"\nFlag to set visibility archival state, valid values are \"disabled\" and \"enabled\".\n","is_empty":false},{"file_name":"cmd-options/visibility-uri.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/visibility-uri.md","id":"cli/cmd-options/visibility-uri","title":"temporal  visibility-uri","description":"Optionally specify visibility archival URI (cannot be changed after first time archival is enabled).","label":"visibility-uri","tags":["cli"],"ssdi":[],"markdown_content":"\nOptionally specify visibility archival URI (cannot be changed after first time archival is enabled).\n","is_empty":false},{"file_name":"cmd-options/workflow-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/workflow-id.md","id":"cli/cmd-options/workflow-id","title":"temporal  workflow-id","description":"Workflow Id","label":"workflow-id","tags":["cli"],"ssdi":[],"markdown_content":"\nWorkflow Id.\n","is_empty":false},{"file_name":"cmd-options/workflow-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/workflow-type.md","id":"cli/cmd-options/workflow-type","title":"temporal  workflow-type","description":"Workflow type name.","label":"workflow-type","tags":["cli"],"ssdi":[],"markdown_content":"\nWorkflow type name.\n","is_empty":false},{"file_name":"cmd-options/yes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/cmd-options/yes.md","id":"cli/cmd-options/yes","title":"temporal  yes","description":"Confirm all prompts.","label":"yes","tags":["cli"],"ssdi":[],"markdown_content":"\nConfirm all prompts.\n","is_empty":false},{"file_name":"batch/describe.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/batch/describe.md","id":"cli/batch/describe","title":"temporal batch describe","description":"Describe a Batch operation job.","label":"describe","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal batch describe` command shows the progress of an ongoing Batch job.\n\nPass a valid Job ID to return a Batch Job's information.\n`temporal batch describe --jobid=MyJobId`\n\nUse the command options listed below to change the information returned by this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--job-id](/cli/cmd-options/job-id)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"batch/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/batch/index.md","id":"cli/batch/index","title":"temporal batch index","description":"Operations performed on Batch jobs.","label":"batch","tags":["cli"],"ssdi":[],"markdown_content":"\nBatch commands allow you to change multiple [Workflow Executions](/concepts/what-is-a-workflow-execution) in the background.\nIn order to do this, you provide the command with a [List Filter](/concepts/what-is-visibility) and the type of Batch job to execute.\n\nThe List Filter identifies the Workflow Executions that will be affected by the Batch job.\nThe Batch type determines the other parameters that need to be provided, along with what is being affected on the Workflow Executions.\n\nThere are three types of Batch Jobs:\n\n- Signal: sends a [Signal](/concepts/what-is-a-signal) to the Workflow Executions specified by the List Filter.\n- Cancel: cancels the Workflow Executions specified by the List Filter.\n- Terminate: terminates the Workflow Executions specified by the List Filter.\n\nA successfully started Batch job will return a Job ID.\nUse this Job ID to execute other actions on the Batch job.\n","is_empty":false},{"file_name":"batch/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/batch/list.md","id":"cli/batch/list","title":"temporal batch list","description":"List Batch operation jobs.","label":"list","tags":["cli"],"ssdi":[],"markdown_content":"\nWhen used, `temporal batch list` returns all Batch jobs.\nBatch Jobs can be returned for an entire Cluster or a single Namespace.\n`temporal batch list --namespace=MyNamespace`\n\nUse the command options listed below to change the information returned by this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"batch/terminate.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/batch/terminate.md","id":"cli/batch/terminate","title":"temporal batch terminate","description":"Stop a Batch operation job.","label":"terminate","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal batch terminate` command terminates a Batch job with the provided Job ID.\nA reason for terminating the Batch Job can also be provided for future reference.\n\n`temporal batch terminate --job-id=MyJobId --reason=JobReason`\n\nUse the command options listed below to change the behavior of this command.\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--job-id](/cli/cmd-options/job-id)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--reason](/cli/cmd-options/reason)\n\n- [--time-format](/cli/cmd-options/time-format)\n","is_empty":false},{"file_name":"activity/complete.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/activity/complete.md","id":"cli/activity/complete","title":"temporal activity complete","description":"Completes an Activity.","label":"complete","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal activity complete` command completes an [Activity Execution](/concepts/what-is-an-activity-execution).\nAlong with completing the Activity, the result given upon return can be set as well.\n\n`temporal activity complete --activity-id=MyActivity --result=ActivityComplete`\n\nUse the options listed below to change the behavior of this command.\n\n- [--activity-id](/cli/cmd-options/activity-id)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--identity](/cli/cmd-options/identity)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--result](/cli/cmd-options/result)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"activity/fail.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/activity/fail.md","id":"cli/activity/fail","title":"temporal activity fail","description":"Fails an Activity.","label":"fail","tags":["cli"],"ssdi":[],"markdown_content":"\nThe `temporal activity fail` command fails an [Activity Execution](/concepts/what-is-an-activity-execution).\nThe Activity must already be running on a valid [Workflow](/concepts/what-is-a-workflow).\n`temporal fail --workflow-id=meaningful-business-id --activity-id=MyActivity`\n\nUse the options listed below to change the behavior of this command.\n\n- [--activity-id](/cli/cmd-options/activity-id)\n\n- [--detail](/cli/cmd-options/detail)\n\n- [--fields](/cli/cmd-options/fields)\n\n- [--identity](/cli/cmd-options/identity)\n\n- [--limit](/cli/cmd-options/limit)\n\n- [--no-pager](/cli/cmd-options/no-pager)\n\n- [--output](/cli/cmd-options/output)\n\n- [--pager](/cli/cmd-options/pager)\n\n- [--reason](/cli/cmd-options/reason)\n\n- [--run-id](/cli/cmd-options/run-id)\n\n- [--time-format](/cli/cmd-options/time-format)\n\n- [--workflow-id](/cli/cmd-options/workflow-id)\n","is_empty":false},{"file_name":"activity/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs-src/cli/activity/index.md","id":"cli/activity/index","title":"temporal activity index","description":"Operations that can be performed on Workflow Activities.","label":"activity","tags":["cli"],"ssdi":[],"markdown_content":"\nActivity commands operate on [Activity Executions](/concepts/what-is-an-activity-execution).\n\nTo run an Activity command, type `temporal activity [command] [command options]`\n","is_empty":false}]

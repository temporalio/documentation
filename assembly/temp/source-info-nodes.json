[{"file_name":"certificates-authorization.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/certificates-authorization.md","id":"cloud-context/certificates-authorization","title":"How to control authorization for Temporal Cloud Namespaces","description":"Temporal Cloud requires full CA chains, so you can achieve authorization in two ways.","label":"Control authorization","tags":["guide-context"],"markdown_content":"\nBecause Temporal Cloud uses mTLS for authorization, we recommend that an end-entity certificate be scoped to a specific Namespace.\nTemporal Cloud requires full CA chains, so you can achieve authorization in two ways.\n\n### Option 1: Issue a separate root certificate for each Namespace\n\nEach certificate must belong to a chain up to the root CA certificate.\nTemporal uses the root CA certificate as the trusted authority for access to your Namespaces.\n\n1. Ensure that your certificates meet the [certificate requirements](#certificate-requirements).\n1. [Add client CA certificates to a Cloud Namespace](/cloud/tcld/namespace/accepted-client-ca/add).\n\n### Option 2: Use the same root certificate for all Namespaces but create a separate certificate filter for each Namespace\n\n[How to manage certificate filters in Temporal Cloud](#manage-certificate-filters)\n","is_empty":false},{"file_name":"certificates-filters.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/certificates-filters.md","id":"cloud-context/certificates-filters","title":"How to manage certificate filters in Temporal Cloud","description":"To limit access to specific CA certificates, you can create certificate filters.","label":"Manage certificate filters","tags":["guide-context"],"markdown_content":"\nTo limit access to specific [end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud), you can create certificate filters.\nEach filter contains values for one or more of the following fields:\n\n- commonName (CN)\n- organization (O)\n- organizationalUnit (OU)\n- subjectAlternativeName (SAN)\n\nCorresponding fields in the client certificate must match every specified value in the filter.\n\nThe values for the fields are case-insensitive.\nIf no wildcard is used, each specified value must match its field exactly.\n\nTo match a substring, place a single `*` wildcard at the beginning or end (but not both) of a value.\nYou cannot use a `*` wildcard by itself.\n\nYou can create a maximum of 25 certificate filters in a Namespace.\n\nIf you provide a well-known CA certificate, you cannot clear a certificate filter.\nA well-known CA certificate is one that is typically included in the certificate store of an operating system.\n\n**Examples**\n\nIn the following example, only the CN field of the certificate's subject is checked, and it must be exactly `code.example.com`.\nThe other fields are not checked.\n\n```json\nAuthorizedClientCertificate {\n  CN : \"code.example.com\"\n}\n```\n\nIn the following example, the CN field must be `stage.example.com` and the O field must be `Example Code Inc.`\n\n```json\nAuthorizedClientCertificate {\n  CN : \"stage.example.com\"\n  O : \"Example Code Inc.\"\n}\n```\n\nWhen using a `*` wildcard, the following values are valid:\n\n- `*.example.com` matches `code.example.com` and `text.example.com`.\n- `Example Code*` matches `Example code` and `Example Code Inc`.\n\nThe following values are not valid:\n\n- `.example.*`\n- `code.*.com`\n- `*`\n\n<!--- How to manage certificate filters in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage certificate filters using Temporal Cloud UI\n\nTo add or remove a certificate filter, follow these steps:\n\n1. On the left side of the window, click **Namespaces**.\n1. On the **Namespaces** page, click the name of the Namespace to manage.\n1. On the right side of the page for the selected Namespace, click **Edit**.\n1. On the **Edit** page, click **Certificate Filters**.\n   - To add a certificate filter, click **Add a Certificate Filter** and enter values in one or more fields.\n   - To remove a certificate filter, click the **×** in the upper-right corner of the filter details.\n1. To cancel your changes, click **Back to Namespace**. To save your changes, click **Save**.\n\n<!--- How to manage certificate filters in Temporal Cloud using tcld --->\n\n### Manage certificate filters using tcld\n\nTo set or clear certificate filters, use the following [tcld](/cloud/tcld) commands:\n\n- [tcld namespace certificate-filters import](/cloud/tcld/namespace/certificate-filters/import)\n- [tcld namespace certificate-filters clear](/cloud/tcld/namespace/certificate-filters/clear)\n\nTo view the current certificate filters, use the [tcld namespace certificate-filters export](/cloud/tcld/namespace/certificate-filters/export) command.\n","is_empty":false},{"file_name":"certificates-intro.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/certificates-intro.md","id":"cloud-context/certificates-intro","title":"How to manage certificates in Temporal Cloud","description":"Access to Temporal Cloud requires a certificate from you.","label":"Manage certificates","tags":["guide-context"],"markdown_content":"\nAccess to [Temporal Cloud](https://temporal.io/cloud) is secured with the mutual Transport Layer Security (mTLS) protocol.\nThis protocol requires a CA certificate from you.\n\n[Worker Processes](/workers/#worker-process) use both CA certificates and private keys to connect to Temporal Cloud. Private keys remain in your control; Temporal Cloud requires no exchange of secrets.\n","is_empty":false},{"file_name":"certificates-issue.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/certificates-issue.md","id":"cloud-context/certificates-issue","title":"How to issue root CA and end-entity certificates","description":"You can issue root CA and end-entity certificates in two ways.","label":"Issue certificates","tags":["guide-context"],"markdown_content":"\nTemporal Cloud authenticates a client connection by validating the client certificate against one or more CA certificates that are configured for the specified Namespace.\n\n### Option 1: You already have certificate management infrastructure\n\nIf your existing certificate management infrastructure supports issuing CA and end-entity certificates, it satisfies the requirements.\nWhen you configure the client SDK, you must present a complete certificate chain up to the CA certificate given to Temporal.\n\n### Option 2: You have no certificate management infrastructure\n\nIf you don't have existing certificate management infrastructure, you can issue the CA and client certificates by using tools such as OpenSSL.\n\nWe also provide a tool that issues one root CA and the required end-entity certificate to use on the client SDK.\nThe tool can issue multiple end-entity certificates.\nWe've kept this tool minimal because it is a demonstration tool; **it is _not_ meant to be used in production.**\n\nYou can use this tool in two ways:\n\n- Follow the instructions for the [temporalio/client-certificate-generation](https://hub.docker.com/r/temporalio/client-certificate-generation) image in Docker Hub.\n  This procedure is the easiest because it's independent of your operating system.\n- Follow the README instructions in the [client-only](https://github.com/temporalio/samples-server/tree/main/tls/client-only) directory in our `temporalio/samples-server` repository in GitHub.\n\n:::info\n\nThe maximum number of CA certificates in a certificate bundle is 16. The payload size of a certificate bundle (before base64-encoding) is 32 KB.\n\n:::\n","is_empty":false},{"file_name":"certificates-namespace.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/certificates-namespace.md","id":"cloud-context/certificates-namespace","title":"How to add, update, and remove certificates in a Temporal Cloud Namespace","description":"To manage certificates for Temporal Cloud Namespaces, use the `tcld namespace accepted-client-ca` commands.","label":"Manage certificates","tags":["guide-context"],"markdown_content":"\n:::note\n\nTo manage certificates for a Namespace, a user must have [Namespace Admin](/cloud/#namespace-level-permissions) permission for that Namespace.\n\n:::\n\nTo manage certificates for Temporal Cloud Namespaces, use the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/index) commands.\n","is_empty":false},{"file_name":"certificates-requirements.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/certificates-requirements.md","id":"cloud-context/certificates-requirements","title":"Requirements for CA certificates in Temporal Cloud","description":"Certificates provided to Temporal for your Namespaces must meet certain requirements.","label":"Certificate requirements","tags":["guide-context"],"markdown_content":"\nCertificates provided to Temporal for your [Namespaces](/namespaces) _must_ meet the following requirements.\n\n### CA certificates\n\nCA certificates _must_ meet the following criteria:\n\n- The certificates must be X.509v3.\n- Each certificate in the bundle must be either a root certificate or issued by another certificate in the bundle.\n- Each certificate in the bundle must include `CA: true`.\n- A certificate cannot be a well-known CA (such as DigiCert or Let's Encrypt) _unless_ the user also specifies certificate filters.\n- The signing algorithm must include SHA-256 or stronger.\n  SHA-1 and MD5 signing algorithms are rejected.\n\n### End-entity certificates\n\nAn end-entity (leaf) certificate _must_ meet the following criteria:\n\n- The certificate must be X.509v3.\n- Basic constraints must include `CA: false`.\n- The key usage must include Digital Signature.\n- The signing algorithm must include SHA-256 or stronger.\n  SHA-1 and MD5 signing algorithms are rejected.\n\nWhen a client presents an end-entity certificate, and the whole certificate chain is constructed, each certificate in the chain (from end-entity to the root) must have a unique Distinguished Name.\n\n:::caution\n\nDistinguished Names are _not_ case sensitive; that is, uppercase letters (such as ABC) and lowercase letters (such as abc) are equivalent.\n\n:::\n","is_empty":false},{"file_name":"cloud-intro.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/cloud-intro.md","id":"cloud-context/cloud-intro","title":"Temporal Cloud documentation","description":"Temporal Cloud documentation, including explanations and usage.","label":"Temporal Cloud","tags":["explanation"],"markdown_content":"\n:::note Sign up for Temporal Cloud\n\nTo request a Temporal Cloud account, complete the [request form](https://pages.temporal.io/cloud-request-access).\n\n:::\n\n- [Get started with Temporal Cloud](/cloud/how-to-get-started-with-temporal-cloud)\n- [Manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud)\n- [Manage Namespaces in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud)\n- [tcld (Temporal Cloud command-line interface)](/cloud/tcld)\n- [Temporal Cloud release notes](/cloud/release-notes)\n","is_empty":false},{"file_name":"get-started-certificates.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/get-started-certificates.md","id":"cloud-context/get-started-certificates","title":"Get started - Certificates","description":"Learn requirements for CA certificates","label":"Issue CA certificates","tags":["guide-context"],"markdown_content":"\nYou must provide your own certificates to access Temporal Cloud.\nFor certificate requirements, see the following:\n\n- [Requirements for CA certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements)\n- [Issue root CA and end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#issue-certificates)\n","is_empty":false},{"file_name":"get-started-connect.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/get-started-connect.md","id":"cloud-context/get-started-connect","title":"Get started - Connect","description":"Connect Temporal Clients and Worker Processes to Temporal Cloud.","label":"Connect to Temporal Cloud","tags":["guide-context"],"markdown_content":"\nConnecting your [Temporal Clients](/temporal#temporal-client) and [Worker Processes](/workers#worker-process) to Temporal Cloud is similar to connecting them to your own [Temporal Cluster](/clusters).\nThe primary difference is the requirement to provide client certificates and private keys.\n\n- [Connect a Temporal Client](/application-development/foundations#connect-to-a-cluster)\n- [Connect a Worker Process](/application-development/foundations#run-worker-processes)\n","is_empty":false},{"file_name":"get-started-intro.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/get-started-intro.md","id":"cloud-context/get-started-intro","title":"Get started with Temporal Cloud","description":"Create an account, issue certificates, create a Namespace, invite users, and connect.","label":"Get started","tags":["guide-context"],"markdown_content":"\n:::note Sign up for Temporal Cloud\n\nTo request a Temporal Cloud account, complete the [request form](https://pages.temporal.io/cloud-request-access).\n\n:::\n\n<!--- Onboarding guide for Temporal Cloud --->\n\nYou received email from Temporal that welcomes you to your new Temporal account.\nYour email address is now the first [Global Admin](/cloud/#account-level-roles) for your account.\n\nTo get started with Temporal Cloud, follow these onboarding steps:\n\n<!--- 1. [Create an account.](#create-an-account-in-temporal-cloud) --->\n\n1. [Issue CA certificates](#issue-ca-certificates).\n1. [Create a Namespace](#create-a-namespace).\n1. [Invite users](#invite-users).\n1. [Connect to Temporal Cloud](#connect-to-temporal-cloud).\n","is_empty":false},{"file_name":"get-started-namespace.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/get-started-namespace.md","id":"cloud-context/get-started-namespace","title":"Get started - Namespaces","description":"Gather required information and use Temporal Cloud UI or tcld.","label":"Create a Namespace","tags":["guide-context"],"markdown_content":"\nIf you don't already have a Namespace (or want to create another), see the following:\n\n[Create a Namespace in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud/#create-a-namespace-in-temporal-cloud)\n","is_empty":false},{"file_name":"how-to-monitor-temporal-cloud-metrics.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/how-to-monitor-temporal-cloud-metrics.md","id":"cloud-context/how-to-monitor-temporal-cloud-metrics","title":"How to monitor Temporal Cloud metrics","description":"Configure and track performance metrics for Temporal Cloud.","label":"Cloud metrics","tags":["how-to"],"markdown_content":"\nBeyond the [metrics](/application-development/observability#metrics) provided by the Temporal SDKs, some key metrics exist only in Temporal Cloud.\nYou can use your own observability tool to query an endpoint and review Namespace metrics.\n\nTo ensure security of your metrics, a CA certificate dedicated to observability is required.\nOnly clients that use certificates signed by that CA, or that chain up to the CA, can query the metrics endpoint.\nFor more information about CA certificates in Temporal Cloud, see [Certificate requirements](https://docs.temporal.io/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements).\n\n<!--- How to configure a metrics endpoint in Temporal Cloud using Temporal Cloud UI --->\n\n## Configure a metrics endpoint using Temporal Cloud UI\n\n:::note\n\nTo view and manage third-party integration settings, your user account must have the Global Admin [Role](https://docs.temporal.io/cloud/#account-level-roles).\n\n:::\n\nTo assign a certificate and generate your metrics endpoint, follow these steps:\n\n1. In Temporal Cloud UI, click **Settings**.\n1. On the **Settings** page, click **Integrations**.\n1. In the **Observability** card, click **Configure Observability**.\n   (If observability is already configured, the **Edit** link appears instead.)\n1. In **Certificates**, paste a base64-encoded CA certificate PEM block.\n1. Click **Generate endpoint**.\n\nAfter the page refreshes, the new metrics endpoint appears below **Endpoint**.\nUse the endpoint to configure your observability tool.\n\n<!--- How to configure a metrics endpoint in Temporal Cloud using tcld --->\n\n## Configure a metrics endpoint using tcld\n\nTo add a certificate to a metrics endpoint, use [`tcld account metrics accepted-client-ca add`](/cloud/tcld/account/metrics/accepted-client-ca/add).\n\nTo enable a metrics endpoint, use [`tcld account metrics enable`](/cloud/tcld/account/metrics/enable).\n\nTo disable a metrics endpoint, use [`tcld account metrics disable`](/cloud/tcld/account/metrics/disable).\n\n## Available performance metrics\n\nTemporal tracks the following metrics for your various Namespaces.\n\n- temporal_cloud_v0_frontend_service_error_count\n- temporal_cloud_v0_frontend_service_request_count\n- temporal_cloud_v0_poll_success_count\n- temporal_cloud_v0_poll_success_sync_count\n- temporal_cloud_v0_poll_timeout_count\n- temporal_cloud_v0_service_latency_bucket\n- temporal_cloud_v0_service_latency_count\n- temporal_cloud_v0_service_latency_sum\n- temporal_cloud_v0_state_transition_count\n- temporal_cloud_v0_total_action_count\n- temporal_cloud_v0_workflow_cancel_count\n- temporal_cloud_v0_workflow_continued_as_new_count\n- temporal_cloud_v0_workflow_failed_count\n- temporal_cloud_v0_workflow_success_count\n- temporal_cloud_v0_workflow_terminate_count\n- temporal_cloud_v0_workflow_timeout_count\n\nMetrics for all Namespaces in your account are available from the metrics endpoint.\nThe `temporal_namespace` label identifies the Namespace that is associated with each metric so that each user can build their own dashboard to meet their needs.\n\nMetrics lag real-time performance by approximately one minute.\n\nWe retain raw metrics for seven days.\n","is_empty":false},{"file_name":"namespaces-access.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/namespaces-access.md","id":"cloud-context/namespaces-access","title":"How to access a Namespace in Temporal Cloud","description":"You can access a Namespace in Temporal Cloud via gRPC and HTTPS endpoints.","label":"Access Namespaces","tags":["guide-context"],"markdown_content":"\n<!--- How to access a Namespace in Temporal Cloud --->\n\nEach Namespace in Temporal Cloud has two unique endpoints, both of which include the [Namespace Id](/cloud/#cloud-namespace-id).\n\n- For programmatic access, a gRPC endpoint in the form `<NamespaceId>.tmprl.cloud`; for example, `accounting-production.f45a2.tmprl.cloud:7233`.\n- For accessing Temporal Web UI, an HTTPS endpoint in the form `web.<namespaceId>.tmprl.cloud`; for example, `https://web.accounting-production.f45a2.tmprl.cloud`.\n","is_empty":false},{"file_name":"namespaces-create.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/namespaces-create.md","id":"cloud-context/namespaces-create","title":"How to create a Namespace in Temporal Cloud","description":"To create a Namespace in Temporal Cloud, use either Temporal Cloud UI or tcld.","label":"Create a Namespace","tags":["guide-context"],"markdown_content":"\n:::info\n\nThe user who creates a [Namespace](/namespaces) is automatically granted [Namespace Admin](/cloud/#namespace-level-permissions) permission for that Namespace.\n\nTo create a Namespace, a user must have the Developer or Global Admin account-level [Role](/cloud/#account-level-roles).\n\n:::\n\n:::tip\n\nBy default, each account has a quota of 10 Namespaces.\nIf you want to increase this limit, open a support ticket.\n\n:::\n\n<!--- What information do I need to create a Namespace in Temporal Cloud? --->\n\n### Information needed to create a Namespace\n\nTo create a Namespace in Temporal Cloud, gather the following information:\n\n- [Namespace Name](/cloud/#cloud-namespace) and region\n- [Retention Period](/clusters/#retention-period) for the [Event History](/workflows#event-history) of closed [Workflow Executions](/workflows#workflow-execution)\n- [CA certificate](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements) for the Namespace\n- [Permissions](/cloud/#namespace-level-permissions) for each user\n\n<!--- How to create a Namespace in Temporal Cloud using Temporal Cloud UI --->\n\n### Create a Namespace using Temporal Cloud UI\n\n1. Gather the information listed earlier in [Information needed to create a Namespace](#information-needed-to-create-a-namespace).\n1. Go to the Temporal Cloud UI and log in.\n1. On the left side of the window, click **Namespaces**.\n1. On the **Namespaces** page, click **Create Namespace** in the upper-right portion of the window.\n1. On the **Create Namespace** page in **Name**, enter the Namespace Name.\n1. In **Region**, select the region in which to host this Namespace.\n1. In **Retention Period**, specify a value from 1 to 90 days.\n   When choosing this value, consider your needs for Event History versus the cost of maintaining that Event History.\n   Typically, a development Namespace has a short retention period and a production Namespace has a longer retention period.\n   (If you need to change this value later, contact Temporal Support.)\n1. In **Certificate**, paste the CA certificate for this Namespace.\n1. Click **Create Namespace**.\n\n<!--- How to create a Namespace in Temporal Cloud using tcld --->\n\n### Create a Namespace using tcld\n\nThis functionality is in development.\n","is_empty":false},{"file_name":"namespaces-intro.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/namespaces-intro.md","id":"cloud-context/namespaces-intro","title":"How to manage Namespaces in Temporal Cloud","description":"You can create and manage Namespaces from your Temporal Cloud UI.","label":"Manage Namespaces","tags":["guide-context"],"markdown_content":"\nA Namespace is a unit of isolation within the Temporal Platform.\n\n- [Create a Namespace](#create-a-namespace)\n- [Access a Namespace](#access-a-namespace)\n- [Manage Namespaces](#manage-namespaces)\n","is_empty":false},{"file_name":"namespaces-manage.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/namespaces-manage.md","id":"cloud-context/namespaces-manage","title":"How to manage Namespaces in Temporal Cloud","description":"To manage Namespaces in Temporal Cloud, use either Temporal Cloud UI or tcld.","label":"Manage Namespaces","tags":["how-to"],"markdown_content":"\n<!--- How to manage Namespaces in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage Namespaces in Temporal Cloud using Temporal Cloud UI\n\nTo list Namespaces:\n\n- On the left side of the window, click **Namespaces**.\n\nTo edit a Namespace (including custom Search Attributes, certificates, certificate filters, and permissions), find the Namespace and do either of the following:\n\n- On the right end of the Namespace row, click the three vertical dots (⋮). Click **Edit**.\n- Click the Namespace name. In the top-right portion of the page, click **Edit**.\n\nOn the **Edit** page, you can do the following:\n\n- Add a [custom Search Attribute](/visibility#custom-search-attributes).\n- [Manage CA certificates](/cloud/how-to-manage-certificates-in-temporal-cloud).\n- [Manage certificate filters](/cloud/how-to-manage-certificates-in-temporal-cloud#manage-certificate-filters-using-temporal-cloud-ui).\n- Manage [Namespace-level permissions](/cloud/#namespace-level-permissions).\n\nAfter you make changes, click **Save** in the top-right or bottom-left portion of the page.\n\n<!--- How to manage Namespaces in Temporal Cloud using tcld --->\n\n### Manage Namespaces in Temporal Cloud using tcld\n\nTo list Namespaces and get information about them, use the following [tcld](/cloud/tcld/) commands:\n\n- [tcld namespace list](/cloud/tcld/namespace/list)\n- [tcld namespace get](/cloud/tcld/namespace/get)\n\nTo manage certificates, use the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/index) commands.\nFor more information, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud).\n\nTo manage certificate filters, use the [tcld namespace certificate-filters](/cloud/tcld/namespace/certificate-filters/index) commands.\nFor more information, see [How to manage certificate filters in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud#manage-certificate-filters).\n","is_empty":false},{"file_name":"upgrade-policy-for-temporal-cloud.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/upgrade-policy-for-temporal-cloud.md","id":"cloud-context/upgrade-policy-for-temporal-cloud","title":"What is the upgrade policy for Temporal Cloud?","description":"Basic upgrade policy for customers of Temporal Cloud","label":"Upgrade policy","markdown_content":"\nAll customers will automatically be upgraded to the latest minor version.\n\nMaintenance support, for major versions, will be provided for at least 18 months after a GA release, and there will be at least 6 months' notice before EOL/deprecating support.\n\nThis versioning policy is intended to serve as a minimum set of guidelines for customers who rely on us for their critical business operations.\nIf you have any further questions, please do not hesitate to reach out via community or customer channels.\n","is_empty":false},{"file_name":"users-invite.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/users-invite.md","id":"cloud-context/users-invite","title":"Invite users","description":"Assign Roles and Namespace permissions, and send invites","label":"Invite users","tags":["guide-context"],"markdown_content":"\n:::caution\n\nAccess to Temporal Cloud is authorized via single sign-on (SSO), currently limited to Google OAuth.\nThe email addresses of all users who need access to Temporal Cloud must be registered with Google.\n\nIf an email address is not associated with a Google Account, the user must follow the instructions in the [Use an existing email address](https://support.google.com/accounts/answer/27441?hl=en#existingemail) section of [Create a Google Account](https://support.google.com/accounts/answer/27441).\n\n**Important:** Do _not_ create a Gmail account when creating a Google Account.\n\n:::\n\nWhen you create a user in Temporal Cloud, the prospective user receives an email invitation.\nBefore accepting the invitation, the user must be logged in to Google using the email address that received the invitation.\nThe user must then click **Accept Invite** in the message.\nAttempting to log in to Temporal Cloud without first accepting the invite doesn't work.\n\n### Roles and permissions\n\nEach user in Temporal Cloud is assigned a Role.\nEach user can be assigned permissions for individual Namespaces.\n\n- [Account-level Roles](/cloud/#account-level-roles)\n- [Namespace-level permissions](/cloud/#namespace-level-permissions)\n\n<!--- How to invite users in Temporal Cloud using Web UI --->\n\n### Invite users using Web UI\n\n:::info\n\nTo invite users, a user must have the Global Admin account-level [Role](/cloud/#account-level-roles).\n\n:::\n\n1. In Temporal Web UI, click **Settings** in the lower-left portion of the window.\n1. On the **Settings** page, click **Create Users** in the upper-right portion of the window.\n1. On the **Create Users** page in the **Email Addresses** box, type or paste one or more email addresses.\n1. In **Account-Level Role**, select a [Role](/cloud/#account-level-roles).\n   The Role applies to all users whose email addresses appear in **Email Addresses**.\n1. If the account has any Namespaces, they are listed under **Grant access to Namespaces**.\n   To add a permission, select the checkbox next to a Namespace, and then select a [permission](/cloud/#namespace-level-permissions).\n   Repeat as needed.\n1. When all permissions are assigned, click **Send Invite**.\n\nTemporal sends an email message to each user.\nTo join Temporal Cloud, a user must click **Accept Invite** in the message.\n","is_empty":false},{"file_name":"what-are-the-account-level-roles-for-users-in-temporal-cloud.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/what-are-the-account-level-roles-for-users-in-temporal-cloud.md","id":"cloud-context/what-are-the-account-level-roles-for-users-in-temporal-cloud","title":"What are the account-level Roles for users in Temporal Cloud?","description":"Account-level Roles are Global Admin, Developer, and Read-Only.","label":"Account-level Roles","markdown_content":"\nWhen a Global Admin invites a user to join an account, the Global Admin selects one of the following Roles for that user:\n\n- **Global Admin**\n  - Has full administrative permissions across the account, including users and usage\n  - Has Namespace Admin [permissions](/cloud/#namespace-level-permissions) on all [Namespaces](/namespaces) in the account\n- **Developer**\n  - Can create and update Namespaces; has full control over [Workflows](/workflows)\n  - Has Namespace Admin permissions for each Namespace created by that user\n- **Read-Only:** Can only read information\n","is_empty":false},{"file_name":"what-are-the-namespace-level-permissions-for-users-in-temporal-cloud.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud-context/what-are-the-namespace-level-permissions-for-users-in-temporal-cloud.md","id":"cloud-context/what-are-the-namespace-level-permissions-for-users-in-temporal-cloud","title":"What are the Namespace-level permissions for users in Temporal Cloud?","description":"Namespace-level permissions are Namespace Admin, Write, and Read-Only.","label":"Namespace-level permissions","markdown_content":"\nA [Global Admin](/cloud/#account-level-roles) can assign permissions for any [Namespace](/namespaces) in an account.\nA Developer can assign permissions for a Namespace they create.\n\nFor a Namespace, a user can have one of the following permissions:\n\n- **Namespace Admin:** Can create and edit Namespaces; can create, rename, update, and delete [Workflows](/workflows)\n- **Write:** Can create, rename, update, and delete Workflows within the Namespace\n- **Read-Only:** Can only read information from the Namespace\n","is_empty":false},{"file_name":"tcld/how-to-install-tcld.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/how-to-install-tcld.md","id":"cloud/tcld/how-to-install-tcld","title":"How to install tcld","description":"You can install tcld by using Homebrew or building from source.","label":"Install tcld","tags":["operation-guide","tcld"],"markdown_content":"\nYou can install [tcld](/cloud/tcld) in two ways.\n\n### Install tcld by using Homebrew\n\n```bash\nbrew install temporalio/brew/tcld\n```\n\n### Build tcld from source\n\n1. Verify that you have Go 1.18 or later installed.\n\n   ```bash\n   go version\n   ```\n\n   If Go 1.18 or later is not installed, follow the [Download and install](https://go.dev/doc/install) instructions on the Go website.\n\n1. Clone the tcld repository and run make.\n\n   ```bash\n   git clone https://github.com/temporalio/tcld.git\n   cd tcld\n   make\n   ```\n\n1. Copy the tcld executable to any directory that appears in the PATH environment variable, such as `/usr/local/bin`.\n\n   ```bash\n   cp tcld /usr/local/bin/tcld\n   ```\n\n1. Verify that tcld is installed.\n\n   ```bash\n   tcld version\n   ```\n","is_empty":false},{"file_name":"tcld/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/index.md","id":"cloud/tcld/index","title":"What is tcld?","description":"tcld is a command-line tool that you can use to interact with Temporal Cloud.","label":"tcld CLI","tags":["operation-guide","tcld"],"markdown_content":"\nThe Temporal Cloud CLI (tcld) is a command-line tool that you can use to interact with Temporal Cloud.\n\n- [How to install tcld](/cloud/tcld/how-to-install-tcld)\n\n### tcld commands\n\n- [tcld account](/cloud/tcld/account)\n- [tcld login](/cloud/tcld/login)\n- [tcld namespace](/cloud/tcld/namespace)\n- [tcld request](/cloud/tcld/request)\n- [tcld version](/cloud/tcld/version)\n\n### Global modifiers\n\n#### `--auto_confirm`\n\nAutomatically confirm all prompts.\n\nYou can specify the value for this modifier by setting the AUTO_CONFIRM environment variable.\nThe default value is `false`.\n","is_empty":false},{"file_name":"tcld/login.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/login.md","id":"cloud/tcld/login","title":"tcld login","description":"How to log in to Temporal Cloud using tcld.","label":"login","tags":["tcld"],"markdown_content":"\nThe `tcld login` command logs in a user to Temporal Cloud.\n\nFollow instructions in the browser to log in to your Temporal account.\n\nAlias: `l`\n\n`tcld login`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/version.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/version.md","id":"cloud/tcld/version","title":"tcld version","description":"How to get version information about tcld.","label":"version","tags":["tcld"],"markdown_content":"\nThe `tcld version` command gets version information about tcld.\n\nAlias: `v`\n\n`tcld version`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/request/get.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/request/get.md","id":"cloud/tcld/request/get","title":"tcld request get","description":"How to get the status of an asynchronous request in Temporal Cloud using tcld.","label":"get","tags":["tcld"],"markdown_content":"\nThe `tcld request get` command gets the status of the specified request in Temporal Cloud.\n\n`tcld request get --request-id <request_id>`\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace get --namespace <namespace_id> --request-id <request_id>\n```\n\n### `--request`\n\n_Required modifier_\n\nSpecify a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace get --request-id <request_id>\n```\n","is_empty":false},{"file_name":"tcld/request/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/request/index.md","id":"cloud/tcld/request/index","title":"tcld request","description":"How to manage asynchronous requests in Temporal Cloud using tcld.","label":"request","tags":["tcld"],"markdown_content":"\nThe `tcld request` commands manage asynchronous requests in Temporal Cloud.\n\nAlias: `r`\n\n- [tcld request get](/cloud/tcld/request/get)\n","is_empty":false},{"file_name":"tcld/namespace/get.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/get.md","id":"cloud/tcld/namespace/get","title":"tcld namespace get","description":"How to get information about a Namespace in Temporal Cloud using tcld.","label":"get","tags":["tcld"],"markdown_content":"\nThe `tcld namespace get` command gets information about the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `g`\n\n`tcld namespace get`\n\nThe following modifier controls the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace get --namespace <namespace_id>\n```\n","is_empty":false},{"file_name":"tcld/namespace/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/index.md","id":"cloud/tcld/namespace/index","title":"tcld namespace","description":"How to operate Namespaces in Temporal Cloud using tcld.","label":"namespace","tags":["tcld"],"markdown_content":"\nThe `tcld namespace` commands enable [Namespace](/concepts/what-is-a-namespace) operations in Temporal Cloud.\n\nAlias: `n`\n\n- [tcld namespace list](/cloud/tcld/namespace/list)\n- [tcld namespace get](/cloud/tcld/namespace/get)\n- [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/index)\n- [tcld namespace certificate-filters](/cloud/tcld/namespace/certificate-filters/index)\n- [tcld namespace search-attributes](/cloud/tcld/namespace/search-attributes/index)\n","is_empty":false},{"file_name":"tcld/namespace/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/list.md","id":"cloud/tcld/namespace/list","title":"tcld namespace list","description":"How to list all Namespaces in Temporal Cloud using tcld.","label":"list","tags":["tcld"],"markdown_content":"\nThe `tcld namespace list` command lists all [Namespaces](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `l`\n\n`tcld namespace list`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/namespace/search-attributes/add.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/search-attributes/add.md","id":"cloud/tcld/namespace/search-attributes/add","title":"tcld namespace search-attributes add","description":"How to add custom Search Attributes to a Namespace in Temporal Cloud using tcld.","label":"add","tags":["tcld"],"markdown_content":"\nThe `tcld namespace search-attributes add` command adds custom [Search Attributes](/concepts/what-is-a-search-attribute) to a Namespace in Temporal Cloud.\n\n`tcld namespace search-attributes add --search-attribute <value>`\n\nAlias: `a`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --namespace <namespace_id> --search-attribute <value>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --request-id <request_id> --search-attribute <value>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --resource-version <etag> --search-attribute <value>\n```\n\n#### `--search-attribute`\n\n_Required modifier; can be specified more than once_\n\nSpecify a custom Search Attribute in the form \"_name_=_type_\". Valid values for _type_ are as follows:\n\n- Bool\n- Datetime\n- Double\n- Int\n- Keyword\n- Text\n\nAlias: `--sa`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --search-attribute \"YourSearchAttribute1=Text\" --search-attribute \"YourSearchAttribute2=Double\"\n```\n","is_empty":false},{"file_name":"tcld/namespace/search-attributes/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/search-attributes/index.md","id":"cloud/tcld/namespace/search-attributes/index","title":"tcld namespace search-attributes","description":"How to manage Search Attributes of a Namespace in Temporal Cloud using tcld.","label":"search-attributes","tags":["tcld"],"markdown_content":"\nThe `tcld namespace search-attributes` commands manage [Search Attributes](/concepts/what-is-a-search-attribute) of the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `sa`\n\n- [tcld namespace search-attributes add](/cloud/tcld/namespace/search-attributes/add)\n- [tcld namespace search-attributes rename](/cloud/tcld/namespace/search-attributes/rename)\n","is_empty":false},{"file_name":"tcld/namespace/search-attributes/rename.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/search-attributes/rename.md","id":"cloud/tcld/namespace/search-attributes/rename","title":"tcld namespace search-attributes rename","description":"How to rename an existing custom Search Attribute in Temporal Cloud using tcld.","label":"rename","tags":["tcld"],"markdown_content":"\nThe `tcld namespace search-attributes rename` command renames a custom [Search Attribute](/concepts/what-is-a-search-attribute) in Temporal Cloud.\n\n`tcld namespace search-attributes rename --existing-name <value> --new-name <value>`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --namespace <namespace_id> --existing-name <value> --new-name <value>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --request-id <request_id> --existing-name <value> --new-name <value>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --resource-version <etag> --existing-name <value> --new-name <value>\n```\n\n#### `--existing-name`\n\n_Required modifier_\n\nSpecify the name of an existing Search Attribute.\n\nAlias: `--en`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --existing-name <value> --new-name <value>\n```\n\n#### `--new-name`\n\n_Required modifier_\n\nSpecify a new name for the Search Attribute.\n\nAlias: `--nn`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --existing-name <value> --new-name <value>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/clear.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/certificate-filters/clear.md","id":"cloud/tcld/namespace/certificate-filters/clear","title":"tcld namespace certificate-filters clear","description":"How to clear all certificate filters from a Namespace in Temporal Cloud using tcld.","label":"clear","tags":["tcld"],"markdown_content":"\nThe `tcld namespace certificate-filters clear` command clears all certificate filters from a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n:::caution\n\nUsing this command allows _any_ client certificate that chains up to a configured CA certificate to connect to the Namespace.\n\n:::\n\n`tcld namespace certificate-filters clear`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters clear --namespace <namespace_id>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters clear --request-id <request_id>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters clear --resource-version <etag>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/export.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/certificate-filters/export.md","id":"cloud/tcld/namespace/certificate-filters/export","title":"tcld namespace certificate-filters export","description":"How to export certificate filters from a Namespace in Temporal Cloud using tcld.","label":"export","tags":["tcld"],"markdown_content":"\nThe `tcld namespace certificate-filters export` command exports existing certificate filters from a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace certificate-filters export --certificate-filter-file <path>`\n\nAlias: `exp`\n\nThe following modifiers control the behavior of the command.\n\n#### `--certificate-filter-file`\n\nSpecify a path to a JSON file where tcld can export the certificate filters.\n\nAliases: `--file`, `-f`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters export --certificate-filter-file <path>\n```\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --namespace <namespace_id> --certificate-filter-input <json>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --request-id <request_id> --certificate-filter-input <json>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --resource-version <etag> --certificate-filter-input <json>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/import.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/certificate-filters/import.md","id":"cloud/tcld/namespace/certificate-filters/import","title":"tcld namespace certificate-filters import","description":"How to set certificate filters for a Namespace in Temporal Cloud using tcld.","label":"import","tags":["tcld"],"markdown_content":"\nThe `tcld namespace certificate-filters import` command sets certificate filters for a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace certificate-filters import --certificate-filter-file <path>`\n\nAlias: `imp`\n\nA certificate filter can include any combination (and at least one) of the following:\n\n- `commonName`\n- `organization`\n- `organizationalUnit`\n- `subjectAlternativeName`\n\nThe following modifiers control the behavior of the command.\n\n#### `--certificate-filter-file`\n\n_Required modifier unless `--certificate-filter-input` is specified_\n\nSpecify a path to a JSON file that defines certificate filters to be applied to the Namespace, such as `{ \"filters\": [ { \"commonName\": \"test1\" } ] }`. The specified filters replace any existing filters.\n\nIf both `--certificate-filter-file` and `--certificate-filter-input` are specified, the command returns an error.\n\nAliases: `--file`, `-f`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --certificate-filter-file <path>\n```\n\n#### `--certificate-filter-input`\n\n_Required modifier unless `--certificate-filter-file` is specified_\n\nSpecify a JSON string that defines certificate filters to be applied to the Namespace, such as `{ \"filters\": [ { \"commonName\": \"test1\" } ] }`. The specified filters replace any existing filters.\n\nIf both `--certificate-filter-input` and `--certificate-filter-file` are specified, the command returns an error.\n\nAliases: `--input`, `-i`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --certificate-filter-input <json>\n```\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --namespace <namespace_id> --certificate-filter-input <json>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --request-id <request_id> --certificate-filter-input <json>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --resource-version <etag> --certificate-filter-input <json>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/certificate-filters/index.md","id":"cloud/tcld/namespace/certificate-filters/index","title":"tcld namespace certificate-filters","description":"How to manage certificate filters for a Namespace in Temporal Cloud using tcld.","label":"certificate-filters","tags":["tcld"],"markdown_content":"\nThe `tcld namespace certificate-filters` commands manage optional certificate filters for the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud. The Namespace can use certificate filters to authorize client certificates based on distinguished name (DN) fields.\n\nAlias: `cf`\n\n- [tcld namespace certificate-filters import](/cloud/tcld/namespace/certificate-filters/import)\n- [tcld namespace certificate-filters export](/cloud/tcld/namespace/certificate-filters/export)\n- [tcld namespace certificate-filters clear](/cloud/tcld/namespace/certificate-filters/clear)\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/add.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/add.md","id":"cloud/tcld/namespace/accepted-client-ca/add","title":"tcld namespace accepted-client-ca add","description":"How to add client CA certificates to a Namespace in Temporal Cloud using tcld.","label":"add","tags":["tcld"],"markdown_content":"\nThe `tcld namespace accepted-client-ca add` command adds client CA certificates to a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca add --ca-certificate <value>`\n\nAlias: `a`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --namespace <namespace_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/index.md","id":"cloud/tcld/namespace/accepted-client-ca/index","title":"tcld namespace accepted-client-ca","description":"How to manage the client CA certificates for a Namespace in Temporal Cloud using tcld.","label":"accepted-client-ca","tags":["tcld"],"markdown_content":"\nThe `tcld namespace accepted-client-ca` commands manage the client CA certificates of the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud. The certificates are used to verify client connections.\n\n:::important\n\nDo not use a CA certificate that is signed with an insecure signature algorithm, such as SHA-1.\nSuch signatures will be rejected.\nExisting CA certificates that use SHA-1 can stop working without warning.\n\nFor more information about the vulnerabilities of SHA-1, see [SHAttered](https://shattered.io/).\n\n:::\n\nAlias: `ca`\n\n- [tcld namespace accepted-client-ca add](/cloud/tcld/namespace/accepted-client-ca/add)\n- [tcld namespace accepted-client-ca list](/cloud/tcld/namespace/accepted-client-ca/list)\n- [tcld namespace accepted-client-ca set](/cloud/tcld/namespace/accepted-client-ca/set)\n- [tcld namespace accepted-client-ca remove](/cloud/tcld/namespace/accepted-client-ca/remove)\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/list.md","id":"cloud/tcld/namespace/accepted-client-ca/list","title":"tcld namespace accepted-client-ca list","description":"How to list the client CA certificates for a Namespace in Temporal Cloud using tcld.","label":"list","tags":["tcld"],"markdown_content":"\nThe `tcld namespace accepted-client-ca list` command lists the client CA certificates that are currently configured for a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca list`\n\nAlias: `l`\n\nThe following modifier controls the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca list --namespace <namespace_id>\n```\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/remove.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/remove.md","id":"cloud/tcld/namespace/accepted-client-ca/remove","title":"tcld namespace accepted-client-ca remove","description":"How to remove client CA certificates from a Namespace in Temporal Cloud using tcld.","label":"remove","tags":["tcld"],"markdown_content":"\nThe `tcld namespace accepted-client-ca remove` command removes client CA certificates from a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca remove --ca-certificate <value>`\n\nAlias: `r`\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --namespace <namespace_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate-file` is specified_\n\nSpecify the base64-encoded string of a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate` and `--ca-certificate-file` are ignored.\n\nIf `--ca-certificate-file` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate-file` and `--ca-certificate` are ignored.\n\nIf `--ca-certificate` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --ca-certificate-file <path>\n```\n\n#### `--ca-certificate-fingerprint`\n\n_Required modifier unless `--ca-certificate` or `--ca-certificate-file` is specified_\n\nSpecify the fingerprint of a CA certificate.\n\nIf `--ca-certificate`, `--ca-certificate-file`, or both are also specified, they are ignored.\n\nAlias: `--fp`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --ca-certificate-fingerprint <fingerprint>\n```\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/set.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/namespace/accepted-client-ca/set.md","id":"cloud/tcld/namespace/accepted-client-ca/set","title":"tcld namespace accepted-client-ca set","description":"How to set the client CA certificates for a Namespace in Temporal Cloud using tcld.","label":"set","tags":["tcld"],"markdown_content":"\nThe `tcld namespace accepted-client-ca set` command sets the client CA certificates for a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca set --ca-certificate <value>`\n\nAlias: `s`\n\n<!--- How to rollover accepted client CA certificates in Temporal Cloud using tcld --->\n\nWhen updating CA certificates, it's important to follow a rollover process.\nDoing so enables your Namespace to serve both CA certificates for a period of time until traffic to your old CA certificate ceases.\n\n1. Create a single file that contains both your old and new CA certificate PEM blocks.\n   Just concatenate the PEM blocks on adjacent lines.\n\n   ```\n   -----BEGIN CERTIFICATE-----\n   ... old CA cert ...\n   -----END CERTIFICATE-----\n   -----BEGIN CERTIFICATE-----\n   ... new CA cert ...\n   -----END CERTIFICATE-----\n   ```\n\n1. Run the `tcld namespace accepted-client-ca set` command with the CA certificate bundle file.\n\n   ```bash\n   tcld namespace accepted-client-ca set --ca-certificate-file <path>\n   ```\n\n1. Monitor traffic to your old certificate until it ceases.\n\n1. Create another file that contains only the new CA certificate.\n\n1. Run the `tcld namespace accepted-client-ca set` command again with the updated CA certificate bundle file.\n\nThe following modifiers control the behavior of the command.\n\n#### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --namespace <namespace_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n#### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --ca-certificate <encoded_certificate>\n```\n\n#### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"tcld/account/get.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/get.md","id":"cloud/tcld/account/get","title":"tcld account get","description":"How to get information about an account in Temporal Cloud using tcld.","label":"get","tags":["tcld"],"markdown_content":"\nThe `tcld account get` command gets information about the Temporal Cloud account you are logged into.\n\nAlias: `g`\n\n`tcld account get`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/account/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/index.md","id":"cloud/tcld/account/index","title":"tcld account","description":"How to manage accounts in Temporal Cloud using tcld.","label":"account","tags":["tcld"],"markdown_content":"\nThe `tcld account` commands manage accounts in Temporal Cloud.\n\nAlias: `a`\n\n- [tcld account get](/cloud/tcld/account/get)\n- [tcld account metrics](/cloud/tcld/account/metrics/index)\n","is_empty":false},{"file_name":"tcld/account/metrics/disable.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/metrics/disable.md","id":"cloud/tcld/account/metrics/disable","title":"tcld account metrics disable","description":"How to disable the metrics endpoint for a Temporal Cloud account using tcld.","label":"disable","tags":["tcld"],"markdown_content":"\nThe `tcld account metrics disable` command disables the metrics endpoint for the Temporal Cloud account that is currently logged in.\n\n`tcld account metrics disable`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/account/metrics/enable.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/metrics/enable.md","id":"cloud/tcld/account/metrics/enable","title":"tcld account metrics enable","description":"How to enable the metrics endpoint for a Temporal Cloud account using tcld.","label":"enable","tags":["tcld"],"markdown_content":"\nThe `tcld account metrics enable` command enables the metrics endpoint for the Temporal Cloud account that is currently logged in.\n\n:::info\n\nThe end-entity for the metrics endpoint _must_ be configured before the endpoint can be enabled. See the [tcld account metrics accepted-client-ca](/cloud/tcld/account/metrics/accepted-client-ca/index) commands.\n\n:::\n\n`tcld account metrics enable`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/account/metrics/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/metrics/index.md","id":"cloud/tcld/account/metrics/index","title":"tcld account metrics","description":"How to configure the metrics endpoint for a Temporal Cloud account using tcld.","label":"metrics","tags":["tcld"],"markdown_content":"\nThe `tcld account metrics` commands configure the metrics endpoint for the Temporal Cloud account that is currently logged in.\n\nAlias: `m`\n\n- [tcld account metrics enable](/cloud/tcld/account/metrics/enable)\n- [tcld account metrics disable](/cloud/tcld/account/metrics/disable)\n- [tcld account metrics accepted-client-ca](/cloud/tcld/account/metrics/accepted-client-ca/index)\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/add.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/add.md","id":"cloud/tcld/account/metrics/accepted-client-ca/add","title":"tcld account metrics accepted-client-ca add","description":"How to add end-entity certificates to the metrics endpoint of a Temporal Cloud account using tcld.","label":"add","tags":["tcld"],"markdown_content":"\nThe `tcld account metrics accepted-client-ca add` command adds end-entity certificates to the metrics endpoint of a Temporal Cloud account.\n\n:::info\n\nThe end-entity certificates for the metrics endpoint must chain up to the CA certificate used for the account. For more information, see [Certificate requirements](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements).\n\n:::\n\n`tcld account metrics accepted-client-ca add --ca-certificate <value>`\n\nAlias: `a`\n\nThe following modifiers control the behavior of the command.\n\n##### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca add --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n##### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca add --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca add --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca add --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/index.md","id":"cloud/tcld/account/metrics/accepted-client-ca/index","title":"tcld account metrics accepted-client-ca","description":"How to managed the end-entity certificates for the metrics endpoint of a Temporal Cloud account using tcld.","label":"accepted-client-ca","tags":["tcld"],"markdown_content":"\nThe `tcld account metrics accepted-client-ca` commands manage the end-entity certificates for the metrics endpoint of the Temporal Cloud account that is currently logged in.\n\n:::info\n\nThe end-entity certificates for the metrics endpoint must chain up to the CA certificate used for the account. For more information, see [Certificate requirements](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements).\n\n:::\n\nAlias: `ca`\n\n- [tcld account metrics accepted-client-ca add](/cloud/tcld/account/metrics/accepted-client-ca/add)\n- [tcld account metrics accepted-client-ca list](/cloud/tcld/account/metrics/accepted-client-ca/list)\n- [tcld account metrics accepted-client-ca set](/cloud/tcld/account/metrics/accepted-client-ca/set)\n- [tcld account metrics accepted-client-ca remove](/cloud/tcld/account/metrics/accepted-client-ca/remove)\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/list.md","id":"cloud/tcld/account/metrics/accepted-client-ca/list","title":"tcld account metrics accepted-client-ca list","description":"How to list the end-entity certificates for the metrics endpoint of a Temporal Cloud account using tcld.","label":"list","tags":["tcld"],"markdown_content":"\nThe `tcld account metrics accepted-client-ca list` command lists the end-entity certificates that are currently configured for the metrics endpoint of a Temporal Cloud account.\n\n`tcld account metrics accepted-client-ca list`\n\nAlias: `l`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/remove.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/remove.md","id":"cloud/tcld/account/metrics/accepted-client-ca/remove","title":"tcld account metrics accepted-client-ca remove","description":"How to remove end-entity certificates from the metrics endpoint of a Temporal Cloud account using tcld.","label":"remove","tags":["tcld"],"markdown_content":"\nThe `tcld account metrics accepted-client-ca remove` command removes end-entity certificates from the metrics endpoint of a Temporal Cloud account.\n\n`tcld account metrics accepted-client-ca remove --ca-certificate <value>`\n\nAlias: `r`\n\nThe following modifiers control the behavior of the command.\n\n##### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n##### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate` and `--ca-certificate-file` are ignored.\n\nIf `--ca-certificate-file` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate-file` and `--ca-certificate` are ignored.\n\nIf `--ca-certificate` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --ca-certificate-file <path>\n```\n\n##### `--ca-certificate-fingerprint`\n\n_Required modifier unless `--ca-certificate` or `--ca-certificate-file` is specified_\n\nSpecify the fingerprint of a CA certificate.\n\nIf `--ca-certificate`, `--ca-certificate-file`, or both are also specified, they are ignored.\n\nAlias: `--fp`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca remove --ca-certificate-fingerprint <fingerprint>\n```\n","is_empty":false},{"file_name":"tcld/account/metrics/accepted-client-ca/set.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cloud/tcld/account/metrics/accepted-client-ca/set.md","id":"cloud/tcld/account/metrics/accepted-client-ca/set","title":"tcld account metrics accepted-client-ca set","description":"How to set the end-entity certificates for the metrics endpoint of a Temporal Cloud account using tcld.","label":"set","tags":["tcld"],"markdown_content":"\nThe `tcld account metrics accepted-client-ca set` command sets the end-entity certificates for the metrics endpoint of a Temporal Cloud account.\n\n:::info\n\nThe end-entity certificates for the metrics endpoint must chain up to the CA certificate used for the account. For more information, see [Certificate requirements](/cloud/how-to-manage-certificates-in-temporal-cloud#certificate-requirements).\n\n:::\n\n`tcld account metrics accepted-client-ca set --ca-certificate <value>`\n\nAlias: `s`\n\nThe following modifiers control the behavior of the command.\n\n##### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca set --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n##### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca set --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca set --ca-certificate <encoded_certificate>\n```\n\n##### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld account metrics accepted-client-ca set --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"activity-heartbeats.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/activity-heartbeats.md","id":"app-dev-context/activity-heartbeats","title":"How to Heartbeat an Activity","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.","label":"Activity Heartbeats","tags":["guide-context"],"markdown_content":"\nAn [Activity Heartbeat](/concepts/what-is-an-activity-heartbeat) is a ping from the [Worker Process](/concepts/what-is-a-worker-process) that is executing the Activity to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nEach Heartbeat informs the Temporal Cluster that the [Activity Execution](/concepts/what-is-an-activity-execution) is making progress and the Worker has not crashed.\nIf the Cluster does not receive a Heartbeat within a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) time period, the Activity will be considered failed and another [Activity Task Execution](/concepts/what-is-an-activity-task-execution) may be scheduled according to the Retry Policy.\n\nHeartbeats may not always be sent to the Cluster—they may be [throttled](/concepts/what-is-an-activity-heartbeat#throttling) by the Worker.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\nHeartbeats can contain a `details` field describing the Activity's current progress.\nIf an Activity gets retried, the Activity can access the `details` from the last Heartbeat that was sent to the Cluster.\n","is_empty":false},{"file_name":"activity-parameters.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/activity-parameters.md","id":"app-dev-context/activity-parameters","title":"How to develop Activity Parameters","description":"When it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.","label":"Activity parameters","tags":["guide-context"],"markdown_content":"\nThere is no explicit limit to the total number of parameters that an [Activity Definition](/concepts/what-is-an-activity-definition) may support.\nHowever, there is a limit of the total size of the data ends up encoded into a gRPC message Payload.\n\nA single argument is limited to a maximum size of 2 MB.\nAnd the total size of a gRPC message, which includes all the arguments, is limited to a maximum of 4 MB.\n\nAlso, keep in mind that all Payload data is recorded in the [Workflow Execution Event History](/concepts/what-is-an-event-history) and large Event Histories can affect Worker performance.\nThis is because the entire Event History could be transferred to a Worker Process with a [Workflow Task](/concepts/what-is-a-workflow-task).\n\n<!--TODO link to gRPC limit section when available -->\n\nSome SDKs require that you pass context objects, others do not.\nWhen it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.\nThis is so that you can change what data is passed to the Activity without breaking a function or method signature.\n","is_empty":false},{"file_name":"activity-retries.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/activity-retries.md","id":"app-dev-context/activity-retries","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity retries","tags":["guide-context"],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-policy.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/activity-retry-policy.md","id":"app-dev-context/activity-retry-policy","title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity Retry Policy","tags":["guide-context"],"markdown_content":"\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-simulator.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/activity-retry-simulator.md","id":"app-dev-context/activity-retry-simulator","title":"How to visualize an Activity Retry Policy with timeouts","description":"Use this tool to visualize total Activity Execution times and experiment with various Activity timeouts and Retry Policies.","label":"Activity retry simulator","tags":["guide-context"],"markdown_content":"\nUse this tool to visualize total Activity Execution times and experiment with different Activity timeouts and Retry Policies.\n\nThe simulator is based on a common Activity use-case, which is to call a third party HTTP API and return the results.\nSee the example code snippets below.\n\nUse the Activity Retries settings to configure how long the API request takes to succeed or fail.\nThere is an option to generate scenarios.\nThe _Task Time in Queue_ simulates the time the Activity Task might be waiting in the Task Queue.\n\nUse the Activity Timeouts and Retry Policy settings to see how they impact the success or failure of an Activity Execution.\n\nimport RetrySimulator from '/docs/components/RetrySimulator/RetrySimulator';\n\n<RetrySimulator />\n","is_empty":false},{"file_name":"activity-return-values.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/activity-return-values.md","id":"app-dev-context/activity-return-values","title":"How to define Activity return values","description":"All data returned from an Activity must be serializable.","label":"Activity return values","tags":["guide-context"],"markdown_content":"\nAll data returned from an Activity must be serializable.\n\nThere is no explicit limit to the amount of data that can be returned by an Activity, but keep in mind that all return values are recorded in a [Workflow Execution Event History](/concepts/what-is-an-event-history).\n","is_empty":false},{"file_name":"activity-timeouts-and-retries.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/activity-timeouts-and-retries.md","id":"app-dev-context/activity-timeouts-and-retries","title":"How to set Activity timeouts and retries","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts and retries","tags":["guide-context"],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"activity-timeouts.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/activity-timeouts.md","id":"app-dev-context/activity-timeouts","title":"How to set Activity timeouts","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity timeouts","tags":["guide-context"],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\n\nThe following timeouts are available in the Activity Options.\n\n- **[Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout)**: is the maximum amount of time allowed for the overall [Activity Execution](/concepts/what-is-an-activity-execution).\n- **[Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout)**: is the maximum time allowed for a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n- **[Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout)**: is the maximum amount of time that is allowed from when an [Activity Task](/concepts/what-is-an-activity-task) is scheduled to when a [Worker](/concepts/what-is-a-worker) starts that Activity Task.\n\nAn Activity Execution must have either the Start-To-Close or the Schedule-To-Close Timeout set.\n","is_empty":false},{"file_name":"activity-type.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/activity-type.md","id":"app-dev-context/activity-type","title":"How to customize your Activity Type","description":"You can set a custom name for your Activity Type.","label":"Activity Type","tags":["guide-context"],"markdown_content":"\nActivities have a Type that are referred to as the Activity name.\nThe following examples demonstrate how to set a custom name for your Activity Type.\n","is_empty":false},{"file_name":"add-sdk.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/add-sdk.md","id":"app-dev-context/add-sdk","title":"How to install a Temporal SDK","description":"A Temporal SDK provides a framework for Temporal Application development.","label":"Install a Temporal SDK","tags":["guide-context"],"markdown_content":"\nA [Temporal SDK](/concepts/what-is-a-temporal-sdk) provides a framework for [Temporal Application](/concepts/what-is-a-temporal-application) development.\n\nAn SDK provides you with the following:\n\n- A [Temporal Client](/concepts/what-is-a-temporal-client) to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n- APIs to develop [Workflows](/concepts/what-is-a-workflow).\n- APIs to create and manage [Worker Processes](/concepts/what-is-a-worker).\n- APIs to author [Activities](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"advanced-visibility.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/advanced-visibility.md","id":"app-dev-context/advanced-visibility","title":"How to use Advanced Visibility application features","description":"Advanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through a custom SQL-like List Filter.","label":"Advanced Visibility","tags":["guide-context"],"markdown_content":"\n[Advanced Visibility](concepts/advanced-visibility), within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through a custom SQL-like [List Filter](/concepts/what-is-a-list-filter).\n","is_empty":false},{"file_name":"api-reference.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/api-reference.md","id":"app-dev-context/api-reference","title":"How to find an SDK API reference","description":"Each SDK has its own API reference. Select a programming language and follow the link to be taken to that reference page.","label":"API reference","tags":["guide-context"],"markdown_content":"\nEach SDK has its own API reference. Select a programming language and follow the link to be taken to that reference page.\n","is_empty":false},{"file_name":"assert-in-workflows.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/assert-in-workflows.md","id":"app-dev-context/assert-in-workflows","title":"Assert in Workflows","description":"How to Assert in Workflows","label":"Assert in Workflows","tags":["guide-context"],"markdown_content":"\n<!-- not used -->\n\nIn some cases it's useful to assert directly in the Workflow context.\n\nFor example, TypeScript and Python, can use `assert` in Workflow code.\n","is_empty":false},{"file_name":"async-activity-completion.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/async-activity-completion.md","id":"app-dev-context/async-activity-completion","title":"How to asynchronously complete an Activity","description":"Asynchronous Activity Completion enables the Activity Function to return without the Activity Execution completing.","label":"Asynchronous Activity Completion","tags":["guide-context"],"markdown_content":"\n[Asynchronous Activity Completion](/concepts/what-is-asynchronous-activity-completion) enables the Activity Function to return without the Activity Execution completing.\n\nThere are three steps to follow:\n\n1. The Activity provides the external system with identifying information needed to complete the Activity Execution.\n   Identifying information can be a [Task Token](/concepts/what-is-a-task-token), or a combination of Namespace, Workflow Id, and Activity Id.\n2. The Activity Function completes in a way that identifies it as waiting to be completed by an external system.\n3. The Temporal Client is used to Heartbeat and complete the Activity.\n","is_empty":false},{"file_name":"cancel-an-activity.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/cancel-an-activity.md","id":"app-dev-context/cancel-an-activity","title":"Cancel an Activity","description":"If an Activity is supposed to react to Cancellation, you can test whether it reacts correctly by canceling it.","label":"Cancel an Activity","tags":["guide-context"],"markdown_content":"\nIf an Activity is supposed to react to a Cancellation, you can test whether it reacts correctly by canceling it.\n","is_empty":false},{"file_name":"child-workflows.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/child-workflows.md","id":"app-dev-context/child-workflows","title":"How to start a Child Workflow Execution","description":"A Child Workflow Execution is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.","label":"Child Workflows","tags":["guide-context"],"markdown_content":"\nA [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.\n\nWhen using a Child Workflow API, Child Workflow related Events ([StartChildWorkflowExecutionInitiated](/references/events#startchildworkflowexecutioninitiated), [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted), [ChildWorkflowExecutionCompleted](/references/events#childworkflowexecutioncompleted), etc...) are logged in the Workflow Execution Event History.\n\nAlways block progress until the [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted) Event is logged to the Event History to ensure the Child Workflow Execution has started.\nAfter that, Child Workflow Executions may be abandoned using the default _Abandon_ [Parent Close Policy](/concepts/what-is-a-parent-close-policy) set in the Child Workflow Options.\n\nTo be sure that the Child Workflow Execution has started, first call the Child Workflow Execution method on the instance of Child Workflow future, which returns a different future.\n\nThen get the value of an object that acts as a proxy for a result that is initially unknown, which is what waits until the Child Workflow Execution has spawned.\n","is_empty":false},{"file_name":"code-samples.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/code-samples.md","id":"app-dev-context/code-samples","title":"Where are SDK-specific code examples?","description":"You can find a complete list of executable code samples in Temporal's GitHub repository.","label":"Code samples","tags":["guide-context"],"markdown_content":"\nYou can find a complete list of executable code samples in [Temporal's GitHub repository](https://github.com/temporalio?q=samples-&type=all&language=&sort=).\n\nAdditionally, several of the [Tutorials](https://learn.temporal.io) are backed by a fully executable template application.\n","is_empty":false},{"file_name":"connect-to-a-cluster.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/connect-to-a-cluster.md","id":"app-dev-context/connect-to-a-cluster","title":"How to connect a Temporal Client to a Temporal Cluster","description":"When connecting a Temporal Client to a Temporal Cluster, you must provide the address and port number of the Temporal Cluster.","label":"Connect to a Cluster","tags":["guide-context"],"markdown_content":"\nA [Temporal Client](/concepts/what-is-a-temporal-client) enables you to communicate with the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nCommunication with a Temporal Cluster includes, but isn't limited to, the following:\n\n- Starting Workflow Executions.\n- Sending Signals to Workflow Executions.\n- Sending Queries to Workflow Executions.\n- Getting the results of a Workflow Execution.\n- Providing an Activity Task Token.\n\n:::caution\n\nA Temporal Client cannot be initialized and used inside a Workflow.\nHowever, it is acceptable and common to use a Temporal Client inside an Activity to communicate with a Temporal Cluster.\n\n:::\n\nWhen you are running a Cluster locally (such as [Temporalite](/clusters/quick-install#temporalite)), the number of connection options you must provide is minimal.\nMany SDKs default to the local host or IP address and port that Temporalite and [Docker Compose](/clusters/quick-install#docker-compose) serve (`127.0.0.1:7233`).\n\nWhen you are connecting to a production Cluster (such as [Temporal Cloud](/cloud)), you will likely need to provide additional connection and client options that might include, but aren't limited to, the following:\n\n- An address and port number.\n- A [Namespace](/concepts/what-is-a-namespace) Name (like a Temporal Cloud Namespace: `<Namespace_ID>.tmprl.cloud`).\n- mTLS CA certificate.\n- mTLS private key.\n\nFor more information about managing and generating client certificates for Temporal Cloud, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud.md).\n\nFor more information about configuring TLS to secure inter and intra network communication for a Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n","is_empty":false},{"file_name":"continue-as-new.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/continue-as-new.md","id":"app-dev-context/continue-as-new","title":"How to Continue-As-New","description":"Continue-As-New enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.","label":"Continue-As-New","tags":["guide-context"],"markdown_content":"\n[Continue-As-New](/concepts/what-is-continue-as-new) enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.\nThe Workflow Execution spawned from the use of Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\n","is_empty":false},{"file_name":"cron-jobs.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/cron-jobs.md","id":"app-dev-context/cron-jobs","title":"How to use Temporal Cron Jobs","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Jobs","tags":["guide-context"],"markdown_content":"\nA [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.\n","is_empty":false},{"file_name":"custom-logging.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/custom-logging.md","id":"app-dev-context/custom-logging","title":"How to provide a custom logger","description":"Use a custom logger for logging.","label":"Custom logger","tags":["guide-context"],"markdown_content":"\nUse a custom logger for logging.\n","is_empty":false},{"file_name":"debug-environment-development.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/debug-environment-development.md","id":"app-dev-context/debug-environment-development","title":"How to debug in a development environment","description":"In addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the Web UI and tctl.","label":"Debug in a development environment","tags":["guide-context"],"markdown_content":"\nIn addition to the normal development tools of logging and a debugger, you can also see what’s happening in your Workflow by using the [Web UI](/web-ui) or [`tctl`](/tctl-v1).\n","is_empty":false},{"file_name":"debug-environment-production.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/debug-environment-production.md","id":"app-dev-context/debug-environment-production","title":"How to debug in a development production","description":"Debug production Workflows using the Web UI, tctl, Replays, Tracing, or Logging.","label":"Debug in a development production","tags":["guide-context"],"markdown_content":"\nYou can debug production Workflows using:\n\n- [Web UI](/web-ui)\n- [tctl](/tctl-v1)\n- [Replay](#replay)\n- [Tracing](/application-development/observability#tracing)\n- [Logging](/application-development/observability#logging)\n\nYou can debug and tune Worker performance with metrics and the [Worker performance guide](/application-development/worker-performance). For more information, see [Observability ▶️ Metrics](/application-development/observability#metrics) for setting up SDK metrics.\n\nDebug Server performance with [Cloud metrics](/cloud/how-to-monitor-temporal-cloud-metrics) or [self-hosted Server metrics](/server/production-deployment#scaling-and-metrics).\n","is_empty":false},{"file_name":"debugging.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/debugging.md","id":"app-dev-context/debugging","title":"Debugging","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Debug","tags":["guide-context"],"markdown_content":"","is_empty":false},{"file_name":"define-query.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/define-query.md","id":"app-dev-context/define-query","title":"How to define a Query","description":"A Query has a name and can have arguments.","label":"Define Query","tags":["guide-context"],"markdown_content":"\nA Query has a name and can have arguments.\n\n- The name, also called a Query type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter/).\n","is_empty":false},{"file_name":"define-signal.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/define-signal.md","id":"app-dev-context/define-signal","title":"How to define a Signal","description":"A Signal has a name and can have arguments.","label":"Define Signal","tags":["guide-context"],"markdown_content":"\nA Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter/).\n","is_empty":false},{"file_name":"developing-activities.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/developing-activities.md","id":"app-dev-context/developing-activities","title":"How to develop a basic Activity","description":"One of the primary things that Workflows do is orchestrate the execution of Activities.","label":"Develop Activities","tags":["guide-context"],"markdown_content":"\nOne of the primary things that Workflows do is orchestrate the execution of Activities.\nActivities are normal function/method executions that can interact with the world.\nFor the Workflow to be able to execute the Activity, we must define the [Activity Definition](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"developing-workflows.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/developing-workflows.md","id":"app-dev-context/developing-workflows","title":"How to develop a basic Workflow","description":"Workflows are the fundamental unit of a Temporal Application, and it all starts with the development of a Workflow Definition.","label":"Develop Workflows","tags":["guide-context"],"markdown_content":"\nWorkflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/concepts/what-is-a-workflow-definition).\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/environment-variables.md","id":"app-dev-context/environment-variables","title":"How to read and pass environment variables","description":"Environment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.","label":"Environment variables","tags":["guide-context"],"markdown_content":"\nEnvironment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.\nThey can't be used normally with Workflow code, as that would be [nondeterministic](/concepts/what-is-a-workflow-definition#intrinsic-non-deterministic-logic) (if the environment variables changed between Workflow replays, the code that used them would behave differently).\n\nMost of the time, you can provide environment variables in your Activity function; however, if you need them in your Workflow functions, you can use the following options:\n\n- Provide environment variables as arguments when starting the Workflow.\n- Call a Local Activity at the beginning of the Workflow that returns environment variables.\n\nIn either case, the environment variables will appear in Event History, so you may want to use an [encryption Data Converter](/concepts/what-is-a-data-converter/#encryption).\n","is_empty":false},{"file_name":"features.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/features.md","id":"app-dev-context/features","title":"How to use Workflow and Activity features","description":"The Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.","label":"Features","tags":["guide-context"],"markdown_content":"\nThe Features section of the Temporal Developer's guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Developer's guide, it could be in [older docs for SDKs](https://legacy-documentation-sdks.temporal.io/).\n\n:::\n\nIn this section you can find the following:\n\n- [How to develop Signals](#signals)\n- [How to develop Queries](#queries)\n- [How to start a Child Workflow Execution](#child-workflows)\n- [How to start a Temporal Cron Job](#temporal-cron-jobs)\n- [How to use Continue-As-New](#continue-as-new)\n- [How to set Workflow timeouts & retries](#workflow-timeouts)\n- [How to set Activity timeouts & retries](#activity-timeouts)\n- [How to Heartbeat an Activity](#activity-heartbeats)\n- [How to Asynchronously complete an Activity](#asynchronous-activity-completion)\n- [How to register Namespaces](#namespaces)\n","is_empty":false},{"file_name":"foundations.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/foundations.md","id":"app-dev-context/foundations","title":"How to build a basic Temporal Application","description":"The Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application—that is, all the relevant steps to start a Workflow Execution that executes an Activity.","label":"Foundations","tags":["guide-context"],"markdown_content":"\nThe Foundations section of the Temporal Developer's guide covers the minimum set of concepts and implementation details needed to build and run a [Temporal Application](/concepts/what-is-a-temporal-application)—that is, all the relevant steps to start a [Workflow Execution](#develop-workflows) that executes an [Activity](#develop-activities).\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Developer's guide, it could be in [older docs for SDKs](https://legacy-documentation-sdks.temporal.io/).\n\n:::\n\nIn this section you can find the following:\n\n- [How to run a dev Cluster](#run-a-dev-cluster)\n- [How to add your SDK](#add-your-sdk)\n- [How to create a Temporal Client](#connect-to-a-cluster)\n- [How to develop a Workflow](#develop-workflows)\n- [How to develop an Activity](#develop-activities)\n- [How to start an Activity Execution](#activity-execution)\n- [How to run a Worker Process](#run-worker-processes)\n- [How to start a Workflow Execution](#start-workflow-execution)\n","is_empty":false},{"file_name":"get-activity-results.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/get-activity-results.md","id":"app-dev-context/get-activity-results","title":"How to get the results of an Activity Execution","description":"The call to spawn an Activity Execution generates the ScheduleActivityTask Command and provides the Workflow with an Awaitable.","label":"Get Activity results","tags":["guide-context"],"markdown_content":"\nThe call to spawn an [Activity Execution](/concepts/what-is-an-activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.\n","is_empty":false},{"file_name":"get-workflow-results.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/get-workflow-results.md","id":"app-dev-context/get-workflow-results","title":"How to get the results of a Workflow Execution","description":"If the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.","label":"Get Workflow results","tags":["guide-context"],"markdown_content":"\nIf the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.\n\nThe Workflow Id, Run Id, and Namespace may be used to uniquely identify a Workflow Execution in the system and get its result.\n\nIt's possible to both block progress on the result (synchronous execution) or get the result at some other point in time (asynchronous execution).\n\nIn the Temporal Platform, it's also acceptable to use Queries as the preferred method for accessing the state and results of Workflow Executions.\n","is_empty":false},{"file_name":"handle-query.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/handle-query.md","id":"app-dev-context/handle-query","title":"How to handle a Query","description":"Queries are handled by your Workflow.","label":"Handle Query","tags":["guide-context"],"markdown_content":"\nQueries are handled by your Workflow.\n\nDon’t include any logic that causes [Command](/concepts/what-is-a-command) generation within a Query handler (such as executing Activities).\nIncluding such logic causes unexpected behavior.\n","is_empty":false},{"file_name":"handle-signal.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/handle-signal.md","id":"app-dev-context/handle-signal","title":"How to handle a Signal","description":"Workflows listen for Signals by the Signal's name.","label":"Handle Signal","tags":["guide-context"],"markdown_content":"\nWorkflows listen for Signals by the Signal's name.\n","is_empty":false},{"file_name":"heartbeat-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/heartbeat-timeout.md","id":"app-dev-context/heartbeat-timeout","title":"How to set a Heartbeat Timeout","description":"A Heartbeat Timeout works in conjunction with Activity Heartbeats.","label":"Heartbeat Timeout","tags":["guide-context"],"markdown_content":"\nA [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) works in conjunction with [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n","is_empty":false},{"file_name":"list-filter.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/list-filter.md","id":"app-dev-context/list-filter","title":"How to use List Filters in Advanced Visibility APIs","description":"A List Filter is the SQL-like string that is provided as the parameter to an Advanced Visibility List API.","label":"List Filter","tags":["guide-context"],"markdown_content":"\nA List Filter is the SQL-like string that is provided as the parameter to an [Advanced Visibility](/concepts/what-is-advanced-visibility) List API.\n\nA List Filter contains [Search Attribute](/concepts/what-is-a-search-attribute) names, Search Attribute values, and Operators.\n\n- The following operators are supported in List Filters:\n\n  - **AND, OR, ()**\n  - **=, !=, >, >=, <, <=**\n  - **IN**\n  - **BETWEEN ... AND**\n  - **ORDER BY**\n\n- A List Filter applies to a single Namespace.\n\n- The range of a List Filter timestamp (`StartTime`, `CloseTime`, `ExecutionTime`) cannot exceed `9223372036854775807` (that is, `maxInt64: 1001`).\n\n- A List Filter that uses a time range has a resolution of 1 ms on Elasticsearch 6 and 1 ns on Elasticsearch 7.\n\n- List Filter Search Attribute names are case-sensitive.\n\n- An Advanced List Filter API may take longer than expected if it is retrieving more than 10 million Workflow Executions.\n\n- A `ListWorkflow` API supports pagination.\n  Use the page token in the following call to retrieve the next page; continue until the page token is `null` or `nil`.\n\n- To efficiently count the number of Workflow Executions, use the `CountWorkflow` API.\n","is_empty":false},{"file_name":"listen-to-heartbeats.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/listen-to-heartbeats.md","id":"app-dev-context/listen-to-heartbeats","title":"Listen to Heartbeats","description":"When an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.","label":"Listen to Heartbeats","tags":["guide-context"],"markdown_content":"\nWhen an Activity sends a Heartbeat, be sure that you can see the Heartbeats in your test code so that you can verify them.\n","is_empty":false},{"file_name":"logging.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/logging.md","id":"app-dev-context/logging","title":"How to log from a Workflow","description":"Send logs and errors to a logging service, so that when things go wrong, you can see what happened.","label":"Logging","tags":["guide-context"],"markdown_content":"\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nThe SDK core uses `WARN` for its default logging level.\n","is_empty":false},{"file_name":"metrics.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/metrics.md","id":"app-dev-context/metrics","title":"How to emit metrics","description":"Each Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.","label":"Metrics","tags":["guide-context"],"markdown_content":"\nEach Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.\nFor a complete list of metrics capable of being emitted, see the [SDK metrics reference](/references/sdk-metrics).\n\nMetrics can be scraped and stored in time series databases, such as:\n\n- [Prometheus](https://prometheus.io/docs/introduction/overview/)\n- [M3db](https://m3db.io/docs/)\n- [statsd](https://github.com/statsd/statsd)\n\nTemporal also provides a dashboard you can integrate with graphing services like [Grafana](https://grafana.com/docs/). For more information, see:\n\n- Temporal's implementation of the [Grafana dashboard](https://github.com/temporalio/dashboards)\n- [How to export metrics in Grafana](https://github.com/temporalio/helm-charts#exploring-metrics-via-grafana)\n","is_empty":false},{"file_name":"mock-activities.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/mock-activities.md","id":"app-dev-context/mock-activities","title":"How to mock Activities","description":"Mock an Activity by providing mock Activity implementations to the Worker.","label":"Mock Activities","tags":["guide-context"],"markdown_content":"\nMock the Activity invocation when unit testing your Workflows.\n\nWhen integration testing Workflows with a Worker, you can mock Activities by providing mock Activity implementations to the Worker.\n","is_empty":false},{"file_name":"mutable-side-effects.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/mutable-side-effects.md","id":"app-dev-context/mutable-side-effects","title":"Mutable Side Effects","description":"Mutable Side Effects are a method of execution to produce nondeterministic code.","label":"Mutable Side Effects","tags":["guide-context"],"markdown_content":"\nMutable Side Effects execute the provided function once, and then it looks up the History of the value with the given Workflow ID.\n\n- If there is no existing value, then it records the function result as a value with the given Workflow Id on the History.\n- If there is an existing value, then it compares whether the existing value from the History has changed from the new function results, by calling the equals function.\n  - If the values are equal, then it returns the value without recording a new Marker Event\n  - If the values aren't equal, then it records the new value with the same ID on the History.\n\n:::note\n\nDuring a Workflow Execution, every new Side Effect call results in a new Marker recorded on the Workflow History; whereas Mutable Side Effects only records a new Marker on the Workflow History if the value for the Side Effect ID changes or is set the first time.\n\nDuring a Replay, Mutable Side Effects will not execute the function again. Instead, it returns the exact same value that was returned during the Workflow Execution.\n\n:::\n","is_empty":false},{"file_name":"namespaces.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/namespaces.md","id":"app-dev-context/namespaces","title":"How to create Namespaces","description":"A Namespace is a unit of isolation within the Temporal Platform.","label":"Namespaces","tags":["guide-context"],"markdown_content":"\nA [Namespace](/concepts/what-is-a-namespace) is a unit of isolation within the Temporal Platform.\n\nYou can use Namespaces to match the development lifecycle; for example, having separate `dev` and `prod` Namespaces.\nOr you could use them to ensure Workflow Executions between different teams never communicate; such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud-context/namespaces-create) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to create and manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can register and manage your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nYou must register a Namespace with the Temporal Cluster before setting it in the Temporal Client.\n","is_empty":false},{"file_name":"observability.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/observability.md","id":"app-dev-context/observability","title":"How to use Temporal Observability features","description":"The observability section of the Temporal Developer's guide covers the many ways to view the current state of your Temporal Application—that is, ways to view which Workflow Executions are tracked by the Temporal Platform and the state of any specified Workflow Execution, either currently or at points of an execution","label":"Observability","tags":["guide-context"],"markdown_content":"\nThe observability section of the Temporal Developer's guide covers the many ways to view the current state of your [Temporal Application](/concepts/what-is-a-temporal-application)—that is, ways to view which [Workflow Executions](/concepts/what-is-a-workflow-execution) are tracked by the [Temporal Platform](/concepts/what-is-the-temporal-platform) and the state of any specified Workflow Execution, either currently or at points of an execution.\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Developer's guide, it could be in [older docs for SDKs](https://legacy-documentation-sdks.temporal.io/).\n\n:::\n\nThis section covers features related to viewing the state of the application, including:\n\n- [Metrics](#metrics)\n- [Tracing](#tracing)\n- [Logging](#logging)\n- [Visibility](#visibility)\n- [Replays](#replays)\n","is_empty":false},{"file_name":"parent-close-policy.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/parent-close-policy.md","id":"app-dev-context/parent-close-policy","title":"How to set a Parent Close Policy","description":"A Parent Close Policy determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).","label":"Parent Close Policy","tags":["guide-context"],"markdown_content":"\nA [Parent Close Policy](/concepts/what-is-a-parent-close-policy) determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/queries.md","id":"app-dev-context/queries","title":"How to develop with Queries","description":"A Query is a synchronous operation that is used to get the state of a Workflow Execution.","label":"Queries","tags":["guide-context"],"markdown_content":"\nA [Query](/concepts/what-is-a-query) is a synchronous operation that is used to get the state of a Workflow Execution.\n","is_empty":false},{"file_name":"registering-types.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/registering-types.md","id":"app-dev-context/registering-types","title":"How to register types","description":"How to register Workflow and Activity Types","label":"Register types","tags":["guide-context"],"markdown_content":"\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it fails that Task.\nHowever, the failure of the Task does not cause the associated Workflow Execution to fail.\n","is_empty":false},{"file_name":"remove-search-attributes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/remove-search-attributes.md","id":"app-dev-context/remove-search-attributes","title":"How to remove a Search Attribute from a Workflow","description":"To remove a Search Attribute that was previously set, set it to an empty array.","label":"Remove Search Attribute","tags":["guide-context"],"markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array: `[]`.\n","is_empty":false},{"file_name":"replays.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/replays.md","id":"app-dev-context/replays","title":"How to Replay a Workflow Execution","description":"Replay recreates the exact state of a Workflow Execution.","label":"Replay","tags":["guide-context"],"markdown_content":"\nReplay recreates the exact state of a Workflow Execution.\nYou can replay a Workflow from the beginning of its history when resumed.\n\nReplay allows code to resume only if it is compatible from a deterministic point of view.\n\nTo retrieve the Workflow History, use any of the following options and then pass the object to your SDK of choice.\n","is_empty":false},{"file_name":"required-activity-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/required-activity-timeout.md","id":"app-dev-context/required-activity-timeout","title":"How to set the required Activity Timeouts","description":"The only required value that needs to be set is either a Schedule-To-Close Timeout or a Start-To-Close Timeout","label":"Required timeout","tags":["guide-context"],"markdown_content":"\nActivity Execution semantics rely on several parameters.\nThe only required value that needs to be set is either a [Schedule-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) or a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout).\nThese values are set in the Activity Options.\n","is_empty":false},{"file_name":"run-an-activity.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/run-an-activity.md","id":"app-dev-context/run-an-activity","title":"Run an Activity","description":"If an Activity references its context, you need to mock that context when testing in isolation.","label":"Run an Activity","tags":["guide-context"],"markdown_content":"\nIf an Activity references its context, you need to mock that context when testing in isolation.\n","is_empty":false},{"file_name":"run-worker-processes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/run-worker-processes.md","id":"app-dev-context/run-worker-processes","title":"How to run Worker Processes","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run Worker Processes","tags":["guide-context"],"markdown_content":"\nThe [Worker Process](/concepts/what-is-a-worker-process) is where Workflow Functions and Activity Functions are executed.\n\n- Each [Worker Entity](/concepts/what-is-a-worker-entity) in the Worker Process must register the exact Workflow Types and Activity Types it may execute.\n- Each Worker Entity must also associate itself with exactly one [Task Queue](/concepts/what-is-a-task-queue).\n- Each Worker Entity polling the same Task Queue must be registered with the same Workflow Types and Activity Types.\n\nA [Worker Entity](/concepts/what-is-a-worker-entity) is the component within a Worker Process that listens to a specific Task Queue.\n\nAlthough multiple Worker Entities can be in a single Worker Process, a single Worker Entity Worker Process may be perfectly sufficient.\nFor more information, see the [Worker tuning guide](/application-development/worker-performance).\n\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it can make progress for either a Workflow Execution or an Activity Execution.\n","is_empty":false},{"file_name":"schedule-to-close.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/schedule-to-close.md","id":"app-dev-context/schedule-to-close","title":"How to set a Schedule-To-Close Timeout","description":"Use the Schedule-To-Close Timeout to limit the maximum duration of an Activity Execution.","label":"Schedule-To-Close Timeout","tags":["guide-context"],"markdown_content":"\nUse the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"schedule-to-start.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/schedule-to-start.md","id":"app-dev-context/schedule-to-start","title":"How to set a Schedule-To-Start Timeout","description":"Use the Schedule-To-Start Timeout to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","label":"Schedule-To-Start Timeout","tags":["guide-context"],"markdown_content":"\nUse the [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.\n","is_empty":false},{"file_name":"search-attributes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/search-attributes.md","id":"app-dev-context/search-attributes","title":"How to use Search Attributes","description":"Search Attributes enable complex List Filters to find the exact of Workflow Executions you are looking for.","label":"Search Attributes","tags":["guide-context"],"markdown_content":"\nThe typical method of retrieving a Workflow Execution is by its Workflow Id.\n\nHowever, sometimes you'll want to retrieve one or more Workflow Executions based on another property. For example, imagine you want to get all Workflow Executions of a certain type that have failed within a time range, so that you can start new ones with the same arguments.\n\nYou can do this with [Search Attributes](/concepts/what-is-a-search-attribute/).\n\n- [**Default** Search Attributes](/concepts/what-is-a-search-attribute/#default-search-attributes) like `WorkflowType`, `StartTime` and `ExecutionStatus` are automatically added to Workflow Executions.\n- _Custom Search Attributes_ can contain their own domain-specific data (like `customerId` or `numItems`).\n  - A few [generic Custom Search Attributes](/concepts/what-is-a-search-attribute/#custom-search-attributes) like `CustomKeywordField` and `CustomIntField` are created by default in Temporal's [Docker Compose](/clusters/quick-install/#docker-compose).\n\nThe steps to using custom Search Attributes are:\n\n- Create a new Search Attribute in your Cluster using `tctl search-attribute create` or the Cloud UI.\n- Set the value of the Search Attribute for a Workflow Execution:\n  - On the Client by including it as an option when starting the Execution.\n  - In the Workflow by calling `UpsertSearchAttributes`.\n- Read the value of the Search Attribute:\n  - On the Client by calling `DescribeWorkflow`.\n  - In the Workflow by looking at `WorkflowInfo`.\n- Query Workflow Executions by the Search Attribute using a [List Filter](/concepts/what-is-a-list-filter/):\n  - [In `tctl`](/tctl-v1/workflow/list).\n  - In code by calling `ListWorkflowExecutions`.\n\nHere is how to query Workflow Executions:\n","is_empty":false},{"file_name":"send-query.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/send-query.md","id":"app-dev-context/send-query","title":"How to send a Query","description":"Queries are sent from a Temporal Client.","label":"Send Query","tags":["guide-context"],"markdown_content":"\nQueries are sent from a Temporal Client.\n","is_empty":false},{"file_name":"send-signal-from-client.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/send-signal-from-client.md","id":"app-dev-context/send-signal-from-client","title":"How to send a Signal from a Temporal Client","description":"When a Signal is sent successfully from the Temporal Client, the WorkflowExecutionSignaled Event appears in the Event History of the Workflow that receives the Signal.","label":"Send Signal from Client","tags":["guide-context"],"markdown_content":"\nWhen a Signal is sent successfully from the Temporal Client, the [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Event History of the Workflow that receives the Signal.\n","is_empty":false},{"file_name":"send-signal-from-workflow.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/send-signal-from-workflow.md","id":"app-dev-context/send-signal-from-workflow","title":"How to send a Signal from a Workflow","description":"A Workflow can send a Signal to another Workflow, in which case it's called an External Signal","label":"Send Signal from Workflow","tags":["guide-context"],"markdown_content":"\nA Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.\n\nWhen an External Signal is sent:\n\n- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.\n- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.\n","is_empty":false},{"file_name":"set-custom-search-attributes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/set-custom-search-attributes.md","id":"app-dev-context/set-custom-search-attributes","title":"How to set custom Search Attributes","description":"After you've created custom Search Attributes in your Cluster (using `tctl` or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.","label":"Custom Search Attributes","tags":["guide-context"],"markdown_content":"\nAfter you've created custom Search Attributes in your Cluster (using `tctl search-attribute create`or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.\n","is_empty":false},{"file_name":"set-task-queue.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/set-task-queue.md","id":"app-dev-context/set-task-queue","title":"How to set a Workflow's Task Queue","description":"In most SDKs, the only Workflow Option that must be set is the name of the Task Queue.","label":"Set Task Queue","tags":["guide-context"],"markdown_content":"\nIn most SDKs, the only Workflow Option that must be set is the name of the [Task Queue](/concepts/what-is-a-task-queue).\n\nFor any code to execute, a Worker Process must be running that contains a Worker Entity that is polling the same Task Queue name.\n","is_empty":false},{"file_name":"set-workflow-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/set-workflow-id.md","id":"app-dev-context/set-workflow-id","title":"How to set a Workflow Id","description":"Although it is not required, we recommend providing your own Workflow Id that maps to a business process or business entity identifier, such as an order identifier or customer identifier.","label":"Workflow Id","tags":["guide-context"],"markdown_content":"\nAlthough it is not required, we recommend providing your own [Workflow Id](/concepts/what-is-a-workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.\n","is_empty":false},{"file_name":"side-effects.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/side-effects.md","id":"app-dev-context/side-effects","title":"Side Effects","description":"A Side Effect is used to produce nondeterministic code, such as generating a UUID or a random number.","label":"Side Effects","tags":["guide-context"],"markdown_content":"\nSide Effects are used to execute nondeterministic code, such as generating a UUID or a random number, without compromising deterministic in the Workflow. This is done by storing the nondeterministic results of the Side Effect into the Workflow [Event History](/workflows/#event-history).\n\nA Side Effect does not re-execute during a Replay. Instead, it returns the recorded result from the Workflow Execution Event History.\n\nSide Effects should not fail. An exception that is thrown from the Side Effect causes failure and retry of the current Workflow Task.\n\nAn Activity or a Local Activity may also be used instead of a Side effect, as its result is also persisted in Workflow Execution History.\n\n:::note\n\nYou shouldn’t modify the Workflow state inside a Side Effect function, because it is not reexecuted during Replay. Side Effect function should be used to return a value.\n\n:::\n","is_empty":false},{"file_name":"signal-with-start.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/signal-with-start.md","id":"app-dev-context/signal-with-start","title":"How to Signal-With-Start","description":"Signal-With-Start is used from the Client","label":"Signal-With-Start","tags":["guide-context"],"markdown_content":"\nSignal-With-Start is used from the Client.\nIt takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.\n\nIf there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/signals.md","id":"app-dev-context/signals","title":"How to develop with Signals","description":"A Signal is a message sent to a running Workflow Execution","label":"Signals","tags":["guide-context"],"markdown_content":"\nA [Signal](/concepts/what-is-a-signal) is a message sent to a running Workflow Execution.\n\nSignals are defined in your code and handled in your Workflow Definition.\nSignals can be sent to Workflow Executions from a Temporal Client or from another Workflow Execution.\n","is_empty":false},{"file_name":"skip-time-set-up.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/skip-time-set-up.md","id":"app-dev-context/skip-time-set-up","title":"Set up time skipping","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Setting up","tags":["guide-context"],"markdown_content":"\nLearn to set up the time-skipping test framework in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-activities.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/skip-time-skip-activities.md","id":"app-dev-context/skip-time-skip-activities","title":"Skip time in Activities","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time in Activities","tags":["guide-context"],"markdown_content":"\nLearn to skip time in Activities in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time-skip-automatically.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/skip-time-skip-automatically.md","id":"app-dev-context/skip-time-skip-automatically","title":"Skip time automatically","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Automatic method","tags":["guide-context"],"markdown_content":"\nYou can skip time automatically in the SDK of your choice.\nStart a test server process that skips time as needed.\nFor example, in the time-skipping mode, Timers, which include sleeps and conditional timeouts, are fast-forwarded except when Activities are running.\n","is_empty":false},{"file_name":"skip-time-skip-manually.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/skip-time-skip-manually.md","id":"app-dev-context/skip-time-skip-manually","title":"Skip time manually","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Manual method","tags":["guide-context"],"markdown_content":"\nLearn to skip time manually in the SDK of your choice.\n","is_empty":false},{"file_name":"skip-time.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/skip-time.md","id":"app-dev-context/skip-time","title":"How to skip time","description":"The test server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.","label":"Skip time","tags":["guide-context"],"markdown_content":"\nSome long-running Workflows can persist for months or even years.\nImplementing the test framework allows your Workflow code to skip time and complete your tests in seconds rather than the Workflow's specified amount.\n\nFor example, if you have a Workflow sleep for a day, or have an Activity failure with a long retry interval, you don't need to wait the entire length of the sleep period to test whether the sleep function works.\nInstead, test the logic that happens after the sleep by skipping forward in time and complete your tests in a timely manner.\n\n:::note\n\nSkipping time is not relevant to unit testing Workflow code, because in that case you’re mocking functions that take time, like sleep and Activity calls.\n\n:::\n\nThe test framework included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time.\nTime is a global property of an instance of `TestWorkflowEnvironment`: skipping time (either automatically or manually) applies to all currently running tests.\nIf you need different time behaviors for different tests, run your tests in a series or with separate instances of the test server.\nFor example, you could run all tests with automatic time skipping in parallel, and then all tests with manual time skipping in series, and then all tests without time skipping in parallel.\n","is_empty":false},{"file_name":"spawning-activities.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/spawning-activities.md","id":"app-dev-context/spawning-activities","title":"How to start an Activity Execution","description":"Calls to spawn Activity Executions are written within a Workflow Definition.","label":"Activity Execution","tags":["guide-context"],"markdown_content":"\nCalls to spawn [Activity Executions](/concepts/what-is-an-activity-execution) are written within a [Workflow Definition](/concepts/what-is-a-workflow-definition).\nThe call to spawn an Activity Execution generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nThis results in the set of three [Activity Task](/concepts/what-is-an-activity-task) related Events ([ActivityTaskScheduled](/references/events/#activitytaskscheduled), [ActivityTaskStarted](/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.\n\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the Execution history.\nThe entire Execution history is transferred from the Temporal service to Workflow Workers when a Workflow state needs to recover.\nA large Execution history can thus adversely impact the performance of your Workflow.\n\nTherefore, be mindful of the amount of data you transfer through Activity invocation parameters or Return Values.\nOtherwise, no additional limitations exist on Activity implementations.\n","is_empty":false},{"file_name":"spawning-workflows.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/spawning-workflows.md","id":"app-dev-context/spawning-workflows","title":"How to start a Workflow Execution","description":"Workflow Execution semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.","label":"Start Workflow Execution","tags":["guide-context"],"markdown_content":"\n[Workflow Execution](/concepts/what-is-a-workflow-execution) semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.\n\nIn the examples below, all Workflow Executions are started using a Temporal Client.\nTo spawn Workflow Executions from within another Workflow Execution, use either the [Child Workflow](#child-workflows) or External Workflow APIs.\n\nSee the [Customize Workflow Type](#customize-workflow-type) section to see how to customize the name of the Workflow Type.\n\nA request to spawn a Workflow Execution causes the Temporal Cluster to create the first Event ([WorkflowExecutionStarted](/references/events/#workflowexecutionstarted)) in the Workflow Execution Event History.\nThe Temporal Cluster then creates the first Workflow Task, resulting in the first [WorkflowTaskScheduled](/references/events/#workflowtaskscheduled) Event.\n","is_empty":false},{"file_name":"start-to-close.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/start-to-close.md","id":"app-dev-context/start-to-close","title":"How to set a Start-To-Close Timeout","description":"Use the Start-To-Close Timeout to limit the maximum duration of a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["guide-context"],"markdown_content":"\nUse the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) to limit the maximum duration of a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n","is_empty":false},{"file_name":"test-functions-assert-in-workflow.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/test-functions-assert-in-workflow.md","id":"app-dev-context/test-functions-assert-in-workflow","title":"Assert in Workflow","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Assert in Workflow","tags":["guide-context"],"markdown_content":"\nThe `assert` statement is a convenient way to insert debugging assertions into the Workflow context.\n\nThe `assert` method is available in Python and TypeScript.\n","is_empty":false},{"file_name":"test-functions-in-workflow-context.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/test-functions-in-workflow-context.md","id":"app-dev-context/test-functions-in-workflow-context","title":"Test functions in Workflow context","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Workflow context","tags":["guide-context"],"markdown_content":"\nFor a function or method to run in the Workflow context (where it’s possible to get the current Workflow info, or running inside the sandbox in the case of TypeScript or Python), it needs to be run by the Worker as if it were a Workflow.\n\n:::note\n\nThis section is applicable in Python and TypeScript.\nIn Python, we allow testing of Workflows only and not generic Workflow-related code.\n\n:::\n","is_empty":false},{"file_name":"testing-activities.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/testing-activities.md","id":"app-dev-context/testing-activities","title":"Testing Activities","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Activities","tags":["guide-context"],"markdown_content":"\nAn Activity can be tested with a mock Activity environment, which provides a way to mock the Activity context, listen to Heartbeats, and cancel the Activity.\nThis behavior allows you to test the Activity in isolation by calling it directly, without needing to create a Worker to run the Activity.\n","is_empty":false},{"file_name":"testing-frameworks.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/testing-frameworks.md","id":"app-dev-context/testing-frameworks","title":"Test frameworks","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test frameworks","tags":["guide-context"],"markdown_content":"\nSome SDKs have support or examples for popular test frameworks, runners, or libraries.\n","is_empty":false},{"file_name":"testing-workflows.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/testing-workflows.md","id":"app-dev-context/testing-workflows","title":"Testing Workflows","description":"Testing provides a framework to facilitate Workflow and integration testing.","label":"Test Workflows","tags":["guide-context"],"markdown_content":"","is_empty":false},{"file_name":"testing.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/testing.md","id":"app-dev-context/testing","title":"Testing","description":"The Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.","label":"Testing","tags":["guide-context"],"markdown_content":"\nThe Testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.\n\nIn the context of Temporal, you can create these types of automated tests:\n\n- **End-to-end**: Running a Temporal Server and Worker with all its Workflows and Activities; starting and interacting with Workflows from a Client.\n- **Integration**: Anything between end-to-end and unit testing.\n  - Running Activities with mocked Context and other SDK imports (and usually network requests).\n  - Running Workers with mock Activities, and using a Client to start Workflows.\n  - Running Workflows with mocked SDK imports.\n- **Unit**: Running a piece of Workflow or Activity code (a function or method) and mocking any code it calls.\n\nWe generally recommend writing the majority of your tests as integration tests.\n\nBecause the test server supports skipping time, use the test server for both end-to-end and integration tests with Workers.\n","is_empty":false},{"file_name":"timers.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/timers.md","id":"app-dev-context/timers","title":"What is a Timer?","description":"A Timer lets a Workflow sleep for a fixed time period.","label":"Timers","tags":["guide-context","timers","sleep"],"markdown_content":"\nA Workflow can set a durable timer for a fixed time period.\nIn some SDKs, the function is called `sleep()`, and in others, it's called `timer()`.\n\nA Workflow can sleep for months.\nTimers are persisted, so even if your Worker or Temporal Cluster is down when the time period completes, as soon as your Worker and Cluster are back up, the `sleep()` call will resolve and your code will continue executing.\n\nSleeping is a resource-light operation: it does not tie up the process, and you can run millions of Timers off a single Worker.\n","is_empty":false},{"file_name":"tracing.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/tracing.md","id":"app-dev-context/tracing","title":"How to setup Tracing","description":"Tracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.","label":"Tracing","tags":["guide-context"],"markdown_content":"\nTracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.\n\nTemporal Web's tracing capabilities mainly track Activity Execution within a Temporal context. If you need custom tracing specific for your use case, you should make use of context propagation to add tracing logic accordingly.\n\nFor information about Workflow tracing, see [Tracing Temporal Workflows with DataDog](https://spiralscout.com/blog/tracing-temporal-workflow-with-datadog).\n\nFor information about how to configure exporters and instrument your code, see [Tracing Temporal Services with OTEL](https://github.com/temporalio/temporal/blob/master/develop/docs/tracing.md).\n","is_empty":false},{"file_name":"upsert-custom-search-attributes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/upsert-custom-search-attributes.md","id":"app-dev-context/upsert-custom-search-attributes","title":"How to upsert Search Attributes","description":"You can upsert Search Attributes to add or update Search Attributes from within Workflow code.","label":"Upsert Search Attributes","tags":["guide-context"],"markdown_content":"\nYou can upsert Search Attributes to add or update Search Attributes from within Workflow code.\n","is_empty":false},{"file_name":"visibility.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/visibility.md","id":"app-dev-context/visibility","title":"How to use Visibility APIs","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["guide-context"],"markdown_content":"\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n","is_empty":false},{"file_name":"workflow-execution-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-execution-timeout.md","id":"app-dev-context/workflow-execution-timeout","title":"How to set a Workflow Execution Timeout","description":"Use the Workflow Execution Timeout to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["guide-context"],"markdown_content":"\nUse the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n","is_empty":false},{"file_name":"workflow-logic-requirements.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-logic-requirements.md","id":"app-dev-context/workflow-logic-requirements","title":"How develop Workflow logic","description":"Workflow logic is constrained by deterministic execution requirements.","label":"Workflow logic requirements","tags":["guide-context"],"markdown_content":"\nWorkflow logic is constrained by [deterministic execution requirements](/concepts/what-is-a-workflow-definition/#deterministic-constraints).\nTherefore, each language is limited to the use of certain idiomatic techniques.\nHowever, each Temporal SDK provides a set of APIs that can be used inside your Workflow to interact with external (to the Workflow) application code.\n","is_empty":false},{"file_name":"workflow-parameters.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-parameters.md","id":"app-dev-context/workflow-parameters","title":"How to define Workflow parameters","description":"Temporal Workflows may have any number of custom parameters.","label":"Workflow parameters","tags":["guide-context"],"markdown_content":"\nTemporal Workflows may have any number of custom parameters.\nHowever, we strongly recommended that objects are used as parameters, so that the object's individual fields may be altered without breaking the signature of the Workflow.\nAll Workflow Definition parameters must be serializable.\n","is_empty":false},{"file_name":"workflow-retries.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-retries.md","id":"app-dev-context/workflow-retries","title":"Workflow retries","description":"A Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.","label":"Workflow retries","tags":["guide-context"],"markdown_content":"\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-retry-policy.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-retry-policy.md","id":"app-dev-context/workflow-retry-policy","title":"How to set a Workflow Retry Policy","description":"Use a Retry Policy to retry a Workflow Execution in the event of a failure.","label":"Workflow Retry Policy","tags":["guide-context"],"markdown_content":"\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-return-values.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-return-values.md","id":"app-dev-context/workflow-return-values","title":"How to define Workflow return parameters","description":"Workflow return values must also be serializable.","label":"Workflow return values","tags":["guide-context"],"markdown_content":"\nWorkflow return values must also be serializable.\nReturning results, returning errors, or throwing exceptions is fairly idiomatic in each language that is supported.\nHowever, Temporal APIs that must be used to get the result of a Workflow Execution will only ever receive one of either the result or the error.\n","is_empty":false},{"file_name":"workflow-run-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-run-timeout.md","id":"app-dev-context/workflow-run-timeout","title":"How to set a Workflow Run Timeout","description":"Use the Workflow Run Timeout to restrict the maximum amount of time that a single Workflow Run can last.","label":"Workflow Run Timeout","tags":["guide-context"],"markdown_content":"\nUse the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) to restrict the maximum amount of time that a single [Workflow Run](/concepts/what-is-a-workflow-execution/#workflow-execution-chain) can last.\n","is_empty":false},{"file_name":"workflow-task-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-task-timeout.md","id":"app-dev-context/workflow-task-timeout","title":"How to set a Workflow Task Timeout","description":"Use the Workflow Task Timeout to restrict the maximum amount of time that a Worker can execute a Workflow Task.","label":"Workflow Task Timeout","tags":["guide-context"],"markdown_content":"\nUse the [Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout) to restrict the maximum amount of time that a Worker can execute a [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"workflow-timeouts-and-retries.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-timeouts-and-retries.md","id":"app-dev-context/workflow-timeouts-and-retries","title":"Workflow timeouts and retries","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts & retries","tags":["guide-context"],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"workflow-timeouts.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-timeouts.md","id":"app-dev-context/workflow-timeouts","title":"Workflow timeouts","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts","tags":["guide-context"],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\n\nWorkflow timeouts are set when [starting the Workflow Execution](/app-dev-context/workflow-timeouts).\n\n- **[Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout)** - restricts the maximum amount of time that a single Workflow Execution can be executed.\n- **[Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout)**: restricts the maximum amount of time that a single Workflow Run can last.\n- **[Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout)**: restricts the maximum amount of time that a Worker can execute a Workflow Task.\n","is_empty":false},{"file_name":"workflow-type.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/app-dev-context/workflow-type.md","id":"app-dev-context/workflow-type","title":"How to customize your Workflow Type","description":"You can set a custom name for your Workflow Type.","label":"Workflow Type","tags":["guide-context"],"markdown_content":"\nWorkflows have a Type that are referred to as the Workflow name.\n\nThe following examples demonstrate how to set a custom name for your Workflow Type.\n","is_empty":false},{"file_name":"archival.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cluster-ops-context/archival.md","id":"cluster-ops-context/archival","title":"How to use Archival","description":"Archival is a feature that automatically backs up Workflow Execution Event Histories and Visibility data from Temporal Cluster persistence to a custom blob store.","label":"Archival","tags":["guide-context"],"markdown_content":"\n[Archival](/concepts/what-is-archival) is a feature that automatically backs up Workflow Execution Event Histories and Visibility data from Temporal Cluster persistence to a custom blob store.\n","is_empty":false},{"file_name":"intro.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/cluster-ops-context/intro.md","id":"cluster-ops-context/intro","title":"How to deploy a Temporal Cluster","description":"This guide is a work in progress","label":"Deploy a Temporal Cluster","tags":["guide-context"],"markdown_content":"\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete.\nInformation may change at any time.\n\nLegacy production deployment information is available [here](/server/production-deployment)\n\n:::\n","is_empty":false},{"file_name":"how-to-create-a-custom-archiver.md","file_path":"/Users/ssantiago/Documents/documentation/docs/clusters/how-to-create-a-custom-archiver.md","id":"clusters/how-to-create-a-custom-archiver","title":"How to create a custom Archiver","description":"To archive data with a given provider, using the Archival feature, Temporal must have a corresponding Archiver component installed.","label":"Custom Archiver","tags":["how-to"],"markdown_content":"\nTo archive data with a given provider, using the [Archival](/concepts/what-is-archival) feature, Temporal must have a corresponding Archiver component installed.\nThe platform does not limit you to the existing providers.\nTo use a provider that is not currently supported, you can create your own Archiver.\n\n#### Create a new package\n\nThe first step is to create a new package for your implementation in [/common/archiver](https://github.com/temporalio/temporal/tree/master/common/archiver).\nCreate a directory in the archiver folder and arrange the structure to look like the following:\n\n```\ntemporal/common/archiver\n  - filestore/                      -- Filestore implementation\n  - provider/\n      - provider.go                 -- Provider of archiver instances\n  - yourImplementation/\n      - historyArchiver.go          -- HistoryArchiver implementation\n      - historyArchiver_test.go     -- Unit tests for HistoryArchiver\n      - visibilityArchiver.go       -- VisibilityArchiver implementations\n      - visibilityArchiver_test.go  -- Unit tests for VisibilityArchiver\n```\n\n#### Archiver interfaces\n\nNext, define objects that implement the [HistoryArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L80) and the [VisibilityArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L121) interfaces.\n\nThe objects should live in `historyArchiver.go` and `visibilityArchiver.go`, respectively.\n\n#### Update provider\n\nUpdate the `GetHistoryArchiver` and `GetVisibilityArchiver` methods of the `archiverProvider` object in the [/common/archiver/provider/provider.go](https://github.com/temporalio/temporal/blob/master/common/archiver/provider/provider.go) file so that it knows how to create an instance of your archiver.\n\n#### Add configs\n\nAdd configs for your archiver to the `config/development.yaml` file and then modify the [HistoryArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L376) and [VisibilityArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L393) structs in `/common/common/config.go` accordingly.\n\n#### Custom archiver FAQ\n\n**If my custom Archive method can automatically be retried by the caller, how can I record and access progress between retries?**\n\nHandle this situation by using `ArchiverOptions`.\nHere is an example:\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n    var progress progress\n    // Check if the feature for recording progress is enabled.\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.LoadProgress(ctx, & prevProgress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n\n    // Your archiver implementation...\n\n    // Record current progress\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.RecordProgress(ctx, progress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n}\n```\n\n**If my `Archive` method encounters an error that is non-retryable, how do I indicate to the caller that it should not retry?**\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n\n    err: = youArchiverImpl()\n\n    if nonRetryableErr(err) {\n        if featureCatalog.NonRetryableError != nil {\n            return featureCatalog.NonRetryableError() // when the caller gets this error type back it will not retry anymore.\n        }\n    }\n}\n```\n\n**How does my history archiver implementation read history?**\n\nThe archiver package provides a utility called [HistoryIterator](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) which is a wrapper of [ExecutionManager](https://github.com/temporalio/temporal/blob/master/common/persistence/dataInterfaces.go#L1014).\n`HistoryIterator` is more simple than the `HistoryManager`, which is available in the BootstrapContainer, so archiver implementations can choose to use it when reading Workflow histories.\nSee the [historyIterator.go](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) file for more details.\nUse the [filestore historyArchiver implementation](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) as an example.\n\n**Should my archiver define its own error types?**\n\nEach archiver is free to define and return its own errors.\nHowever, many common errors that exist between archivers are already defined in [common/archiver/constants.go](https://github.com/temporalio/temporal/blob/master/common/archiver/constants.go).\n\n**Is there a generic query syntax for the visibility archiver?**\n\nCurrently, no.\nBut this is something we plan to do in the future.\nAs for now, try to make your syntax similar to the one used by our advanced list Workflow API.\n\n- [s3store](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store#visibility-query-syntax)\n- [gcloud](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud#visibility-query-syntax)\n","is_empty":false},{"file_name":"how-to-integrate-elasticsearch-into-a-temporal-cluster.md","file_path":"/Users/ssantiago/Documents/documentation/docs/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster.md","id":"clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster","title":"How to integrate Elasticsearch into a Temporal Cluster","description":"To integrate Elasticsearch with your Temporal Cluster, edit the `persistence` section of your `development.yaml` configuration file and run the index schema setup commands.","label":"Elasticsearch","tags":["operation-guide","filtered-lists","visibility"],"markdown_content":"\n[Advanced Visibility](/concepts/what-is-advanced-visibility) features depend on an integration with Elasticsearch.\n\nTo integrate Elasticsearch with your Temporal Cluster, edit the `persistence` section of your `development.yaml` configuration file and run the index schema setup commands.\n\n:::note\n\nThese steps are needed only if you have a \"plain\" [Temporal Server Docker image](https://hub.docker.com/r/temporalio/server).\n\nIf you operate a Temporal Cluster using our [Helm charts](https://github.com/temporalio/helm-charts) or\n[Docker Compose](https://github.com/temporalio/docker-compose), the Elasticsearch index schema and index are created automatically using the [auto-setup Docker image](https://hub.docker.com/r/temporalio/auto-setup).\n\n:::\n\n:::note Supported versions\n\n- Elasticsearch v8 is supported from Temporal version 1.18.0 onwards\n- Elasticsearch v7.10 is supported from Temporal version 1.7.0 onwards\n- Elasticsearch v6.8 is supported up to Temporal version 1.17.x\n- Elasticsearch v6.8 and v7.10 versions are explicitly supported with AWS Elasticsearch\n\n:::\n\n#### Edit persistence\n\n1. Add the `advancedVisibilityStore: es-visibility` key-value pair to the `persistence` section.\n   The [development_es.yaml](https://github.com/temporalio/temporal/blob/master/config/development_es.yaml) file in the `temporalio/temporal` repo is a working example.\n   The configuration instructs the Temporal Cluster how and where to connect to Elasticsearch storage.\n\n```yaml\npersistence:\n  ...\n  advancedVisibilityStore: es-visibility\n```\n\n2. Define the Elasticsearch datastore connection information under the `es-visibility` key:\n\n```yaml\npersistence:\n  ...\n  advancedVisibilityStore: es-visibility\n  datastores:\n    ...\n    es-visibility:\n      elasticsearch:\n        version: \"v7\"\n        url:\n          scheme: \"http\"\n          host: \"127.0.0.1:9200\"\n        indices:\n          visibility: temporal_visibility_v1_dev\n```\n\n#### Create index schema and index\n\nRun the following commands to create the index schema and index:\n\n```bash\n# ES_SERVER is the URL of Elasticsearch server; for example, \"http://localhost:9200\".\nSETTINGS_URL=\"${ES_SERVER}/_cluster/settings\"\nSETTINGS_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/cluster_settings_${ES_VERSION}.json\nTEMPLATE_URL=\"${ES_SERVER}/_template/temporal_visibility_v1_template\"\nSCHEMA_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/index_template_${ES_VERSION}.json\nINDEX_URL=\"${ES_SERVER}/${ES_VIS_INDEX}\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SETTINGS_URL}\" -H \"Content-Type: application/json\" --data-binary \"@${SETTINGS_FILE}\" --write-out \"\\n\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${TEMPLATE_URL}\" -H 'Content-Type: application/json' --data-binary \"@${SCHEMA_FILE}\" --write-out \"\\n\"\ncurl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${INDEX_URL}\" --write-out \"\\n\"\n```\n\n#### Set Elasticsearch privileges\n\nEnsure that the following privileges are granted for the Elasticsearch Temporal index:\n\n- **Read**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `create`, `index`, `delete`, `read`\n- **Write**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `write`\n- **Custom Search Attributes**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `manage`\n  - [cluster privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-cluster): `monitor` or `manage`.\n\n#### Add custom Search Attributes (optional)\n\nThis step is optional.\n\nHere we are adding custom Search Attributes to your Cluster.\n\nRun the following command to create search attributes: `tctl search-attribute create`\n","is_empty":false},{"file_name":"how-to-set-up-archival.md","file_path":"/Users/ssantiago/Documents/documentation/docs/clusters/how-to-set-up-archival.md","id":"clusters/how-to-set-up-archival","title":"How to set up Archival","description":"This guide covers Temporal's archiving capabilities and how to set up the Archival feature.","label":"Set up Archival","tags":["how-to"],"markdown_content":"\n[Archival](/concepts/what-is-archival) consists of the following elements:\n\n- **Configuration**: Archival is controlled by the [server configuration](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L81) (i.e. the `config/development.yaml` file).\n- **Provider**: Location where the data should be archived. Supported providers are S3, GCloud, and the local file system.\n- **URI**: Specifies which provider should be used. The system uses the URI schema and path to make the determination.\n\nTake the following steps to set up Archival:\n\n1. [Set up the provider](#providers) of your choice.\n2. [Configure Archival](#configuration).\n3. [Create a Namespace](#namespace-creation) that uses a valid URI and has Archival enabled.\n\n#### Providers\n\nTemporal directly supports several providers:\n\n- **Local file system**: The [filestore archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) is used to archive data in the file system of whatever host the Temporal server is running on. This provider is used mainly for local installations and testing and should not be relied on for production environments.\n- **Google Cloud**: The [gcloud archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud) is used to connect and archive data with [Google Cloud](https://cloud.google.com/storage).\n- **S3**: The [s3store archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store) is used to connect and archive data with [S3](https://aws.amazon.com/s3).\n- **Custom**: If you want to use a provider that is not currently supported, you can [create your own archiver](/clusters/how-to-create-a-custom-archiver) to support it.\n\nMake sure that you save the provider's storage location URI in a place where you can reference it later, because it is passed as a parameter when you [create a Namespace](#namespace-creation).\n\n#### Configuration\n\nArchival configuration is defined in the [`config/development.yaml`](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L93) file.\nLet's look at an example configuration:\n\n```yaml\n# Cluster level Archival config\narchival:\n  # Event History configuration\n  history:\n    # Archival is enabled at the cluster level\n    state: \"enabled\"\n    enableRead: true\n    # Namespaces can use either the local filestore provider or the Google Cloud provider\n    provider:\n      filestore:\n        fileMode: \"0666\"\n        dirMode: \"0766\"\n      gstorage:\n        credentialsPath: \"/tmp/gcloud/keyfile.json\"\n\n# Default values for a Namespace if none are provided at creation\nnamespaceDefaults:\n  # Archival defaults\n  archival:\n    # Event History defaults\n    history:\n      state: \"enabled\"\n      # New Namespaces will default to the local provider\n      URI: \"file:///tmp/temporal_archival/development\"\n```\n\nYou can disable Archival by setting `archival.history.state` and `namespaceDefaults.archival.history.state` to `\"disabled\"`.\n\nExample:\n\n```yaml\narchival:\n  history:\n    state: \"disabled\"\n\nnamespaceDefaults:\n  archival:\n    history:\n      state: \"disabled\"\n```\n\nThe following table showcases acceptable values for each configuration and what purpose they serve.\n\n| Config                                         | Acceptable values                                                                  | Description                                                                                                                  |\n| ---------------------------------------------- | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\n| `archival.history.state`                       | `enabled`, `disabled`                                                              | Must be `enabled` to use the Archival feature with any Namespace in the cluster.                                             |\n| `archival.history.enableRead`                  | `true`, `false`                                                                    | Must be `true` to read from the archived Event History.                                                                      |\n| `archival.history.provider`                    | Sub provider configs are `filestore`, `gstorage`, `s3`, or `your_custom_provider`. | Default config specifies `filestore`.                                                                                        |\n| `archival.history.provider.filestore.fileMode` | File permission string                                                             | File permissions of the archived files. We recommend using the default value of `\"0666\"` to avoid read/write issues.         |\n| `archival.history.provider.filestore.dirMode`  | File permission string                                                             | Directory permissions of the archive directory. We recommend using the default value of `\"0766\"` to avoid read/write issues. |\n| `namespaceDefaults.archival.history.state`     | `enabled`, `disabled`                                                              | Default state of the Archival feature whenever a new Namespace is created without specifying the Archival state.             |\n| `namespaceDefaults.archival.history.URI`       | Valid URI                                                                          | Must be a URI of the file store location and match a schema that correlates to a provider.                                   |\n\n#### Namespace creation\n\nAlthough Archival is configured at the cluster level, it operates independently within each Namespace.\nIf an Archival URI is not specified when a Namespace is created, the Namespace uses the value of `defaultNamespace.archival.history.URI` from the `config/development.yaml` file.\nThe Archival URI cannot be changed after the Namespace is created.\nEach Namespace supports only a single Archival URI, but each Namespace can use a different URI.\nA Namespace can safely switch Archival between `enabled` and `disabled` states as long as Archival is enabled at the cluster level.\n\nArchival is supported in [Global Namespaces](/concepts/what-is-a-global-namespace/) (Namespaces that span multiple clusters).\nWhen Archival is running in a Global Namespace, it first runs on the active cluster; later it runs on the standby cluster. Before archiving, a history check is done to see what has been previously archived.\n\n#### Test setup\n\nTo test Archival locally, start by running a Temporal server:\n\n```bash\n./temporal-server start\n```\n\nThen register a new Namespace with Archival enabled.\n\n```bash\n./tctl --ns samples-namespace namespace register --gd false --history_archival_state enabled --retention 3\n```\n\n:::note\n\nIf the retention period isn't set, it defaults to two days.\nThe minimum retention period is one day.\nThe maximum retention period is 30 days.\n\nSetting the retention period to 0 results in the error _A valid retention period is not set on request_.\n\n:::\n\nNext, run a sample Workflow such as the [helloworld temporal sample](https://github.com/temporalio/temporal-go-samples/tree/master/helloworld).\n\nWhen execution is finished, Archival occurs.\n\n#### Retrieve archives\n\nYou can retrieve archived Event Histories by copying the `workflowId` and `runId` of the completed Workflow from the log output and running the following command:\n\n```bash\n./temporal --ns samples-namespace wf show --wid <workflowId> --rid <runId>\n```\n","is_empty":false},{"file_name":"how-to-set-up-multi-cluster-replication.md","file_path":"/Users/ssantiago/Documents/documentation/docs/clusters/how-to-set-up-multi-cluster-replication.md","id":"clusters/how-to-set-up-multi-cluster-replication","title":"How to set up Multi-Cluster Replication","description":"Multi-Cluster Replication can be enabled by setting the appropriate values in the `clusterMetadata` section of your configuration file.","label":"Set up Multi-Cluster Replication","tags":["how-to","cluster"],"markdown_content":"\nThe [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication) feature asynchronously replicates Workflow Execution Event Histories from active Clusters to other passive Clusters, and can be enabled by setting the appropriate values in the `clusterMetadata` section of your configuration file.\n\n1. `enableGlobalNamespace` must be set to `true`.\n2. `failoverVersionIncrement` has to be equal across connected Clusters.\n3. `initialFailoverVersion` in each Cluster has to assign a different value.\n   No equal value is allowed across connected Clusters.\n\nAfter the above conditions are satisfied, you can start to configure a multi-cluster setup.\n\n#### Set up Multi-Cluster Replication prior to v1.14\n\nYou can set this up with [`clusterMetadata` configuration](/references/configuration#clustermetadata); however, this is meant to be only a conceptual guide rather than a detailed tutorial.\nPlease reach out to us if you need to set this up.\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\n#### Set up Multi-Cluster Replication in v1.14 and later\n\nYou still need to set up local cluster [`clusterMetadata` configuration](/references/configuration#clustermetadata)\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterB\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\nThen you can use the `tctl admin` tool to add cluster connections. All operations should be executed in both Clusters.\n\n```shell\n# Add cluster B connection into cluster A\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\"\n# Add cluster A connection into cluster B\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\"\n\n# Disable connections\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\" --enable_connection false\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\" --enable_connection false\n\n# Delete connections\ntctl -address 127.0.0.1:7233 admin cluster remove-remote-cluster --cluster \"clusterB\"\ntctl -address 127.0.0.1:8233 admin cluster remove-remote-cluster --cluster \"clusterA\"\n```\n","is_empty":false},{"file_name":"how-to-upgrade-the-temporal-server-version.md","file_path":"/Users/ssantiago/Documents/documentation/docs/clusters/how-to-upgrade-the-temporal-server-version.md","id":"clusters/how-to-upgrade-the-temporal-server-version","title":"How to upgrade the Temporal Server version","description":"If a newer version of the Temporal Server is available, a notification appears in the Temporal Web UI.","label":"Upgrade Server","tags":["how-to"],"markdown_content":"\nIf a newer version of the [Temporal Server](/concepts/what-is-the-temporal-server) is available, a notification appears in the Temporal Web UI.\n\n:::info\n\nIf you are using a version that is older than 1.0.0, reach out to us at [community.temporal.io](http://community.temporal.io) to ask how to upgrade.\n\n:::\n\nFirst check to see if an upgrade to the database schema is required for the version you wish to upgrade to.\nIf a database schema upgrade is required, it will be called out directly in the [release notes](https://github.com/temporalio/temporal/releases).\nSome releases require changes to the schema, and some do not.\nWe ensure that any consecutive versions are compatible in terms of database schema upgrades, features, and system behavior; however there is no guarantee that there is compatibility between _any_ two non-consecutive versions.\n\nWhen upgrading your Temporal Server version, ensure that you upgrade sequentially.\nFor example, when upgrading from v1.n.x, always upgrade to v1.n+1.x (or the next available version) and so on until you get to the required version.\n\nThe Temporal Server upgrade updates or rewrites the old version data with the format introduced in the newer version.\nBecause Temporal Server guarantees backward compatibility between two consecutive minor versions, and because older versions of the code are eventually removed from the code base, skipping versions when upgrading might cause older formats to become unrecognizable.\nIf the old format of the data can't be read to be rewritten to the new format, the upgrades fail.\n\nCheck the [Temporal Server releases](https://github.com/temporalio/temporal/releases) and follow these releases in order.\nYou can skip patch versions; use the latest patch of a minor version when upgrading.\n\nAlso be aware that each upgrade requires the History Service to load all Shards and update the Shard metadata, so allow approximately 10 minutes on each version for these processes to complete before upgrading to the next version.\n\nUse one of the upgrade tools to upgrade your database schema to be compatible with the Temporal Server version being upgraded to.\n\nIf you are using a schema tools version prior to 1.8.0, we strongly recommend _never_ using the \"dryrun\" (`-y`, or `--dryrun`) options in any of your schema update commands.\nUsing this option might lead to potential loss of data, as when using it will create a new database and drop your\nexisting one.\nThis flag was removed in the 1.8.0 release.\n\n### Upgrade Cassandra schema\n\nIf you are using Cassandra for your Cluster's persistence, use the `temporal-cassandra-tool` to upgrade both the default and visibility schemas.\n\n**Example default schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/temporal/versioned\n\n```\n\n**Example visibility schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal_visibility \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/visibility/versioned\n\n```\n\n### Upgrade MySQL / PostgreSQL schema\n\nIf you are using MySQL or PostgreSQL use the `temporal-sql-tool`, which works similarly to the `temporal-cassandra-tool`.\n\nRefer to this [Makefile](https://github.com/temporalio/temporal/blob/v1.4.1/Makefile#L367-L383) for context.\n\n#### PostgreSQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal update-schema -d ./schema/postgresql/v96/temporal/versioned\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal_visibility update-schema -d ./schema/postgresql/v96/visibility/versioned\n```\n\n#### MySQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal update-schema -d ./schema/mysql/v57/temporal/versioned/\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal_visibility update-schema -d ./schema/mysql/v57/visibility/versioned/\n```\n\n### Roll-out technique\n\nWe recommend preparing a staging Cluster and then do the following to verify the upgrade is successful:\n\n1. Create some simulation load on the staging cluster.\n2. Upgrade the database schema in the staging cluster.\n3. Wait and observe for a few minutes to verify that there is no unstable behavior from both the server and the simulation load logic.\n4. Upgrade the server.\n5. Now do the same to the live environment cluster.\n","is_empty":false},{"file_name":"quick-install.md","file_path":"/Users/ssantiago/Documents/documentation/docs/clusters/quick-install.md","id":"clusters/quick-install","title":"How to quickly install a Temporal Cluster for testing and local development","description":"There are four ways to quickly install and run a Temporal Cluster.","label":"Run a development Cluster","markdown_content":"\nThe following sections list various methods of deploying your [Temporal Clusters](/concepts/what-is-a-temporal-cluster) locally, so that you can use and interact with the [Temporal Client](/concepts/what-is-a-temporal-client) APIs and [tctl](/tctl-v1) commands to test and develop applications.\n\nThe following sections list methods for deploying your Temporal development Clusters.\n\n- [Temporalite](#temporalite): This distribution of Temporal runs as a single process with zero runtime dependencies.\n- [Docker](#docker-compose): Using Docker Compose simplifies developing your Temporal Application.\n- [Gitpod](#gitpod): One-click deployments are available for Go and TypeScript.\n\n**For information on deploying a [production environment](/server/production-deployment), see the [Temporal Cloud](/cloud) documentation.**\n\n### Temporalite\n\nTemporalite is a distribution of Temporal that runs as a single process with zero runtime dependencies.\nIt supports persistence to disk and in-memory mode through SQLite.\n\n**Prerequisites**\n\nTemporalite requires Go 1.18 or later.\n\n**Build and start Temporalite**\n\nThe following steps start and run a Temporal Cluster.\n\n1. Build from source.\n   ```bash\n   git clone https://github.com/temporalio/temporalite.git\n   cd temporalite\n   go build ./cmd/temporalite\n   ```\n2. Start Temporalite by using the `start` command.\n   ```bash\n   temporalite start --namespace default\n   ```\n   Replace `default` with your [Namespace Name](/namespaces).\n\n**Results**: You should have Temporal Cluster running at `http://127.0.0.1:7233` and the Temporal Web UI at [`http://127.0.0.1:8233`](http://127.0.0.1:8233/).\n\n<!-- For macOS users, if you receive the `error setting up schema: stat /Users/<user_name>/Library/Application Support/temporalite/db:` error, then create the folders `temporalite/db` in your `Application Support` library. -->\n\n### Docker Compose\n\nUse Docker Compose and Temporal Cluster Docker images to quickly install and run a Temporal Cluster locally while developing Temporal Applications.\n\n**Prerequisites**\n\nInstall [Docker](https://docs.docker.com/engine/install) and [Docker Compose](https://docs.docker.com/compose/install).\n\n**Clone the repo and run Docker Compose**\n\nThe following steps start and run a Temporal Cluster using the default configuration.\n\n1. Clone the [temporalio/docker-compose](https://github.com/temporalio/docker-compose) repository.\n   ```bash\n   git clone https://github.com/temporalio/docker-compose.git\n   ```\n2. Change to the directory for the project.\n   ```bash\n   cd docker-compose\n   ```\n3. From your project directory, start your application.\n   ```bash\n   docker compose up\n   ```\n\n**Results**: You should have Temporal Cluster running at `http://127.0.0.1:7233` and the Temporal Web UI at [`http://127.0.0.1:8080`](http://127.0.0.1:8080/).\n\nTo try other configurations (different dependencies and databases), or to try a custom Docker image, follow the [temporalio/docker-compose README](https://github.com/temporalio/docker-compose/blob/main/README.md).\n\n### Gitpod\n\nRun a Temporal Cluster and develop Temporal Applications in your browser using [Gitpod](https://gitpod.io/#https://github.com/temporalio/samples-typescript/).\n\nOne-click deployments are available for the [temporalio/samples-go](https://github.com/temporalio/samples-go) repo and the [temporalio/samples-typescript](https://github.com/temporalio/samples-typescript) repo.\n\nA one-click deployment starts a Temporal Cluster using a Temporal Cluster Docker image, starts a Worker Process, and starts one of the application's sample Workflows.\n\nA one-click deployment can take up to a full minute to get fully up and running.\nWhen it is running, you can customize the application samples.\n","is_empty":false},{"file_name":"intro.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/concept-context/intro.md","id":"concept-context/intro","title":"Temporal core concepts","description":"Temporal core concepts explained","label":"Temporal core concepts","tags":["guide-context"],"markdown_content":"\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete.\nInformation may change at any time.\n\n:::\n","is_empty":false},{"file_name":"landing.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/landing.md","id":"concepts/landing","title":"Legacy concept docs","description":"Legacy category for concepts","label":"Concepts","tags":["introduction"],"markdown_content":"\n:::info Legacy docs set\n\nThe information in this specific sidebar (left nav) is now largely reflected in the [concept guides](/concepts).\n\n:::\n\n:::info See the Glossary\n\nFor the complete list of defined terms, see the [Glossary](/glossary).\n\n:::\n","is_empty":false},{"file_name":"what-is-a-child-workflow-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-child-workflow-execution.md","id":"concepts/what-is-a-child-workflow-execution","title":"What is a Child Workflow Execution?","description":"A Child Workflow Execution is a Workflow Execution that is spawned from within another Workflow.","label":"Child Workflow","tags":["term","explanation","child-workflow"],"markdown_content":"\nA Child Workflow Execution is a [Workflow Execution](/concepts/what-is-a-workflow-execution) that is spawned from within another Workflow.\n\n- [How to start a Child Workflow Execution](/application-development/features#child-workflows)\n\nA Workflow Execution can be both a Parent and a Child Workflow Execution because any Workflow can spawn another Workflow.\n\n![Parent and Child Workflow Execution entity relationship](/diagrams/parent-child-workflow-execution-relationship.svg)\n\nA Parent Workflow Execution must await on the Child Workflow Execution to spawn.\nThe Parent can optionally await on the result of the Child Workflow Execution.\nConsider the Child's [Parent Close Policy](/concepts/what-is-a-parent-close-policy) if the Parent does not await on the result of the Child, which includes any use of Continue-As-New by the Parent.\n\nWhen a Parent Workflow Execution reaches a Closed status, the Cluster propagates Cancellation Requests or Terminations to Child Workflow Executions depending on the Child's Parent Close Policy.\n\nIf a Child Workflow Execution uses Continue-As-New, from the Parent Workflow Execution's perspective the entire chain of Runs is treated as a single execution.\n\n![Parent and Child Workflow Execution entity relationship with Continue As New](/diagrams/parent-child-workflow-execution-with-continue-as-new.svg)\n\n### When to use Child Workflows\n\n**Consider Workflow Execution Event History size limits.**\n\nAn individual Workflow Execution has an [Event History](/concepts/what-is-an-event-history) size limit, which imposes a couple of considerations for using Child Workflows.\n\nOn one hand, because Child Workflow Executions have their own Event Histories, they are often used to partition large workloads into smaller chunks.\nFor example, a single Workflow Execution does not have enough space in its Event History to spawn 100,000 [Activity Executions](/concepts/what-is-an-activity-execution).\nBut a Parent Workflow Execution can spawn 1,000 Child Workflow Executions that each spawn 1,000 Activity Executions to achieve a total of 1,000,000 Activity Executions.\n\nHowever, because a Parent Workflow Execution Event History contains [Events](/concepts/what-is-an-event) that correspond to the status of the Child Workflow Execution, a single Parent should not spawn more than 1,000 Child Workflow Executions.\n\nIn general, however, Child Workflow Executions result in more overall Events recorded in Event Histories than Activities.\nBecause each entry in an Event History is a _cost_ in terms of compute resources, this could become a factor in very large workloads.\nTherefore, we recommend starting with a single Workflow implementation that uses Activities until there is a clear need for Child Workflows.\n\n**Consider each Child Workflow Execution as a separate service.**\n\nBecause a Child Workflow Execution can be processed by a completely separate set of [Workers](/concepts/what-is-a-worker) than the Parent Workflow Execution, it can act as an entirely separate service.\nHowever, this also means that a Parent Workflow Execution and a Child Workflow Execution do not share any local state.\nAs all Workflow Executions, they can communicate only via asynchronous [Signals](/concepts/what-is-a-signal).\n\n**Consider that a single Child Workflow Execution can represent a single resource.**\n\nAs all Workflow Executions, a Child Workflow Execution can create a one to one mapping with a resource.\nFor example, a Workflow that manages host upgrades could spawn a Child Workflow Execution per host.\n","is_empty":false},{"file_name":"what-is-a-claimmapper-plugin.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-claimmapper-plugin.md","id":"concepts/what-is-a-claimmapper-plugin","title":"What is a ClaimMapper Plugin?","description":"The Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).","label":"Claim Mapper","tags":["term"],"markdown_content":"\nThe Claim Mapper component is a pluggable component that extracts Claims from JSON Web Tokens (JWTs).\n\nThis process is achieved with the method `GetClaims`, which translates `AuthInfo` structs from the caller into `Claims` about the caller's roles within Temporal.\n\nA `Role` (within Temporal) is a bit mask that combines one or more of the role constants.\nIn the following example, the role is assigned constants that allow the caller to read and write information.\n\n```go\nrole := authorization.RoleReader | authorization.RoleWriter\n```\n\n`GetClaims` is customizable and can be modified with the `temporal.WithClaimMapper` server option.\nTemporal also offers a default JWT `ClaimMapper` for your use.\n\nA typical approach is for `ClaimMapper` to interpret custom `Claims` from a caller's JWT, such as membership in groups, and map them to Temporal roles for the user.\nThe subject information from the caller's mTLS certificate can also be a parameter in determining roles.\n\n#### `AuthInfo`\n\n`AuthInfo` is a struct that is passed to `GetClaims`. `AuthInfo` contains an authorization token extracted from the `authorization` header of the gRPC request.\n\n`AuthInfo` includes a pointer to the `pkix.Name` struct.\nThis struct contains an [x.509](https://www.ibm.com/docs/en/ibm-mq/7.5?topic=certificates-distinguished-names) Distinguished Name from the caller's mTLS certificate.\n\n#### `Claims`\n\n`Claims` is a struct that contains information about permission claims granted to the caller.\n\n`Authorizer` assumes that the caller has been properly authenticated, and trusts the `Claims` when making an authorization decision.\n\n#### Default JWT ClaimMapper\n\nTemporal offers a default JWT `ClaimMapper` that extracts the information needed to form Temporal `Claims`.\nThis plugin requires a public key to validate digital signatures.\n\nTo get an instance of the default JWT `ClaimMapper`, call `NewDefaultJWTClaimMapper` and provide it with the following:\n\n- a `TokenKeyProvider` instance\n- a `config.Authorization` pointer\n- a logger\n\nThe code for the default `ClaimMapper` can also be used to build a custom `ClaimMapper`.\n\n#### Token key provider\n\nA `TokenKeyProvider` obtains public keys from specified issuers' URIs that adhere to a specific format.\nThe default JWT `ClaimMapper` uses this component to obtain and refresh public keys over time.\n\nTemporal provides an `rsaTokenKeyProvider`.\nThis component dynamically obtains public keys that follow the [JWKS format](https://tools.ietf.org/html/rfc7517).\n`rsaTokenKeyProvider` uses only the `RSAKey` and `Close` methods.\n\n```go\nprovider := authorization.NewRSAKeyProvider(cfg)\n```\n\n:::note\n\n`KeySourceURIs` are the HTTP endpoints that return public keys of token issuers in the [JWKS format](https://tools.ietf.org/html/rfc7517).\n`RefreshInterval` defines how frequently keys should be refreshed.\nFor example, [Auth0](https://auth0.com/) exposes endpoints such as `https://YOUR_DOMAIN/.well-known/jwks.json`.\n\n:::\n\nBy default, \"permissions\" is used to name the `permissionsClaimName` value.\n\nConfigure the plugin with `config.Config.Global.Authorization.JWTKeyProvider`.\n\n#### JSON Web Token format\n\nThe default JWT `ClaimMapper` expects authorization tokens to be formatted as follows:\n\n```\nBearer <token>\n```\n\nThe Permissions Claim in the JWT Token is expected to be a collection of Individual Permission Claims.\nEach Individual Permission Claim must be formatted as follows:\n\n```\n<namespace> : <permission>\n```\n\nThese permissions are then converted into Temporal roles for the caller.\nThis can be one of Temporal's four values:\n\n- read\n- write\n- worker\n- admin\n\nMultiple permissions for the same Namespace are overridden by the `ClaimMapper`.\n\n##### Example of a payload for the default JWT ClaimMapper\n\n```\n{\n   \"permissions\":[\n      \"system:read\",\n      \"namespace1:write\"\n   ],\n   \"aud\":[\n      \"audience\"\n   ],\n   \"exp\":1630295722,\n   \"iss\":\"Issuer\"\n}\n```\n","is_empty":false},{"file_name":"what-is-a-cloud-account-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-cloud-account-id.md","id":"concepts/what-is-a-cloud-account-id","title":"What is a Temporal Cloud Account Id?","description":"A Temporal Cloud Account Id is a unique identifier for a customer.","label":"Temporal Cloud Account Id","tags":["term","explanation"],"markdown_content":"\nA Temporal Cloud Account Id is a unique identifier for a customer for the entire time they use Temporal Cloud.\nTemporal Technologies assigns each Account Id, which is an opaque code of five or six alphanumeric characters, such as `f45a2`.\n","is_empty":false},{"file_name":"what-is-a-cloud-namespace-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-cloud-namespace-id.md","id":"concepts/what-is-a-cloud-namespace-id","title":"What is a Cloud Namespace Id?","description":"A Cloud Namespace Id is a globally unique identifier for a Namespace in Temporal Cloud.","label":"Temporal Cloud Namespace Id","tags":["term","explanation"],"markdown_content":"\nA Cloud Namespace Id is a globally unique identifier for a [Namespace](/namespaces) in Temporal Cloud.\nA Namespace Id is formed by concatenating the following:\n\n1. A [Namespace Name](/concepts/what-is-a-cloud-namespace-name)\n1. A period (.)\n1. The [Account Id](/concepts/what-is-a-cloud-account-id) to which the Namespace belongs\n\nFor example, for the Account Id `f45a2` and Namespace Name `accounting-production`, the Namespace Id is `accounting-production.f45a2`.\n","is_empty":false},{"file_name":"what-is-a-cloud-namespace-name.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-cloud-namespace-name.md","id":"concepts/what-is-a-cloud-namespace-name","title":"What is a Cloud Namespace Name?","description":"A Cloud Namespace Name is a customer-supplied name for a Namespace in Temporal Cloud.","label":"Temporal Cloud Namespace Name","tags":["term","explanation"],"markdown_content":"\nA Cloud Namespace Name is a customer-supplied name for a [Namespace](/namespaces) in Temporal Cloud.\nEach Namespace Name, such as `accounting-production`, is unique within the scope of a customer's account.\nIt cannot be changed after the Namespace is provisioned.\n\nEach Namespace Name must conform to the following rules:\n\n- A Namespace Name must contain at least 2 characters and no more than 34 characters.\n- A Namespace Name must begin with a letter, end with a letter or number, and contain only letters, numbers, and the hyphen (-) character.\n- Each hyphen (-) character must be immediately preceded _and_ followed by a letter or number; consecutive hyphens are not permitted.\n- All letters in a Namespace Name must be lowercase.\n","is_empty":false},{"file_name":"what-is-a-command.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-command.md","id":"concepts/what-is-a-command","title":"What is a Command?","description":"A Command is a requested action issued by a Worker to the Temporal Cluster after a Workflow Task Execution completes.","label":"Command","tags":["term","explanation"],"markdown_content":"\nA Command is a requested action issued by a [Worker](/concepts/what-is-a-worker) to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) after a [Workflow Task Execution](/concepts/what-is-a-workflow-task-execution) completes.\n\nThe action that the Cluster takes is recorded in the [Workflow Execution's](/concepts/what-is-a-workflow-execution) [Event History](/concepts/what-is-an-event-history) as an [Event](/concepts/what-is-an-event).\nThe Workflow Execution can await on some of the Events that come as a result from some of the Commands.\n\nCommands are generated by the use of Workflow APIs in your code. During a Workflow Task Execution there may be several Commands that are generated.\nThe Commands are batched and sent to the Cluster as part of the Workflow Task Execution completion request, after the Workflow Task has progressed as far as it can with the Workflow function.\nThere will always be [WorkflowTaskStarted](/references/events/#workflowtaskstarted) and [WorkflowTaskCompleted](/references/events/#workflowtaskcompleted) Events in the Event History when there is a Workflow Task Execution completion request.\n\n![Commands are generated by the use of Workflow APIs in your code](/diagrams/commands.svg)\n\nCommands are described in the [Command reference](/references/commands) and are defined in the [Temporal gRPC API](https://github.com/temporalio/api/blob/master/temporal/api/command/v1/message.proto).\n","is_empty":false},{"file_name":"what-is-a-data-converter.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-data-converter.md","id":"concepts/what-is-a-data-converter","title":"What is a Data Converter?","description":"A Data Converter is a Temporal SDK component that encodes and decodes data entering and exiting a Temporal Server.","label":"Data Converter","tags":["term","explanation"],"markdown_content":"\nA Data Converter is a Temporal SDK component that encodes and decodes data entering and exiting a Temporal Server.\n\n- TypeScript: [Data Converters](/typescript/data-converters)\n- Go: [Create a custom Data Converter](/go/how-to-create-a-custom-data-converter-in-go)\n\n![Data Converter encodes and decodes data](/diagrams/default-data-converter.svg)\n\nData is encoded before it is sent to a Temporal Server, and it is decoded when it is received from a Temporal Server.\n\nThe main pieces of data that run through the Data Converter are arguments and return values:\n\n- The Client:\n  - Encodes Workflow, Signal, and Query arguments.\n  - Decodes Workflow and Query return values.\n- The Worker:\n  - Decodes Workflow, Signal, and Query arguments.\n  - Encodes Workflow and Query return values.\n  - Decodes and encodes Activity arguments and return values.\n\nEach piece of data (like a single argument or return value) is encoded as a [`Payload`](https://github.com/temporalio/api/blob/2f980f7ce4349e808b16ec0f21e0fe675f79330f/temporal/api/common/v1/message.proto#L49) Protobuf message, which consists of binary `data` and key-value `metadata`.\n\n## Default Data Converter\n\nEach Temporal SDK includes a default Data Converter.\nIn most SDKs, the default converter supports binary, JSON, and Protobufs.\n(In SDKs that cannot determine parameter types at runtime—like TypeScript—Protobufs aren't included in the default converter.)\nIt tries to encode values in the following order:\n\n- Null\n- Binary\n- Protobuf JSON\n- JSON\n\nFor example:\n\n- If a value is an instance of a Protobuf message, it will be encoded with [proto3 JSON](https://developers.google.com/protocol-buffers/docs/proto3#json).\n- If a value isn't null, binary, or a Protobuf, it will be encoded as JSON. If any part of it is not serializable as JSON (for example, a Date—see [JSON data types](https://en.wikipedia.org/wiki/JSON#Data_types)), an error will be thrown.\n\nThe default converter also supports decoding binary Protobufs.\n\n## Custom Data Converter\n\nApplications can create their own custom Data Converters to alter the format (for example using [MessagePack](https://msgpack.org/) instead of JSON) or add compression or encryption.\n\nTo use a custom Data Converter, provide it in the following contexts:\n\n- The Client and Worker in the SDKs you use.\n- Temporal Web via [`tctl data-converter web`](/tctl-v1/dataconverter#web) (for displaying decoded data in the Web UI).\n- `tctl` via [`--data-converter-plugin`](/tctl-next/modifiers#--data-converter-plugin) (for displaying decoded headers in `tctl` output).\n\nCustom Data Converters are not applied to all data:\n\n- `searchAttributes` are always encoded with JSON.\n- Headers are not encoded by the SDK (the one exception will be—when implemented—the SDK [running OTel baggage through custom Codecs](https://github.com/temporalio/sdk-typescript/issues/514)).\n\n### Payload Codecs\n\nIn [TypeScript](/typescript/data-converters#custom-data-converter), [Go](https://pkg.go.dev/go.temporal.io/sdk/converter#PayloadCodec), and [Python](https://python.temporal.io/temporalio.converter.DataConverter.html), data conversion happens in two stages:\n\n1. A Payload Converter converts a value into a [`Payload`](https://github.com/temporalio/api/blob/2f980f7ce4349e808b16ec0f21e0fe675f79330f/temporal/api/common/v1/message.proto#L49).\n2. A Payload Codec transforms an array of Payloads (for example, a list of Workflow arguments) into another array of Payloads.\n\nThe Payload Codec is an optional step that happens between the wire and the Payload Converter:\n\n```\nTemporal Server <--> Wire <--> Payload Codec <--> Payload Converter <--> User code\n```\n\nCommon Payload Codec transformations are compression and encryption.\n\nIn codec implementations, we recommended running the function (whether it be compressing, encrypting, etc) on the entire input Payload, and putting the result in a new Payload's `data` field. That way, the input Payload's headers are preserved. See, for example:\n\n- [`ZlibCodec`](https://github.com/temporalio/sdk-go/blob/706516c7077ba2e9b40304aeddbed47e25b2a68f/converter/codec.go#L77-L105) in the Go SDK\n- [Encryption Data Converter](https://github.com/temporalio/samples-go/blob/15be864c80d4d983ebb8a8fbd3fa5263bcef6930/encryption/data_converter.go#L100-L126) in Go's encryption sample\n\n### Encryption\n\nDoing encryption in a custom Data Converter ensures that all application data is encrypted during the following actions:\n\n- Being sent to/from Temporal Server.\n- Moving inside Temporal Server.\n- Stored by Temporal Server.\n\nThen data exists unencrypted in memory only on the Client and in the Worker Process that is executing Workflows and Activities on hosts that the application developer controls.\n\nOur encryption samples use AES GCM with 256-bit keys:\n\n- [TypeScript sample](https://github.com/temporalio/samples-typescript/tree/main/encryption)\n- [Go sample](https://github.com/temporalio/samples-go/tree/main/encryption)\n- [Python sample](https://github.com/temporalio/samples-python/tree/main/encryption)\n- [Java sample](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/encryptedpayloads)\n","is_empty":false},{"file_name":"what-is-a-frontend-service.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-frontend-service.md","id":"concepts/what-is-a-frontend-service","title":"What is a Frontend Service?","description":"The Frontend Service is a stateless gateway service that exposes a strongly typed Proto API. The Frontend Service is responsible for rate limiting, authorizing, validating, and routing all inbound calls.","label":"Frontend Service","tags":["term"],"markdown_content":"\nThe Frontend Service is a stateless gateway service that exposes a strongly typed [Proto API](https://github.com/temporalio/api/blob/master/temporal/api/workflowservice/v1/service.proto).\nThe Frontend Service is responsible for rate limiting, authorizing, validating, and routing all inbound calls.\n\n![Frontend Service](/diagrams/temporal-frontend-service.svg)\n\nTypes of inbound calls include the following:\n\n- [Namespace](/concepts/what-is-a-namespace) CRUD\n- External events\n- Worker polls\n- [Visibility](/concepts/what-is-visibility) requests\n- [tctl](/tctl-v1) (the Temporal CLI) operations\n- Calls from a remote Cluster related to [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication)\n\nEvery inbound request related to a Workflow Execution must have a Workflow Id, which is hashed for routing purposes.\nThe Frontend Service has access to the hash rings that maintain service membership information, including how many nodes (instances of each service) are in the Cluster.\n\nInbound call rate limiting is applied per host and per namespace.\n\nThe Frontend Service talks to the Matching Service, History Service, Worker Service, the database, and Elasticsearch (if in use).\n\n- It uses the grpcPort 7233 to host the service handler.\n- It uses port 6933 for membership-related communication.\n\nPorts are configurable in the Cluster configuration.\n","is_empty":false},{"file_name":"what-is-a-global-namespace.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-global-namespace.md","id":"concepts/what-is-a-global-namespace","title":"What is a Global Namespace?","description":"A Global Namespace is a Namespace that exists across Clusters when Multi-Cluster Replication is set up.","label":"Global Namespace","tags":["term","explanation"],"markdown_content":"\nA Global Namespace is a [Namespace](/concepts/what-is-a-namespace) that exists across Clusters when [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication) is set up.\n\n- [How to register a Global Namespace](/tctl-v1/namespace#register)\n- [How to change the active Cluster for a Global Namespace](/tctl-v1/namespace#update)\n\nThe Global Namespace feature enables Workflow Executions to progress through another Cluster in the event of a failover.\n\nA Global Namespace may be replicated to any number of Clusters, but is active in only one Cluster at any given time.\n\nFor a failover to be successful, Worker Processes must be polling for Tasks for the Global Namespace on all Clusters.\n\nA Global Namespace has a failover version.\nBecause a failover can be triggered from any Cluster, the failover version prevents certain conflicts from occurring if a failover is mistakenly triggered simultaneously on two Clusters.\n\nOnly the active Cluster dispatches [Tasks](/concepts/what-is-a-task); however, certain conflicts are possible.\nUnlike regular Namespaces, which provide at-most-once semantics for an Activity Execution, Global Namespaces can support only at-least-once semantics (see [Conflict resolution](/concepts/what-is-multi-cluster-replication/#conflict-resolution)).\nWorker Processes on the standby Clusters are idle until a failover occurs and their Cluster becomes active.\n\nTemporal Application API calls made to a non-active Cluster are rejected with a **NamespaceNotActiveError** which contains the name of the current active Cluster.\nIt is the responsibility of the Temporal Application to call the Cluster that is currently active.\n","is_empty":false},{"file_name":"what-is-a-heartbeat-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-heartbeat-timeout.md","id":"concepts/what-is-a-heartbeat-timeout","title":"What is a Heartbeat Timeout?","description":"A Heartbeat Timeout is the maximum time between Activity Heartbeats.","label":"Heartbeat Timeout","tags":["term","explanation","timeouts"],"markdown_content":"\nA Heartbeat Timeout is the maximum time between [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n\n- [How to set a Heartbeat Timeout](/application-development/features#heartbeat-timeout)\n\n![Heartbeat Timeout periods](/diagrams/heartbeat-timeout.svg)\n\nIf this timeout is reached, the Activity Task fails and a retry occurs if a [Retry Policy](/concepts/what-is-a-retry-policy) dictates it.\n","is_empty":false},{"file_name":"what-is-a-history-service.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-history-service.md","id":"concepts/what-is-a-history-service","title":"What is a History Service?","description":"The History Service is responsible for persisting Workflow Execution state and determining what to do next to progress the Workflow Execution through History Shards.","label":"History Service","tags":["term"],"markdown_content":"\nThe History Service is responsible for persisting Workflow Execution state and determining what to do next to progress the Workflow Execution by using [History Shards](/concepts/what-is-a-history-shard).\n\n![History Service](/diagrams/temporal-history-service.svg)\n\nThe total number of History Services can be between 1 and the total number of History Shards.\nAn individual History Service can support a large number of History Shards.\nTemporal recommends starting at a ratio of 1 History Service for every 500 History Shards.\n\nAlthough the total number of History Shards remains static for the life of the Cluster, the number of History Services can change.\n\nThe History Service talks to the Matching Service and the database.\n\n- It uses grpcPort 7234 to host the service handler.\n- It uses port 6934 for membership-related communication.\n\nPorts are configurable in the Cluster configuration.\n","is_empty":false},{"file_name":"what-is-a-history-shard.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-history-shard.md","id":"concepts/what-is-a-history-shard","title":"What is a History Shard?","description":"A History Shard is an important unit within a Temporal Cluster by which the scale of concurrent Workflow Execution throughput can be measured.","label":"History Shard","tags":["term"],"markdown_content":"\nA History Shard is an important unit within a Temporal Cluster by which the scale of concurrent Workflow Execution throughput can be measured.\n\nEach History Shard maps to a single persistence partition.\nA History Shard assumes that only be one concurrent operation can be within a partition at a time.\nIn essence, the number of History Shards represents the number of concurrent database operations that can occur for a Cluster.\nThis means that the number of History Shards in a Temporal Cluster plays a significant role in the performance of your Temporal Application.\n\nBefore integrating a database, the total number of History Shards for the Temporal Cluster must be chosen and set in the Cluster's configuration (see [persistence](/references/configuration#persistence)).\nAfter the Shard count is configured and the database integrated, the total number of History Shards for the Cluster cannot be changed.\n\nIn theory, a Temporal Cluster can operate with an unlimited number of History Shards, but each History Shard adds compute overhead to the Cluster.\nTemporal Clusters have operated successfully using anywhere from 1 to 128K History Shards, with each Shard responsible for tens of thousands of Workflow Executions.\nOne Shard is useful only in small scale setups designed for testing, while 128k Shards is useful only in very large scale production environments.\nThe correct number of History Shards for any given Cluster depends entirely on the Temporal Application that it is supporting and the type of database.\n\nA History Shard is represented as a hashed integer.\nEach Workflow Execution is automatically assigned to a History Shard.\nThe assignment algorithm hashes Workflow Execution metadata such as Workflow Id and Namespace and uses that value to match a History Shard.\n\nEach History Shard maintains the Workflow Execution Event History, Workflow Execution mutable state, and the following internal Task Queues:\n\n- Internal Transfer Task Queue: Transfers internal tasks to the Matching Service.\n  Whenever a new Workflow Task needs to be scheduled, the History Service's Transfer Task Queue Processor transactionally dispatches it to the Matching Service.\n- Internal Timer Task Queue: Durably persists Timers.\n- Internal Replicator Task Queue: Asynchronously replicates Workflow Executions from active Clusters to other passive Clusters.\n  (Relies on the experimental Multi-Cluster feature.)\n- Internal Visibility Task Queue: Pushes data to the [Advanced Visibility](/concepts/what-is-advanced-visibility) index.\n","is_empty":false},{"file_name":"what-is-a-list-filter.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-list-filter.md","id":"concepts/what-is-a-list-filter","title":"What is a List Filter?","description":"A List Filter is the SQL-like string that is provided as the parameter to an Advanced Visibility List API.","label":"List Filter","tags":["term","explanation","filtered-lists","visibility"],"markdown_content":"\nA List Filter is the SQL-like string that is provided as the parameter to an [Advanced Visibility](/concepts/what-is-advanced-visibility) List API.\n\n- [How to use a List Filter using tctl](/tctl-v1/workflow#list)\n\nThe following is an example List Filter:\n\n```\nWorkflowType = \"main.YourWorkflowDefinition\" and ExecutionStatus != \"Running\" and (StartTime > \"2021-06-07T16:46:34.236-08:00\" or CloseTime > \"2021-06-07T16:46:34-08:00\") order by StartTime desc\n```\n\n[More example List Filters](#example-list-filters)\n\nA List Filter contains [Search Attribute](/concepts/what-is-a-search-attribute) names, Search Attribute values, and Operators.\n\n- The following operators are supported in List Filters:\n\n  - **=, !=, >, >=, <, <=**\n  - **AND, OR, ()**\n  - **BETWEEN ... AND**\n  - **IN**\n  - **ORDER BY**\n\n- A List Filter applies to a single Namespace.\n\n- The range of a List Filter timestamp (StartTime, CloseTime, ExecutionTime) cannot exceed 9223372036854775807 (that is, maxInt64 - 1001).\n\n- A List Filter that uses a time range has a resolution of 1 ms on Elasticsearch 6 and 1 ns on Elasticsearch 7.\n\n- List Filter Search Attribute names are case sensitive.\n\n- An Advanced List Filter API may take longer than expected if it is retrieving a large number of Workflow Executions (more than 10 million).\n\n- A `ListWorkflow` API supports pagination.\n  Use the page token in the following call to retrieve the next page; continue until the page token is `null`/`nil`.\n\n- To efficiently count the number of Workflow Executions, use the `CountWorkflow` API.\n\n#### Example List Filters\n\n```sql\nWorkflowId = '<workflow-id>'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or WorkflowId = '<another-workflow-id>'\n```\n\n```sql\nWorkflowId IN ('<workflow-id>', '<another-workflow-id>')\n```\n\n```sql\nWorkflowId = '<workflow-id>' order by StartTime desc\n```\n\n```sql\nWorkflowId = '<workflow-id>' and ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' and StartTime > '2021-08-22T15:04:05+00:00'\n```\n\n```sql\nExecutionTime between '2021-08-22T15:04:05+00:00' and '2021-08-28T15:04:05+00:00'\n```\n\n```sql\nExecutionTime < '2021-08-28T15:04:05+00:00' or ExecutionTime > '2021-08-22T15:04:05+00:00'\n```\n\n```sql\norder by ExecutionTime\n```\n\n```sql\norder by StartTime desc, CloseTime asc\n```\n\n```sql\norder by CustomIntField asc\n```\n","is_empty":false},{"file_name":"what-is-a-local-activity.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-local-activity.md","id":"concepts/what-is-a-local-activity","title":"What is a Local Activity?","description":"A Local Activity is an Activity Execution that executes in the same process as the Workflow Execution that spawns it.","label":"Local Activity","tags":["term","explanation"],"markdown_content":"\nA Local Activity is an [Activity Execution](/concepts/what-is-an-activity-execution) that executes in the same process as the [Workflow Execution](/concepts/what-is-a-workflow-execution) that spawns it.\n\nSome Activity Executions are very short-living and do not need the queuing semantic, flow control, rate limiting, and routing capabilities.\nFor this case, Temporal supports the Local Activity feature.\n\nThe main benefit of Local Activities is that they use less Temporal Cluster resources (for example, fewer History events) and have much lower latency overhead (because no need to roundtrip to the Cluster) compared to normal Activity Executions.\nHowever, Local Activities are subject to shorter durations and a lack of rate limiting.\n\nConsider using Local Activities for functions that are the following:\n\n- can be implemented in the same binary as the Workflow that calls them.\n- do not require global rate limiting.\n- do not require routing to a specific Worker or Worker pool.\n- no longer than a few seconds, inclusive of retries.\n\nIf it takes longer than 80% of the Workflow Task Timeout (which is 10 seconds by default), the Worker will ask the Cluster to create a new Workflow Task to extend the \"lease\" for processing the Local Activity.\nThe Worker will continue doing so until the Local Activity has completed.\nThis is called Workflow Task Heartbeating.\nThe drawbacks of long-running Local Activities are:\n\n- Each new Workflow Task results in 3 more Events in History.\n- The Workflow won't get notified of new events like Signals and completions until the next Workflow Task Heartbeat.\n- New Commands created by the Workflow concurrently with the Local Activity will not be sent to the Cluster until either the Local Activity completes or the next Workflow Task Heartbeat.\n\nUsing a Local Activity without understanding its limitations can cause various production issues.\n**We recommend using regular Activities unless your use case requires very high throughput and large Activity fan outs of very short-lived Activities.**\nMore guidance in choosing between [Local Activity vs Activity](https://community.temporal.io/t/local-activity-vs-activity/290/3) is available in our forums.\n","is_empty":false},{"file_name":"what-is-a-matching-service.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-matching-service.md","id":"concepts/what-is-a-matching-service","title":"What is a Matching Service?","description":"The Matching Service is responsible for hosting external Task Queues for Task dispatching.","label":"Matching Service","tags":["term"],"markdown_content":"\nThe Matching Service is responsible for hosting user-facing [Task Queues](/concepts/what-is-a-task-queue) for Task dispatching.\n\n![Matching Service](/diagrams/temporal-matching-service.svg)\n\nIt is responsible for matching Workers to Tasks and routing new Tasks to the appropriate queue.\nThis service can scale internally by having multiple instances.\n\nIt talks to the Frontend Service, History Service, and the database.\n\n- It uses grpcPort 7235 to host the service handler.\n- It uses port 6935 for membership related communication.\n\nPorts are configurable in the Cluster configuration.\n","is_empty":false},{"file_name":"what-is-a-memo.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-memo.md","id":"concepts/what-is-a-memo","title":"What is a Memo?","description":"A Memo is a non-indexed user-supplied set of Workflow Execution metadata that is displayed with Filtered List results.","label":"Memo","tags":["term","explanation"],"markdown_content":"\nA Memo is a non-indexed user-supplied set of Workflow Execution metadata that is displayed with Filtered List results.\n","is_empty":false},{"file_name":"what-is-a-namespace.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-namespace.md","id":"concepts/what-is-a-namespace","title":"What is a Namespace?","description":"A Namespace is a unit of isolation within the Temporal Platform","label":"Namespace","tags":["term","explanation"],"markdown_content":"\nA Namespace is a unit of isolation within the Temporal Platform.\n\nA single Namespace is still multi-tenant.\n\n### Usage\n\nNamespaces are created on the Temporal Cluster, and provide a range of controls to achieve isolation on Workflow Executions.\n\n- Namespaces are a mechanism for resource isolation. Heavy traffic from one Namespace will not impact other Namespaces running on the same Cluster.\n  For example, you can use Namespaces to match the development lifecycle by having separate `dev` and `prod` Namespaces.\n- If no other Namespace is specified, the Temporal Cluster uses the Namespace \"default\" for all Temporal SDKs and tctl.\n  See the [Registration](#registration) section for details.\n- Namespaces created on self-hosted Temporal Clusters are case-sensitive. For example, `foo` and `Foo` are two different Namespaces.\n  On Temporal Cloud, Namespaces are case-insensitive, and we recommend using lowercase for Namespace names to avoid potential issues.\n- **Membership**: [Task Queue](/concepts/what-is-a-task-queue) names and [Workflow Ids](/concepts/what-is-a-workflow-id) must all correspond to a specific Namespace.\n  For example, when a Workflow Execution is spawned, it does so within a specific Namespace.\n- **Uniqueness**: Temporal guarantees a unique Workflow Id within a Namespace.\n  Workflow Executions may have the same Workflow Id if they are in different Namespaces.\n- **Namespace Configuration**: Various configuration options like the [Retention Period](/concepts/what-is-a-retention-period) and the [Archival](/concepts/what-is-archival) destination are configured per Namespace through a special CRUD API or through [`tctl`](/tctl-v1/namespace).\n\n### Registration\n\nRegistering a Namespace creates the Namespace on the Temporal Cluster.\nWhen you register your Namespace, you must also set the [Retention Period](/concepts/what-is-a-retention-period) for the Namespace.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud/how-to-manage-namespaces-in-temporal-cloud) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to create and manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can register your Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\nAll SDKs require a Namespace on the Temporal Cluster (or Temporal Cloud) for their Client calls. If not set using Client options, the Workflow Client API looks for the `default` Namespace. If there is no default Namespace registered with your Temporal Cluster (or Temporal Cloud), all calls will throw errors.\nYou must register your Namespace with the Temporal Cluster (or Temporal Cloud) before setting it in your Client.\n\nOn self-hosted Temporal Clusters, you can register your Namespaces in the following ways:\n\n- In your Cluster setup, create your Namespaces, including the default, in your setup script.\n  For example:\n\n  - If deploying through Docker Compose or using the [auto-setup image](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) in a custom Docker Compose application, the Namespace \"default\" is created, through the auto-setup script.\n  - If deploying through the [Temporal Helm charts](https://github.com/temporalio/helm-charts), you can create the \"default\" Namespace by using tctl; for example, `tctl --namespace default namespace register`.\n\n- Use the `tctl namespace register` command with the `--retention` modfiier to register your Namespaces, one at a time, and set the Retention Period on each.\n\n  - [How to register a new Namespace using tctl](/tctl-v1/namespace#register)\n\n- In your Client program, register your Namespace using `RegisterNamespaceRequest` API available in all the SDKs.\n\n  - [How to register a new Namespace using SDK](/application-development/features#namespaces)\n\nNote that registering a Namespace takes up to 15 seconds to complete. Ensure that you are waiting for this process to complete before making calls to the Namespace.\n\n### Manage Namespaces\n\nUse a custom [Authorizer](/concepts/what-is-an-authorizer-plugin) on your Frontend Service in the Temporal Cluster to set restrictions on who can create, update, or deprecate Namespaces.\n\nOn Temporal Cloud, use the [Temporal Cloud UI](/cloud/how-to-manage-namespaces-in-temporal-cloud) or [tcld commands](https://docs.temporal.io/cloud/tcld/namespace/) to manage Namespaces.\n\nOn self-hosted Temporal Cluster, you can manage your registered Namespaces using tctl (recommended) or programmatically using APIs. Note that these APIs and tctl commands will not work with Temporal Cloud.\n\n- Update information and configuration for a registered Namespace on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace update`](/tctl-v1/namespace#update)\n  - Use the [`UpdateNamespace` API]9(/application-development/features#namespaces) to update configuration on a Namespace.\n\n- Get details for a registered Namespace on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace describe`](/tctl-v1/namespace#describe)\n  - Use the [`DescribeNamespace` API](/application-development/features#namespaces) to return information and configuration details for a registered Namespace.\n\n- Get details for all registered Namespaces on your Temporal Cluster:\n\n  - With tctl: [`tctl namespace list`](/tctl-v1/namespace#list)\n  - Use the [`ListNamespace` API](/application-development/features#namespaces) to return information and configuration details for all registered Namespaces on your Temporal Cluster.\n\n- Deprecate a Namespace: The [`DeprecateNamespace` API](/application-development/features#namespaces) updates the state of a registered Namespace to \"DEPRECATED\". Once a Namespace is deprecated, you cannot start new Workflow Executions on it. All existing and running Workflow Executions on a deprecated Namespace will continue to run.\n\n### Setting\n\nSet Namespaces in your SDK Client to isolate your Workflow Executions to the Namespace.\nIf you do not set a Namespace, all Workflow Executions started using the Client will be associated with the \"default\" Namespace. This means, you must have a default Namespace called \"default\" registered with your Temporal Cluster. See [Registration](#Registration) for details.\n\n- [How to set the Namespace for a Temporal Client](/application-development/foundations#set-namespace)\n- [How to list Namespaces in a Cluster using tctl](/tctl-v1/namespace#list)\n- [How to view (describe) Namespace metadata and details using tctl](/tctl-v1/namespace#describe)\n","is_empty":false},{"file_name":"what-is-a-parent-close-policy.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-parent-close-policy.md","id":"concepts/what-is-a-parent-close-policy","title":"What is a Parent Close Policy?","description":"If a Workflow Execution is a Child Workflow Execution, a Parent Close Policy determines what happens to the Workflow Execution if its Parent Workflow Execution changes to a Closed status (Completed, Failed, Timed out).","label":"Parent Close Policy","tags":["term","explanation","child-workflow-executions"],"markdown_content":"\nA Parent Close Policy determines what happens to a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) if its Parent changes to a Closed status (Completed, Failed, or Timed out).\n\n- [How to set a Parent Close Policy](/application-development/features#parent-close-policy)\n\nThere are three possible values:\n\n- **Abandon**: the Child Workflow Execution is not affected.\n- **Request Cancel**: a Cancellation request is sent to the Child Workflow Execution.\n- **Terminate** (default): the Child Workflow Execution is forcefully Terminated.\n\n[`ParentClosePolicy`](https://github.com/temporalio/api/blob/c1f04d0856a3ba2995e92717607f83536b5a44f5/temporal/api/enums/v1/workflow.proto#L44) proto definition.\n\nEach Child Workflow Execution may have its own Parent Close Policy.\nThis policy applies only to Child Workflow Executions and has no effect otherwise.\n\n![Parent Close Policy entity relationship](/diagrams/parent-close-policy.svg)\n\nYou can set policies per child, which means you can opt out of propagating terminates / cancels on a per-child basis.\nThis is useful for starting Child Workflows asynchronously (see [relevant issue here](https://community.temporal.io/t/best-way-to-create-an-async-child-workflow/114) or the corresponding SDK docs).\n","is_empty":false},{"file_name":"what-is-a-query.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-query.md","id":"concepts/what-is-a-query","title":"What is a Query?","description":"A Query is a synchronous operation that is used to report the state of a Workflow Execution.","label":"Query","tags":["term","queries","explanation"],"markdown_content":"\nA Query is a synchronous operation that is used to get the state of a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nThe state of a running Workflow Execution is constantly changing.\nYou can use Queries to expose the internal Workflow Execution state to the external world.\nQueries are available for running or completed Workflows Executions only if the Worker is up and listening on the Task Queue.\n\n- [How to send a Query using tctl](/tctl-v1/workflow#query)\n- [How to send and handle Queries with an SDK](/application-development/features#queries)\n\nQueries are sent from a Temporal Client to a Workflow Execution.\nThe API call is synchronous.\nThe Query is identified at both ends by a Query name.\nThe Workflow must have a Query handler that is developed to handle that Query and provide data that represents the state of the Workflow Execution.\n\nQueries are strongly consistent and are guaranteed to return the most recent state.\nThis means that the data reflects the state of all confirmed Events that came in before the Query was sent.\nAn Event is considered confirmed if the call creating the Event returned success.\nEvents that are created while the Query is outstanding may or may not be reflected in the Workflow state the Query result is based on.\n\nA Query can carry arguments to specify the data it is requesting.\nAnd each Workflow can expose data to multiple types of Queries.\n\nA Query must never mutate the state of the Workflow Execution—that is, Queries are _read-only_ and cannot contain any blocking code.\nThis means, for example, that Query handling logic cannot schedule Activity Executions.\n\nSending Queries to completed Workflow Executions is supported, though Query reject conditions can be configured per Query.\n\n#### Stack Trace Query\n\nIn many SDKs, the Temporal Client exposes a predefined `__stack_trace` Query that returns the stack trace of all the threads owned by that Workflow Execution.\nThis is a great way to troubleshoot a Workflow Execution in production.\nFor example, if a Workflow Execution has been stuck at a state for longer than an expected period of time, you can send a `__stack_trace` Query to return the current call stack.\nThe `__stack_trace` Query name does not require special handling in your Workflow code.\n\n:::note\n\nStack Trace Queries are available only for running Workflow Executions.\n\n:::\n","is_empty":false},{"file_name":"what-is-a-retention-period.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-retention-period.md","id":"concepts/what-is-a-retention-period","title":"What is a Retention Period?","description":"A Retention Period is the amount of time a Workflow Execution Event History remains in the Cluster's persistence store.","label":"Retention Period","tags":["term","explanation"],"markdown_content":"\nRetention Period is the duration for which the Temporal Cluster stores data associated with closed Workflow Executions on a Namespace in the Persistence store.\n\n- [How to set the Retention Period for a Namespace](/tctl-v1/namespace#register)\n- [How to set the Retention Period for a Namespace using an SDK](/application-development/features/#namespaces)\n\nA Retention Period applies to all closed Workflow Executions within a [Namespace](/concepts/what-is-a-namespace) and is set when the Namespace is registered.\n\nThe Temporal Cluster triggers a Timer task at the end of the Retention Period that cleans up the data associated with the closed Workflow Execution on that Namespace.\nmutable\nThe minimum Retention Period is 1 day.\nOn Temporal Cluster version 1.18 and later, the maximum Retention Period value for Namespaces can be set to anything over the minimum requirement of 1 day. Ensure that your Persistence store has enough capacity for the storage.\nOn Temporal Cluster versions 1.17 and earlier, the maximum Retention Period you can set is 30 days.\nSetting the Retention Period to 0 results in the error _A valid retention period is not set on request_.\n\nIf you don't set the Retention Period value when using the [`tctl namespace register`](/tctl-v1/namespace#register) command, it defaults to 3 days.\nIf you don't set the Retention Period value when using the [`RegisterNamespaceRequest`](/application-development/features/#namespaces) API, it returns an error.\n","is_empty":false},{"file_name":"what-is-a-retry-policy.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-retry-policy.md","id":"concepts/what-is-a-retry-policy","title":"What is a Retry Policy?","description":"A Retry Policy is a collection of attributes that instructs the Temporal Server how to retry a failure of a Workflow Execution or an Activity Task Execution.","label":"Retry Policy","tags":["term","explanation"],"markdown_content":"\nA Retry Policy is a collection of attributes that instructs the Temporal Server how to retry a failure of a [Workflow Execution](/concepts/what-is-a-workflow-execution) or an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n(Retry Policies do not apply to [Workflow Task Executions](/concepts/what-is-a-workflow-task-execution), which always retry indefinitely.)\n\n- [Activity retry simulator](/application-development/features#activity-retry-simulator)\n- [How to set a custom Retry Policy for an Activity](/application-development/features#activity-retry-policy)\n- [How to set a Retry Policy for a Workflow](/application-development/features#workflow-retry-policy)\n\n<!-- ![Diagram that shows the retry interval and its formula](/img/retry-interval-diagram.png) -->\n\n## Default behavior\n\n- **Workflow Execution**: When a Workflow Execution is spawned, it is not associated with a default Retry Policy and thus does not retry by default.\n  The intention is that a Workflow Definition should be written to never fail due to intermittent issues; an Activity is designed to handle such issues.\n\n- **Activity Execution**: When an Activity Execution is spawned, it is associated with a default Retry Policy, and thus Activity Task Executions are retried by default.\n  When an Activity Task Execution is retried, the Cluster places a new [Activity Task](/concepts/what-is-an-activity-task) into its respective [Activity Task Queue](/concepts/what-is-a-task-queue), which results in a new Activity Task Execution.\n\n## Custom Retry Policy\n\nTo use a custom Retry Policy, provide it as an options parameter when starting a Workflow Execution or Activity Execution.\nOnly certain scenarios merit starting a Workflow Execution with a custom Retry Policy, such as the following:\n\n- A [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) or some other stateless, always-running Workflow Execution that can benefit from retries.\n- A file-processing or media-encoding Workflow Execution that downloads files to a host.\n\n## Properties\n\n### Default values for Retry Policy\n\n```\nInitial Interval     = 1 second\nBackoff Coefficient  = 2.0\nMaximum Interval     = 100 × Initial Interval\nMaximum Attempts     = ∞\nNon-Retryable Errors = []\n```\n\n### Initial Interval\n\n- **Description**: Amount of time that must elapse before the first retry occurs.\n  - **The default value is 1 second.**\n- **Use case**: This is used as the base interval time for the [Backoff Coefficient](#backoff-coefficient) to multiply against.\n\n### Backoff Coefficient\n\n- **Description**: The value dictates how much the _retry interval_ increases.\n  - **The default value is 2.0.**\n  - A backoff coefficient of 1.0 means that the retry interval always equals the [Initial Interval](#initial-interval).\n- **Use case**: Use this attribute to increase the interval between retries.\n  By having a backoff coefficient greater than 1.0, the first few retries happen relatively quickly to overcome intermittent failures, but subsequent retries happen farther and farther apart to account for longer outages.\n  Use the [Maximum Interval](#maximum-interval) attribute to prevent the coefficient from increasing the retry interval too much.\n\n### Maximum Interval\n\n- **Description**: Specifies the maximum interval between retries.\n  - **The default value is 100 times the [Initial Interval](#initial-interval).**\n- **Use case**: This attribute is useful for [Backoff Coefficients](#backoff-coefficient) that are greater than 1.0 because it prevents the retry interval from growing infinitely.\n\n### Maximum Attempts\n\n- **Description**: Specifies the maximum number of execution attempts that can be made in the presence of failures.\n  - **The default is unlimited.**\n  - If this limit is exceeded, the execution fails without retrying again. When this happens an error is returned.\n  - Setting the value to 0 also means unlimited.\n  - Setting the value to 1 means a single execution attempt and no retries.\n  - Setting the value to a negative integer results in an error when the execution is invoked.\n- **Use case**: Use this attribute to ensure that retries do not continue indefinitely.\n  However, in the majority of cases, we recommend relying on the Workflow Execution Timeout, in the case of [Workflows](#workflow), or Schedule-To-Close Timeout, in the case of [Activities](#activity), to limit the total duration of retries instead of using this attribute.\n\n### Non-Retryable Errors\n\n- **Description**: Specifies errors that shouldn't be retried.\n  - **Default is none.**\n  - If one of those errors occurs, the [Activity Task Execution](#activity-task-execution) or [Workflow Execution](#workflow-execution) is not retried.\n- **Use case**: There may be errors that you know of that should not trigger a retry.\n  In this case you can specify them such that if they occur, the given execution will not be retried.\n\n## Retry interval\n\nThe wait time before a retry is the _retry interval_. A retry interval is the smaller of two values:\n\n- The [Initial Interval](#initial-interval) multiplied by the [Backoff Coefficient](#backoff-coefficient) raised to the power of the number of retries.\n- The [Maximum Interval](#maximum-interval).\n\n## Event History\n\nThere are some subtle nuances to how Events are recorded to an Event History when a Retry Policy comes into play.\n\n- For an Activity Execution, the [ActivityTaskStarted](/concepts/what-is-an-event#activitytaskstarted) Event will not show up in the Workflow Execution Event History until the Activity Execution has completed or failed (having exhausted all retries).\n  This is to avoid filling the Event History with noise.\n  Use the Describe API to get a pending Activity Execution's attempt count.\n\n- For a Workflow Execution with a Retry Policy, if the Workflow Execution fails, the Workflow Execution will [Continue-As-New](/concepts/what-is-continue-as-new) and the associated Event is written to the Event History.\n  The [WorkflowExecutionContinuedAsNew](/concepts/what-is-an-event#workflowexecutioncontinuedasnew) Event will have an \"initiator\" field that will specify the Retry Policy as the value and the new Run Id for the next retry attempt.\n  The new Workflow Execution is created immediately.\n  But the first Workflow Task won't be scheduled until the backoff duration is exhausted.\n  That duration is recorded as the `firstWorkflowTaskBackoff` field of the new run's `WorkflowExecutionStartedEventAttributes` event.\n","is_empty":false},{"file_name":"what-is-a-run-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-run-id.md","id":"concepts/what-is-a-run-id","title":"What is a Run Id?","description":"A Run Id is a globally unique, platform-level identifier for a Workflow Execution.","label":"Run Id","tags":["term","explanation"],"markdown_content":"\nA Run Id is a globally unique, platform-level identifier for a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nTemporal guarantees that only one Workflow Execution with a given [Workflow Id](/concepts/what-is-a-workflow-id) can be in an Open state at any given time.\nBut when a Workflow Execution reaches a Closed state, it is possible to have another Workflow Execution in an Open state with the same Workflow Id.\nFor example, a Temporal Cron Job is a chain of Workflow Executions that all have the same Workflow Id.\nEach Workflow Execution within the chain is considered a _Run_.\n\nA Run Id uniquely identifies a Workflow Execution even if it shares a Workflow Id with other Workflow Executions.\n\n:::caution\n\nDon't rely on storing the current Run Id or using it for any logical choices.\nA Workflow Retry changes the Run Id.\nBecause the current Run Id is mutable, relying on it might produce non-determinism issues.\n\n:::\n\n**Learn more**\n\nFor more information, see the following links.\n\n- [`message.proto`](https://github.com/temporalio/api/blob/master/temporal/api/history/v1/message.proto#L75-L82)\n- [Non-determinism issues for Run Ids](/kb/non-determinism-issues-for-run-ids)\n","is_empty":false},{"file_name":"what-is-a-schedule-to-close-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-schedule-to-close-timeout.md","id":"concepts/what-is-a-schedule-to-close-timeout","title":"What is a Schedule-To-Close Timeout?","description":"A Schedule-To-Close Timeout is the maximum amount of time allowed for the overall Activity Execution, from when the first Activity Task is scheduled to when the last Activity Task, in the chain of Activity Tasks that make up the Activity Execution, reaches a Closed status.","label":"Schedule-To-Close Timeout","tags":["term","explanation","timeouts"],"markdown_content":"\nA Schedule-To-Close Timeout is the maximum amount of time allowed for the overall [Activity Execution](/concepts/what-is-an-activity-execution), from when the first [Activity Task](/concepts/what-is-an-activity-task) is scheduled to when the last Activity Task, in the chain of Activity Tasks that make up the Activity Execution, reaches a Closed status.\n\n- [How to set a Schedule-To-Close Timeout](/go/how-to-set-a-schedule-to-close-timeout-in-go)\n\n![Schedule-To-Close Timeout period](/diagrams/schedule-to-close-timeout.svg)\n\nExample Schedule-To-Close Timeout period for an Activity Execution that has a chain Activity Task Executions:\n\n![Schedule-To-Close Timeout period with a retry](/diagrams/schedule-to-close-timeout-with-retry.svg)\n\n**The default Schedule-To-Close Timeout is ∞ (infinity).**\n\nAn Activity Execution must have either this timeout (Schedule-To-Close) or [Start-To-Close](/concepts/what-is-a-start-to-close-timeout) set.\nBy default, an Activity Execution Retry Policy dictates that retries will occur for up to 10 years.\nThis timeout can be used to control the overall duration of an Activity Execution in the face of failures (repeated Activity Task Executions), without altering the Maximum Attempts field of the Retry Policy.\n","is_empty":false},{"file_name":"what-is-a-schedule-to-start-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-schedule-to-start-timeout.md","id":"concepts/what-is-a-schedule-to-start-timeout","title":"What is a Schedule-To-Start Timeout?","description":"A Schedule-To-Start Timeout is the maximum amount of time that is allowed from when an Activity Task is placed in a Task Queue to when a Worker picks it up from the Task Queue.","label":"Schedule-To-Start Timeout","tags":["term","explanation","timeouts"],"markdown_content":"\nA Schedule-To-Start Timeout is the maximum amount of time that is allowed from when an [Activity Task](/concepts/what-is-an-activity-task) is scheduled (that is, placed in a Task Queue) to when a [Worker](/concepts/what-is-a-worker) starts (that is, picks up from the Task Queue) that Activity Task.\nIn other words, it's a limit for how long an Activity Task can be enqueued.\n\n[How to set a Schedule-To-Start Timeout](/go/how-to-set-a-schedule-to-start-timeout-in-go)\n\nThe moment that the Task is picked by the Worker from the Task Queue is considered to be the start of the Activity Task for the purposes of the Schedule-To-Start Timeout and associated metrics.\nThis definition of \"Start\" avoids issues that a clock difference between the Temporal Cluster and a Worker might create.\n\n![Schedule-To-Start Timeout period](/diagrams/schedule-to-start-timeout.svg)\n\n\"Schedule\" in Schedule-To-Start and Schedule-To-Close have different frequency guarantees.\n\nThe Schedule-To-Start Timeout is enforced for each Activity Task, whereas the Schedule-To-Close Timeout is enforced once per Activity Execution.\nThus, \"Schedule\" in Schedule-To-Start refers to the scheduling moment of _every_ Activity Task in the sequence of Activity Tasks that make up the Activity Execution, while\n\"Schedule\" in Schedule-To-Close refers to the _first_ Activity Task in that sequence.\n\nA [Retry Policy](/concepts/what-is-a-retry-policy) attached to an Activity Execution retries an Activity Task.\n\n![Start-To-Close Timeout period with retries](/diagrams/schedule-to-start-timeout-with-retry.svg)\n\nThis timeout has two primary use cases:\n\n1. Detect whether an individual Worker has crashed.\n2. Detect whether the fleet of Workers polling the Task Queue is not able to keep up with the rate of Activity Tasks.\n\n**The default Schedule-To-Start Timeout is ∞ (infinity).**\n\nIf this timeout is used, we recommend setting this timeout to the maximum time a Workflow Execution is willing to wait for an Activity Execution in the presence of all possible Worker outages, and have a concrete plan in place to reroute Activity Tasks to a different Task Queue.\nThis timeout **does not** trigger any retries regardless of the Retry Policy, as a retry would place the Activity Task back into the same Task Queue.\nWe do not recommend using this timeout unless you know what you are doing.\n\nIn most cases, we recommend monitoring the `temporal_activity_schedule_to_start_latency` metric to know when Workers slow down picking up Activity Tasks, instead of setting this timeout.\n","is_empty":false},{"file_name":"what-is-a-schedule.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-schedule.md","id":"concepts/what-is-a-schedule","title":"What is a Schedule","description":"A Schedule enables the scheduling of Workflow Executions.","label":"Schedule","tags":["term","explanation"],"markdown_content":"\nA Schedule contains instructions for starting a [Workflow Execution](/concepts/what-is-a-workflow-execution) at specific times.\nSchedules provide a more flexible and user-friendly approach than [Temporal Cron Jobs](/concepts/what-is-a-temporal-cron-job).\n\n- [How to enable Schedules](#limitations)\n- [How to operate Schedules using tctl](/tctl-v1/schedule#)\n\nA Schedule has an identity and is independent of a Workflow Execution.\nThis differs from a Temporal Cron Job, which relies on a cron schedule as a property of the Workflow Execution.\n\n### Action\n\nThe Action of a Schedule is where the Workflow Execution properties are established, such as Workflow Type, Task Queue, parameters, and timeouts.\n\nWorkflow Executions started by a Schedule have the following additional properties:\n\n- The Action's timestamp is appended to the Workflow Id.\n- The `TemporalScheduledStartTime` [Search Attribute](/concepts/what-is-a-search-attribute) is added to the Workflow Execution.\n  The value is the Action's timestamp.\n- The `TemporalScheduledById` Search Attribute is added to the Workflow Execution.\n  The value is the Schedule Id.\n\n### Spec\n\nThe Schedule Spec describes when the Action is taken.\nThere are two kinds of Schedule Spec:\n\n- A simple interval, like \"every 30 minutes\" (aligned to start at the Unix epoch, and optionally including a phase offset).\n- A calendar-based expression, similar to the \"cron expressions\" supported by lots of software, including the older Temporal Cron feature.\n\nThese two kinds have multiple representations, depending on the interface or SDK you're using, but they all support the same features.\n\nIn tctl, for example, an interval is specified as a string like `45m` to mean every 45 minutes, or `6h/5h` to mean every 6 hours but at the start of the fifth hour within each period.\n\nIn tctl, a calendar expression can be specified as either a traditional cron string with five (or six or seven) positional fields, or as JSON with named fields:\n\n```json\n{\n  \"year\": \"2022\",\n  \"month\": \"Jan,Apr,Jul,Oct\",\n  \"dayOfMonth\": \"1,15\",\n  \"hour\": \"11-14\"\n}\n```\n\nThe following calendar JSON fields are available:\n\n- `year`\n- `month`\n- `dayOfMonth`\n- `dayOfWeek`\n- `hour`\n- `minute`\n- `second`\n- `comment`\n\nEach field can contain a comma-separated list of ranges (or the `*` wildcard), and each range can include a slash followed by a skip value.\nThe `hour`, `minute`, and `second` fields default to `0` while the others default to `*`, so you can describe many useful specs with only a few fields.\n\nFor `month`, names of months may be used instead of integers (case-insensitive, abbreviations permitted).\nFor `dayOfWeek`, day-of-week names may be used.\n\nThe `comment` field is optional and can be used to include a free-form description of the intent of the calendar spec, useful for complicated specs.\n\nNo matter which form you supply, calendar and interval specs are converted to canonical representations.\nWhat you see when you \"describe\" or \"list\" a Schedule might not look exactly like what you entered, but it has the same meaning.\n\nOther Spec features:\n\n**Multiple intervals/calendar expressions:** A Spec can have combinations of multiple intervals and/or calendar expressions to define a specific Schedule.\n\n**Time bounds:** Provide an absolute start or end time (or both) with a Spec to ensure that no actions are taken before the start time or after the end time.\n\n**Exclusions:** A Spec can contain exclusions in the form of zero or more calendar expressions.\nThis can be used to express scheduling like \"each Monday at noon except for holidays.\nYou'll have to provide your own set of exclusions and include it in each schedule; there are no pre-defined sets.\n(This feature isn't currently exposed in tctl or the Temporal Web UI.)\n\n**Jitter:** If given, a random offset between zero and the maximum jitter is added to each Action time (but bounded by the time until the next scheduled Action).\n\n**Time zones:** By default, calendar-based expressions are interpreted in UTC.\nTemporal recommends using UTC to avoid various surprising properties of time zones.\nIf you don't want to use UTC, you can provide the name of a time zone.\nThe time zone definition is loaded on the Temporal Server Worker Service from either disk or the fallback embedded in the binary.\n\nFor more operational control, embed the contents of the time zone database file in the Schedule Spec itself.\n(Note: this isn't currently exposed in tctl or the web UI.)\n\n### Pause\n\nA Schedule can be Paused.\nWhen a Schedule is Paused, the Spec has no effect.\nHowever, you can still force manual actions by using the [tctl schedule trigger](/tctl-v1/schedule#trigger) command.\n\nTo assist communication among developers and operators, a “notes” field can be updated on pause or resume to store an explanation for the current state.\n\n### Backfill\n\nA Schedule can be Backfilled.\nWhen a Schedule is Backfilled, all the Actions that would have been taken over a specified time period are taken now (in parallel if the `AllowAll` [Overlap Policy](#overlap-policy) is used; sequentially if `BufferAll` is used).\nYou might use this to fill in runs from a time period when the Schedule was paused due to an external condition that's now resolved, or a period before the Schedule was created.\n\n### Limit number of Actions\n\nA Schedule can be limited to a certain number of scheduled Actions (that is, not trigger immediately).\nAfter that it will act as if it were paused.\n\n### Policies\n\nA Schedule supports a set of Policies that enable customizing behavior.\n\n#### Overlap Policy\n\nThe Overlap Policy controls what happens when it is time to start a Workflow Execution but a previously started Workflow Execution is still running.\nThe following options are available:\n\n- `Skip`: **Default**.\n  Nothing happens; the Workflow Execution is not started.\n- `BufferOne`: Starts the Workflow Execution as soon as the current one completes.\n  The buffer is limited to one.\n  If another Workflow Execution is supposed to start, but one is already in the buffer, only the one in the buffer eventually starts.\n- `BufferAll`: Allows an unlimited number of Workflows to buffer.\n  They are started sequentially.\n- `CancelOther`: Cancels the running Workflow Execution, and then starts the new one after the old one completes cancellation.\n- `TerminateOther`: Terminates the running Workflow Execution and starts the new one immediately.\n- `AllowAll` Starts any number of concurrent Workflow Executions.\n  With this policy (and only this policy), more than one Workflow Execution, started by the Schedule, can run simultaneously.\n\n#### Catchup Window\n\nThe Temporal Cluster might be down or unavailable at the time when a Schedule should take an Action.\nWhen it comes back up, the Catchup Window controls which missed Actions should be taken at that point.\nThe default is one minute, which means that the Schedule attempts to take any Actions that wouldn't be more than one minute late.\nAn outage that lasts longer than the Catchup Window could lead to missed Actions.\n(But you can always [Backfill](#backfill).)\n\n#### Pause-on-failure\n\nIf this policy is set, a Workflow Execution started by a Schedule that ends with a failure or timeout (but not Cancellation or Termination) causes the Schedule to automatically pause.\n\nNote that with the `AllowAll` Overlap Policy, this pause might not apply to the next Workflow Execution, because the next Workflow Execution might have started before the failed one finished.\nIt applies only to Workflow Executions that were scheduled to start after the failed one finished.\n\n### Last completion result\n\nA Workflow started by a Schedule can obtain the completion result from the most recent successful run.\n(How you do this depends on the SDK you're using.)\n\nFor overlap policies that don't allow overlap, “the most recent successful run” is straightforward to define.\nFor the `AllowAll` policy, it refers to the run that completed most recently, at the time that the run in question is started.\nConsider the following overlapping runs:\n\n```\ntime -------------------------------------------->\n A     |----------------------|\n B               |-------|\n C                          |---------------|\n D                                |--------------T\n```\n\nIf D asks for the last completion result at time T, it gets the result of A.\nNot B, even though B started more recently, because A completed later.\nAnd not C, even though C completed after A, because the result for D is captured when D is started, not when it's queried.\n\nFailures and timeouts do not affect the last completion result.\n\n### Last failure\n\nA Workflow started by a Schedule can obtain the details of the failure of the most recent run that ended at the time when the Workflow in question was started. Unlike last completion result, a _successful_ run _does_ reset the last failure.\n\n### Limitations\n\n:::info Experimental\n\nThe Scheduled Workflows feature is available in Temporal Server version 1.18.\n\nInternally, a Schedule is implemented as a Workflow.\nIf you're using Advanced Visibility (Elasticsearch), these Workflow Executions are hidden from normal views.\nIf you're using Standard Visibility, they are visible, though there's no need to interact with them directly.\n\n:::\n\nNative support for Schedules in language SDKs is coming soon.\nFor now, `tctl` and the web UI are the main interfaces to Schedules.\nFor advanced use, you can also use the gRPC API by getting a `WorkflowServiceClient` object from the SDK and calling methods such as `CreateSchedule`.\n","is_empty":false},{"file_name":"what-is-a-search-attribute.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-search-attribute.md","id":"concepts/what-is-a-search-attribute","title":"What is a Search Attribute?","description":"A Search Attribute is an indexed name used in List Filters to filter a list of Workflow Executions that have the Search Attribute in their metadata.","label":"Search Attribute","tags":["term","explanation","filtered-lists","visibility"],"markdown_content":"\nA Search Attribute is an indexed field used in a [List Filter](/concepts/what-is-a-list-filter) to filter a list of [Workflow Executions](/concepts/what-is-a-workflow-execution) that have the Search Attribute in their metadata.\n\nIf a [Temporal Cluster](/concepts/what-is-a-temporal-cluster) does not have [Elasticsearch integrated](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster), but a Workflow Execution is spawned and tagged with Search Attributes, no errors occur.\nHowever, you won't be able to use [Advanced Visibility](/concepts/what-is-advanced-visibility) List APIs and List Filters to find and list the Workflow Execution.\n\nWhen using [Continue-As-New](/concepts/what-is-continue-as-new) or a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job), Search Attributes are carried over to the new Workflow Run by default.\n\n#### Search Attributes maximums\n\nDefault total maximum number of Search Attribute **keys** per Temporal Cluster is 100.\n\n<!-- TODO - [How to configure maximum number of Search Attribute keys per Cluster](#) -->\n\nDefault single Search Attribute **value** size limit is 2 KB.\n\n<!-- TODO - [How to configure Search Attribute value size limit](#) -->\n\nTotal Search Attribute size: 40 KB\n\n<!-- TODO - [How to configure total Search Attribute size limite](#) -->\n\n<!-- temp keeping for reference\nThis is configurable with [`SearchAttributesNumberOfKeysLimit`, `SearchAttributesTotalSizeLimit` and `SearchAttributesSizeOfValueLimit`](https://github.com/temporalio/temporal/blob/v1.7.0/service/history/configs/config.go#L440-L442), if you know what you are doing.\n-->\n\n#### Default Search Attributes\n\nA Temporal Cluster that is integrated with Elasticsearch has a set of default Search Attributes already available.\nThese Search Attributes are created when the initial index is created.\n\n| NAME                  | TYPE     | DEFINITION                                                                                                                                                                   |\n| --------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| WorkflowType          | Keyword  | The type of Workflow.                                                                                                                                                        |\n| WorkflowId            | Keyword  | Identifies the Workflow Execution.                                                                                                                                           |\n| ExecutionStatus       | Keyword  | The current state of the Workflow Execution.                                                                                                                                 |\n| StartTime             | Datetime | The time at which the Workflow Execution started.                                                                                                                            |\n| CloseTime             | Datetime | The time at which the Workflow Execution completed.                                                                                                                          |\n| ExecutionTime         | Datetime | Same as StartTime for the most cases but different for cron Workflows and retried Workflows. For them it is the time at which the Workflow Execution actually begin running. |\n| RunId                 | Keyword  | Identifies the current Workflow Execution Run.                                                                                                                               |\n| ExecutionDuration     | Int      | The time needed to run the Workflow Execution. Available only for closed Workflows.                                                                                          |\n| HistoryLength         | Int      | The number of events in the history of Workflow Execution. Available only for closed Workflows.                                                                              |\n| StateTransitionCount  | Int      | The number of times that Workflow Execution has persisted its state. Available only for closed Workflows.                                                                    |\n| TaskQueue             | Keyword  | Task Queue used by Workflow Execution.                                                                                                                                       |\n| TemporalChangeVersion | Keyword  | If Workflow versioning is enabled, list of change/version pairs will be stored here.                                                                                         |\n| BinaryChecksums       | Keyword  | List of binary Ids of Workers that run the Workflow Execution.                                                                                                               |\n| BatcherNamespace      | Keyword  | Used by internal batcher to indicate the Namespace where batch operation was applied to.                                                                                     |\n| BatcherUser           | Keyword  | Used by internal batcher to indicate the user who started the batch operation.                                                                                               |\n\n- All default Search Attributes are reserved and read-only.\n  (You cannot create a custom one with the same name or alter the existing one.)\n\n- ExecutionStatus values correspond to Workflow Execution Statuses: Running, Completed, Failed, Canceled, Terminated, ContinuedAsNew, TimedOut.\n\n- StartTime, CloseTime, and ExecutionTime are stored as dates but are supported by queries that use either EpochTime in nanoseconds or a string in [RFC3339Nano format](https://pkg.go.dev/time#pkg-constants) (such as \"2006-01-02T15:04:05.999999999Z07:00\").\n\n- ExecutionDuration is stored in nanoseconds but is supported by queries that use integers in nanoseconds, [Golang duration format](https://pkg.go.dev/time#ParseDuration), or \"hh:mm:ss\" format.\n\n- CloseTime, HistoryLength, StateTransitionCount, and ExecutionDuration are present only in a Closed Workflow Execution.\n\n- ExecutionTime can differ from StartTime in retry and cron use cases.\n\n#### Custom Search Attributes\n\nCustom Search Attributes can be added to a Temporal Cluster by using `tctl search-attribute create`.\nAdding a Search Attribute makes it available to use with Workflow Executions within that Cluster.\n\nThere is no hard limit on the number of attributes you can add.\nHowever, we recommend enforcing the following limits:\n\n- Number of Search Attributes: 100 per Workflow\n- Size of each value: 2 KB per value\n- Total size of names and values: 40 KB per Workflow\n\n:::note\n\nDue to Elasticsearch limitations, you can only add Search Attributes.\nIt is not possible to rename Search Attributes or remove them from the index schema.\n\n:::\n\nThe [temporalio/auto-setup](https://hub.docker.com/r/temporalio/auto-setup) Docker image uses a pre-defined set of custom Search Attributes that are handy for testing.\nTheir names indicate their types:\n\n- CustomBoolField\n- CustomDatetimeField\n- CustomDoubleField\n- CustomIntField\n- CustomKeywordField\n- CustomTextField\n\n#### Types\n\nSearch Attributes must be one of the following types:\n\n- Bool\n- Datetime\n- Double\n- Int\n- Keyword\n- Text\n\nNote:\n\n- **Double** is backed up by `scaled_float` Elasticsearch type with scale factor 10000 (4 decimal digits).\n- **Datetime** is backed up by `date` type with milliseconds precision in Elasticsearch 6 and `date_nanos` type with nanoseconds precision in Elasticsearch 7.\n- **Int** is 64-bit integer (`long` Elasticsearch type).\n- **Keyword** and **Text** types are concepts taken from Elasticsearch. Each word in a **Text** is considered a searchable keyword.\n  For a UUID, that can be problematic because Elasticsearch indexes each portion of the UUID separately.\n  To have the whole string considered as a searchable keyword, use the **Keyword** type.\n  For example, if the key `ProductId` has the value of `2dd29ab7-2dd8-4668-83e0-89cae261cfb1`:\n  - As a **Keyword** it would be matched only by `ProductId = \"2dd29ab7-2dd8-4668-83e0-89cae261cfb1`.\n  - As a **Text** it would be matched by `ProductId = 2dd8`, which could cause unwanted matches.\n- The **Text** type cannot be used in the \"Order By\" clause.\n\n- [How to view Search Attributes using tctl](/tctl-v1/cluster#get-search-attributes)\n\n#### Search Attributes as Workflow Execution metadata\n\nTo actually have results from the use of a [List Filter](/concepts/what-is-a-list-filter), Search Attributes must be added to a Workflow Execution as metadata.\nHow to do this entirely depends on the method by which you spawn the Workflow Execution:\n\n- [How to set Search Attributes as Workflow Execution metadata in Go](/go/startworkflowoptions-reference/#searchattributes)\n","is_empty":false},{"file_name":"what-is-a-side-effect.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-side-effect.md","id":"concepts/what-is-a-side-effect","title":"What is a Side Effect?","description":"A Side Effect is a way to execute a short, nondeterministic code snippet, such as generating a UUID, that executes the provided function once and records its result into the Workflow Execution Event History.","label":"Side Effect","tags":["term","explanation"],"markdown_content":"\nA Side Effect is a way to execute a short, nondeterministic code snippet, such as generating a UUID, that executes the provided function once and records its result into the Workflow Execution Event History.\n\nA Side Effect does not re-execute upon replay, but instead returns the recorded result.\n\nDo not ever have a Side Effect that could fail, because failure could result in the Side Effect function executing more than once.\nIf there is any chance that the code provided to the Side Effect could fail, use an Activity.\n","is_empty":false},{"file_name":"what-is-a-signal.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-signal.md","id":"concepts/what-is-a-signal","title":"What is a Signal?","description":"A Signal is an asynchronous request to a Workflow Execution.","label":"Signal","tags":["term","signals","explanation"],"markdown_content":"\nA Signal is an asynchronous request to a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\n- [How to develop, send, and handle Signals in code](/application-development/features#signals)\n- [How to send a Signal using tctl](/tctl-v1/workflow#signal)\n\nA Signal delivers data to a running Workflow Execution.\nIt cannot return data to the caller; to do so, use a [Query](#queries) instead.\nThe Workflow code that handles a Signal can mutate Workflow state.\nA Signal can be sent from a Temporal Client or a Workflow.\nWhen a Signal is sent, it is received by the Cluster and recorded as an Event to the Workflow Execution [Event History](#event-history).\nA successful response from the Cluster means that the Signal has been persisted and will be delivered at least once to the Workflow Execution.[^1]\nThe next scheduled Workflow Task will contain the Signal Event.\n\nA Signal must include a destination (Namespace and Workflow Id) and name.\nIt can include a list of arguments.\n\nSignal handlers are Workflow functions that listen for Signals by the Signal name.\nSignals are delivered in the order they are received by the Cluster.\nIf multiple deliveries of a Signal would be a problem for your Workflow, add idempotency logic to your Signal handler that checks for duplicates.\n\n[^1]: The Cluster usually deduplicates Signals, but does not guarantee deduplication: During shard migration, two Signal Events (and therefore two deliveries to the Workflow Execution) can be recorded for a single Signal because the deduping info is stored only in memory.\n","is_empty":false},{"file_name":"what-is-a-start-to-close-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-start-to-close-timeout.md","id":"concepts/what-is-a-start-to-close-timeout","title":"What is a Start-To-Close Timeout?","description":"A Start-To-Close Timeout is the maximum time allowed for a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["term","explanation","timeouts"],"markdown_content":"\nA Start-To-Close Timeout is the maximum time allowed for a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n\n- [How to set a Start-To-Close Timeout](/go/how-to-set-a-start-to-close-timeout-in-go)\n\n**The default Start-To-Close Timeout is the same as the default [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout).**\n\nAn Activity Execution must have either this timeout (Start-To-Close) or the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) set.\nWe recommend always setting this timeout; however, make sure that it is always set to be longer than the maximum possible time for the Activity Execution to take place.\nFor long running Activity Executions, we recommend also using [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat) and [Heartbeat Timeouts](/concepts/what-is-a-heartbeat-timeout).\n\nThe main use case for the Start-To-Close timeout is to detect when a Worker crashes after it has started executing an Activity Task.\n\n![Start-To-Close Timeout period](/diagrams/start-to-close-timeout.svg)\n\nA [Retry Policy](/concepts/what-is-a-retry-policy) attached to an Activity Execution retries an Activity Task Execution.\nThus, the Start-To-Close Timeout is applied to each Activity Task Execution within an Activity Execution.\n\nIf the first Activity Task Execution returns an error the first time, then the full Activity Execution might look like this:\n\n![Start-To-Close Timeout period with retries](/diagrams/start-to-close-timeout-with-retry.svg)\n\nIf this timeout is reached, the following actions occur:\n\n- An [ActivityTaskTimedOut](/references/events/#activitytasktimedout) Event is written to the Workflow Execution's mutable state.\n- If a Retry Policy dictates a retry, the Temporal Cluster schedules another Activity Task.\n  - The attempt count increments by 1 in the Workflow Execution's mutable state.\n  - The Start-To-Close Timeout timer is reset.\n","is_empty":false},{"file_name":"what-is-a-sticky-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-sticky-execution.md","id":"concepts/what-is-a-sticky-execution","title":"What is a Sticky Execution?","description":"A Sticky Execution is a when a Worker Entity caches the Workflow Execution Event History and creates a dedicated Task Queue to listen on.","label":"Sticky Execution","tags":["term","explanation"],"markdown_content":"\nA Sticky Execution is when a Worker Entity caches the Workflow Execution Event History and creates a dedicated Task Queue to listen on.\n\nA Sticky Execution occurs after a Worker Entity completes the first Workflow Task in the chain of Workflow Tasks for the Workflow Execution.\n\nThe Worker Entity caches the Workflow Execution Event History and begins polling the dedicated Task Queue for Workflow Tasks that contain updates, rather than the entire Event History.\n\nIf the Worker Entity does not pick up a Workflow Task from the dedicated Task Queue in an appropriate amount of time, the Cluster will resume Scheduling Workflow Tasks on the original Task Queue.\nAnother Worker Entity can then resume the Workflow Execution, and can set up its own Sticky Execution for future Workflow Tasks.\n\n- [How to set a `StickyScheduleToStartTimeout` on a Worker Entity in Go](/go/how-to-set-workeroptions-in-go/#stickyscheduletostarttimeout)\n\nSticky Executions are the default behavior of the Temporal Platform.\n","is_empty":false},{"file_name":"what-is-a-task-queue.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-task-queue.md","id":"concepts/what-is-a-task-queue","title":"What is a Task Queue?","description":"A Task Queue is a first-in, first-out queue that a Worker Process polls for Tasks.","label":"Task Queue","tags":["term","explanation"],"markdown_content":"\nA Task Queue is a lightweight, dynamically allocated queue that one or more [Worker Entities](/concepts/what-is-a-worker-entity) poll for [Tasks](/concepts/what-is-a-task).\n\nTask Queues do not have any ordering guarantees.\nIt is possible to have a Task that stays in a Task Queue for a period of time, if there is a backlog that wasn't drained for that time.\n\nThere are two types of Task Queues, Activity Task Queues and Workflow Task Queues.\n\n![Task Queue component](/diagrams/task-queue.svg)\n\nTask Queues are very lightweight components.\nTask Queues do not require explicit registration but instead are created on demand when a Workflow Execution or Activity spawns or when a Worker Process subscribes to it.\nWhen a Task Queue is created, both a Workflow Task Queue and an Activity Task Queue are created under the same name.\nThere is no limit to the number of Task Queues a Temporal Application can use or a Temporal Cluster can maintain.\n\nWorkers poll for Tasks in Task Queues via synchronous RPC.\nThis implementation offers several benefits:\n\n- A Worker Process polls for a message only when it has spare capacity, avoiding overloading itself.\n- In effect, Task Queues enable load balancing across many Worker Processes.\n- Task Queues enable what we call [Task Routing](/concepts/what-is-task-routing), which is the routing of specific Tasks to specific Worker Processes or even a specific process.\n- Task Queues support server-side throttling, which enables you to limit the Task dispatching rate to the pool of Worker Processes while still supporting Task dispatching at higher rates when spikes happen.\n- When all Worker Processes are down, messages simply persist in a Task Queue, waiting for the Worker Processes to recover.\n- Worker Processes do not need to advertise themselves through DNS or any other network discovery mechanism.\n- Worker Processes do not need to have any open ports, which is more secure.\n\nAll Workers listening to a given Task Queue must have identical registrations of Activities and/or Workflows.\nThe one exception is during a Server upgrade, where it is okay to have registration temporarily misaligned while the binary rolls out.\n\n#### Where to set Task Queues\n\nThere are four places where the name of the Task Queue can be set by the developer.\n\n1. A Task Queue must be set when spawning a Workflow Execution:\n\n- [How to start a Workflow Execution using an SDK](/application-development/foundations#set-task-queue)\n- [How to start a Workflow Execution using tctl](/tctl-v1/workflow#start)\n\n2. A Task Queue name must be set when creating a Worker Entity and when running a Worker Process:\n\n- [How to develop a Worker Program](/application-development/foundations#run-worker-processes)\n\nNote that all Worker Entities listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker Entity polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. A Task Queue name can be provided when spawning an Activity Execution:\n\nThis is optional.\nAn Activity Execution inherits the Task Queue name from its Workflow Execution if one is not provided.\n\n- [How to start an Activity Execution](/application-development/foundations#activity-execution)\n\n4. A Task Queue name can be provided when spawning a Child Workflow Execution:\n\nThis is optional.\nA Child Workflow Execution inherits the Task Queue name from its Parent Workflow Execution if one is not provided.\n\n- [How to start a Child Workflow Execution](/application-development/features#child-workflows)\n","is_empty":false},{"file_name":"what-is-a-task-token.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-task-token.md","id":"concepts/what-is-a-task-token","title":"What is a Task Token?","description":"A Task Token is a unique Id that correlates to an Activity Execution.","label":"Task Token","tags":["term","explanation"],"markdown_content":"\nA Task Token is a unique identifier for an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n\n[Asynchronous Activity Completion](/concepts/what-is-asynchronous-activity-completion/) calls take either of the following as arguments:\n\n- a Task Token, or\n- an [Activity Id](/concepts/what-is-an-activity-id), a [Workflow Id](/concepts/what-is-a-workflow-id), and optionally a [Run Id](/concepts/what-is-a-run-id/).\n","is_empty":false},{"file_name":"what-is-a-task.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-task.md","id":"concepts/what-is-a-task","title":"What is a Task?","description":"A Task is the context needed to make progress with a specific Workflow Execution or Activity Execution.","label":"Task","tags":["term","explanation"],"markdown_content":"\nA Task is the context that a Worker needs to progress with a specific [Workflow Execution](/concepts/what-is-a-workflow-execution) or [Activity Execution](/concepts/what-is-an-activity-execution).\n\nThere are two types of Tasks:\n\n- [Activity Task](/concepts/what-is-an-activity-task)\n- [Workflow Task](/concepts/what-is-a-workflow-task)\n","is_empty":false},{"file_name":"what-is-a-temporal-application.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-temporal-application.md","id":"concepts/what-is-a-temporal-application","title":"What is a Temporal Application","description":"A Temporal Application is a set of Workflow Executions.","label":"Temporal Application","tags":["term","explanation"],"markdown_content":"\nA Temporal Application is a set of [Temporal Workflow Executions](/concepts/what-is-a-workflow-execution).\nEach Temporal Workflow Execution has exclusive access to its local state, executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions and the environment via message passing.\n\nA Temporal Application can consist of millions to billions of Workflow Executions.\nWorkflow Executions are lightweight components.\nA Workflow Execution consumes few compute resources; in fact, if a Workflow Execution is suspended, such as when it is in a waiting state, the Workflow Execution consumes no compute resources at all.\n\n**Reentrant Process**\n\nA Temporal Workflow Execution is a Reentrant Process. A Reentrant Process is resumable, recoverable, and reactive.\n\n- Resumable: Ability of a process to continue execution after execution was suspended on an _awaitable_.\n- Recoverable: Ability of a process to continue execution after execution was suspended on a _failure_.\n- Reactive: Ability of a process to react to external events.\n\nTherefore, a Temporal Workflow Execution executes a [Temporal Workflow Definition](/concepts/what-is-a-workflow-definition), also called a Temporal Workflow Function, your application code, exactly once and to completion—whether your code executes for seconds or years, in the presence of arbitrary load and arbitrary failures.\n","is_empty":false},{"file_name":"what-is-a-temporal-client.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-temporal-client.md","id":"concepts/what-is-a-temporal-client","title":"What is a Temporal Client","description":"A Temporal Client, provided by a Temporal SDK, provides a set of APIs to communicate with a Temporal Cluster.","label":"Temporal Client","tags":["term","explanation"],"markdown_content":"\nA Temporal Client is available in each SDK and provides a set of APIs to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n\nThe most common operations that a Temporal Client enables you to perform are the following:\n\n- Get the result of Workflow Execution.\n- List Workflow Executions.\n- Query a Workflow Execution.\n- Signal a Workflow Execution.\n- Start a Workflow Execution.\n","is_empty":false},{"file_name":"what-is-a-temporal-cluster.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-temporal-cluster.md","id":"concepts/what-is-a-temporal-cluster","title":"What is a Temporal Cluster?","description":"A Temporal Cluster is the Temporal Server paired with persistence.","label":"Temporal Cluster","tags":["term","explanation"],"markdown_content":"\nA Temporal Cluster is the group of services, known as the [Temporal Server](/concepts/what-is-the-temporal-server), combined with persistence stores, that together act as a component of the Temporal Platform.\n\n- [How to quickly install a Temporal Cluster for testing and development](/clusters/quick-install)\n- [Cluster deployment guide](/cluster-deployment-guide)\n\n![A Temporal Cluster (Server + persistence)](/diagrams/temporal-cluster.svg)\n\n### Persistence\n\nA Temporal Cluster's only required dependency for basic operation is a database.\nMultiple types of databases are supported.\n\n![Persistence](/diagrams/temporal-database.svg)\n\nThe database stores the following types of data:\n\n- Tasks: Tasks to be dispatched.\n- State of Workflow Executions:\n  - Execution table: A capture of the mutable state of Workflow Executions.\n  - History table: An append only log of Workflow Execution History Events.\n- Namespace metadata: Metadata of each Namespace in the Cluster.\n- Visibility data: Enables operations like \"show all running Workflow Executions\".\n  For production environments, we recommend using Elasticsearch.\n\nAn Elasticsearch database can be added to enable [Advanced Visibility](/concepts/what-is-advanced-visibility).\n\n#### Dependency versions\n\nTemporal tests compatibility by spanning the **minimum** and **maximum** stable non-EOL major versions for each supported database.\nAs of time of writing, these specific versions are used in our test pipelines and actively tested before we release any version of Temporal:\n\n- **Cassandra v3.11 and v4.0**\n- **PostgreSQL v10.18 and v13.4**\n- **MySQL v5.7 and v8.0** (specifically 8.0.19+ due to a bug)\n\nWe update these support ranges once a year.\nThe release notes of each Temporal Server declare when we plan to drop support for database versions reaching End of Life.\n\n- Because Temporal Server primarily relies on core database functionality, we do not expect compatibility to break often.\n  Temporal has no opinions on database upgrade paths; as long as you can upgrade your database according to each project's specifications, Temporal should work with any version within supported ranges.\n- We do not run tests with vendors like Vitess and CockroachDB, so you rely on their compatibility claims if you use them.\n  Feel free to discuss them with fellow users [in our forum](https://community.temporal.io/).\n- Temporal is [working on official SQLite v3.x persistence](https://github.com/temporalio/temporal/pulls?q=is%3Apr+sort%3Aupdated-desc+sqlite), but this is meant only for development and testing, not production usage.\n  Cassandra, MySQL, and PostgreSQL schemas are supported and thus can be used as the Server's database.\n\n### Monitoring and observation\n\nTemporal emits metrics by default in a format that is supported by Prometheus.\nMonitoring and observing those metrics is optional.\nAny metrics software that supports the same format can be used. Currently, we test with the following Prometheus and Grafana versions:\n\n- **Prometheus >= v2.0**\n- **Grafana >= v2.5**\n\n### Visibility\n\nTemporal has built-in [Visibility](/concepts/what-is-visibility) features.\nTo enhance this feature, Temporal supports an [integration with Elasticsearch](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster).\n\n- Elasticsearch v8 is supported from Temporal version 1.18.0 onwards\n- Elasticsearch v7.10 is supported from Temporal version 1.7.0 onwards\n- Elasticsearch v6.8 is supported up to Temporal version 1.17.x\n- Elasticsearch v6.8 and v7.10 versions are explicitly supported with AWS Elasticsearch\n\n### mTLS encryption\n\nTemporal supports Mutual Transport Layer Security (mTLS) as a method of encrypting network traffic between services within a Temporal Cluster, or between application processes and a Cluster.\n\nMutual TLS can be enabled in Temporal’s [TLS configuration](/references/configuration#tls).\nThis configuration can be passed through `WithConfig` or `WithConfigLoader`.\n\nThis configuration includes two sections that serve to separate intra-cluster and external traffic. That way, different certificates and settings can be used to encrypt each section of traffic:\n\n- `internode`: configuration for encrypting communication between nodes within the Cluster.\n- `frontend`: configuration for encrypting the Frontend's public endpoints\n\n### Temporal Client connections\n\nA client's network access can be limited by using certificates issued by a specific Certificate Authority (CA).\n\nTo restrict access to Temporal Cluster endpoints, use the `clientCAFiles` or `clientCAData` property and the `requireClientAuth` property.\nThese properties can be specified in both the `internode` and `frontend` sections of the [mTLS configuration](/references/configuration#tls).\n\n#### Server name specification\n\nSpecify the `serverName` in the `client` section of your mTLS configuration to prevent spoofing and [MITM attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack).\n\nEntering a value for `serverName` enables established connections to authenticate the endpoint.\nThis ensures that the server certificate presented to any connected client has the specified server name in its CN property.\n\nThis measure can be used for `internode` and `frontend` endpoints.\n\nFor more information on mTLS configuration, refer to our [TLS configuration guide](/references/configuration#tls).\n\n### Auth\n\n**Authentication** is the process of verifying users who want to access your application are actually the users you want accessing it.\n**Authorization** is the verification of applications and data that a user on your Cluster or application has access to.\n\nTemporal has several authentication protocols that can be set to restrict access to your data.\nThese protocols address three areas: servers, client connections, and users.\n\nServer attacks can be prevented by specifying `serverName` in the `client` section of your mTLS configuration.\nThis can be done for both `frontend` and `internode` endpoints.\n\nClient connections can be restricted to certain endpoints by requiring certificates from a specific CA.\nModify the `clientCaFiles`, `clientCaData`, and `requireClientAuth` properties in the `internode` and `frontend` sections of the mTLS configuration.\n\nUser access can be restricted through extensibility points and plugins.\nWhen implemented, the `frontend` invokes the plugin before executing the requested operation.\n\nTemporal offers two plugin interfaces for API call authentication and authorization.\n\n- [`ClaimMapper`](/concepts/what-is-a-claimmapper-plugin)\n- [`Authorizer`](/concepts/what-is-an-authorizer-plugin)\n\nThe logic of both plugins can be customized to fit a variety of use cases.\nWhen provided, the frontend invokes the implementation of the plugins before running the requested operation.\n","is_empty":false},{"file_name":"what-is-a-temporal-cron-job.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-temporal-cron-job.md","id":"concepts/what-is-a-temporal-cron-job","title":"What is a Temporal Cron Job?","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Job","tags":["term","explanation"],"markdown_content":"\nA Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\n![Temporal Cron Job timeline](/diagrams/temporal-cron-job.svg)\n\nA Temporal Cron Job is similar to a classic unix cron job.\nJust as a unix cron job accepts a command and a schedule on which to execute that command, a Cron Schedule can be provided with the call to spawn a Workflow Execution.\nIf a Cron Schedule is provided, the Temporal Server will spawn an execution for the associated Workflow Type per the schedule.\n\nEach Workflow Execution within the series is considered a Run.\n\n- Each Run receives the same input parameters as the initial Run.\n- Each Run inherits the same Workflow Options as the initial Run.\n\nThe Temporal Server spawns the first Workflow Execution in the chain of Runs immediately.\nHowever, it calculates and applies a backoff (`firstWorkflowTaskBackoff`) so that the first Workflow Task of the Workflow Execution does not get placed into a Task Queue until the scheduled time.\nAfter each Run Completes, Fails, or reaches the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout), the same thing happens: the next run will be created immediately with a new `firstWorkflowTaskBackoff` that is calculated based on the current Server time and the defined Cron Schedule.\n\nThe Temporal Server spawns the next Run only after the current Run has Completed, Failed, or has reached the Workflow Run Timeout.\nThis means that, if a Retry Policy has also been provided, and a Run Fails or reaches the Workflow Run Timeout, the Run will first be retried per the Retry Policy until the Run Completes or the Retry Policy has been exhausted.\nIf the next Run, per the Cron Schedule, is due to spawn while the current Run is still Open (including retries), the Server automatically starts the new Run after the current Run completes successfully.\nThe start time for this new Run and the Cron definitions are used to calculate the `firstWorkflowTaskBackoff` that is applied to the new Run.\n\nA [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) is used to limit how long a Workflow can be executing (have an Open status), including retries and any usage of Continue As New.\nThe Cron Schedule runs until the Workflow Execution Timeout is reached or you terminate the Workflow.\n\n![Temporal Cron Job Run Failure with a Retry Policy](/diagrams/temporal-cron-job-failure-with-retry.svg)\n\n### Cron Schedules\n\nCron Schedules are interpreted in UTC time by default.\n\nThe Cron Schedule is provided as a string and must follow one of two specifications:\n\n**Classic specification**\n\nThis is what the \"classic\" specification looks like:\n\n```\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12)\n│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n│ │ │ │ │\n* * * * *\n```\n\nFor example, `15 8 * * *` causes a Workflow Execution to spawn daily at 8:15 AM UTC.\nUse the [crontab guru site](https://crontab.guru/) to test your cron expressions.\n\n### `robfig` predefined schedules and intervals\n\nYou can also pass any of the [predefined schedules](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Predefined_schedules) or [intervals](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Intervals) described in the [`robfig/cron` documentation](https://pkg.go.dev/github.com/robfig/cron/v3).\n\n```\n| Schedules              | Description                                | Equivalent To |\n| ---------------------- | ------------------------------------------ | ------------- |\n| @yearly (or @annually) | Run once a year, midnight, Jan. 1st        | 0 0 1 1 *     |\n| @monthly               | Run once a month, midnight, first of month | 0 0 1 * *     |\n| @weekly                | Run once a week, midnight between Sat/Sun  | 0 0 * * 0     |\n| @daily (or @midnight)  | Run once a day, midnight                   | 0 0 * * *     |\n| @hourly                | Run once an hour, beginning of hour        | 0 * * * *     |\n```\n\nFor example, \"@weekly\" causes a Workflow Execution to spawn once a week at midnight between Saturday and Sunday.\n\nIntervals just take a string that can be accepted by [time.ParseDuration](http://golang.org/pkg/time/#ParseDuration).\n\n```\n@every <duration>\n```\n\n### Time zones\n\n_This feature only applies in Temporal 1.15 and up_\n\nYou can change the time zone that a Cron Schedule is interpreted in by prefixing the specification with `CRON_TZ=America/New_York` (or your [desired time zone from tz](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)). `CRON_TZ=America/New_York 15 8 * * *` therefore spawns a Workflow Execution every day at 8:15 AM New York time, subject to caveats listed below.\n\nConsider that using time zones in production introduces a surprising amount of complexity and failure modes!\n**If at all possible, we recommend specifying Cron Schedules in UTC (the default)**.\n\nIf you need to use time zones, here are a few edge cases to keep in mind:\n\n- **Beware Daylight Saving Time**: If a Temporal Cron Job is scheduled around the time when daylight saving time (DST) begins or ends (for example, `30 2 * * *`), **it might run zero, one, or two times in a day**! The Cron library that we use does not do any special handling of DST transitions. Avoid schedules that include times that fall within DST transition periods.\n  - For example, in the US, DST begins at 2 AM. When you \"fall back,\" the clock goes `1:59 … 1:00 … 1:01 … 1:59 … 2:00 … 2:01 AM` and any Cron jobs that fall in that 1 AM hour are fired again. The inverse happens when clocks \"spring forward\" for DST, and Cron jobs that fall in the 2 AM hour are skipped.\n  - In other time zones like Chile and Iran, DST \"spring forward\" is at midnight. 11:59 PM is followed by 1 AM, which means `00:00:00` never happens.\n- **Self Hosting note**: If you manage your own Temporal Cluster, you are responsible for ensuring that it has access to current `tzdata` files. The official Docker images are built with [tzdata](https://docs.w3cub.com/go/time/tzdata/index) installed (provided by Alpine Linux), but ultimately you should be aware of how tzdata is deployed and updated in your infrastructure.\n- **Updating Temporal**: If you use the official Docker images, note that an upgrade of the Temporal Cluster may include an update to the tzdata files, which may change the meaning of your Cron Schedule. You should be aware of upcoming changes to the definitions of the time zones you use, particularly around daylight saving time start/end dates.\n- **Absolute Time Fixed at Start**: The absolute start time of the next Run is computed and stored in the database when the previous Run completes, and is not recomputed. This means that if you have a Cron Schedule that runs very infrequently, and the definition of the time zone changes between one Run and the next, the Run might happen at the wrong time. For example, `CRON_TZ=America/Los_Angeles 0 12 11 11 *` means \"noon in Los Angeles on November 11\" (normally not in DST). If at some point the government makes any changes (for example, move the end of DST one week later, or stay on permanent DST year-round), the meaning of that specification changes. In that first year, the Run happens at the wrong time, because it was computed using the older definition.\n\n### How to stop a Temporal Cron Job\n\nA Temporal Cron Job does not stop spawning Runs until it has been Terminated or until the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) is reached.\n\nA Cancellation Request affects only the current Run.\n\nUse the Workflow Id in any requests to Cancel or Terminate.\n\n**Implementation guides:**\n\n- [How to set a Cron Schedule in Go](/go/startworkflowoptions-reference/#cronschedule)\n- [How to set a Cron Schedule in Java](/java/reference-workflowoptions/#cronschedule)\n- [How to set a Cron Schedule in PHP](/php/distributed-cron)\n- [How to set a Cron Schedule in Typescript](/typescript/clients)\n","is_empty":false},{"file_name":"what-is-a-temporal-sdk.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-temporal-sdk.md","id":"concepts/what-is-a-temporal-sdk","title":"What is a Temporal SDK?","description":"A Temporal SDK is a language-specific library that offers APIs to construct and use a Temporal Client to communicate with a Temporal Cluster, develop Workflow Definitions, and develop Worker Programs.","label":"Temporal SDK","tags":["term","explanation"],"markdown_content":"\nA Temporal SDK is a language-specific library that offers APIs to do the following:\n\n1. Construct and use a [Temporal Client](/concepts/what-is-a-temporal-client)\n2. Develop [Workflow Definitions](/concepts/what-is-a-workflow-definition)\n3. Develop [Worker Programs](/concepts/what-is-a-worker-program)\n\nA Temporal SDK enables you to write your application code using the full power of the programming language, while the Temporal Platform handles the durability, reliability, and scalability of the application.\n\nTemporal currently offers the following SDKs:\n\n- [Get started with the Go SDK](/application-development/foundations/?lang=go#add-your-sdk)\n- [Get started with the Java SDK](/application-development/foundations/?lang=java#add-your-sdk)\n- [Get started with the PHP SDK](/application-development/foundations/?lang=php)\n- [Get started with the Python SDK](/application-development/foundations/?lang=python#add-your-sdk)\n- [How to use the TypeScript SDK](/application-development/foundations/?lang=typescript#add-your-sdk)\n\nEach SDK emits metrics which can be ingested into monitoring platforms.\nSee the [SDK metrics reference](/references/sdk-metrics) for a complete list.\n\n### Auth\n\nTemporal offers methods of authenticating and authorizing client API calls within our SDKs.\n\n### SDKs in development\n\nThe following SDKs are in alpha/pre-alpha development stages, but are not yet supported in the Developer's guide:\n\n- [.NET](https://github.com/temporalio/sdk-dotnet)\n- [Rust](https://github.com/temporalio/sdk-core)\n- [Ruby](https://github.com/temporalio/sdk-ruby)\n\n### Third-party SDKs\n\nThe following third-party SDKs exist but are not supported in the [Developer's guide](/application-development):\n\n- [Clojure](https://github.com/manetu/temporal-clojure-sdk) - from [@Manetu](https://github.com/manetu)\n- [Scala](https://github.com/vitaliihonta/zio-temporal) from [@vitaliihonta](https://github.com/vitaliihonta)\n- [Ruby](https://github.com/coinbase/temporal-ruby) from [@coinbase](https://github.com/coinbase)\n","is_empty":false},{"file_name":"what-is-a-worker-entity.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-worker-entity.md","id":"concepts/what-is-a-worker-entity","title":"What is a Worker Entity?","description":"A Worker Entity is the individual Worker within a Worker Process that listens to a specific Task Queue.","label":"Worker Entity","tags":["term","explanation"],"markdown_content":"\nA Worker Entity is the individual Worker within a Worker Process that listens to a specific Task Queue.\n\nA Worker Entity listens and polls on a single Task Queue.\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it may make progress of either a Workflow Execution or an Activity Execution.\n\n**Can a Worker handle more Workflow Executions than its cache size or number of supported threads?**\n\nYes it can.\nHowever, the trade off is added latency.\n\nWorkers are stateless, so any Workflow Execution in a blocked state can be safely removed from a Worker.\nLater on, it can be resurrected on the same or different Worker when the need arises (in the form of an external event).\nTherefore, a single Worker can handle millions of open Workflow Executions, assuming it can handle the update rate and that a slightly higher latency is not a concern.\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)\n","is_empty":false},{"file_name":"what-is-a-worker-process.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-worker-process.md","id":"concepts/what-is-a-worker-process","title":"What is a Worker Process?","description":"A Worker Process is responsible for polling a Task Queue, dequeueing a Task, executing your code in response to a Task, and responding to the Temporal Server with the results.","label":"Worker Process","tags":["term","explanation"],"markdown_content":"\n![Component diagram of a Worker Process and the Temporal Server](/diagrams/worker-and-server-component.svg)\n\nA Worker Process is responsible for polling a [Task Queue](/concepts/what-is-a-task-queue), dequeueing a [Task](/concepts/what-is-a-task), executing your code in response to a Task, and responding to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) with the results.\n\nMore formally, a Worker Process is any process that implements the Task Queue Protocol and the Task Execution Protocol.\n\n- A Worker Process is a Workflow Worker Process if the process implements the Workflow Task Queue Protocol and executes the Workflow Task Execution Protocol to make progress on a Workflow Execution.\n  A Workflow Worker Process can listen on an arbitrary number of Workflow Task Queues and can execute an arbitrary number of Workflow Tasks.\n- A Worker Process is an Activity Worker Process if the process implements the Activity Task Queue Protocol and executes the Activity Task Processing Protocol to make progress on an Activity Execution.\n  An Activity Worker Process can listen on an arbitrary number of Activity Task Queues and can execute an arbitrary number of Activity Tasks.\n\n**Worker Processes are external to a Temporal Cluster.**\nTemporal Application developers are responsible for developing [Worker Programs](/concepts/what-is-a-worker-program) and operating Worker Processes.\nSaid another way, the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) (including the Temporal Cloud) doesn't execute any of your code (Workflow and Activity Definitions) on Temporal Cluster machines. The Cluster is solely responsible for orchestrating state transitions and providing Tasks to the next available Worker Entity.\n\nWhile data transferred in Event Histories is [secured by mTLS](/security/#encryption-of-network-traffic), by default, it is still readable at rest in the Temporal Cluster.\n\nTo solve this, Temporal SDKs offer a [Data Converter API](/concepts/what-is-a-data-converter) that you can use to customize the serialization of data going out of and coming back in to a Worker Entity, with the net effect of guaranteeing that the Temporal Cluster cannot read sensitive business data.\n\nIn many of our tutorials, we show you how to run both a Temporal Cluster and one Worker on the same machine for local development.\nHowever, a production-grade Temporal Application typically has a _fleet_ of Worker Processes, all running on hosts external to the Temporal Cluster.\nA Temporal Application can have as many Worker Processes as needed.\n\nA Worker Process can be both a Workflow Worker Process and an Activity Worker Process.\nMany SDKs support the ability to have multiple Worker Entities in a single Worker Process.\n(Worker entity creation and management differ between SDKs.)\nA single Worker Entity can listen to only a single Task Queue.\nBut if a Worker Process has multiple Worker Entities, the Worker Process could be listening to multiple Task Queues.\n\n![Entity relationship diagram (meta model) of Worker Processes, Task Queues, and Tasks](/diagrams/worker-and-server-entity-relationship.svg)\n\nWorker Processes executing Activity Tasks must have access to any resources needed to execute the actions that are defined in Activity Definitions, such as the following:\n\n- Network access for external API calls.\n- Credentials for infrastructure provisioning.\n- Specialized GPUs for machine learning utilities.\n\nThe Temporal Cluster itself has [internal workers](https://temporal.io/blog/workflow-engine-principles/#system-workflows-1910) for system Workflow Executions.\nHowever, these internal workers are not visible to the developer.\n","is_empty":false},{"file_name":"what-is-a-worker-program.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-worker-program.md","id":"concepts/what-is-a-worker-program","title":"What is a Worker Program?","description":"A Worker Program is the static code that defines the constraints of the Worker Process, developed using the APIs of a Temporal SDK.","label":"Worker Program","tags":["term","explanation"],"markdown_content":"\nA Worker Program is the static code that defines the constraints of the Worker Process, developed using the APIs of a Temporal SDK.\n\n**Implementation guide:**\n\n- [How to develop a Worker Program](/application-development/foundations#run-worker-processes)\n","is_empty":false},{"file_name":"what-is-a-worker-service.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-worker-service.md","id":"concepts/what-is-a-worker-service","title":"What is a Worker Service?","description":"The Worker Service runs background processing for the replication queue, system Workflows, and (in versions older than 1.5.0) the Kafka visibility processor.","label":"Worker Service","tags":["term"],"markdown_content":"\nThe Worker Service runs background processing for the replication queue, system Workflows, and (in versions older than 1.5.0) the Kafka visibility processor.\n\n![Worker Service](/diagrams/temporal-worker-service.svg)\n\nIt talks to the Frontend Service.\n\n- It uses port 6939 for membership-related communication.\n\nPorts are configurable in the Cluster configuration.\n","is_empty":false},{"file_name":"what-is-a-worker.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-worker.md","id":"concepts/what-is-a-worker","title":"What is a Worker?","description":"In day-to-day conversations, the term Worker is used to denote both a Worker Program and a Worker Process. Temporal documentation aims to be explicit and differentiate between them.","label":"Worker","tags":["term","explanation"],"markdown_content":"\nIn day-to-day conversations, the term Worker is used to denote either a [Worker Program](/concepts/what-is-a-worker-program), a [Worker Process](/concepts/what-is-a-worker-process), or a [Worker Entity](/concepts/what-is-a-worker-entity).\nTemporal documentation aims to be explicit and differentiate between them.\n","is_empty":false},{"file_name":"what-is-a-workflow-definition.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-definition.md","id":"concepts/what-is-a-workflow-definition","title":"What is a Workflow Definition?","description":"A Workflow Definition is the code that defines the constraints of a Workflow Execution.","label":"Workflow Definition","tags":["term","explanation"],"markdown_content":"\nA Workflow Definition is the code that defines the constraints of a Workflow Execution.\n\n- [How to develop a Workflow Definition](/application-development/foundations#develop-workflows)\n\nA Workflow Definition is often also referred to as a Workflow Function.\nIn Temporal's documentation, a Workflow Definition refers to the source for the instance of a Workflow Execution, while a Workflow Function refers to the source for the instance of a Workflow Function Execution.\n\nA Workflow Execution effectively executes once to completion, while a Workflow Function Execution occurs many times during the life of a Workflow Execution.\n\nWe strongly recommend that you write a Workflow Definition in a language that has a corresponding Temporal SDK.\n\n### Deterministic constraints\n\nA critical aspect of developing Workflow Definitions is ensuring they exhibit certain deterministic traits – that is, making sure that the same Commands are emitted in the same sequence, whenever a corresponding Workflow Function Execution (instance of the Function Definition) is re-executed.\n\nThe execution semantics of a Workflow Execution include the re-execution of a Workflow Function.\nThe use of Workflow APIs in the function is what generates [Commands](/concepts/what-is-a-command).\nCommands tell the Cluster which Events to create and add to the Workflow Execution's Event History.\nWhen a Workflow Function executes, the Commands that are emitted are compared with the existing Event History.\nIf a corresponding Event already exists within the Event History that maps to the generation of that Command in the same sequence, and some specific metadata of that Command matches with some specific metadata of the Event, then the Function Execution progresses.\n\nFor example, using an SDK's \"Execute Activity\" API generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nWhen this API is called upon re-execution, that Command is compared with the Event that is in the same location within the sequence.\nThe Event in the sequence must be an [ActivityTaskScheduled](/references/events/#activitytaskscheduled) Event, where the Activity name is the same as what is in the Command.\n\nIf a generated Command doesn't match what it needs to in the existing Event History, then the Workflow Execution returns a _non-deterministic_ error.\n\nThe following are the two reasons why a Command might be generated out of sequence or the wrong Command might be generated altogether:\n\n1. Code changes are made to a Workflow Definition that is in use by a running Workflow Execution.\n2. There is intrinsic non-deterministic logic (such as inline random branching).\n\n### Code changes can cause non-deterministic behavior\n\nThe Workflow Definition can change in very limited ways once there is a Workflow Execution depending on it.\nTo alleviate non-deterministic issues that arise from code changes, we recommend using [Workflow Versioning](#workflow-versioning).\n\nFor example, let's say we have a Workflow Definition that defines the following sequence:\n\n1. Start and wait on a Timer/sleep.\n2. Spawn and wait on an Activity Execution.\n3. Complete.\n\nWe start a Worker and spawn a Workflow Execution that uses that Workflow Definition.\nThe Worker would emit the [StartTimer](/references/commands/#starttimer) Command and the Workflow Execution would become suspended.\n\nBefore the Timer is up, we change the Workflow Definition to the following sequence:\n\n1. Spawn and wait on an Activity Execution.\n2. Start and wait on a Timer/sleep.\n3. Complete.\n\nWhen the Timer fires, the next Workflow Task will cause the Workflow Function to re-execute.\nThe first Command the Worker sees would be ScheduleActivityTask Command, which wouldn't match up to the expected [TimerStarted](/references/events/#timerstarted) Event.\n\nThe Workflow Execution would fail and return a non-deterministic error.\n\nThe following are examples of minor changes that would not result in non-determinism errors when re-executing a History which already contain the Events:\n\n- Changing the duration of a Timer.\n- Changing the arguments to:\n  - The Activity Options in a call to spawn an Activity Execution (local or nonlocal).\n  - The Child Workflow Options in a call to spawn a Child Workflow Execution.\n  - Call to Signal an External Workflow Execution.\n\n### Intrinsic non-deterministic logic\n\nIntrinsic non-determinism is when a Workflow Function Execution might emit a different sequence of Commands on re-execution, regardless of whether all the input parameters are the same.\n\nFor example, a Workflow Definition can not have inline logic that branches (emits a different Command sequence) based off a local time setting or a random number.\nIn the representative pseudocode below, the `local_clock()` function returns the local time, rather than Temporal-defined time:\n\n```text\nfn your_workflow() {\n  if local_clock().is_before(\"12pm\") {\n    await workflow.sleep(duration_until(\"12pm\"))\n  } else {\n    await your_afternoon_activity()\n  }\n}\n```\n\nEach Temporal SDK offers APIs that enable Workflow Definitions to have logic that gets and uses time, random numbers, and data from unreliable resources.\nWhen those APIs are used, the results are stored as part of the Event History, which means that a re-executed Workflow Function will issue the same sequence of Commands, even if there is branching involved.\n\nIn other words, all operations that do not purely mutate the Workflow Execution's state should occur through a Temporal SDK API.\n\n### Workflow Versioning\n\nThe Workflow Versioning feature enables the creation of logical branching inside a Workflow Definition based on a developer specified version identifier.\nThis feature is useful for Workflow Definition logic needs to be updated, but there are running Workflow Executions that currently depends on it.\nIt is important to note that a practical way to handle different versions of Workflow Definitions, without using the versioning API, is to run the different versions on separate Task Queues.\n\n- [How to version Workflow Definitions in Go](/go/versioning)\n- [How to version Workflow Definitions in Java](/java/versioning)\n- [How to version Workflow Definitions in TypeScript](/typescript/patching)\n\n### Handling unreliable Worker Processes\n\nYou do not handle Worker Process failure or restarts in a Workflow Definition.\n\nWorkflow Function Executions are completely oblivious to the Worker Process in terms of failures or downtime.\nThe Temporal Platform ensures that the state of a Workflow Execution is recovered and progress resumes if there is an outage of either Worker Processes or the Temporal Cluster itself.\nThe only reason a Workflow Execution might fail is due to the code throwing an error or exception, not because of underlying infrastructure outages.\n","is_empty":false},{"file_name":"what-is-a-workflow-execution-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-execution-timeout.md","id":"concepts/what-is-a-workflow-execution-timeout","title":"What is a Workflow Execution Timeout?","description":"A Workflow Execution Timeout is the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["term","explanation","timeouts"],"markdown_content":"\nA Workflow Execution Timeout is the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n\n- [How to set a Workflow Execution Timeout](/go/how-to-set-a-workflow-execution-timeout-in-go)\n\n![Workflow Execution Timeout period](/diagrams/workflow-execution-timeout.svg)\n\n**The default value is ∞ (infinite).**\nIf this timeout is reached, the Workflow Execution changes to a Timed Out status.\nThis timeout is different from the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout).\nThis timeout is most commonly used for stopping the execution of a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) after a certain amount of time has passed.\n","is_empty":false},{"file_name":"what-is-a-workflow-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-execution.md","id":"concepts/what-is-a-workflow-execution","title":"What is a Workflow Execution?","description":"A Temporal Workflow Execution is a durable, scalable, reliable, and reactive function execution. It is the main unit of execution of a Temporal Application.","label":"Workflow Execution","tags":["term","explanation"],"markdown_content":"\nA Temporal Workflow Execution is a durable, reliable, and scalable function execution.\nIt is the main unit of execution of a [Temporal Application](/concepts/what-is-a-temporal-application).\n\n- [How to start a Workflow Execution using an SDK](/application-development/foundations#start-workflow-execution)\n- [How to start a Workflow Execution using tctl](/tctl-v1/workflow#start)\n\nEach Temporal Workflow Execution has exclusive access to its local state.\nIt executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions through [Signals](/concepts/what-is-a-signal) and the environment through [Activities](/concepts/what-is-an-activity).\nWhile a single Workflow Execution has limits on size and throughput, a Temporal Application can consist of millions to billions of Workflow Executions.\n\n**Durability**\n\nDurability is the absence of an imposed time limit.\n\nA Workflow Execution is durable because it executes a Temporal Workflow Definition (also called a Temporal Workflow Function), your application code, effectively once and to completion—whether your code executes for seconds or years.\n\n**Reliability**\n\nReliability is responsiveness in the presence of failure.\n\nA Workflow Execution is reliable, because it is fully recoverable after a failure.\nThe Temporal Platform ensures the state of the Workflow Execution persists in the face of failures and outages and resumes execution from the latest state.\n\n**Scalability**\n\nScalability is responsiveness in the presence of load.\n\nA single Workflow Execution is limited in size and throughput but is scalable because it can [Continue-As-New](/concepts/what-is-continue-as-new) in response to load.\nA Temporal Application is scalable because the Temporal Platform is capable of supporting millions to billions of Workflow Executions executing concurrently, which is realized by the design and nature of the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) and [Worker Processes](/concepts/what-is-a-worker-process).\n\n### Commands and awaitables\n\nA Workflow Execution does two things:\n\n1. Issue [Commands](/concepts/what-is-a-command).\n2. Wait on an Awaitables (often called Futures).\n\n![Command generation and waiting](/diagrams/workflow-execution-progession-simple.svg)\n\nCommands are issued and Awaitables are provided by the use of Workflow APIs in the [Workflow Definition](/concepts/what-is-a-workflow-definition).\n\nCommands are generated whenever the Workflow Function is executed.\nThe Worker Process supervises the Command generation and makes sure that it maps to the current Event History.\n(For more information, see [Deterministic constraints](/concepts/what-is-a-workflow-definition/#deterministic-constraints).)\nThe Worker Process batches the Commands and then suspends progress to send the Commands to the Cluster whenever the Workflow Function reaches a place where it can no longer progress without a result from an Awaitable.\n\nA Workflow Execution may only ever block progress on an Awaitable that is provided through a Temporal SDK API.\nAwaitables are provided when using APIs for the following:\n\n- Awaiting: Progress can block using explicit \"Await\" APIs.\n- Requesting cancellation of another Workflow Execution: Progress can block on confirmation that the other Workflow Execution is cancelled.\n- Sending a [Signal](/concepts/what-is-a-signal): Progress can block on confirmation that the Signal sent.\n- Spawning a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution): Progress can block on confirmation that the Child Workflow Execution started, and on the result of the Child Workflow Execution.\n- Spawning an [Activity Execution](/concepts/what-is-an-activity-execution): Progress can block on the result of the Activity Execution.\n- Starting a Timer: Progress can block until the Timer fires.\n\n### Status\n\nA Workflow Execution can be either Open or Closed.\n\n![Workflow Execution statuses](/diagrams/workflow-execution-statuses.svg)\n\n**Open**\n\n- Running: The only Open status for a Workflow Execution.\n  When the Workflow Execution is Running, it is either actively progressing or is waiting on something.\n\n**Closed**\n\nA Closed status means that the Workflow Execution cannot make further progress because of one of the following reasons:\n\n- Cancelled: The Workflow Execution successfully handled a cancellation request.\n- Completed: The Workflow Execution has completed successfully.\n- Continued-As-New: The Workflow Execution [Continued-As-New](/concepts/what-is-continue-as-new).\n- Failed: The Workflow Execution returned an error and failed.\n- Terminated: The Workflow Execution was terminated.\n- Timed Out: The Workflow Execution reached a timeout limit.\n\n### Workflow Execution Chain\n\nA Workflow Execution Chain is a sequence of Workflow Executions that share the same Workflow Id.\nEach link in the Chain is often called a Workflow Run.\nEach Workflow Run in the sequence is connected by one of the following:\n\n- [Continue-As-New](/concepts/what-is-continue-as-new)\n- [Retries](/concepts/what-is-a-retry-policy)\n- [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job)\n\nA Workflow Execution is uniquely identified by its [Namespace](/concepts/what-is-a-namespace), [Workflow Id](/concepts/what-is-a-workflow-id), and [Run Id](/concepts/what-is-a-run-id).\n\nThe [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) applies to a Workflow Execution Chain.\nThe [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) applies to a single Workflow Execution (Workflow Run).\n\n### Event loop\n\nA Workflow Execution is made up of a sequence of [Events](/concepts/what-is-an-event) called an [Event History](/concepts/what-is-an-event-history).\nEvents are created by the Temporal Cluster in response to either Commands or actions requested by a Temporal Client (such as a request to spawn a Workflow Execution).\n\n![Workflow Execution](/diagrams/workflow-execution-swim-lane-01.svg)\n\n### Time constraints\n\n**Is there a limit to how long Workflows can run?**\n\nNo, there is no time constraint on how long a Workflow Execution can be Running.\n\nHowever, Workflow Executions intended to run indefinitely should be written with some care.\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\nThere is a hard limit of 50,000 Events in a Workflow Execution Event History, as well as a hard limit of 50 MB in terms of size.\nThe Temporal Cluster logs a warning at every 10,000 Events.\nWhen the Event History reaches 50,000 Events or the size limit of 50 MB, the Workflow Execution is forcefully terminated.\n\nTo prevent _runaway_ Workflow Executions, you can use the Workflow Execution Timeout, the Workflow Run Timeout, or both.\nA Workflow Execution Timeout can be used to limit the duration of Workflow Execution Chain, and a Workflow Run Timeout can be used to limit the duration an individual Workflow Execution (Run).\n\nYou can use the [Continue-As-New](/concepts/what-is-continue-as-new) feature to close the current Workflow Execution and create a new Workflow Execution in a single atomic operation.\nThe Workflow Execution spawned from Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\nFor example, it may be reasonable to use Continue-As-New once per day for a long-running Workflow Execution that is generating a large Event History.\n","is_empty":false},{"file_name":"what-is-a-workflow-id-reuse-policy.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-id-reuse-policy.md","id":"concepts/what-is-a-workflow-id-reuse-policy","title":"What is a Workflow Id Reuse Policy?","description":"A Workflow Id Reuse Policy determines whether a Workflow Execution is allowed to spawn with a particular Workflow Id, if that Workflow Id has been used with a previous, and now Closed, Workflow Execution.","label":"Workflow Id Reuse Policy","tags":["term","explanation"],"markdown_content":"\nA Workflow Id Reuse Policy determines whether a Workflow Execution is allowed to spawn with a particular Workflow Id, if that Workflow Id has been used with a previous, and now Closed, Workflow Execution.\n\nIt is not possible for a new Workflow Execution to spawn with the same Workflow Id as another Open Workflow Execution.\nAn attempt to spawn a Workflow Execution with a Workflow Id that is the same as the Id of a currently Open Workflow Execution results in a `Workflow Execution already started` error.\n\nA Workflow Id Reuse Policy has three possible values:\n\n- **Allow Duplicate** The Workflow Execution is allowed to exist regardless of the Closed status of a previous Workflow Execution with the same Workflow Id.\n  **This is the default policy, if one is not specified.**\n  Use this when it is OK to have a Workflow Execution with the same Workflow Id as a previous, but now Closed, Workflow Execution.\n- **Allow Duplicate Failed Only**: The Workflow Execution is allowed to exist only if a previous Workflow Execution with the same Workflow Id does not have a Completed status.\n  Use this policy when there is a need to re-execute a Failed, Timed Out, Terminated or Cancelled Workflow Execution and guarantee that the Completed Workflow Execution will not be re-executed.\n- **Reject Duplicate**: The Workflow Execution cannot exist if a previous Workflow Execution has the same Workflow Id, regardless of the Closed status.\n  Use this when there can only be one Workflow Execution per Workflow Id within a Namespace for the given retention period.\n\nA Workflow Id Reuse Policy applies only if a Closed Workflow Execution with the same Workflow Id exists within the Retention Period of the associated Namespace.\nFor example, if the Namespace's retention period is 30 days, a Workflow Id Reuse Policy can only compare the Workflow Id of the spawning Workflow Execution against the Closed Workflow Executions for the last 30 days.\n\nIf there is an attempt to spawn a Workflow Execution with a Workflow Id Reuse Policy that won't allow it the Server will prevent the Workflow Execution from spawning.\n","is_empty":false},{"file_name":"what-is-a-workflow-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-id.md","id":"concepts/what-is-a-workflow-id","title":"What is a Workflow Id?","description":"A Workflow Id is a customizable, application-level identifier for a Workflow Execution that is unique to an Open Workflow Execution within a Namespace.","label":"Workflow Id","tags":["term","explanation"],"markdown_content":"\nA Workflow Id is a customizable, application-level identifier for a [Workflow Execution](/concepts/what-is-a-workflow-execution) that is unique to an Open Workflow Execution within a [Namespace](/namespaces).\n\n- [How to set a Workflow Id](/go/how-to-set-a-workflow-id-in-go)\n\nA Workflow Id is meant to be a business-process identifier such as customer identifier or order identifier.\n\nA [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy) can be used to manage whether a Workflow Id can be re-used.\nThe Temporal Platform guarantees uniqueness of the Workflow Id within a [Namespace](/concepts/what-is-a-namespace) based on the Workflow Id Reuse Policy.\n\nIt is not possible for a new Workflow Execution to spawn with the same Workflow Id as another Open Workflow Execution, regardless of the Workflow Id Reuse Policy.\nAn attempt to spawn a Workflow Execution with a Workflow Id that is the same as the Id of a currently Open Workflow Execution results in a `Workflow execution already started` error.\n\nA Workflow Execution can be uniquely identified across all Namespaces by its [Namespace](/concepts/what-is-a-namespace), Workflow Id, and [Run Id](/concepts/what-is-a-run-id).\n","is_empty":false},{"file_name":"what-is-a-workflow-run-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-run-timeout.md","id":"concepts/what-is-a-workflow-run-timeout","title":"What is a Workflow Run Timeout?","description":"This is the maximum amount of time that a single Workflow Run is restricted to.","label":"Workflow Run Timeout","tags":["term","explanation","timeouts"],"markdown_content":"\nA Workflow Run Timeout is the maximum amount of time that a single Workflow Run is restricted to.\n\n- [How to set a Workflow Run Timeout](/go/startworkflowoptions-reference/#workflowruntimeout)\n\n![Workflow Run Timeout period](/diagrams/workflow-run-timeout.svg)\n\n**The default is set to the same value as the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout).**\nThis timeout is most commonly used to limit the execution time of a single [Temporal Cron Job Execution](/concepts/what-is-a-temporal-cron-job).\n\nIf the Workflow Run Timeout is reached, the Workflow Execution is Terminated.\n","is_empty":false},{"file_name":"what-is-a-workflow-task-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-task-execution.md","id":"concepts/what-is-a-workflow-task-execution","title":"What is a Workflow Task Execution?","description":"A Workflow Task Execution is when a Worker picks up a Workflow Task and uses it to make progress on the execution of a Workflow function.","label":"Workflow Task Execution","tags":["term","explanation"],"markdown_content":"\nA Workflow Task Execution is when a Worker picks up a Workflow Task and uses it to make progress on the execution of a Workflow function.\n","is_empty":false},{"file_name":"what-is-a-workflow-task-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-task-timeout.md","id":"concepts/what-is-a-workflow-task-timeout","title":"What is a Workflow Task Timeout?","description":"A Workflow Task Timeout is the maximum amount of time that the Temporal Server will wait for a Worker to start processing a Workflow Task after the Task has been pulled from the Task Queue.","label":"Workflow Task Timeout","tags":["term","explanation","timeouts"],"markdown_content":"\nA Workflow Task Timeout is the maximum amount of time allowed for a [Worker](/concepts/what-is-a-worker) to execute a [Workflow Task](/concepts/what-is-a-workflow-task) after the Worker has pulled that Workflow Task from the [Task Queue](/concepts/what-is-a-task-queue).\n\n![Workflow Task Timeout period](/diagrams/workflow-task-timeout.svg)\n\n**The default value is 10 seconds.**\nThis timeout is primarily available to recognize whether a Worker has gone down so that the Workflow Execution can be recovered on a different Worker.\nThe main reason for increasing the default value would be to accommodate a Workflow Execution that has a very long Workflow Execution History that could take longer than 10 seconds for the Worker to load.\n\n**Implementation guides:**\n\n- [How to set a Workflow Task Timeout](/go/startworkflowoptions-reference/#workflowtasktimeout)\n","is_empty":false},{"file_name":"what-is-a-workflow-task.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-task.md","id":"concepts/what-is-a-workflow-task","title":"What is a Workflow Task?","description":"A Workflow Task is a Task that contains the context needed to make progress with a Workflow Execution.","label":"Workflow Task","tags":["term","explanation"],"markdown_content":"\nA Workflow Task is a Task that contains the context needed to make progress with a Workflow Execution.\n\n- Every time a new external event that might affect a Workflow state is recorded, a Workflow Task that contains the event is added to a Task Queue and then picked up by a Workflow Worker.\n- After the new event is handled, the Workflow Task is completed with a list of [Commands](/concepts/what-is-a-command).\n- Handling of a Workflow Task is usually very fast and is not related to the duration of operations that the Workflow invokes.\n","is_empty":false},{"file_name":"what-is-a-workflow-type.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow-type.md","id":"concepts/what-is-a-workflow-type","title":"What is a Workflow Type?","description":"A Workflow Type is a name that maps to a Workflow Definition.","label":"Workflow Type","tags":["term","explanation"],"markdown_content":"\nA Workflow Type is a name that maps to a Workflow Definition.\n\n- A single Workflow Type can be instantiated as multiple Workflow Executions.\n- A Workflow Type is scoped by a Task Queue.\n  It is acceptable to have the same Workflow Type name map to different Workflow Definitions if they are using completely different Workers.\n\n![Workflow Type cardinality with Workflow Definitions and Workflow Executions](/diagrams/workflow-type-cardinality.svg)\n","is_empty":false},{"file_name":"what-is-a-workflow.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-a-workflow.md","id":"concepts/what-is-a-workflow","title":"What is a Workflow?","description":"In day-to-day conversations, the term \"Workflow\" frequently denotes either a Workflow Type, a Workflow Definition, or a Workflow Execution.","label":"Workflow","tags":["term","explanation"],"markdown_content":"\nIn day-to-day conversations, the term _Workflow_ frequently denotes either a [Workflow Type](/concepts/what-is-a-workflow-type), a [Workflow Definition](/concepts/what-is-a-workflow-definition), or a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nTemporal documentation aims to be explicit and differentiate between them.\n","is_empty":false},{"file_name":"what-is-advanced-visibility.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-advanced-visibility.md","id":"concepts/what-is-advanced-visibility","title":"What is Advanced Visibility?","description":"Advanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through an SQL-like query syntax.","label":"Advanced Visibility","tags":["term","explanation","filtered-lists","visibility"],"markdown_content":"\nAdvanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through a custom SQL-like [List Filter](/concepts/what-is-a-list-filter).\n\nTo use Advanced Visibility, your Temporal Cluster must be [integrated with Elasticsearch](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster).\nWe highly recommend operating a Temporal Cluster with Elasticsearch for any use case that spawns more than just a few Workflow Executions.\nElasticsearch takes on the Visibility request load, relieving potential performance issues.\n","is_empty":false},{"file_name":"what-is-an-activity-definition.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-activity-definition.md","id":"concepts/what-is-an-activity-definition","title":"What is an Activity Definition?","description":"An Activity Definition is the code that defines the constraints of an Activity Task Execution.","label":"Activity Definition","tags":["term","explanation"],"markdown_content":"\nAn Activity Definition is the code that defines the constraints of an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n\n- [How to develop an Activity Definition](/application-development/foundations#develop-activities)\n\nThe term 'Activity Definition' is used to refer to the full set of primitives in any given language SDK that provides an access point to an Activity Function Definition——the method or function that is invoked for an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\nTherefore, the terms Activity Function and Activity Method refer to the source of an instance of an execution.\n\nActivity Definitions are named and referenced in code by their [Activity Type](/concepts/what-is-an-activity-type).\n\n![Activity Definition](/diagrams/activity-definition.svg)\n\n#### Constraints\n\nActivity Definitions are executed as normal functions.\n\nIn the event of failure, the function begins at its initial state when retried (except when Activity Heartbeats are established).\n\nTherefore, an Activity Definition has no restrictions on the code it contains.\n\n#### Parameters\n\nAn Activity Definition can support as many parameters as needed.\n\nAll values passed through these parameters are recorded in the [Event History](/concepts/what-is-an-event-history) of the Workflow Execution.\nReturn values are also captured in the Event History for the calling Workflow Execution.\n\nActivity Definitions must contain the following parameters:\n\n- Context: an optional parameter that provides Activity context within multiple APIs.\n- Heartbeat: a notification from the Worker to the Temporal Cluster that the Activity Execution is progressing. Cancelations are allowed only if the Activity Definition permits Heartbeating.\n- Timeouts: intervals that control the execution and retrying of Activity Task Executions.\n\nOther parameters, such as [Retry Policies](/concepts/what-is-a-retry-policy) and return values, can be seen in the implementation guides, listed in the next section.\n","is_empty":false},{"file_name":"what-is-an-activity-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-activity-execution.md","id":"concepts/what-is-an-activity-execution","title":"What is an Activity Execution?","description":"An Activity Execution is the full chain of Activity Task Executions.","label":"Activity Execution","tags":["term","explanation"],"markdown_content":"\nAn Activity Execution is the full chain of [Activity Task Executions](/concepts/what-is-an-activity-task-execution).\n\n- [How to spawn an Activity Execution](/application-development/foundations#activity-execution)\n\n![Activity Execution](/diagrams/activity-execution.svg)\n\nAn Activity Execution has no time limit.\nActivity Execution time limits and retries can be optimized for each situation within the Temporal Application.\n\nIf for any reason an Activity Execution does not complete (exhausts all retries), the error is returned to the [Workflow](/workflows), which decides how to handle it.\n\n### Request Cancellation\n\nA Workflow can request to cancel an Activity Execution.\nWhen an Activity Execution is canceled, or its Workflow Execution has completed or failed, the context passed into its function is canceled, which also sets its channel’s closed state to `Done`.\nAn Activity can use that to perform any necessary cleanup and abort its execution.\n\nCancellation requests are only delivered to Activity Executions that Heartbeat:\n\n- The Heartbeat request fails with a special error indicating that the Activity Execution is canceled.\n  Heartbeats can also fail when the Workflow Execution that spawned it is in a completed state.\n- The Activity should perform all necessary cleanup and report when it is done.\n- The Workflow can decide if it wants to wait for the Activity cancellation confirmation or proceed without waiting.\n","is_empty":false},{"file_name":"what-is-an-activity-heartbeat.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-activity-heartbeat.md","id":"concepts/what-is-an-activity-heartbeat","title":"What is an Activity Heartbeat?","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster. Each ping informs the Temporal Cluster that the Activity Execution is making progress and the Worker has not crashed.","label":"Activity Heartbeat","tags":["term","explanation"],"markdown_content":"\nAn Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.\nEach ping informs the Temporal Cluster that the Activity Execution is making progress and the Worker has not crashed.\n\n- [How to Heartbeat an Activity](/application-development/features#activity-heartbeats)\n\nActivity Heartbeats work in conjunction with a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout).\n\nActivity Heartbeats are implemented within the Activity Definition.\nCustom progress information can be included in the Heartbeat which can then be used by the Activity Execution should a retry occur.\n\nAn Activity Heartbeat can be recorded as often as needed (e.g. once a minute or every loop iteration).\nIt is often a good practice to Heartbeat on anything but the shortest Activity Function Execution.\nTemporal SDKs control the rate at which Heartbeats are sent to the Cluster.\n\nHeartbeating is not required from [Local Activities](/concepts/what-is-a-local-activity), and does nothing.\n\nFor _long-running_ Activities, we recommend using a relatively short Heartbeat Timeout and a frequent Heartbeat.\nThat way if a Worker fails it can be handled in a timely manner.\n\nA Heartbeat can include an application layer payload that can be used to _save_ Activity Execution progress.\nIf an [Activity Task Execution](/concepts/what-is-an-activity-task-execution) times out due to a missed Heartbeat, the next Activity Task can access and continue with that payload.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\n#### Throttling\n\nHeartbeats may not always be sent to the Cluster—they may be throttled by the Worker.\nThe throttle interval is the smaller of the following:\n\n- If `heartbeatTimeout` is provided, `heartbeatTimeout * 0.8`; otherwise, `defaultHeartbeatThrottleInterval`\n- `maxHeartbeatThrottleInterval`\n\n`defaultHeartbeatThrottleInterval` is 30 seconds by default, and `maxHeartbeatThrottleInterval` is 60 seconds by default.\nEach can be set in Worker options.\n\nThrottling is implemented as follows:\n\n- After sending a Heartbeat, the Worker sets a timer for the throttle interval.\n- The Worker stops sending Heartbeats, but continues receiving Heartbeats from the Activity and remembers the most recent one.\n- When the timer fires, the Worker:\n  - Sends the most recent Heartbeat.\n  - Sets the timer again.\n\n#### Which Activities should Heartbeat?\n\nHeartbeating is best thought about not in terms of time, but in terms of \"How do you know you are making progress?\"\nFor short-term operations, progress updates are not a requirement.\nHowever, checking the progress and status of Activity Executions that run over long periods is almost always useful.\n\nConsider the following when setting Activity Hearbeats:\n\n- Your underlying task must be able to report definite progress.\n  Note that your Workflow cannot read this progress information while the Activity is still executing (or it would have to store it in Event History).\n  You can report progress to external sources if you need it exposed to the user.\n\n- Your Activity Execution is long-running, and you need to verify whether the Worker that is processing your Activity is still alive and has not run out of memory or silently crashed.\n\nFor example, the following scenarios are suitable for Heartbeating:\n\n- Reading a large file from Amazon S3.\n- Running a ML training job on some local GPUs.\n\nAnd the following scenarios are not suitable for Heartbeating:\n\n- Making a quick API call.\n- Reading a small file from disk.\n","is_empty":false},{"file_name":"what-is-an-activity-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-activity-id.md","id":"concepts/what-is-an-activity-id","title":"What is an Activity Id?","description":"A unique identifier for an Activity Execution.","label":"Activity Id","tags":["term","explanation"],"markdown_content":"\nThe identifier for an [Activity Execution](/concepts/what-is-an-activity-execution).\nThe identifier can be generated by the system, or it can be provided by the Workflow code that spawns the Activity Execution.\nThe identifier is unique among the open Activity Executions of a [Workflow Run](/concepts/what-is-a-run-id/).\n(A single Workflow Run may reuse an Activity Id if an earlier Activity Execution with the same Id has closed.)\n\nAn Activity Id can be used to [complete the Activity asynchronously](/concepts/what-is-asynchronous-activity-completion/).\n","is_empty":false},{"file_name":"what-is-an-activity-task-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-activity-task-execution.md","id":"concepts/what-is-an-activity-task-execution","title":"What is an Activity Task Execution?","description":"An Activity Task Execution is the execution of an Activity Type.","label":"Activity Task Execution","tags":["term","explanation"],"markdown_content":"\nAn Activity Task Execution is when the Worker uses the Context provided from the [Activity Task](/concepts/what-is-an-activity-task) and executes the [Activity Definition](/concepts/what-is-an-activity-definition) (also known as the Activity Function).\n\nThe [ActivityTaskScheduled Event](/references/events#activitytaskscheduled) corresponds to when the Temporal Cluster puts the Activity Task into the Task Queue.\n\nThe [ActivityTaskStarted Event](/references/events#activitytaskstarted) corresponds to when the Worker picks up the Activity Task from the Task Queue.\n\nEither [ActivityTaskCompleted](/references/events#activitytaskcompleted) or one of the other Closed Activity Task Events corresponds to when the Worker has yielded back to the Temporal Cluster.\n\nThe API to schedule an Activity Execution provides an \"effectively once\" experience, even though there may be several Activity Task Executions that take place to successfully complete an Activity.\n\nOnce an Activity Task finishes execution, the Worker responds to the Cluster with a specific Event:\n\n- ActivityTaskCanceled\n- ActivityTaskCompleted\n- ActivityTaskFailed\n- ActivityTaskTerminated\n- ActivityTaskTimedOut\n","is_empty":false},{"file_name":"what-is-an-activity-task.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-activity-task.md","id":"concepts/what-is-an-activity-task","title":"What is an Activity Task?","description":"An Activity Task contains the context needed to make an Activity Task Execution.","label":"Activity Task","tags":["term","explanation"],"markdown_content":"\nAn Activity Task contains the context needed to proceed with an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\nActivity Tasks largely represent the Activity Task Scheduled Event, which contains the data needed to execute an Activity Function.\n\nIf Heartbeat data is being passed, an Activity Task will also contain the latest Heartbeat details.\n","is_empty":false},{"file_name":"what-is-an-activity-type.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-activity-type.md","id":"concepts/what-is-an-activity-type","title":"What is an Activity Type?","description":"An Activity Type is the mapping of a name to an Activity Definition.","label":"Activity Type","tags":["term","explanation"],"markdown_content":"\nAn Activity Type is the mapping of a name to an Activity Definition.\n\nActivity Types are scoped through Task Queues.\n","is_empty":false},{"file_name":"what-is-an-activity.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-activity.md","id":"concepts/what-is-an-activity","title":"What is an Activity?","description":"In day-to-day conversations, the term \"Activity\" frequently denotes either an Activity Type, an Activity Definition, or an Activity Execution.","label":"Activity","tags":["term","explanation"],"markdown_content":"\nIn day-to-day conversations, the term _Activity_ frequently denotes either an [Activity Definition](/concepts/what-is-an-activity-definition), an [Activity Type](/concepts/what-is-an-activity-type), or an [Activity Execution](/concepts/what-is-an-activity-execution).\nTemporal documentation aims to be explicit and differentiate between them.\n\nAn Activity is a normal function or object method that executes a single, well-defined action (either short or long running), such as calling another service, transcoding a media file, or sending an email message.\n\nWorkflow code orchestrates the execution of Activities, persisting the results.\nIf an Activity Function Execution fails, any future execution starts from initial state (except Heartbeats).\nTherefore, an Activity function is allowed to contain any code without restrictions.\n\nActivity Functions are executed by Worker Processes.\nWhen the Activity Function returns, the Worker sends the results back to the Temporal Cluster as part of the `ActivityTaskCompleted` Event.\nThe Event is added to the Workflow Execution's Event History.\n","is_empty":false},{"file_name":"what-is-an-authorizer-plugin.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-authorizer-plugin.md","id":"concepts/what-is-an-authorizer-plugin","title":"What is an Authorizer Plugin?","label":"Authorizer Plugin","tags":["term"],"markdown_content":"\nThe `Authorizer` plugin contains a single `Authorize` method, which is invoked for each incoming API call.\n`Authorize` receives information about the API call, along with the role and permission claims of the caller.\n\n`Authorizer` allows for a wide range of authorization logic, including call target, role/permissions claims, and other data available to the system.\n\n#### Configuration\n\nThe following arguments must be passed to `Authorizer`:\n\n- `context.Context`: General context of the call.\n- `authorization.Claims`: Claims about the roles assigned to the caller. Its intended use is described in the [`Claims`](#claims) section earlier on this page.\n- `authorization.CallTarget`: Target of the API call.\n\n`Authorizer` then returns one of two decisions:\n\n- `DecisionDeny`: the requested API call is not invoked and an error is returned to the caller.\n- `DecisionAllow`: the requested API call is invoked.\n\n:::warning\n\n`Authorizer` allows all API calls pass by default. Disable the `nopAuthority` authorizer and configure your own to prevent this behavior.\n\n:::\n\nConfigure your `Authorizer` when you start the server via the [`temporal.WithAuthorizer`](/references/server-options#withauthorizer) server option.\n\nIf an `Authorizer` is not set in the server options, Temporal uses the `nopAuthority` authorizer that unconditionally allows all API calls to pass through.\n\n```go\na := authorization.NewDefaultAuthorizer()\n```\n","is_empty":false},{"file_name":"what-is-an-event-history.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-event-history.md","id":"concepts/what-is-an-event-history","title":"What is an Event History?","description":"An append log of Events that represents the full state a Workflow Execution.","label":"Event History","tags":["term","explanation"],"markdown_content":"\nAn append-log of [Events](/concepts/what-is-an-event) for your application.\n\n- Event History is durably persisted by the Temporal service, enabling seamless recovery of your application state from crashes or failures.\n- It also serves as an audit log for debugging.\n\n**Event History limits**\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\nThere is a hard limit of 50,000 Events in a Workflow Execution Event History, as well as a hard limit of 50 MB in terms of size.\nThe Temporal Cluster logs a warning at every 10,000 Events.\nWhen the Event History reaches 50,000 Events or the size limit of 50 MB, the Workflow Execution is forcefully terminated.\n","is_empty":false},{"file_name":"what-is-an-event.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-an-event.md","id":"concepts/what-is-an-event","title":"What is an Event?","description":"Events are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution.","label":"Event","tags":["term","explanation"],"markdown_content":"\nEvents are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution. Each Event corresponds to an `enum` that is defined in the [Server API](https://github.com/temporalio/api/blob/master/temporal/api/enums/v1/event_type.proto).\n\nAll Events are recorded in the [Event History](/concepts/what-is-an-event-history).\n\nA list of all possible Events that could appear in a Workflow Execution Event History is provided in the [Event reference](/references/events).\n","is_empty":false},{"file_name":"what-is-archival.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-archival.md","id":"concepts/what-is-archival","title":"What is Archival?","description":"Archival is a feature that automatically backs up Event Histories from Temporal Cluster persistence to a custom blob store after the Closed Workflow Execution retention period is reached.","label":"Archival","tags":["term","explanation"],"markdown_content":"\nArchival is a feature that automatically backs up [Event Histories](/concepts/what-is-an-event-history) and Visibility records from Temporal Cluster persistence to a custom blob store.\n\n- [How to create a custom Archiver](/clusters/how-to-create-a-custom-archiver)\n- [How to set up Archival](/clusters/how-to-set-up-archival)\n\nWorkflow Execution Event Histories are backed up after the [Retention Period](/concepts/what-is-a-namespace/#retention-period) is reached.\nVisibility records are backed up immediately after a Workflow Execution reaches a Closed status.\n\nArchival enables Workflow Execution data to persist as long as needed, while not overwhelming the Cluster's persistence store.\n\nThis feature is helpful for compliance and debugging.\n\nTemporal's Archival feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nArchival is not supported when running Temporal through Docker and is disabled by default when installing the system manually and when deploying through [helm charts](https://github.com/temporalio/helm-charts/blob/master/templates/server-configmap.yaml) (but can be enabled in the [config](https://github.com/temporalio/temporal/blob/master/config/development.yaml)).\n","is_empty":false},{"file_name":"what-is-asynchronous-activity-completion.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-asynchronous-activity-completion.md","id":"concepts/what-is-asynchronous-activity-completion","title":"What is Asynchronous Activity Completion?","description":"Asynchronous Activity Completion occurs when an external system provides the final result of a computation, started by an Activity, to the Temporal System.","label":"Asynchronous Activity Completion","tags":["term","explanation"],"markdown_content":"\nAsynchronous Activity Completion is a feature that enables an Activity Function to return without causing the Activity Execution to complete.\nThe Temporal Client can then be used to both Heartbeat Activity Execution progress and eventually provide a result.\n\n- [How to complete an Activity Asynchronously](/application-development/features#asynchronous-activity-completion)\n\n#### When to use Async Completion\n\nThe intended use-case for this feature is when an external system has the final result of a computation, started by an Activity.\n\nConsider using Asynchronous Activities instead of Signals if the external process is unreliable and might fail to send critical status updates through a Signal.\n\nConsider using [Signals](/concepts/what-is-a-signal) as an alternative to Asynchronous Activities to return data back to a Workflow Execution if there is a human in the process loop.\nThe reason is that a human in the loop means multiple steps in the process.\nThe first is the Activity Function that stores state in an external system and at least one other step where a human would “complete” the activity.\nIf the first step fails, you want to detect that quickly and retry instead of waiting for the entire process, which could be significantly longer when humans are involved.\n","is_empty":false},{"file_name":"what-is-continue-as-new.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-continue-as-new.md","id":"concepts/what-is-continue-as-new","title":"What is Continue-As-New?","description":"Continue-As-New is the mechanism by which all relevant state is passed to a new Workflow Execution with a fresh Event History.","label":"Continue-As-New","tags":["term","explanation","continue-as-new"],"markdown_content":"\nContinue-As-New is a mechanism by which the latest relevant state is passed to a new Workflow Execution, with a fresh Event History.\n\nAs a precautionary measure, the Temporal Platform limits the total [Event History](/concepts/what-is-an-event-history) to 50,000 Events or 50 MB, and will warn you every 10,000 Events or 10 MB.\nTo prevent a Workflow Execution Event History from exceeding this limit and failing, use Continue-As-New to start a new Workflow Execution with a fresh Event History.\n\nAll values passed to a Workflow Execution through parameters or returned through a result value are recorded into the Event History.\nA Temporal Cluster stores the full Event History of a Workflow Execution for the duration of a Namespace's retention period.\nA Workflow Execution that periodically executes many Activities has the potential of hitting the size limit.\n\nA very large Event History can adversely affect the performance of a Workflow Execution.\nFor example, in the case of a Workflow Worker failure, the full Event History must be pulled from the Temporal Cluster and given to another Worker via a Workflow Task.\nIf the Event history is very large, it may take some time to load it.\n\nThe Continue-As-New feature enables developers to complete the current Workflow Execution and start a new one atomically.\n\nThe new Workflow Execution has the same Workflow Id, but a different Run Id, and has its own Event History.\n\nIn the case of [Temporal Cron Jobs](/concepts/what-is-a-temporal-cron-job), Continue-As-New is actually used internally for the same effect.\n\n- [How to Continue-As-New](/application-development/features#continue-as-new)\n","is_empty":false},{"file_name":"what-is-multi-cluster-replication.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-multi-cluster-replication.md","id":"concepts/what-is-multi-cluster-replication","title":"What is Multi-Cluster Replication?","description":"Multi-Cluster Replication is a feature which asynchronously replicates Workflow Executions from active Clusters to other passive Clusters, for backup and state reconstruction.","label":"Multi-Cluster Replication","tags":["term","explanation"],"markdown_content":"\nMulti-Cluster Replication is a feature which asynchronously replicates Workflow Executions from active Clusters to other passive Clusters, for backup and state reconstruction.\nWhen necessary, for higher availability, Cluster operators can failover to any of the backup Clusters.\n\nTemporal's Multi-Cluster Replication feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nTemporal automatically forwards Start, Signal, and Query requests to the active Cluster.\nThis feature must be enabled through a Dynamic Config flag per [Global Namespace](/concepts/what-is-a-global-namespace).\n\nWhen the feature is enabled, Tasks are sent to the Parent Task Queue partition that matches that Namespace, if it exists.\n\nAll Visibility APIs can be used against active and standby Clusters.\nThis enables [Temporal Web](https://github.com/temporalio/temporal-web) to work seamlessly for Global Namespaces.\nApplications making API calls directly to the Temporal Visibility API continue to work even if a Global Namespace is in standby mode.\nHowever, they might see a lag due to replication delay when querying the Workflow Execution state from a standby Cluster.\n\n#### Namespace Versions\n\nA _version_ is a concept in Multi-Cluster Replication that describes the chronological order of events per Namespace.\n\nWith Multi-Cluster Replication, all Namespace change events and Workflow Execution History events are replicated asynchronously for high throughput.\nThis means that data across clusters is **not** strongly consistent.\nTo guarantee that Namespace data and Workflow Execution data will achieve eventual consistency (especially when there is a data conflict during a failover), a **version** is introduced and attached to Namespaces.\nAll Workflow Execution History entries generated in a Namespace will also come with the version attached to that Namespace.\n\nAll participating Clusters are pre-configured with a unique initial version and a shared version increment:\n\n- `initial version < shared version increment`\n\nWhen performing failover for a Namespace from one Cluster to another Cluster, the version attached to the Namespace will be changed by the following rule:\n\n- for all versions which follow `version % (shared version increment) == (active cluster's initial version)`, find the smallest version which has `version >= old version in namespace`\n\nWhen there is a data conflict, a comparison will be made and Workflow Execution History entries with the highest version will be considered the source of truth.\n\nWhen a cluster is trying to mutate a Workflow Execution History, the version will be checked.\nA cluster can mutate a Workflow Execution History only if the following is true:\n\n- The version in the Namespace belongs to this cluster, i.e.\n  `(version in namespace) % (shared version increment) == (this cluster's initial version)`\n- The version of this Workflow Execution History's last entry (event) is equal or less than the version in the Namespace, i.e.\n  `(last event's version) <= (version in namespace)`\n\n<details>\n<summary>Namespace version change example\n</summary>\n\nAssuming the following scenario:\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: Namespace α is registered, with active Cluster set to Cluster A\n\n```\nnamespace α's version is 1\nall workflows events generated within this namespace, will come with version 1\n```\n\nT = 1: namespace β is registered, with active Cluster set to Cluster B\n\n```\nnamespace β's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 2: Namespace α is updated to with active Cluster set to Cluster B\n\n```\nnamespace α's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 3: Namespace β is updated to with active Cluster set to Cluster A\n\n```\nnamespace β's version is 11\nall workflows events generated within this namespace, will come with version 11\n```\n\n</details>\n\n#### Version history\n\nVersion history is a concept which provides a high level summary of version information in regards to Workflow Execution History.\n\nWhenever there is a new Workflow Execution History entry generated, the version from Namespace will be attached.\nThe Workflow Executions's mutable state will keep track of all history entries (events) and the corresponding version.\n\n<details>\n<summary>Version history example (without data conflict)\n</summary>\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: adding event with event ID == 1 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 1               | 1       |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 2 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 2: adding event with event ID == 3 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               |                 |         |\n| 3        | 1               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 3: Namespace failover triggered, Namespace version is now 2\nadding event with event ID == 4 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               | 4               | 2       |\n| 3        | 1               |                 |         |\n| 4        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 4: adding event with event ID == 5 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               | 5               | 2       |\n| 3        | 1               |                 |         |\n| 4        | 2               |                 |         |\n| 5        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n</details>\n\nSince Temporal is AP, during failover (change of active Temporal Cluster Namespace), there can exist cases where more than one Cluster can modify a Workflow Execution, causing divergence of Workflow Execution History. Below shows how the version history will look like under such conditions.\n\n<details>\n<summary>Version history example (with data conflict)\n</summary>\n\nBelow, shows version history of the same Workflow Execution in 2 different Clusters.\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Cluster C comes with initial version: 3\n- Shared version increment: 10\n\nT = 0:\n\nView in both Cluster B & C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 3               | 2       |\n| 3        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 4 & version == 2 in Cluster B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 4               | 2       |\n| 3        | 2               |                 |         |\n| 4        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 1: namespace failover to Cluster C, adding event with event ID == 4 & version == 3 in Cluster C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 3               | 2       |\n| 3        | 2               | 4               | 3       |\n| 4        | 3               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster C arrives in Cluster B\n\nNote: below are a tree structures\n\n```\n                | -------- | ------------- |\n                | Events        |\n                | ------------- | ------------- |\n                | Event ID      | Event Version |\n                | --------      | ------------- |\n                | 1             | 1             |\n                | 2             | 1             |\n                | 3             | 2             |\n                | --------      | ------------- |\n                |               |\n                | ------------- | ------------  |\n                |               |\n                | --------      | ------------- |  | -------- | ------------- |\n                | Event ID      | Event Version |  | Event ID | Event Version |\n                | --------      | ------------- |  | -------- | ------------- |\n                | 4             | 2             |  | 4        | 3             |\n                | --------      | ------------- |  | -------- | ------------- |\n\n          | --------------- | ------- |\n          | Version History |\n          | --------------- | ------------------- |\n          | Event ID        | Version             |\n          | --------------- | -------             |\n          | 2               | 1                   |\n          | 3               | 2                   |\n          | --------------- | -------             |\n          |                 |\n          | -------         | ------------------- |\n          |                 |\n          | --------------- | -------             |  | --------------- | ------- |\n          | Event ID        | Version             |  | Event ID        | Version |\n          | --------------- | -------             |  | --------------- | ------- |\n          | 4               | 2                   |  | 4               | 3       |\n          | --------------- | -------             |  | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster B arrives in Cluster C, same as above\n\n</details>\n\n#### Conflict resolution\n\nWhen a Workflow Execution History diverges, proper conflict resolution is applied.\n\nIn Multi-cluster Replication, Workflow Execution History Events are modeled as a tree, as shown in the second example in [Version History](#version-history).\n\nWorkflow Execution Histories that diverge will have more than one history branch.\nAmong all history branches, the history branch with the highest version is considered the `current branch` and the Workflow Execution's mutable state is a summary of the current branch.\nWhenever there is a switch between Workflow Execution History branches, a complete rebuild of the Workflow Execution's mutable state will occur.\n\nTemporal Multi-Cluster Replication relies on asynchronous replication of Events across Clusters, so in the case of a failover it is possible to have an Activity Task dispatched again to the newly active Cluster due to a replication task lag.\nThis also means that whenever a Workflow Execution is updated after a failover by the new Cluster, any previous replication tasks for that Execution cannot be applied.\nThis results in loss of some progress made by the Workflow Execution in the previous active Cluster.\nDuring such conflict resolution, Temporal re-injects any external Events like Signals in the new Event History before discarding replication tasks.\nEven though some progress could roll back during failovers, Temporal provides the guarantee that Workflow Executions won’t get stuck and will continue to make forward progress.\n\nActivity Execution completions are not forwarded across Clusters.\nAny outstanding Activities will eventually time out based on the configuration.\nYour application should have retry logic in place so that the Activity gets retried and dispatched again to a Worker after the failover to the new Cluster.\nHandling this is similar to handling an Activity Task timeout caused by a Worker restarting.\n\n#### Zombie Workflows\n\nThere is an existing contract that for any Namespace and Workflow Id combination, there can be at most one run (Namespace + Workflow Id + Run Id) open / executing.\n\nMulti-cluster Replication aims to keep the Workflow Execution History as up-to-date as possible among all participating Clusters.\n\nDue to the nature of Multi-cluster Replication (for example, Workflow Execution History events are replicated asynchronously) different Runs (same Namespace and Workflow Id) can arrive at the target Cluster at different times, sometimes out of order, as shown below:\n\n```\n| ------------- |          | ------------- |          | ------------- |\n| Cluster A |  | Network Layer |  | Cluster B |\n| --------- || ------------- |          | ------------- |\n        |                          |                          |\n        | Run 1 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        | Run 2 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          | Run 2 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n        |                          | Run 1 Replication Events |\n        |                          | -----------------------> |\n        |     |  |\n        | --- || ------------- |          | ------------- |\n| Cluster A |  | Network Layer |  | Cluster B |\n| --------- || ------------- |          | ------------- |\n```\n\nBecause Run 2 appears in Cluster B first, Run 1 cannot be replicated as \"runnable\" due to the rule `at most one Run open` (see above), thus the \"zombie\" Workflow Execution state is introduced.\nA \"zombie\" state is one in which a Workflow Execution which cannot be actively mutated by a Cluster (assuming the corresponding Namespace is active in this Cluster). A zombie Workflow Execution can only be changed by a replication Task.\n\nRun 1 will be replicated similar to Run 2, except when Run 1's execution will become a \"zombie\" before Run 1 reaches completion.\n\n#### Workflow Task processing\n\nIn the context of Multi-cluster Replication, a Workflow Execution's mutable state is an entity which tracks all pending tasks.\nPrior to the introduction of Multi-cluster Replication, Workflow Execution History entries (events) are from a single branch, and the Temporal Server will only append new entries (events) to the Workflow Execution History.\n\nAfter the introduction of Multi-cluster Replication, it is possible that a Workflow Execution can have multiple Workflow Execution History branches.\nTasks generated according to one history branch may become invalidated by switching history branches during conflict resolution.\n\nExample:\n\nT = 0: task A is generated according to Event Id: 4, version: 2\n\n```\n| -------- | ------------- |\n| Events   |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 1        | 1             |\n| 2        | 1             |\n| 3        | 2             |\n| -------- | ------------- |\n|          |\n|          |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event |\n| -------- | ------------- |\n```\n\nT = 1: conflict resolution happens, Workflow Execution's mutable state is rebuilt and history Event Id: 4, version: 3 is written down to persistence\n\n```\n| -------- | ------------- |\n| Events        |\n| ------------- | -------------------------------------------- |\n| Event ID      | Event Version                                |\n| --------      | -------------                                |\n| 1             | 1                                            |\n| 2             | 1                                            |\n| 3             | 2                                            |\n| --------      | -------------                                |\n|               |\n| ------------- | -------------------------------------------- |\n|               |\n| --------      | -------------                                |                                  | -------- | ------------- |\n| Event ID      | Event Version                                |                                  | Event ID | Event Version |\n| --------      | -------------                                |                                  | -------- | ------------- |\n| 4             | 2                                            | <-- task A belongs to this event | 4        | 3             | <-- current branch / mutable state |\n| --------      | -------------                                |                                  | -------- | ------------- |\n```\n\nT = 2: task A is loaded.\n\nAt this time, due to the rebuild of a Workflow Execution's mutable state (conflict resolution), Task A is no longer relevant (Task A's corresponding Event belongs to non-current branch).\nTask processing logic will verify both the Event Id and version of the Task against a corresponding Workflow Execution's mutable state, then discard task A.\n","is_empty":false},{"file_name":"what-is-standard-visibility.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-standard-visibility.md","id":"concepts/what-is-standard-visibility","title":"What is Standard Visibility?","description":"Standard Visibility, within the Temporal Platform, is the subsystem and APIs that list Workflow Executions by a predefined set of filters.","label":"Standard Visibility","tags":["term","explanation","filtered-lists","visibility"],"markdown_content":"\nStandard Visibility, within the Temporal Platform, is the subsystem and APIs that list Workflow Executions by a predefined set of filters.\n\nOpen Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, or Run Id.\n\nClosed Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, Run Id, or Execution Status (Completed, Failed, Timed Out, Terminated, Canceled, or Continued-As-New).\n","is_empty":false},{"file_name":"what-is-task-routing.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-task-routing.md","id":"concepts/what-is-task-routing","title":"What is Task Routing?","description":"Task Routing is when a Task Queue is paired with one or more Worker Processes, primarily for Activity Task Executions.","label":"Task Routing","tags":["term","explanation"],"markdown_content":"\nTask Routing is simply when a Task Queue is paired with one or more Workers, primarily for Activity Task Executions.\n\nThis could also mean employing multiple Task Queues, each one paired with a Worker Process.\n\nTask Routing has many applicable use cases.\n\n### Flow control\n\nA Worker that consumes from a Task Queue asks for an Activity Task only when it has available capacity, so it is never overloaded by request spikes.\nIf Activity Tasks get created faster than Workers can process them, they are backlogged in the Task Queue.\n\n### Throttling\n\nThe rate at which each Activity Worker polls for and processes Activity Tasks is configurable per Worker.\nWorkers do not exceed this rate even if it has spare capacity.\nThere is also support for global Task Queue rate limiting.\nThis limit works across all Workers for the given Task Queue.\nIt is frequently used to limit load on a downstream service that an Activity calls into.\n\n### Specific environments\n\nIn some cases, you might need to execute Activities in a dedicated environment.\nTo send Activity Tasks to this environment, use a dedicated Task Queue.\n\n#### Route Activity Tasks to a specific host\n\nIn some use cases, such as file processing or machine learning model training, an Activity Task must be routed to a specific Worker Process or Worker Entity.\n\nFor example, suppose that you have a Workflow with the following three separate Activities:\n\n- Download a file.\n- Process the file in some way.\n- Upload a file to another location.\n\nThe first Activity, to download the file, could occur on any Worker on any host.\nHowever, the second and third Activities must be executed by a Worker on the same host where the first Activity downloaded the file.\n\nIn a real-life scenario, you might have many Worker Processes scaled over many hosts.\nYou would need to develop your Temporal Application to route Tasks to specific Worker Processes when needed.\n\nCode samples:\n\n- [Go file processing example](https://github.com/temporalio/samples-go/tree/master/fileprocessing)\n- [Java file processing example](https://github.com/temporalio/samples-java/tree/master/src/main/java/io/temporal/samples/fileprocessing)\n- [PHP file processing example](https://github.com/temporalio/samples-php/tree/master/app/src/FileProcessing)\n\n#### Sessions\n\nSome SDKs provide a Session API that provides a straightforward way to ensure that Activity Tasks are executed with the same Worker without requiring you to manually specify Task Queue names.\nIt also includes features like **concurrent session limitations** and **worker failure detection**.\n\n- [How to create Worker Sessions in Go](/go/how-to-create-a-worker-session-in-go)\n\n#### Route Activity Tasks to a specific process\n\nSome Activities load large datasets and cache them in the process.\nThe Activities that rely on those datasets should be routed to the same process.\n\nIn this case, a unique Task Queue would exist for each Worker Process involved.\n\n#### Workers with different capabilities\n\nSome Workers might exist on GPU boxes versus non-GPU boxes.\nIn this case, each type of box would have its own Task Queue and a Workflow can pick one to send Activity Tasks.\n\n### Multiple priorities\n\nIf your use case involves more than one priority, you can create one Task Queue per priority, with a Worker pool per priority.\n\n### Versioning\n\nTask Routing is the simplest way to version your code.\n\nIf you have a new backward-incompatible Activity Definition, start by using a different Task Queue.\n","is_empty":false},{"file_name":"what-is-temporal-cloud.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-temporal-cloud.md","id":"concepts/what-is-temporal-cloud","title":"What is Temporal Cloud?","description":"Temporal Cloud is a managed, hosted Temporal environment that provides a platform for Temporal Applications.","label":"Temporal Cloud","tags":["term","explanation"],"markdown_content":"\n[Temporal Cloud](https://temporal.io/cloud) is a managed, hosted Temporal environment that provides a platform for [Temporal Applications](/temporal/#temporal-application)—an alternative to deploying and operating your own [Temporal Cluster](/clusters).\n\nTemporal Cloud is offered in units of isolation known as [Namespaces](/namespaces). You can provision and use one or more Cloud Namespaces. A typical use case is to use separate Namespaces as development, testing, integration, staging, and production environments for an application.\n","is_empty":false},{"file_name":"what-is-temporal.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-temporal.md","id":"concepts/what-is-temporal","title":"What is Temporal?","description":"Temporal is a scalable and reliable runtime for Reentrant Processes called Temporal Workflow Executions.","label":"Temporal","tags":["term","explanation"],"markdown_content":"\nTemporal is a scalable and reliable runtime for Reentrant Processes called [Temporal Workflow Executions](/concepts/what-is-a-workflow-execution).\n\n<!-- TODO content more appropriate for blog\n:::note [Temporal's tenth rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule)\n\nAny sufficiently complex distributed system contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of temporal.io.\n\n:::\n-->\n\n![The Temporal System](/diagrams/temporal-system-simple.svg)\n","is_empty":false},{"file_name":"what-is-the-temporal-platform.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-the-temporal-platform.md","id":"concepts/what-is-the-temporal-platform","title":"What is the Temporal Platform?","description":"The Temporal Platform consists of a Temporal Cluster and Worker Processes.","label":"Temporal Platform","tags":["term","explanation"],"markdown_content":"\nThe Temporal Platform consists of a [Temporal Cluster](/concepts/what-is-a-temporal-cluster) and [Worker Processes](/concepts/what-is-a-worker-process).\nTogether these components create a runtime for Workflow Executions.\n\n![The Temporal Platform](/diagrams/temporal-platform-simple.svg)\n\nThe Temporal Cluster is open source and can be operated by you.\nThe Temporal Cloud is a set of Clusters operated by us.\n\nWorker Processes are hosted by you and execute your code.\nThey communicate with a Temporal Cluster via gRPC.\n","is_empty":false},{"file_name":"what-is-the-temporal-server.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-the-temporal-server.md","id":"concepts/what-is-the-temporal-server","title":"What is the Temporal Server?","description":"The Temporal Server is a grouping of four horizontally scalable services.","label":"Temporal Server","tags":["term","explanation"],"markdown_content":"\nThe Temporal Server consists of four independently scalable services:\n\n- Frontend gateway: for rate limiting, routing, authorizing.\n- History subsystem: maintains data (mutable state, queues, and timers).\n- Matching subsystem: hosts Task Queues for dispatching.\n- Worker Service: for internal background Workflows.\n\nFor example, a real-life production deployment can have 5 Frontend, 15 History, 17 Matching, and 3 Worker Services per cluster.\n\nThe Temporal Server services can run independently or be grouped together into shared processes on one or more physical or virtual machines.\nFor live (production) environments, we recommend that each service runs independently, because each one has different scaling requirements and troubleshooting becomes easier.\nThe History, Matching, and Worker Services can scale horizontally within a Cluster.\nThe Frontend Service scales differently than the others because it has no sharding or partitioning; it is just stateless.\n\nEach service is aware of the others, including scaled instances, through a membership protocol via [Ringpop](https://github.com/temporalio/ringpop-go).\n\n#### Versions and support\n\nAll Temporal Server releases abide by the [Semantic Versioning Specification](https://semver.org/).\n\nFairly precise upgrade paths and support have been established starting from Temporal `v1.7.0`.\n\nWe provide maintenance support for previously published minor and major versions by continuing to release critical bug fixes related to security, the prevention of data loss, and reliability, whenever they are found.\n\nWe aim to publish incremental upgrade guides for each minor and major version, which include specifics about dependency upgrades that we have tested for (such as Cassandra 3.0 -> 3.11).\n\nWe offer maintenance support of the last three **minor** versions after a release and do not plan to \"backport\" patches beyond that.\n\nWe offer maintenance support of **major** versions for at least 12 months after a GA release, and we provide at least 6 months' notice before EOL/deprecating support.\n\n#### Dependencies\n\nTemporal offers official support for, and is tested against, dependencies with the exact versions described in the `go.mod` file of the corresponding release tag.\n(For example, [v1.5.1](https://github.com/temporalio/temporal/tree/v1.5.1) dependencies are documented in [the go.mod for v1.5.1](https://github.com/temporalio/temporal/blob/v1.5.1/go.mod).)\n","is_empty":false},{"file_name":"what-is-the-temporal-web-ui.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-the-temporal-web-ui.md","id":"concepts/what-is-the-temporal-web-ui","title":"What is the Temporal Web UI?","description":"The Temporal Web UI","label":"Temporal Web UI","tags":["term","web-ui"],"markdown_content":"\n:::info Upgrade available\n\nTemporal Web UI v2 is now generally available.\n\nTemporal Web UI v1 is being deprecated on September 30, 2022.\n\n:::\n\nThe Temporal Web UI is a GUI that provides users with Workflow Execution state and metadata and is intended to be used to debug execution issues.\nIt ships with every [Docker Compose](/application-development/foundations#docker-compose) update and is available with [Temporal Cloud](/cloud).\n\nYou can configure the Temporal Web UI to work in your own environment.\nSee the [UI configuration reference](/references/web-ui-configuration).\n\nWeb UI open source repos:\n\n- [temporalio/ui](https://github.com/temporalio/ui)\n- [temporalio/ui-server](https://github.com/temporalio/ui-server)\n\nThe Web UI is packed with several features.\n\n### Namespace selection\n\nUsers can switch between Namespaces by clicking the Namespace Switcher icon in the left navigation.\nClicking the Namespace Switcher reveals a side panel where users can search for a Namespace or select a Namespace from the list.\nAfter a Namespace is selected, the user is redirected to the Recent Workflows page for that Namespace.\nIn Temporal Cloud, users can access only Namespaces that they have been granted access to.\n\n### Recent Workflows\n\nThe Recent Workflows page lists the most recent 1,000 Workflow Executions in the past 24 hours, by default.\nUsers can list Workflow Executions by any of the following:\n\n- [Workflow ID](/concepts/what-is-a-workflow-id)\n- [Workflow Type](/concepts/what-is-a-workflow-type)\n- Status\n- Date and Time—users can set their preferred date and time format as one of the following:\n  - UTC\n  - Local\n  - Relative\n- A [List Filter](/concepts/what-is-a-list-filter)\n\nSelect a Workflow Execution to see a breakdown of the Workflow Execution's History, Workers, and pending Activities.\n\n#### History\n\nThis is a view of the [Events](/concepts/what-is-an-event) and Event fields that make up the Workflow Execution.\nApproximately [40 different Events](/references/events) can appear in a Workflow Execution's Event History.\nThe top of the page lists the following execution metadata:\n\n- [Workflow Type](/concepts/what-is-a-workflow-type)\n- [Run ID](/concepts/what-is-a-run-id)\n- Start Time and Close Time\n- [Task Queue](/concepts/what-is-a-task-queue)\n- Parent and Parent ID\n- State Transitions\n\nThe Input and Results section displays the function arguments and return values for debugging purposes.\nResults are not available until the Workflow finishes.\n\nThe Recent Events tab has the following views:\n\n- Timeline: A chronological or reverse-chronological order of events with a summary.\n  Clicking into an Event displays all details for that Event.\n  Clicking “Expand all” displays all Event details.\n  Similarly, clicking “Collapse all” collapses the table and displays only the summary.\n- Compact: A logical grouping of Activities, Signals and Timers.\n- JSON: The full JSON code for the workflow.\n\n#### Download Event History\n\nThe entire Workflow Execution Event History, in JSON format, can be downloaded from this screen.\n\n#### Terminate Workflow\n\nWorkflow Executions can be Terminated directly from the UI.\nA custom note can be logged from the UI when that happens.\n\n#### Workers\n\nDisplays the Workers currently polling on the Workflow Task Queue with a count.\nIf no Workers are polling, an error displays.\n\n#### Pending Activities\n\nDisplays a summary of recently active and/or pending Activity Executions.\nClicking a pending Activity directs the user to the Pending Activities tab to view details.\n\n#### Stack Trace\n\nThe screen shows the captured result from the [\\_\\_stack_trace](/workflows#stack-trace-query) Query.\nThe Query is performed when the tab is selected.\nIt works only if a Worker is running and available to return the stack trace.\n\n#### Queries\n\nLists all Queries sent to the Workflow Execution.\n\n### Settings\n\nDisplays the following information:\n\n- Description of the Namespace.\n- Owner: Namespace owner.\n- Global?: Whether the Namespace is a Global Namespace\n- Retention Period: Namespace Retention Period\n- History Archival: Whether History Archival is enabled\n- Visibility Archival: Whether Visibility Archival is enabled\n- Failover Version: Namespace Failover Version\n- Clusters: Cluster information\n\n### Archival\n\n[Archival](/concepts/what-is-archival) feature information.\n\n### Import Event History\n\nNavigate to `/import` to import an Event History in JSON format and populate a Workflow details page.\n\n### Data Encoder\n\nThe Web UI can use the same Data Converter that Workers use for inputs and return values.\nThe UI supports both a Remote Codec endpoint and/or the tctl plugin port.\n","is_empty":false},{"file_name":"what-is-visibility.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/what-is-visibility.md","id":"concepts/what-is-visibility","title":"What is Visibility?","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["term"],"markdown_content":"\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n","is_empty":false},{"file_name":"why-temporal.md","file_path":"/Users/ssantiago/Documents/documentation/docs/concepts/why-temporal.md","id":"concepts/why-temporal","title":"What are the differences between Temporal and a traditional system?","description":"This page compares a function execution in a traditional system and a Workflow Execution in Temporal.","tags":["explanation"],"markdown_content":"\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nOne of the aspects of the Temporal System is that it abstracts the complexity of a distributed system.\nDistributed systems exist to scale computation across multiple machines as the potential load of a system changes.\nIn theory, a distributed system facilitates a reliable and highly performant application.\n\nHowever, any failure that leaves the downstream part of the application waiting for a response can make things very complicated, especially at a large scale.\n\n![Distributed application failures](/diagrams/basic-distributed-system.svg)\n\nHow will a downstream part of the application know if there was a failure before or a failure after changes to the state if there is no response?\nHow will the application track and reconcile an inconsistent state?\n\nIn traditional systems, a large investment is often made to maintain the health of each individual component, visualize the health of the overall system, define timeout constraints for computations, orchestrate retries for computations that fail, and maintain a consistent state.\n\nThese systems are often a mixture of stateless services, databases, cron jobs, and queues.\nAnd as these systems scale, responding to multiple asynchronous events, communicating with unreliable external resources, or tracking the state of something very complex becomes more and more challenging.\n\nTemporal restructures the use of services, databases, cron jobs, queues, host processes, and SDKs, into the Temporal Platform, and addresses failures head on.\n\nIn a traditional system, the service exists to spawn function executions.\nThe Temporal Platform exists to facilitate [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\n![Temporal vs Traditional system](/diagrams/temporal-vs-traditional.svg)\n\nAlthough the two systems seem similar at first glance, they differ in several significant ways.\n\n**Failure**\n\nWith a traditional system, a service function execution is both volatile and short-lived.\n\n- If a function execution fails, it's not resumable because all execution state is lost. The longer a function execution awaits, the higher the chance of failure.\n- A traditional function execution typically has a limited lifespan, often measured in minutes.\n\nWith Temporal, a Workflow Execution is resumable.\n\n- A Workflow Execution is fully resumable after a failure.\n- Temporal imposes no deadlines on Workflow Executions.\n\n**State**\n\nWith a traditional system, stoppage or failure means that all execution state is lost.\nYour application (or a supporting component) must monitor the service's response to initiate a retry of the service execution.\nA retry starts from its _initial_ state.\n\nWith Temporal, computation resumes from its _latest_ state. All progress is retained.\n\n**Communication**\n\nWith a traditional system, you can't communicate with a function execution.\n\nWith Temporal, [Signals](/concepts/what-is-a-signal) and [Queries](/concepts/what-is-a-query) enable data to be sent to or extracted from a Workflow Execution.\n\n**Scope**\n\nWith a traditional system, a service function execution can at best represent a business process.\nTypically, it represents only a part of a business process.\n\nA Temporal Workflow Execution can represent a business process or an entire business object.\n\n### Example subscription use case\n\nLet's look at a subscription-based use case to compare the difference between a Temporal Application and other traditional approaches.\n\nThe basic business steps are as follows:\n\n1. A customer signs up for a service that has a trial period.\n2. After the trial period, if the customer has not canceled, they should be charged once a month.\n3. The customer has to be notified via email about the charges and should be able to cancel the subscription at any time.\n\nThis business logic is not very complicated and can be expressed in a few dozen lines of code.\nAny practical implementation also has to ensure that the business process is fault-tolerant and scalable.\n\n**Database-centric design approach**\n\nThe first approach might be to center everything around a database where an application process would periodically scan the database tables for customers in specific states, execute necessary actions, and update the database to reflect changes.\n\nHowever, there are various drawbacks.\n\n- The most obvious one is that the application state machine of the customer's state quickly becomes extremely complicated.\n  For example, if a credit card charge attempt fails or sending an email fails due to a downstream system's unavailability, the state is now in limbo.\n- Failed calls likely need to be retried for a long time, and these calls need to be throttled to not overload external resources.\n- There needs to be logic to handle corrupted customer records to avoid blocking the whole process.\n- Additionally, databases have performance and scalability limitations (eventually requiring sharding) and are not efficient for scenarios that require constant polling.\n\n**Queue system design approach**\n\nThe next commonly employed approach is to use a timer service and queues.\nUpdates are pushed to a queue while a service consumes them one at a time, updating a database, and possibly pushing more messages into other downstream queues.\nA timer service can be used to schedule queue polling or database actions.\n\nWhile this approach has shown to scale a bit better, the programming model can become very complex and error-prone, as there are usually no transactional updates between a queuing system, a timer service, and a database.\n\n**Temporal design approach**\n\nThe Temporal Platform approach aims to encapsulate and implement the entire business logic in a simple function or object method.\nThanks to the Temporal Platform, the function/method is durably stateful, and the implementer doesn't need to employ any additional systems to ensure consistency and fault tolerance.\n\nHere are example Workflow Definitions that implement the subscription management use case in Java, Go, Typescript and PHP:\n\n<Tabs\ndefaultValue=\"java\"\nvalues={[\n{label: 'Go', value: 'go'},\n{label: 'Java', value: 'java'},\n{label: 'Typescript', value: 'ts'},\n{label: 'PHP', value: 'php'},\n]\n}>\n\n<TabItem value=\"go\">\n\n<!--SNIPSTART subscription-go-workflow-definition-->\n<!--SNIPEND-->\n\n</TabItem>\n<TabItem value=\"java\">\n\n<!--SNIPSTART subscription-java-workflow-definition-implementation-->\n<!--SNIPEND-->\n\n</TabItem>\n<TabItem value=\"ts\">\n\n<!--SNIPSTART subscription-ts-workflow-definition-->\n<!--SNIPEND-->\n\n</TabItem>\n<TabItem value=\"php\">\n\n<!--SNIPSTART subscription-php-workflow-definition-implementation-->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\nAgain, it is important to note that this is working application code that directly implements the business logic.\nIf any of the operations take a long time, the code is not going to change.\n\nIt is completely okay to be blocked on `chargeCustomerForBillingPeriod` for a day or more if the downstream processing service is down or not responding.\nIn the same way, it is a completely normal operation to sleep for 30 days directly inside the Workflow code.\nThis is possible because infrastructure failures won't affect the Workflow state—including threads, blocking calls, and any variables.\n\nThe Temporal Platform has practically no scalability limits on the number of open Workflow Executions, so this code can be used over and over even if your application has hundreds of millions of customers.\n","is_empty":false},{"file_name":"what-is-a-codec-server.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/concepts/what-is-a-codec-server.md","id":"concepts/what-is-a-codec-server","title":"What is a Codec Server?","description":"A Codec Server is an HTTP server that runs data from tctl or the Web UI through a Payload Codec.","label":"Codec Server","tags":["term"],"markdown_content":"\nA Codec Server is an HTTP server that runs data from [tctl](/tctl-v1) or the [Web UI](/web-ui) through a [Payload Codec](/concepts/what-is-a-data-converter#payload-codecs).\n\n- [How to set up a Codec Server](/security/how-to-set-up-codec-server)\n\nBy default, tctl and the Web UI use the [Default Data Converter](/concepts/what-is-a-data-converter#default-data-converter) without a [Payload Codec](/concepts/what-is-a-data-converter#payload-codecs).\nIf you use a Payload Codec with your SDK, you may not be able to understand the Payload data displayed in the Web UI/tctl (for example, it may be encrypted or compressed).\nIn order to convert the data to its original format, you can configure the Web UI/tctl to use a Codec Server that uses your Payload Codec.\n\n![](/img/tctl-diagram-codec-server.svg)\n\n## Use case: tctl\n\nSuppose that you want to view Workflow History.\nThis information needs to be decoded before it can be viewed.\n\nYou can use [tctl workflow showid](/tctl-v1/workflow#show) to view a Workflow Execution Event History.\n\n```bash\ntctl workflow showid <workflowID>\n```\n\nWith a Codec Server, Payloads that are part of the Event History will be sent to the Codec Server to be decoded before being deserialized by the Default Data Converter and displayed in your terminal.\n\n- [How to configure tctl with a Codec Server](/security/how-to-set-up-codec-server#configure-tctl)\n\n## Use case: Web UI\n\nWorkflow Execution Event History is available in the Web UI.\nPayload information for each Event is captured within Event 'input' and 'result' fields.\nWithout a Codec Server, this information remains encoded.\n\nPassing these Payloads through a Codec Server returns decoded results to the Web UI.\n\n- [How to configure the Web UI with a Codec Server](/security/how-to-set-up-codec-server#configure-the-web-ui)\n","is_empty":false},{"file_name":"what-is-tctl-next.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/concepts/what-is-tctl-next.md","id":"concepts/what-is-tctl-next","title":"What is tctl next-version?","description":"tctl next-version is the next version of Temporal's tctl command-line tool. Currently it is known as tctl v2.0.0-beta, but the name may change in the future.","label":"tctl","tags":["term","tctl"],"markdown_content":"\nThis documentation reflects the \"next\" version of Temporal's tctl command line tool.\n`tctl next` was formerly known as [tctl v2.0.0-beta](https://github.com/temporalio/tctl#trying-out-new-tctl-v200-beta-with-updated-ux).\n\n:::note\n\nUpdate to version 1.17 or later before switching to `tctl next`.\n\n:::\n\nThe Temporal CLI (tctl) is a command-line tool that you can use to interact with a Temporal Cluster.\nIt can perform [Namespace](/concepts/what-is-a-namespace) operations (such as register, update, and describe) and [Workflow](/concepts/what-is-a-workflow) operations (such as start\nWorkflow, show Workflow History, and Signal Workflow).\n\n- [How to install tctl](/tctl-next/how-to-install-tctl)\n- [Environment variables for tctl](/tctl-next/environment-variables)\n\n### Available commands\n\n- [tctl activity](/tctl-next/activity/)\n- [tctl batch](/tctl-next/batch/)\n- [tctl cluster](/tctl-next/cluster/)\n- [tctl data-converter](/tctl-next/data-converter/)\n- [tctl namespace](/tctl-next/namespace/)\n- [tctl schedule](/tctl-next/schedule)\n- [tctl search-attribute](/tctl-next/search-attribute)\n- [tctl task-queue](/tctl-next/task-queue/)\n- [tctl workflow](/tctl-next/workflow/)\n","is_empty":false},{"file_name":"what-is-tctl-v1.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/concepts/what-is-tctl-v1.md","id":"concepts/what-is-tctl-v1","title":"What is tctl?","description":"tctl is a command-line tool that you can use to interact with a Temporal Cluster.","label":"tctl","tags":["term","tctl"],"markdown_content":"\n:::note\n\nThis documentation reflects tctl version 1.17\n\n:::\n\nThe Temporal CLI (tctl) is a command-line tool that you can use to interact with a Temporal Cluster.\nIt can perform [Namespace](/concepts/what-is-a-namespace) operations (such as register, update, and describe) and [Workflow](/concepts/what-is-a-workflow) operations (such as start\nWorkflow, show Workflow History, and Signal Workflow).\n\n- [How to install tctl](/tctl-v1/how-to-install-tctl)\n- [Environment variables for tctl](/tctl-v1/environment-variables)\n\n## tctl commands\n\n- [tctl activity](/tctl-v1/activity/)\n- [tctl admin](/tctl-v1/admin/)\n- [tctl batch](/tctl-v1/batch/)\n- [tctl cluster](/tctl-v1/cluster/)\n- [tctl dataconverter](/tctl-v1/dataconverter/)\n- [tctl namespace](/tctl-v1/namespace/)\n- [tctl taskqueue](/tctl-v1/taskqueue/)\n- [tctl workflow](/tctl-v1/workflow/)\n","is_empty":false},{"file_name":"develop-a-worker.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/develop-a-worker.md","id":"go/develop-a-worker","title":"How to develop a Worker in Go","description":"Develop an instance of a Worker by calling `worker.New()`, available via the `go.temporal.io/sdk/worker` package.","label":"Develop Worker","tags":["developer-guide","go","workers"],"markdown_content":"\nCreate an instance of [`Worker`](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) by calling [`worker.New()`](https://pkg.go.dev/go.temporal.io/sdk/worker#New), available through the `go.temporal.io/sdk/worker` package, and pass it the following parameters:\n\n1. An instance of the Temporal Go SDK `Client`.\n1. The name of the Task Queue that it will poll.\n1. An instance of [`worker.Options`](/go/how-to-set-workeroptions-in-go), which can be empty.\n\nThen, register the Workflow Types and the Activity Types that the Worker will be capable of executing.\n\nLastly, call either the `Start()` or the `Run()` method on the instance of the Worker.\nRun accepts an interrupt channel as a parameter, so that the Worker can be stopped in the terminal.\nOtherwise, the `Stop()` method must be called to stop the Worker.\n\n```go\npackage main\n\nimport (\n   \"go.temporal.io/sdk/client\"\n   \"go.temporal.io/sdk/worker\"\n)\n\nfunc main() {\n   c, err := client.Dial(client.Options{})\n   if err != nil {\n       // ...\n   }\n   defer c.Close()\n   w := worker.New(c, \"your-task-queue\", worker.Options{})\n   w.RegisterWorkflow(YourWorkflowDefinition)\n   w.RegisterActivity(YourActivityDefinition)\n   err = w.Run(worker.InterruptCh())\n   if err != nil {\n       // ...\n   }\n // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n}\n\nfunc YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResponse, error) {\n // ...\n}\n```\n\n:::tip\n\nIf you have [`gow`](https://github.com/mitranim/gow) installed, the Worker Process automatically \"reloads\" when you update the Worker file:\n\n```bash\ngo install github.com/mitranim/gow@latest\ngow run worker/main.go # automatically reload when file changed\n```\n\n:::\n","is_empty":false},{"file_name":"develop-activities.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/develop-activities.md","id":"go/develop-activities","title":"How to develop an Activity in Go","description":"In the Temporal Go SDK programming model, an Activity Definition is an exportable function or `stuct` method.","label":"Activity Development","tags":["developer-guide","go"],"markdown_content":"\nIn the Temporal Go SDK programming model, an Activity Definition is an exportable function or a `struct` method.\n\n**Function**\n\n```go\n// basic function signature\nfunc YourActivityDefinition(ctx context.Context) error {\n // ...\n return nil\n}\n\n// with parameters and return values\nfunc SimpleActivity(ctx context.Context, value string) (string, error)\n```\n\n**Struct method**\n\n```go\ntype YourActivityStruct struct {\n ActivityFieldOne string\n ActivityFieldTwo int\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinition(ctx context.Context) error {\n // ...\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinitionTwo(ctx context.Context) error {\n // ...\n}\n```\n\nAn _Activity struct_ can have more than one method, with each method acting as a separate Activity Type.\nActivities written as struct methods can use shared struct variables, such as:\n\n- an application level DB pool\n- client connection to another service\n- reusable utilities\n- any other expensive resources that you only want to initialize once per process\n\nBecause this is such a common need, the rest of this guide shows Activities written as `struct` methods.\n\n### Parameters\n\nThe first parameter of an Activity Definition is `context.Context`.\nThis parameter is optional for an Activity Definition, though it is recommended, especially if the Activity is expected to use other Go SDK APIs.\n\nAn Activity Definition can support as many other custom parameters as needed.\nHowever, all parameters must be serializable (parameters can’t be channels, functions, variadic, or unsafe pointers), and it is recommended to pass a single struct that can be updated later.\n\n```go\ntype YourActivityParam struct {\n ActivityParamFieldOne string\n ActivityParamFieldTwo int\n}\n\ntype YourActivityStruct struct {\n // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n // ...\n}\n```\n\n### Return values\n\nA Go-based Activity Definition can return either just an `error` or a `customValue, error` combination (same as a Workflow Definition).\nYou may wish to use a `struct` type to hold all custom values, just keep in mind they must all be serializable.\n\n```go\ntype YourActivityResult struct{\n  ActivityResultFieldOne string\n  ActivityResultFieldTwo int\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResult, error) {\n  // ...\n  result := YourActivityResult {\n    ActivityResultFieldOne: a.ActivityFieldOne,\n    ActivityResultFieldTwo: a.ActivityFieldTwo,\n  }\n  return result, nil\n}\n```\n","is_empty":false},{"file_name":"develop-workflows.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/develop-workflows.md","id":"go/develop-workflows","title":"Develop a Workflow in Go","description":"In the Temporal Go SDK programming model, a Workflow Definition is an exportable function.","label":"Workflow Development","tags":["developer-guide","go"],"markdown_content":"\nIn the Temporal Go SDK programming model, a [Workflow Definition](/concepts/what-is-a-workflow-definition) is an exportable function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context) error {\n  // ...\n  return nil\n}\n```\n\nIn Go, by default, the Workflow Type name is the same as the function name.\n\n### Parameters\n\nThe first parameter of a Go-based Workflow Definition must be of the [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context) type, as it is used by the Temporal Go SDK to pass around Workflow Execution context, and virtually all the Go SDK APIs that are callable from the Workflow require it.\nIt is acquired from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package.\n\n```go\nimport (\n   \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param string) error {\n // ...\n}\n```\n\nThe `workflow.Context` entity operates similarly to the standard `context.Context` entity provided by Go.\nThe only difference between `workflow.Context` and `context.Context` is that the `Done()` function, provided by `workflow.Context`, returns `workflow.Channel` instead of the standard Go `chan`.\n\nThe second parameter, `string`, is a custom parameter that is passed to the Workflow when it is invoked.\nA Workflow Definition may support multiple custom parameters, or none.\nThese parameters can be regular type variables or safe pointers.\nHowever, the best practice is to pass a single parameter that is of a `struct` type, so there can be some backward compatibility if new parameters are added.\n\n```go\ntype YourWorkflowParam struct {\n WorkflowParamFieldOne string\n WorkflowParamFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n // ...\n}\n```\n\nAll Workflow Definition parameters must be serializable, regardless of whether pointers or regular type values are used.\nParameters can’t be channels, functions, variadic, or unsafe pointers.\n\n### Return values\n\nA Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.\nAgain, the best practice here is to use a `struct` type to hold all custom values.\n\n```go\ntype YourWorkflowResponse struct{\n WorkflowResultFieldOne string\n WorkflowResultFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n if err != nil {\n   return \"\", err\n }\n responseVar := YourWorkflowResponse {\n   FieldOne: \"super\",\n   FieldTwo: 1,\n }\n return responseVar, nil\n}\n```\n\nA Workflow Definition written in Go can return both a custom value and an error.\nHowever, it's not possible to receive both a custom value and an error in the calling process, as is normal in Go.\nThe caller will receive either one or the other.\nReturning a non-nil `error` from a Workflow indicates that an error was encountered during its execution and the Workflow Execution should be terminated, and any custom return values will be ignored by the system.\n\n### Logic requirements\n\nIn Go, Workflow Definition code cannot directly do the following:\n\n- Iterate over maps using `range`, because with `range` the order of the map's iteration is randomized.\n  Instead you can collect the keys of the map, sort them, and then iterate over the sorted keys to access the map.\n  This technique provides deterministic results.\n  You can also use a Side Effect or an Activity to process the map instead.\n- Call an external API, conduct a file I/O operation, talk to another service, etc. (Use an Activity for these.)\n\nThe Temporal Go SDK has APIs to handle equivalent Go constructs:\n\n- `workflow.Now()` This is a replacement for `time.Now()`.\n- `workflow.Sleep()` This is a replacement for `time.Sleep()`.\n- `workflow.GetLogger()` This ensures that the provided logger does not duplicate logs during a replay.\n- `workflow.Go()` This is a replacement for the `go` statement.\n- `workflow.Channel` This is a replacement for the native `chan` type.\n  Temporal provides support for both buffered and unbuffered channels.\n- `workflow.Selector` This is a replacement for the `select` statement. Learn more on the [Go SDK Selectors](/go/selectors) page\n- `workflow.Context` This is a replacement for `context.Context`. Learn more on the [Go SDK Context Propagation](/go/tracing) page.\n","is_empty":false},{"file_name":"error-handling.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/error-handling.md","id":"go/error-handling","title":"Error Handling in Go","markdown_content":"\nAn Activity, or a Child Workflow, might fail, and you could handle errors differently based on the different\nerror cases.\n\nIf the Activity returns an error as `errors.New()` or `fmt.Errorf()`, that error is converted into `*temporal.ApplicationError`.\n\nIf the Activity returns an error as `temporal.NewNonRetryableApplicationError(\"error message\", details)`, that error is returned as `*temporal.ApplicationError`.\n\nThere are other types of errors such as `*temporal.TimeoutError`, `*temporal.CanceledError` and\n`*temporal.PanicError`.\nFollowing is an example of what your error code might look like:\n\nHere's an example of handling Activity errors within Workflow code that differentiates between different error types.\n\n```go\nerr := workflow.ExecuteActivity(ctx, YourActivity, ...).Get(ctx, nil)\nif err != nil {\n\tvar applicationErr *ApplicationError\n\tif errors.As(err, &applicationErr) {\n\t\t// retrieve error message\n\t\tfmt.Println(applicationError.Error())\n\n\t\t// handle Activity errors (created via NewApplicationError() API)\n\t\tvar detailMsg string // assuming Activity return error by NewApplicationError(\"message\", true, \"string details\")\n\t\tapplicationErr.Details(&detailMsg) // extract strong typed details\n\n\t\t// handle Activity errors (errors created other than using NewApplicationError() API)\n\t\tswitch applicationErr.Type() {\n\t\tcase \"CustomErrTypeA\":\n\t\t\t// handle CustomErrTypeA\n\t\tcase CustomErrTypeB:\n\t\t\t// handle CustomErrTypeB\n\t\tdefault:\n\t\t\t// newer version of Activity could return new errors that Workflow was not aware of.\n\t\t}\n\t}\n\n\tvar canceledErr *CanceledError\n\tif errors.As(err, &canceledErr) {\n\t\t// handle cancellation\n\t}\n\n\tvar timeoutErr *TimeoutError\n\tif errors.As(err, &timeoutErr) {\n\t\t// handle timeout, could check timeout type by timeoutErr.TimeoutType()\n        switch err.TimeoutType() {\n        case commonpb.ScheduleToStart:\n                // Handle ScheduleToStart timeout.\n        case commonpb.StartToClose:\n                // Handle StartToClose timeout.\n        case commonpb.Heartbeat:\n                // Handle heartbeat timeout.\n        default:\n        }\n\t}\n\n\tvar panicErr *PanicError\n\tif errors.As(err, &panicErr) {\n\t\t// handle panic, message and stack trace are available by panicErr.Error() and panicErr.StackTrace()\n\t}\n}\n```\n","is_empty":false},{"file_name":"get-the-result-of-a-workflow-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/get-the-result-of-a-workflow-execution.md","id":"go/get-the-result-of-a-workflow-execution","title":"How to get the result of a Workflow Execution in Go","description":"Use the Future returned by `ExecuteWorkflow` API call to retrieve the result.","label":"Workflow Execution result","tags":["developer-guide","go"],"markdown_content":"\nThe `ExecuteWorkflow` call returns an instance of [`WorkflowRun`](https://pkg.go.dev/go.temporal.io/sdk/client#WorkflowRun), which is the `workflowRun` variable in the following line.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, app.YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n // ...\n}\n```\n\nThe instance of `WorkflowRun` has the following three methods:\n\n- `GetWorkflowID()`: Returns the Workflow Id of the invoked Workflow Execution.\n- `GetRunID()`: Always returns the Run Id of the initial Run (See [Continue As New](#)) in the series of Runs that make up the full Workflow Execution.\n- `Get`: Takes a pointer as a parameter and populates the associated variable with the Workflow Execution result.\n\nTo wait on the result of Workflow Execution in the same process that invoked it, call `Get()` on the instance of `WorkflowRun` that is returned by the `ExecuteWorkflow()` call.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n}\n```\n\nHowever, the result of a Workflow Execution can be obtained from a completely different process.\nAll that is needed is the [Workflow Id](#).\n(A [Run Id](#) is optional if more than one closed Workflow Execution has the same Workflow Id.)\nThe result of the Workflow Execution is available for as long as the Workflow Execution Event History remains in the system.\n\n<!-- TODO (See [How long do Workflow Execution Histories persist](#)). -->\n\nCall the `GetWorkflow()` method on an instance of the Go SDK Client and pass it the Workflow Id used to spawn the Workflow Execution.\nThen call the `Get()` method on the instance of `WorkflowRun` that is returned, passing it a pointer to populate the result.\n\n```go\n // ...\n workflowID := \"Your-Custom-Workflow-Id\"\n workflowRun := c.GetWorkflow(context.Background, workflowID)\n\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n```\n\n**Get last completion result**\n\nIn the case of a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job), you might need to get the result of the previous Workflow Run and use it in the current Workflow Run.\n\nTo do this, use the [`HasLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#HasLastCompletionResult) and [`GetLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLastCompletionResult) APIs, available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package, directly in your Workflow code.\n\n```go\ntype CronResult struct {\n Count int\n}\n\nfunc YourCronWorkflowDefinition(ctx workflow.Context) (CronResult, error) {\n count := 1\n\n if workflow.HasLastCompletionResult(ctx) {\n   var lastResult CronResult\n   if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {\n     count = count + lastResult.Count\n   }\n }\n\n newResult := CronResult {\n   Count: count,\n }\n return newResult, nil\n}\n```\n\nThis will work even if one of the cron Workflow Runs fails.\nThe next Workflow Run gets the result of the last successfully Completed Workflow Run.\n","is_empty":false},{"file_name":"get-the-result-of-an-activity-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/get-the-result-of-an-activity-execution.md","id":"go/get-the-result-of-an-activity-execution","title":"How to get the result of an Activity Execution in Go","description":"Use the Future returned from the `ExecuteActivity` API call to retrieve the result.","label":"Activity Execution result","tags":["developer-guide","go"],"markdown_content":"\nThe `ExecuteActivity` API call returns an instance of [`workflow.Future`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Futures) which has the following two methods:\n\n- `Get()`: Takes an instance of the `workflow.Context`, that was passed to the Activity Execution, and a pointer as parameters.\n  The variable associated with the pointer is populated with the Activity Execution result.\n  This call blocks until the results are available.\n- `IsReady()`: Returns `true` when the result of the Activity Execution is ready.\n\nCall the `Get()` method on the instance of `workflow.Future` to get the result of the Activity Execution.\nThe type of the result parameter must match the type of the return value declared by the Activity function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n var yourActivityResult YourActivityResult\n if err := future.Get(ctx, &yourActivityResult); err != nil {\n   // ...\n }\n // ...\n}\n```\n\nUse the `IsReady()` method first to make sure the `Get()` call doesn't cause the Workflow Execution to wait on the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n // ...\n if(future.IsReady()) {\n   var yourActivityResult YourActivityResult\n   if err := future.Get(ctx, &yourActivityResult); err != nil {\n     // ...\n   }\n }\n // ...\n}\n```\n\nIt is idiomatic to invoke multiple Activity Executions from within a Workflow.\nTherefore, it is also idiomatic to either block on the results of the Activity Executions or continue on to execute additional logic, checking for the Activity Execution results at a later time.\n","is_empty":false},{"file_name":"heartbeat-an-activity.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/heartbeat-an-activity.md","id":"go/heartbeat-an-activity","title":"How to Heartbeat an Activity in Go","description":"Use, the `RecordHeartbeat` API to report that the execution is alive and progressing.","label":"Activity Heartbeats","tags":["go","developer-guide"],"markdown_content":"\nTo [Heartbeat](/concepts/what-is-an-activity-heartbeat) in an Activity in Go, use the `RecordHeartbeat` API.\n\n```go\nimport (\n    // ...\n    \"go.temporal.io/sdk/workflow\"\n    // ...\n)\n\nfunc YourActivityDefinition(ctx, YourActivityDefinitionParam) (YourActivityDefinitionResult, error) {\n    // ...\n    activity.RecordHeartbeat(ctx, details)\n    // ...\n}\n```\n\nWhen an Activity Task Execution times out due to a missed Heartbeat, the last value of the `details` variable above is returned to the calling Workflow in the `details` field of `TimeoutError` with `TimeoutType` set to `Heartbeat`.\n\nYou can also Heartbeat an Activity from an external source:\n\n```go\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n// Record heartbeat.\nerr := temporalClient.RecordActivityHeartbeat(ctx, taskToken, details)\n```\n\nThe parameters of the `RecordActivityHeartbeat` function are:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `details`: The serializable payload containing progress information.\n\nIf an Activity Execution Heartbeats its progress before it failed, the retry attempt will have access to the progress information, so that the Activity Execution can resume from the failed state.\nHere's an example of how this can be implemented:\n\n```go\nfunc SampleActivity(ctx context.Context, inputArg InputParams) error {\n    startIdx := inputArg.StartIndex\n    if activity.HasHeartbeatDetails(ctx) {\n        // Recover from finished progress.\n        var finishedIndex int\n        if err := activity.GetHeartbeatDetails(ctx, &finishedIndex); err == nil {\n            startIdx = finishedIndex + 1 // Start from next one.\n        }\n    }\n\n    // Normal Activity logic...\n    for i:=startIdx; i<inputArg.EndIdx; i++ {\n        // Code for processing item i goes here...\n        activity.RecordHeartbeat(ctx, i) // Report progress.\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go.md","id":"go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go","title":"How to add custom Search Attributes to Workflow Executions at start time in Go","description":"Add custom Search Attributes to Workflow Executions at start time","label":"Add custom Search Attributes to Workflow Executions at start time","tags":["developer-guide","go","client"],"markdown_content":"\nProvide key-value pairs in [`StartWorkflowOptions.SearchAttributes`](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions).\n\nSearch Attributes are represented as `map[string]interface{}`.\nThe values in the map must correspond to the [Search Attribute's value type](/concepts/what-is-a-search-attribute/#types):\n\n- Bool = `bool`\n- Datetime = `time.Time`\n- Double = `float64`\n- Int = `int64`\n- Keyword = `string`\n- Text = `string`\n\nIf you had custom Search Attributes `CustomerId` of type Keyword and `MiscData` of type Text, you would provide `string` values:\n\n```go\nfunc (c *Client) CallYourWorkflow(ctx context.Context, workflowID string, payload map[string]interface{}) error {\n    // ...\n    searchAttributes := map[string]interface{}{\n        \"CustomerId\": payload[\"customer\"],\n        \"MiscData\": payload[\"miscData\"]\n    }\n    options := client.StartWorkflowOptions{\n        SearchAttributes:   searchAttributes\n        // ...\n    }\n    we, err := c.Client.ExecuteWorkflow(ctx, options, app.YourWorkflow, payload)\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-asynchronously-complete-an-activity-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-asynchronously-complete-an-activity-in-go.md","id":"go/how-to-asynchronously-complete-an-activity-in-go","title":"How to asynchronously complete an Activity in Go","description":"Provide the external system with a Task Token to complete the Activity Execution.","label":"Asynchronous Activity Completion","tags":["how-to","go"],"markdown_content":"\n1. Provide the external system with a Task Token to complete the Activity Execution.\n   To do this, use the `GetInfo()` API from the `go.temporal.io/sdk/activity` package.\n\n```go\n// Retrieve the Activity information needed to asynchronously complete the Activity.\nactivityInfo := activity.GetInfo(ctx)\ntaskToken := activityInfo.TaskToken\n// Send the taskToken to the external service that will complete the Activity.\n```\n\n2. Return an `activity.ErrResultPending` error to indicate that the Activity is completing asynchronously.\n\n```go\nreturn \"\", activity.ErrResultPending\n```\n\n3. Use the Temporal Client to complete the Activity using the Task Token.\n\n```go\n// Instantiate a Temporal service client.\n// The same client can be used to complete or fail any number of Activities.\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n\n// Complete the Activity.\ntemporalClient.CompleteActivity(context.Background(), taskToken, result, nil)\n```\n\nThe following are the parameters of the `CompleteActivity` function:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `result`: The return value to record for the Activity. The type of this value must match the type\n  of the return value declared by the Activity function.\n- `err`: The error code to return if the Activity terminates with an error.\n\nIf `error` is not null, the value of the `result` field is ignored.\n\nTo fail the Activity, you would do the following:\n\n```go\n// Fail the Activity.\nclient.CompleteActivity(context.Background(), taskToken, nil, err)\n```\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-configure-tracing-in-go.md","id":"go/how-to-configure-tracing-in-go","title":"How to configure tracing in Go","description":"Configure tracing","label":"Configure tracing","tags":["go","how-to"],"markdown_content":"\nThe Go SDK provides support for distributed tracing through [OpenTracing](https://opentracing.io/).\nTracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.\n\nTracing can be configured by providing an [opentracing.Tracer](https://pkg.go.dev/github.com/opentracing/opentracing-go#Tracer)\nimplementation in [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions) during client instantiation.\n\nFor more details on how to configure and leverage tracing, see the [OpenTracing documentation](https://opentracing.io/docs/getting-started/).\n\nThe OpenTracing support has been validated using [Jaeger](https://www.jaegertracing.io/), but other implementations mentioned [here](https://opentracing.io/docs/supported-tracers/) should also work.\n\nTracing functionality utilizes generic context propagation provided by the Client.\n","is_empty":false},{"file_name":"how-to-connect-to-a-cluster-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-connect-to-a-cluster-in-go.md","id":"go/how-to-connect-to-a-cluster-in-go","title":"How to connect to a Temporal Cluster in Go","description":"Connect a Temporal Client to a Cluster in the Go SDK.","label":"Connect a Temporal Client","tags":["developer-guide","sdk","go"],"markdown_content":"\nUse the [`Dial()`](https://pkg.go.dev/go.temporal.io/sdk/client#Dial) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to create a new [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nIf you don't provide [`HostPort`](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions), the Client defaults the address and port number to `127.0.0.1:7233`.\n\nSet a custom Namespace name in the Namespace field on an instance of the Client Options.\n\nUse the [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#ConnectionOptions) API to connect a Client with mTLS.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\nfunc main() {\n    cert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n    if err != nil {\n        return err\n    }\n    client, err := client.Dial(client.Options{\n        HostPort:  \"your-custom-namespace.tmprl.cloud:7233\",\n        Namespace: \"your-custom-namespace\",\n        ConnectionOptions: client.ConnectionOptions{\n            TLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n        },\n    }\n    defer temporalClient.Close()\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-continue-as-new-in-go.md","id":"go/how-to-continue-as-new-in-go","title":"How to Continue-As-New-in-Go","description":"To cause a Workflow Execution to Continue-As-New, the Workflow function should return the result of the `NewContinueAsNewError()` API available from the `go.temporal.io/sdk/workflow` package.","label":"Continue-As-New","tags":["go","developer-guide"],"markdown_content":"\nTo cause a Workflow Execution to [Continue-As-New](/concepts/what-is-continue-as-new), the Workflow API should return the result of the [`NewContinueAsNewError()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#NewContinueAsNewError) function available from the `go.temporal.io/sdk/workflow` package.\n\n```go\nfunc SimpleWorkflow(ctx workflow.Context, value string) error {\n    ...\n    return workflow.NewContinueAsNewError(ctx, SimpleWorkflow, value)\n}\n```\n\nTo check whether a Workflow Execution was spawned as a result of Continue-As-New, you can check if `workflow.GetInfo(ctx).ContinuedExecutionRunID` is not empty (i.e. `\"\"`).\n\n**Notes**\n\n- To prevent Signal loss, be sure to perform an asynchronous drain on the Signal channel.\n  Failure to do so can result in buffered Signals being ignored and lost.\n- Make sure that the previous Workflow and the Continue-As-New Workflow are referenced by the same alias.\n  Failure to do so can cause the Workflow to Continue-As-New on an entirely different Workflow.\n","is_empty":false},{"file_name":"how-to-create-a-custom-data-converter-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-create-a-custom-data-converter-in-go.md","id":"go/how-to-create-a-custom-data-converter-in-go","title":"How to create a custom Data Converter in Go","description":"Wrap your custom functionality around the default Data Converter.","label":"Custom Data Converter","tags":["go","developer-guide"],"markdown_content":"\nWrap your custom functionality around the default [Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter).\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-create-a-temporal-client-in-go.md","id":"go/how-to-create-a-temporal-client-in-go","title":"How to create a Temporal Client in Go","description":"Use the `NewClient()` API available in the `go.temporal.io/sdk/client` package to create a new `Client`.","label":"Temporal Client","tags":["go","how-to"],"markdown_content":"\nUse the [`Dial()`](https://pkg.go.dev/go.temporal.io/sdk/client#Dial) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to create a new [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nIf you don't provide [`HostPort`](https://pkg.go.dev/go.temporal.io/sdk@v1.15.0/internal#ClientOptions), the Client defaults the address and port number to `127.0.0.1:7233`.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n}\n```\n\nTo connect to your Cluster, specify `HostPort` followed by your Cluster address.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{\n    HostPort: \"web.<Namespace_ID>.tmprl.cloud.\",\n  })\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-create-a-worker-session-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-create-a-worker-session-in-go.md","id":"go/how-to-create-a-worker-session-in-go","title":"How to create a Worker Session in Go","description":"First, enable Sessions on the Worker via the Worker Options and then use the `CreateSession` API to create a Context object that can be passed to the calls to spawn Activity Executions.","label":"Worker Session","tags":["go","developer-guide"],"markdown_content":"\nFirst, [enable Sessions on the Worker via the Worker Options](/go/how-to-set-workeroptions-in-go#enablesessionworker).\n\nNext, use the [`CreateSession`](https://pkg.go.dev/go.temporal.io/sdk/workflow#CreateSession) API to create a Context object that can be passed to calls to spawn Activity Executions.\n\nPass an instance of `workflow.Context` and [`SessionOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SessionOptions) to the `CreateSession` API call and get a Session Context which contains metadata information of the Session.\n\nUse the Session Context to spawn all Activity Executions that should belong to the Session.\nAll associated Activity Tasks are then processed by the same Worker Entity.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, fileID string) (err error) {\n // ...\n sessionOptions := &workflow.SessionOptions{\n   CreationTimeout:  time.Minute,\n   ExecutionTimeout: time.Minute,\n }\n sessionCtx, err := workflow.CreateSession(ctx, sessionOptions)\n if err != nil {\n   return err\n }\n defer workflow.CompleteSession(sessionCtx)\n\n var activityResult1 *ActivityResult1\n err = workflow.ExecuteActivity(sessionCtx, ActivityFunction1, param1).Get(sessionCtx, &activityResult1)\n if err != nil {\n   return err\n }\n\n var activityResult2 *ActivityResult2\n err = workflow.ExecuteActivity(sessionCtx, ActivityFunction2, *activityResult1).Get(sessionCtx, &activityResult2)\n if err != nil {\n   return err\n }\n\n return workflow.ExecuteActivity(sessionCtx, uploadFileActivityName, *activityResult2).Get(sessionCtx, nil)\n}\n```\n\nWhen the `CreateSession` API is called, the Task Queue name that is specified in the `ActivityOptions` is used (or in the `StartWorkflowOptions` if the Task Queue name is not specified in `ActivityOptions`), and a Session is created with one of the Workers polling that Task Queue.\n\nThe Session Context is cancelled if the Worker executing this Session dies or `CompleteSession()` is called.\nWhen using the returned Session Context to spawn Activity Executions, a `workflow.ErrSessionFailed` error may be returned if the Session framework detects that the Worker executing this Session has died.\nThe failure of Activity Executions won't affect the state of the Session, so you still need to handle the errors returned from your Activities and call `CompleteSession()` if necessary.\n\n`CreateSession()` will return an error if the context passed in already contains an open Session.\nIf all the Workers are currently busy and unable to handle a new Session, the framework will keep retrying until the `CreationTimeout` you specified in `SessionOptions` has passed before returning an error (check the **Concurrent Session Limitation** section for more details).\n\n`CompleteSession()` releases the resources reserved on the Worker, so it's important to call it as soon as you no longer need the Session.\nIt will cancel the session context and therefore all the Activity Executions using that Session Context.\nNote that it's safe to call `CompleteSession()` on a failed Session, meaning that you can call it from a `defer` function after the Session is successfully created.\n\n#### Session metadata\n\n```go\ntype SessionInfo struct {\n // A unique Id for the session\n SessionID         string\n // The hostname of the worker that is executing the session\n HostName          string\n // ... other unexported fields\n}\n\nfunc GetSessionInfo(ctx Context) *SessionInfo\n```\n\nThe Session Context also stores some Session metadata, which can be retrieved by the `GetSessionInfo()` API.\nIf the Context passed in doesn't contain any Session metadata, this API will return a `nil` pointer.\n\n#### Limiting concurrent Sessions\n\nTo limit the number of concurrent Sessions running on a Worker, set the `MaxConcurrentSessionExecutionSize` field of `worker.Options` to the desired value.\nBy default, this field is set to a very large value, so there's no need to manually set it if no limitation is needed.\n\nIf a Worker hits this limitation, it won't accept any new `CreateSession()` requests until one of the existing sessions is completed. `CreateSession()` will return an error if the session can't be created within `CreationTimeout`.\n\n#### Recreate Session\n\nFor long-running Sessions, you may want to use the `ContinueAsNew` feature to split the Workflow into multiple runs when all Activities need to be executed by the same Worker.\nThe `RecreateSession()` API is designed for such a use case.\n\n```go\nfunc RecreateSession(ctx Context, recreateToken []byte, sessionOptions *SessionOptions) (Context, error)\n```\n\nIts usage is the same as `CreateSession()` except that it also takes in a `recreateToken`, which is needed to create a new Session on the same Worker as the previous one.\nYou can get the token by calling the `GetRecreateToken()` method of the `SessionInfo` object.\n\n```go\ntoken := workflow.GetSessionInfo(sessionCtx).GetRecreateToken()\n```\n\n**Is there a complete example?**\n\nYes, the [file processing example](https://github.com/temporalio/samples-go/tree/master/fileprocessing) in the [temporalio/samples-go](https://github.com/temporalio/samples-go) repo has been updated to use the session framework.\n\n**What happens to my Activity if the Worker dies?**\n\nIf your Activity has already been scheduled, it will be canceled.\nIf not, you will get a `workflow.ErrSessionFailed` error when you call `workflow.ExecuteActivity()`.\n\n**Is the concurrent session limitation per process or per host?**\n\nIt's per Worker Process, so make sure there's only one Worker Process running on the host if you plan to use this feature.\n\n**Future Work**\n\n- Right now, a Session is considered failed if the Worker Process dies.\n  However, for some use cases, you may only care whether the Worker host is alive or not.\n  For these use cases, the Session should be automatically re-established if the Worker Process is restarted.\n\n- The current implementation assumes that all Sessions are consuming the same type of resource and there's only one global limitation.\n  Our plan is to allow you to specify what type of resource your Session will consume and enforce different limitations on different types of resources.\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-customize-activity-type-in-go.md","id":"go/how-to-customize-activity-type-in-go","title":"How to customize Activity Type in Go","description":"To customize the Workflow Type set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.","label":"Customize Activity Type","tags":["developer-guide","go"],"markdown_content":"\nTo customize the Activity Type, set the `Name` parameter with `RegisterOptions` when registering your Activity with a Worker.\n\n- Type: `string`\n- Default: function name\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  Name: \"YourActivityName\",\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-customize-workflow-type-in-go.md","id":"go/how-to-customize-workflow-type-in-go","title":"How to customize Workflow Type in Go","description":"To customize the Workflow Type set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.","label":"Customize Workflow Type","tags":["developer-guide","go"],"markdown_content":"\nTo customize the Workflow Type, set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.\n\n- Type: `string`\n- Default: function name\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := workflow.RegisterOptions{\n  Name: \"YourWorkflowName\",\n  // ...\n}\nw.RegisterWorkflowWithOptions(YourWorkflowDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-define-a-query-type-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-define-a-query-type-in-go.md","id":"go/how-to-define-a-query-type-in-go","title":"How to define a Query Type in Go","description":"A Query type, also called a Query name, is a `string` value.","label":"Query type","tags":["go","how-to"],"markdown_content":"\nIn Go, a Query type, also called a Query name, is a `string` value.\n\n```go\nqueryType := \"your_query_name\"\n```\n","is_empty":false},{"file_name":"how-to-emit-metrics-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-emit-metrics-in-go.md","id":"go/how-to-emit-metrics-in-go","title":"How to emit metrics in Go","description":"Emit metrics","label":"Emit metrics","tags":["go","how-to"],"markdown_content":"\nTo emit metrics from the Temporal Client in Go, create a [metrics handler](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler) from the [Client Options](https://pkg.go.dev/go.temporal.io/sdk@v1.15.0/internal#ClientOptions) and specify a listener address to be used by Prometheus.\n\n```go\nclient.Options{\n\t\tMetricsHandler: sdktally.NewMetricsHandler(newPrometheusScope(prometheus.Configuration{\n\t\t\tListenAddress: \"0.0.0.0:9090\",\n\t\t\tTimerType:     \"histogram\",\n\t\t}\n```\n\nThe Go SDK currently supports the [Tally](https://pkg.go.dev/go.temporal.io/sdk/contrib/tally) library; however, Tally offers [extensible custom metrics reporting](https://github.com/uber-go/tally#report-your-metrics), which is exposed through the [`WithCustomMetricsReporter`](/references/server-options#withcustommetricsreporter) API.\n\nFor more information, see the [Go sample for metrics](https://github.com/temporalio/samples-go/tree/main/metrics).\n","is_empty":false},{"file_name":"how-to-execute-a-side-effect-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-execute-a-side-effect-in-go.md","id":"go/how-to-execute-a-side-effect-in-go","title":"How to execute a Side Effect in Go","description":"Use the SideEffect API from the `go.temporal.io/sdk/workflow` package to execute a Side Effect directly in your Workflow.","label":"Side Effect","tags":["developer-guide","go"],"markdown_content":"\nUse the [`SideEffect`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SideEffect) function from the `go.temporal.io/sdk/workflow` package to execute a [Side Effect](/concepts/what-is-a-side-effect) directly in your Workflow.\n\nPass it an instance of `context.Context` and the function to execute.\n\nThe `SideEffect` API returns a Future, an instance of [`converter.EncodedValue`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SideEffect).\n\nUse the `Get` method on the Future to retrieve the result of the Side Effect.\n\n**Correct implementation**\n\nThe following example demonstrates the correct way to use `SideEffect`:\n\n```go\nencodedRandom := workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {\n return rand.Intn(100)\n})\n\nvar random int\nencodedRandom.Get(&random)\n// ...\n}\n```\n\n**Incorrect implementation**\n\nThe following example demonstrates how NOT to use `SideEffect`:\n\n```go\n// Warning: This is an incorrect example.\n// This code is nondeterministic.\nvar random int\nworkflow.SideEffect(func(ctx workflow.Context) interface{} {\n      random = rand.Intn(100)\n      return nil\n})\n// random will always be 0 in replay, so this code is nondeterministic.\n```\n\nOn replay the provided function is not executed, the random number will always be 0, and the Workflow Execution could take a different path, breaking determinism.\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-handle-a-query-in-a-workflow-in-go.md","id":"go/how-to-handle-a-query-in-a-workflow-in-go","title":"How to handle a Query in a Workflow in Go","description":"Use the `SetQueryHandler` API to set a Query Handler that listens for a Query by name.","label":"Handling Queries","tags":["go","how-to"],"markdown_content":"\nUse the `SetQueryHandler` API from the `go.temporal.io/sdk/workflow` package to set a Query Handler that listens for a Query by name.\n\nThe handler must be a function that returns two values:\n\n1. A serializable result\n2. An error\n\nThe handler function can receive any number of input parameters, but all input parameters must be serializable.\nThe following sample code sets up a Query Handler that handles the `current_state` Query type:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n  currentState := \"started\" // This could be any serializable struct.\n  queryType := \"current_state\"\n  err := workflow.SetQueryHandler(ctx, queryType, func() (string, error) {\n    return currentState, nil\n  })\n  if err != nil {\n    currentState = \"failed to register query handler\"\n    return err\n  }\n  // Your normal Workflow code begins here, and you update the currentState as the code makes progress.\n  currentState = \"waiting timer\"\n  err = NewTimer(ctx, time.Hour).Get(ctx, nil)\n  if err != nil {\n    currentState = \"timer failed\"\n    return err\n  }\n  currentState = \"waiting activity\"\n  ctx = WithActivityOptions(ctx, yourActivityOptions)\n  err = ExecuteActivity(ctx, YourActivity, \"your_input\").Get(ctx, nil)\n  if err != nil {\n    currentState = \"activity failed\"\n    return err\n  }\n  currentState = \"done\"\n  return nil\n}\n```\n\nFor example, suppose your query handler function takes two parameters:\n\n```go\nerr := workflow.SetQueryHandler(ctx, \"current_state\", func(prefix string, suffix string) (string, error) {\n    return prefix + currentState + suffix, nil\n})\n```\n","is_empty":false},{"file_name":"how-to-list-workflow-executions-using-the-client-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-list-workflow-executions-using-the-client-in-go.md","id":"go/how-to-list-workflow-executions-using-the-client-in-go","title":"How to list Workflow Executions using the Client in Go","description":"List Workflow Executions using the Client","label":"List Workflow Executions using the Client","tags":["developer-guide","go","client"],"markdown_content":"\nUse [`Client.ListWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/client#Client.ListWorkflow).\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-log-from-a-workflow-in-go.md","id":"go/how-to-log-from-a-workflow-in-go","title":"How to log from a Workflow in TypeScript","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","go","log"],"markdown_content":"\nIn Workflow Definitions you can use [`workflow.GetLogger(ctx)`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLogger) to write logs.\n\n```go\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"go.temporal.io/sdk/activity\"\n\t\"go.temporal.io/sdk/workflow\"\n)\n\n// Workflow is a standard workflow definition.\n// Note that the Workflow and Activity don't need to care that\n// their inputs/results are being compressed.\nfunc Workflow(ctx workflow.Context, name string) (string, error) {\n// ...\n\nworkflow.WithActivityOptions(ctx, ao)\n\n// Getting the logger from the context.\n\tlogger := workflow.GetLogger(ctx)\n// Logging a message with the key value pair `name` and `name`\n\tlogger.Info(\"Compressed Payloads workflow started\", \"name\", name)\n\n\tinfo := map[string]string{\n\t\t\"name\": name,\n\t}\n\n\n\tlogger.Info(\"Compressed Payloads workflow completed.\", \"result\", result)\n\n\treturn result, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-remove-search-attributes-from-a-workflow-in-go.md","id":"go/how-to-remove-search-attributes-from-a-workflow-in-go","title":"How to remove Search Attributes from a Workflow in Go","description":"How to remove Search Attributes from a Workflow","label":"How to remove Search Attributes from a Workflow","tags":["developer-guide","go"],"markdown_content":"\n**There is no support for removing a field.**\n\nHowever, to achieve a similar effect, set the field to some placeholder value.\nFor example, you could set `CustomKeywordField` to `impossibleVal`.\nThen searching `CustomKeywordField != 'impossibleVal'` will match Workflows with `CustomKeywordField` not equal to `impossibleVal`, which includes Workflows without the `CustomKeywordField` set.\n","is_empty":false},{"file_name":"how-to-replay-a-workflow-execution-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-replay-a-workflow-execution-in-go.md","id":"go/how-to-replay-a-workflow-execution-in-go","title":"How to replay a Workflow Execution in Go","description":"Use the `WorkflowReplayer` API to replay an existing Workflow Execution from an Event History to replicate errors.","label":"WorkflowReplayer","tags":["go","how-to"],"markdown_content":"\nUse the [worker.WorkflowReplayer](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowReplayer) to replay an existing Workflow Execution from its Event History to replicate errors.\n\nFor example, the following code retrieves the Event History of a Workflow:\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/api/enums/v1\"\n\t\"go.temporal.io/api/history/v1\"\n\t\"go.temporal.io/sdk/client\"\n)\n\nfunc GetWorkflowHistory(ctx context.Context, client client.Client, id, runID string) (*history.History, error) {\n\tvar hist history.History\n\titer := client.GetWorkflowHistory(ctx, id, runID, false, enums.HISTORY_EVENT_FILTER_TYPE_ALL_EVENT)\n\tfor iter.HasNext() {\n\t\tevent, err := iter.Next()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thist.Events = append(hist.Events, event)\n\t}\n\treturn &hist, nil\n}\n```\n\nThis history can then be used to _replay_.\nFor example, the following code creates a `WorkflowReplayer` and register the `YourWorkflow` Workflow function.\nThen it calls the `ReplayWorkflowHistory` to _replay_ the Event History and return an error code.\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n)\n\nfunc ReplayWorkflow(ctx context.Context, client client.Client, id, runID string) error {\n\thist, err := GetWorkflowHistory(ctx, client, id, runID)\n\tif err != nil {\n\t\treturn err\n\t}\n\treplayer := worker.NewWorkflowReplayer()\n\treplayer.RegisterWorkflow(YourWorkflow)\n\treturn replayer.ReplayWorkflowHistory(nil, hist)\n}\n```\n\nThe code above will cause the Worker to re-execute the Workflow's Workflow Function using the original Event History.\nIf a noticeably different code path was followed or some code caused a deadlock, it will be returned in the error code.\nReplaying a Workflow Execution locally is a good way to see exactly what code path was taken for given input and events.\n","is_empty":false},{"file_name":"how-to-request-cancellation-of-a-workflow-execution-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-request-cancellation-of-a-workflow-execution-in-go.md","id":"go/how-to-request-cancellation-of-a-workflow-execution-in-go","title":"How to request Cancellation of a Workflow Execution in Go","description":"Use the `CancelWorkflow` API to cancel a Workflow Execution using its Id.","tags":["developer-guide","go"],"markdown_content":"\nUse the `CancelWorkflow` API to cancel a Workflow Execution using its Id.\n\n<!--SNIPSTART samples-go-cancellation-cancel-workflow-execution-trigger-->\n[cancellation/cancel/main.go](https://github.com/temporalio/samples-go/blob/master/cancellation/cancel/main.go)\n```go\nfunc main() {\n\tvar workflowID string\n\tflag.StringVar(&workflowID, \"wid\", \"workflowID-to-cancel\", \"workflowID of the Workflow Execution to be canceled.\")\n\tflag.Parse()\n\n\tif workflowID == \"\" {\n\t\tflag.PrintDefaults()\n\t\treturn\n\t}\n\n\t// The client is a heavyweight object that should be created once per process.\n\tc, err := client.Dial(client.Options{\n\t\tHostPort: client.DefaultHostPort,\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create client\", err)\n\t}\n\tdefer c.Close()\n\n\terr = c.CancelWorkflow(context.Background(), workflowID, \"\")\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to cancel Workflow Execution\", err)\n\t}\n\tlog.Println(\"Workflow Execution cancelled\", \"WorkflowID\", workflowID)\n}\n\n```\n<!--SNIPEND-->\n\n#### How to clean up after a Workflow is cancelled\n\nWorkflow Definitions can be written to handle execution cancellation requests with Go's `defer` and the `workflow.NewDisconnectedContext` API.\nIn the Workflow Definition below, there is a special Activity that handles clean up should the execution be cancelled.\n\n<!--SNIPSTART samples-go-cancellation-workflow-definition-->\n[cancellation/workflow.go](https://github.com/temporalio/samples-go/blob/master/cancellation/workflow.go)\n```go\n// YourWorkflow is a Workflow Definition that shows how it can be canceled.\nfunc YourWorkflow(ctx workflow.Context) error {\n\tao := workflow.ActivityOptions{\n\t\tStartToCloseTimeout: 30 * time.Minute,\n\t\tHeartbeatTimeout:    5 * time.Second,\n\t\tWaitForCancellation: true,\n\t}\n\tctx = workflow.WithActivityOptions(ctx, ao)\n\tlogger := workflow.GetLogger(ctx)\n\tlogger.Info(\"cancel workflow started\")\n\tvar a *Activities // Used to call Activities by function pointer\n\tdefer func() {\n\t\t\n\t\tif !errors.Is(ctx.Err(), workflow.ErrCanceled) {\n\t\t\treturn\n\t\t}\n\t\t\n\t\t// When the Workflow is canceled, it has to get a new disconnected context to execute any Activities\n\t\tnewCtx, _ := workflow.NewDisconnectedContext(ctx)\n\t\terr := workflow.ExecuteActivity(newCtx, a.CleanupActivity).Get(ctx, nil)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"CleanupActivity failed\", \"Error\", err)\n\t\t}\n\t}()\n\n\tvar result string\n\terr := workflow.ExecuteActivity(ctx, a.ActivityToBeCanceled).Get(ctx, &result)\n\tlogger.Info(fmt.Sprintf(\"ActivityToBeCanceled returns %v, %v\", result, err))\n\n\terr = workflow.ExecuteActivity(ctx, a.ActivityToBeSkipped).Get(ctx, nil)\n\tlogger.Error(\"Error from ActivityToBeSkipped\", \"Error\", err)\n\n\tlogger.Info(\"Workflow Execution complete.\")\n\n\treturn nil\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-execution-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-send-a-query-to-a-workflow-execution-in-go.md","id":"go/how-to-send-a-query-to-a-workflow-execution-in-go","title":"How to send a Query to a Workflow Execution in Go","description":"Use the `QueryWorkflow()` API to send a Query to a Workflow in Go.","label":"Sending Queries","tags":["go","how-to"],"markdown_content":"\nUse the `QueryWorkflow()` API or the `QueryWorkflowWithOptions` API on the Temporal Client to send a Query to a Workflow Execution.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType)\nif err != nil {\n  // ...\n}\n// ...\n```\n\nYou can pass an arbitrary number of arguments to the `QueryWorkflow()` function.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType, \"foo\", \"baz\")\nif err != nil {\n  // ...\n}\n// ...\n```\n\nThe `QueryWorkflowWithOptions()` API provides similar functionality, but with the ability to set additional configurations through [QueryWorkflowWithOptionsRequest](https://pkg.go.dev/go.temporal.io/sdk/client#QueryWorkflowWithOptionsRequest).\nWhen using this API, you will also receive a structured response of type [QueryWorkflowWithOptionsResponse](https://pkg.go.dev/go.temporal.io/sdk/client#QueryWorkflowWithOptionsResponse).\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflowWithOptions(context.Background(), &client.QueryWorkflowWithOptionsRequest{\n    WorkflowID: workflowID,\n    RunID: runID,\n    QueryType: queryType,\n    Args: args,\n})\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-cron-schedule-in-go.md","id":"go/how-to-set-a-cron-schedule-in-go","title":"How to set a Cron Schedule in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `CronSchedule` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Cron Schedule","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `CronSchedule` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-custom-logger-in-go.md","id":"go/how-to-set-a-custom-logger-in-go","title":"How to set a custom logger in Go","description":"Set a custom logger","label":"Custom logger","tags":["go","how-to"],"markdown_content":"\nThis field sets a custom Logger that is used for all logging actions of the instance of the Temporal Client.\n\nAlthough the Go SDK does not support most third-party logging solutions natively, [our friends at Banzai Cloud](https://github.com/sagikazarmark) built the adapter package [logur](https://github.com/logur/logur) which makes it possible to use third party loggers with minimal overhead.\nMost of the popular logging solutions have existing adapters in Logur, but you can find a full list [in the Logur Github project](https://github.com/logur?q=adapter-).\n\nHere is an example of using Logur to support [Logrus](https://github.com/sirupsen/logrus):\n\n```go\npackage main\nimport (\n  \"go.temporal.io/sdk/client\"\n\n\t\"github.com/sirupsen/logrus\"\n\tlogrusadapter \"logur.dev/adapter/logrus\"\n\t\"logur.dev/logur\"\n)\n\nfunc main() {\n  // ...\n  logger := logur.LoggerToKV(logrusadapter.New(logrus.New()))\n  clientOptions := client.Options{\n    Logger: logger,\n  }\n  temporalClient, err := client.Dial(clientOptions)\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-heartbeat-timeout-in-go.md","id":"go/how-to-set-a-heartbeat-timeout-in-go","title":"How to set a Heartbeat Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `HeartbeatTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Retry Policy","tags":["go","how-to"],"markdown_content":"\nTo set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout), Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  HeartbeatTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-parent-close-policy-in-go.md","id":"go/how-to-set-a-parent-close-policy-in-go","title":"How to set a Parent Close Policy in Go","description":"Create an instance of `ChildWorkflowOptions` from the `go.temporal.io/sdk/workflow` package, set the `ParentClosePolicy` field, apply the options to the instance of `workflow.Context`, and pass the context to the `ExecuteChildWorkflow` call.","label":"Parent Close Policy","tags":["go","how-to"],"markdown_content":"\nIn Go, a Parent Close Policy is set on the `ParentClosePolicy` field of an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions).\nThe possible values can be obtained from the [`go.temporal.io/api/enums/v1`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy) package.\n\n- `PARENT_CLOSE_POLICY_ABANDON`\n- `PARENT_CLOSE_POLICY_TERMINATE`\n- `PARENT_CLOSE_POLICY_REQUEST_CANCEL`\n\nThe Child Workflow Options are then applied to the instance of `workflow.Context` by using the `WithChildOptions` API, which is then passed to the `ExecuteChildWorkflow()` call.\n\n- Type: [`ParentClosePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy)\n- Default: `PARENT_CLOSE_POLICY_ABANDON`\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n  // ...\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    // ...\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // ...\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-schedule-to-close-timeout-in-go.md","id":"go/how-to-set-a-schedule-to-close-timeout-in-go","title":"How to set a Schedule-To-Close Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Schedule-To-Close Timeout","tags":["go","how-to"],"markdown_content":"\nTo set a [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `time.Duration`\n- Default: ∞ (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-schedule-to-start-timeout-in-go.md","id":"go/how-to-set-a-schedule-to-start-timeout-in-go","title":"How to set a Schedule-To-Start Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Schedule-To-Close Timeout","tags":["go","how-to"],"markdown_content":"\nTo set a [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: `time.Duration`\n- Default: ∞ (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-start-to-close-timeout-in-go.md","id":"go/how-to-set-a-start-to-close-timeout-in-go","title":"How to set a Start-To-Close Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Start-To-Close Timeout","tags":["go","how-to"],"markdown_content":"\nTo set a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `time.Duration`\n- Default: Same as the `ScheduleToCloseTimeout`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  StartToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-execution-timeout-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-workflow-execution-timeout-in-go.md","id":"go/how-to-set-a-workflow-execution-timeout-in-go","title":"How to set a Workflow Execution Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Execution Timeout","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  WorkflowExecutionTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-workflow-id-in-go.md","id":"go/how-to-set-a-workflow-id-in-go","title":"How to set a custom Workflow Id in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Id","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: System generated UUID\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  ID: \"Your-Custom-Workflow-Id\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-retry-policy-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-workflow-retry-policy-in-go.md","id":"go/how-to-set-a-workflow-retry-policy-in-go","title":"How to set a Workflow Retry Policy in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `RetryPolicy` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Retry Policy","tags":["go","how-to"],"markdown_content":"\nCreate an instance of a [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy) from the `go.temporal.io/sdk/temporal` package and provide it as the value to the `RetryPolicy` field of the instance of `StartWorkflowOptions`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default: None\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\nworkflowOptions := client.StartWorkflowOptions{\n  RetryPolicy: retrypolicy,\n  // ...\n}\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-run-timeout-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-workflow-run-timeout-in-go.md","id":"go/how-to-set-a-workflow-run-timeout-in-go","title":"How to set a Workflow Run Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Run Timeout","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Same as [`WorkflowExecutionTimeout`](#workflowexecutiontimeout)\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowRunTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-workflow-task-queue-in-go.md","id":"go/how-to-set-a-workflow-task-queue-in-go","title":"How to set the Task Queue for Workflow Execution in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Task Queue","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None, this is a required field to be set by the developer\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  TaskQueue: \"your-task-queue\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-timeout-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-a-workflow-task-timeout-in-go.md","id":"go/how-to-set-a-workflow-task-timeout-in-go","title":"How to set a Workflow Task Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Task Timeout","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: `time.Seconds * 10`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowTaskTimeout: time.Second * 10,\n  //...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-activity-timeouts-in-go.md","id":"go/how-to-set-activity-timeouts-in-go","title":"How to set Activity Timeouts in Go","description":"Create an instance of StartWorkflowOptions.","label":"Activity Timeouts","tags":["go","how-to"],"markdown_content":"\nTo set an Activity Timeout in Go, create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the Activity Timeout field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nAvailable timeouts are:\n\n- `StartToCloseTimeout`\n- `ScheduleToClose`\n- `ScheduleToStartTimeout`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  // Set Activity Timeout duration\n  ScheduleToCloseTimeout: 10 * time.Second,\n  // StartToCloseTimeout: 10 * time.Second,\n  // ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-an-activity-retry-policy-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-an-activity-retry-policy-in-go.md","id":"go/how-to-set-an-activity-retry-policy-in-go","title":"How to set an Activity Retry Policy in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Retry Policy","tags":["go","how-to"],"markdown_content":"\nTo set a [RetryPolicy](/concepts/what-is-a-retry-policy), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default:\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100, // 100 * InitialInterval\n  MaximumAttempts: 0, // Unlimited\n  NonRetryableErrorTypes: []string, // empty\n}\n```\n\nProviding a Retry Policy here is a customization, and overwrites individual Field defaults.\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\n\nactivityoptions := workflow.ActivityOptions{\n  RetryPolicy: retrypolicy,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-childworkflowoptions-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-childworkflowoptions-in-go.md","id":"go/how-to-set-childworkflowoptions-in-go","title":"How to set ChildWorkflowOptions in Go","description":"Used to set all Child Workflow Execution specific options","label":"ChildWorkflowOptions","tags":["go","developer-guide"],"markdown_content":"\nUsed to set all Child Workflow specific options\n\n| Field                    | Description                                                                       | Type                   |\n| ------------------------ | --------------------------------------------------------------------------------- | ---------------------- |\n| Namespace                | Set the namespace of the Child Workflow Execution                                 | string                 |\n| WorkflowID               | Set the Id of the Child Workflow to be scheduled                                  | string                 |\n| TaskQueue                | Set Task Queue that the Child Workflow needs to be scheduled on                   | string                 |\n| WorkflowExecutionTimeout | Set the end to end timeout for the Child Workflow Execution including retries     | time.Duration          |\n| WorkflowRunTimeout       | Set the timeout for a single run of the Child Workflow Execution                  | time.Duration          |\n| WorkflowTaskTimeout      | Set the maximum execution time of a single Workflow Task                          | time.Duration          |\n| WaitForCancellation      | Set to wait for canceled Child Workflow to be ended                               | bool                   |\n| WorkflowIDReusePolicy    | Set if server allow reuse of Workflow Id                                          | WorkflowIdReusePolicy  |\n| RetryPolicy              | Set how to retry Child Workflow if error happens                                  | RetryPolicy            |\n| CronSchedule             | Set the cron schedule for Child Workflow                                          | string                 |\n| Memo                     | Set non-indexed info that will be shown in list Child Workflow                    | map[string]interface{} |\n| SearchAttributes         | Set indexed info that can be used in query of List/Scan/Count Child Workflow APIs | map[string]interface{} |\n| ParentClosePolicy        | Set policy to decide what to do for the child when the parent closes              | ParentClosePolicy      |\n\n### Parent Close Policy\n\nimport ParentClosePolicy from './how-to-set-a-parent-close-policy-in-go.md'\n\n<ParentClosePolicy/>\n","is_empty":false},{"file_name":"how-to-set-clientoptions-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-clientoptions-in-go.md","id":"go/how-to-set-clientoptions-in-go","title":"How to set ClientOptions in Go","description":"Create an instance of `Options` from the `go.temporal.io/sdk/client` package and pass it the call to create a new Temporal Client.","label":"ClientOptions","tags":["go","developer-guide"],"markdown_content":"\nCreate an instance of [`Options`](https://pkg.go.dev/go.temporal.io/sdk/client#Options) from the `go.temporal.io/sdk/client` package and pass it the call to create a new Temporal Client.\n\n| Field                                       | Required | Type                                                                                       |\n| ------------------------------------------- | -------- | ------------------------------------------------------------------------------------------ |\n| [`HostPort`](#hostport)                     | No       | `string`                                                                                   |\n| [`Namespace`](#namespace)                   | No       | `string`                                                                                   |\n| [`Logger`](#logger)                         | No       | [`log.Logger`](https://pkg.go.dev/go.temporal.io/sdk/log#Logger)                           |\n| [`MetricsHandler`](#metricshandler)         | No       | [`metrics.Handler`](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler) |\n| [`Identity`](#identify)                     | No       | `string`                                                                                   |\n| [`DataConverter`](#dataconverter)           | No       | [`converter.DataConverter`](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter) |\n| [`ContextPropagators`](#contextpropagators) | No       | [`[]ContextPropagator`](https://pkg.go.dev/go.temporal.io/sdk/internal#ContextPropagator)  |\n| [`ConnectionOptions`](#connectionoptions)   | No       | [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/internal#ConnectionOptions)    |\n| [`HeadersProvider`](#headersprovider)       | No       | [`HeadersProvider`](https://pkg.go.dev/go.temporal.io/sdk/internal#HeadersProvider)        |\n| [`TrafficController`](#trafficcontroller)   | No       | [`TrafficController`](https://pkg.go.dev/go.temporal.io/sdk/internal#TrafficController)    |\n| [`Interceptors`](#interceptors)             | No       | [`[]ClientInterceptor`](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientInterceptor)  |\n\n### `HostPort`\n\n**How to set the Temporal Client's host:port connection in Go**\n\n- Type: `string`\n- Default: [`client.DefaultHostPort`](https://pkg.go.dev/go.temporal.io/sdk/client#pkg-constants) (127.0.0.1:7233)\n\n```go\nclientOptions := client.Options{\n  HostPort: client.DefaultHostPort,\n}\ntemporalClient, err := client.Dial(clientOptions)\n```\n\nThe `HostPort` value is a gRPC address and therefore can also support a special-formatted address of `<resolver>:///<value>` that will use a registered resolver.\nBy default all hosts returned from the resolver will be used in a round-robin fashion.\n\nThe \"dns\" resolver is registered by default.\nUsing a `dns:///` prefixed address will cause a periodic round-robin resolution of all IPs for all DNS addresses.\n\nA custom resolver can be created to provide multiple hosts in other ways.\nFor example, to manually provide multiple IPs to round-robin across, a `google.golang.org/grpc/resolver/` manual resolver can be created and registered with a custom scheme:\n\n```go\nbuilder := manual.NewBuilderWithScheme(\"myresolver\")\nbuilder.InitialState(resolver.State{Addresses: []resolver.Address{{Addr: \"1.2.3.4:1234\"},{Addr: \"2.3.4.5:2345\"}}})\nresolver.Register(builder)\ntemporalClient, err := client.Dial(client.Options{HostPort: \"myresolver:///ignoredvalue\"})\n```\n\nOther more advanced resolvers can also be registered.\n\n### `Namespace`\n\nimport Namespace from './how-to-set-the-namespace-for-a-temporal-client-in-go.md'\n\n<Namespace/>\n\n### `Logger`\n\n**How to use a custom logger in Go**\n\nThis field sets a custom Logger that is used for all logging actions of the instance of the Temporal Client.\n\nAlthough the Go SDK does not support most third-party logging solutions natively, [our friends at Banzai Cloud](https://github.com/sagikazarmark) built the adapter package [logur](https://github.com/logur/logur) which makes it possible to use third party loggers with minimal overhead.\nMost of the popular logging solutions have existing adapters in Logur, but you can find a full list [in the Logur Github project](https://github.com/logur?q=adapter-).\n\nHere is an example of using Logur to support [Logrus](https://github.com/sirupsen/logrus):\n\n```go\npackage main\nimport (\n  \"go.temporal.io/sdk/client\"\n\n\t\"github.com/sirupsen/logrus\"\n\tlogrusadapter \"logur.dev/adapter/logrus\"\n\t\"logur.dev/logur\"\n)\n\nfunc main() {\n  // ...\n  logger := logur.LoggerToKV(logrusadapter.New(logrus.New()))\n  clientOptions := client.Options{\n    Logger: logger,\n  }\n  temporalClient, err := client.Dial(clientOptions)\n  // ...\n}\n```\n\n### `MetricsHandler`\n\nSets the metric scope, which metrics should be reported\n\n- Type: [`metrics.Handler`](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler)\n- Default: None\n\n### `Identity`\n\nSets an identify that can be used to track this host for debugging\n\n### `DataConverter`\n\nSets DataConverter to customize serialization/deserialization of arguments in Temporal\n\n- Type: [`converter.DataConverter`](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter)\n\n### `ContextPropagators`\n\nSets ContextPropagators that allows users to control the context information passed through a Workflow\n\n- Type: `[]ContextPropagator`\n\n### `ConnectionOptions`\n\nSets options for server connection that allow users to control features of connections such as TLS settings\n\n- Type: `ConnectionOptions`\n\n### `HeadersProvider`\n\nSets custom request headers\n\n- Type: `HeadersProvider`\n\n### `TrafficController`\n\nSet to induce artificial failures in test scenarios\n\n- Type: `TrafficController`\n\n### `Interceptors`\n\ngRPC interceptors that are applied to every RPC call performed by this connection.\nBy default, an interceptor is included; it automatically retries retryable errors.\nIf you do not want to perform automatic retries, set this to an empty list (or a list with your own interceptors).\n\n- Type: `[]ClientInterceptor`\n","is_empty":false},{"file_name":"how-to-set-connectionoptions-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-connectionoptions-in-go.md","id":"go/how-to-set-connectionoptions-in-go","title":"How to set ConnectionOptions in Go","description":"Options to control optional connection params","label":"ConnectionOptions","tags":["go","developer-guide"],"markdown_content":"\n- Options to control optional connection params\n\n| Option                       | Description                                                                   | Type          |\n| ---------------------------- | ----------------------------------------------------------------------------- | ------------- |\n| TLS                          | Configures connection level security credentials                              | tls.Config    |\n| Authority                    | Set the value to be used as the :authority pseudo-header                      | string        |\n| DisableHealthCheck           | Disable health check                                                          | bool          |\n| HealthCheckAttemptTimeout    | Specify how to long to wait for service response on each health check attempt | time.Duration |\n| HealthCheckTimeout           | Set the default health check timeout                                          | time.Duration |\n| EnableKeepAliveCheck         | Set enable keep alive check                                                   | bool          |\n| KeepAliveTime                | Set the keep alive time                                                       | time.Duration |\n| KeepAliveTimeout             | Set the keep alive timeout                                                    | time.Duration |\n| KeepAlivePermitWithoutStream | Set if client sends keepalive pings even with no active RPCs                  | bool          |\n","is_empty":false},{"file_name":"how-to-set-executelocalactivityoptions-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-executelocalactivityoptions-in-go.md","id":"go/how-to-set-executelocalactivityoptions-in-go","title":"How to set ExecuteLocalActivityOptions in Go","description":"Used to set local activity specific parameters that will be stored inside of a context","label":"ExecuteLocalActivityOptions","tags":["go","developer-guide"],"markdown_content":"\n- Used to set local activity specific parameters that will be stored inside a context\n\n| Option                 | Description                                                         | Type          |\n| ---------------------- | ------------------------------------------------------------------- | ------------- |\n| ScheduleToCloseTimeout | Set the end to end timeout for the local activity including retries | time.Duration |\n| StartToCloseTimeout    | Set timeout for a single execution of the local activity            | time.Duration |\n| RetryPolicy            | Set how to retry Activity if error happens                          | time.Duration |\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-mtls-configuration-in-go.md","id":"go/how-to-set-mtls-configuration-in-go","title":"How to set mTLS configuration in Go","description":"Use the `ConnectionOptions` API available in the `go.temporal.io/sdk/client` package to connect a Client with mTLS.","label":"Set mTLS configuration","tags":["developer-guide","sdk","Go"],"markdown_content":"\nUse the [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#ConnectionOptions) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to connect a Client with mTLS.\n\n```go\n\tcert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tclient, err := client.Dial(client.Options{\n\t\tHostPort:  \"foo.bar.tmprl.cloud:7233\",\n\t\tNamespace: \"foo.bar\",\n\t\tConnectionOptions: client.ConnectionOptions{\n\t\t\tTLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n\t\t},\n\t})\n```\n","is_empty":false},{"file_name":"how-to-set-mutable-side-effects-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-mutable-side-effects-in-go.md","id":"go/how-to-set-mutable-side-effects-in-go","title":"How to set Mutable Side Effects in Go","description":"To use MutableSideEffect() in Go, provide the Workflow Id.","label":"Set Mutable Side Effects","tags":["developer-guide","sdk","Go"],"markdown_content":"\nTo use [`MutableSideEffect()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#MutableSideEffect) in Go, provide a unique name within the scope of the workflow.\n\n```go\nif err := workflow.MutableSideEffect(ctx, \"configureNumber\", get, eq).Get(&number); err != nil {\n    panic(\"can't decode number:\" + err.Error())\n  }\n```\n","is_empty":false},{"file_name":"how-to-set-registeractivityoptions-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-registeractivityoptions-in-go.md","id":"go/how-to-set-registeractivityoptions-in-go","title":"How to set RegisterActivityOptions in Go","description":"Create an instance of `RegisterOptions` from the `go.temporal.io/sdk/activity` package and pass it to the `RegisterActivityWithOptions` call when registering the Activity Type with the Worker.","label":"RegisterActivityOptions","tags":["developer-guide"],"markdown_content":"\nCreate an instance of [`RegisterOptions`](https://pkg.go.dev/go.temporal.io/sdk/activity#RegisterOptions) from the `go.temporal.io/sdk/activity` package and pass it to the [`RegisterActivityWithOptions`](https://pkg.go.dev/go.temporal.io/sdk/worker#ActivityRegistry) call when registering the Activity Type with the Worker.\n\nOptions for registering an Activity\n\n| Field                                                             | Required | Type     |\n| ----------------------------------------------------------------- | -------- | -------- |\n| [`Name`](#name)                                                   | No       | `string` |\n| [`DisableAlreadyRegisteredCheck`](#disablealreadyregisteredcheck) | No       | `bool`   |\n| [`SkipInvalidStructFunctions`](#skipinvalidstructfunctions)       | No       | `bool`   |\n\n### `Name`\n\nimport CustomizeActivityType from './how-to-customize-activity-type-in-go.md'\n\n<CustomizeActivityType/>\n\n### `DisableAlreadyRegisteredCheck`\n\nDisables the check to see if the Activity has already been registered.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  DisableAlreadyRegisteredCheck: false,\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n\n### `SkipInvalidStructFunctions`\n\nWhen registering a struct that has Activities, skip functions that are not valid.\nIf false, registration panics.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  SkipInvalidStructFunctions: false,\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-registerworkflowoptions-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-registerworkflowoptions-in-go.md","id":"go/how-to-set-registerworkflowoptions-in-go","title":"How to set RegisterWorkflowOptions in Go","description":"Create an instance of `RegisterOptions` from the `go.temporal.io/sdk/workflow` package and pass it to the `RegisterWorkflowWithOptions` call when registering the Workflow Type with the Worker","label":"RegisterWorkflowOptions","tags":["developer-guide","go"],"markdown_content":"\nCreate an instance of [`RegisterOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#RegisterOptions) from the `go.temporal.io/sdk/workflow` package and pass it to the [`RegisterWorkflowWithOptions`](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowRegistry) call when registering the Workflow Type with the Worker.\n\n- Used to set options for registering a Workflow\n\n| Field                                                             | Required | Type     |\n| ----------------------------------------------------------------- | -------- | -------- |\n| [`Name`](#name)                                                   | No       | `string` |\n| [`DisableAlreadyRegisteredCheck`](#disablealreadyregisteredcheck) | No       | `bool`   |\n\n## `Name`\n\nimport CustomizeWorkflowType from './how-to-customize-workflow-type-in-go.md'\n\n<CustomizeWorkflowType/>\n\n### `DisableAlreadyRegisteredCheck`\n\nDisables the check to see if the Workflow Type has already been registered.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := workflow.RegisterOptions{\n  DisableAlreadyRegisteredCheck: `false`,\n  // ...\n}\nw.RegisterWorkflowWithOptions(YourWorkflowDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-session-options-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-session-options-in-go.md","id":"go/how-to-set-sessionoptions-in-go","title":"How to set SessionOptions in Go","description":"Create an instance of `SessionOptions` and pass it to the `CreateSession()` API call.","label":"SessionOptions","tags":["developer-guide"],"markdown_content":"\nCreate an instance of [`SessionOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SessionOptions) and pass them to the [`CreateSession()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#CreateSession)\n\n| Field                                   | Required | Type            |\n| --------------------------------------- | -------- | --------------- |\n| [`ExecutionTimeout`](#executiontimeout) | No       | `time.Duration` |\n| [`CreationTimeout`](#creationtimeout)   | No       | `time.Duration` |\n| [`HeartbeatTimeout`](#heartbeattimeout) | No       | `time.Duration` |\n\n### ExecutionTimeout\n\nSpecifies the maximum amount of time the session can run.\n\n- Type: `time.Duration`\n- Default:\n\n### CreationTimeout\n\nSpecifies how long session creation can take before returning an error.\n\n- Type: `time.Duration`\n- Default:\n\n### HeartbeatTimeout\n\nSpecifies the heartbeat timeout.\n\n- Type: `time.Duration`\n- Default:\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-the-namespace-for-a-temporal-client-in-go.md","id":"go/how-to-set-the-namespace-for-a-temporal-client-in-go","title":"How to set a Namespace for a Temporal Client in Go","description":"Set the Namespace field on an instance of the Client Options.","label":"Set Namespace","tags":["how-to","go"],"markdown_content":"\nSet the `Namespace` field on an instance of the Client Options.\n\n```go\n// ...\nclientOptions := client.Options{\n  Namespace: \"your-custom-namespace\",\n}\ntemporalClient, err := client.Dial(clientOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-timers-in-go.md","id":"go/how-to-set-timers-in-go","title":"How to set Timers in Go","description":"To set a Timer in Go, use the `NewTimer()` function.","label":"Timers","tags":["timers","sleep"],"markdown_content":"\nTo set a Timer in Go, use the [`NewTimer()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#NewTimer) function and pass the duration you want to wait before continuing.\n\n```go\ntimer := workflow.NewTimer(timerCtx, duration)\n```\n\nTo set a sleep duration in Go, use the [`sleep()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Sleep) function and pass the duration you want to wait before continuing.\nA zero or negative sleep duration causes the function to return immediately.\n\n```go\nsleep = workflow.Sleep(ctx, 10*time.Second)\n```\n\nFor more information, see the [Timer](https://github.com/temporalio/samples-go/tree/main/timer) example in the [Go Samples repository](https://github.com/temporalio/samples-go).\n","is_empty":false},{"file_name":"how-to-set-workeroptions-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-workeroptions-in-go.md","id":"go/how-to-set-workeroptions-in-go","title":"How to set WorkerOptions in Go","description":"Create an instance of `Options` from the `go.temporal.io/sdk/worker` package, set any of the optional fields, and pass the instance to the `New` call.","label":"WorkerOptions","tags":["developer-guide","options","go"],"markdown_content":"\nCreate an instance of [`Options`](https://pkg.go.dev/go.temporal.io/sdk/worker#Options) from the `go.temporal.io/sdk/worker` package, set any of the optional fields, and pass the instance to the [`New`](https://pkg.go.dev/go.temporal.io/sdk/worker#New) call.\n\n| Field                                                                                 | Required | Type                                                                                          |\n| ------------------------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------- |\n| [`MaxConcurrentActivityExecutionSize`](#maxconcurrentactivityexecutionsize)           | No       | `int`                                                                                         |\n| [`WorkerActivitiesPerSecond`](#workeractivitiespersecond)                             | No       | `float64`                                                                                     |\n| [`MaxConcurrentLocalActivityExecutionSize`](#maxconcurrentlocalactivityexecutionsize) | No       | `int`                                                                                         |\n| [`WorkerLocalActivitiesPerSecond`](#workerlocalactivitiespersecond)                   | No       | `float64`                                                                                     |\n| [`TaskQueueActivitiesPerSecond`](#taskqueueactivitiespersecond)                       | No       | `float64`                                                                                     |\n| [`MaxConcurrentActivityTaskPollers`](#maxconcurrentactivitytaskpollers)               | No       | `int`                                                                                         |\n| [`MaxConcurrentWorkflowTaskExecutionSize`](#maxconcurrentworkflowtaskexecutionsize)   | No       | `int`                                                                                         |\n| [`MaxConcurrentWorkflowTaskPollers`](#maxconcurrentworkflowtaskpollers)               | No       | `int`                                                                                         |\n| [`EnableLoggingInReplay`](#enablelogginginreplay)                                     | No       | `bool`                                                                                        |\n| [`DisableStickyExecution`](#disablestickyexecution)                                   | No       | `bool`                                                                                        |\n| [`StickyScheduleToStartTimeout`](#stickyscheduletostarttimeout)                       | No       | [`time.Duration`](https://pkg.go.dev/time#Duration)                                           |\n| [`BackgroundActivityContext`](#backgroundactivitycontext)                             | No       | [`context.Context`](https://pkg.go.dev/context#Context)                                       |\n| [`WorkflowPanicPolicy`](#workflowopanicpolicy)                                        | No       | [`WorkflowPanicPolicy`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowPanicPolicy)   |\n| [`WorkerStopTimeout`](#workerstoptimeout)                                             | No       | [`time.Duration`](https://pkg.go.dev/time#Duration)                                           |\n| [`EnableSessionWorker`](#enablesessionworker)                                         | No       | `bool`                                                                                        |\n| [`MaxConcurrentSessionExecutionSize`](#maxconcurrentsessionexecutionsize)             | No       | `int`                                                                                         |\n| [`WorkflowInterceptorChainFactories`](#workflowinterceptorchainfactories)             | No       | [`[]WorkflowInterceptor`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowInterceptor) |\n| [`LocalActivityWorkerOnly`](#localactivityworkeronly)                                 | No       | `bool`                                                                                        |\n| [`Identity`](#identity)                                                               | No       | `string`                                                                                      |\n| [`DeadlockDetectionTimeout`](#deadlockdetectiontimeout)                               | No       | [`time.Duration`](https://pkg.go.dev/time#Duration)                                           |\n\n### `MaxConcurrentActivityExecutionSize`\n\nSets the maximum concurrent Activity Executions for the Worker.\n\n- Type: `int`\n- Default: `1000`\n\nA value of `0` sets to the default.\n\n```go\n// ...\nworkerOptions := worker.Options{\n  MaxConcurrentActivityExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkerActivitiesPerSecond`\n\nRate limits the number of Activity Task Executions started per second for the Worker.\n\n- Type: `float64`\n- Default: `100000`\n\nA value of `0` sets to the default.\n\nIntended use case is to limit resources used by the Worker.\n\nNotice that the value type is a float so that the value can be less than 1 if needed.\nFor example, if set to 0.1, Activity Task Executions will happen once every ten seconds.\nThis can be used to protect down stream services from flooding with requests.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tWorkerActivitiesPerSecond: 100000,\n  // ..\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentLocalActivityExecutionSize`\n\nSet the maximum concurrent [Local Activity Executions](/concepts/what-is-a-local-activity) for the Worker.\n\n- Type: `int`\n- Default: `1000`\n\nA value of `0` sets to the default value.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentLocalActivityExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkerLocalActivitiesPerSecond`\n\nRate limits the number of Local Activity Executions per second executed for the Worker.\n\n- Type: `float64`\n- Default: `100000`\n\nA value of `0` sets to the default value.\n\nIntended use case is to limit resources used by the Worker.\n\nNotice that the value type is a float so that the value can be less than 1 if needed.\nFor example, if set to 0.1, Local Activity Task Executions will happen once every ten seconds.\nThis can be used to protect down stream services from flooding with requests.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tWorkerLocalActivitiesPerSecond: 100000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `TaskQueueActivitiesPerSecond`\n\nRate limits the number of Activity Executions that can be started per second.\n\n- Type: `float64`\n- Default: `100000`\n\nA value of `0` sets to the default value.\n\nThis rate is managed by the Temporal Cluster and limits the Activity Tasks per second for the entire Task Queue. This is in contrast to [`WorkerActivityTasksPerSecond`](#workeractivitytaskspersecond) controls activities only per Worker.\n\nNotice that the number is represented in float, so that you can set it to less than 1 if needed.\nFor example, set the number to 0.1 means you want your Activity to be executed once for every 10 seconds.\nThis can be used to protect down stream services from flooding.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tTaskQueueActivitiesPerSecond: 100000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentActivityTaskPollers`\n\nSets the maximum number of goroutines to concurrently poll the Task Queue for Activity Tasks.\n\n- Type: `int`\n- Default: `2`\n\nChanging this value will affect the rate at which the Worker is able to consume Activity Tasks from the Task Queue.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentActivityTaskPollers: 2,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentWorkflowTaskExecutionSize`\n\nSets the maximum number of concurrent Workflow Task Executions the Worker can have.\n\n- Type: `int`\n- Default: `1000`\n\nA value of `0` sets to the default value.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentWorkflowTaskExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentWorkflowTaskPollers`\n\nSets the maximum number of goroutines that will concurrently poll the Task Queue for Workflow Tasks.\n\n- Type: `int`\n- Default: `2`\n\nChanging this value will affect the rate at which the Worker is able to consume Workflow Tasks from the Task Queue.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentWorkflowTaskPollers: 2,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `EnableLoggingInReplay`\n\nSet to enable logging in Workflow Execution replays.\n\n- type: `bool`\n- Default: `false`\n\nIn Workflow Definitions you can use [`workflow.GetLogger(ctx)`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLogger) to write logs.\nBy default, the logger will skip logging during replays, so you do not see duplicate logs.\n\nThis is only really useful for debugging purpose.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tEnableLoggingInReplay: false,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `DisableStickyExecution`\n\n:::caution Deprecated\n\nWhen DisableStickyExecution is `true` it can harm performance.\nIt will be removed soon.\nSee [`SetStickyWorkflowCacheSize`](https://pkg.go.dev/go.temporal.io/sdk/worker#SetStickyWorkflowCacheSize) instead.\n\n:::\n\nSet to disable Sticky Executions\n\n- Type: `bool`\n- Default: `false`\n\nSticky Execution runs Workflow Tasks of a Workflow Execution on same host (could be a different Worker, as long as it is on the same host).\nThis is an optimization for Workflow Executions.\nWhen sticky execution is enabled, Worker keeps the Workflow state in memory.\nNew Workflow Task contains the new history events will be dispatched to the same Worker.\nIf this Worker crashes, the sticky Workflow Task will timeout after `StickyScheduleToStartTimeout`, and Temporal Cluster will clear the stickiness for that Workflow Execution and automatically reschedule a new Workflow Task that is available for any Worker to pick up and resume the progress.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tStickyScheduleToStartTimeout: time.Second(5),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `StickyScheduleToStartTimeout`\n\nSets the Sticky Execution Schedule-To-Start Timeout for Workflow Tasks.\n\n- Type: [`time.Duration`](https://pkg.go.dev/time#Duration)\n- Default value is `5`\n\nThe resolution is in seconds.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tStickyScheduleToStartTimeout: time.Second(5),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `BackgroundActivityContext`\n\n:::caution Not recommended\n\nThis method of passing dependencies between Activity Task Executions is not recommended anymore.\n\nInstead, we recommend using a struct with fields that contain dependencies and [develop Activity Definitions](/application-development/foundations#develop-activities) as struct methods and then pass all the dependencies on the structure initialization.\n\n:::\n\n- Type: [`context.Context`](https://pkg.go.dev/context#Context)\n\nSets the background `context.Context` for all Activity Types registered with the Worker.\n\nThe context can be used to pass external dependencies such as database connections to Activity Task Executions.\n\n```go\n// ...\nctx := context.WithValue(context.Background(), \"your-key\", \"your-value\")\nworkerOptions := worker.Options{\n\tBackgroundActivityContext: ctx,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkflowPanicPolicy`\n\nSets how the Workflow Worker handles a non-deterministic Workflow Execution History Event and other panics from Workflow Definition code.\n\n- Type: [`WorkflowPanicPolicy`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowPanicPolicy)\n- Default: `BlockWorkflow`\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tDisableStickyExecution: internal.BlockWorkflow,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkerStopTimeout`\n\nSets the Worker's graceful stop timeout\n\n- Type: [`time.Duration`](https://pkg.go.dev/time#Duration)\n- Default: `0`\n\nValue resolution is in seconds.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tWorkerStopTimeout: time.Second(0),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `EnableSessionWorker`\n\nEnables Sessions for Activity Workers.\n\n- Type: `bool`\n- Default: `false`\n\nWhen `true` the Activity Worker creates a Session to sequentially process Activity Tasks for the given Task Queue.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tEnableSessionWorker: true,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentSessionExecutionSize`\n\nSets the maximum number of concurrent Sessions that the Worker can support.\n\n- Type: `int`\n- Default: 1000\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentSessionExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkflowInterceptorChainFactories`\n\nSpecifies the factories used to instantiate the Workflow interceptor chain.\n\n- Type: [`[]WorkflowInterceptor`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowInterceptor)\n\nThe chain is instantiated for each replay of a Workflow Execution.\n\n### `LocalActivityWorkerOnly`\n\nSets the Worker to only handle Workflow Tasks and local Activity Tasks.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tLocalActivityWorkerOnly: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `Identity`\n\nSets the Temporal Client-level Identity value, overwriting the existing one.\n\n- Type: string\n- Default: client identity\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tIdentity: \"your_custom_identity\",\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `DeadlockDetectionTimeout`\n\nSets the maximum time that a Workflow Task can execute for.\n\n- Type: [`time.Duration`](https://pkg.go.dev/time#Duration)\n- Default: 1\n\nResolution is in seconds.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tDeadlockDetectionTimeout: time.Second(1),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-set-workflow-timeouts-in-go.md","id":"go/how-to-set-workflow-timeouts-in-go","title":"How to set Workflow Timeouts in Go","description":"Create an instance of StartWorkflowOptions.","label":"Workflow Timeouts","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set a timeout, and pass the instance to the `ExecuteWorkflow` call.\n\nAvailable timeouts are:\n\n- `WorkflowExecutionTimeout`\n- `WorkflowRunTimeout`\n- `WorkflowTaskTimeout`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  // Set Workflow Timeout duration\n  WorkflowExecutionTimeout: time.Hours * 24 * 365 * 10,\n  // WorkflowRunTimeout: time.Hours * 24 * 365 * 10,\n  // WorkflowTaskTimeout: time.Second * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-spawn-a-child-workflow-execution-in-go.md","id":"go/how-to-spawn-a-child-workflow-execution-in-go","title":"How to spawn a Child Workflow Execution in Go","description":"Use the `ExecuteChildWorkflow`, available from the `go.temporal.io/sdk/workflow` package, to spawn a Child Workflow Execution in Go.","label":"Child Workflow Execution","tags":["developer-guide","go"],"markdown_content":"\nTo spawn a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) in Go, use the [`ExecuteChildWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ExecuteChildWorkflow) API, which is available from the `go.temporal.io/sdk/workflow` package.\n\nThe `ExecuteChildWorkflow` call requires an instance of [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context), with an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions) applied to it, the Workflow Type, and any parameters that should be passed to the Child Workflow Execution.\n\n`workflow.ChildWorkflowOptions` contain the same fields as `client.StartWorkflowOptions`.\nWorkflow Option fields automatically inherit their values from the Parent Workflow Options if they are not explicitly set.\nIf a custom `WorkflowID` is not set, one is generated when the Child Workflow Execution is spawned.\nUse the [`WithChildOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithChildOptions) API to apply Child Workflow Options to the instance of `workflow.Context`.\n\nThe `ExecuteChildWorkflow` call returns an instance of a [`ChildWorkflowFuture`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowFuture).\n\nCall the `.Get()` method on the instance of `ChildWorkflowFuture` to wait for the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{}\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  var result ChildResp\n  err := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{}).Get(ctx, &result)\n  if err != nil {\n    // ...\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\nTo asynchronously spawn a Child Workflow Execution, the Child Workflow must have an \"Abandon\" Parent Close Policy set in the Child Workflow Options.\nAdditionally, the Parent Workflow Execution must wait for the `ChildWorkflowExecutionStarted` Event to appear in its Event History before it completes.\n\nIf the Parent makes the `ExecuteChildWorkflow` call and then immediately completes, the Child Workflow Execution does not spawn.\n\nTo be sure that the Child Workflow Execution has started, first call the `GetChildWorkflowExecution` method on the instance of the `ChildWorkflowFuture`, which will return a different Future.\nThen call the `Get()` method on that Future, which is what will wait until the Child Workflow Execution has spawned.\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // Wait for the Child Workflow Execution to spawn\n  var childWE workflow.Execution\n  if err := childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE); err != nil {\n     return err\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-test-workflow-definitions-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-test-workflow-definitions-in-go.md","id":"go/how-to-test-workflow-definitions-in-go","title":"How to test Workflow Definitions in Go","label":"Testing and debugging","markdown_content":"\nThe Temporal Go SDK provides a test framework to facilitate testing Workflow implementations.\n\nThis framework is suited for implementing unit tests as well as functional tests of the Workflow logic.\n\nThe following code implements unit tests for the `SimpleWorkflow` sample:\n\n```go\npackage sample\n\nimport (\n        \"context\"\n        \"errors\"\n        \"testing\"\n\n        \"github.com/stretchr/testify/mock\"\n        \"github.com/stretchr/testify/suite\"\n\n        \"go.temporal.io/sdk/activity\"\n        \"go.temporal.io/sdk/testsuite\"\n)\n\ntype UnitTestSuite struct {\n        suite.Suite\n        testsuite.WorkflowTestSuite\n\n        env *testsuite.TestWorkflowEnvironment\n}\n\nfunc (s *UnitTestSuite) SetupTest() {\n        s.env = s.NewTestWorkflowEnvironment()\n}\n\nfunc (s *UnitTestSuite) AfterTest(suiteName, testName string) {\n        s.env.AssertExpectations(s.T())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n\nfunc TestUnitTestSuite(t *testing.T) {\n        suite.Run(t, new(UnitTestSuite))\n}\n```\n\n#### Setup\n\nTo run unit tests, we first define a test suite struct that absorbs both the\nbasic suite functionality from [testify](https://pkg.go.dev/github.com/stretchr/testify/suite)\nvia `suite.Suite` and the suite functionality from the Temporal test framework via\n`testsuite.WorkflowTestSuite`. Because every test in this test suite will test our Workflow, we\nadd a property to our struct to hold an instance of the test environment. This allows us to initialize\nthe test environment in a setup method. For testing Workflows, we use a `testsuite.TestWorkflowEnvironment`.\n\nNext, we implement a `SetupTest` method to set up a new test environment before each test. Doing so\nensures that each test runs in its own isolated sandbox. We also implement an `AfterTest` function\nwhere we assert that all the mocks we set up were indeed called by invoking `s.env.AssertExpectations(s.T())`.\n\nTimeout for the entire test can be set using `SetTestTimeout` in the Workflow or Activity environment.\n\nFinally, we create a regular test function recognized by the `go test` command, and pass the struct to `suite.Run`.\n\n#### A Simple Test\n\nThe simplest test case we can write is to have the test environment execute the Workflow and then\nevaluate the results.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\nCalling `s.env.ExecuteWorkflow(...)` executes the Workflow logic and any invoked Activities inside the\ntest process. The first parameter of `s.env.ExecuteWorkflow(...)` contains the Workflow functions,\nand any subsequent parameters contain values for custom input parameters declared by the Workflow\nfunction.\n\n> Note that unless the Activity invocations are mocked or Activity implementation\n> replaced (see [Activity mocking and overriding](#activity-mocking-and-overriding)), the test environment\n> will execute the actual Activity code including any calls to outside services.\n\nAfter executing the Workflow in the above example, we assert that the Workflow ran through completion\nvia the call to `s.env.IsWorkflowComplete()`. We also assert that no errors were returned by asserting\non the return value of `s.env.GetWorkflowError()`. If our Workflow returned a value, we could have\nretrieved that value via a call to `s.env.GetWorkflowResult(&value)` and had additional asserts on that\nvalue.\n\n#### Activity mocking and overriding\n\nWhen running unit tests on Workflows, we want to test the Workflow logic in isolation. Additionally,\nwe want to inject Activity errors during our test runs. The test framework provides two mechanisms\nthat support these scenarios: Activity mocking and Activity overriding. Both of these mechanisms allow\nyou to change the behavior of Activities invoked by your Workflow without the need to modify the actual\nWorkflow code.\n\nLet's take a look at a test that simulates a test that fails via the \"Activity mocking\" mechanism.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n```\n\nThis test simulates the execution of the Activity `SimpleActivity` that is invoked by our Workflow\n`SimpleWorkflow` returning an error. We accomplish this by setting up a mock on the test environment\nfor the `SimpleActivity` that returns an error.\n\n```go\ns.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n  \"\", errors.New(\"SimpleActivityFailure\"))\n```\n\nWith the mock set up we can now execute the Workflow via the `s.env.ExecuteWorkflow(...)` method and\nassert that the Workflow completed successfully and returned the expected error.\n\nSimply mocking the execution to return a desired value or error is a pretty powerful mechanism to\nisolate Workflow logic. However, sometimes we want to replace the Activity with an alternate implementation\nto support a more complex test scenario. Let's assume we want to validate that the Activity gets called\nwith the correct parameters.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\nIn this example, we provide a function implementation as the parameter to `Return`. This allows us to\nprovide an alternate implementation for the Activity `SimpleActivity`. The framework will execute this\nfunction whenever the Activity is invoked and pass on the return value from the function as the result\nof the Activity invocation. Additionally, the framework will validate that the signature of the \"mock\"\nfunction matches the signature of the original Activity function.\n\nSince this can be an entire function, there is no limitation as to what we can do here. In this\nexample, we assert that the `value` param has the same content as the value param we passed to the Workflow.\n\n#### Queries\n\n`TestWorkflowEnvironment` instances have a [`QueryWorkflow()` method](https://pkg.go.dev/go.temporal.io/temporal/internal#TestWorkflowEnvironment.QueryWorkflow) that lets you query the state of the currently running Workflow.\nFor example, suppose you have a Workflow that lets you query the progress of a long running task as shown below.\n\n```go\nfunc ProgressWorkflow(ctx workflow.Context, percent int) error {\n\tlogger := workflow.GetLogger(ctx)\n\n\terr := workflow.SetQueryHandler(ctx, \"getProgress\", func(input []byte) (int, error) {\n\t\treturn percent, nil\n\t})\n\tif err != nil {\n\t\tlogger.Info(\"SetQueryHandler failed.\", \"Error\", err)\n\t\treturn err\n\t}\n\n\tfor percent = 0; percent<100; percent++ {\n                // Important! Use `workflow.Sleep()`, not `time.Sleep()`, because Temporal's\n                // test environment doesn't stub out `time.Sleep()`.\n\t\tworkflow.Sleep(ctx, time.Second*1)\n\t}\n\n\treturn nil\n}\n```\n\nThis Workflow tracks the current progress of a task in percentage terms, and increments the percentage by 1 every second.\nBelow is how you would write a test case that queries this Workflow.\nNote that you should always query the Workflow either after `ExecuteWorkflow()` is done or in a `RegisterDelayedCallback()` callback, otherwise you'll get a `runtime error` panic.\n\n```go\nfunc (s *UnitTestSuite) Test_ProgressWorkflow() {\n\tvalue := 0\n\n\t// After 10 seconds plus padding, progress should be 10.\n\t// Note that `RegisterDelayedCallback()` doesn't actually make your test wait for 10 seconds!\n\t// Temporal's test framework advances time internally, so this test should take < 1 second.\n\ts.env.RegisterDelayedCallback(func() {\n\t\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\t\ts.NoError(err)\n\t\terr = res.Get(&value)\n\t\ts.NoError(err)\n\t\ts.Equal(10, value)\n\t}, time.Second*10+time.Millisecond*1)\n\n\ts.env.ExecuteWorkflow(ProgressWorkflow, 0)\n\n\ts.True(s.env.IsWorkflowCompleted())\n\n\t// Once the workflow is completed, progress should always be 100\n\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\ts.NoError(err)\n\terr = res.Get(&value)\n\ts.NoError(err)\n\ts.Equal(value, 100)\n}\n```\n\n:::note\n\n`RegisterDelayedCallback` can also be used to send [Signals](/concepts/what-is-a-signal).\nWhen using \"Signal-With-Start\", set the delay to `0`.\n:::\n\n#### Debugging\n\nYou can use a debugger tool provided by your favorite IDE to debug your Workflow Definitions prior to testing or executing them.\n\nThe Temporal Go SDK includes deadlock detection which fails a Workflow Task in case the code blocks over a second without relinquishing execution control.\nBecause of this you can often encounter a `PanicError: Potential deadlock detected` while stepping through Workflow Definitions during debugging.\n\nTo alleviate this issue, you can set the `TEMPORAL_DEBUG` environment variable to `true` before debugging your Workflow Definition.\n\n:::note\n\nMake sure to set `TEMPORAL_DEBUG` to true only during debugging.\n\n:::\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go.md","id":"go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go","title":"How to upsert custom Search Attributes to Workflow during Execution","label":"How to upsert custom Search Attributes to Workflow during Execution","tags":["developer-guide","go"],"markdown_content":"\nIn advanced cases, you may want to dynamically update these attributes as the Workflow progresses.\n[UpsertSearchAttributes](https://pkg.go.dev/go.temporal.io/sdk/workflow#UpsertSearchAttributes) is used to add or update Search Attributes from within Workflow code.\n\n`UpsertSearchAttributes` will merge attributes to the existing map in the Workflow.\nConsider this example Workflow code:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n\n    attr1 := map[string]interface{}{\n        \"CustomIntField\": 1,\n        \"CustomBoolField\": true,\n    }\n    workflow.UpsertSearchAttributes(ctx, attr1)\n\n    attr2 := map[string]interface{}{\n        \"CustomIntField\": 2,\n        \"CustomKeywordField\": \"seattle\",\n    }\n    workflow.UpsertSearchAttributes(ctx, attr2)\n}\n```\n\nAfter the second call to `UpsertSearchAttributes`, the map will contain:\n\n```go\nmap[string]interface{}{\n    \"CustomIntField\": 2, // last update wins\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"seattle\",\n}\n```\n","is_empty":false},{"file_name":"how-to-use-queries-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/how-to-use-queries-in-go.md","id":"go/how-to-use-queries-in-go","title":"How to use Queries in Go","description":"A Query is sent from a Temporal Client to a Workflow Execution and is identified by its name.","label":"Queries","tags":["go","developer-guide"],"markdown_content":"\nimport QueryType from './how-to-define-a-query-type-in-go.md'\n\n<QueryType/>\n\n### Send Query\n\nimport SendQuery from './how-to-send-a-query-to-a-workflow-execution-in-go.md'\n\n<SendQuery/>\n\n### Handle Query\n\nimport HandleQuery from './how-to-handle-a-query-in-a-workflow-in-go.md'\n\n<HandleQuery/>\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/index.md","id":"go/index","title":"How to use the Temporal Go SDK","description":"Add the Temporal Go SDK to your project.","tags":["developer-guide","go"],"markdown_content":"\n:::caution Legacy docs set\n\nThe information provided in this documentation set is intended to be available in the [Developer's guide](/application-development).\n\nHowever, the guide is still a work in progress.\nAlthough much of the information is already represented there, if you can't find what you are looking for, we still encourage you to check this legacy docs set.\n\n:::\n\n[![Build Status](https://badge.buildkite.com/ce6df3b1a8b375270261ae70fb2d2756af298fef3a0dac4d20.svg?theme=github&branch=master)](https://buildkite.com/temporal/temporal-go-client) [![Coverage Status](https://coveralls.io/repos/github/temporalio/temporal-go-sdk/badge.svg?branch=master)](https://coveralls.io/github/temporalio/temporal-go-sdk?branch=master) [![Go reference](https://pkg.go.dev/badge/go.temporal.io/sdk)](https://pkg.go.dev/go.temporal.io/sdk)\n\nAdd the [Temporal Go SDK](https://github.com/temporalio/sdk-go) to your project:\n\n```bash\ngo get go.temporal.io/sdk\n```\n\nOr clone the Go SDK repo to your preferred location:\n\n```bash\ngit clone git@github.com:temporalio/sdk-go.git\n```\n","is_empty":false},{"file_name":"reference-activityoptions.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/reference-activityoptions.md","id":"go/activityoptions-reference","title":"Go ActivityOptions reference","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package and use `WithActivityOptions()` to apply it to the instance of `workflow.Context`.","label":"Activity Options reference","tags":["developer-guide","go"],"markdown_content":"\nCreate an instance of [`ActivityOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ActivityOptions) from the `go.temporal.io/sdk/workflow` package and use [`WithActivityOptions()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithActivityOptions) to apply it to the instance of `workflow.Context`.\n\nThe instance of `workflow.Context` is then passed to the `ExecuteActivity()` call.\n\n| Field                                               | Required                          | Type                                                                        |\n| --------------------------------------------------- | --------------------------------- | --------------------------------------------------------------------------- |\n| [`ActivityID`](#activityid)                         | No                                | `string`                                                                    |\n| [`TaskQueueName`](#taskqueuename)                   | No                                | `string`                                                                    |\n| [`ScheduleToCloseTimeout`](#scheduletoclosetimeout) | Yes (or `StartToCloseTimeout`)    | `time.Duration`                                                             |\n| [`ScheduleToStartTimeout`](#scheduletostarttimeout) | No                                | `time.Duration`                                                             |\n| [`StartToCloseTimeout`](#scheduletoclosetimeout)    | Yes (or `ScheduleToCloseTimeout`) | `time.Duration`                                                             |\n| [`HeartbeatTimeout`](#heartbeattimeout)             | No                                | `time.Duration`                                                             |\n| [`WaitForCancellation`](#waitforcancellation)       | No                                | `bool`                                                                      |\n| [`OriginalTaskQueueName`](#originaltaskqueuename)   | No                                | `string`                                                                    |\n| [`RetryPolicy`](#retrypolicy)                       | No                                | [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy) |\n\n### `ActivityID`\n\n- Type: `string`\n- Default: None\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ActivityID: \"your-activity-id\",\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n- [What is an Activity Id](/concepts/what-is-an-activity-id)\n\n### `TaskQueueName`\n\n- Type: `string`\n- Default: Inherits the TaskQueue name from the Workflow.\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  TaskQueueName: \"your-task-queue-name\",\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n- [What is a Task Queue](/concepts/what-is-a-task-queue)\n\n### `ScheduleToCloseTimeout`\n\nimport ScheduleToCloseTimeout from './how-to-set-a-schedule-to-close-timeout-in-go.md'\n\n<ScheduleToCloseTimeout/>\n\n### `ScheduleToStartTimeout`\n\nimport ScheduleToStartTimeout from './how-to-set-a-schedule-to-start-timeout-in-go.md'\n\n<ScheduleToStartTimeout/>\n\n### `StartToCloseTimeout`\n\nimport StartToCloseTimeout from './how-to-set-a-start-to-close-timeout-in-go.md'\n\n<StartToCloseTimeout/>\n\n### `HeartbeatTimeout`\n\nimport HeartbeatTimeout from './how-to-set-a-heartbeat-timeout-in-go.md'\n\n<HeartbeatTimeout/>\n\n### `WaitForCancellation`\n\nIf `true` the Activity Execution will finish executing should there be a Cancellation request.\n\n- Type: `bool`\n- Default: `false`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  WaitForCancellation: false,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n### `OriginalTaskQueueName`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  OriginalTaskQueueName: \"your-original-task-queue-name\",\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n### `RetryPolicy`\n\nimport RetryPolicy from './how-to-set-an-activity-retry-policy-in-go.md'\n\n<RetryPolicy/>\n","is_empty":false},{"file_name":"reference-startworkflowoptions.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/reference-startworkflowoptions.md","id":"go/startworkflowoptions-reference","title":"Go StartWorkflowOptions reference","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Options reference","tags":["developer-guide","options"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, and pass the instance to the `ExecuteWorkflow` call.\n\nThe following fields are available:\n\n| Field                                                                                   | Required | Type                                                                                            |\n| --------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------- |\n| [`ID`](#id)                                                                             | No       | `string`                                                                                        |\n| [`TaskQueue`](#taskqueue)                                                               | **Yes**  | `string`                                                                                        |\n| [`WorkflowExecutionTimeout`](#workflowexecutiontimeout)                                 | No       | `time.Duration`                                                                                 |\n| [`WorkflowRunTimeout`](#workflowruntimeout)                                             | No       | `time.Duration`                                                                                 |\n| [`WorkflowTaskTimeout`](#workflowtasktimeout)                                           | No       | `time.Duration`                                                                                 |\n| [`WorkflowIDReusePolicy`](#workflowidreusepolicy)                                       | No       | [`WorkflowIdReusePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#WorkflowIdReusePolicy) |\n| [`WorkflowExecutionErrorWhenAlreadyStarted`](#workflowexecutionerrorwhenalreadystarted) | No       | `bool`                                                                                          |\n| [`RetryPolicy`](#retrypolicy)                                                           | No       | [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)                     |\n| [`CronSchedule`](#cronschedule)                                                         | No       | `string`                                                                                        |\n| [`Memo`](#memo)                                                                         | No       | `map[string]interface{}`                                                                        |\n| [`SearchAttributes`](#searchattributes)                                                 | No       | `map[string]interface{}`                                                                        |\n\n### `ID`\n\nimport WorkflowId from './how-to-set-a-workflow-id-in-go.md'\n\n<WorkflowId/>\n\n### `TaskQueue`\n\nimport TaskQueue from './how-to-set-a-workflow-task-queue-in-go.md'\n\n<TaskQueue/>\n\n### `WorkflowExecutionTimeout`\n\nimport WFETimeout from './how-to-set-a-workflow-execution-timeout-in-go.md'\n\n<WFETimeout/>\n\n### `WorkflowRunTimeout`\n\nimport WFRTimeout from './how-to-set-a-workflow-run-timeout-in-go.md'\n\n<WFRTimeout/>\n\n### `WorkflowTaskTimeout`\n\nimport WFTTimeout from './how-to-set-a-workflow-task-timeout-in-go.md'\n\n<WFTTimeout/>\n\n### `WorkflowIDReusePolicy`\n\n- Type: [`WorkflowIdReusePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#WorkflowIdReusePolicy)\n- Default: `enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE`\n\nSet a value from the `go.temporal.io/api/enums/v1` package.\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowIdReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n### `WorkflowExecutionErrorWhenAlreadyStarted`\n\n- Type: `bool`\n- Default: `false`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowExecutionErrorWhenAlreadyStarted: false,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n### `RetryPolicy`\n\nimport RetryPolicy from './how-to-set-a-workflow-retry-policy-in-go.md'\n\n<RetryPolicy/>\n\n### `CronSchedule`\n\n- Type: `string`\n- Default: None\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n[Sample](https://github.com/temporalio/samples-go/tree/master/cron)\n\n### `Memo`\n\n- Type: `map[string]interface{}`\n- Default: Empty\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  Memo: map[string]interface{}{\n    \"description\": \"Test search attributes workflow\",\n  },\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n### `SearchAttributes`\n\n**How to set Workflow Execution Search Attributes in Go**\n\n- Type: `map[string]interface{}`\n- Default: Empty.\n\nThese are the corresponding [Search Attribute value types](/concepts/what-is-a-search-attribute/#types) in Go:\n\n- Keyword = string\n- Int = int64\n- Double = float64\n- Bool = bool\n- Datetime = time.Time\n- Text = string\n\n```go\nsearchAttributes := map[string]interface{}{\n  \"CustomIntField\": 1,\n  \"MiscData\": \"yellow\",\n}\nworkflowOptions := client.StartWorkflowOptions{\n  SearchAttributes: searchAttributes,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"search-apis.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/search-apis.md","id":"go/search-apis","title":"Using Custom Searchable Attributes in Go","label":"Search Attributes","markdown_content":"\n## Overview\n\nSearch Attributes enable complex and business-logic-focused search queries for Workflow Executions.\nThese are often queried through the Temporal Web UI, but you can also query from within your Workflow code.\n\nMany [Search Attributes](/concepts/what-is-a-search-attribute) are added to Workflow Executions by default.\nBut these are necessarily focused on Temporal internal state tracking.\n\nFor more debugging and monitoring, you might want to add your own domain-specific Search Attributes, such as `customerId` or `numItems`, that can serve as useful search filters.\n\nThe [Go SDK Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) offers APIs for configuring Search Attributes.\nThere are also APIs on the SDK client for listing Workflows by status.\nGo samples for Search Attributes can be found at [`temporalio/samples-go`](https://github.com/temporalio/samples-go/tree/master/searchattributes).\n\n## Value types\n\nHere are the [Search Attribute value types](/concepts/what-is-a-search-attribute/#types) and their corresponding types in Go:\n\n- Bool = bool\n- Datetime = time.Time\n- Double = float64\n- Int = int64\n- Keyword = string\n- Text = string\n\n## Tagging Search Attributes at Workflow creation\n\nYou can provide key-value pairs as Search Attributes in [StartWorkflowOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions).\nIn Go, Search Attributes are represented as `map[string]interface{}`.\nThe value provided in the map must be the same type that was added to a Cluster.\n\nThis can be useful for tagging executions with useful attributes you may want to search up later. For example:\n\n```go\nfunc (c *Client) CallYourWorkflow(ctx context.Context, workflowID string, payload map[string]interface{}) error {\n    // ...\n    searchAttributes := map[string]interface{}{\n        \"CustomerId\": payload[\"customer\"],\n        \"MiscData\": payload[\"miscData\"]\n    }\n    options := client.StartWorkflowOptions{\n        ID:                 workflowID,\n        TaskQueue:          app.MyTaskQueue,\n        SearchAttributes:   searchAttributes\n    }\n    we, err := c.Client.ExecuteWorkflow(ctx, options, app.YourWorkflow, payload)\n    // ...\n}\n```\n\n## Upsert Search Attributes during Workflow Execution\n\nIn advanced cases, you may want to dynamically update these attributes as the Workflow progresses.\n[UpsertSearchAttributes](https://pkg.go.dev/go.temporal.io/sdk/workflow#UpsertSearchAttributes) is used to add or update Search Attributes from within Workflow code.\n\n`UpsertSearchAttributes` will merge attributes to the existing map in the Workflow.\nConsider this example Workflow code:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n\n    attr1 := map[string]interface{}{\n        \"CustomIntField\": 1,\n        \"CustomBoolField\": true,\n    }\n    workflow.UpsertSearchAttributes(ctx, attr1)\n\n    attr2 := map[string]interface{}{\n        \"CustomIntField\": 2,\n        \"CustomKeywordField\": \"seattle\",\n    }\n    workflow.UpsertSearchAttributes(ctx, attr2)\n}\n```\n\nAfter the second call to `UpsertSearchAttributes`, the map will contain:\n\n```go\nmap[string]interface{}{\n    \"CustomIntField\": 2, // last update wins\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"seattle\",\n}\n```\n\n## Removing Search Attributes\n\n**There is no support for removing a field.**\n\nHowever, to achieve a similar effect, set the field to some placeholder value.\nFor example, you could set `CustomKeywordField` to `impossibleVal`.\nThen searching `CustomKeywordField != 'impossibleVal'` will match Workflows with `CustomKeywordField` not equal to `impossibleVal`, which includes Workflows without the `CustomKeywordField` set.\n\n## Retrieving Search Attributes\n\nUse the `SearchAttributes` property of `workflow.GetInfo` to get a specific Search Attribute:\n\n```go\n// Get search attributes that were provided when workflow was started.\ninfo := workflow.GetInfo(ctx)\nval := info.SearchAttributes.IndexedFields[\"CustomIntField\"]\n```\n\n## Querying Search Attributes within a Workflow\n\nYou can programmatically retrieve attributes from a Workflow Execution with `GetSearchAttributes`, and log out all fields with `GetIndexedFields`:\n\n```go\nsearchAttributes := workflowExecution.GetSearchAttributes()\nvar builder strings.Builder\nfor k, v := range searchAttributes.GetIndexedFields() {\n    var currentVal interface{}\n    err := converter.GetDefaultDataConverter().FromPayload(v, &currentVal)\n    if err != nil {\n        logger.Error(fmt.Sprintf(\"Get search attribute for key %s failed.\", k), \"Error\", err)\n        return err\n    }\n    builder.WriteString(fmt.Sprintf(\"%s=%v\\n\", k, currentVal))\n}\n```\n\n## Testing Search Attributes\n\nThe Go SDK's test suite comes with corresponding methods for mocking and asserting these operations:\n\n```go\nfunc Test_Workflow(t *testing.T) {\n\ttestSuite := &testsuite.WorkflowTestSuite{}\n\tenv := testSuite.NewTestWorkflowEnvironment()\n\tenv.RegisterActivity(ListExecutions)\n\n\t// mock search attributes on start\n\t_ = env.SetSearchAttributesOnStart(map[string]interface{}{\"CustomIntField\": 1})\n\n\t// mock upsert operations\n\tattributes := map[string]interface{}{\n\t\t\"CustomIntField\":      2, // update CustomIntField from 1 to 2, then insert other fields\n\t\t\"CustomKeywordField\":  \"Update1\",\n\t\t\"CustomBoolField\":     true,\n\t\t\"CustomDoubleField\":   3.14,\n\t\t\"CustomDatetimeField\": env.Now().UTC(),\n\t\t\"CustomStringField\":   \"String field is for text. When query, it will be tokenized for partial match. StringTypeField cannot be used in Order By\",\n\t}\n\tenv.OnUpsertSearchAttributes(attributes).Return(nil).Once()\n\n\tattributes = map[string]interface{}{\n\t\t\"CustomKeywordField\": \"Update2\",\n\t}\n\tenv.OnUpsertSearchAttributes(attributes).Return(nil).Once()\n\n\t// mock activity\n\tenv.OnActivity(ListExecutions, mock.Anything, mock.Anything).Return([]*workflowpb.WorkflowExecutionInfo{{}}, nil).Once()\n\n\tenv.ExecuteWorkflow(SearchAttributesWorkflow)\n\trequire.True(t, env.IsWorkflowCompleted())\n\trequire.NoError(t, env.GetWorkflowError())\n}\n```\n\n## Full Search Attributes example code\n\nYou can find full example Search Attributes sample code [in the Temporal `samples-go` repo](https://github.com/temporalio/samples-go/tree/master/searchattributes).\n","is_empty":false},{"file_name":"selectors.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/selectors.md","id":"go/selectors","title":"Go SDK Selectors","label":"Selectors","markdown_content":"\n## Overview\n\nIn Go, the `select` statement lets a goroutine wait on multiple communication operations.\nA `select` **blocks until one of its cases can run**, then it executes that case.\nIt chooses one at random if multiple are ready.\n\nHowever, a normal Go select statement can not be used inside of Workflows directly because of the random nature.\nTemporal's Go SDK `Selector`s are similar and act as a replacement.\nThey can block on sending and receiving from Channels but as a bonus can listen on Future deferred work.\nUsage of Selectors to defer and process work (in place of Go's `select`) are necessary in order to ensure deterministic Workflow code execution (though using `select` in Activity code is fine).\n\n## Full API Example\n\nThe API is sufficiently different from `select` that it bears documenting:\n\n```go\nfunc SampleWorkflow(ctx workflow.Context) error {\n\t// standard Workflow setup code omitted...\n\n\t// API Example: declare a new selector\n\tselector := workflow.NewSelector(ctx)\n\n\t// API Example: defer code execution until the Future that represents Activity result is ready\n\twork := workflow.ExecuteActivity(ctx, ExampleActivity)\n\tselector.AddFuture(work, func(f workflow.Future) {\n\t\t// deferred code omitted...\n\t})\n\n\t// more parallel timers and activities initiated...\n\n\t// API Example: receive information from a Channel\n\tvar signalVal string\n\tchannel := workflow.GetSignalChannel(ctx, channelName)\n\tselector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {\n\t\t// matching on the channel doesn't consume the message.\n\t \t// So it has to be explicitly consumed here\n\t\tc.Receive(ctx, &signalVal)\n\t\t// do something with received information\n\t})\n\n\t// API Example: block until the next Future is ready to run\n\t// important! none of the deferred code runs until you call selector.Select\n\tselector.Select(ctx)\n\n\t// Todo: document selector.HasPending\n}\n```\n\n## Using Selectors with Futures\n\nYou usually add `Future`s after `Activities`:\n\n```go\n\t// API Example: defer code execution until after an activity is done\n\twork := workflow.ExecuteActivity(ctx, ExampleActivity)\n\tselector.AddFuture(work, func(f workflow.Future) {\n\t\t// deferred code omitted...\n\t})\n```\n\n`selector.Select(ctx)` is the primary mechanism which blocks on and executes `Future` work.\nIt is intentionally flexible; you may call it conditionally or multiple times:\n\n```go\n\t// API Example: blocking conditionally\n  if somecondition != nil {\n\t\tselector.Select(ctx)\n  }\n\n\t// API Example: popping off all remaining Futures\n  for i := 0; i < len(someArray); i++ {\n\t\tselector.Select(ctx) // this will wait for one branch\n\t\t// you can interrupt execution here\n\t}\n```\n\nA Future matches only once per Selector instance even if Select is called multiple times.\nIf multiple items are available, the order of matching is not defined.\n\n### Using Selectors with Timers\n\nAn important use case of futures is setting up a race between a timer and a pending activity, effectively adding a \"soft\" timeout that doesn't result in any errors or retries of that activity.\n\nFor example, [the Timer sample](https://github.com/temporalio/samples-go/blob/master/timer) shows how you can write a long running order processing operation where:\n\n- if processing takes too long, we send out a notification email to user about the delay, but we won't cancel the operation\n- if the operation finishes before the timer fires, then we want to cancel the timer.\n\n```go\nvar processingDone bool\nf := workflow.ExecuteActivity(ctx, OrderProcessingActivity)\nselector.AddFuture(f, func(f workflow.Future) {\n\tprocessingDone = true\n\t// cancel timerFuture\n\tcancelHandler()\n})\n\n// use timer future to send notification email if processing takes too long\ntimerFuture := workflow.NewTimer(childCtx, processingTimeThreshold)\nselector.AddFuture(timerFuture, func(f workflow.Future) {\n\tif !processingDone {\n\t\t// processing is not done yet when timer fires, send notification email\n\t\t_ = workflow.ExecuteActivity(ctx, SendEmailActivity).Get(ctx, nil)\n\t}\n})\n\n// wait the timer or the order processing to finish\nselector.Select(ctx)\n```\n\nWe create timers with the `workflow.NewTimer` API.\n\n## Using Selectors with Channels\n\n`selector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {})` is the primary mechanism which receives messages from `Channels`.\n\n```go\n\t// API Example: receive information from a Channel\n\tvar signalVal string\n\tchannel := workflow.GetSignalChannel(ctx, channelName)\n\tselector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {\n\t\tc.Receive(ctx, &signalVal)\n\t\t// do something with received information\n\t})\n```\n\nMerely matching on the channel doesn't consume the message; it has to be explicitly consumed with a `c.Receive(ctx, &signalVal)` call.\n\n## Querying Selector State\n\nYou can use the `selector.HasPending` API to ensure that signals are not lost when a Workflow is closed (e.g. by `ContinueAsNew`).\n\n## Learn More\n\nUsage of Selectors is best learned by example:\n\n- Setting up a race condition between an Activity and a Timer, and conditionally execute ([Timer example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/timer/workflow.go))\n- Receiving information in a Channel ([Mutex example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/mutex/mutex_workflow.go))\n- Looping through a list of work and scheduling them all in parallel ([DSL example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/dsl/workflow.go))\n- Executing activities in parallel, pick the first result, cancel remainder ([Pick First example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/pickfirst/pickfirst_workflow.go))\n","is_empty":false},{"file_name":"spawn-a-child-workflow-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/spawn-a-child-workflow-execution.md","id":"go/spawn-a-child-workflow-execution","title":"How to spawn a Child Workflow Execution in Go","description":"Use the `ExecuteChildWorkflow`, available from the `go.temporal.io/sdk/workflow` package, to spawn a Child Workflow Execution in Go.","label":"Child Workflow Execution","tags":["developer-guide","go"],"markdown_content":"\nTo spawn a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) in Go, use the [`ExecuteChildWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ExecuteChildWorkflow) API, which is available from the `go.temporal.io/sdk/workflow` package.\n\nThe `ExecuteChildWorkflow` call requires an instance of [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context), with an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions) applied to it, the Workflow Type, and any parameters that should be passed to the Child Workflow Execution.\n\n`workflow.ChildWorkflowOptions` contain the same fields as `client.StartWorkflowOptions`.\nWorkflow Option fields automatically inherit their values from the Parent Workflow Options if they are not explicitly set.\nIf a custom `WorkflowID` is not set, one is generated when the Child Workflow Execution is spawned.\nUse the [`WithChildOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithChildOptions) API to apply Child Workflow Options to the instance of `workflow.Context`.\n\nThe `ExecuteChildWorkflow` call returns an instance of a [`ChildWorkflowFuture`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowFuture).\n\nCall the `.Get()` method on the instance of `ChildWorkflowFuture` to wait for the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{}\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  var result ChildResp\n  err := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{}).Get(ctx, &result)\n  if err != nil {\n    // ...\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\nTo asynchronously spawn a Child Workflow Execution, the Child Workflow must have an \"Abandon\" Parent Close Policy set in the Child Workflow Options.\nAdditionally, the Parent Workflow Execution must wait for the \"ChildWorkflowExecutionStarted\" event to appear in its event history before it completes.\n\nIf the Parent makes the `ExecuteChildWorkflow` call and then immediately completes, the Child Workflow Execution will not spawn.\n\nTo be sure that the Child Workflow Execution has started, first call the `GetChildWorkflowExecution` method on the instance of the `ChildWorkflowFuture`, which will return a different Future.\nThen call the `Get()` method on that Future, which is what will wait until the Child Workflow Execution has spawned.\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // Wait for the Child Workflow Execution to spawn\n  var childWE workflow.Execution\n  if err := childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE); err != nil {\n     return err\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n","is_empty":false},{"file_name":"spawn-a-workflow-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/spawn-a-workflow-execution.md","id":"go/spawn-a-workflow-execution","title":"How to spawn a Workflow Execution in Go","description":"Use the `ExecuteWorkflow()` method on the Go SDK `Client`, which is available via `Dial()` in the `go.temporal.io/sdk/client` package.","label":"Workflow Execution","tags":["developer-guide","go"],"markdown_content":"\nTo spawn a [Workflow Execution](/concepts/what-is-a-workflow-execution), use the `ExecuteWorkflow()` method on the Go SDK [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nThe `ExecuteWorkflow()` API call requires an instance of [`context.Context`](https://pkg.go.dev/context#Context), an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions), a Workflow Type name, and all variables to be passed to the Workflow Execution.\nThe `ExecuteWorkflow()` call returns a Future, which can be used to get the result of the Workflow Execution.\n\n```go\npackage main\n\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n  workflowOptions := client.StartWorkflowOptions{\n    // ...\n  }\n  workflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n  if err != nil {\n    // ...\n  }\n  // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n}\n```\n\nIf the invocation process has access to the function directly, then the Workflow Type name parameter can be passed as if the function name were a variable, without quotations.\n\n```go\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n```\n\nIf the invocation process does not have direct access to the statically defined Workflow Definition, for example, if the Workflow Definition is in an un-importable package, or it is written in a completely different language, then the Workflow Type can be provided as a `string`.\n\n```go\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, \"YourWorkflowDefinition\", param)\n```\n","is_empty":false},{"file_name":"spawn-activity-execution.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/spawn-activity-execution.md","id":"go/spawn-an-activity-execution","title":"How to spawn an Activity Execution in Go","description":"Use the `ExecuteActivity()` API call available from the `go.temporal.io/sdk/workflow` package.","label":"Activity Execution","tags":["developer-guide","go"],"markdown_content":"\nTo spawn an [Activity Execution](/concepts/what-is-an-activity-execution), use the [`ExecuteActivity()`](https://pkg.go.dev/go.temporal.io/workflow#ExecuteActivity) API call inside your Workflow Definition.\nThe API is available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/workflow) package.\n\nThe `ExecuteActivity()` API call requires an instance of `workflow.Context`, the Activity function name, and any variables to be passed to the Activity Execution.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n  yourActivityParam := YourActivityParam{\n    // ...\n  }\n  var activities *YourActivityStruct\n  future := workflow.ExecuteActivity(ctx, activities.YourActivityDefinition, yourActivityParam)\n  // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n  // ...\n}\n```\n\nThe Activity function name can be provided as a variable object (no quotations) or as a string.\n\n```go\n// ...\n  future := workflow.ExecuteActivity(ctx, \"YourActivityDefinition\", yourActivityParam)\n// ...\n```\n\nThe benefit of passing the actual function object is that the framework can validate the parameters against the Activity Definition.\n\nThe `ExecuteActivity` call returns a Future, which can be used to get the result of the Activity Execution.\n","is_empty":false},{"file_name":"tracing.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/tracing.md","id":"go/tracing","title":"Tracing and Context Propagation","markdown_content":"\n## Tracing\n\nThe Go SDK provides support for distributed tracing through [OpenTracing](https://opentracing.io/).\nTracing allows you to view the call graph of a Workflow along with its Activities and any Child Workflows.\n\nTracing can be configured by providing an [opentracing.Tracer](https://pkg.go.dev/github.com/opentracing/opentracing-go#Tracer)\nimplementation in [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions) during client instantiation.\nFor more details on how to configure and leverage tracing, see the [OpenTracing documentation](https://opentracing.io/docs/getting-started/).\n\nThe OpenTracing support has been validated using [Jaeger](https://www.jaegertracing.io/), but other implementations mentioned [here](https://opentracing.io/docs/supported-tracers/) should also work.\nTracing functionality utilizes generic context propagation provided by the client.\n\n## Context Propagation\n\nTemporal provides a standard way to propagate a custom context across a Workflow.\nYou can configure a context propagator in via the [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions).\nThe context propagator extracts and passes on information present in `context.Context` and `workflow.Context` objects across the Workflow.\nOnce a context propagator is configured, you should be able to access the required values in the context objects as you would normally do in Go.\nYou can see how the Go SDK implements a [tracing context propagator](https://github.com/temporalio/sdk-go/blob/master/internal/tracer.go).\n\n### Server-Side Headers\n\nOn the server side, Temporal provides a mechanism for propagating context across Workflow transitions called headers.\n\n```proto\nmessage Header {\n    map<string, Payload> fields = 1;\n}\n```\n\n`Client` leverages headers to pass around additional context information.\n[HeaderReader](https://pkg.go.dev/go.temporal.io/sdk/internal#HeaderReader) and [HeaderWriter](https://pkg.go.dev/go.temporal.io/sdk/internal#HeaderWriter) are interfaces that allow reading and writing to the Temporal Server headers.\nThe SDK includes [implementations](https://github.com/temporalio/sdk-go/blob/master/internal/headers.go) for these interfaces.\n`HeaderWriter` sets a value for a header.\nHeaders are held as a map, so setting a value for the same key will overwrite its previous value.\n`HeaderReader` gets a value of a header.\nIt also can iterate through all headers and execute the provided handler function on each header, so that your code can operate on select headers you need.\n\n```go\ntype HeaderWriter interface {\n\tSet(string, *commonpb.Payload)\n}\n\ntype HeaderReader interface {\n\tGet(string) (*commonpb.Payload, bool)\n\tForEachKey(handler func(string, *commonpb.Payload) error) error\n}\n```\n\n### Context Propagators\n\nYou can propagate additional context through Workflow Execution by using a context propagator.\nA context propagator needs to implement the `ContextPropagator` interface that includes the following four methods:\n\n```go\ntype ContextPropagator interface {\n  Inject(context.Context, HeaderWriter) error\n\n  Extract(context.Context, HeaderReader) (context.Context, error)\n\n  InjectFromWorkflow(Context, HeaderWriter) error\n\n  ExtractToWorkflow(Context, HeaderReader) (Context, error)\n}\n```\n\n- `Inject` reads select context keys from a Go [context.Context](https://golang.org/pkg/context/#Context) object and writes them into the headers using the [HeaderWriter](https://pkg.go.dev/go.temporal.io/sdk/internal#HeaderWriter) interface.\n- `InjectFromWorkflow` operates similar to `Inject` but reads from a [workflow.Context](https://pkg.go.dev/go.temporal.io/sdk/internal#Context) object.\n- `Extract` picks select headers and put their values into the [context.Context](https://golang.org/pkg/context/#Context) object.\n- `ExtractToWorkflow` operates similar to `Extract` but write to a [workflow.Context](https://pkg.go.dev/go.temporal.io/sdk/internal#Context) object.\n\nThe [tracing context propagator](https://github.com/temporalio/sdk-go/blob/master/internal/tracer.go) shows a sample implementation of a context propagator.\n\n### Is there a complete example?\n\nThe [context propagation sample](https://github.com/temporalio/samples-go/blob/master/ctxpropagation/) configures a custom context propagator and shows context propagation of custom keys across a Workflow and an Activity.\nIt also uses Jaeger for tracing.\n\n### Can I configure multiple context propagators?\n\nYes. Multiple context propagators help to structure code with each propagator having its own scope of responsibility.\n\n## Useful Resources\n\n- [Passing Context with Temporal](https://spiralscout.com/blog/passing-context-with-temporal) by SpiralScout\n","is_empty":false},{"file_name":"use-signals.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/use-signals.md","id":"go/use-signals","title":"How to use Signals in Go","description":"Use the `SignalWorkflow()` method on and instance of the Go SDK Temporal Client to send a Signal to a Workflow Execution.","label":"Signals","tags":["go","developer-guide"],"markdown_content":"\nTo use Signals in Go, first define your Signal type and then add a Signal handler to your Workflow Definition.\nSignals can then be sent via the Temporal Client or from within a Workflow.\n\n### Define Signal type\n\nStructs should be used to define Signals and carry data, as long as the struct is [serializable via the Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#CompositeDataConverter.ToPayload).\nThe `Receive()` method on the Data Converter decodes the data into the Struct within the Workflow.\nOnly public fields are serializable.\n\n```go\nMySignal struct {\n\tMessage string // serializable\n\tmessage string // not serializable\n}\n```\n\n### Handle Signal\n\n---\n\nid: how-to-handle-a-signal-in-go\ntitle: How to handle a Signal in Go\nsidebar_label: Handle Signal\ndescription: Use the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.\ntags:\n\n- go\n- how-to\n\n---\n\nUse the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.\nGet a new [`Selector`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Selector) and pass it the Signal Channel and a callback function to handle the payload.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  // ...\n  var signal MySignal\n  signalChan := workflow.GetSignalChannel(ctx, \"your-signal-name\")\n  selector := workflow.NewSelector(ctx)\n  selector.AddReceive(signalChan, func(channel workflow.ReceiveChannel, more bool) {\n      channel.Receive(ctx, &signal)\n      // ...\n  })\n  selector.Select(ctx)\n  if len(signal.Message) > 0 && signal.Message != \"SOME_VALUE\" {\n      return errors.New(\"signal\")\n  }\n  // ...\n}\n```\n\nIn the example above, the Workflow code uses `workflow.GetSignalChannel` to open a `workflow.Channel` for the Signal type (identified by the Signal name).\nWe then use a [`workflow.Selector`](/go/selectors) and the `AddReceive()` to wait on a Signal from this channel.\nThe `more` bool in the callback function indicates that channel is not closed and more deliveries are possible.\n\nBefore completing the Workflow or using [Continue-As-New](/application-development/features#continue-as-new), make sure to do an asynchronous drain on the Signal channel.\nOtherwise, the Signals will be lost.\n\n### Send Signal from Temporal Client\n\nUse the `SignalWorkflow()` method on an instance of the [Go SDK Temporal Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) to send a [Signal](/concepts/what-is-a-signal) to a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nPass in both the [Workflow Id](/concepts/what-is-a-workflow-id) and [Run Id](/concepts/what-is-a-run-id) to uniquely identify the Workflow Execution.\nIf only the Workflow Id is supplied (provide an empty string as the Run Id param), the Workflow Execution that is Running receives the Signal.\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWorkflow(context.Background(), \"your-workflow-id\", runID, \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n// ...\n```\n\nPossible errors:\n\n- `serviceerror.NotFound`\n- `serviceerror.Internal`\n- `serviceerror.Unavailable`\n\n### Send Signal from within a Workflow\n\nA Signal can be sent from within a Workflow to a different Workflow Execution using the [`SignalExternalWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SignalExternalWorkflow) API from the `go.temporal.io/sdk/workflow` package.\n\n```go\n// ...\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  //...\n  signal := MySignal {\n    Message: \"Some important data\",\n  }\n  err :=  workflow.SignalExternalWorkflow(ctx, \"some-workflow-id\", \"\", \"your-signal-name\", signal).Get(ctx, nil)\n  if err != nil {\n    // ...\n  }\n// ...\n}\n```\n\n### Signal-With-Start\n\nUse the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.\n\nBecause the Workflow Execution might not exist, this API does not take a Run ID as a parameter\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWithStartWorkflow(context.Background(), \"your-workflow-id\", \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n```\n","is_empty":false},{"file_name":"versioning.md","file_path":"/Users/ssantiago/Documents/documentation/docs/go/versioning.md","id":"go/versioning","title":"Versioning","markdown_content":"\nThe definition code of a Temporal Workflow must be deterministic because Temporal uses event sourcing\nto reconstruct the Workflow state by replaying the saved history event data on the Workflow\ndefinition code. This means that any incompatible update to the Workflow Definition code could cause\na non-deterministic issue if not handled correctly.\n\n## Introduction to Versioning\n\nBecause we design for potentially long running Workflows at scale, versioning with Temporal works differently. We explain more in this optional 30 minute introduction: [https://www.youtube.com/watch?v=kkP899WxgzY](https://www.youtube.com/watch?v=kkP899WxgzY)\n\n## workflow.GetVersion()\n\nConsider the following Workflow Definition:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, data string) (string, error) {\n        ao := workflow.ActivityOptions{\n                ScheduleToStartTimeout: time.Minute,\n                StartToCloseTimeout:    time.Minute,\n        }\n        ctx = workflow.WithActivityOptions(ctx, ao)\n        var result1 string\n        err := workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n        if err != nil {\n                return \"\", err\n        }\n        var result2 string\n        err = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\n        return result2, err\n}\n```\n\nNow let's say we have replaced ActivityA with ActivityC, and deployed the updated code. If there\nis an existing Workflow Execution that was started by the original version of the Workflow code, where\nActivityA had already completed and the result was recorded to history, the new version of the Workflow\ncode will pick up that Workflow Execution and try to resume from there. However, the Workflow will fail\nbecause the new code expects a result for ActivityC from the history data, but instead it gets the\nresult for ActivityA. This causes the Workflow to fail on the non-deterministic error.\n\nThus we use `workflow.GetVersion().`\n\n```go\nvar err error\nv := workflow.GetVersion(ctx, \"Step1\", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n}\nif err != nil {\n        return \"\", err\n}\n\nvar result2 string\nerr = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\nreturn result2, err\n```\n\nWhen `workflow.GetVersion()` is run for the new Workflow Execution, it records a marker in the Workflow history so that all future calls to `GetVersion` for this change Id—`Step 1` in the example—on this Workflow Execution will always return the given version number, which is `1` in the example.\n\nIf you make an additional change, such as replacing ActivityC with ActivityD, you need to\nadd some additional code:\n\n```go\nv := workflow.GetVersion(ctx, \"Step1\", workflow.DefaultVersion, 2)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else if v == 1 {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n```\n\nNote that we have changed `maxSupported` from 1 to 2. A Workflow that had already passed this\n`GetVersion()` call before it was introduced will return `DefaultVersion`. A Workflow that was run\nwith `maxSupported` set to 1, will return 1. New Workflows will return 2.\n\nAfter you are sure that all of the Workflow Executions prior to version 1 have completed, you can remove the code for that version.\nIt should now look like the following:\n\n```go\nv := workflow.GetVersion(ctx, \"Step1\", 1, 2)\nif v == 1 {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n```\n\nYou'll note that `minSupported` has changed from `DefaultVersion` to `1`.\nIf an older version of the Workflow Execution history is replayed on this code, it fails because the minimum expected version is 1.\nAfter you are sure that all of the Workflow Executions for version 1 have completed, you can remove version 1 so that your code looks like the following:\n\n```go\n_ := workflow.GetVersion(ctx, \"Step1\", 2, 2)\nerr = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n```\n\nNote that we have preserved the call to `GetVersion()`. There are two reasons to preserve this call:\n\n1. This ensures that if there is a Workflow Execution still running for an older version, it will\n   fail here and not proceed.\n2. If you need to make additional changes for `Step1`, such as changing ActivityD to ActivityE, you\n   only need to update `maxVersion` from 2 to 3 and branch from there.\n\nYou only need to preserve the first call to `GetVersion()` for each `changeID`. All subsequent calls to\n`GetVersion()` with the same change Id are safe to remove. If necessary, you can remove the first\n`GetVersion()` call, but you need to ensure the following:\n\n- All executions with an older version are completed.\n- You can no longer use `Step1` for the changeId. If you need to make changes to that same part in\n  the future, such as change from ActivityD to ActivityE, you would need to use a different changeId\n  like `Step1-fix2`, and start minVersion from DefaultVersion again. The code would look like the\n  following:\n\n```go\nv := workflow.GetVersion(ctx, \"Step1-fix2\", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityE, data).Get(ctx, &result1)\n}\n```\n\nUpgrading a Workflow is straightforward if you don't need to preserve your currently running Workflow Executions.\nYou can simply terminate all of the currently running Workflow Executions and suspend new ones from being created while you deploy the new version of your Workflow code, which does not use `GetVersion()`, and then resume Workflow creation.\nHowever, that is often not the case, and you need to take care of the currently running Workflow Executions, so using `GetVersion()` to update your code is the method to use.\n\nHowever, if you want your currently running Workflows to proceed based on the current Workflow logic,\nbut you want to ensure new Workflows are running on new logic, you can define your Workflow as a\nnew `WorkflowType`, and change your start path (calls to `StartWorkflow()`) to start the new Workflow\ntype.\n\n## Sanity checking\n\nThe Temporal client SDK performs a sanity check to help prevent obvious incompatible changes.\nThe sanity check verifies whether a Command made in replay matches the event recorded in history,\nin the same order. The Command is generated by calling any of the following methods:\n\n- workflow.ExecuteActivity()\n- workflow.ExecuteChildWorkflow()\n- workflow.NewTimer()\n- workflow.RequestCancelWorkflow()\n- workflow.SideEffect()\n- workflow.SignalExternalWorkflow()\n- workflow.Sleep()\n\nAdding, removing, or reordering any of the above methods triggers the sanity check and results in\na non-deterministic error.\n\nThe sanity check does not perform a thorough check. For example, it does not check on the Activity's\ninput arguments or the timer duration. If the check is enforced on every property, then it becomes\ntoo restricted and harder to maintain the Workflow code. For example, if you move your Activity code\nfrom one package to another package, that changes the `ActivityType`, which technically becomes a different\nActivity. But, we don't want to fail on that change, so we only check the function name part of the\n`ActivityType`.\n","is_empty":false},{"file_name":"api-reference-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/api-reference-go.md","id":"go/api-reference-go","title":"API reference","label":"API reference","markdown_content":"\nThe Temporal Go SDK API reference is published on [pkg.go.dev](https://pkg.go.dev/go.temporal.io/sdk).\n","is_empty":false},{"file_name":"code-samples-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/code-samples-go.md","id":"go/code-samples-go","title":"Code samples","label":"Code samples","markdown_content":"\n- [Go Samples repo](https://github.com/temporalio/samples-go#samples-directory)\n- [Background Check application](https://github.com/temporalio/background-checks): Provides a non-trivial Temporal Application implementation in conjunction with [application documentaion](https://learn.temporal.io/examples/go/background-checks/).\n- [Hello world application template in Go](https://github.com/temporalio/hello-world-project-template-go): Provides a quick-start development app for users.\n  This sample works in conjunction with the [\"Hello World!\" from scratch tutorial in Go](https://learn.temporal.io/getting_started/go/hello_world_in_go/).\n- [Money transfer application template in Go](https://github.com/temporalio/money-transfer-project-template-go): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Go](https://learn.temporal.io/getting_started/go/first_program_in_go/).\n- [Subscription-style Workflow Definition in Go](https://github.com/temporalio/subscription-workflow-project-template-go): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n- [eCommerce application example in Go](https://github.com/temporalio/temporal-ecommerce): Showcases a per-user shopping cart–style Workflow Definition that includes an API for adding and removing items from the cart as well as a web UI.\n  This application sample works in conjunction with the [eCommerce in Go tutorial](https://temporal.io/blog/build-an-ecommerce-app-with-temporal-part-1).\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-define-a-signal-in-go.md","id":"go/how-to-define-a-signal-in-go","title":"How to define a Signal in Go","description":"Structs should be used to define Signals and carry data.","label":"Define Signal","tags":["go","developer-guide"],"markdown_content":"\nStructs should be used to define Signals and carry data, as long as the struct is [serializable via the Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#CompositeDataConverter.ToPayload).\nThe `Receive()` method on the Data Converter decodes the data into the Struct within the Workflow.\nOnly public fields are serializable.\n\n```go\nMySignal struct {\n\tMessage string // serializable\n\tmessage string // not serializable\n}\n```\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-define-activity-parameters-in-go.md","id":"go/how-to-define-activity-parameters-in-go","title":"How to define Activity Parameters in Go","description":"The only required parameter is `context.Context`, but Activities can support many custom parameters.","label":"Activity Parameters","tags":["developer-guide","go"],"markdown_content":"\nThe first parameter of an Activity Definition is `context.Context`.\nThis parameter is optional for an Activity Definition, though it is recommended, especially if the Activity is expected to use other Go SDK APIs.\n\nAn Activity Definition can support as many other custom parameters as needed.\nHowever, all parameters must be serializable (parameters can’t be channels, functions, variadic, or unsafe pointers), and it is recommended to pass a single struct that can be updated later.\n\n```go\ntype YourActivityParam struct {\n ActivityParamFieldOne string\n ActivityParamFieldTwo int\n}\n\ntype YourActivityStruct struct {\n // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-define-activity-return-values-in-go.md","id":"go/how-to-define-activity-return-values-in-go","title":"How to define Activity return values in Go","description":"A Go-based Activity Definition can return either just an `error` or a `customValue, error` combination.","label":"Activity return values","tags":["developer-guide","go"],"markdown_content":"\nA Go-based Activity Definition can return either just an `error` or a `customValue, error` combination (same as a Workflow Definition).\nYou may wish to use a `struct` type to hold all custom values, just keep in mind they must all be serializable.\n\n```go\ntype YourActivityResult struct{\n  ActivityResultFieldOne string\n  ActivityResultFieldTwo int\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResult, error) {\n  // ...\n  result := YourActivityResult {\n    ActivityResultFieldOne: a.ActivityFieldOne,\n    ActivityResultFieldTwo: a.ActivityFieldTwo,\n  }\n  return result, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-define-workflow-parameters-in-go.md","id":"go/how-to-define-workflow-parameters-in-go","title":"How to define Workflow parameters in Go","description":"A Go-based Workflow Definition must accept `workflow.Context` and may support multiple custom parameters.","label":"Workflow parameters","tags":["go","how-to"],"markdown_content":"\nThe first parameter of a Go-based Workflow Definition must be of the [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context) type, as it is used by the Temporal Go SDK to pass around Workflow Execution context, and virtually all the Go SDK APIs that are callable from the Workflow require it.\nIt is acquired from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package.\n\n```go\nimport (\n   \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param string) error {\n // ...\n}\n```\n\nThe `workflow.Context` entity operates similarly to the standard `context.Context` entity provided by Go.\nThe only difference between `workflow.Context` and `context.Context` is that the `Done()` function, provided by `workflow.Context`, returns `workflow.Channel` instead of the standard Go `chan`.\n\nThe second parameter, `string`, is a custom parameter that is passed to the Workflow when it is invoked.\nA Workflow Definition may support multiple custom parameters, or none.\nThese parameters can be regular type variables or safe pointers.\nHowever, the best practice is to pass a single parameter that is of a `struct` type, so there can be some backward compatibility if new parameters are added.\n\n```go\ntype YourWorkflowParam struct {\n WorkflowParamFieldOne string\n WorkflowParamFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n // ...\n}\n```\n\nAll Workflow Definition parameters must be serializable, regardless of whether pointers or regular type values are used.\nParameters can’t be channels, functions, variadic, or unsafe pointers.\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-define-workflow-return-values-in-go.md","id":"go/how-to-define-workflow-return-values-in-go","title":"How to define Workflow return values in Go","description":"A Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.","label":"Workflow return values","tags":["go","how-to"],"markdown_content":"\nA Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.\nAgain, the best practice here is to use a `struct` type to hold all custom values.\n\n```go\ntype YourWorkflowResponse struct{\n WorkflowResultFieldOne string\n WorkflowResultFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n if err != nil {\n   return \"\", err\n }\n responseVar := YourWorkflowResponse {\n   FieldOne: \"super\",\n   FieldTwo: 1,\n }\n return responseVar, nil\n}\n```\n\nA Workflow Definition written in Go can return both a custom value and an error.\nHowever, it's not possible to receive both a custom value and an error in the calling process, as is normal in Go.\nThe caller will receive either one or the other.\nReturning a non-nil `error` from a Workflow indicates that an error was encountered during its execution and the Workflow Execution should be terminated, and any custom return values will be ignored by the system.\n","is_empty":false},{"file_name":"how-to-develop-a-worker-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-develop-a-worker-in-go.md","id":"go/how-to-develop-a-worker-in-go","title":"How to develop a Worker in Go","description":"Develop an instance of a Worker by calling `worker.New()`, available via the `go.temporal.io/sdk/worker` package.","label":"Develop Worker","tags":["developer-guide","go","workers"],"markdown_content":"\nCreate an instance of [`Worker`](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) by calling [`worker.New()`](https://pkg.go.dev/go.temporal.io/sdk/worker#New), available through the `go.temporal.io/sdk/worker` package, and pass it the following parameters:\n\n1. An instance of the Temporal Go SDK `Client`.\n1. The name of the Task Queue that it will poll.\n1. An instance of [`worker.Options`](/go/how-to-set-workeroptions-in-go), which can be empty.\n\nThen, register the Workflow Types and the Activity Types that the Worker will be capable of executing.\n\nLastly, call either the `Start()` or the `Run()` method on the instance of the Worker.\nRun accepts an interrupt channel as a parameter, so that the Worker can be stopped in the terminal.\nOtherwise, the `Stop()` method must be called to stop the Worker.\n\n```go\npackage main\n\nimport (\n   \"go.temporal.io/sdk/client\"\n   \"go.temporal.io/sdk/worker\"\n)\n\nfunc main() {\n   c, err := client.Dial(client.Options{})\n   if err != nil {\n       // ...\n   }\n   defer c.Close()\n   w := worker.New(c, \"your-task-queue\", worker.Options{})\n   w.RegisterWorkflow(YourWorkflowDefinition)\n   w.RegisterActivity(YourActivityDefinition)\n   err = w.Run(worker.InterruptCh())\n   if err != nil {\n       // ...\n   }\n // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n}\n\nfunc YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResponse, error) {\n // ...\n}\n```\n\n:::tip\n\nIf you have [`gow`](https://github.com/mitranim/gow) installed, the Worker Process automatically \"reloads\" when you update the Worker file:\n\n```bash\ngo install github.com/mitranim/gow@latest\ngow run worker/main.go # automatically reload when file changed\n```\n\n:::\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-develop-a-workflow-definition-in-go.md","id":"go/how-to-develop-a-workflow-definition-in-go","title":"How to develop a Workflow Definition in Go","description":"In the Temporal Go SDK programming model, a Workflow Definition is an exportable function.","label":"Workflow Definition","tags":["developer-guide","go"],"markdown_content":"\nIn the Temporal Go SDK programming model, a [Workflow Definition](/concepts/what-is-a-workflow-definition) is an exportable function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context) error {\n  // ...\n  return nil\n}\n```\n\nIn Go, by default, the Workflow Type name is the same as the function name.\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-develop-an-activity-definition-in-go.md","id":"go/how-to-develop-an-activity-definition-in-go","title":"How to develop an Activity Definition in Go","description":"In the Temporal Go SDK programming model, an Activity Definition is an exportable function or `stuct` method.","label":"Activity Definition","tags":["developer-guide","go"],"markdown_content":"\nIn the Temporal Go SDK programming model, an Activity Definition is an exportable function or a `struct` method.\n\n**Function**\n\n```go\n// basic function signature\nfunc YourActivityDefinition(ctx context.Context) error {\n // ...\n return nil\n}\n\n// with parameters and return values\nfunc SimpleActivity(ctx context.Context, value string) (string, error)\n```\n\n**Struct method**\n\n```go\ntype YourActivityStruct struct {\n ActivityFieldOne string\n ActivityFieldTwo int\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinition(ctx context.Context) error {\n // ...\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinitionTwo(ctx context.Context) error {\n // ...\n}\n```\n\nAn _Activity struct_ can have more than one method, with each method acting as a separate Activity Type.\nActivities written as struct methods can use shared struct variables, such as:\n\n- an application level DB pool\n- client connection to another service\n- reusable utilities\n- any other expensive resources that you only want to initialize once per process\n\nBecause this is such a common need, the rest of this guide shows Activities written as `struct` methods.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-get-the-result-of-a-workflow-execution-in-go.md","id":"go/how-to-get-the-result-of-a-workflow-execution-in-go","title":"How to get the result of a Workflow Execution in Go","description":"Use the Future returned by `ExecuteWorkflow` API call to retrieve the result.","label":"Workflow Execution result","tags":["developer-guide","go"],"markdown_content":"\nThe `ExecuteWorkflow` call returns an instance of [`WorkflowRun`](https://pkg.go.dev/go.temporal.io/sdk/client#WorkflowRun), which is the `workflowRun` variable in the following line.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, app.YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n // ...\n}\n```\n\nThe instance of `WorkflowRun` has the following three methods:\n\n- `GetWorkflowID()`: Returns the Workflow Id of the invoked Workflow Execution.\n- `GetRunID()`: Always returns the Run Id of the initial Run (See [Continue As New](#)) in the series of Runs that make up the full Workflow Execution.\n- `Get`: Takes a pointer as a parameter and populates the associated variable with the Workflow Execution result.\n\nTo wait on the result of Workflow Execution in the same process that invoked it, call `Get()` on the instance of `WorkflowRun` that is returned by the `ExecuteWorkflow()` call.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n}\n```\n\nHowever, the result of a Workflow Execution can be obtained from a completely different process.\nAll that is needed is the [Workflow Id](#).\n(A [Run Id](#) is optional if more than one closed Workflow Execution has the same Workflow Id.)\nThe result of the Workflow Execution is available for as long as the Workflow Execution Event History remains in the system.\n\n<!-- TODO (See [How long do Workflow Execution Histories persist](#)). -->\n\nCall the `GetWorkflow()` method on an instance of the Go SDK Client and pass it the Workflow Id used to spawn the Workflow Execution.\nThen call the `Get()` method on the instance of `WorkflowRun` that is returned, passing it a pointer to populate the result.\n\n```go\n // ...\n workflowID := \"Your-Custom-Workflow-Id\"\n workflowRun := c.GetWorkflow(context.Background, workflowID)\n\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n```\n\n**Get last completion result**\n\nIn the case of a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job), you might need to get the result of the previous Workflow Run and use it in the current Workflow Run.\n\nTo do this, use the [`HasLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#HasLastCompletionResult) and [`GetLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLastCompletionResult) APIs, available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package, directly in your Workflow code.\n\n```go\ntype CronResult struct {\n Count int\n}\n\nfunc YourCronWorkflowDefinition(ctx workflow.Context) (CronResult, error) {\n count := 1\n\n if workflow.HasLastCompletionResult(ctx) {\n   var lastResult CronResult\n   if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {\n     count = count + lastResult.Count\n   }\n }\n\n newResult := CronResult {\n   Count: count,\n }\n return newResult, nil\n}\n```\n\nThis will work even if one of the cron Workflow Runs fails.\nThe next Workflow Run gets the result of the last successfully Completed Workflow Run.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-get-the-result-of-an-activity-execution-in-go.md","id":"go/how-to-get-the-result-of-an-activity-execution-in-go","title":"How to get the result of an Activity Execution in Go","description":"Use the Future returned from the `ExecuteActivity` API call to retrieve the result.","label":"Activity Execution result","tags":["developer-guide","go"],"markdown_content":"\nThe `ExecuteActivity` API call returns an instance of [`workflow.Future`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Futures) which has the following two methods:\n\n- `Get()`: Takes an instance of the `workflow.Context`, that was passed to the Activity Execution, and a pointer as parameters.\n  The variable associated with the pointer is populated with the Activity Execution result.\n  This call blocks until the results are available.\n- `IsReady()`: Returns `true` when the result of the Activity Execution is ready.\n\nCall the `Get()` method on the instance of `workflow.Future` to get the result of the Activity Execution.\nThe type of the result parameter must match the type of the return value declared by the Activity function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n var yourActivityResult YourActivityResult\n if err := future.Get(ctx, &yourActivityResult); err != nil {\n   // ...\n }\n // ...\n}\n```\n\nUse the `IsReady()` method first to make sure the `Get()` call doesn't cause the Workflow Execution to wait on the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n // ...\n if(future.IsReady()) {\n   var yourActivityResult YourActivityResult\n   if err := future.Get(ctx, &yourActivityResult); err != nil {\n     // ...\n   }\n }\n // ...\n}\n```\n\nIt is idiomatic to invoke multiple Activity Executions from within a Workflow.\nTherefore, it is also idiomatic to either block on the results of the Activity Executions or continue on to execute additional logic, checking for the Activity Execution results at a later time.\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-handle-a-signal-in-go.md","id":"go/how-to-handle-a-signal-in-go","title":"How to handle a Signal in Go","description":"Use the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.","label":"Handle Signal","tags":["go","how-to"],"markdown_content":"\nUse the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  // ...\n  var signal MySignal\n  signalChan := workflow.GetSignalChannel(ctx, \"your-signal-name\")\n  signalChan.Receive(ctx, &signal)\n  if len(signal.Message) > 0 && signal.Message != \"SOME_VALUE\" {\n      return errors.New(\"signal\")\n  }\n  // ...\n}\n```\n\nIn the example above, the Workflow code uses `workflow.GetSignalChannel` to open a `workflow.Channel` for the Signal type (identified by the Signal name).\n\nBefore completing the Workflow or using [Continue-As-New](/application-development/features#continue-as-new), make sure to do an asynchronous drain on the Signal channel.\nOtherwise, the Signals will be lost.\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-handle-workflow-logic-requirements-in-go.md","id":"go/how-to-handle-workflow-logic-requirements-in-go","title":"How to handle Workflow logic requirements in Go","description":"In Go, Workflow Definition code cannot directly do a few things to adhere to deterministic constraints.","label":"Workflow logic requirements","tags":["go","how-to"],"markdown_content":"\nIn Go, Workflow Definition code cannot directly do the following:\n\n- Iterate over maps using `range`, because with `range` the order of the map's iteration is randomized.\n  Instead you can collect the keys of the map, sort them, and then iterate over the sorted keys to access the map.\n  This technique provides deterministic results.\n  You can also use a Side Effect or an Activity to process the map instead.\n- Call an external API, conduct a file I/O operation, talk to another service, etc. (Use an Activity for these.)\n\nThe Temporal Go SDK has APIs to handle equivalent Go constructs:\n\n- `workflow.Now()` This is a replacement for `time.Now()`.\n- `workflow.Sleep()` This is a replacement for `time.Sleep()`.\n- `workflow.GetLogger()` This ensures that the provided logger does not duplicate logs during a replay.\n- `workflow.Go()` This is a replacement for the `go` statement.\n- `workflow.Channel` This is a replacement for the native `chan` type.\n  Temporal provides support for both buffered and unbuffered channels.\n- `workflow.Selector` This is a replacement for the `select` statement. Learn more on the [Go SDK Selectors](/go/selectors) page\n- `workflow.Context` This is a replacement for `context.Context`. Learn more on the [Go SDK Context Propagation](/go/tracing) page.\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-heartbeat-an-activity-in-go.md","id":"go/how-to-heartbeat-an-activity-in-go","title":"How to Heartbeat an Activity in Go","description":"Use, the `RecordHeartbeat` API to report that the execution is alive and progressing.","label":"Activity Heartbeats","tags":["go","developer-guide"],"markdown_content":"\nTo [Heartbeat](/concepts/what-is-an-activity-heartbeat) in an Activity in Go, use the `RecordHeartbeat` API.\n\n```go\nimport (\n    // ...\n    \"go.temporal.io/sdk/workflow\"\n    // ...\n)\n\nfunc YourActivityDefinition(ctx, YourActivityDefinitionParam) (YourActivityDefinitionResult, error) {\n    // ...\n    activity.RecordHeartbeat(ctx, details)\n    // ...\n}\n```\n\nWhen an Activity Task Execution times out due to a missed Heartbeat, the last value of the `details` variable above is returned to the calling Workflow in the `details` field of `TimeoutError` with `TimeoutType` set to `Heartbeat`.\n\nYou can also Heartbeat an Activity from an external source:\n\n```go\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n// Record heartbeat.\nerr := temporalClient.RecordActivityHeartbeat(ctx, taskToken, details)\n```\n\nThe parameters of the `RecordActivityHeartbeat` function are:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `details`: The serializable payload containing progress information.\n\nIf an Activity Execution Heartbeats its progress before it failed, the retry attempt will have access to the progress information, so that the Activity Execution can resume from the failed state.\nHere's an example of how this can be implemented:\n\n```go\nfunc SampleActivity(ctx context.Context, inputArg InputParams) error {\n    startIdx := inputArg.StartIndex\n    if activity.HasHeartbeatDetails(ctx) {\n        // Recover from finished progress.\n        var finishedIndex int\n        if err := activity.GetHeartbeatDetails(ctx, &finishedIndex); err == nil {\n            startIdx = finishedIndex + 1 // Start from next one.\n        }\n    }\n\n    // Normal Activity logic...\n    for i:=startIdx; i<inputArg.EndIdx; i++ {\n        // Code for processing item i goes here...\n        activity.RecordHeartbeat(ctx, i) // Report progress.\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-register-namespace-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-register-namespace-in-go.md","id":"go/how-to-register-namespace-in-go","title":"How to register a Namespace in Go","description":"Use the `NamespaceClient` interface with the `Register` APIs to register your namespace.","label":"Register Namespaces","tags":["developer-guide","go","workers"],"markdown_content":"\nUse [`Register` API](https://pkg.go.dev/go.temporal.io/sdk@v1.17.0/client#NamespaceClient.Register) with the `NamespaceClient` interface to register a [Namespace](/concepts/what-is-a-namespace) and set the [Retention Period](/concepts/what-is-a-retention-period) for the Workflow Execution Event History for the Namespace.\n\nYou can also [register Namespaces using the tctl command-line tool](/tctl-v1/namespace/register).\n\n```go\nclient, err := client.NewNamespaceClient(client.Options{HostPort: ts.config.ServiceAddr})\n        //...\n    err = client.Register(ctx, &workflowservice.RegisterNamespaceRequest{\n        Namespace: your-namespace-name,\n        WorkflowExecutionRetentionPeriod: &retention,\n    })\n```\n\nThe Retention Period setting using `WorkflowExecutionRetentionPeriod` is mandatory.\nThe minimum value you can set for this period is 1 day.\n\nOnce registered, set Namespace using `Dial` in a Workflow Client to run your Workflow Executions within that Namespace.\nSee [how to set Namespace in a Client in Go](/app-dev-context/connect-to-a-cluster) for details.\n\nNote that Namespace registration using this API takes up to 10 seconds to complete.\nEnsure that you wait for this registration to complete before starting the Workflow Execution against the Namespace.\n\nTo update your Namespace, use the [`Update` API](https://pkg.go.dev/go.temporal.io/sdk@v1.17.0/client#NamespaceClient.Update) with the `NamespaceClient`.\n\nTo update your Namespace using tctl, use the [tctl namespace update](/tctl-v1/namespace/update) command.\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-register-types-with-a-worker-in-go.md","id":"go/how-to-register-types-with-a-worker-in-go","title":"How to register types with a Worker in Go","description":"The `RegisterWorkflow()` and `RegisterActivity()` calls create an in-memory mapping between the Workflow Types and their implementations.","label":"Register Types","tags":["developer-guide","go","workers"],"markdown_content":"\nThe `RegisterWorkflow()` and `RegisterActivity()` calls essentially create an in-memory mapping between the Workflow Types and their implementations, inside the Worker process.\n\n**Registering Activity `structs`**\n\nPer [Activity Definition](/go/how-to-develop-an-activity-definition-in-go) best practices, you might have an Activity struct that has multiple methods and fields.\nWhen you use `RegisterActivity()` for an Activity struct, that Worker has access to all exported methods.\n\n**Registering multiple Types**\n\nTo register multiple Activity Types and/or Workflow Types with the Worker Entity, just make multiple Activity registration calls, but make sure each Type name is unique:\n\n```go\nw.registerActivity(ActivityA)\nw.registerActivity(ActivityB)\nw.registerActivity(ActivityC)\nw.registerWorkflow(WorkflowA)\nw.registerWorkflow(WorkflowB)\nw.registerWorkflow(WorkflowC)\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-send-a-signal-from-a-client-in-go.md","id":"go/how-to-send-a-signal-from-a-client-in-go","title":"How to send a Signal from a Temporal Client in Go","description":"Use the `SignalWorkflow()` method on an instance of the Go SDK Temporal Client to send a Signal to a Workflow Execution.","label":"Send Signal from Client","tags":["go","how-to"],"markdown_content":"\nUse the `SignalWorkflow()` method on an instance of the [Go SDK Temporal Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) to send a [Signal](/concepts/what-is-a-signal) to a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nPass in both the [Workflow Id](/concepts/what-is-a-workflow-id) and [Run Id](/concepts/what-is-a-run-id) to uniquely identify the Workflow Execution.\nIf only the Workflow Id is supplied (provide an empty string as the Run Id param), the Workflow Execution that is Running receives the Signal.\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWorkflow(context.Background(), \"your-workflow-id\", runID, \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n// ...\n```\n\nPossible errors:\n\n- `serviceerror.NotFound`\n- `serviceerror.Internal`\n- `serviceerror.Unavailable`\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-send-a-signal-from-a-workflow-in-go.md","id":"go/how-to-send-a-signal-from-a-workflow-in-go","title":"How to send a Signal from a Workflow in Go","description":"A Signal can be sent from within a Workflow to a different Workflow Execution using the `SignalExternalWorkflow` API from the `go.temporal.io/sdk/workflow` package.","label":"Send Signal from Workflow","tags":["go","how-to"],"markdown_content":"\nA Signal can be sent from within a Workflow to a different Workflow Execution using the [`SignalExternalWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SignalExternalWorkflow) API from the `go.temporal.io/sdk/workflow` package.\n\n```go\n// ...\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  //...\n  signal := MySignal {\n    Message: \"Some important data\",\n  }\n  err :=  workflow.SignalExternalWorkflow(ctx, \"some-workflow-id\", \"\", \"your-signal-name\", signal).Get(ctx, nil)\n  if err != nil {\n    // ...\n  }\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-send-a-signal-with-start-in-go.md","id":"go/how-to-send-a-signal-with-start-in-go","title":"How to send a Signal-With-Start in Go","description":"Use the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.","label":"Signal-With-Start","tags":["go","how-to"],"markdown_content":"\nUse the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.\n\nBecause the Workflow Execution might not exist, this API does not take a Run ID as a parameter\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWithStartWorkflow(context.Background(), \"your-workflow-id\", \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-spawn-a-workflow-execution-in-go.md","id":"go/how-to-spawn-a-workflow-execution-in-go","title":"How to spawn a Workflow Execution in Go","description":"Use the `ExecuteWorkflow()` method on the Go SDK `Client`, which is available via `Dial()` in the `go.temporal.io/sdk/client` package.","label":"Workflow Execution","tags":["developer-guide","go"],"markdown_content":"\nTo spawn a [Workflow Execution](/concepts/what-is-a-workflow-execution), use the `ExecuteWorkflow()` method on the Go SDK [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nThe `ExecuteWorkflow()` API call requires an instance of [`context.Context`](https://pkg.go.dev/context#Context), an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions), a Workflow Type name, and all variables to be passed to the Workflow Execution.\nThe `ExecuteWorkflow()` call returns a Future, which can be used to get the result of the Workflow Execution.\n\n```go\npackage main\n\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n  workflowOptions := client.StartWorkflowOptions{\n    // ...\n  }\n  workflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n  if err != nil {\n    // ...\n  }\n  // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n}\n```\n\nIf the invocation process has access to the function directly, then the Workflow Type name parameter can be passed as if the function name were a variable, without quotations.\n\n```go\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n```\n\nIf the invocation process does not have direct access to the statically defined Workflow Definition, for example, if the Workflow Definition is in an un-importable package, or it is written in a completely different language, then the Workflow Type can be provided as a `string`.\n\n```go\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, \"YourWorkflowDefinition\", param)\n```\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-spawn-an-activity-execution-in-go.md","id":"go/how-to-spawn-an-activity-execution-in-go","title":"How to spawn an Activity Execution in Go","description":"Use the `ExecuteActivity()` API call available from the `go.temporal.io/sdk/workflow` package.","label":"Activity Execution","tags":["developer-guide","go"],"markdown_content":"\nTo spawn an [Activity Execution](/concepts/what-is-an-activity-execution), call [`ExecuteActivity()`](https://pkg.go.dev/go.temporal.io/workflow#ExecuteActivity) inside your Workflow Definition.\nThe API is available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/workflow) package.\n\nThe `ExecuteActivity()` API call requires an instance of `workflow.Context`, the Activity function name, and any variables to be passed to the Activity Execution.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n  yourActivityParam := YourActivityParam{\n    // ...\n  }\n  var activities *YourActivityStruct\n  future := workflow.ExecuteActivity(ctx, activities.YourActivityDefinition, yourActivityParam)\n  // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n  // ...\n}\n```\n\nThe Activity function name can be provided as a variable object (no quotations) or as a string.\n\n```go\n// ...\n  future := workflow.ExecuteActivity(ctx, \"YourActivityDefinition\", yourActivityParam)\n// ...\n```\n\nThe benefit of passing the actual function object is that the framework can validate the parameters against the Activity Definition.\n\nThe `ExecuteActivity` call returns a Future, which can be used to get the result of the Activity Execution.\n","is_empty":false},{"file_name":"how-to-use-test-frameworks-in-go.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-use-test-frameworks-in-go.md","id":"go/how-to-use-test-frameworks-in-go","title":"How to use the test framework in Go","description":"To use the test framework in Go, import `helloworld_test.go`.","label":"Test Framework","tags":["developer-guide","go"],"markdown_content":"\nTo use the test framework in Go, import the following packages, use the [samples-go repo](https://github.com/temporalio/samples-go/), and run `go test ./helloworld` to run these sample tests.\n\n[helloworld/helloworld_test.go](https://github.com/temporalio/samples-go/blob/main/helloworld/helloworld_test.go)\n","is_empty":false},{"file_name":"how-to-use-the-go-sdk.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/go/how-to-use-the-go-sdk.md","id":"go/how-to-use-the-go-sdk","title":"How to use the Temporal Go SDK","description":"Add the Temporal Go SDK to your project.","tags":["developer-guide","go"],"markdown_content":"\n[![Build Status](https://badge.buildkite.com/ce6df3b1a8b375270261ae70fb2d2756af298fef3a0dac4d20.svg?theme=github&branch=master)](https://buildkite.com/temporal/temporal-go-client) [![Coverage Status](https://coveralls.io/repos/github/temporalio/temporal-go-sdk/badge.svg?branch=master)](https://coveralls.io/github/temporalio/temporal-go-sdk?branch=master) [![Go reference](https://pkg.go.dev/badge/go.temporal.io/sdk)](https://pkg.go.dev/go.temporal.io/sdk)\n\nAdd the [Temporal Go SDK](https://github.com/temporalio/sdk-go) to your project:\n\n```bash\ngo get go.temporal.io/sdk\n```\n\nOr clone the Go SDK repo to your preferred location:\n\n```bash\ngit clone git@github.com:temporalio/sdk-go.git\n```\n","is_empty":false},{"file_name":"activities.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/activities.md","id":"java/activities","title":"Activities in Java","label":"Activities","markdown_content":"\n## What is an Activity?\n\nActivities are implementations of certain tasks that need to be performed during a Workflow Execution.\nThey can be used to interact with external systems, such as databases and services.\n\nWorkflows orchestrate invocations of Activities.\n\nJust like [Workflows](./workflows.md), Activities must be registered with a [Worker](./workers.md).\n\n### Activity interface\n\nSimilar to Workflows, Activities in Temporal Java SDK programming model are classes which implement\nthe ActivityInterface Interface.\n\nActivity Interfaces are Java Interfaces which are annotated with the `@ActivityInterface` annotation:\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    String composeGreeting(String greeting, String language);\n}\n```\n\nEach method defined in the Activity interface defines a separate Activity method.\nYou can annotate each method in the Activity interface with the `@ActivityMethod`\nannotation, but this is completely optional, for example:\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod(name = \"greet\")\n    String composeGreeting(String greeting, String language);\n}\n```\n\nNote that the `@ActivityMethod` annotation has a `name` parameter which can be used to define the Activity type.\nIf it is specified like in the example above the type would be \"greet\".\nIf not specified, the Activity method name (with the first letter capitalized) is used by default, so in the example again it would be `composeGreeting`.\n\n### Activity implementation\n\nAn Activity implementation is Java class which implements an Activity Interface, for example:\n\n```java\n  public class MultiLanguageGreeting implements GreetingsActivities {\n    private final TranslationService translationService;\n\n    public MultiLanguageGreeting(TranslationService translationService) {\n      this.translationService = translationService;\n    }\n\n    @Override\n    public String composeGreeting(String greeting, String language) {\n      return translationService.translate(greeting, language);\n    }\n  }\n```\n\n## Registering Activities with a Worker\n\nJust like Workflows, Activities need to be registered with a Worker, for example:\n\n```java\n    Worker worker = factory.newWorker(TASK_QUEUE);\n    ...\n    // register the Activity\n    worker.registerActivitiesImplementations(new MultiLanguageGreeting(translationService));\n```\n\nNote that when registering Activities, we register an instance of the Activity implementation, and can pass any\nnumber of dependencies in its constructor, such as the database connections, services, etc.\n\n## Invoking Activities inside Workflows\n\nSimilar to Workflows, Activities should only be instantiated via stubs.\n\n`Workflow.newActivityStub` returns a client-side stub that implements an Activity interface.\nIt takes Activity type and Activity options as arguments.\nActivity options allow you to specify different Activity timeout and retry options.\n\nCalling a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if an Activity's execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\nLet's take a look at an example Workflow that calls Activities:\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) {\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    // ...\n}\n```\n\nIn this example we use `Workflow.newActivityStub` to create a client-side stub of our file processing Activity.\nWe also define ActivityOptions and set the setStartToCloseTimeout timeout to one hour, meaning that we set the total execution timeout for each of its method invocations to one hour (from when the Activity Execution is started to when it completes).\n\nWorkflow can create multiple Activity stubs. Each activity stub can have its own ActivityOptions defined, for example:\n\n```java\npublic FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue1\")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue2\")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n```\n\n### Invoking Activities Asynchronously\n\nSometimes Workflows need to perform certain operations in parallel.\nThe Temporal Java SDK provides the `Async` class which includes static methods used to invoke any Activity asynchronously.\nThe calls return a result of type `Promise` which is similar to the Java `Future` and `CompletionStage`.\n\nWhen you need to get the results of an async invoked Activity method, you can use the `Promise` `get` method to block until the Activity method result is available.\n\nTo convert the following synchronous Activity method call:\n\n```java\nString localName = activities.download(sourceBucket, sourceFile);\n```\n\nTo asynchronous style, the method reference is passed to `Async.function` or `Async.procedure`\nfollowed by Activity arguments:\n\n```java\nPromise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);\n```\n\nThen to wait synchronously for the result you can do the following:\n\n```java\nString localName = localNamePromise.get();\n```\n\nHere is the above example rewritten to call download and upload Activity methods in parallel, on multiple files:\n\n```java\n  public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n      // Download all files in parallel.\n      for (String sourceFilename : args.getSourceFilenames()) {\n        Promise<String> localName =\n            Async.function(activities::download, args.getSourceBucketName(), sourceFilename);\n        localNamePromises.add(localName);\n      }\n      List<String> localNames = new ArrayList<>();\n      for (Promise<String> localName : localNamePromises) {\n        localNames.add(localName.get());\n      }\n      processedNames = activities.processFiles(localNames);\n\n      // Upload all results in parallel.\n      List<Promise<Void>> uploadedList = new ArrayList<>();\n      for (String processedName : processedNames) {\n        Promise<Void> uploaded =\n            Async.procedure(\n                activities::upload,\n                args.getTargetBucketName(),\n                args.getTargetFilename(),\n                processedName);\n        uploadedList.add(uploaded);\n      }\n      // Wait for all uploads to complete.\n      Promise.allOf(uploadedList).get();\n    } finally {\n      for (Promise<String> localNamePromise : localNamePromises) {\n        // Skip files that haven't completed downloading.\n        if (localNamePromise.isCompleted()) {\n          activities.deleteLocalFile(localNamePromise.get());\n        }\n      }\n      if (processedNames != null) {\n        for (String processedName : processedNames) {\n          activities.deleteLocalFile(processedName);\n        }\n      }\n    }\n  }\n```\n\n## Invoking Activities via `Workflow.newUntypedActivityStub`\n\nIt is also possible to invoke Activities inside Workflows using `Workflow.newUntypedActivityStub`, meaning you can\ninvoke them without referencing an interface it implements.\nThis is useful in scenarios where the Activity type is not known at compile time, or to invoke\nActivities implemented in different programming languages.\n\n```java\n   // Workflow code\n    ActivityOptions activityOptions =\n        ActivityOptions.newBuilder()\n        .setStartToCloseTimeout(Duration.ofSeconds(3))\n        .setTaskQueue(\"simple-queue-node\")\n        .build();\n\n    ActivityStub activity = Workflow.newUntypedActivityStub(activityOptions);\n    activity.execute(\"ComposeGreeting\", String.class, \"Hello World\" , \"Spanish\");\n```\n\n## Activity Execution Context\n\n`ActivityExecutionContext` is a context object passed to each Activity implementation by default.\nYou can access it in your Activity implementations via `Activity.getExecutionContext()`.\n\nIt provides getters to access information about the Workflow that invoked the Activity.\nNote that the Activity context information is stored in a thread-local variable.\nTherefore, calls to `getExecutionContext()` succeed only within the thread that invoked the Activity function.\n\nFollowing is an example of using the `ActivityExecutionContext`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n    ActivityInfo info = ctx.getInfo();\n\n    log.info(\"namespace=\" +  info.getActivityNamespace());\n    log.info(\"workflowId=\" + info.getWorkflowId());\n    log.info(\"runId=\" + info.getRunId());\n    log.info(\"activityId=\" + info.getActivityId());\n    log.info(\"activityTimeout=\" + info.getStartToCloseTimeoutSeconds());\n\n    return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n  }\n    ...\n}\n```\n\n## Asynchronous Activity Completion\n\nSometimes an Activity lifecycle goes beyond a synchronous method invocation.\nFor example, a request can be put in a queue and later a reply comes and is picked up by a different Worker process.\nThe whole request-reply interaction can be modeled as a single Activity.\n\nTo indicate that an Activity should not be completed upon its method return, call `ActivityExecutionContext.doNotCompleteOnReturn()` from the original Activity thread.\n\nThen later, when replies come, complete the Activity using the `ActivityCompletionClient`.\nTo correlate Activity invocation with completion, use either a `TaskToken` or Workflow and Activity Ids.\n\nFollowing is an example of using `ActivityExecutionContext.doNotCompleteOnReturn()`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n\n    // Used to correlate reply\n    byte[] taskToken = ctx.getInfo().getTaskToken();\n    asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n    ctx.doNotCompleteOnReturn();\n\n    // Return value is ignored when doNotCompleteOnReturn was called.\n    return \"ignored\";\n  }\n  ...\n}\n```\n\nWhen the download is complete, the download service potentially can complete the Activity, or fail it from a different process, for example:\n\n```java\n  public <R> void completeActivity(byte[] taskToken, R result) {\n    completionClient.complete(taskToken, result);\n  }\n\n  public void failActivity(byte[] taskToken, Exception failure) {\n    completionClient.completeExceptionally(taskToken, failure);\n  }\n```\n\n## Activity heartbeats\n\nActivities can be long-running.\nIn these cases the Activity Execution timeouts should be set to be longer than the maximum predicted time of the Activity Execution.\nIn those cases it can happen that an Activity Execution is started and cannot proceed, or fails to continue its execution for some reasons.\nWith our long set execution timeout the calling Workflow will not be able to time out the Activity and retry it or fail it until this timeout is reached.\n\nIn order to react quickly to crashes of long-running Activities you can use the Activity heartbeat mechanism.\nYou can set a short heartbeat timeout in order to detect Activity issues and react to them without having to wait for the long Activity Execution timeout to complete first.\n\n`Activity.getExecutionContext().heartbeat()` lets the Temporal service know that the Activity is still alive.\n\nThe `Activity.getExecutionContext().heartbeat()` can take an argument which represents heartbeat\n`details`.\nIf an Activity times out, the last heartbeat `details` will be included in the thrown `ActivityTimeoutException` which can be caught by the calling Workflow.\nThe Workflow then can use the `details` information to pass to the next Activity invocation if needed.\n\nIn the case of Activity retries, the last Heartbeat's `details` are available and can be extracted from the last fail attempt using `Activity.getExecutionContext().getHeartbeatDetails(Class<V> detailsClass)`\n\nFollowing is an example of using Activity heartbeat:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n    InputStream inputStream = openInputStream(file);\n    try {\n      byte[] bytes = new byte[MAX_BUFFER_SIZE];\n      while ((read = inputStream.read(bytes)) != -1) {\n        totalRead += read;\n        f.write(bytes, 0, read);\n        // Let the Server know about the download progress.\n        Activity.getExecutionContext().heartbeat(totalRead);\n      }\n    } finally{\n      inputStream.close();\n    }\n  }\n  ...\n}\n```\n\n## Throwing Activity errors\n\nIf there is a need to throw checked Exception from Activity methods which do not support re-throwing checked Exceptions in their signatures,\nyou should wrap them using the `Activity.wrap` method and re-throw the Exceptions.\n\nThere is no need to wrap unchecked Exceptions, but it's safe to do so if you want to.\n\nIn addition, when wrapping checked Exceptions, the original Exception is attached as a cause to the wrapped one, and is not lost.\n\nHere is an example of catching a checked Exception and wrapping it:\n\n```java\ntry {\n  return someCall();\n} catch (Exception e) {\n  throw Activity.wrap(e);\n}\n```\n\nNote that any Exception thrown from an Activity is converted to `io.temporal.failure.ApplicationFailure`, unless the thrown Exception extends `io.temporal.failure.TemporalException` .\n","is_empty":false},{"file_name":"api-reference-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/api-reference-java.md","id":"java/api-reference-java","title":"API reference","label":"API reference","markdown_content":"\nThe Temporal Java SDK API reference is published on [javadoc.io](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/index.html).\n","is_empty":false},{"file_name":"code-samples-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/code-samples-java.md","id":"java/code-samples-java","title":"Code samples","label":"Code samples","markdown_content":"\n- [Java samples library](https://github.com/temporalio/samples-java)\n- [Hello world application template in Java](https://github.com/temporalio/hello-world-project-template-java): Provides a quick-start development app for users.\n  Works in conjunction with the [\"Hello World!\" from scratch tutorial in Java](https://learn.temporal.io/getting_started/java/hello_world_in_java/).\n- [Money transfer application template in Java](https://github.com/temporalio/money-transfer-project-template-java): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Java](https://learn.temporal.io/getting_started/java/first_program_in_java/).\n- [Subscription-style Workflow Definition in Java](https://github.com/temporalio/subscription-workflow-project-template-java): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n","is_empty":false},{"file_name":"distributed-cron.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/distributed-cron.md","id":"java/distributed-cron","title":"Distributed CRON","markdown_content":"\n<!-- prettier-ignore -->\nimport * as WhatIsATemporalCronJob from '../concepts/what-is-a-temporal-cron-job.md'\n\nThis is how you set a cron schedule in Java:\n\n```java\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder()\n            .setWorkflowId(WORKFLOW_ID)\n            .setTaskQueue(TASK_QUEUE)\n            .setCronSchedule(\"* * * * *\")\n            .setWorkflowExecutionTimeout(Duration.ofMinutes(3))\n            .setWorkflowRunTimeout(Duration.ofMinutes(1))\n            .build();\n\n    // Create the workflow client stub. It is used to start our workflow execution.\n    GreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);\n```\n\nSetting `setCronSchedule` turns the Workflow Execution into a <preview page={WhatIsATemporalCronJob}>Temporal Cron Job</preview>\n\nYou can check our [Java samples](https://github.com/temporalio/samples-java/blob/master/src/main/java/io/temporal/samples/hello/HelloCron.java) for example code.\n\nJava SDK `workflowOptions` source code: https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.html\n\n## Retrieve last successful result\n\nSometimes it is useful to obtain the progress of previous successful runs.\nThis is supported by one new APIs in the Java SDK:\n`GetLastCompletionResult`. The method returns null if there is no previous completion. Below is an example of how\nto use this in Java:\n\n```java\npublic String cronWorkflow() {\n    String lastProcessedFileName = Workflow.getLastCompletionResult(String.class);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the cron schedule runs failed. The\nnext schedule will still get the last successful result if it ever successfully\ncompleted at least once. For example, for a daily cron Workflow, if the first day\nrun succeeds and the second day fails, then the third day run will still get\nthe result from first day's run using these APIs.\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-java.md","id":"java/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-java","title":"How to set custom Search Attributes in Java","description":"To set custom Search Attributes, call the setSearchAttributes method.","label":"Set custom Search Attributes","tags":["developer-guide","sdk","java"],"markdown_content":"\nTo set a custom Search Attribute, call the [`setSearchAttributes()`](<https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html#setSearchAttributes(java.util.Map)>) method.\n\n```java\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder()\n            .setSearchAttributes(generateSearchAttributes())\n            .build();\n```\n\n`generateSearchAttributes()` is a `Map<String, ?>` from the Search Attribute used as the key to a value of one of the following types.\n\n- `String`\n- `Long`\n- `Integer`\n- `Boolean`\n- `Double`\n- `OffsetDateTime`\n","is_empty":false},{"file_name":"how-to-asynchronously-complete-an-activity-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-asynchronously-complete-an-activity-in-java.md","id":"java/how-to-asynchronously-complete-an-activity-in-java","title":"How to asynchronously complete an Activity in Java","description":"To asynchronously complete an Activity in Java, set the `ActivityCompletionClient` interface to the `complete()` method.","label":"Asynchronously complete an Activity","tags":["java","how-to"],"markdown_content":"\nTo complete an Activity asynchronously, set the [`ActivityCompletionClient`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/ActivityCompletionClient.html) interface to the `complete()` method.\n\n```java\n    @Override\n    public String composeGreeting(String greeting, String name) {\n\n      // Get the activity execution context\n      ActivityExecutionContext context = Activity.getExecutionContext();\n\n      // Set a correlation token that can be used to complete the activity asynchronously\n      byte[] taskToken = context.getTaskToken();\n\n      /**\n       * For the example we will use a {@link java.util.concurrent.ForkJoinPool} to execute our\n       * activity. In real-life applications this could be any service. The composeGreetingAsync\n       * method is the one that will actually complete workflow action execution.\n       */\n      ForkJoinPool.commonPool().execute(() -> composeGreetingAsync(taskToken, greeting, name));\n      context.doNotCompleteOnReturn();\n\n      // Since we have set doNotCompleteOnReturn(), the workflow action method return value is\n      // ignored.\n      return \"ignored\";\n    }\n\n    // Method that will complete action execution using the defined ActivityCompletionClient\n    private void composeGreetingAsync(byte[] taskToken, String greeting, String name) {\n      String result = greeting + \" \" + name + \"!\";\n\n      // Complete our workflow activity using ActivityCompletionClient\n      completionClient.complete(taskToken, result);\n    }\n  }\n```\n\nAlternatively, set the [`doNotCompleteOnReturn()`](<https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityExecutionContext.html#doNotCompleteOnReturn()>) method during an Activity Execution.\n\n```java\n    @Override\n    public String composeGreeting(String greeting, String name) {\n\n      // Get the activity execution context\n      ActivityExecutionContext context = Activity.getExecutionContext();\n\n      // Set a correlation token that can be used to complete the activity asynchronously\n      byte[] taskToken = context.getTaskToken();\n\n      /**\n       * For the example we will use a {@link java.util.concurrent.ForkJoinPool} to execute our\n       * activity. In real-life applications this could be any service. The composeGreetingAsync\n       * method is the one that will actually complete workflow action execution.\n       */\n      ForkJoinPool.commonPool().execute(() -> composeGreetingAsync(taskToken, greeting, name));\n      context.doNotCompleteOnReturn();\n\n      // Since we have set doNotCompleteOnReturn(), the workflow action method return value is\n      // ignored.\n      return \"ignored\";\n    }\n```\n\nWhen this method is called during an Activity Execution, the Activity Execution does not complete when its method returns.\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-configure-tracing-in-java.md","id":"java/how-to-configure-tracing-in-java","title":"How to configure tracing in Java","description":"To configure tracing in Java, register the `OpenTracingClientInterceptor()` interceptor.","label":"Configure tracing","tags":["java","how-to"],"markdown_content":"\nTo configure tracing in Java, register the `OpenTracingClientInterceptor()` interceptor.\nYou can register the interceptors on both the Temporal Client side and the Worker side.\n\nThe following code examples demonstrate the `OpenTracingClientInterceptor()` on the Temporal Client.\n\n```java\nWorkflowClientOptions.newBuilder()\n   //...\n   .setInterceptors(new OpenTracingClientInterceptor())\n   .build();\n```\n\n```java\n    WorkflowClientOptions clientOptions =\n        WorkflowClientOptions.newBuilder()\n            .setInterceptors(new OpenTracingClientInterceptor(JaegerUtils.getJaegerOptions(type)))\n            .build();\n    WorkflowClient client = WorkflowClient.newInstance(service, clientOptions);\n```\n\nThe following code examples demonstrate the `OpenTracingClientInterceptor()` on the Worker.\n\n```java\nWorkerFactoryOptions.newBuilder()\n   //...\n   .setWorkerInterceptors(new OpenTracingWorkerInterceptor())\n   .build();\n```\n\n```java\n    WorkerFactoryOptions factoryOptions =\n        WorkerFactoryOptions.newBuilder()\n            .setWorkerInterceptors(\n                new OpenTracingWorkerInterceptor(JaegerUtils.getJaegerOptions(type)))\n            .build();\n    WorkerFactory factory = WorkerFactory.newInstance(client, factoryOptions);\n```\n\nFor more information, see the Temporal [OpenTracing module](https://github.com/temporalio/sdk-java/blob/master/temporal-opentracing/README.md).\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-continue-as-new-in-java.md","id":"java/how-to-continue-as-new-in-java","title":"How to Continue-As-New in Java","description":"To cause a Workflow to Continue-As-New, use `Workflow.continueAsNew()`.","label":"Continue-As-New","tags":["java","developer-guide"],"markdown_content":"\nTemporal SDK allows you to use [Continue-As-New](/concepts/what-is-continue-as-new) in various ways.\n\nTo continue execution of the same Workflow that is currently running, use:\n\n```java\nWorkflow.continueAsNew(input1, ...);\n```\n\nTo continue execution of a currently running Workflow as a completely different Workflow Type, use `Workflow.newContinueAsNewStub()`.\nFor example, in a Workflow class called `YourWorkflow`, we can create a Workflow stub with a different type, and call its Workflow method to continue execution as that type:\n\n```java\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class);\nconinueAsNew.greet(input);\n```\n\nTo provide `ContinueAsNewOptions` options in `Workflow.newContinueAsNewStub()` use:\n\n```java\nContinueAsNewOptions options = ContinueAsNewOptions.newBuilder()\n        .setTaskQueue(\"newTaskQueueName\")\n        .build();\n\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class, options);\n// ...\ncontinueAsNew.greet(input);\n```\n\nProviding these options allows you to continue Workflow Execution as a new Workflow run, with a different Workflow Type, and on a different Task Queue.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-create-a-temporal-client-in-java.md","id":"java/how-to-create-a-temporal-client-in-java","title":"How to create a Temporal Client in Java","description":"To initialize a Workflow Client, create an instance of a `WorkflowClient`, create a client-side `WorkflowStub`, and then call a Workflow method (annotated with the `@WorkflowMethod` annotation).","label":"Temporal Client","tags":["java","developer-guide"],"markdown_content":"\nTo initialize a Workflow Client, create an instance of a `WorkflowClient`, create a client-side `WorkflowStub`, and then call a Workflow method (annotated with `@WorkflowMethod`).\n\nTo start a Workflow Execution, your Temporal Server must be running, and your front-end service must be accepting gRPC calls.\n\nTo establish a connection with the front-end service, use `WorkflowServiceStubs`.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n```\n\nYou can provide `WorkflowServiceStubsOptions` to override the default values for the gRPC calls.\n\nFor example, the default front-end service gRPC address is set to `127.0.0.1:7233`, where `7233` is the default port for the Temporal Frontend Service.\n\nIf your server is running on a different host or port from the default, you can set it as shown in the following example.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newInstance(\n                    WorkflowServiceStubsOptions.newBuilder()\n                     .setTarget(TARGET_ENDPOINT)\n                            .build());\n\n```\n\nAfter the connection to the Temporal Frontend Service is established, create a Client for the service stub.\nThe Workflow Client helps with client-side APIs and is required by Workers.\n\nCreate an instance of a `WorkflowClient` for the Workflow service stub, and use `WorkflowClientOptions` to set options for the Workflow Client.\nThe following example shows how to create a `WorkflowClient` instance called \"client\" for the `WorkflowServiceStubs` \"service\" that we created in the previous example, and set `Namespace` option for the `WorkflowClient`.\n\n```java\nWorkflowClient client = WorkflowClient.newInstance(\n                service,\n                WorkflowClientOptions.newBuilder()\n                        .setNamespace(“Abc”)\n                    .build());\n\n```\n\nFor more information, see [WorkflowClientOptions](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClientOptions.Builder.html).\n\n`WorkflowService` and `WorkflowClient` creation is a heavyweight operation, and will be resource-intensive if created each time you start a Workflow or send a Signal to it.\nThe recommended way is to create them once and reuse where possible.\n\nWith the Client defined, you can start interacting with the Temporal Frontend Service.\n\nTo initialize a Workflow in the Client, create a `WorkflowStub`, and start the Workflow Execution with `WorkflowClient.start()`.\nStarting Workflows or sending Signals or Queries to Workflows from within a Client must be done using `WorkflowStubs`.\n\n```java\nWorkflowClient workflowClient =  WorkflowClient.newInstance(service, clientOptions);\n // Create a Workflow stub.\n YourWorkflow workflow = workflowClient.newWorkflowStub(YourWorkflow.class);\n // Start Workflow asynchronously and call its \"yourWFMethod\" Workflow method\n WorkflowClient.start(workflow::yourWFMethod);\n```\n\nFor more information, see the following:\n\n- [How to spawn a Workflow Execution in Java](/java/how-to-spawn-a-workflow-execution-in-java)\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-customize-activity-type-in-java.md","id":"java/how-to-customize-activity-type-in-java","title":"How to customize Activity Type in Java","description":"The Activity Type defaults to method name with the first letter of the method name capitalized, and can be customized using `namePrefix()` or `{ActivityMethod.name()}` to ensure they are distinct.","label":"Customize Activity Type","tags":["developer-guide","java"],"markdown_content":"\nThe Activity Type defaults to method name, with the first letter of the method name capitalized, and can be customized using `namePrefix()` or `{ActivityMethod.name()}` to ensure they are distinct.\n\nIn the following example, the Activity Type defaults to `ComposeGreeting`.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nTo overwrite this default naming and assign a custom Activity Type, use the `@ActivityMethod` annotation with the `name` parameter.\nIn the following example, the Activity Type is set to \"greet\".\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod(name = \"greet\")\n    String composeGreeting(String greeting, String language);\n}\n```\n\nYou can also define a prefix for all of your Activity Types using the `namePrefix` parameter with the `@ActivityInterface` annotation.\nThe following example shows a `namePrefix` parameter applied to the `@ActivityInterface`, and two Activity methods, of which one is defined using the `@ActivityMethod` annotation.\n\n```java\n@ActivityInterface(namePrefix = \"A_\")\nPublic interface GreetingActivities {\n    String sendGreeting(String input);\n\n  @ActivityMethod(name = \"abc\")\n  String composeGreeting(String greeting, String language);\n}\n```\n\nIn this example, the Activity type for the first method is set to `A_SendGreeting`.\nThe Activity type for the method annotated with `@ActivityMethod` is set to `A_abc`.\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-customize-workflow-type-in-java.md","id":"java/how-to-customize-workflow-type-in-java","title":"How to customize Workflow Type in Java","description":"The Workflow Type defaults to the short name of the Workflow interface, and can be customized with the `name` parameter.","label":"Customize Workflow Type","tags":["developer-guide","java"],"markdown_content":"\nThe Workflow Type defaults to the short name of the Workflow interface.\nIn the following example, the Workflow Type defaults to `NotifyUserAccounts`.\n\n```java\n  @WorkflowInterface\n\n  public interface NotifyUserAccounts {\n    @WorkflowMethod\n    void notify(String[] accountIds);\n}\n```\n\nTo overwrite this default naming and assign a custom Workflow Type, use the `@WorkflowMethod` annotation with the `name` parameter.\nIn the following example, the Workflow Type is set to `Abc`.\n\n```java\n@WorkflowInterface\n\n  public interface NotifyUserAccounts {\n  @WorkflowMethod(name = \"Abc\")\n  void notify(String[] accountIds);\n  }\n```\n\nWhen you set the Workflow Type this way, the value of the `name` parameter does not have to start with an uppercase letter.\n","is_empty":false},{"file_name":"how-to-define-a-query-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-define-a-query-in-java.md","id":"java/how-to-define-a-query-in-java","title":"How to define a Query in Java","description":"Create a Query handler using the `@QueryMethod` annotation in the Workflow interface.","label":"Define Query","tags":["java","developer-guide"],"markdown_content":"\nTo define a Query, define the method name and the result type of the Query.\n\n```java\nquery(String queryType, Class<R> resultClass, Type resultType, Object... args);\n\n  /* @param queryType name of the Query handler. Usually it is a method name.\n   * @param resultClass class of the Query result type\n   * @param args optional Query arguments\n   * @param <R> type of the Query result\n  */\n```\n\nQuery methods can take in any number of input parameters which can be used to limit the data that is returned.\n\nUse the Query method names to send and receive Queries.\n\nQuery methods must never change any Workflow state including starting Activities or blocking threads in any way.\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-define-a-signal-in-java.md","id":"java/how-to-define-a-signal-in-java","title":"How to define Signals in Java","description":"Define a Signal method with `@SignalMethod` annotation in the Workflow interface.","label":"Define Signal","tags":["java","developer-guide"],"markdown_content":"\nThe `@SignalMethod` annotation indicates that the method is used to handle and react to external Signals.\n\n```java\n @SignalMethod\n    void mySignal(String signalName);\n```\n\nThe method can have parameters that contain the Signal payload and must be serializable by the default Jackson JSON Payload Converter.\n\n```java\nvoid mySignal(String signalName, Object... args);\n```\n\nThis method does not return a value and must have a `void` return type.\n\nThings to consider when defining Signals:\n\n- Use Workflow object constructors and initialization blocks to initialize the internal data structures if possible.\n- Signals might be received by a Workflow before the Workflow method is executed.\n  When implementing Signals in scenarios where this can occur, assume that no parts of Workflow code ran.\n  In some cases, Signal method implementation might require some initialization to be performed by the Workflow method code first—for example, when the Signal processing depends on, and is defined by the Workflow input.\n  In this case, you can use a flag to determine whether the Workflow method is already triggered; if not, persist the Signal data into a collection for delayed processing by the Workflow method.\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-define-activity-parameters-in-java.md","id":"java/how-to-define-activity-parameters-in-java","title":"How to define Activity paramters in Java","description":"An Activity interface can have any number of parameters.","label":"Activity parameters","tags":["developer-guide","java"],"markdown_content":"\nAn Activity interface can have any number of parameters.\nAll inputs should be serializable by the default Jackson JSON Payload Converter.\n\nWhen implementing Activities, be mindful of the amount of data that you transfer using the Activity invocation parameters or return values as these are recorded in the Workflow Execution Events History.\nLarge Events Histories can adversely impact performance.\n\nYou can create a custom object, and pass it to the Activity interface, as shown in the following example.\n\n```java\n@ActivityInterface\npublic interface YourActivities {\n    String getCustomObject(CustomObj customobj);\n    void sendCustomObject(CustomObj customobj, String abc);\n}\n```\n\nThe `execute` method in the dynamic Activity interface implementation takes in `EncodedValues` that are inputs to the Activity Execution, as shown in the following example.\n\n```java\n // Dynamic Activity implementation\n  public static class DynamicActivityImpl implements DynamicActivity {\n    @Override\n    public Object execute(EncodedValues args) {\n      String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n      return activityType\n          + \": \"\n          + args.get(0, String.class)\n          + \" \"\n          + args.get(1, String.class)\n          + \" from: \"\n          + args.get(2, String.class);\n    }\n  }\n```\n\nFor more details, see [Dynamic Activity Reference](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/DynamicActivity.html).\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-define-activity-return-values-in-java.md","id":"java/how-to-define-activity-return-values-in-java","title":"How to define Activity return values in Java","description":"Activity return values must be serializable and deserializable by the provided `DataConverter`","label":"Activity return values","tags":["developer-guide","java"],"markdown_content":"\nActivity return values must be serializable and deserializable by the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.17.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicActivity` can return type Object.\nEnsure that your Workflow or Client can handle an Object type return or is able to convert the Object type response.\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-define-workflow-parameters-in-java.md","id":"java/how-to-define-workflow-parameters-in-java","title":"How to define Workflow Parameters in Java","description":"A method annotated with `@WorkflowMethod` can have any number of parameters.","label":"Workflow parameters","tags":["developer-guide","java"],"markdown_content":"\nA method annotated with `@WorkflowMethod` can have any number of parameters.\n\nWe recommend passing a single parameter that contains all the input fields to allow for adding fields in a backward-compatible manner.\n\nNote that all inputs should be serializable by the default Jackson JSON Payload Converter.\n\nYou can create a custom object and pass it to the Workflow method, as shown in the following example.\n\n```java\n//...\n@WorkflowInterface\npublic interface YourWorkflow {\n    @WorkflowMethod\n    String yourWFMethod(CustomObj customobj);\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-define-workflow-return-values-in-java.md","id":"java/how-to-define-workflow-return-values-in-java","title":"How to define Workflow return values in Java","description":"Workflow method arguments and return values must be serializable and deserializable using the provided `DataConverter`.","label":"Workflow return values","tags":["developer-guide","java"],"markdown_content":"\nWorkflow method arguments and return values must be serializable and deserializable using the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.17.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicWorkflow` can return type Object.\nEnsure that your Client can handle an Object type return or is able to convert the Object type response.\n\nRelated references:\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-develop-a-worker-program-in-java.md","id":"java/how-to-develop-a-worker-program-in-java","title":"How to develop a Worker Program in Java","description":"Use the `newWorker` method on an instance of a `WorkerFactory` to create a new Worker in Java.","tags":["developer-guide","java","workers"],"markdown_content":"\nUse the `newWorker` method on an instance of a [`WorkerFactory`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/worker/WorkerFactory.html) to create a new Worker in Java.\n\nA single Worker Entity can contain many Worker Objects.\nCall the `start()` method on the instance of the `WorkerFactory` to start all the Workers created in this process.\n\n```java\n// ...\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.serviceclient.WorkflowServiceStubs;\nimport io.temporal.worker.Worker;\nimport io.temporal.worker.WorkerFactory;\n\npublic class YourWorker {\n\n  public static void main(String[] args) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker yourWorker = factory.newWorker(\"your_task_queue\");\n\n    // Register Workflow\n    // and/or register Activities\n\n    factory.start();\n  }\n}\n```\n\nAfter creating the Worker entity, register all Workflow Types and all Activity Types that the Worker can execute.\nA Worker can be registered with just Workflows, just Activities, or both.\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-develop-a-workflow-definition-in-java.md","id":"java/how-to-develop-a-workflow-definition-in-java","title":"How to develop a Workflow Definition in Java","description":"In the Temporal Java SDK programming model, a Workflow is a class which implements a Workflow interface.","label":"Workflow Definition","tags":["java","developer-guide"],"markdown_content":"\nIn the Temporal Java SDK programming model, a Workflow Definition comprises a Workflow interface annotated with `@WorkflowInterface` and a Workflow implementation that implements the Workflow interface.\n\nThe Workflow interface is a Java interface and is annotated with `@WorkflowInterface`.\nEach Workflow interface must have only one method annotated with `@WorkflowMethod`.\n\n```java\n// Workflow interface\n@WorkflowInterface\npublic interface YourWorkflow {\n\n    @WorkflowMethod\n    String yourWFMethod(Arguments args);\n}\n```\n\nHowever, when using dynamic Workflows, do not specify a `@WorkflowMethod`, and implement the `DynamicWorkflow` directly in the Workflow implementation code.\n\nThe `@WorkflowMethod` identifies the method that is the starting point of the Workflow Execution.\nThe Workflow Execution completes when this method completes.\n\nYou can create interface inheritance hierarchies to reuse components across other Workflow interfaces.\nThe interface inheritance approach does not apply to `@WorkflowMethod` annotations.\n\nA Workflow implementation implements a Workflow interface.\n\n```java\n// Define the Workflow implementation which implements our getGreeting Workflow method.\n  public static class GreetingWorkflowImpl implements GreetingWorkflow {\n      ...\n    }\n  }\n```\n\n\nTo call Activities in your Workflow, call the Activity implementation.\n\n Use `ExternalWorkflowStub` to start or send Signals from within a Workflow to other running Workflow Executions.\n\n You can also invoke other Workflows as Child Workflows with `Workflow.newChildWorkflowStub()` or `Workflow.newUntypedChildWorkflowStub()` within a Workflow Definition.\n\n Use [`DynamicWorkflow`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/DynamicWorkflow.html) to implement Workflow Types dynamically.\n Register a Workflow implementation type that extends `DynamicWorkflow` to implement any Workflow Type that is not explicitly registered with the Worker.\n\n The dynamic Workflow interface is implemented with the `execute` method. This method takes in `EncodedValues` that are inputs to the Workflow Execution.\n These inputs can be specified by the Client when invoking the Workflow Execution.\n\n ```java\n public class MyDynamicWorkflow implements DynamicWorkflow {\n    @Override\n     public Object execute(EncodedValues args) {\n     }\n }\n ```\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-develop-a-workflow-in-java.md","id":"java/how-to-develop-a-workflow-in-java","title":"How to develop a Workflow in Java","description":"In the Temporal Java SDK programming model, a Workflow is a class which implements a Workflow interface.","label":"Workflow Development","tags":["developer-guide","java"],"markdown_content":"\nimport WorkflowDefinition from './how-to-develop-a-workflow-definition-in-java.md'\n\n<WorkflowDefinition/>\n\n### Customize Workflow Type\n\nimport CustomizeWorkflowType from './how-to-customize-workflow-type-in-java.md'\n\n<CustomizeWorkflowType/>\n\n### Parameters\n\nimport WorkflowParameters from './how-to-define-workflow-parameters-in-java.md'\n\n<WorkflowParameters/>\n\n### Return values\n\nimport WorkflowReturn from './how-to-define-workflow-return-values-in-java.md'\n\n<WorkflowReturn/>\n\n### Logic requirements\n\nimport LogicRequirements from './how-to-handle-workflow-logic-requirements-in-java.md'\n\n<LogicRequirements/>\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-develop-an-activity-definition-in-java.md","id":"java/how-to-develop-an-activity-definition-in-java","title":"How to develop an Activity Definition in Java","description":"In the Temporal Java SDK programming model, Activities are classes which implement the Activity Interface.","label":"Activity Definition","tags":["java","developer-guide"],"markdown_content":"\nAn [Activity Definition](/concepts/what-is-an-activity) is a combination of the Temporal Java SDK [Activity](https://www.javadoc.io/static/io.temporal/temporal-sdk/0.19.0/io/temporal/activity/Activity.html) Class implementing a specially annotated interface.\n\nAn Activity interface is annotated with `@ActivityInterface` and an Activity implementation implements this Activity interface.\nTo handle Activity types that do not have an explicitly registered handler, you can directly implement a dynamic Activity.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    String composeGreeting(String greeting, String language);\n}\n```\n\nEach method defined in the Activity interface defines a separate Activity method.\nYou can annotate each method in the Activity interface with the `@ActivityMethod` annotation, but this is completely optional.\nThe following example uses the `@ActivityMethod` annotation for the method defined in the previous example.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nAn Activity implementation is a Java class that implements an Activity annotated interface.\n\n```java\n// Implementation for the GreetingActivities interface example from in the previous section\n static class GreetingActivitiesImpl implements GreetingActivities {\n    @Override\n    public String composeGreeting(String greeting, String name) {\n      return greeting + \" \" + name + \"!\";\n    }\n  }\n```\n\nUse `DynamicActivity` to implement any number of Activity types dynamically.\nWhen an Activity implementation that extends `DynamicActivity` is registered, it is called for any Activity type invocation that doesn't have an explicitly registered handler.\n\nThe dynamic Activity interface is implemented with the `execute` method, as shown in the following example.\n\n```java\n // Dynamic Activity implementation\n  public static class DynamicGreetingActivityImpl implements DynamicActivity {\n    @Override\n    public Object execute(EncodedValues args) {\n      String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n      return activityType\n          + \": \"\n          + args.get(0, String.class)\n          + \" \"\n          + args.get(1, String.class)\n          + \" from: \"\n          + args.get(2, String.class);\n    }\n  }\n```\n\nUse `Activity.getExecutionContext()` to get information about the Activity type that should be implemented dynamically.\n","is_empty":false},{"file_name":"how-to-develop-an-activity-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-develop-an-activity-in-java.md","id":"java/how-to-develop-an-activity-in-java","title":"How to develop an Activity in Java","description":"In the Temporal Java SDK programming model, Activities are classes which implement the Activity Interface.","label":"Activity Development","tags":["developer-guide","java"],"markdown_content":"\nimport ActivityDefinition from './how-to-develop-an-activity-definition-in-java.md'\n\n<ActivityDefinition/>\n\n### Customize Activity Type\n\nimport CustomizeActivityType from './how-to-customize-activity-type-in-java.md'\n\n<CustomizeActivityType/>\n\n### Parameters\n\nimport ActivityParameters from './how-to-define-activity-parameters-in-java.md'\n\n<ActivityParameters/>\n\n### Return values\n\nimport ActivityReturnValues from './how-to-define-activity-return-values-in-java.md'\n\n<ActivityReturnValues/>\n","is_empty":false},{"file_name":"how-to-emit-metrics-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-emit-metrics-in-java.md","id":"java/how-to-emit-metrics-in-java","title":"How to emit metrics in Java","description":"To emit metrics with the Java SDK, use `WorkflowServiceStubsOptions.Builder.setMetricsScope` to set the metrics scope in your Worker or Client code.","label":"Emit metrics","tags":["developer-guide","java"],"markdown_content":"\nTo emit metrics with the Java SDK, use the[`MicrometerClientStatsReporter`](https://github.com/temporalio/sdk-java/blob/55ee7894aec427d7e384c3519732bdd61119961a/src/main/java/io/temporal/common/reporter/MicrometerClientStatsReporter.java#L34) class to integrate with Micrometer MeterRegistry configured for your metrics backend.\n[Micrometer](https://micrometer.io/docs) is a popular Java framework that provides integration with Prometheus and other backends.\n\nThe following example shows how to use `MicrometerClientStatsReporter` to define the metrics scope and set it with the `WorkflowServiceStubsOptions`.\n\n```java\n//...\n   // see the Micrometer documentation for configuration details on other supported monitoring systems.\n   // in this example shows how to set up Prometheus registry and stats reported.\n   PrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\n   StatsReporter reporter = new MicrometerClientStatsReporter(registry);\n    // set up a new scope, report every 10 seconds\n     Scope scope = new RootScopeBuilder()\n             .reporter(reporter)\n             .reportEvery(com.uber.m3.util.Duration.ofSeconds(10));\n   // for Prometheus collection, expose a scrape endpoint.\n   //...\n   // add metrics scope to WorkflowServiceStub options\n   WorkflowServiceStubsOptions stubOptions =\n       WorkflowServiceStubsOptions.newBuilder().setMetricsScope(scope).build();\n//...\n```\n\nFor more details, see the [Java SDK Samples](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/metrics).\nFor details on configuring a Prometheus scrape endpoint with Micrometer, see the [Micrometer Prometheus Configuring](https://micrometer.io/docs/registry/prometheus#_configuring) documentation.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-get-the-result-of-a-workflow-execution-in-java.md","id":"java/how-to-get-the-result-of-a-workflow-execution-in-java","title":"How to get the result of a Workflow Execution in Java","description":"A synchronous Workflow Execution blocks your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure). An asynchronous Workflow Execution immediately returns a value to the caller.","label":"Workflow Execution Result","tags":["java","developer-guide"],"markdown_content":"\nA synchronous Workflow Execution blocks your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure).\n\nThe following example is a type-safe approach for getting the results of a synchronous Workflow Execution.\n\n```java\n FileProcessingWorkflow workflow = client.newWorkflowStub(\n                FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setWorkflowId(workflowId)\n                        .setTaskQueue(taskQueue)\n                        .build();\n\n// start sync and wait for results (or failure)\nString result = workflow.processfile(new Argument());\n```\n\nAn asynchronous Workflow Execution immediately returns a value to the caller.\n\nThe following examples show how to get the results of a Workflow Execution through typed and untyped `WorkflowStub`.\n\n- **Typed WorkflowStub Example**\n\n  ```java\n  // create typed Workflow stub\n  FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setTaskQueue(taskQueue)\n                        .setWorkflowId(workflowId)\n                        .build());\n  // use WorkflowClient.execute (if your Workflow takes in arguments) or WorkflowClient.start (for zero arguments)\n  WorkflowClient.start(workflow::greetCustomer);\n  ```\n\n- **Untyped WorkflowStub Example**\n\n  ```java\n  WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n                  WorkflowOptions.newBuilder()\n                          .setWorkflowId(workflowId)\n                          .setTaskQueue(taskQueue)\n                          .build());\n\n  // blocks until Workflow Execution has been started (not until it completes)\n  untyped.start(argument);\n  ```\n\nIf you need to wait for a Workflow Execution to complete after an asynchronous start, the most straightforward way is to call the blocking Workflow instance again.\n\nNote that if `WorkflowOptions.WorkflowIdReusePolicy` is not set to `AllowDuplicate`, then instead of throwing `DuplicateWorkflowException`, it reconnects to an existing Workflow and waits for its completion.\n\nThe following example shows how to do this from a different process than the one that started the Workflow Execution.\n\n```java\nYourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflow.yourMethod();\n```\n\nAnother way to connect to an existing Workflow and wait for its completion from another process, is to use `UntypedWorkflowStub`. For example:\n\n```java\nWorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = untyped.getResult(String.class);\n```\n\n**Get last (successful) completion result**\n\nFor a Temporal Cron Job, get the result of previous successful runs using `GetLastCompletionResult()`.\nThe method returns `null` if there is no previous completion.\nThe following example shows how to implement this in a Workflow.\n\n```java\npublic String cronWorkflow() {\n    String lastProcessedFileName = Workflow.getLastCompletionResult(String.class);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the Cron schedule runs failed.\nThe next schedule will still get the last successful result if it ever successfully completed at least once.\nFor example, for a daily cron Workflow, if the run succeeds on the first day and fails on the second day, then the third day run will get the result from first day's run using these APIs.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-get-the-result-of-an-activity-execution-in-java.md","id":"java/how-to-get-the-result-of-an-activity-execution-in-java","title":"How to get the result of an Activity Execution","description":"To get the results of an asynchronously invoked Activity method, use the `Promise` `get` method to block until the Activity method result is available.","label":"Activity Execution Result","tags":["java","developer-guide"],"markdown_content":"\nTo get the results of an asynchronously invoked Activity method, use the `Promise` `get` method to block until the Activity method result is available.\n\nSometimes an Activity Execution lifecycle goes beyond a synchronous method invocation.\nFor example, a request can be put in a queue and later a reply comes and is picked up by a different Worker process.\nThe whole request-reply interaction can be modeled as a single Activity.\n\nTo indicate that an Activity should not be completed upon its method return, call `ActivityExecutionContext.doNotCompleteOnReturn()` from the original Activity thread.\n\nThen later, when replies come, complete the Activity using the `ActivityCompletionClient`.\nTo correlate Activity invocation with completion, use either a `TaskToken` or Workflow and Activity Ids.\n\nFollowing is an example of using `ActivityExecutionContext.doNotCompleteOnReturn()`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n\n    // Used to correlate reply\n    byte[] taskToken = ctx.getInfo().getTaskToken();\n\n    asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n    ctx.doNotCompleteOnReturn();\n\n    // Return value is ignored when doNotCompleteOnReturn was called.\n    return \"ignored\";\n  }\n  ...\n}\n```\n\nWhen the download is complete, the download service potentially can complete the Activity, or fail it from a different process, for example:\n\n```java\n  public <R> void completeActivity(byte[] taskToken, R result) {\n    completionClient.complete(taskToken, result);\n  }\n\n  public void failActivity(byte[] taskToken, Exception failure) {\n    completionClient.completeExceptionally(taskToken, failure);\n  }\n```\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-handle-a-query-in-a-workflow-in-java.md","id":"java/how-to-handle-a-query-in-a-workflow-in-java","title":"How to handle a Query in a Workflow in Java","description":"To handle a Query in a Workflow, define a Query handler method using the `@QueryMethod` annotation in the Workflow interface.","label":"Handle Query","tags":["java","developer-guide"],"markdown_content":"\nTo handle a Query in the Workflow, create a Query handler using the `@QueryMethod` annotation in the Workflow interface and define it in the Workflow implementation.\n\nThe `@QueryMethod` annotation indicates that the method is used to handle a Query that is sent to the Workflow Execution.\nThe method can have parameters that can be used to filter data that the Query returns.\nBecause the method returns a value, it must have a return type that is not `void`.\n\nThe Query name defaults to the name of the method.\nIn the following example, the Query name defaults to `getStatus`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod\n   String getStatus();\n}\n```\n\nTo overwrite this default naming and assign a custom Query name, use the `@QueryMethod` annotation with the `name` parameter. In the following example, the Query name is set to \"history\".\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod(name = \"history\")\n   String getStatus();\n}\n```\n\nA Workflow Definition interface can define multiple methods annotated with `@QueryMethod`, but the method names or the `name` parameters for each must be unique.\n\nThe following Workflow interface has a Query method `getCount()` to handle Queries to this Workflow.\n\n```java\n  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @QueryMethod\n    int getCount();\n  }\n```\n\nThe following example is the Workflow implementation with the Query method defined in the `HelloWorld` Workflow interface from the previous example.\n\n```java\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = \"Hello\";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!\"Bye\".equals(greeting)) {\n        logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n```\n\n**Dynamic Query Handler**\nYou can also implement Query handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicQueryListener` in the Workflow implementation code.\n\n```java\n      Workflow.registerListener(\n        (DynamicQueryHandler)\n            (queryName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Queries sent to the Workflow without a defined handler will be delivered to the `DynamicQueryHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicQueryHandler` can be implemented in both regular and dynamic Workflow implementations.\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-a-workflow-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-handle-a-signal-in-a-workflow-in-java.md","id":"java/how-to-handle-a-signal-in-a-workflow-in-java","title":"How to handle Signals in an Workflow in Java","description":"Use the `@SignalMethod` annotation to handle Signals within the Workflow interface.","label":"Handle Signals","tags":["java","developer-guide"],"markdown_content":"\nUse the `@SignalMethod` annotation to handle Signals in the Workflow interface.\n\nThe Signal type defaults to the name of the method. In the following example, the Signal type defaults to `retryNow`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod\n   void retryNow();\n}\n```\n\nTo overwrite this default naming and assign a custom Signal type, use the `@SignalMethod` annotation with the `name` parameter.\nIn the following example, the Signal type is set to `retrysignal`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod(name = \"retrysignal\")\n   void retryNow();\n}\n```\n\nA Workflow interface can define any number of methods annotated with `@SignalMethod`, but the method names or the `name` parameters for each must be unique.\n\nIn the following example, we define a Signal method `updateGreeting` to update the greeting in the Workflow.\nWe set a `Workflow.await` in the Workflow implementation to block the current Workflow Execution until the provided unblock condition is evaluated to `true`.\nIn this case, the unblocking condition is evaluated to `true` when the Signal to update the greeting is received.\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n}\n```\n\n```java\npublic class HelloWorldImpl implements HelloWorld {\n    private final Logger workflowLogger = Workflow.getLogger(HelloWorldImpl.class);\n    private String greeting;\n\n    @Override\n    public void sayHello(String name) {\n        int count = 0;\n        while (!\"Bye\".equals(greeting)) {\n            String oldGreeting = greeting;\n            Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n        }\n        workflowLogger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n        this.greeting = greeting;\n    }\n}\n```\n\nThis Workflow completes when the Signal updates the greeting to `Bye`.\n\n**Dynamic Signal Handler**\nYou can also implement Signal handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicSignalListener` in the Workflow implementation code.\n\n```java\n      Workflow.registerListener(\n        (DynamicSignalHandler)\n            (signalName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Signals sent to the Workflow without a defined handler will be delivered to the `DynamicSignalHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicSignalHandler` can be implemented in both regular and dynamic Workflow implementations.\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-handle-workflow-logic-requirements-in-java.md","id":"java/how-to-handle-workflow-logic-requirements-in-java","title":"How to handle Workflow Logic Requirements in Java","description":"When defining Workflows using the Temporal Java SDK, the Workflow code must be written to execute effectively once and to completion.","label":"Workflow logic requirements","tags":["developer-guide","java"],"markdown_content":"\nWhen defining Workflows using the Temporal Java SDK, the Workflow code must be written to execute effectively once and to completion.\n\nThe following constraints apply when writing Workflow Definitions:\n\n- Do not use mutable global variables in your Workflow implementations.\n  This will ensure that multiple Workflow instances are fully isolated.\n- Your Workflow code must be deterministic.\n  Do not call non-deterministic functions (such as non-seeded random or `UUID.randomUUID()`) directly from the Workflow code.\n  The Temporal SDK provides specific API for calling non-deterministic code in your Workflows.\n- Do not use programming language constructs that rely on system time.\n  For example, only use `Workflow.currentTimeMillis()` to get the current time inside a Workflow.\n- Do not use native Java `Thread` or any other multi-threaded classes like `ThreadPoolExecutor`.\n  Use `Async.function` or `Async.procedure`, provided by the Temporal SDK, to execute code asynchronously.\n- Do not use synchronization, locks, or other standard Java blocking concurrency-related classes besides those provided by the Workflow class.\n  There is no need for explicit synchronization because multi-threaded code inside a Workflow is executed one thread at a time and under a global lock.\n  - Call `Workflow.sleep` instead of `Thread.sleep`.\n  - Use `Promise` and `CompletablePromise` instead of `Future` and `CompletableFuture`.\n  - Use `WorkflowQueue` instead of `BlockingQueue`.\n- Use `Workflow.getVersion` when making any changes to the Workflow code.\n  Without this, any deployment of updated Workflow code might break already running Workflows.\n- Do not access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n- Use `DynamicWorkflow` when you need a default Workflow that can handle all Workflow Types that are not registered with a Worker.\n  A single implementation can implement a Workflow Type which by definition is dynamically loaded from some external source.\n  All standard `WorkflowOptions` and determinism rules apply to Dynamic Workflow implementations.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-heartbeat-an-activity-in-java.md","id":"java/how-to-heartbeat-an-activity-in-java","title":"How to Heartbeat an Activity in Java","description":"To inform the Temporal service that the Activity is still alive, use `Activity.getExecutionContext().heartbeat()` in the Activity implementation code.","label":"Activity Heartbeat","tags":["java","developer-guide"],"markdown_content":"\nTo Heartbeat an Activity Execution in Java, use the `Activity.getExecutionContext().heartbeat()` Class method.\n\n```java\npublic class YourActivityDefinitionImpl implements YourActivityDefinition {\n\n  @Override\n  public String yourActivityMethod(YourActivityMethodParam param) {\n    // ...\n    Activity.getExecutionContext().heartbeat(details);\n    // ...\n  }\n  // ...\n}\n```\n\nThe method takes an optional argument, the `details` variable above that represents latest progress of the Activity Execution.\nThis method can take a variety of types such as an exception object, custom object, or string.\n\nIf the Activity Execution times out, the last Heartbeat `details` are included in the thrown `ActivityTimeoutException`, which can be caught by the calling Workflow.\nThe Workflow can then use the `details` information to pass to the next Activity invocation if needed.\n\nIn the case of Activity retries, the last Heartbeat's `details` are available and can be extracted from the last failed attempt by using `Activity.getExecutionContext().getHeartbeatDetails(Class<V> detailsClass)`\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-log-from-a-workflow-in-java.md","id":"java/how-to-log-from-a-workflow-in-java","title":"How to log from a Workflow in Java","description":"To log from a Workflow in Java, use the `Workflow.getLogger` method.","label":"Log from a Workflow","tags":["developer-guide","sdk","java"],"markdown_content":"\nTo get a standard `slf4j` logger in your Workflow code, use the [`Workflow.getLogger`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html) method.\n\n```java\n  private static final Logger logger = Workflow.getLogger(DynamicDslWorkflow.class);\n```\n\nLogs in replay mode are omitted unless the [`WorkerFactoryOptions.Builder.setEnableLoggingInReplay(boolean)`](<https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/worker/WorkerFactoryOptions.Builder.html#setEnableLoggingInReplay(boolean)>) method is set to true.\n","is_empty":false},{"file_name":"how-to-pass-an-authorization-header-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-pass-an-authorization-header-in-java.md","id":"java/how-to-provide-an-authorization-token-in-java","title":"How to provide an Authorization Token in Java (JWT)","description":"Providing authorization header to Temporal Server in Java SDK including JWT tokens","label":"Authorization","tags":["developer-guide","java","auth"],"markdown_content":"\nThe Temporal Server [expects](/security/#authentication) an `authorization` gRPC header with an authorization token to be passed with API calls if [requests authorization](/security/#authorization) is configured.\n\nAuthorization Tokens may be provided to the Temporal Java SDK by implementing a `io.temporal.authorization.AuthorizationTokenSupplier` interface.\nThe implementation should be used to create `io.temporal.authorization.AuthorizationGrpcMetadataProvider` that may be configured on ServiceStub gRPC interceptors list.\n\nThe implementation is called for each SDK gRPC request and may supply dynamic tokens.\n\n**JWT**\n\nOne of the token types that may be passed this way are JWT tokens.\nTemporal Server provides a [default implementation of JWT authentication](/security/#default-jwt-claimmapper).\n\n**Example**\n\n```java\n  AuthorizationTokenSupplier tokenSupplier =\n    //your implementation of token supplier\n    () -> \"Bearer <Base64 url-encoded value of the token for default JWT ClaimMapper>\";\n  WorkflowServiceStubsOptions serviceStubOptions =\n    WorkflowServiceStubsOptions.newBuilder()\n      //other service stub options\n      .addGrpcMetadataProvider(new AuthorizationGrpcMetadataProvider(tokenSupplier))\n      .build();\n  WorkflowServiceStubs service = WorkflowServiceStubs.newServiceStubs(serviceStubOptions);\n  WorkflowClient client = WorkflowClient.newInstance(service);\n```\n\nRelated read:\n\n- [How to secure a Temporal Cluster](/security)\n","is_empty":false},{"file_name":"how-to-register-namespace-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-register-namespace-in-java.md","id":"java/how-to-register-namespace-in-java","title":"How to register a Namespace in Java","description":"Use the `RegisterNamespaceRequest` API to register a Namespace and set the Retention Period for the Workflow Execution Event History for the Namespace.","label":"Register Namespaces","tags":["developer-guide","java","workers"],"markdown_content":"\nUse the [`RegisterNamespace` API](https://github.com/temporalio/api/blob/master/temporal/api/workflowservice/v1/service.proto) to register a [Namespace](/concepts/what-is-a-namespace) and set the [Retention Period](/concepts/what-is-a-retention-period) for the Workflow Execution Event History for the Namespace.\n\n```java\n//...\nimport com.google.protobuf.util.Durations;\nimport io.temporal.api.workflowservice.v1.RegisterNamespaceRequest;\n//...\npublic static void createNamespace(String name) {\n    RegisterNamespaceRequest req = RegisterNamespaceRequest.newBuilder()\n            .setNamespace(\"your-custom-namespace\")\n            .setWorkflowExecutionRetentionPeriod(Durations.fromDays(3)) // keeps the Workflow Execution\n            //Event History for up to 3 days in the Persistence store. Not setting this value will throw an error.\n            .build();\n    service.blockingStub().registerNamespace(req);\n}\n//...\n```\n\nThe Retention Period setting using `WorkflowExecutionRetentionPeriod` is mandatory.\nThe minimum value you can set for this period is 1 day.\n\nOnce registered, set Namespace using `WorkflowClientOptions` within a Workflow Client to run your Workflow Executions within that Namespace.\nSee [how to set Namespace in a Client in Java](/application-development/features/#namespaces) for details.\n\nNote that Namespace registration using this API takes up to 10 seconds to complete.\nEnsure that you wait for this registration to complete before starting the Workflow Execution against the Namespace.\n\nTo update your Namespace, use the [`UpdateNamespace` API](https://github.com/temporalio/api/blob/master/temporal/api/workflowservice/v1/service.proto) with the `NamespaceClient`.\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-register-types-with-a-worker-in-java.md","id":"java/how-to-register-types-with-a-worker-in-java","title":"How to register types with a Worker in Java","description":"Use `worker.registerWorkflowImplementationTypes` to register Workflow Type and `worker.registerActivitiesImplementations` to register Activity implementation with Workers.","label":"Register Types","tags":["developer-guide","java","workers"],"markdown_content":"\nUse `worker.registerWorkflowImplementationTypes` to register Workflow Type and `worker.registerActivitiesImplementations` to register Activity implementation with Workers.\n\nFor Workflows, the Workflow Type is registered with a Worker.\nA Workflow Type can be registered only once per Worker entity.\nIf you define multiple Workflow implementations of the same type, you get an exception at the time of registration.\n\nFor Activities, Activity implementation instances are registered with a Worker because they are stateless and thread-safe.\nYou can pass any number of dependencies in the Activity implementation constructor, such as the database connections, services, etc.\n\nThe following example shows how to register a Workflow and an Activity with a Worker.\n\n```java\n    Worker worker = workerFactory.newWorker(\"your_task_queue\");\n    ...\n    // Register Workflow\n    worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n    // Register Activity\n    worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n```\n\nWhen you register a single instance of an Activity, you can have multiple instances of Workflow Executions calling the same Activity.\nActivity code must be thread-safe because the same instance of the Activity code is run for every Workflow Execution that calls it.\n\nFor `DynamicWorkflow`, only one Workflow implementation that extends `DynamicWorkflow` can be registered with a Worker.\nThe following example shows how to register the `DynamicWorkflow` and `DynamicActivity` implementation with a Worker.\n\n```java\n  public static void main(String[] arg) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker(TASK_QUEUE);\n\n    /* Register the Dynamic Workflow implementation with the Worker. Workflow implementations\n    ** must be known to the Worker at runtime to dispatch Workflow Tasks.\n    */\n    worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    // Start all the Workers that are in this process.\n    factory.start();\n\n    /* Create the Workflow stub. Note that the Workflow Type is not explicitly registered with the Worker. */\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n    /**\n     * Register Dynamic Activity implementation with the Worker. Since Activities are stateless\n     * and thread-safe, we need to register a shared instance.\n    */\n    worker.registerActivitiesImplementations(new DynamicGreetingActivityImpl());\n\n    /* Start Workflow Execution and immmediately send Signal. Pass in the Workflow args and Signal args. */\n    workflow.signalWithStart(\"greetingSignal\", new Object[] {\"John\"}, new Object[] {\"Hello\"});\n\n    // Wait for the Workflow to finish getting the results.\n    String result = workflow.getResult(String.class);\n\n    System.out.println(result);\n\n    System.exit(0);\n  }\n}\n```\n\nYou can register multiple type-specific Workflow implementations alongside a single `DynamicWorkflow` implementation.\nYou can register only one Activity instance that implements `DynamicActivity` with a Worker.\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-remove-search-attributes-from-a-workflow-in-java.md","id":"java/how-to-remove-search-attributes-from-a-workflow-in-java","title":"How to remove Search Attributes in Java","description":"To remove a Search Attribute, use `upsertSearchAttributes()` with an empty list as its value.","label":"Remove Search Attributes","tags":["developer-guide","sdk","java"],"markdown_content":"\nTo remove a Search Attribute, call the `upsertSearchAttributes()` method and set it to an empty map.\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-send-a-query-to-a-workflow-in-java.md","id":"java/how-to-send-a-query-to-a-workflow-in-java","title":"How to send a Query in Java","description":"To send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.","label":"Send Query","tags":["java","developer-guide"],"markdown_content":"\nTo send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.\n\nFor example, the following Client code calls a Query method `queryGreeting()` defined in the `GreetingWorkflow` Workflow interface.\n\n```java\n // Create our workflow options\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder()\n        .setWorkflowId(WORKFLOW_ID)\n        .setTaskQueue(TASK_QUEUE).build();\n\n    // Create the Temporal client stub. It is used to start our workflow execution.\n    GreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);\n\n    // Start our workflow asynchronously to not use another thread to query.\n    WorkflowClient.start(workflow::createGreeting, \"World\");\n\n    // Query the Workflow to get the current value of greeting and print it.\n    System.out.println(workflow.queryGreeting());\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-send-a-signal-from-a-client-in-java.md","id":"java/how-to-send-a-signal-from-a-client-in-java","title":"How to send a Signal from a Client in Java","description":"To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.","label":"Send Signal from Client","tags":["java","developer-guide"],"markdown_content":"\nTo send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.\n\nIn the following Client code example, we start the Workflow `greetCustomer` and call the Signal method `addCustomer` that is handled in the Workflow.\n\n```java\n// create a typed Workflow stub for GreetingsWorkflow\nGreetingsWorkflow workflow = client.newWorkflowStub(GreetingsWorkflow.class,\n        WorkflowOptions.newBuilder()\n                // set the Task Queue\n                .setTaskQueue(taskQueue)\n                // Workflow Id is recommended but not required\n                .setWorkflowId(workflowId)\n                .build());\n\n// start the Workflow\nWorkflowClient.start(workflow::greetCustomer);\n// send a Signal to the Workflow\nCustomer customer = new Customer(\"John\", \"Spanish\", \"john@john.com\");\nworkflow.addCustomer(customer); //addCustomer is the Signal method defined in the greetCustomer Workflow.\n```\n\nSee [Handle Signals](/java/how-to-handle-a-signal-in-a-workflow-in-java) for details on how to handle Signals in a Workflow.\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-send-a-signal-from-a-workflow-in-java.md","id":"java/how-to-send-a-signal-from-a-workflow-in-java","title":"How to send a Signal from a Workflow in Java","description":"To send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow.","label":"Send Signal from Workflow","tags":["java","developer-guide"],"markdown_content":"\nTo send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow.\n\nThe following example shows how to use an untyped `ExternalWorkflowStub` in the Workflow implementation to send a Signal to another Workflow.\n\n```java\n    public String sendGreeting(String name) {\n\n        // initiate ExternalWorkflowStub to call another Workflow by its Id \"ReplyWF\"\n        ExternalWorkflowStub callRespondWorkflow = Workflow.newUntypedExternalWorkflowStub(\"ReplyWF\");\n\n        String responseTrigger = activity.greeting(\"Hello\", name);\n\n        // send a Signal from this sendGreeting Workflow to the other Workflow\n        // by calling the Signal method name \"getGreetCall\" defined in that Workflow.\n        callRespondWorkflow.signal(\"getGreetCall\", responseTrigger);\n\n        return responseTrigger;\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-send-a-signal-with-start-in-java.md","id":"java/how-to-send-a-signal-with-start-in-java","title":"How to send a Signal-with-Start in Java","description":"To send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart` with a `WorkflowStub` in the Client code.","label":"Signal with Start","tags":["java","developer-guide"],"markdown_content":"\nTo send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart` with a `WorkflowStub` in the Client code.\nThis method ensures that if the Workflow Execution is in a closed state, a new Workflow Execution is spawned and the Signal is delivered to the running Workflow Execution.\n\nNote that when the `SignalwithStart` spawns a new Workflow Execution, the Signal is delivered before the call to your `@WorkflowMethod`.\nThis means that the Signal handler in your Workflow interface code will execute before the `@WorkfowMethod`.\nYou must ensure that your code logic can deal with this.\n\nIn the following example, the Client code uses `SignalwithStart` to send the Signal `setCustomer` to the `UntypedWorkflowStub` named `GreetingWorkflow`.\nIf the `GreetingWorkflow` Workflow Execution is not running, the `SignalwithStart` starts the Workflow Execution.\n\n```java\n...\npublic static void signalWithStart() {\n        // WorkflowStub is a client-side stub to a single Workflow instance\n        WorkflowStub untypedWorkflowStub = client.newUntypedWorkflowStub(\"GreetingWorkflow\",\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(workflowId)\n                .setTaskQueue(taskQueue)\n                .build());\n\n        untypedWorkflowStub.signalWithStart(\"setCustomer\", new Object[] {customer2}, new Object[] {customer1});\n\n        printWorkflowStatus();\n\n        try {\n            String greeting = untypedWorkflowStub.getResult(String.class);\n            printWorkflowStatus();\n            System.out.println(\"Greeting: \" + greeting);\n        } catch(WorkflowFailedException e) {\n            System.out.println(\"Workflow failed: \" + e.getCause().getMessage());\n            printWorkflowStatus();\n        }\n    }\n...\n```\n\nThe following example shows the Workflow interface for the `GreetingWorkflow` called in the previous example.\n\n```java\n...\n@WorkflowInterface\npublic interface GreetingWorkflow {\n    @WorkflowMethod\n    String greet(Customer customer);\n\n    @SignalMethod\n    void setCustomer(Customer customer);\n\n    @QueryMethod\n    Customer getCustomer();\n...\n}\n```\n\nNote that the Signal handler `setCustomer` is executed before the `@WorkflowMethod` `greet` is called.\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-cron-schedule-in-java.md","id":"java/how-to-set-a-cron-schedule-in-java","title":"How to set a Cron Schedule in Java","description":"Set the Cron Schedule with the `WorkflowStub` instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`","label":"Cron Schedule","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the Cron Schedule with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\nSetting `setCronSchedule` changes the Workflow Execution into a Temporal Cron Job.\nThe default timezone for a Cron is UTC.\n\n- Type: `String`\n- Default: None\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    YourWorker.yourclient.newWorkflowStub(\n        YourWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(YourWorker.TASK_QUEUE)\n                // Set Cron Schedule\n                .setCronSchedule(\"* * * * *\")\n                .build());\n```\n\nFor more details, see the [Cron Sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/hello/HelloCron.java)\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-custom-logger-in-java.md","id":"java/how-to-set-a-custom-logger-in-java","title":"How to set a custom Logger in Java","description":"Configure your custom logger the same way you would for any other Java application.","label":"Custom Logger","tags":["java","how-to"],"markdown_content":"\nTo set a custom logger, supply your own logging implementation and configuration details the same way you would in any other Java application.\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-heartbeat-timeout-in-java.md","id":"java/how-to-set-a-heartbeat-timeout-in-java","title":"How to set a Heartbeat Timeout in Java","description":"To set a Heartbeat Timeout, use `ActivityOptions.newBuilder.setHeartbeatTimeout​`].","label":"Heartbeat Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout), use [`ActivityOptions.newBuilder.setHeartbeatTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: None\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  private final GreetingActivities activities =\n      Workflow.newActivityStub(\n          GreetingActivities.class,\n          ActivityOptions.newBuilder()\n              // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n              // required when setting Activity options.\n              .setStartToCloseTimeout(Duration.ofSeconds(5))\n              .setHeartbeatTimeout(Duration.ofSeconds(2))\n              .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                          // required when setting Activity options.\n                                            .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                            .setHeartbeatTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-parent-close-policy-in-java.md","id":"java/how-to-set-a-parent-close-policy-in-java","title":"How to set Parent Close Policy in Java","description":"Set `Parent Close Policy` on an instance of `ChildWorkflowOptions` using `ChildWorkflowOptions.newBuilder().setParentClosePolicy`.","label":"Parent Close Policy","tags":["java","developer-guide","how-to"],"markdown_content":"\nSet [Parent Close Policy](/concepts/what-is-a-parent-close-policy) on an instance of `ChildWorkflowOptions` using [`ChildWorkflowOptions.newBuilder().setParentClosePolicy`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/ChildWorkflowOptions.Builder.html).\n\n- Type: `ChildWorkflowOptions.Builder`\n- Default: None.\n\n```java\n   public void parentWorkflow() {\n       ChildWorkflowOptions options =\n          ChildWorkflowOptions.newBuilder()\n              .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)\n              .build();\n       MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, options);\n       Async.procedure(child::<workflowMethod>, <args>...);\n       Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(child);\n       // Wait for child to start\n       childExecution.get()\n  }\n```\n\nIn this example, we are:\n\n1. Setting `ChildWorkflowOptions.ParentClosePolicy` to `ABANDON` when creating a Child Workflow stub.\n2. Starting Child Workflow Execution asynchronously using `Async.function` or `Async.procedure`.\n3. Calling `Workflow.getWorkflowExecution(…)` on the child stub.\n4. Waiting for the `Promise` returned by `getWorkflowExecution` to complete.\n   This indicates whether the Child Workflow started successfully (or failed).\n5. Completing parent Workflow Execution asynchronously.\n\nSteps 3 and 4 are needed to ensure that a Child Workflow Execution starts before the parent closes.\nIf the parent initiates a Child Workflow Execution and then completes immediately after, the Child Workflow will never execute.\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-schedule-to-close-timeout-in-java.md","id":"java/how-to-set-a-schedule-to-close-timeout-in-java","title":"How to set a Schedule-To-Close Timeout in Java","description":"To set a Schedule-To-Close Timeout, use `ActivityOptions.newBuilder.setScheduleToCloseTimeout​`].","label":"Schedule-To-Close Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set a [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout), use [`ActivityOptions.newBuilder.setScheduleToCloseTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `Duration`\n- Default: Unlimited.\n  Note that if `WorkflowRunTimeout` and/or `WorkflowExecutionTimeout` are defined in the Workflow, all Activity retries will stop when either or both of these timeouts are reached.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                      \"GetCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                          .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-schedule-to-start-timeout-in-java.md","id":"java/how-to-set-a-schedule-to-start-timeout-in-java","title":"How to set a Schedule-To-Start Timeout in Java","description":"To set a Schedule-To-Start Timeout, use `ActivityOptions.newBuilder.setScheduleToStartTimeout​`].","label":"Schedule-To-Start Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set a [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout), use [`ActivityOptions.newBuilder.setScheduleToStartTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: Unlimited. This timeout is non-retryable.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                          // required when setting Activity options.\n                          .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n             WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"GetCustomerGreeting\",\n                                ActivityOptions.newBuilder()\n                                    .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                    .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-start-to-close-timeout-in-java.md","id":"java/how-to-set-a-start-to-close-timeout-in-java","title":"How to set a Start-To-Close Timeout in Java","description":"To set a Start-To-Close Timeout, use `ActivityOptions.newBuilder.setStartToCloseTimeout​`].","label":"Start-To-Close Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout), use [`ActivityOptions.newBuilder.setStartToCloseTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `Duration`\n- Default: Defaults to [`ScheduleToCloseTimeout`](#scheduletoclosetimeout) value\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n              ActivityOptions.newBuilder()\n                      .setStartToCloseTimeout(Duration.ofSeconds(2))\n                      .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // Set Activity Execution timeout (single run)\n                                            .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-execution-timeout-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-workflow-execution-timeout-in-java.md","id":"java/how-to-set-a-workflow-execution-timeout-in-java","title":"How to set a Workflow Execution Timeout in Java","description":"Set the Workflow Execution Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowExecutionTimeout`.","label":"Workflow Execution Timeout","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowExecutionTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Execution Timeout duration\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-workflow-id-in-java.md","id":"java/how-to-set-a-workflow-id-in-java","title":"How to set a custom Workflow Id in Java","description":"Set the Workflow Id with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowId​`.","label":"Workflow Id","tags":["Java","how-to","developer-guide"],"markdown_content":"\nSet the Workflow Id with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowId​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                // Set the Workflow Id\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-run-timeout-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-workflow-run-timeout-in-java.md","id":"java/how-to-set-a-workflow-run-timeout-in-java","title":"How to set a Workflow Run Timeout in Java","description":"Set the Workflow Run Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowRunTimeout`.","label":"Workflow Run Timeout","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the Workflow Run Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowRunTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Same as [WorkflowExecutionTimeout](/java/how-to-set-a-workflow-execution-timeout-in-java).\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Run Timeout duration\n                .setWorkflowRunTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-workflow-task-queue-in-java.md","id":"java/how-to-set-a-workflow-task-queue-in-java","title":"How to set the Task Queue for Workflow Execution in Java","description":"Set the Workflow Task Queue with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setTaskQueue`.","label":"Task Queue","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the Workflow Task Queue with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setTaskQueue`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                // Set the Task Queue\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-timeout-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-a-workflow-task-timeout-in-java.md","id":"java/how-to-set-a-workflow-task-timeout-in-java","title":"How to set a Workflow Task Timeout in Java","description":"Set the Workflow Task Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowTaskTimeout`.","label":"Workflow Task Timeout","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the Workflow Task Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowTaskTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: 10 seconds.\n- Values: Maximum accepted value is 60 seconds.\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Task Timeout duration\n                .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-activity-retry-options-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-activity-retry-options-in-java.md","id":"java/how-to-set-activity-retry-options-in-java","title":"How to set Activity Retry Options in Java","description":"To set a Heartbeat Timeout, use `ActivityOptions.newBuilder.setHeartbeatTimeout​`].","label":"Activity Retry Options","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set a Retry Policy, known as the [Retry Options](/concepts/what-is-a-retry-policy) in Java, use [`ActivityOptions.newBuilder.setRetryOptions()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: Server-defined Activity Retry policy.\n\n- With `ActivityStub`\n\n  ```java\n  private final ActivityOptions options =\n      ActivityOptions.newBuilder()\n          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n          // required when setting Activity options.\n          .setStartToCloseTimeout(Duration.ofSeconds(5))\n          .setRetryOptions(\n              RetryOptions.newBuilder()\n                  .setInitialInterval(Duration.ofSeconds(1))\n                  .setMaximumInterval(Duration.ofSeconds(10))\n                  .build())\n          .build();\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                // required when setting Activity options.\n                                .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                .setRetryOptions(\n                                      RetryOptions.newBuilder()\n                                          .setDoNotRetry(NullPointerException.class.getName())\n                                          .build())\n                                .build()))\n                .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-activity-timeouts-in-java.md","id":"java/how-to-set-activity-timeouts-in-java","title":"How to set Activity Timeouts in Java","description":"Activity Timeouts","label":"Activity Timeouts","tags":["Java","how-to","developer-guide"],"markdown_content":"\nSet your Activity Timeout from the [`ActivityOptions.Builder`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html) class.\n\nAvailable timeouts are:\n\n- ScheduleToCloseTimeout()\n- ScheduleToStartTimeout()\n- StartToCloseTimeout()\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\n\nThe following uses `ActivityStub`.\n\n```java\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                        // .setStartToCloseTimeout(Duration.ofSeconds(2)\n                        // .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                        .build());\n```\n\nThe following uses `WorkflowImplementationOptions`.\n\n```java\nWorkflowImplementationOptions options =\n            WorkflowImplementationOptions.newBuilder()\n                    .setActivityOptions(\n                            ImmutableMap.of(\n                                    \"GetCustomerGreeting\",\n                                    // Set Activity Execution timeout\n                                    ActivityOptions.newBuilder()\n                                        .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                        // .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                        // .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                        .build()))\n                    .build();\n```\n\n:::note\n\nIf you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n:::\n","is_empty":false},{"file_name":"how-to-set-activityoptions-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-activityoptions-in-java.md","id":"java/how-to-set-activityoptions-in-java","title":"How to set ActivityOptions in Java","description":"Use `ActivityOptions` to configure how to invoke an Activity Execution.","label":"Set Activity Options","tags":["java","developer-guide"],"markdown_content":"\nUse `ActivityOptions` to configure how to invoke an Activity Execution.\nNote that Activity options must be set before the Activity Execution is invoked.\n\nYou can set Activity options for Activities within a Workflow or define specific Activity options per Activity Type within a Worker.\n\n## Setting Activity options within a Workflow\n\nUse `ActivityOptions` with `ActivityStub` to set options for invoking Activities within a Workflow.\nThe following example shows how to set `ActivityOptions` for Activities within a Workflow.\n\n```java\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofSeconds(5))\n                        // if task queue not set, it will be same Task Queue as what the Workflow uses\n                        .setTaskQueue(\"yourTaskQueue\")\n                        // If RetryOptions are not explicitly set, Activities have a default RetryOption that apply.\n                       .setRetryOptions(RetryOptions.newBuilder()\n                                .build())\n                        .build());\n\n```\n\nNote that these Activity options will apply for all the Activities defined in the _GreetingActivities_ Activity interface.\nYou can create multiple Activity stubs within a Workflow, and each can have different Activity options defined.\n\n## Setting per-Activity options when registering a Workflow with a Worker\n\nTo set different options per Activity type, use `.setActivityOptions` with `WorkflowImplementationOptions`.\nNote that if you define options per Activity Type with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically within `ActivityOptions` in a Workflow will override this setting.\n\nThe following example shows how to set Activity options for Activity Types with `WorkflowImplementationOptions`.\n\n```java\n WorkflowImplementationOptions options =\n                WorkflowImplementationOptions.newBuilder()\n                        // setActivityOptions allows you to set different ActivityOption per Activity type.\n                        // By default Activity type is the name of Activity method (with first letter capitalized.)\n                        .setActivityOptions(\n                                ImmutableMap.of(\n                                        \"GetCustomerGreeting\",\n                                        ActivityOptions.newBuilder()\n                                                // Set Activity Execution timeout (including retries)\n                                                .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                                .build(),\n                                        \"EmailCustomerGreeting\",\n                                        ActivityOptions.newBuilder()\n                                                // Set Activity Execution timeout (single run)\n                                                .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                                .setRetryOptions(\n                                                        RetryOptions.newBuilder()\n                                                                // ActivityTypeB activity type shouldn't retry on NPE\n                                                                .setDoNotRetry(NullPointerException.class.getName())\n                                                                .build())\n                                                .build()))\n                        .build();\n// ...\nworker.registerWorkflowImplementationTypes(options, YourWorkflowImpl.class);\n```\n\nFor more details, see [Activity Options Reference](/java/reference-activityoptions).\n","is_empty":false},{"file_name":"how-to-set-child-workflow-options-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-child-workflow-options-in-java.md","id":"java/how-to-set-child-workflow-options-in-java","title":"How to set ChildWorkflowOptions in Java","description":"Set Child Workflow specific options with the `ChildWorkflowOptions` class.","label":"Child Workflow Options","tags":["java","developer-guide"],"markdown_content":"\nSet Child Workflow specific options with the `ChildWorkflowOptions.Builder` class and [methods](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.8.0/io/temporal/workflow/ChildWorkflowOptions.Builder.html).\n\n| Option                                                  | Required | Type                         |\n| ------------------------------------------------------- | -------- | ---------------------------- |\n| [`Namespace`](#namespace)                               | No       | String                       |\n| [`WorkflowId`](#workflowId)                             | No       | String                       |\n| [`ParentClosePolicy`](#parentclosepolicy)               | No       | ChildWorkflowOptions.Builder |\n| [`WorkflowIdReusePolicy`](#workflowidreusepolicy)       | No       | WorkflowIdReusePolicy        |\n| [`WorkflowExecutionTimeout`](#workflowexecutiontimeout) | No       | Duration                     |\n| [`WorkflowRunTimeout`](#workflowruntimeout)             | No       | Duration                     |\n| [`WorkflowTaskTimeout`](#workflowtasktimeout)           | No       | Duration                     |\n| [`RetryOptions`](#retryoptions)                         | No       | RetryOptions                 |\n| [`CronSchedule`](#cronschedule)                         | No       | String                       |\n| [`Memo`](#memo)                                         | No       | String                       |\n| [`SearchAttributes`](#searchattributes)                 | No       | Map<String, Object>          |\n\n### `Namespace`\n\n- Type: `String`\n- Default: Inherits the `namespace` value set from the parent Workflow.\n\n```java\npublic void parentWorkflow() {\n   ChildWorkflowOptions options = ChildWorkflowOptions.newBuilder()\n        .setNamespace(\"childWorkflowNamespace\")\n        .build();\n   GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class, options);\n  }\n```\n\nSee [What is a Namespace?](/concepts/what-is-a-namespace)\n\n### `WorkflowId`\n\n- Type: `String`\n- Default: none\n\n```java\n private void parentWorkflow() {\n        ChildWorkflowOptions options =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowId(\"childWorkflow1\")\n                        .build();\n\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a WorkflowId?](/concepts/what-is-a-workflow-id)\n\n### `ParentClosePolicy`\n\nimport ParentClosePolicy from './how-to-set-a-parent-close-policy-in-java.md'\n\n<ParentClosePolicy/>\n\n### `WorkflowIdReusePolicy`\n\n- Type: `WorkflowIdReusePolicy`\n- Default: `enums.AllowDuplicateFailedOnly` is the default value. It means that the Workflow can start a new run if the previous run failed, was canceled, or was terminated.\n- Values: `AllowDuplicate` allows a new run independently of the previous run closure status.\n  `RejectDuplicate` doesn't allow a new run independently of the previous run closure status.\n\n```java\n private void parentWorkflow() {\n        ChildWorkflowOptions options = ChildWorkflowOptions.newBuilder()\n        .setWorkflowId(\"YourWorkflowId\")\n        .setWorkflowRunTimeout(Duration.ofSeconds(5))\n        .setWorkflowIdReusePolicy(\n                WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE\n        )\n        .build();\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a Workflow Id Reuse Policy?](/concepts/what-is-a-workflow-id-reuse-policy)\n\n### `WorkflowExecutionTimeout`\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```java\n private void parentWorkflow() {\n        ChildWorkflowOptions childWorkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                        .build();\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a Workflow Execution Timeout?](/concepts/what-is-a-workflow-execution-timeout)\n\n### `WorkflowRunTimeout`\n\n- Type: `time.Duration`\n- Default: Same as [WorkflowExecutionTimeout](#WorkflowExecutionTimeout).\n\n```java\nprivate void parentWorkflow() {\n        ChildWorkflowOptions childWorkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowRunTimeout(Duration.ofSeconds(4))\n                        .build();\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a Workflow Run Timeout?](/concepts/what-is-a-workflow-run-timeout)\n\n### `WorkflowTaskTimeout`\n\n- Type: `time.Duration`\n- Default: 10 seconds.\n- Values: Maximum accepted value is 60 seconds.\n\n```java\n private void parentWorkflow() {\n        ChildWorkflowOptions childWorkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                        .build();\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a Workflow Task Timeout?](/concepts/what-is-a-workflow-task-timeout)\n\n### `RetryOptions`\n\n- Type: `RetryOptions`\n- Default: `Null` which means no retries will be attempted.\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowExecutionTimeout(Duration.ofSeconds(10)\n                        .setRetryOptions(RetryOptions.newBuilder()\n                                .build())\n                        .build();\n         ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, ChildworkflowOptions);\n         child.executeChild();\n```\n\nSee [What is a Retry Policy?](/concepts/what-is-a-retry-policy)\n\n### `CronSchedule`\n\n- Type: `String`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setCronSchedule(\"@every 10s\")\n                        .build();\n         ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, ChildworkflowOptions);\n         child.executeChild();\n```\n\nSee [Cron Schedules](/concepts/what-is-a-temporal-cron-job#cron-schedules)\n\n### `Memo`\n\n- Type: `String`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // You can set additional non-indexed info via Memo\n                        .setMemo(ImmutableMap.of(\n                                \"memoKey\", \"memoValue\"\n                        ))\n                        .build();\n```\n\nSee [What is a Memo?](/concepts/what-is-a-memo)\n\n### `SearchAttributes`\n\n- Type: `Map<String, Object>`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // You can set search attributes just like in WorkflowOptions\n                        // make sure that these search attributes were added before\n                        .setSearchAttributes(ImmutableMap.of(\"MySearchAttributeNAme\", \"value\"))\n                        .build();\n```\n\nSee [What is a Search Attribute?](/concepts/what-is-a-search-attribute)\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-mtls-configuration-in-java.md","id":"java/how-to-set-mtls-configuration-in-java","title":"How to set mTLS configuration in Java","description":"To set the mTLS configuration in Java, provide the certificate and private key in an instance of `WorkflowServiceStub`.","label":"Set mTLS configuration","tags":["developer-guide","sdk","java"],"markdown_content":"\nTo set the mTLS configuration in Java, provide the certificate and private key in an instance of `WorkflowServiceStub`.\n\nThe following example shows how to set up certificates and pass the `SSLContext` for the Client.\n\n```java\nimport io.temporal.serviceclient.SimpleSslContextBuilder;\n...\n// Load your client certificate, which should look like:\n    // -----BEGIN CERTIFICATE-----\n    // ...\n    // -----END CERTIFICATE-----\n    InputStream clientCert = new FileInputStream(System.getenv(\"TEMPORAL_CLIENT_CERT\"));\n    // PKCS8 client key, which should look like:\n    // -----BEGIN PRIVATE KEY-----\n    // ...\n    // -----END PRIVATE KEY-----\n    InputStream clientKey = new FileInputStream(System.getenv(\"TEMPORAL_CLIENT_KEY\"));\n    // For Temporal Cloud this would likely be ${namespace}.tmprl.cloud:7233\n    String targetEndpoint = System.getenv(\"TEMPORAL_ENDPOINT\");\n    // Your registered Namespace.\n    String namespace = System.getenv(\"TEMPORAL_NAMESPACE\");\n    // Create SSL enabled client by passing SslContext, created by SimpleSslContextBuilder.\n    WorkflowServiceStubs service =\n        WorkflowServiceStubs.newInstance(\n            WorkflowServiceStubsOptions.newBuilder()\n                .setSslContext(SimpleSslContextBuilder.forPKCS8(clientCert, clientKey).build())\n                .setTarget(targetEndpoint)\n                .build());\n\n```\n\nFor more information, see [Sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/ssl/SslEnabledWorker.java).\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-the-namespace-for-a-temporal-client-in-java.md","id":"java/how-to-set-the-namespace-for-a-temporal-client-in-java","title":"How to set a Namespace for a Temporal Client in Java","description":"Use the setNamespace method on Workflow Client Options Builder.","label":"Set Namespace","tags":["how-to","java"],"markdown_content":"\nUse the `setNamespace()` method on Workflow Client Options Builder.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\nWorkflowClientOptions clientOptions = WorkflowClientOptions.newBuilder()\n        .setNamespace(\"your-custom-namespace\").build();\nWorkflowClient workflowClient =  WorkflowClient.newInstance(service, clientOptions);\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-timers-in-java.md","id":"java/how-to-set-timers-in-java","title":"How to set Timers in Java","description":"To set a Timer in Java, use `sleep()`.","label":"Timers","tags":["timers","sleep"],"markdown_content":"\nTo set a Timer in Java, use [`sleep()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#sleep) and pass the number of seconds you want to wait before continuing.\n\n```java\nsleep(5);\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-retry-options-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-workflow-retry-options-in-java.md","id":"java/how-to-set-workflow-retry-options-in-java","title":"How to set Workflow Retry Options in Java","description":"Set Workflow Retry Options in the `WorkflowStub` instance using `WorkflowOptions.Builder.setWorkflowRetryOptions`.","label":"Workflow Retry Options","tags":["java","how-to","developer-guide"],"markdown_content":"\nTo set a Workflow Retry Options in the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance use [`WorkflowOptions.Builder.setWorkflowRetryOptions`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: `Null` which means no retries will be attempted.\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Retry Options\n                .setRetryOptions(RetryOptions.newBuilder()\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-workflow-timeouts-in-java.md","id":"java/how-to-set-workflow-timeouts-in-java","title":"How to set Workflow Timeouts in Java","description":"Set the Workflow Execution Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowExecutionTimeout`.","label":"Workflow Timeouts","tags":["java","how-to","developer-guide"],"markdown_content":"\nCreate an instance of [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) in the Client code and set your timeout.\n\nAvailable timeouts are:\n\n- [setWorkflowExecutionTimeout()](<https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html#setWorkflowExecutionTimeout(java.time.Duration)>)\n- [setWorkflowRunTimeout()](<https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html#setWorkflowRunTimeout(java.time.Duration)>)\n- [setWorkflowTaskTimeout()](<https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html#setWorkflowTaskTimeout(java.time.Duration)>)\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWorkflow\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Timeout duration\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                // .setWorkflowRunTimeout(Duration.ofSeconds(10))\n                // .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-workflowclientoptions-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-workflowclientoptions-in-java.md","id":"java/how-to-set-workflowclientoptions-in-java","title":"How to set WorkflowClientOptions in Java","description":"Set `WorkflowClient` specific options with the `WorkflowClientOptions` class.","label":"WorkflowClientOptions","tags":["java","developer-guide"],"markdown_content":"\nSet `WorkflowClient` specific options with the `WorkflowClientOptions` class.\n\nThe following table lists the options used to configure `WorkflowClient`.\n\n| Option                  | Description                                                                       | Type                        |\n| ----------------------- | --------------------------------------------------------------------------------- | --------------------------- |\n| setDataConverter        | Set data converter                                                                | DataConverter               |\n| setInterceptors         | Set interceptors used to intercept Workflow Client calls                          | WorkflowClientInterceptor[] |\n| setIdentity             | Set human-readable identity of the Worker                                         | String                      |\n| setBinaryChecksum       | Set Worker binary checksum                                                        | String                      |\n| setContextPropagators   | Set the Context Propagators                                                       | List< ContextPropagator >   |\n| setQueryRejectCondition | Set conditions for when a Query should be rejected by closed and failed Workflows | QueryRejectCondition        |\n","is_empty":false},{"file_name":"how-to-set-workflowservicestuboptions-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-set-workflowservicestuboptions-in-java.md","id":"java/how-to-set-workflowservicestuboptions-in-java","title":"How to set WorkflowServiceStubOptions in Java","description":"Set `WorkflowServiceStub` specific options with the `WorkflowServiceStubOptions` class.","label":"WorkflowServiceStubOptions","tags":["java","developer-guide"],"markdown_content":"\nSet `WorkflowServiceStub`-specific options with the `WorkflowServiceStubOptions` class.\nThe following table lists the options used to configure `WorkflowServiceStub`.\n\n| Option                             | Description                                                                 | Type            |\n| ---------------------------------- | --------------------------------------------------------------------------- | --------------- |\n| setChannel                         | Sets gRPC channel to use. Exclusive with target and sslContext              | ManagedChannel  |\n| setSslContext                      | Sets gRPC SSL Context to use                                                | SslContext      |\n| setEnableHttps                     | Sets option to enable SSL/TLS/HTTPS for gRPC                                | boolean         |\n| setTarget                          | Sets a target string                                                        | String          |\n| setRpcTimeout                      | Sets the rpc timeout value for non query and non long poll calls            | Duration        |\n| setRpcLongPollTimeout              | Sets the rpc timeout value                                                  | Duration        |\n| setRpcQueryTimeout                 | Sets the rpc timeout for queries                                            | Duration        |\n| setRpcRetryOptions                 | Set the rpc retry options                                                   | RpcRetryOptions |\n| setConnectionBackoffResetFrequency | Sets frequency at which gRPC connection backoff should be reset practically | Duration        |\n| setGrpcReconnectFrequency          | Sets frequency at which gRPC channel will be moved into an idle state       | Duration        |\n| setQueryRpcTimeout                 | Set the query rpc options                                                   | Duration        |\n| setHeaders                         | Set the headers                                                             | Metadata        |\n| setBlockingStubInterceptor         | Set blocking stub interceptor                                               | Function        |\n| setFutureStubInterceptor           | Set the future stub interceptor                                             | Function        |\n| setMetricsScope                    | Set the metric scope                                                        | Scope           |\n| setEnableKeepAlive                 | Set keep alive ping from client to the server                               | boolean         |\n| setKeepAliveTime                   | Set the keep alive time                                                     | Duration        |\n| setKeepAliveTimeout                | Set the keep alive timeout                                                  | Duration        |\n| setKeepAlivePermitWithoutStream    | Set if client sends keepalive pings even with no active RPCs                | boolean         |\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-spawn-a-child-workflow-execution-in-java.md","id":"java/how-to-spawn-a-child-workflow-execution-in-java","title":"How to spawn a Child Workflow Execution in Java","description":"The first call to the Child Workflow stub can be synchronous or asynchronous using `Async.function(Functions.Func)` or `Async.procedure(Functions.Proc)`, and must always be to a method annotated with `@WorkflowMethod`.","label":"Child Workflow Execution","tags":["java","developer-guide"],"markdown_content":"\nThe first call to the Child Workflow stub must always be its Workflow method (method annotated with `@WorkflowMethod`).\nSimilar to Activities, invoking Child Workflow methods can be made synchronous or asynchronous by using `Async#function` or `Async#procedure`.\nThe synchronous call blocks until a Child Workflow method completes.\nThe asynchronous call returns a `Promise` which can be used to wait for the completion of the Child Workflow method, as in the following example:\n\n```java\nGreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\nPromise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n// ...\ngreeting.get()\n```\n\nTo execute an untyped Child Workflow asynchronously, call `executeAsync` on the `ChildWorkflowStub`, as shown in the following example.\n\n```java\n//...\nChildWorkflowStub childUntyped =\n    Workflow.newUntypedChildWorkflowStub(\n        \"GreetingChild\", // your workflow type\n        ChildWorkflowOptions.newBuilder().setWorkflowId(\"childWorkflow\").build());\n\nPromise<String> greeting =\n    childUntyped.executeAsync(String.class, String.class, \"Hello\", name);\nString result = greeting.get();\n//...\n```\n\nThe following examples show how to spawn a Child Workflow:\n\n- Spawn a Child Workflow from a Workflow:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n  @WorkflowMethod\n  String composeGreeting(String greeting, String name);\n  }\n  // Child Workflow implementation not shown\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n  @Override\n  public String getGreeting(String name) {\n      GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n      // This is a blocking call that returns only after child has completed.\n      return child.composeGreeting(\"Hello\", name );\n  }\n  }\n  ```\n\n- Spawn two Child Workflows (with the same type) in parallel:\n\n  ```java\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n\n          // Workflows are stateful, so a new stub must be created for each new child.\n          GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting1 = Async.function(child1::composeGreeting, \"Hello\", name);\n\n          // Both children will run concurrently.\n          GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting2 = Async.function(child2::composeGreeting, \"Bye\", name);\n\n          // Do something else here.\n          ...\n          return \"First: \" + greeting1.get() + \", second: \" + greeting2.get();\n      }\n  }\n  ```\n\n- Send a Signal to a Child Workflow from the parent:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n      @WorkflowMethod\n      String composeGreeting(String greeting, String name);\n\n      @SignalMethod\n      void updateName(String name);\n  }\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n          GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n          child.updateName(\"Temporal\");\n          return greeting.get();\n      }\n  }\n  ```\n\n- Sending a Query to Child Workflows from within the parent Workflow code is not supported. However, you can send a Query to Child Workflows from Activities using `WorkflowClient`.\n\nRelated reads:\n\n- [How to set a Child Workflow Options in Java](/java/how-to-set-child-workflow-options-in-java)\n\n- [How to develop a Workflow Definition in Java](/java/how-to-develop-a-workflow-definition-in-java)\n\n- Java Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-spawn-a-workflow-execution-in-java.md","id":"java/how-to-spawn-a-workflow-execution-in-java","title":"How to spawn a Workflow Execution in Java","description":"Use `WorkflowStub` to start a Workflow Execution from within a Client, and `ExternalWorkflowStub` to start a different Workflow Execution from within a Workflow.","label":"Workflow Execution","tags":["java","developer-guide"],"markdown_content":"\nUse `WorkflowStub` to start a Workflow Execution from within a Client, and `ExternalWorkflowStub` to start a different Workflow Execution from within a Workflow.\n\nSee [`SignalwithStart`](/java/how-to-send-a-signal-with-start-in-java) to start a Workflow Execution to receive a Signal from within another Workflow.\n\n**Using `WorkflowStub`**\n\n`WorkflowStub` is a proxy generated by the `WorkflowClient`.\nEach time a new Workflow Execution is started, an instance of the Workflow implementation object is created.\nThen, one of the methods (depending on the Workflow Type of the instance) annotated with `@WorkflowMethod` can be invoked.\nAs soon as this method returns, the Workflow Execution is considered to be complete.\n\nYou can use a typed or untyped `WorkflowStub` in the client code.\n\n- Typed `WorkflowStub` are useful because they are type safe and allow you to invoke your Workflow methods such as `@WorkflowMethod`, `@QueryMethod`, and `@SignalMethod` directly.\n- An untyped `WorkflowStub` does not use the Workflow interface, and is not type safe. It is more flexible because it has methods from the `WorkflowStub` interface, such as `start`, `signalWithStart`, `getResults` (sync and async), `query`, `signal`, `cancel` and `terminate`.\n  Note that the Temporal Java SDK also provides typed `WorkflowStub` versions for these methods.\n  When using untyped `WorkflowStub`, we rely on the Workflow Type, Activity Type, Child Workflow Type, as well as Query and Signal names.\n  For details, see [Temporal Client](/java/how-to-create-a-temporal-client-in-java).\n\nA Workflow Execution can be started either synchronously or asynchronously.\n\n- Synchronous invocation starts a Workflow and then waits for its completion. If the process that started the Workflow crashes or stops waiting, the Workflow continues executing.\n  Because Workflows are potentially long-running, and Client crashes happen, it is not very commonly found in production use.\n  The following example is a type-safe approach for starting a Workflow Execution synchronously.\n\n  ```java\n    NotifyUserAccounts workflow = client.newWorkflowStub(\n          NotifyUserAccounts.class,\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(\"notifyAccounts\")\n                  .setTaskQueue(taskQueue)\n                  .build()\n          );\n\n  // start the Workflow and wait for a result.\n    workflow.notify(new String[] { \"Account1\", \"Account2\", \"Account3\", \"Account4\", \"Account5\",\n                  \"Account6\", \"Account7\", \"Account8\", \"Account9\", \"Account10\"});\n      }\n  // notify(String[] accountIds) is a Workflow method defined in the Workflow Definition.\n  ```\n\n- Asynchronous start initiates a Workflow Execution and immediately returns to the caller. This is the most common way to start Workflows in production code.\n  The `WorkflowClient`<https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/client/WorkflowClient.java)> provides some static methods, such as `start`, `execute`, `signalWithStart` etc., that help with starting your Workflows asynchronously.\n\n  The following examples show how to start Workflow Executions asynchronously, with either typed or untyped `WorkflowStub`.\n\n  - **Typed WorkflowStub Example**\n\n    ```java\n    // create typed Workflow stub\n    FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n          WorkflowOptions.newBuilder()\n                  .setTaskQueue(taskQueue)\n                  .setWorkflowId(workflowId)\n                  .build());\n    // use WorkflowClient.execute to return future that contains Workflow result or failure, or\n    // use WorkflowClient.start to return WorkflowId and RunId of the started Workflow).\n    WorkflowClient.start(workflow::greetCustomer);\n    ```\n\n  - **Untyped WorkflowStub Example**\n\n    ```java\n    WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(workflowId)\n                  .setTaskQueue(taskQueue)\n                  .build());\n\n    // blocks until Workflow Execution has been started (not until it completes)\n    untyped.start(argument);\n    ```\n\nYou can call a Dynamic Workflow implementation using an untyped `WorkflowStub`.\nThe following example shows how to call the Dynamic Workflow implementation in the Client code.\n\n```java\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    /**\n      * Note that for this part of the client code, the dynamic Workflow implementation must\n      * be known to the Worker at runtime in order to dispatch Workflow tasks, and may be defined\n      * in the Worker definition as:*/\n    // worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    /* Create the Workflow stub to call the dynamic Workflow.\n    * Note that the Workflow Type is not explicitly registered with the Worker.*/\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n```\n\n`DynamicWorkflow` can be used to invoke different Workflow Types.\nTo check what type is running when your Dynamic Workflow `execute` method runs, use `getWorkflowType()` in the implementation code.\n\n```java\nString type = Workflow.getInfo().getWorkflowType();\n```\n\nSee [Workflow Execution Result](/java/how-to-get-the-result-of-a-workflow-execution-in-java) for details on how to get the results of the Workflow Execution.\n\n**Using `ExternalWorkflowStub`**\n\nUse `ExternalWorkflowStub` within a Workflow to invoke, and send Signals to, other Workflows by type.\n\nThis helps particularly for executing Workflows written in other language SDKs, as shown in the following example.\n\n```java\n@Override\n  public String yourWFMethod(String name) {\n      ExternalWorkflowStub callOtherWorkflow = Workflow.newUntypedExternalWorkflowStub(\"OtherWFId\");\n    }\n```\n\nSee the [Temporal Polyglot](https://github.com/tsurdilo/temporal-polyglot) code for examples of executing Workflows written in other language SDKs.\n\n**Recurring start**\n\nYou can start a Workflow Execution on a regular schedule by using [`setCronSchedule`](/java/reference-workflowoptions/#cronschedule) Workflow option in the Client code.\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-spawn-an-activity-execution-in-java.md","id":"java/how-to-spawn-an-activity-execution-in-java","title":"How to spawn an Activity Execution in Java","description":"Invoke Activities using `Workflow.newActivityStub`(type-safe) or `Workflow.newUntypedActivityStub` (untyped) from within a Workflow.","label":"Activity Execution","tags":["java","developer-guide"],"markdown_content":"\nActivities are remote procedure calls that must be invoked from within a Workflow using `ActivityStub`.\nActivities are not executable on their own. You cannot start an Activity Execution by itself.\n\nNote that before an Activity Execution is invoked:\n\n- Activity options (either [`setStartToCloseTimeout`](/concepts/what-is-a-start-to-close-timeout) or [`ScheduleToCloseTimeout`](/concepts/what-is-a-schedule-to-close-timeout) are required) must be set for the Activity.\n  For details, see [Set Activity Options](/java/how-to-set-activityoptions-in-java) and [Activity Options reference](/java/reference-activityoptions).\n- The Activity must be registered with a Worker.\n  See [Worker Program](/java/how-to-develop-a-worker-program-in-java)\n- Activity code must be thread-safe.\n\nActivities should only be instantiated using stubs from within a Workflow.\nAn `ActivityStub` returns a client-side stub that implements an Activity interface.\nYou can invoke Activities using `Workflow.newActivityStub`(type-safe) or `Workflow.newUntypedActivityStub` (untyped).\n\nCalling a method on the Activity interface schedules the Activity invocation with the Temporal service, and generates an [`ActivityTaskScheduled` Event](/concepts/what-is-an-event#activitytaskscheduled).\n\nActivities can be invoked synchronously or asynchronously.\n\n**Invoking Activities Synchronously**\n\nIn the following example, we use the type-safe `Workflow.newActivityStub` within the \"FileProcessingWorkflow\" Workflow implementation to create a client-side stub of the `FileProcessingActivities` class. We also define `ActivityOptions` and set `setStartToCloseTimeout` option to one hour.\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) {\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    // ...\n}\n```\n\nA Workflow can have multiple Activity stubs. Each Activity stub can have its own `ActivityOptions` defined.\nThe following example shows a Workflow implementation with two typed Activity stubs.\n\n```java\npublic FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue1\")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue2\")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n```\n\nTo invoke Activities inside Workflows without referencing the interface it implements, use an untyped Activity stub `Workflow.newUntypedActivityStub`.\nThis is useful when the Activity type is not known at compile time, or to invoke Activities implemented in different programming languages.\n\n```java\n   // Workflow code\n    ActivityOptions activityOptions =\n        ActivityOptions.newBuilder()\n        .setStartToCloseTimeout(Duration.ofSeconds(3))\n        .setTaskQueue(\"simple-queue-node\")\n        .build();\n\n    ActivityStub activity = Workflow.newUntypedActivityStub(activityOptions);\n    activity.execute(\"ComposeGreeting\", String.class, \"Hello World\" , \"Spanish\");\n```\n\n**Invoking Activities Asynchronously**\n\nSometimes Workflows need to perform certain operations in parallel.\nThe Temporal Java SDK provides the `Async` class which includes static methods used to invoke any Activity asynchronously.\nThe calls return a result of type `Promise` which is similar to the Java `Future` and `CompletionStage`.\nWhen invoking Activities, use `Async.function` for Activities that return a result, and `Async.procedure` for Activities that return void.\n\nIn the following asynchronous Activity invocation, the method reference is passed to `Async.function` followed by Activity arguments.\n\n```java\nPromise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);\n```\n\nThe following example shows how to call two Activity methods, \"download\" and \"upload\", in parallel on multiple files.\n\n```java\n  public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n      // Download all files in parallel.\n      for (String sourceFilename : args.getSourceFilenames()) {\n        Promise<String> localName =\n            Async.function(activities::download, args.getSourceBucketName(), sourceFilename);\n        localNamePromises.add(localName);\n      }\n      List<String> localNames = new ArrayList<>();\n      for (Promise<String> localName : localNamePromises) {\n        localNames.add(localName.get());\n      }\n      processedNames = activities.processFiles(localNames);\n\n      // Upload all results in parallel.\n      List<Promise<Void>> uploadedList = new ArrayList<>();\n      for (String processedName : processedNames) {\n        Promise<Void> uploaded =\n            Async.procedure(\n                activities::upload,\n                args.getTargetBucketName(),\n                args.getTargetFilename(),\n                processedName);\n        uploadedList.add(uploaded);\n      }\n      // Wait for all uploads to complete.\n      Promise.allOf(uploadedList).get();\n    } finally {\n      for (Promise<String> localNamePromise : localNamePromises) {\n        // Skip files that haven't completed downloading.\n        if (localNamePromise.isCompleted()) {\n          activities.deleteLocalFile(localNamePromise.get());\n        }\n      }\n      if (processedNames != null) {\n        for (String processedName : processedNames) {\n          activities.deleteLocalFile(processedName);\n        }\n      }\n    }\n  }\n```\n\n**Activity Execution Context**\n\n`ActivityExecutionContext` is a context object passed to each Activity implementation by default.\nYou can access it in your Activity implementations via `Activity.getExecutionContext()`.\n\nIt provides getters to access information about the Workflow that invoked the Activity.\nNote that the Activity context information is stored in a thread-local variable.\nTherefore, calls to `getExecutionContext()` succeed only within the thread that invoked the Activity function.\n\nFollowing is an example of using the `ActivityExecutionContext`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n    ActivityInfo info = ctx.getInfo();\n\n    log.info(\"namespace=\" +  info.getActivityNamespace());\n    log.info(\"workflowId=\" + info.getWorkflowId());\n    log.info(\"runId=\" + info.getRunId());\n    log.info(\"activityId=\" + info.getActivityId());\n    log.info(\"activityTimeout=\" + info.getStartToCloseTimeout();\n\n    return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n  }\n    ...\n}\n```\n\nFor details on getting the results of an Activity Execution, see [Activity Execution Result](/java/how-to-get-the-result-of-an-activity-execution-in-java).\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-java.md","id":"java/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-java","title":"How to upsert custom Search Attributes","description":"To upsert custom Search Attributes, call the Workflow.upsertSearchAttributes(Map<String, ?> searchAttributes) method.","label":"Upsert custom Search Attributes","tags":["developer-guide","sdk","java"],"markdown_content":"\nIn your Workflow code, call the [`upsertSearchAttributes(Map<String, ?> searchAttributes)`](<https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#upsertSearchAttributes(java.util.Map)>) method.\n\n```java\n Map<String, Object> attr1 = new HashMap<>();\n     attr1.put(\"CustomIntField\", 1);\n     attr1.put(\"CustomBoolField\", true);\n     Workflow.upsertSearchAttributes(attr1);\n\n     Map<String, Object> attr2 = new HashMap<>();\n     attr2.put(\"CustomIntField\", Lists.newArrayList(1, 2));\n     attr2.put(\"CustomKeywordField\", \"Seattle\");\n     Workflow.upsertSearchAttributes(attr2);\n```\n\nThe results of `upsertSearchAttributes()` output the following search attributes.\n\n```json\n   {\n       \"CustomIntField\": 1, 2,\n       \"CustomBoolField\": true,\n       \"CustomKeywordField\": \"Seattle\",\n     }\n```\n","is_empty":false},{"file_name":"how-to-use-a-side-effect-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-use-a-side-effect-in-java.md","id":"java/how-to-use-a-side-effect-in-java","title":"How to use a Side Effect in Java","description":"A Side Effect is a method of execution to produce nondeterministic code.","label":"Side Effect","tags":["Java","developer-guide"],"markdown_content":"\nTo use a Side Effect in Java, set the [`sideEffect()`](<https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#sideEffect(java.lang.Class,io.temporal.workflow.Functions.Func)>) function in your Workflow Execution and return the nondeterministic code.\n\n```java\n  int random = Workflow.sideEffect(Integer.class, () -> random.nextInt(100));\n  if random < 50 {\n         ....\n  } else {\n         ....\n  }\n```\n\nHere's another example that uses `sideEffect()`.\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.sideEffect( int.class, () -> {\n        Random random = new SecureRandom();\n        return random.nextInt();\n    });\n\n    String userHome = Workflow.sideEffect(String.class, () -> System.getenv(\"USER_HOME\"));\n\n    if(randomInt % 2 == 0) {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n\nJava also provides a deterministic method to generate random numbers or random UUIDs.\n\nTo generate random numbers in a deterministic method, use [`newRandom()`](<https://www.javadoc.io/static/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#newRandom()>)\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.newRandom().nextInt();\n    // ...\n}\n```\n\nTo generate a random UUID in a deterministic method, use [`randomUUID()`](<https://www.javadoc.io/static/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#newRandom()>).\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    String randomUUID = Workflow.randomUUID().toString();\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-use-queries-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-use-queries-in-java.md","id":"java/how-to-use-queries-in-java","title":"How to use Queries in Java","description":"Define a Query method inside the Workflow interface, annotated with the `@QueryMethod` annotation and call the method from an external process.","label":"Queries","tags":["java","developer-guide"],"markdown_content":"\nTo use Queries to query the state of a Workflow at any stage of the Workflow Execution, create a Query handler using the `@QueryMethod` annotation in the Workflow interface and call the method in your external process.\n\nYou can send a Query to an open or closed Workflow Execution.\n\nWhen using Queries, the following restrictions apply:\n\n- It cannot modify Workflow state in any way.\n- It is not allowed to block its thread in any way.\n\n### Define Query Method\n\nimport DefineQuery from './how-to-define-a-query-in-java.md'\n\n<DefineQuery/>\n\n### Handle Query\n\nimport HandleQuery from './how-to-handle-a-query-in-a-workflow-in-java.md'\n\n<HandleQuery/>\n\n### Send Query from Temporal Client\n\nimport SendQuery from './how-to-send-a-query-to-a-workflow-in-java.md'\n\n<SendQuery/>\n","is_empty":false},{"file_name":"how-to-use-signals-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/how-to-use-signals-in-java.md","id":"java/how-to-use-signals-in-java","title":"How to use Signals in Java","description":"Initiate the Signal method with `@SignalMethod` annotation in the Workflow interface and call it either directly from the Client or from within another Workflow.","label":"Signals","tags":["java","developer-guide"],"markdown_content":"\nTo use Signals in Java, initiate the Signal method with `@SignalMethod` annotation in the Workflow interface and call the Signal method either directly from the Client or use `ExternalWorkflowStub` to call the Signal method from within another Workflow.\n\nA Signal method can be called from either a Client or another Workflow to send Signals to this Workflow.\n\nNote that you can send a Signal only to running Workflow Executions.\nYou can use Signals to update the state of a running Workflow Execution.\n\n### Define Signal Method\n\nimport DefineSignal from './how-to-define-a-signal-in-java.md'\n\n<DefineSignal/>\n\n### Handle Signal\n\nimport HandleSignal from './how-to-handle-a-signal-in-a-workflow-in-java.md'\n\n<HandleSignal/>\n\n### Send Signal from Temporal Client\n\nimport SendSignalClient from './how-to-send-a-signal-from-a-client-in-java.md'\n\n<SendSignalClient/>\n\n### Send Signal from within a Workflow\n\nimport SendSignalWorkflow from './how-to-send-a-signal-from-a-workflow-in-java.md'\n\n<SendSignalWorkflow/>\n\n### Signal-With-Start\n\nimport SignalWithStart from './how-to-send-a-signal-with-start-in-java.md'\n\n<SignalWithStart/>\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/index.md","id":"java/index","title":"How to use the Temporal Java SDK","description":"Add the Temporal Java SDK to your project.","label":"Java How-to","tags":["developer-guide","Java"],"markdown_content":"\n[![Build status](https://badge.buildkite.com/663f6d1be81be6700c28c242b35905f20b68c4fda7b2c7c4e3.svg?branch=master)](https://buildkite.com/temporal/java-sdk-public)\n\nAdd the [Temporal Java SDK](https://github.com/temporalio/sdk-java) to your project as a dependency:\n\n**[Apache Maven](https://maven.apache.org/)**:\n\n```maven\n<dependency>\n  <groupId>io.temporal</groupId>\n  <artifactId>temporal-sdk</artifactId>\n  <version>1.17.0</version>\n</dependency>\n```\n\n**[Gradle Groovy DSL](https://gradle.org/)**:\n\n```groovy\nimplementation 'io.temporal:temporal-sdk:1.17.0'\n```\n\n**Other**:\n\nAdditional scripts for each SDK version are available here: [https://search.maven.org/artifact/io.temporal/temporal-sdk](https://search.maven.org/artifact/io.temporal/temporal-sdk).\nSelect an SDK version to see available scripts.\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/queries.md","id":"java/queries","title":"Queries in Java","label":"Queries","tags":["java"],"markdown_content":"\nWorkflow queries can be used to query a Workflow state by external processes at any time during its execution.\nQuery methods can only be defined inside Workflows Interfaces and are methods annotated with the `@QueryMethod` annotation, for example:\n\n```java\n  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @QueryMethod\n    int getCount();\n  }\n```\n\nNotice that the `getCount` method is annotated with `@QueryMethod`.\nThere can be multiple Query methods per Workflow interface.\n\nThe `QueryMethod` annotation has an optional `name` property which can be used to define the query type.\nIf not specified it defaults to the method name.\n\nLet's look at a Workflow implementation and its query method:\n\n```java\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = \"Hello\";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!\"Bye\".equals(greeting)) {\n        logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n```\n\nThe restrictions on the implementation of the Query method are the following:\n\n- It can not modify Workflow state in any way.\n- It is not allowed to block its thread in any way.\n\nThe Query method usually just returns a value derived from the fields of the Workflow object.\n\nQuery methods can take in any number of input parameters which can be used to limit the data that is returned for example.\n","is_empty":false},{"file_name":"reference-activityoptions.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/reference-activityoptions.md","id":"java/reference-activityoptions","title":"Java ActivityOptions reference","description":"Use `ActivityOptions` to configure how to invoke an Activity Execution.","label":"Activity Options reference","tags":["developer-guide","how-to","java"],"markdown_content":"\nUse [`ActivityOptions`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html) to configure how to invoke an Activity Execution.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\nThe following table lists all `ActivityOptions` that can be configured for an Activity invocation.\n\n| Option                                                 | Required                                           | Type                     |\n| ------------------------------------------------------ | -------------------------------------------------- | ------------------------ |\n| [`setScheduleToCloseTimeout`](#scheduletoclosetimeout) | Yes (if `StartToCloseTimeout` is not specified)    | Duration                 |\n| [`setScheduleToStartTimeout`](#scheduletostarttimeout) | No                                                 | Duration                 |\n| [`setStartToCloseTimeout`](#starttoclosetimeout)       | Yes (if `ScheduleToCloseTimeout` is not specified) | Duration                 |\n| [`setHeartbeatTimeout`](#heartbeattimeout)             | No                                                 | Duration                 |\n| [`setTaskQueue`](#taskqueue)                           | No                                                 | String                   |\n| [`setRetryOptions`](#retryoptions)                     | No                                                 | RetryOptions             |\n| [`setCancellationType`](#cancellationtype)             | No                                                 | ActivityCancellationType |\n\n### `ScheduleToCloseTimeout`\n\nimport ScheduleToCloseTimeout from './how-to-set-a-schedule-to-close-timeout-in-java.md'\n\n<ScheduleToCloseTimeout/>\n\n### `ScheduleToStartTimeout`\n\nimport ScheduleToStartTimeout from './how-to-set-a-schedule-to-start-timeout-in-java.md'\n\n<ScheduleToStartTimeout/>\n\n### `StartToCloseTimeout`\n\nimport StartToCloseTimeout from './how-to-set-a-start-to-close-timeout-in-java.md'\n\n<StartToCloseTimeout/>\n\n### `HeartbeatTimeout`\n\nimport HeartbeatTimeout from './how-to-set-a-heartbeat-timeout-in-java.md'\n\n<HeartbeatTimeout/>\n\n### `TaskQueue`\n\n- Type: `String`\n- Default: Defaults to the Task Queue that the Workflow was started with.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are required when\n                          // setting Activity options.\n                          .setStartToCloseTimeout(Duration.ofSeconds(5))\n                          .setTaskQueue(\"yourTaskQueue\")\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                            // required when setting Activity options.\n                                            .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                            .setTaskQueue(\"yourTaskQueue\")\n                                            .build()))\n                      .build();\n  ```\n\nSee [Task Queue](/concepts/what-is-a-task-queue)\n\n### `RetryOptions`\n\nimport ActivityRetryOptions from './how-to-set-activity-retry-options-in-java.md'\n\n<ActivityRetryOptions/>\n\n### `setCancellationType`\n\n- Type: `ActivityCancellationType`\n- Default: `ActivityCancellationType.TRY_CANCEL`\n\n- With `ActivityStub`\n\n  ```java\n  private final GreetingActivities activities =\n    Workflow.newActivityStub(\n        GreetingActivities.class,\n        ActivityOptions.newBuilder()\n            .setCancellationType(ActivityCancellationType.WAIT_CANCELLATION_COMPLETED)\n            .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                .setCancellationType(ActivityCancellationType.WAIT_CANCELLATION_COMPLETED)\n                                .build()))\n                .build();\n  ```\n","is_empty":false},{"file_name":"reference-workflowoptions.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/reference-workflowoptions.md","id":"java/reference-workflowoptions","title":"Java WorkflowOptions reference","description":"Create a `newWorkflowStub` in the Temporal Client code, call the instance of the Workflow, and set the Workflow options with the `WorkflowOptions.Builder` class.","label":"Workflow Options reference","tags":["developer-guide","options"],"markdown_content":"\nCreate a [`newWorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) in the Temporal Client code, call the instance of the Workflow, and set the Workflow options with the [`WorkflowOptions.Builder`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html) class.\n\nThe following fields are available:\n\n| Option                                                  | Required             | Type                                                                                                                 |\n| ------------------------------------------------------- | -------------------- |----------------------------------------------------------------------------------------------------------------------|\n| [`WorkflowId`](#id)                                     | No (but recommended) | String                                                                                                               |\n| [`TaskQueue`](#taskqueue)                               | **Yes**              | String                                                                                                               |\n| [`WorkflowExecutionTimeout`](#workflowexecutiontimeout) | No                   | `Duration`                                                                                                           |\n| [`WorkflowRunTimeout`](#workflowruntimeout)             | No                   | `Duration`                                                                                                           |\n| [`WorkflowTaskTimeout`](#workflowtasktimeout)           | No                   | `Duration`                                                                                                           |\n| [`WorkflowIdReusePolicy`](#workflowidreusepolicy)       | No                   | `WorkflowIdReusePolicy`                                                                                              |\n| [`RetryOptions`](#retryoptions)                         | No                   | [`RetryOptions`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.17.0/io/temporal/common/RetryOptions.html) |\n| [`CronSchedule`](#cronschedule)                         | No                   | String                                                                                                               |\n| [`Memo`](#memo)                                         | No                   | string                                                                                                               |\n| [`SearchAttributes`](#searchattributes)                 | No                   | Map<String, Object>                                                                                                  |\n\n### `Id`\n\nimport WorkflowId from './how-to-set-a-workflow-id-in-java.md'\n\n<WorkflowId/>\n\n### `TaskQueue`\n\nimport TaskQueue from './how-to-set-a-workflow-task-queue-in-java.md'\n\n<TaskQueue/>\n\n### `WorkflowExecutionTimeout`\n\nimport WFETimeout from './how-to-set-a-workflow-execution-timeout-in-java.md'\n\n<WFETimeout/>\n\n### `WorkflowRunTimeout`\n\nimport WFRTimeout from './how-to-set-a-workflow-run-timeout-in-java.md'\n\n<WFRTimeout/>\n\n### `WorkflowTaskTimeout`\n\nimport WFTTimeout from './how-to-set-a-workflow-task-timeout-in-java.md'\n\n<WFTTimeout/>\n\n### `WorkflowIDReusePolicy`\n\n- Type: `WorkflowIdReusePolicy`\n- Default: `enums.AllowDuplicateFailedOnly` is the default value. It means that the Workflow can start a new run if the previous run failed, was canceled, or was terminated.\n- Values: `AllowDuplicate` allows a new run independently of the previous run closure status.\n  `RejectDuplicate` doesn't allow a new run independently of the previous run closure status.\n\n````java\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Id Reuse Policy\n                .setWorkflowIdReusePolicy(\n                        WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE)\n                .build());\n````\n\n### `RetryOptions`\n\nimport RetryOptions from './how-to-set-workflow-retry-options-in-java.md'\n\n<RetryOptions/>\n\n### `CronSchedule`\n\nimport CronSchedule from './how-to-set-a-cron-schedule-in-java.md'\n\n<CronSchedule/>\n\n### `Memo`\n\n- Type: `String`\n- Default: None\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Memo. You can set additional non-indexed info via Memo\n                        .setMemo(ImmutableMap.of(\n                                \"memoKey\", \"memoValue\"\n                        ))\n                .build());\n```\n\n### `SearchAttributes`\n\nSearch Attributes are additional indexed information attributed to Workflow and used for search and visibility.\nThese can be used in a query of List/Scan/Count Workflow APIs.\nThe key and its value type must be registered on Temporal server side.\n\n- Type: `Map<String, Object>`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // Set Search Attributes\n                        .setSearchAttributes(ImmutableMap.of(\"MySearchAttributeNAme\", \"value\"))\n                        .build();\n```\n\nThe following Java types are supported:\n\n- String\n- Long, Integer, Short, Byte\n- Boolean\n- Double\n- OffsetDateTime\n- Collection of the types in this list.\n","is_empty":false},{"file_name":"side-effect.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/side-effect.md","id":"java/side-effect","title":"SideEffect","markdown_content":"\nWorkflow code must be deterministic.\nThis is important so Temporal can replay your Workflow to the point of failure and continue its execution.\n\nWorkflow code that includes arbitrary side effects (for example getting a random number or generating a random UUID, etc), can cause unpredictable results during replay.\n\nBeing able to add some non-deterministic code inside your Workflow is in some cases important, and you can do that using `Workflow.sideEffect`.\n\nThe following sample demonstrates how to use it:\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.sideEffect( int.class, () -> {\n        Random random = new SecureRandom();\n        return random.nextInt();\n    });\n\n    String userHome = Workflow.sideEffect(String.class, () -> System.getenv(\"USER_HOME\"));\n\n    if(randomInt % 2 == 0) {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n\nThe result of `Workflow.sideEffect` is recorded into the Workflow history, meaning that during a replay it will be returned from the history without executing its code again.\n\nNote that you shouldn't modify the Workflow state inside `Workflow.sideEffect`.\nFor that you should only use the `Workflow.sideEffect` return value.\n\nThe Temporal Java SDK provides deterministic methods to generate a random number, or a random UUID as well:\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.newRandom().nextInt();\n\n    String randomUUID = Workflow.randomUUID().toString();\n\n    // ...\n}\n```\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/signals.md","id":"java/signals","title":"Signals in Java","label":"Signals","tags":["java"],"markdown_content":"\nimport {RelatedReadContainer, RelatedReadItem} from '../components/RelatedReadList.js'\n\n<!-- prettier-ignore -->\nimport * as WhatIsASignal from '../concepts/what-is-a-signal.md'\n\n<RelatedReadContainer>\n  <RelatedReadItem page={WhatIsASignal} />\n</RelatedReadContainer>\n\nSignal methods can only be defined inside Workflows Interfaces and are methods annotated with the `@SignalMethod` annotation, for example:\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n\n    @SignalMethod\n    void exit();\n}\n```\n\nA Workflow interface can define any number of signal methods.\n\nNote that the `@SignalMethod` interface has a `name` parameter which can be used to set the signal type.\nIf not specified, the signal type defaults to the name of the method.\n\nThe following example shows how signals can be used to update the Workflow state.\nYou can use the `Workflow.await` to block the current Workflow Execution until the provided unblock condition is evaluated to `true`.\nIn our case, the unblocking condition is evaluated to `true` when we receive a Signal that updates the greeting to something different from the current greeting.\nThis Workflow completes when the greeting becomes \"Bye\".\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n}\n```\n\n```java\npublic class HelloWorldImpl implements HelloWorld {\n    private final Logger workflowLogger = Workflow.getLogger(HelloWorldImpl.class);\n    private String greeting;\n\n    @Override\n    public void sayHello(String name) {\n        int count = 0;\n        while (!\"Bye\".equals(greeting)) {\n            String oldGreeting = greeting;\n            Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n        }\n        workflowLogger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n        this.greeting = greeting;\n    }\n}\n```\n","is_empty":false},{"file_name":"task-queues.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/task-queues.md","id":"java/task-queues","title":"Task Queues in Java","label":"Task Queues","markdown_content":"\nIn Java, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```java\npublic class InitiateWorkflow {\n\n  public static void main(String[] args) throws Exception {\n    // Create the WorkflowClient\n    // ...\n    WorkflowOptions options = WorkflowOptions.newBuilder()\n      .setTaskQueue(\"Workflow-Task-Queue-1\")\n      .build();\n    // pass the options to the Workflow stub\n    HelloWorldWorkflow workflow = client.newWorkflowStub(\n      WorkflowImplementation.class,\n      options\n    );\n    // Call the Workflow method on the implementation\n    // ...\n  }\n}\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```java\npublic class YourWorker {\n\n  public static void main(String[] args) {\n    // Create the WorkflowClient\n    // ...\n    // Create a Worker factory that can be used to create Workers that poll specific Task Queues.\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker(\"Workflow-Task-Queue-1\");\n    // Register Workflow implementation classes\n    worker.registerWorkflowImplementationTypes(YourdWorkflowImpl.class);\n    // Start polling the Task Queue.\n    factory.start();\n  }\n}\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```java\npublic class YourWorkflowImpl implements YourWorkflow {\n\n  ActivityOptions activityOptions = ActivityOptions.newBuilder()\n    .setTaskQueue(\"Activity-Task-Queue-1\")\n    // ...\n    .build();\n  // Pass the options to the new ActivityStub\n  private final YourActivity yourActivity = Workflow.newActivityStub(\n    YourActivity.class,\n    activityOptions\n  );\n  // Call the Activity from within the Workflow method\n  @Override\n  public String workflowMethod() {\n    return yourActivity.somemethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```java\npublic static class YourWorkflowImpl implements YourWorkflow {\n\n  @Override\n  public String workflowMethod() {\n\n    // Set the Task Queue in the Child Workflow options\n    ChildWorkflowOptions childWorkflowOptions =\n      ChildWorkflowOptions.newBuilder()\n        .setTaskQueue(\"Child-Workflow-Task-Queue-1\")\n        // ...\n        .build();\n    // Pass the options to the new Child Workflow Stub\n    ChildWorkflow childWorkflow = Workflow.newChildWorkflowStub(\n      ChildWorkflow.class,\n      childWorkflowOptions\n    );\n    // Call the Child Workflow method\n    String result = childWorkflow.workflowMethod(...);\n    return result;\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.\n","is_empty":false},{"file_name":"testing-and-debugging.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/testing-and-debugging.md","id":"java/testing-and-debugging","title":"Testing and Debugging","label":"Testing and Debugging","markdown_content":"\n## Overview\n\nThe Temporal Java SDK provides a test framework to facilitate Workflow unit and integration testing.\nThe test framework provides a `TestWorkflowEnvironment` class which includes an in-memory implementation\nof the Temporal service that supports automatic time skipping. This allows you to\neasily test long-running Workflows in seconds, without having to change your Workflow code.\n\nYou can use the provided `TestWorkflowEnvironment` with a Java unit testing framework of your choice,\nsuch as JUnit.\n\n## Setup testing dependency\n\nTo start using the Java SDK test framework, you need to add [`io.temporal:temporal-testing`](https://search.maven.org/artifact/io.temporal/temporal-testing)\nas a dependency to your project:\n\n**[Apache Maven](https://maven.apache.org/)**:\n\n```maven\n<dependency>\n    <groupId>io.temporal</groupId>\n    <artifactId>temporal-testing</artifactId>\n    <version>1.17.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\n**[Gradle Groovy DSL](https://gradle.org/)**:\n\n```groovy\ntestImplementation (\"io.temporal:temporal-testing:1.17.0\")\n```\n\nMake sure to set the version that matches your dependency version of the [Temporal Java SDK](https://github.com/temporalio/sdk-java).\n\n## Sample unit tests\n\nThe following code implements unit tests for the `HelloActivity` sample:\n\n```java\npublic class HelloActivityTest {\n\n    private TestWorkflowEnvironment testEnv;\n    private Worker worker;\n    private WorkflowClient client;\n\n    // Set up the test workflow environment\n    @Before\n    public void setUp() {\n        testEnv = TestWorkflowEnvironment.newInstance();\n        worker = testEnv.newWorker(TASK_QUEUE);\n        // Register your workflow implementations\n        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n\n        client = testEnv.getWorkflowClient();\n    }\n\n    // Clean up test environment after tests are completed\n    @After\n    public void tearDown() {\n        testEnv.close();\n    }\n\n    @Test\n    public void testActivityImpl() {\n        // This uses the actual activity impl\n        worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n\n        // Start test environment\n        testEnv.start();\n\n        // Create the workflow stub\n        GreetingWorkflow workflow =\n                client.newWorkflowStub(\n                        GreetingWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).build());\n\n        // Execute our workflow waiting for it to complete\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n    }\n}\n```\n\nIn cases where you do not wish to execute your actual Activity implementations during\nunit testing, you can use a framework such as Mockito to mock them.\n\nThe following code implements a unit test for the `HelloActivity` sample which shows\nhow activities can be mocked:\n\n```java\npublic class HelloActivityTest {\n\n    private TestWorkflowEnvironment testEnv;\n    private Worker worker;\n    private WorkflowClient client;\n\n    // Set up the test workflow environment\n    @Before\n    public void setUp() {\n        testEnv = TestWorkflowEnvironment.newInstance();\n        worker = testEnv.newWorker(TASK_QUEUE);\n        // Register your workflow implementations\n        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n\n        client = testEnv.getWorkflowClient();\n    }\n\n    // Clean up test environment after tests are completed\n    @After\n    public void tearDown() {\n        testEnv.close();\n    }\n\n    @Test\n    public void testMockedActivity() {\n        // Mock our workflow activity\n        GreetingActivities activities = mock(GreetingActivities.class);\n        when(activities.composeGreeting(\"Hello\", \"World\")).thenReturn(\"Hello Mocked World!\");\n        worker.registerActivitiesImplementations(activities);\n\n        // Start test environment\n        testEnv.start();\n\n        // Create the workflow stub\n        GreetingWorkflow workflow =\n                client.newWorkflowStub(\n                        GreetingWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).build());\n\n        // Execute our workflow waiting for it to complete\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello Mocked World!\", greeting);\n    }\n}\n```\n\n## Testing with JUnit4\n\nFor Junit4 tests, Temporal provides the TestWorkflowRule class which simplifies the Temporal test environment setup, as well as the\ncreation and shutdown of Workflow Workers in your tests.\n\nMake sure to set the version that matches your dependency version of the [Temporal Java SDK](https://github.com/temporalio/sdk-java).\n\nWe can now rewrite our above mentioned \"HelloActivityTest\" test class as follows:\n\n```java\npublic class HelloActivityJUnit4Test {\n    @Rule\n    public TestWorkflowRule testWorkflowRule =\n            TestWorkflowRule.newBuilder()\n                    .setWorkflowTypes(GreetingWorkflowImpl.class)\n                    .setActivityImplementations(new GreetingActivitiesImpl())\n                    .build();\n\n    @Test\n    public void testActivityImpl() {\n        // Get a workflow stub using the same task queue the worker uses.\n        GreetingWorkflow workflow =\n                testWorkflowRule\n                        .getWorkflowClient()\n                        .newWorkflowStub(\n                                GreetingWorkflow.class,\n                                WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build());\n        // Execute a workflow waiting for it to complete.\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n\n        testWorkflowRule.getTestEnvironment().shutdown();\n    }\n}\n```\n\n## Testing with JUnit5\n\nFor Junit5 tests, Temporal also provides the TestWorkflowExtension helped class which can be used to simplify the Temporal test environment setup\nas well as Workflow Worker startup and shutdowns.\n\nTo start using JUnit5 TestWorkflowExtension in your tests with [Gradle](https://gradle.org/), you need to enable capability [`io.temporal:temporal-testing-junit5`]:\n\nMake sure to set the version that matches your dependency version of the [Temporal Java SDK](https://github.com/temporalio/sdk-java).\n\nWe can now use JUnit5 and rewrite our above mentioned \"HelloActivityTest\" test class as follows:\n\n```java\npublic class HelloActivityJUnit5Test {\n    @RegisterExtension\n    public static final TestWorkflowExtension testWorkflowExtension =\n            TestWorkflowExtension.newBuilder()\n                    .setWorkflowTypes(GreetingWorkflowImpl.class)\n                    .setActivityImplementations(new GreetingActivitiesImpl())\n                    .build();\n\n    @Test\n    public void testActivityImpl(\n            TestWorkflowEnvironment testEnv, Worker worker, GreetingWorkflow workflow) {\n        // Execute a workflow waiting for it to complete.\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n    }\n}\n```\n\nYou can find all unit tests for the [Temporal Java samples](https://github.com/temporalio/samples-java) repository in [its test package](https://github.com/temporalio/samples-java/tree/master/src/test/java/io/temporal/samples).\n\n## Debugging\n\nIn addition to writing unit and integration tests, debugging your Workflows is also a very\nvaluable testing tool. You can debug your Workflow code using a debugger provided\nby your favorite Java IDE.\n\nNote that when debugging your Workflow code, the Temporal Java SDK includes deadlock detection\nwhich fails a Workflow Task in case the code blocks over a second without relinquishing\nexecution control. Because of this you can often encounter the `PotentialDeadlockException`\nException while stepping through Workflow code during debugging.\n\nTo alleviate this issue, you can set the `TEMPORAL_DEBUG` environment variable to true before debugging your\nWorkflow code. Make sure to set `TEMPORAL_DEBUG` to true only during debugging.\n","is_empty":false},{"file_name":"versioning.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/versioning.md","id":"java/versioning","title":"Versioning","markdown_content":"\nAs outlined in the _Workflow Implementation Constraints_ section, Workflow code has to be deterministic by taking the same\ncode path when replaying history events. Any Workflow code change that affects the order in which commands are generated breaks\nthis assumption. The solution that allows updating code of already running Workflows is to keep both the old and new code.\nWhen replaying, use the code version that the events were generated with and when executing a new code path, always take the\nnew code.\n\n## Introduction to Versioning\n\nBecause we design for potentially long-running Workflows at scale, versioning with Temporal works differently than with other workflow systems.\nWe explain more in this optional 30-minute introduction: [https://www.youtube.com/watch?v=kkP899WxgzY](https://www.youtube.com/watch?v=kkP899WxgzY).\n\n## Java Versioning API\n\nUse the `Workflow.getVersion` function to return a version of the code that should be executed and then use the returned\nvalue to pick a correct branch. Let's look at an example.\n\n```java\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\nNow we decide to calculate the processed file checksum and pass it to upload.\nThe correct way to implement this change is:\n\n```java\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        int version = Workflow.getVersion(\"checksumAdded\", Workflow.DEFAULT_VERSION, 1);\n        if (version == Workflow.DEFAULT_VERSION) {\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } else {\n            long checksum = activities.calculateChecksum(processedName);\n            activities.uploadWithChecksum(\n                args.getTargetBucketName(), args.getTargetFilename(), processedName, checksum);\n        }\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\nLater, when all Workflows that use the old version are completed, the old branch can be removed.\n\n```java\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        // getVersion call is left here to ensure that any attempt to replay history\n        // for a different version fails. It can be removed later when there is no possibility\n        // of this happening.\n        Workflow.getVersion(\"checksumAdded\", 1, 1);\n        long checksum = activities.calculateChecksum(processedName);\n        activities.uploadWithChecksum(\n            args.getTargetBucketName(), args.getTargetFilename(), processedName, checksum);\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\nThe Id that is passed to the `getVersion` call identifies the change. Each change is expected to have its own Id. But if\na change spawns multiple places in the Workflow code and the new code should be either executed in all of them or\nin none of them, then they have to share the Id.\n","is_empty":false},{"file_name":"workers.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/workers.md","id":"java/workers","title":"Workers in Java","label":"Workers","markdown_content":"\n## What is a Worker?\n\nA Worker is a service that executes [Workflows](/java/workflows) and [Activities](/java/activities).\nWorkers are defined and executed on user controlled hosts.\nYou can use the `WorkerFactory` class to create and run as many Workers as your use case demands, across any number of hosts.\n\nWorkers poll Task Queues for Tasks, execute chunks of code in response to those Tasks, and then communicate the results back to the Temporal Server.\n\nAs a developer, running Workers is a fairly simple procedure,\nbecause the Java SDK handles all the communication between the Worker and the Temporal Server behind the scenes.\n\n## How to start a Worker\n\nTo start a Worker you need to:\n\n1. Create a WorkflowClient instance\n2. Optionally create WorkerOptions\n3. Create a WorkerFactory instance\n4. Create a Worker using the created WorkerFactory's `newWorker` method\n5. Register Workflows and Activities this Worker should execute\n\nAs a simple example, let's say we want our Worker to be able to execute the following Workflow implementation:\n\n```java\npublic static class EmployeeWorkflowImpl implements EmployeeWorkflow {\n\n    private final EmployeeActivities activities =\n        Workflow.newActivityStub(\n                EmployeeActivities.class,\n            ActivityOptions.newBuilder().setStartToCloseTimeout(Duration.ofSeconds(2)).build());\n\n    @Override\n    public Employee getEmployee(String id) {\n      return activities.getEmployeeById(id);\n    }\n  }\n```\n\nOur Workflow invokes `EmployeeActivities` Activities. We can register our Workflow with our Worker:\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\nWorkflowClient client = WorkflowClient.newInstance(service);\nWorkerFactory factory = WorkerFactory.newInstance(client);\n\nWorker worker = factory.newWorker(TASK_QUEUE_NAME);\n\nworker.registerWorkflowImplementationTypes(EmployeeWorkflowImpl.class);\n```\n\nNote that in order to execute our `EmployeeWorkflowImpl` Workflow implementation, there is no need to register any Activities.\nOnly if our created Worker is also used to host the Activity implementations we should register them as well by adding for example:\n\n```java\nString connectionUrl = \"jdbc:sqlserver://localhost:1433;databaseName=EmployeesDb;user=user;password=pass\";\nworker.registerActivitiesImplementations(new EmployeeActivitiesImpl(connectionUrl));\n```\n\nFor Workflows we register the Workflow Type.\nFor Activities, since they are stateless and thread-safe, we need\nto register an Activity instance.\n\nWhen you start a Workflow or when a Workflow needs to invoke an Activity, the Temporal Server adds\na new task to the Workflows / Activity Task Queue. Any Worker polling that Task Queue and has that Workflow / Activity\nregistered can pick up the new task and execute it.\n","is_empty":false},{"file_name":"workflows.md","file_path":"/Users/ssantiago/Documents/documentation/docs/java/workflows.md","id":"java/workflows","title":"Workflows in Java","description":"The core abstraction of the Temporal solution is a fault-oblivious stateful Workflow.","label":"Workflows","markdown_content":"\nimport RelatedReadList from '../components/RelatedReadList.js'\n\n## What is a Workflow?\n\nWorkflows are resilient programs, meaning that they will continue execution even in the presence of\ndifferent failure conditions.\n\nWorkflows encapsulate execution and orchestration of Tasks, which include Activities and Child Workflows.\nThey also need to react to external events, respond to Query requests, and deal with Timeouts.\n\nIn the Temporal Java SDK programming model, a Workflow is a class that implements a Workflow Interface:\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n  // ...\n}\n```\n\nThe Workflow Interface is a Java interface which is annotated with the `@WorkflowInterface` annotation.\n\n## Workflow Interface\n\nWorkflow interface methods must have one of the following annotations:\n\n- **@WorkflowMethod** denotes the starting point of a Workflow Execution.\n  Workflow Execution completes when this method returns.\n- **@SignalMethod** indicates that this method is a Signal handler method and that it can react to external Signals.\n  It can have parameters that can contain the Signal payload.\n  It does not return a value, so it must have a `void` return type.\n- **@QueryMethod** indicates that this method can be used to query the Workflow's state at any time during its execution.\n  It can have parameters that can be used to filter a subset of the Workflow's state that it returns.\n  Because it does return a value, it cannot have a `void` return type.\n\nWorkflow interfaces can define only a single method annotated with `@WorkflowMethod`. They can define\nany number of methods annotated with `@SignalMethod` and `@QueryMethod`, for example:\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n    @WorkflowMethod\n    String processFile(Arguments args);\n\n    @QueryMethod(name=\"history\")\n    List<String> getHistory();\n\n    @QueryMethod\n    String getStatus();\n\n    @SignalMethod\n    void retryNow();\n\n    @SignalMethod\n    void abandon();\n}\n```\n\nThe `@WorkflowMethod` annotation has a `name` parameter, for example: `@WorkflowMethod(name = \"YourWorkflowType\")`.\nIt can be used to denote the Workflow Type. If not set, the Workflow Type defaults to the short name of the Workflow interface,\nin the example above being `FileProcessingWorkflow`.\nMethods annotated with `@WorkflowMethod` can have any number of parameters.\nWe recommend passing a single parameter that contains all the input fields.\nThis allows adding fields in a backward compatible manner.\n\nThe `@QueryMethod` annotation also has a `name` parameter, for example: `@QueryMethod(name = \"history\")`. It can be\nused to denote the query name. If not set, the query name defaults to the name of the method, in the example above\nbeing `getStatus`.\n\nThe `@SignalMethod` too has a `name` parameter, for example: `@SignalMethod(name = \"mysignal\")`. It can be used to denote the\nsignal type. If not set, the signal type defaults to the name of the method, in the example above being `retryNow` and `abandon`.\n\n### Workflow Interface Inheritance\n\nWorkflow interfaces can form inheritance hierarchies. It may be useful for creating components reusable across multiple\nWorkflow interfaces. For example imaging a UI or CLI button that allows to call `retryNow` signal on any Workflow. To implement\nthis feature you can redesign the above interface to:\n\n```java\npublic interface Retryable {\n    @SignalMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface FileProcessingWorkflow extends Retryable {\n\n    @WorkflowMethod\n    String processFile(Arguments args);\n\n    @QueryMethod(name=\"history\")\n    List<String> getHistory();\n\n    @QueryMethod\n    String getStatus();\n\n    @SignalMethod\n    void abandon();\n}\n```\n\nThen some other Workflow interface can extend just `Retryable`, for example:\n\n```java\n@WorkflowInterface\npublic interface MediaProcessingWorkflow extends Retryable {\n\n    @WorkflowMethod\n    String processBlob(Arguments args);\n}\n```\n\nNow if we have two running Workflows, one that implements the `FileProcessingWorkflow` interface and another that implements the\n`MediaProcessingWorkflow` interface, we can signal to both using their common interface and knowing their workflowIds, for example:\n\n```java\nRetryable r1 = client.newWorkflowStub(Retryable.class, firstWorkflowId);\nRetryable r2 = client.newWorkflowStub(Retryable.class, secondWorkflowId);\nr1.retryNow();\nr2.retryNow();\n```\n\nThe same technique can be used to query Workflows using a base Workflow interface.\n\nNote that this approach does not apply to `@WorkflowMethod` annotations, meaning that when using a base interface, it should\nnot include any `@WorkflowMethod` methods.\nTo illustrate this, lets' say that we define the following **invalid** code:\n\n```java\n// INVALID CODE!\npublic interface BaseWorkflow {\n    @WorkflowMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface Workflow1 extends BaseWorkflow {}\n\n@WorkflowInterface\npublic interface Workflow2 extends BaseWorkflow {}\n```\n\nIf we attempt to register implementations of Workflow1 and Workflow2 with a Worker will fail. Let's say that we have:\n\n```java\nworker.registerWorkflowImplementationTypes(\n        Workflow1Impl.class, Workflow2Impl.class);\n```\n\nThis registration will fail with:\n\n```text\njava.lang.IllegalStateException: BaseWorkflow workflow type is already registered with the worker\n```\n\n## Implementing Workflows\n\nA Workflow implementation implements a Workflow interface. Each time a new Workflow Execution is started,\na new instance of the Workflow implementation object is created.\nThen, one of the methods\n(depending on which Workflow Type has been started) annotated with `@WorkflowMethod` can be invoked.\nAs soon as this method returns, the Workflow Execution is considered as completed.\n\nWorkflow methods annotated with `@QueryMethod` and `@SignalMethod` can be invoked during a Workflow's execution.\n\nNote that methods annotated with `@QueryMethod` can be invoked even when a Workflow is in the `Completed`\nstate.\n\n### Workflow Implementation Constraints\n\nTemporal uses the [Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover\nthe state of a Workflow object including its threads and local variable values.\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nNote that during replay, successfully executed Activities are not re-executed as their results are already recorded\nin the Workflow event history.\n\nEven though Temporal has the replay capability, which brings resilience to your Workflows, you should never think about\nthis capability when writing your Workflows.\nInstead, you should focus on implementing your business logic/requirements and write your Workflows\nas they would execute only once.\n\nThere are some things however to think about when writing your Workflows, namely determinism and isolation.\nWe summarize these constraints here:\n\nThey shouldn't use any constructs that rely on system time.\n\n- Do not use any mutable global variables in your Workflow implementations. This will assure that multiple Workflow instances are fully isolated.\n- Do not call any non-deterministic functions like non seeded random or UUID.randomUUID() directly from the Workflow code. The Temporal SDK provides specific API for calling non-deterministic code in your Workflows, which we will show later on in this document.\n- Perform all IO operations and calls to third-party services on Activities and not Workflows, as they are usually non-deterministic in nature.\n- Do not use any programming language constructs that rely on system time. For example, only use `Workflow.currentTimeMillis()` to get the current time inside a Workflow.\n- Do not use native Java `Thread` or any other multi-threaded classes like `ThreadPoolExecutor`. Use `Async.function` or `Async.procedure`,\n  provided by the Temporal SDK, to execute code asynchronously.\n- Don't use any synchronization, locks, and other standard Java blocking concurrency-related classes besides those provided\n  by the Workflow class. There is no need in explicit synchronization because multi-threaded code inside a Workflow is\n  executed one thread at a time and under a global lock.\n  - Call `Workflow.sleep` instead of `Thread.sleep`.\n  - Use `Promise` and `CompletablePromise` instead of `Future` and `CompletableFuture`.\n  - Use `WorkflowQueue` instead of `BlockingQueue`.\n- Use `Workflow.getVersion` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already running Workflows.\n- Don’t access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\n### Workflow Method Arguments\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n\nJava DataConverter reference: https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html\n\n## Workflow Activities\n\nTo learn about Workflow Activities visit [this page](/java/activities).\n\n## Child Workflows\n\nBesides Activities, a Workflow can also start other Workflows.\n\n<RelatedReadList\nreadlist={[\n[\"What is a Child Workflow Execution?\",\"/concepts/what-is-a-child-workflow-execution\",\"explanation\"],  \n]}\n/>\n\n### Java Child Workflow API\n\n`Workflow.newChildWorkflowStub` returns a client-side stub that implements a Child Workflow interface.\nIt takes a Child Workflow Type and optional Child Workflow options as arguments.\nWorkflow options can be used to set Timeouts, retry options, and Task Queue settings, for example.\nBy default, a Child Workflow inherits the Workflow options of its parent.\nYou can, however, overwrite these default options by passing in custom Workflow options when creating the Child Workflow stub.\n\nThe first call to the Child Workflow stub must always be its Workflow method (the method annotated with `@WorkflowMethod`).\n\nSimilar to Activities, invoking child Workflow methods can be made synchronous or asynchronous by using `Async#function` or `Async#procedure`.\nThe synchronous call blocks until a child Workflow method completes. The asynchronous call\nreturns a `Promise` that can be used to wait for the completion of the child Workflow method, for example:\n\n```java\nGreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\nPromise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n// ...\ngreeting.get()\n```\n\nNote that querying child Workflows from within the parent Workflow code is not supported. You can however\nquery child Workflows from Activities using `WorkflowClient`.\n\nFollowing are examples of using a child Workflow inside a Workflow:\n\n```java\n// Child Workflow interface\n@WorkflowInterface\npublic interface GreetingChild {\n   @WorkflowMethod\n   String composeGreeting(String greeting, String name);\n}\n// Child Workflow implementation not shown\n\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n   @Override\n   public String getGreeting(String name) {\n       GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n       // This is a blocking call that returns only after child has completed.\n       return child.composeGreeting(\"Hello\", name );\n   }\n}\n```\n\nRunning two children (with the same type) in parallel:\n\n```java\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n\n        // Workflows are stateful, so a new stub must be created for each new child.\n        GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting1 = Async.function(child1::composeGreeting, \"Hello\", name);\n\n        // Both children will run concurrently.\n        GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting2 = Async.function(child2::composeGreeting, \"Bye\", name);\n\n        // Do something else here.\n        ...\n        return \"First: \" + greeting1.get() + \", second: \" + greeting2.get();\n    }\n}\n```\n\nSending a signal to a child Workflow from the parent:\n\n```java\n// Child Workflow interface\n@WorkflowInterface\npublic interface GreetingChild {\n    @WorkflowMethod\n    String composeGreeting(String greeting, String name);\n\n    @SignalMethod\n    void updateName(String name);\n}\n\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n        GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n        child.updateName(\"Temporal\");\n        return greeting.get();\n    }\n}\n```\n\n### ParentClosePolicy\n\nWhen creating a Child Workflow, you can define a `ParentClosePolicy` that terminates, cancels, or abandons the Workflow Execution if the child's parent stops execution.\n\n- `ABANDON`: When the parent stops, don't do anything with the Child Workflow.\n- `TERMINATE`: When the parent stops, terminate the Child Workflow\n- `REQUEST_CANCEL`: When the parent stops, terminate the Child Workflow\n\nYou can set policies per child, which means you can opt out of propagating terminates / cancels on a per-child basis.\nThis is useful for starting Child Workflows asynchronously:\n\n```java\n   public void parentWorkflow() {\n       ChildWorkflowOptions options =\n          ChildWorkflowOptions.newBuilder()\n              .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)\n              .build();\n       MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, options);\n       Async.procedure(child::<workflowMethod>, <args>...);\n       Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(child);\n       // Wait for child to start\n       childExecution.get()\n  }\n```\n\n1. Set `ChildWorkflowOptions.ParentClosePolicy` to `ABANDON` when creating a Child Workflow stub.\n2. Start Child Workflow Execution asynchronously using `Async.function` or `Async.procedure`.\n3. Call `Workflow.getWorkflowExecution(…)` on the child stub\n4. Wait for the Promise returned by `getWorkflowExecution` to complete.\n   This indicates that the child successfully started (or start failed).\n5. Complete Parent Workflow Execution asynchronously\n\nSteps 3 and 4 are needed to ensure that a Child Workflow Execution starts before the parent closes.\nIf the parent initiates a Child Workflow Execution and then immediately completes, the child would never execute.\n\n## Starting Workflow Executions\n\nIn the Temporal Java SDK, Workflows can be started both synchronously and asynchronously.\nTo do either, you must initialize an instance of a `WorkflowClient`, create a client side Workflow stub,\nand then call a Workflow method (annotated with the `@WorkflowMethod` annotation).\n\n### Asynchronous start\n\nAn asynchronous start initiates a Workflow Execution and immediately returns to the caller.\nThis is the most common way to start Workflows in a live environment.\n\n<!--SNIPSTART money-transfer-project-template-java-workflow-initiator-->\n<!--SNIPEND-->\n\nIf you need to wait for the completion of a Workflow after an asynchronous start, the most straightforward way is to call the blocking Workflow instance again.\n\nIf `WorkflowOptions.WorkflowIdReusePolicy` is not set to `AllowDuplicate`, then instead of throwing `DuplicateWorkflowException`,\nit reconnects to an existing Workflow and waits for its completion.\n\nThe following example shows how to do this from a different process than the one that started the Workflow Execution.\n\n```java\nYourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflow.yourMethod();\n```\n\nAnother way to connect to an existing Workflow and wait for its completion from another process is to use `UntypedWorkflowStub`.\nFor example:\n\n```java\nWorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflowStub.getResult(String.class);\n```\n\n### Synchronous start\n\nA Synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the invocation process and will continue executing even if the waiting process crashes or was stopped.\n\n<!--SNIPSTART hello-world-project-template-java-workflow-initiator-->\n<!--SNIPEND-->\n\n### Recurring start\n\nYou can start a Workflow Execution on a regular schedule with [the CronSchedule option](distributed-cron).\n\n### External Workflows\n\nWorkflows can execute (and signal to) other workflows purely by name.\nThis helps particularly for executing workflows from other language SDKs.\nSee our [Temporal Polyglot example](https://github.com/tsurdilo/temporal-polyglot) for more.\n\n## Large Event Histories\n\nTemporal SDK allows you to manually use [Continue-As-New](/concepts/what-is-continue-as-new) in a number of ways:\n\nIf you are continuing execution of the same Workflow that is currently running, you can do the following:\n\n```java\nWorkflow.continueAsNew(input1, ...);\n```\n\nIt is also possible to continue execution as a completely different Workflow Type.\nIn a Workflow class called `YourWorkflow` for example, we can create a Workflow Stub with a different type and\ncall its Workflow method to continue execution as that type:\n\n```java\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class);\ncontinueAsNew.greet(input);\n```\n\n`Workflow.newContinueAsNewStub` also allows to provide `ContinueAsNewOptions` options, for example:\n\n```java\nContinueAsNewOptions options = ContinueAsNewOptions.newBuilder()\n        .setTaskQueue(\"newTaskQueueName\")\n        .build();\n\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class, options);\n// ...\ncontinueAsNew.greet(input);\n```\n\nThis allows you to continue Workflow Execution as a new Workflow run with a different Workflow Type and on a different Task Queue.\n\nAnother way to deal with the Event History size limits is to use Child Workflows; however,\nthey themselves could eventually, if long running, experience the same issue in which case you can again\napply the \"ContinueAsNew\" feature if needed.\n\n\"ContinueAsNew\" can also be used in [child Workflows](#child-workflows). Note that in this case the parent Workflow\nis not aware if its child Workflows called \"ContinueAsNew\". This way a child Workflow can call \"ContinueAsNew\" as many times\nas it needs, and the parent Workflow will get notified when the last run of the child Workflow completes or fails.\n\nIf you need to know whether a Workflow was started via `continueAsNew`, you can check `Workflow.getInfo().getContinuedExecutionRunId().isPresent()`.\n","is_empty":false},{"file_name":"cluster-plugins.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/security/cluster-plugins.md","id":"security/cluster-plugins","title":"Temporal Cluster plugins conceptual context","description":"Temporal Clusters support some pluggable components.","label":"Plugins","tags":["guide-context"],"markdown_content":"\nTemporal Clusters support some pluggable components.\n","is_empty":false},{"file_name":"how-to-authorize-sdk-api-calls.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/security/how-to-authorize-sdk-api-calls.md","id":"security/how-to-authorize-sdk-api-calls","title":"How to authorize SDK API calls","description":"When authentication is enabled, you can authorize API calls made to the Frontend Service.","label":"Authorize API calls","tags":["security","guide-context"],"markdown_content":"\nWhen authentication is enabled, you can authorize API calls made to the Frontend Service.\n","is_empty":false},{"file_name":"how-to-set-up-codec-server.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/security/how-to-set-up-codec-server.md","id":"security/how-to-set-up-codec-server","title":"How to set up a Codec Server","description":"Run a Codec Server with your Payload Codec and then configure tctl and the Web UI to use the server.","label":"Codec Server","tags":["security","how-to"],"markdown_content":"\nTo use a [Codec Server](/concepts/what-is-a-codec-server), first run it with your Payload Codec and then configure [tctl](/tctl-v1) and the [Web UI](/web-ui) to use it.\n\n### Run the server\n\nA Codec Server is an HTTP server that implements two endpoints:\n\n- `POST /encode`\n- `POST /decode`\n\nEach endpoint receives and responds with a JSON body that has a `payloads` property with an array of Payloads.\nThe endpoints run the Payloads through a [Payload Codec](/concepts/what-is-a-data-converter#payload-codecs) before returning them.\n\nSample Codec Servers:\n\n- [Go](https://github.com/temporalio/samples-go/tree/main/codec-server)\n- [Python](https://github.com/temporalio/samples-python/blob/main/encryption/codec_server.py)\n- [TypeScript](https://github.com/temporalio/samples-typescript/blob/main/encryption/src/codec-server.ts)\n\n### Configure tctl\n\nOnce the Codec Server is started, for example on `http://localhost:8888`, provide it to tctl using the `--codec_endpoint` global option:\n\n```bash\ntctl --codec_endpoint 'http://localhost:8888' workflow show --wid workflow-id-123\n```\n\n### Configure the Web UI\n\nOnce the Codec Server is started, there are two ways to provide it to the Web UI:\n\n#### In the UI\n\n![Data Encoder icon](/img/docs/data-encoder-button.png)\n\nSelect the icon with an up-down arrow on the bottom left of the screen.\nThis action displays the codec endpoint dialog.\n\nEnter the URL and port number for your codec endpoint.\nExit the dialog, go back to the previous page, and refresh the page.\n\nThe button should now be light blue, and your Payloads should be displayed in a readable format.\n\n#### In the config file\n\nThe codec endpoint can be specified in the [configuration file](/references/web-ui-configuration#codec):\n\n```yaml\ncodec:\n    endpoint: {{ default .Env.TEMPORAL_CODEC_ENDPOINT \"{namespace}\"}}\n```\n","is_empty":false},{"file_name":"intro.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/security/intro.md","id":"security/intro","title":"Temporal Platform security overview","description":"The security guide provides a comprehensive overview of the security related features and how to implement them.","tags":["security","guide-context"],"markdown_content":"\n:::info Work in progress\n\nThis guide is a work in progress. Some sections may be incomplete. Information may change at any time.\n\n:::\n\n:::info General company security\n\nFor information about the general security habits of Temporal Technologies see our [company security page](/temporal-technologies-inc-security).\n\n:::\n\nThe Temporal Plaform is designed with security in mind, and there are many features that you can use to keep both the Platform itself and your user's data secure.\n\nA secured Temporal Server has its network communication encrypted and has authentication and authorization protocols set up for API calls made to it.\nWithout these, your server could be accessed by unwanted entities.\n\nWhat is documented on this page are the built-in opt-in security measures that come with Temporal.\nHowever users may also choose to design their own security architecture with reverse proxies or run unsecured instances inside of a VPC environment.\n\n### Server Samples\n\nThe https://github.com/temporalio/samples-server repo offers two examples, which are further explained below:\n\n- **TLS**: how to configure Transport Layer Security (TLS) to secure network communication with and within a Temporal cluster.\n- **Authorizer**: how to inject a low-level authorizer component that can control access to all API calls.\n\n### Encryption in transit with mTLS\n\nTemporal supports Mutual Transport Layer Security (mTLS) as a way of encrypting network traffic between the services of a cluster and also between application processes and a Cluster.\nSelf-signed or properly minted certificates can be used for mTLS.\nmTLS is set in Temporal's [TLS configuration](/references/configuration/#tls).\nThe configuration includes two sections such that intra-Cluster and external traffic can be encrypted with different sets of certificates and settings:\n\n- `internode`: Configuration for encrypting communication between nodes in the cluster.\n- `frontend`: Configuration for encrypting the Frontend's public endpoints.\n\nA customized configuration can be passed using either the [WithConfig](/references/server-options#withconfig) or [WithConfigLoader](/references/server-options#withconfigloader) Server options.\n\nSee [TLS configuration reference](/references/configuration/#tls) for more details.\n\n### Authentication\n\nThere are a few authentication protocols available to prevent unwanted access such as authentication of servers, clients, and users.\n\n### Servers\n\nTo prevent spoofing and [MITM attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) you can specify the `serverName` in the `client` section of your respective mTLS configuration.\nThis enables established connections to authenticate the endpoint, ensuring that the server certificate presented to any connecting Client has the appropriate server name in its CN property.\nIt can be used for both `internode` and `frontend` endpoints.\n\nMore guidance on mTLS setup can be found in [the `samples-server` repo](https://github.com/temporalio/samples-server/tree/main/tls) and you can reach out to us for further guidance.\n\n### Client connections\n\nTo restrict a client's network access to cluster endpoints you can limit it to clients with certificates issued by a specific Certificate Authority (CA).\nUse the `clientCAFiles`/ `clientCAData` and `requireClientAuth` properties in both the `internode` and `frontend` sections of the [mTLS configuration](/references/configuration/#tls).\n\n### Users\n\nTo restrict access to specific users, authentication and authorization is performed through extensibility points and plugins as described in the [Authorization](#authorization) section below.\n\n#### Authorization\n\n:::note\nInformation regarding [`Authorizer`](/concepts/what-is-an-authorizer-plugin) and [`ClaimMapper`](/concepts/what-is-a-claimmapper-plugin) has been moved to another location.\n:::\n\nTemporal offers two plugin interfaces for implementing API call authorization:\n\n- [`ClaimMapper`](/concepts/what-is-a-claimmapper-plugin)\n- [`Authorizer`](/concepts/what-is-an-authorizer-plugin)\n\nThe authorization and claim mapping logic is customizable, making it available to a variety of use cases and identity schemes.\nWhen these are provided the frontend invokes the implementation of these interfaces before executing the requested operation.\n\nSee https://github.com/temporalio/samples-server/blob/main/extensibility/authorizer for a sample implementation.\n\n![](/img/docs/frontend-authorization-order-of-operations.png)\n\n### Single sign-on integration\n\nTemporal can be integrated with a single sign-on (SSO) experience by utilizing the `ClaimMapper` and `Authorizer` plugins.\nThe default JWT `ClaimMapper` implementation can be used as is or as a base for a custom implementation of a similar plugin.\n\n#### Temporal Web\n\nTo enable SSO for the Temporal Web UI edit the web service's configuration per the [Temporal Web README](https://github.com/temporalio/web#configuring-authentication-optional).\n","is_empty":false},{"file_name":"api-reference-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/api-reference-python.md","id":"python/api-reference-python","title":"API reference","label":"API reference","markdown_content":"\nThe Temporal Python SDK API reference is published on [python.temporal.io](https://python.temporal.io/index.html).\n","is_empty":false},{"file_name":"code-samples-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/code-samples-python.md","id":"python/code-samples-python","title":"Code samples","label":"Code samples","markdown_content":"\n- [Python samples library](https://github.com/temporalio/samples-python)\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python.md","id":"python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python","title":"How to set custom Search Attributes in Python","description":"To set custom Search Attributes, use the `search_attributes` parameter of 'start_workflow()'.","label":"Set custom Search Attributes","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo set custom Search Attributes, use the `search_attributes` parameter of the ['start_workflow()'](https://python.temporal.io/temporalio.client.Client.html#start_workflow) method.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    search_attributes={\"Your-Custom-Keyword-Field\": [\"value\"]},\n)\n```\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-configure-tracing-in-python.md","id":"python/how-to-configure-tracing-in-python","title":"How to configure tracing in Python","description":"To configure tracing in Python, install the `opentelemetry` dependencies.","label":"Configure tracing","tags":["python","how-to"],"markdown_content":"\nTo configure tracing in Python, install the `opentelemetry` dependencies.\n\n```bash\n# This command installs the `opentelemetry` dependencies.\npip install temporalio[opentelemetry]\n```\n\nThen the [`temporalio.contrib.opentelemetry.TracingInterceptor`](https://python.temporal.io/temporalio.contrib.opentelemetry.TracingInterceptor.html) class can be set as an interceptor as an argument of [`Client.connect()`](https://python.temporal.io/temporalio.client.Client.html#connect).\n\nWhen your Client is connected, spans are created for all Client calls, Activities, and Workflow invocations on the Worker.\nSpans are created and serialized through the server to give one trace for a Workflow Execution.\n","is_empty":false},{"file_name":"how-to-connect-to-a-cluster-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-connect-to-a-cluster-in-python.md","id":"python/how-to-connect-to-a-cluster-in-python","title":"How to connect to a Temporal Cluster in Python","description":"Connect a Temporal Client to a Cluster in the Python SDK.","label":"Connect a Temporal Client","tags":["developer-guide","sdk","python"],"markdown_content":"\nUse the [`connect()`](https://python.temporal.io/temporalio.client.client#connect) method on the [`Client`](https://python.temporal.io/temporalio.client.client) class to create and connect to a Temporal Client to the Temporal Cluster.\n\nSpecify the `target_host` parameter as a string and provide the [`tls` configuration](https://python.temporal.io/temporalio.service.TLSConfig.html) for connecting to a Temporal Cluster.\n\n```python\nclient = await Client.connect(\n    #  target_host for the Temporal Cloud\n    \"your-custom-namespace.tmprl.cloud:7233\",\n    # target_host for Temporalite\n    # \"127.0.0.1:7233\"\n    namespace=\"your-custom-namespace\",\n    tls=TLSConfig(\n        client_cert=client_cert,\n        client_private_key=client_private_key,\n        # domain=domain\n        # server_root_ca_cert=server_root_ca_cert,\n    ),\n)\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-continue-as-new-in-python.md","id":"python/how-to-continue-as-new-in-python","title":"How to Continue-As-New in Python","description":"Continue-As-New","label":"Continue-As-New","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo Continue-As-New in Python, call the [`continue_as_new()`](https://python.temporal.io/temporalio.workflow.html#continue_as_new) function from inside your Workflow, which will stop the Workflow immediately and Continue-As-New.\n\n```python\nworkflow.continue_as_new(\"your-workflow-name\")\n```\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-create-a-temporal-client-in-python.md","id":"python/how-to-create-a-temporal-client-in-python","title":"How to create a Temporal Client in Python","description":"Create a Temporal Client","label":"Create a Temporal Client","tags":["developer-guide","sdk","python"],"markdown_content":"\nUse [`connect()`](https://python.temporal.io/temporalio.client.Client.html#connect) method on the [`Client`](https://python.temporal.io/temporalio.client.Client.html) class to create and connect to a Temporal Server at a given address and Namespace.\n\nSpecify the `target_host` parameter as a string.\n\n**Connect to Docker**\n\n```python\nawait Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n```\n\n**Connect to your Cluster**\n\n```python\nawait Client.connect(\n    \"web.<Namespace_ID>.tmprl.cloud\", namespace=\"your-custom-namespace\"\n)\n```\n\nA `Client` does not have an explicit close.\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-customize-activity-type-in-python.md","id":"python/how-to-customize-activity-type-in-python","title":"How to customize Activity Type in Python","description":"Customize your Activity Type.","label":"Customize Activity Type","tags":["developer-guide","sdk","python"],"markdown_content":"\nYou can customize the Activity name with a custom name in the decorator argument. For example, `@activity.defn(name=\"your-activity\")`. If the name parameter is not specified, the Activity name defaults to the function name.\n\n```python\n@activity.defn(name=\"your-activity\")\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-customize-workflow-type-in-python.md","id":"python/how-to-customize-workflow-type-in-python","title":"How to customize Workflow types in Python","description":"Customize Workflow types.","label":"Customize Workflow types","tags":["developer-guide","sdk","python"],"markdown_content":"\nYou can customize the Workflow name with a custom name in the decorator argument. For example, `@workflow.defn(name=\"your-workflow-name\")`. If the name parameter is not specified, the Workflow name defaults to the function name.\n\n```python\n@workflow.defn(name=\"your-workflow-name\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-define-a-query-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-define-a-query-in-python.md","id":"python/how-to-define-a-query-in-python","title":"How to define a Query in Python","description":"Define a Query","label":"Define a Query","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo define a Query, set the Query decorator [`@workflow.query`](https://python.temporal.io/temporalio.workflow.html#query) on the Query function inside your Workflow.\n\n```python\n@workflow.query\nasync def current_greeting(self) -> str:\n    return self._current_greeting\n```\n\nThe [`@workflow.query`](https://python.temporal.io/temporalio.workflow.html#query) decorator defines a method as a Query. Queries can be asynchronous or synchronous methods and can be inherited; however, if a method is overridden, the override must also be decorated. Queries should return a value.\n\n**Dynamic Queries**\n\nYou can use `@workflow.query(dynamic=True)`, which means all other unhandled Queries fall through to this.\n\n```python\n@workflow.query(dynamic=True)\ndef query_dynamic(self, name: str, *args: Any) -> str:\n    return f\"query_dynamic {name}: {args[0]}\"\n```\n\n**Customize names**\n\nYou can have a name parameter to customize the Query's name, otherwise it defaults to the unqualified method `__name__`.\n\nThe following example sets a custom Query name.\n\n```python\n@workflow.query(name=\"Custom-Name\")\ndef query(self, arg: str) -> None:\n    self._last_event = f\"query: {arg}\"\n```\n\n:::note\n\nYou can either set the `name` or the `dynamic` parameter in a Query's decorator, but not both.\n\n:::\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-define-a-signal-in-python.md","id":"python/how-to-define-a-signal-in-python","title":"How to define a Signal in Python","description":"Define a Signal","label":"Define a Signal","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo define a Signal, set the Signal decorator [`@workflow.signal`](https://python.temporal.io/temporalio.workflow.html#signal) on the Signal function inside your Workflow.\n\n```python\n@workflow.signal\ndef your_signal(self, value: str) -> None:\n    self._signal = value\n```\n\nThe [`@workflow.signal`](https://python.temporal.io/temporalio.workflow.html#signal) decorator defines a method as a Signal. Signals can be asynchronous or synchronous methods and can be inherited; however, if a method is overridden, the override must also be decorated.\n\n**Dynamic Signals**\n\nYou can use `@workflow.signal(dynamic=True)`, which means all other unhandled Signals fall through to this.\n\nYour method parameters must be `self`, a string Signal name, and a `*args` variable argument parameter.\n\n```python\n@workflow.signal(dynamic=True)\ndef signal_dynamic(self, name: str, *args: Any) -> None:\n    self._last_event = f\"signal_dynamic {name}: {args[0]}\"\n```\n\n**Customize name**\n\nNon-dynamic methods can only have positional arguments. Temporal suggests taking a single argument that is an\nobject or data class of fields that can be added to as needed.\n\nReturn values from Signal methods are ignored.\n\nYou can have a name parameter to customize the Signal's name, otherwise it defaults to the unqualified method `__name__`.\n\nThe following example sets a custom Signal name.\n\n```python\n@workflow.signal(name=\"Custom-Name\")\ndef signal(self, arg: str) -> None:\n    self._last_event = f\"signal: {arg}\"\n```\n\n:::note\n\nYou can either set the `name` or the `dynamic` parameter in a Signal's decorator, but not both.\n\n:::\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-define-activity-parameters-in-python.md","id":"python/how-to-define-activity-parameters-in-python","title":"How to define Activity Parameters in Python","description":"Activities can support many custom parameters.","label":"Activity Parameters","tags":["developer-guide","python"],"markdown_content":"\nActivity parameters are the function parameters of the function decorated with `@activity.defn`.\nThese can be any data type Temporal can convert, including [`dataclasses`](https://docs.python.org/3/library/dataclasses.html) when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single `dataclass` parameter containing all input fields.\n\n```python\n@dataclass\nclass YourParams:\n    your_int_param: int\n    your_str_param: str\n\n\n@activity.defn\nasync def your_activity(params: YourParams) -> None:\n    ...\n```\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-define-activity-return-values-in-python.md","id":"python/how-to-define-activity-return-values-in-python","title":"How to define Activity return values in Python","description":"Activity return values","label":"Activity return values","tags":["developer-guide","python"],"markdown_content":"\nAn Activity Execution can return inputs and other Activity values.\n\nThe following example defines an Activity that takes a string as input and returns a string.\n\n```python\n@activity.defn\nasync def say_hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-define-workflow-parameters-in-python.md","id":"python/how-to-define-workflow-parameters-in-python","title":"How to define Workflow parameters","description":"Define Workflow parameters","label":"Define Workflow parameters","tags":["developer-guide","sdk","python"],"markdown_content":"\nWorkflow parameters are the method parameters of the singular method decorated with `@workflow.run`.\nThese can be any data type Temporal can convert, including [`dataclasses`](https://docs.python.org/3/library/dataclasses.html) when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single `dataclass` parameter containing all input fields.\n\n```python\n@dataclass\nclass YourParams:\n    your_int_param: int\n    your_str_param: str\n\n\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, params: YourParams) -> None:\n        ...\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-define-workflow-return-values-in-python.md","id":"python/how-to-define-workflow-return-values-in-python","title":"How to define Workflow return values","description":"Define Workflow return values","label":"Define Workflow return values","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo return a value of the Workflow, use `return` to return an object.\n\nTo return the results of a Workflow Execution, use either [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods.\n\n```python\n@dataclass\nclass YourResult:\n    your_int_param: int\n    your_str_param: str\n\n\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, params: YourResult) -> None:\n      return YourResult\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-develop-a-worker-program-in-python.md","id":"python/how-to-develop-a-worker-program-in-python","title":"How to develop a Worker Program in Python","description":"Create a new instance of a Worker.","label":"Worker Program","tags":["developer-guide","python","workers"],"markdown_content":"\nTo develop a Worker, use the [`Worker()`](https://python.temporal.io/temporalio.worker.Worker.html#__init__) constructor and add your Client, Task Queue, Workflows, and Activities as arguments.\n\nThe following code example creates a Worker that polls for tasks from the Task Queue and executes the Workflow.\n\n```python\nworker = Worker(\n    client,\n    task_queue=\"your-task-queue\",\n    workflows=[YourWorkflow],\n    activities=[your_activity],\n)\n```\n\nThe following code example shows a Worker hosting Workflows and Activities.\n\n```python\nasync def run_worker(stop_event: asyncio.Event):\n    # Create Client connected to server at the given address\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    # Run the worker until the event is set\n    worker = Worker(\n        client,\n        task_queue=\"your-task-queue\",\n        workflows=[YourWorkflow],\n        activities=[your_activity],\n    )\n    async with worker:\n        await stop_event.wait()\n```\n\nThe `asyncio.Event` that will be set when the Worker should stop.\nAlthough this example accepts a stop event and uses `async with`, you can also use [`run()`](https://python.temporal.io/temporalio.worker.Worker.html#run) and [`shutdown()`](https://python.temporal.io/temporalio.worker.Worker.html#shutdown).\nThe `shutdown()` operation waits on all Activities to complete, so if a long-running Activity does not at least respect cancellation, the shutdown might never complete.\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-develop-a-workflow-definition-in-python.md","id":"python/how-to-develop-a-workflow-definition-in-python","title":"How to develop a Workflow Definition in Python","description":"To develop a Workflow Definition, specify the `@workflow.defn` decorator on the Workflow class and use `@workflow.run` to mark the entry point.","label":"Develop a Workflow Definition","tags":["developer-guide","sdk","python"],"markdown_content":"\nIn the Temporal Python SDK programming model, Workflows are defined as classes.\n\nSpecify the [`@workflow.defn`](https://python.temporal.io/temporalio.workflow.html#defn) decorator on the Workflow class to identify a Workflow.\n\nUse the [`@workflow.run`](https://python.temporal.io/temporalio.workflow.html#run) to mark the entry point method to be invoked.\nThis must be set on one asynchronous method defined on the same class as `@workflow.defn`.\nRun methods have positional parameters.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-develop-an-activity-definition-in-python.md","id":"python/how-to-develop-an-activity-definition-in-python","title":"How to develop an Activity Definition in Python","description":"Develop an Activity Definition","label":"Develop an Activity Definition","tags":["developer-guide","sdk","python"],"markdown_content":"\nYou can develop an Activity Definition by using the [`@activity.defn`](https://python.temporal.io/temporalio.activity.html#defn) decorator.\n\n```python\n@activity.defn\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\nYou can register the function as an Activity with a custom name through a decorator argument. For example, `@activity.defn(name=\"your-activity\")`.\n\n```python\n@activity.defn(name=\"your-activity\")\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n**Types of Activities**\n\nThe following lists the different types of _Activity callables_:\n\n- [Asynchronous Activities](#asynchronous-activities)\n- [Synchronous Activities](#synchronous-activities)\n\n:::note Positional arguments\n\nOnly positional arguments are supported by Activities.\n\n:::\n\n##### [Asynchronous Activities](#asynchronous-activities)\n\nAsynchronous Activities (recommended) are functions using `async def`. When using asynchronous Activities there aren't any additional Worker parameters needed.\n\nCancellation for asynchronous activities is done by means of the\n[`asyncio.Task.cancel`](https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel) operation. This means that `asyncio.CancelledError` will be raised (and can be caught, but it is not recommended).\n\nAn Activity must Heartbeat to receive cancellation.\n\n##### [Synchronous Activities](#synchronous-activities)\n\nThe [`activity_executor`](https://python.temporal.io/temporalio.worker.WorkerConfig.html#activity_executor) Worker parameter must be set with a [`concurrent.futures.Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor) instance to use for executing the Activities.\n\nCancellation for synchronous Activities is done in the background and the Activity must choose to listen for it and react appropriately.\n\nAn Activity must Heartbeat to receive cancellation.\n\n- ###### [Synchronous Multithreaded Activities](#synchronous-multithreaded-activities)\n\nMultithreaded Activities are functions that use `activity_executor` set to an instance of [`concurrent.futures.ThreadPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor).\n\nBesides `activity_executor`, no other additional Worker parameters are required for synchronous multithreaded Activities.\n\n- ###### [Synchronous Multiprocess/Other Activities](#synchronous-multiprocess)\n\nIf `activity_executor` is set to an instance of [`concurrent.futures.Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor) that is not `concurrent.futures.ThreadPoolExecutor`, then the synchronous activities are considered multiprocess/other activities.\n\nThese require special primitives for heartbeating and cancellation. The `shared_state_manager` Worker parameter must be set to an instance of [`worker.SharedStateManager`](https://python.temporal.io/temporalio.worker.SharedStateManager.html). The most common implementation can be created by passing a [`multiprocessing.managers.SyncManager`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.SyncManager) (for example, as a result of [`multiprocessing.managers.Manager()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Manager)) to [`worker.SharedStateManager.create_from_multiprocessing()`](https://python.temporal.io/temporalio.worker.SharedStateManager.html#create_from_multiprocessing).\n","is_empty":false},{"file_name":"how-to-emit-metrics-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-emit-metrics-in-python.md","id":"python/how-to-emit-metrics-in-python","title":"How to emit metrics in Python","description":"Metrics are configured globally be setting a Prometheus endpoint before any other Temporal code.","label":"Emit metrics","tags":["developer-guide","sdk","python"],"markdown_content":"\nMetrics in Python are configured globally; therefore, you should set a Prometheus endpoint before any other Temporal code.\n\nThe following example exposes a Prometheus endpoint on port `9000`.\n\n```python\nfrom temporalio.bridge.telemetry import (\n    init_telemetry,\n    TelemetryConfig,\n    PrometheusMetricsConfig,\n)\n\ninit_telemetry(\n    TelemetryConfig(\n        prometheus_metrics=PrometheusMetricsConfig(bind_address=\"0.0.0.0:9000\")\n    )\n)\n```\n\n<!-- https://github.com/temporalio/sdk-python/issues/125 -->\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-get-the-result-of-a-workflow-execution-in-python.md","id":"python/how-to-get-the-result-of-a-workflow-execution-in-python","title":"How to get the result of a Workflow Execution in python","description":"Workflow Execution result","label":"Workflow Execution result","tags":["developer-guide","python"],"markdown_content":"\nUse [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.Client.html#get_workflow_handle) to return a Workflow handle.\nThen use the [`result`](https://python.temporal.io/temporalio.client.workflowhandle#result) method to await on the result of the Workflow.\n\n```python\nhandle = await client.start_workflow(\n    YourWorkflow.run, \"some arg\", id=\"your-workflow-id\", task_queue=\"your-task-queue\"\n)\n\n# Wait for result\nresult = await handle.result()\nprint(f\"Result: {result}\")\n```\n\nTo get a handle for an existing Workflow by its Id, you can use [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.Client.html#get_workflow_handle), or use [`get_workflow_handle_for()`](https://python.temporal.io/temporalio.client.Client.html#get_workflow_handle_for) for type safety.\n\nThen use [`describe()`](https://python.temporal.io/temporalio.client.workflowhandle#describe) to get the current status of the Workflow.\nIf the Workflow does not exist, this call fails.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-get-the-result-of-an-activity-execution-in-python.md","id":"python/how-to-get-the-result-of-an-activity-execution-in-python","title":"How to get the result of an Activity Execution in Python","description":"Get the result of an Activity Execution","label":"Get the result of an Activity Execution","tags":["developer-guide","sdk","python"],"markdown_content":"\nUse [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) to start an Activity and return its handle, [`ActivityHandle`](https://python.temporal.io/temporalio.workflow.ActivityHandle.html). Use [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) to return the results.\n\nYou must provide either `schedule_to_close_timeout` or `start_to_close_timeout`.\n\n`execute_activity()` is a shortcut for `await start_activity()`. An asynchronous `execute_activity()` helper is provided which takes the same arguments as `start_activity()` and `await`s on the result. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-handle-a-query-in-a-workflow-in-python.md","id":"python/how-to-handle-a-query-in-a-workflow-in-python","title":"How to handle a Query in a Workflow","description":"To send a Query to a Workflow, use the `query` method from the `WorkflowHandle` class.","label":"Handle a Query in a Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo send a Query to the Workflow, use the [`query`](https://python.temporal.io/temporalio.client.WorkflowHandle.html#query) method from the [`WorkflowHandle`](https://python.temporal.io/temporalio.client.WorkflowHandle.html) class.\n\n```python\nawait handle.query(\"some query\")\n```\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-a-workflow-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-handle-a-signal-in-a-workflow-in-python.md","id":"python/how-to-handle-a-signal-in-a-workflow-in-python","title":"How to handle a Signal in a Workflow","description":"Handle a Signal in a Workflow","label":"Handle a Signal in a Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo send a Signal to the Workflow, use the [`signal`](https://python.temporal.io/temporalio.client.workflowhandle#signal) method from the [`WorkflowHandle`](https://python.temporal.io/temporalio.client.workflowhandle) class.\n\n```python\nawait handle.signal(\"some signal\")\n```\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-handle-workflow-logic-requirements-in-python.md","id":"python/how-to-handle-workflow-logic-requirements-in-python","title":"How to handle Workflow logic requirements in Python","description":"Handle Workflow logic requirements","label":"Handle Workflow logic requirements","tags":["developer-guide","sdk","python"],"markdown_content":"\nWorkflow code must be deterministic. This means:\n\n- no threading\n- no randomness\n- no external calls to processes\n- no network I/O\n- no global state mutation\n- no system date or time\n\nAll API safe for Workflows used in the [`temporalio.workflow`](https://python.temporal.io/temporalio.workflow.html) must run in the implicit [`asyncio` event loop](https://docs.python.org/3/library/asyncio-eventloop.html) and be _deterministic_.\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-heartbeat-an-activity-in-python.md","id":"python/how-to-heartbeat-an-activity-in-python","title":"How to heartbeat an Activity in Python","description":"Heartbeat an Activity","label":"Heartbeat an Activity","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo Heartbeat an Activity Execution in Python, use the [`heartbeat()`](https://python.temporal.io/temporalio.activity.html#heartbeat) API.\n\n```python\n@activity.defn\nasync def your_activity_definition() -> str:\n    activity.heartbeat(\"heartbeat details!\")\n```\n\nIn addition to obtaining cancellation information, Heartbeats also support detail data that persists on the server for retrieval during Activity retry.\nIf an Activity calls `heartbeat(123, 456)` and then fails and is retried, `heartbeat_details` returns an iterable containing `123` and `456` on the next Run.\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-log-from-a-workflow-in-python.md","id":"python/how-to-log-from-a-workflow-in-python","title":"How to log from a Workflow in Python","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"\nYou can log from a Workflow using Python's standard library, by importing the logging module `import logging`.\n\nSet your logging configuration to a level you want to expose logs to.\nThe following example sets the logging information level to `INFO`.\n\n```python\nlogging.basicConfig(level=logging.INFO)\n```\n\nThen in your Workflow, set your [`logger`](https://python.temporal.io/temporalio.workflow.html#logger) and level on the Workflow. The following example logs the Workflow.\n\n```python\n@workflow.defn\nclass SayHelloWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        workflow.logger.info(f\"Running workflow with parameter {name}\")\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=10)\n        )\n```\n\nThe following is an example output:\n\n```\nINFO:temporalio.workflow:Running workflow with parameter Temporal ({'attempt': 1, 'your-custom-namespace': 'default', 'run_id': 'your-run-id', 'task_queue': 'your-task-queue', 'workflow_id': 'your-workflow-id', 'workflow_type': 'SayHelloWorkflow'})\n```\n\n:::note\n\nLogs are skipped during replay by default.\n\n:::\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-register-types-with-a-worker-in-python.md","id":"python/how-to-register-types-with-a-worker-in-python","title":"How to register types with a Worker in Python","description":"Register types with a Worker","label":"Register types with a Worker","tags":["developer-guide","sdk","python"],"markdown_content":"\nWhen a `Worker` is created, it accepts a list of Workflows in the `workflows` parameter, a list of Activities in the `activities` parameter, or both.\n\n```python\nworker = Worker(\n    client,\n    task_queue=\"your-task-queue\",\n    workflows=[YourWorkflow1, YourWorkflow2],\n    activities=[your_activity_1, your_activity_2],\n)\n```\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-remove-search-attributes-from-a-workflow-in-python.md","id":"python/how-to-remove-search-attributes-from-a-workflow-in-python","title":"How to remove Search Attributes in Python","description":"To remove a Search Attribute, use `upsert_search_attributes()` with an empty list as its value.","label":"Remove Search Attributes","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo remove a Search Attribute, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) function with an empty list as its value.\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": []})\n```\n","is_empty":false},{"file_name":"how-to-replay-a-workflow-execution-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-replay-a-workflow-execution-in-python.md","id":"python/how-to-replay-a-workflow-execution-in-python","title":"How to replay a Workflow Execution in Python","description":"To replay a Workflow Execution, use the `replay_workflow()` method and pass a Workflow History as an argument.","label":"Replay a Workflow Execution","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo replay a Workflow Execution, use the [`replay_workflow()`](https://python.temporal.io/temporalio.worker.Replayer.html#replay_workflow) method and pass a Workflow History as an argument.\n\nIn the following example, `history_json_str` references the Workflow History as a JSON string.\n\n```python\nasync def run_replayer(history_json_str: str):\n    replayer = Replayer(workflows=[YourWorkflow])\n    await replayer.replay_workflow(history_json_str)\n```\n\nIf the Workflow History is non-deterministic, `run_replayer()` raises an error.\n\n:::note\n\nIf the Workflow History is exported by [Temporal Web UI](/web-ui) or through [tctl](/tctl-v1), you can pass the JSON file history object as a JSON string or as a Python dictionary through the `json.load()` function, which takes a file object and returns the JSON object.\n\n:::\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-execution-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-send-a-query-to-a-workflow-execution-in-python.md","id":"python/how-to-send-a-query-to-a-workflow-execution-in-python","title":"How to send a Query to a Workflow Execution in Python","description":"Use the `query` method to send a Query.","label":"Sending Queries","tags":["python","how-to"],"markdown_content":"\nTo send a Query to a Workflow Execution from Client code, use the `query()` method on the Workflow handle.\n\n```python\nawait my_workflow_handle.query(MyWorkflow.my_query, \"my query arg\")\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-send-a-signal-from-a-client-in-python.md","id":"python/how-to-send-a-signal-from-a-client-in-python","title":"How to send a Signal from a Client in Python","description":"To send a Signal to a Workflow Execution from Client code, use the signal() method on the Workflow handle.","label":"Send a Signal from a Client","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo send a Signal to a Workflow Execution from Client code, use the [`signal()`](https://python.temporal.io/temporalio.workflow.html#signal) method on the Workflow handle.\n\n```python\nawait my_workflow_handle.signal(MyWorkflow.my_signal, \"my signal arg\")\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-send-a-signal-from-a-workflow-in-python.md","id":"python/how-to-send-a-signal-from-a-workflow-in-python","title":"How to Send a Signal from a Workflow in Python","description":"Use `get_external_workflow_handle_for` to get a typed Workflow handle to an existing Workflow by its identifier.","label":"Send Signal from Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"\nUse [`get_external_workflow_handle_for`](https://python.temporal.io/temporalio.workflow.html#get_external_workflow_handle_for) to get a typed Workflow handle to an existing Workflow by its identifier. Use [`get_external_workflow_handle`](https://python.temporal.io/temporalio.workflow.html#get_external_workflow_handle) when you don't know the type of the other Workflow.\n\n```python\n@workflow.defn\nclass MyWorkflow:\n    @workflow.run\n    async run(self) -> None:\n        handle = workflow.get_external_workflow_handle_for(OtherWorkflow.run, \"other-workflow-id\")\n        await handle.signal(OtherWorkflow.other_signal, \"other signal arg\")\n```\n\n:::note\n\nThe Workflow Type passed is only for type annotations and not for validation.\n\n:::\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-send-a-signal-with-start-in-python.md","id":"python/how-to-send-a-signal-with-start-in-python","title":"How to send a Signal-With-Start in Python","description":"Signal-With-Start","label":"Signal-With-Start","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo send a Signal-With-Start in Python, use the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) method and pass the `start_signal` argument with the name of your Signal, instead of using a traditional Workflow start.\n\n```python\nasync def main():\n    client = await Client.connect(\"localhost:7233\", namespace=\"your-namespace\")\n\n    handle = await client.start_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n        start_signal=\"your-signal-name\",\n    )\n```\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-a-cron-schedule-in-python.md","id":"python/how-to-set-a-cron-schedule-in-python","title":"How to set a Cron Schedule in Python","description":"Set a Cron Scheduler in Python","label":"Cron Schedule","tags":["python","how-to"],"markdown_content":"\nYou can set each Workflow to repeat on a schedule with the `cron_schedule` option from either the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods:\n\n```python\nawait client.start_workflow(\n    \"your_workflow_name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    cron_schedule=\"* * * * *\",\n)\n```\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-a-custom-logger-in-python.md","id":"python/how-to-set-a-custom-logger-in-python","title":"How to set a custom Logger in Python","description":"Use the built-in Logging facility for Python.","label":"Custom Logger","tags":["python","how-to"],"markdown_content":"\nUse the built-in [Logging facility for Python](https://docs.python.org/3/library/logging.html) to set a custom logger.\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-a-heartbeat-timeout-in-python.md","id":"python/how-to-set-a-heartbeat-timeout-in-python","title":"How to set a Heartbeat Timeout in Python","description":"Set a Heartbeat Timeout","label":"Set a Heartbeat Timeout","tags":["developer-guide","sdk","python"],"markdown_content":"\n[`heartbeat_timeout`](https://python.temporal.io/temporalio.worker.StartActivityInput.html#heartbeat_timeout) is a class variable for the [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) function used to set the maximum time between Activity Heartbeats.\n\n```python\nworkflow.start_activity(\n    activity=\"your-activity\",\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n```python\nworkflow.execute_activity(\n    activity=\"your-activity\",\n    name,\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-a-parent-close-policy-in-python.md","id":"python/how-to-set-a-parent-close-policy-in-python","title":"How to set a Parent Close Policy in Python","description":"Create an instance of the `ParentClosePolicy` class.","label":"Parent Close Policy","tags":["python","developer-guide","how-to"],"markdown_content":"\nSet the `parent_close_policy` parameter inside the [`start_child_workflow`](https://python.temporal.io/temporalio.workflow.html#start_child_workflow) function or the [`execute_child_workflow()`](https://python.temporal.io/temporalio.workflow.html#execute_child_workflow) function to specify the behavior of the Child Workflow when the Parent Workflow closes.\n\n```python\nasync def run(self, name: str) -> str:\n    return await workflow.execute_child_workflow(\n        ComposeGreeting.run,\n        ComposeGreetingInput(\"Hello\", name),\n        id=\"hello-child-workflow-workflow-child-id\",\n        parent_close_policy=TERMINATE,\n    )\n```\n\n:::note\n\n`execute_child_workflow()` is a shortcut function for `temporalio.workflow.start_child_workflow()` plus `handle.result()`.\n\n:::\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-a-schedule-to-close-timeout-in-python.md","id":"python/how-to-set-a-schedule-to-close-timeout-in-python","title":"How to set a schedule to close timeout in Python","description":"Set a schedule to close timeout","label":"Set a schedule to close timeout","tags":["developer-guide","sdk","python"],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code example sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_close_timeout` to 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-a-schedule-to-start-timeout-in-python.md","id":"python/how-to-set-a-schedule-to-start-timeout-in-python","title":"How to set a schedule to start timeout in Python","description":"Set a schedule to start timeout","label":"Set a schedule to start timeout","tags":["developer-guide","sdk","python"],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_start_timeout` to 1 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            name,\n            schedule_to_close_timeout=5000,\n            schedule_to_start_timeout=1000,\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-a-start-to-close-timeout-in-python.md","id":"python/how-to-set-a-start-to-close-timeout-in-python","title":"How to set a start to close timeout in Python","description":"Set a start to close timeout","label":"Set a start to close timeout","tags":["developer-guide","sdk","python"],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\n```python\nstart_to_close_timeout = timedelta(seconds=5)\n```\n\nThe following code example executes an Activity with a `start_to_close_timeout` of 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-a-workflow-id-in-python.md","id":"python/how-to-set-a-workflow-id-in-python","title":"How to set a Workflow Id in Python","description":"Set a Workflow Id","label":"Set a Workflow Id","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo set a Workflow Id in Python, specify the `id` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) methods.\n\nThe `id` argument should be a unique identifier for the Workflow Execution.\n\n```python\nresult = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-a-workflow-task-queue-in-python.md","id":"python/how-to-set-a-workflow-task-queue-in-python","title":"How to set the Task Queue for Workflow Execution in Python","description":"Task Queue","label":"Task Queue","tags":["python","how-to"],"markdown_content":"\nTo set a Task Queue in Python, specify the `task_queue` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) methods.\n\n```python\nresult = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-activity-timeouts-in-python.md","id":"python/how-to-set-activity-timeouts-in-python","title":"How to set Activity Timeouts in Python","description":"Set Activity Timeouts","label":"Set Activity Timeouts","tags":["developer-guide","sdk","python"],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments.\n\nAvailable timeouts are:\n\n- schedule_to_close_timeout\n- schedule_to_start_timeout\n- start_to_close_timeout\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            name,\n            schedule_to_close_timeout=timedelta(seconds=5),\n            # schedule_to_start_timeout=timedelta(seconds=5),\n            # start_to_close_timeout=timedelta(seconds=5),\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-an-activity-retry-policy-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-an-activity-retry-policy-in-python.md","id":"python/how-to-set-an-activity-retry-policy-in-python","title":"How to set an Activity Retry Policy in Python","description":"Create an instance of an Activity Retry Policy in Python.","label":"Retry Policy","tags":["python","how-to"],"markdown_content":"\nTo create an Activity Retry Policy in Python, set the [RetryPolicy](https://python.temporal.io/temporalio.common.RetryPolicy.html) class within the [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) or [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) function.\n\nThe following example sets the maximum interval to 2 seconds.\n\n```python\nworkflow.execute_activity(\n    your_activity,\n    name,\n    start_to_close_timeout=timedelta(seconds=10),\n    retry_policy=RetryPolicy(maximum_interval=timedelta(seconds=2)),\n)\n```\n","is_empty":false},{"file_name":"how-to-set-asynchronous-activity-completion-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-asynchronous-activity-completion-in-python.md","id":"python/how-to-set-asynchronous-activity-completion-in-python","title":"How to set an Asynchronous Activity Completion in Python","description":"To set the completion status of an asynchronous Activity, get the handle of the Activity and call the appropriate method of `get_async_activity_handle()`.","label":"Set an Asynchronous Activity Completion","tags":["python","how-to"],"markdown_content":"\nTo mark an Activity as completing asynchoronus, do the following inside the Activity.\n\n```python\n# Capture token for later completion\ncaptured_token = activity.info().task_token\nactivity.raise_complete_async()\n```\n\nTo update an Activity outside the Activity, use the [get_async_activity_handle()](https://python.temporal.io/temporalio.client.Client.html#get_async_activity_handle) method to get the handle of the Activity.\n\n```python\nhandle = my_client.get_async_activity_handle(task_token=captured_token)\n```\n\nThen, on that handle, you can call the results of the Activity, `heartbeat`, `complete`, `fail`, or `report_cancellation` method to update the Activity.\n\n```python\nawait handle.complete(\"Completion value.\")\n```\n","is_empty":false},{"file_name":"how-to-set-cluster-address-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-cluster-address-in-python.md","id":"python/how-to-set-cluster-address-in-python","title":"How to set a Cluster address in Python","description":"Set Cluster address","label":"Set Cluster address","tags":["python","how-to"],"markdown_content":"\nTo use a custom Cluster address, set the `target_url` parameter of the [`Client`](https://python.temporal.io/temporalio.client.Client.html) class.\n\n```python\nclient = await Client.connect(\n    \"foo.bar.tmprl.cloud\",\n    # ...\n)\n```\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-mtls-configuration-in-python.md","id":"python/how-to-set-mtls-configuration-in-python","title":"How to set mTLS configuration in Python","description":"Use the `tls_config` parameter from the `Client` class to connect a Client with mTLS.","label":"Set mTLS configuration","tags":["developer-guide","sdk","python"],"markdown_content":"\nUse the `tls_config` parameter from the [`Client`](https://python.temporal.io/temporalio.client.Client.html) class to connect a Client with mTLS.\n\nThe following example connects your Client to your address. The `tls_config` options uses variables that reference the certificate and private key.\n\n```python\nawait Client.connect(\n    \"foo.bar.tmprl.cloud\",\n    namespace=\"foo.bar\",\n    tls_config=TLSConfig(\n        client_cert=client_cert,\n        client_private_key=client_private_key,\n    ),\n)\n```\n\n[The Hello World mTLS sample](https://github.com/temporalio/samples-python/blob/main/hello/hello_mtls.py) demonstrates sample code used to connect to a Temporal Cloud account with the `argparse` library.\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-the-namespace-for-a-temporal-client-in-python.md","id":"python/how-to-set-the-namespace-for-a-temporal-client-in-python","title":"How to set a Namespace for a Temporal Client in Python","description":"Set Namespace","label":"Set Namespace","tags":["python","how-to"],"markdown_content":"\nTo specify a Namespace, set the `namespace` parameter from the [`connect()`](https://python.temporal.io/temporalio.client.Client.html#connect) method.\n\n```python\nawait Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n```\n\n`Client` can be directly instantiated with a service of another, such as when you need to create another Client to use an additional Namespace.\n\nClients also provide a shallow copy of their config for use in making slightly different Clients backed by the same connection with [`config`](https://python.temporal.io/temporalio.client.Client.html#config). The following example creates a new Client with the same connection but a different Namespace.\n\n```python\nconfig = client.config()\nconfig[\"namespace\"] = \"your-other-namespace\"\nother_ns_client = Client(**config)\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-timers-in-python.md","id":"python/how-to-set-timers-in-python","title":"How to set Timers in Python","description":"To set a Timer in Python, set the `asyncio.sleep()` function.","label":"Python","tags":["timers","sleep"],"markdown_content":"\nTo set a Timer in Python, call the [`asyncio.sleep()`](https://docs.python.org/3/library/asyncio-task.html#sleeping) function and pass the duration in seconds you want to wait before continuing.\n\n```python\nawait asyncio.sleep(5)\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-retry-options-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-workflow-retry-options-in-python.md","id":"python/how-to-set-workflow-retry-options-in-python","title":"How to set Workflow Retry Options in Python","description":"Set the Retry Policy from either start_workflow() or execute_workflow().","label":"Workflow Retry Options","tags":["python","how-to"],"markdown_content":"\nSet the Retry Policy from either the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    start_signal=\"your-signal-name\",\n    retry_policy=RetryPolicy(maximum_interval=timedelta(seconds=2)),\n)\n```\n\n```python\nhandle = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    start_signal=\"your-signal-name\",\n    retry_policy=RetryPolicy(maximum_interval=timedelta(seconds=2)),\n)\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-set-workflow-timeouts-in-python.md","id":"python/how-to-set-workflow-timeouts-in-python","title":"How to set Workflow Timeouts in Python","description":"Set the timeout from either start_workflow() or execute_workflow().","label":"Workflow Timeouts","tags":["python","how-to"],"markdown_content":"\nSet the timeout from either the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods.\n\nAvailable timeouts are:\n\n- `execution_timeout`\n- `run_timeout`\n- `task_timeout`\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    start_signal=\"your-signal-name\",\n    # Set Workflow Timeout duration\n    execution_timeout=\"timedelta(seconds=2)\",\n    # run_timeout=\"timedelta(seconds=2)\",\n    # task_timeout=\"timedelta(seconds=2)\",\n)\n```\n\n```python\nhandle = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    start_signal=\"your-signal-name\",\n    # Set Workflow Timeout duration\n    execution_timeout=\"timedelta(seconds=2)\",\n    # run_timeout=\"timedelta(seconds=2)\",\n    # task_timeout=\"timedelta(seconds=2)\",\n)\n```\n","is_empty":false},{"file_name":"how-to-skip-time-skip-automatically-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-skip-time-skip-automatically-in-python.md","id":"python/how-to-skip-time-skip-automatically-in-python","title":"How to skip time automatically in Python","description":"Skip time from the test server automatically.","label":"Skip time automatically","tags":["python","how-to"],"markdown_content":"\nUse the [`start_time_skipping()`](https://python.temporal.io/temporalio.testing.WorkflowEnvironment.html#start_time_skipping) method to start a test server process and skip time automatically.\n\nUse the [`start_local()`](https://python.temporal.io/temporalio.testing.WorkflowEnvironment.html#start_local) method for a full local Temporal server.\n\nUse the [`from_client`](https://python.temporal.io/temporalio.testing.WorkflowEnvironment.html#from_client) method for an existing Temporal sever.\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-spawn-a-child-workflow-execution-in-python.md","id":"python/how-to-spawn-a-child-workflow-execution-in-python","title":"How to spawn a Child Workflow Execution in Python","label":"Child Workflow Execution","tags":["developer-guide","python"],"markdown_content":"\nTo spawn a Child Workflow Execution in Python, use the [`execute_child_workflow()`](https://python.temporal.io/temporalio.workflow.html#execute_child_workflow) function. `execute_child_workflow()` starts the Child Workflow and waits for completion.\n\n```python\nawait workflow.execute_child_workflow(MyWorkflow.run, \"my child arg\", id=\"my-child-id\")\n```\n\nAlternatively, use the [`start_child_workflow()`](https://python.temporal.io/temporalio.workflow.html#start_child_workflow) function to start a Child Workflow and return its handle. This is useful if you want to do something after it has only started, or to get the workflow/run ID, or to be able to signal it while running. To wait for completion, simply `await` the handle. `execute_child_workflow()` is a helper function for `start_child_workflow()` + `await handle`.\n\n```python\nawait workflow.start_child_workflow(MyWorkflow.run, \"my child arg\", id=\"my-child-id\")\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-spawn-a-workflow-execution-in-python.md","id":"python/how-to-spawn-a-workflow-execution-in-python","title":"How to spawn a Workflow Execution in Python","description":"Spawn a Workflow Execution","label":"Spawn a Workflow Execution","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo start a Workflow Execution in python, use either the [`start_workflow()`](https://python.temporal.io/temporalio.client.Client.html#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.Client.html#execute_workflow) asynchronous methods in the Client.\n\nThe following code example starts a Workflow and returns its handle.\n\n```python\nasync def main():\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    handle = await client.start_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n```\n\nThe following code example starts a Workflow and waits for completion.\n\n```python\nasync def main():\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    handle = await client.execute_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n```\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-spawn-an-activity-execution-in-python.md","id":"python/how-to-spawn-an-activity-execution-in-python","title":"How to spawn an Activity Execution in Python","description":"Use the `execute_activity()` operation from within your Workflow Definition.","label":"Activity Execution","tags":["developer-guide","python"],"markdown_content":"\nTo spawn an Activity Execution, use the [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) operation from within your Workflow Definition.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`.\nIn most cases, use `execute_activity()` unless advanced task capabilities are needed.\n\nA single argument to the Activity is positional. Multiple arguments are not supported in the type-safe form of `start_activity()` or `execute_activity()` and must be supplied by the `args` keyword argument.\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python.md","id":"python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python","title":"How to upsert custom Search Attributes","description":"To upsert custom Search Attributes, use [`upsert_search_attributes()`] and set it to an empty list.","label":"Upsert custom Search Attributes","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo upsert custom Search Attributes, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) function and set it to an empty list.\n\nThe keys are added to or replace the existing Search Attributes, similar to [`dict.update()`](https://docs.python.org/3/library/stdtypes.html#dict.update).\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": [\"new-value\"]})\n```\n","is_empty":false},{"file_name":"how-to-use-assert-python.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/how-to-use-assert-python.md","id":"python/how-to-use-assert-python","title":"How to assert a Workflow in Python","label":"Assert a Workflow","tags":["developer-guide","python"],"markdown_content":"\nFor information about assert statements in Python, see [`assert`](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement) in the Python Language Reference.\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/python/index.md","id":"python/index","title":"How to add the Temporal Python SDK","description":"Add the Temporal Python SDK to your project.","tags":["developer-guide","python"],"markdown_content":"\n[![Python 3.7+](https://img.shields.io/pypi/pyversions/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n[![PyPI](https://img.shields.io/pypi/v/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n\nTo install the latest version of the Temporal Python package, run the following command.\n\n```bash\npip install temporalio\n```\n","is_empty":false},{"file_name":"code-samples-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/code-samples-php.md","id":"php/code-samples-php","title":"Code samples","label":"Code samples","markdown_content":"\n- [PHP samples repo](https://github.com/temporalio/samples-php)\n\n- [Subscription-style Workflow Definition in PHP](https://github.com/temporalio/subscription-workflow-project-template-php): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-php.md","id":"php/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-php","title":"How to set Custom Search Attributes to a Workflow Execution in PHP","label":"Custom Search Attributes","markdown_content":"\nUse the `WorkflowOptions::withSearchAttributes()` method to provide Search Attributes when you start a Workflow.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    GreetingWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowExecutionTimeout(CarbonInterval::minute())\n        ->withSearchAttributes(\n            [\n                'CustomKeywordField' => 'value',\n                'CustomIntField' => 123,\n            ]\n        )\n);\n```\n","is_empty":false},{"file_name":"how-to-connect-to-a-cluster-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-connect-to-a-cluster-php.md","id":"php/how-to-connect-to-a-cluster-php","title":"How to connect to a Cluster in PHP","label":"Connect to a Cluster","markdown_content":"\nCreate an instance of the `$workflowClient` class and use the `create()` method to connect a Temporal Client to a Temporal Cluster.\n\nSpecify the target host, `localhost:7223`, parameter as a string and provide the TLS configuration for connecting to a Temporal Cluster.\n\n```php\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowOptions;\n# . . .\n$workflowClient = Temporal\\Client\\WorkflowClient::create(\n     ServiceClient::createSSL(\n         'localhost:7233',\n         'certs/ca.cert',\n         'certs/client.key',\n         'certs/client.pem',\n         'tls-sample',\n     ),\n );\n```\n\nTo provide the client options as an environmental variable, add the `tls` option to the RoadRunner configuration file and pass the path to the file.\n\n```yml\ntemporal:\n  # . . .\n  tls:\n    key: \"certs/client.key\"\n    cert: \"certs/client.pem\"\n    root_ca: \"certs/ca.cert\"\n    client_auth_type: require_and_verify_client_cert\n    server_name: \"tls-sample\"\n```\n\nThen update your application and use the SSL connection for `ServiceClient`.\n\n```php\n$workflowClient = Temporal\\Client\\WorkflowClient::create(\n     ServiceClient::createSSL(\n         'localhost:7233',\n         getenv('TEMPORAL_SERVER_ROOT_CA_CERT_PATH'),\n         getenv('TEMPORAL_CLIENT_KEY_PATH'),\n         getenv('TEMPORAL_CLIENT_CERT_PATH'),\n         getenv('TEMPORAL_SERVER_NAME_OVERRIDE')\n     ),\n );\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-continue-as-new-in-php.md","id":"php/how-to-continue-as-new-in-php","title":"How to Continue-As-New in PHP","label":"Continue-As-New","markdown_content":"\nWorkflows that need to rerun periodically could naively be implemented as a big **while** loop with a sleep where the entire logic of the Workflow is inside the body of the **while** loop.\nThe problem with this approach is that the history for that Workflow will keep growing to a point where it reaches the maximum size enforced by the service.\n\n**ContinueAsNew** is the low level construct that enables implementing such Workflows without the risk of failures down the road.\nThe operation atomically completes the current execution and starts a new execution of the Workflow with the same **Workflow Id**.\nThe new execution will not carry over any history from the old execution.\n\nTo trigger this behavior, use `Workflow::continueAsNew` or `Workflow::newContinueAsNewStub` method:\n\n```php\n#[Workflow\\WorkflowMethod]\npublic function periodic(string $name, int $value = 0)\n{\n    for ($i = 0; $i < 100; $i++) {\n        // do something\n        $value++;\n    }\n\n    // maintain $value counter between runs\n    return Workflow::newContinueAsNewStub(self::class)->periodic($name, $value);\n}\n```\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-create-a-temporal-client-in-php.md","id":"php/how-to-create-a-temporal-client-in-php","title":"How to create a Temporal Client in PHP","label":"Temporal Client","markdown_content":"\nThe following example represents a console command that starts a Workflow, prints its IDs, and then waits for its result:\n\n<!--SNIPSTART php-hello-client {\"enable_source_link\": true}-->\n[app/src/SimpleActivity/ExecuteCommand.php](https://github.com/temporalio/samples-php/blob/master/app/src/SimpleActivity/ExecuteCommand.php)\n```php\nclass ExecuteCommand extends Command\n{\n    protected const NAME = 'simple-activity';\n    protected const DESCRIPTION = 'Execute SimpleActivity\\GreetingWorkflow';\n\n    public function execute(InputInterface $input, OutputInterface $output)\n    {\n        $workflow = $this->workflowClient->newWorkflowStub(\n            GreetingWorkflowInterface::class,\n            WorkflowOptions::new()->withWorkflowExecutionTimeout(CarbonInterval::minute())\n        );\n\n        $output->writeln(\"Starting <comment>GreetingWorkflow</comment>... \");\n\n        // Start a workflow execution. Usually this is done from another program.\n        // Uses task queue from the GreetingWorkflow @WorkflowMethod annotation.\n        $run = $this->workflowClient->start($workflow, 'Antony');\n\n        $output->writeln(\n            sprintf(\n                'Started: WorkflowID=<fg=magenta>%s</fg=magenta>',\n                $run->getExecution()->getID(),\n            )\n        );\n\n        // getResult waits for workflow to complete\n        $output->writeln(sprintf(\"Result:\\n<info>%s</info>\", $run->getResult()));\n\n        return self::SUCCESS;\n    }\n}\n```\n<!--SNIPEND-->\n\nThe `WorkflowClientInterface` in the snippet is an entry point to get access to Workflow.\nUse an instance of `WorkflowClientInterface` to create, retrieve, or start a Workflow.\nHere we create an instance of `GreetingWorkflowInterface` with a Workflow Execution Timeout of one minute.\n\nThen we print some information and start the Workflow.\n","is_empty":false},{"file_name":"how-to-create-local-activities-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-create-local-activities-in-php.md","id":"php/how-to-execute-a-local-activity-in-php","title":"How to execute a Local Activity in PHP","label":"Local Activity","markdown_content":"\nTo execute a Local Activity, use `#[LocalActivityInterface]`.\n\n```php\nuse Temporal\\Activity\\LocalActivityInterface;\n\n#[ActivityInterface]\ninterface YourActivityInterface\n{\n    #[ActivityMethod(\"youractivity\")]\n    public function youractivity(): string;\n}\n```\n\nLocal Activities requires `LocalActivityOptions`:\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    YourActivityInterface::class,\n    LocalActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n```\n\nLocal Activity Execution options include the following:\n\n- `ScheduleToCloseTimeout`\n- `StartToCloseTimeout`\n- `RetryPolicy`.\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-customize-activity-type-in-php.md","id":"php/how-to-customize-activity-type-in-php","title":"How to customize Activity Type in PHP","description":"Customize your Activity Type.","label":"Customize Activity Type","tags":["developer-guide","sdk","php"],"markdown_content":"\nAn optional `#[ActivityMethod]` annotation can be used to override a default Activity name.\n\nYou can define your own prefix for all Activity names by adding the `prefix` option to the `YourActivityInterface` annotation.\n(The default prefix is empty.)\n\n```php\n#[YourActivityInterface(\"file_activities.\")]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName);\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName);\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName);\n}\n```\n\nThe `#[YourActivityInterface(\"file_activities.\")]` is an annotation that tells the PHP SDK to generate a class to implement the `FileProcessingActivities` interface. The functions define Activities that are used in the Workflow.\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-customize-workflow-type-in-php.md","id":"php/how-to-customize-workflow-type-in-php","title":"How to customize a Workflow Type in PHP","description":"How to customize a Workflow Type in PHP","label":"Custom Workflow Type","tags":["developer-guide","sdk","php"],"markdown_content":"\nTo customize a Workflow Type, use the `WorkflowMethod` annotation to specify the name of Workflow.\n\n```php\n#[WorkflowMethod(name)]\n```\n\nIf a Workflow Type is not specified, then Workflow Type defaults to the interface name, which is `YourWorkflowDefinitionInterface` in this case.\n\n```php\n#[WorkflowInterface]\ninterface YourWorkflowDefinitionInterface\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n}\n```\n","is_empty":false},{"file_name":"how-to-define-a-query-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-define-a-query-in-php.md","id":"php/how-to-define-a-query-in-php","title":"How to define a Query in PHP","label":"Define a Query","markdown_content":"\nWorkflows can answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow Type defaults to `\"FileProcessingWorkflow\"`.\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-define-a-signal-in-php.md","id":"php/how-to-define-a-signal-in-php","title":"How to define a Signal in PHP","label":"Define a Signal","markdown_content":"\nWorkflows can answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow Type defaults to `\"FileProcessingWorkflow\"`.\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-define-activity-parameters-in-php.md","id":"php/how-to-define-activity-parameters-in-php","title":"Define Activity parameters in PHP","label":"Activity parameters","markdown_content":"\nEach method defines a single Activity type.\nA single Workflow can use more than one Activity interface and call more than one Activity method from the same interface.\n\nThe only requirement is that Activity method arguments and return values are serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-define-activity-return-values-in-php.md","id":"php/how-to-define-activity-return-values-in-php","title":"How to define Activity return values in PHP","description":"Activity return values must be serializable and deserializable by the provided `DataConverter`","label":"Activity return values","tags":["developer-guide","php"],"markdown_content":"\nReturn values must be serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\nThus, you can return both primitive types:\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): string\n    {\n        return $greeting . ' ' . $name;\n    }\n}\n```\n\nAnd objects:\n\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): Greeting\n    {\n        return new Greeting($greeting, $name);\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-java.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-define-workflow-parameters-in-java.md","id":"php/how-to-define-workflow-parameters-in-php","title":"How to define Workflow Parameters in PHP","description":"A method annotated with `#[WorkflowMethod]` can have any number of parameters.","label":"Workflow parameters","tags":["developer-guide","php"],"markdown_content":"\nA method annotated with `#[WorkflowMethod]` can have any number of parameters.\n\nWe recommend passing a single parameter that contains all the input fields to allow for adding fields in a backward-compatible manner.\n\nNote that all inputs should be serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\nYou can create a custom object and pass it to the Workflow method, as shown in the following example:\n\n```php\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-define-workflow-return-values-in-php.md","id":"php/how-to-define-workflow-return-values-in-php","title":"Define Workflow return values in PHP","label":"Workflow return values","markdown_content":"\nA Workflow method returns a Generator.\nTo properly typecast the Workflow's return value in the client code, use the `#[ReturnType()]` annotation.\n\n```php\n#[YourWorkflowInterface]\ninterface FileProcessingWorkflow {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-develop-a-worker-program-in-php.md","id":"php/how-to-develop-a-worker-program-in-php","title":"How to develop a Worker Program in PHP","description":"Use the `newWorker()` method on an instance of a `WorkerFactory` to create a new Worker in PHP.","tags":["developer-guide","php","workers"],"markdown_content":"\nThe [RoadRunner application server](https://roadrunner.dev/) will launch multiple Temporal PHP Worker processes based on provided `.rr.yaml` configuration.\n\nEach Worker might connect to one or multiple Task Queues.\nWorker poll _Temporal service_ for tasks, performs those tasks, and communicates task execution results back to the _Temporal service_.\n\nWorker code are developed, deployed, and operated by Temporal customers.\nTo create a worker use `Temporal\\WorkerFactory`:\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nuse Temporal\\WorkerFactory;\n\nini_set('display_errors', 'stderr');\ninclude \"vendor/autoload.php\";\n\n// factory initiates and runs task queue specific activity and workflow workers\n$factory = WorkerFactory::create();\n\n// Worker that listens on a Task Queue and hosts both workflow and activity implementations.\n$worker = $factory->newWorker();\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n\n// Activities are stateless and thread safe. So a shared instance is used.\n$worker->registerActivity(App\\DemoActivity::class);\n\n// In case an activity class requires some external dependencies provide a callback - factory\n// that creates or builds a new activity instance. The factory should be a callable which accepts\n// an instance of ReflectionClass with an activity class which should be created.\n$worker->registerActivity(App\\DemoActivity::class, fn(ReflectionClass $class) => $container->create($class->getName()));\n\n// start primary loop\n$factory->run();\n```\n\nYou can configure task queue name using first argument of `WorkerFactory`->`newWorker`:\n\n```php\n$worker = $factory->newWorker('your-task-queue');\n```\n\nAs mentioned above you can create as many Task Queue connections inside a single Worker Process as you need.\n\nTo configure additional WorkerOptions use `Temporal\\Worker\\WorkerOptions`:\n\n```php\nuse Temporal\\Worker\\WorkerOptions;\n\n$worker = $factory->newWorker(\n    'your-task-queue',\n    WorkerOptions::new()\n        ->withMaxConcurrentWorkflowTaskPollers(10)\n);\n```\n\nMake sure to point the Worker file in application server configuration:\n\n```yaml\nrpc:\n  listen: tcp://127.0.0.1:6001\n\nserver:\n  command: \"php worker.php\"\n\ntemporal:\n  address: \"temporal:7233\"\n  activities:\n    num_workers: 10\n```\n\n> You can serve HTTP endpoints using the same server setup.\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-develop-a-workflow-definition-in-php.md","id":"php/how-to-develop-a-workflow-definition-in-php","title":"Develop a Workflow Definition in PHP","label":"Workflow Definition","markdown_content":"\nIn the Temporal PHP SDK programming model, Workflows are a class method. Classes must implement interfaces that are annotated with `#[WorkflowInterface]`. The method that is the Workflow must be annotated with `#[WorkflowMethod]`.\n\n```php\nuse Temporal\\Workflow\\YourWorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-develop-an-activity-definition-in-php.md","id":"php/how-to-develop-an-activity-definition-in-php","title":"Develop an Activity Definition in PHP","label":"Activity Definition","markdown_content":"\nActivities are defined as methods of a plain PHP interface annotated with `#[YourActivityInterface]`.\n(You can also use PHP 8 attributes in PHP 7.)\n\nFollowing is an example of an interface that defines four Activities:\n\n```php\n#[YourActivityInterface]\n// Defining an interface for the activities.\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName): void;\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName): void;\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName): void;\n}\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-get-the-result-of-a-workflow-execution-in-php.md","id":"php/how-to-get-the-result-of-a-workflow-execution-in-php","title":"How to get the result of an Workflow Execution in PHP","label":"Workflow Execution","markdown_content":"\nIf you need to wait for the completion of a Workflow after an asynchronous start, make a blocking call to\nthe `WorkflowRun`->`getResult` method.\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getResult());\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-get-the-result-of-an-activity-execution-in-php.md","id":"php/how-to-get-the-result-of-an-activity-execution-in-php","title":"How to get the result of an Activity Execution in PHP","label":"Activity Execution","markdown_content":"\n`Workflow::newActivityStub`returns a client-side stub an implements an Activity interface. The client-side stub can be used within the Workflow code. It takes the Activity's type and`ActivityOptions` as arguments.\n\nCalling (via `yield`) a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if Activity Execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\n```php\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    private $greetingActivity;\n\n    public function __construct()\n    {\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n        );\n    }\n\n    public function greet(string $name): \\Generator\n    {\n        // This is a blocking call that returns only after the activity has completed.\n        return yield $this->greetingActivity->composeGreeting('Hello', $name);\n    }\n}\n```\n\nIf different Activities need different options, like timeouts or a task queue, multiple client-side stubs can be created with different options.\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 minutes'))\n);\n```\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-handle-a-query-in-a-workflow-in-php.md","id":"php/how-to-handle-a-query-in-a-workflow-in-php","title":"How to handle a Query in PHP","label":"Handle a Query","markdown_content":"\nYou can add custom Query types to handle Queries such as Querying the current state of a\nWorkflow, or Querying how many Activities the Workflow has completed. To do this, you need to set\nup a Query handler using method attribute `QueryMethod` or `Workflow::registerQueryHandler`.\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\QueryMethod]\n    public function getValue()\n    {\n        return 42;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // workflow code\n    }\n\n}\n```\n\nThe handler function can receive any number of input parameters, but all input parameters must be\nserializable. The following sample code sets up a Query handler that handles the Query type of\n`currentState`:\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private string $currentState;\n\n    #[Workflow\\QueryMethod('current_state')]\n    public function getCurrentState(): string\n    {\n        return $this->currentState;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // Your normal Workflow code begins here, and you update the currentState\n        // as the code makes progress.\n        $this->currentState = 'waiting timer';\n        try{\n            yield Workflow::timer(DateInterval::createFromDateString('1 hour'));\n        } catch (\\Throwable $e) {\n            $this->currentState = 'timer failed';\n            throw $e;\n        }\n\n        $yourActivity = Workflow::newActivityStub(\n            YourActivityInterface::class,\n            ActivityOptions::new()->withScheduleToStartTimeout(60)\n        );\n\n        $this->currentState = 'waiting activity';\n        try{\n            yield $yourActivity->doSomething('some input');\n        } catch (\\Throwable $e) {\n            $this->currentState = 'activity failed';\n            throw $e;\n        }\n\n        $this->currentState = 'done';\n\n        return null;\n    }\n}\n```\n\nYou can also issue a Query from code using the `QueryWorkflow()` API on a Temporal Client object.\n\nUse `WorkflowStub` to Query Workflow instances from your Client code (can be applied to both running and closed Workflows):\n\n```php\n$workflow = $workflowClient->newWorkflowStub(\n    YourWorkflow::class,\n    WorkflowOptions::new()\n);\n\n$workflowClient->start($workflow);\n\nvar_dump($workflow->getCurrentState());\nsleep(60);\nvar_dump($workflow->getCurrentState());\n```\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-a-workflow-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-handle-a-signal-in-a-workflow-in-php.md","id":"php/how-to-handle-a-signal-in-a-workflow-in-php","title":"How to handle Signals in an Workflow in PHP","description":"Use the `#[SignalMethod]` annotation to handle Signals within the Workflow interface.","label":"Handle Signals","tags":["php","developer-guide"],"markdown_content":"\nUse the `#[SignalMethod]` annotation to handle Signals in the Workflow interface:\n\n```php\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private bool $value;\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        yield Workflow::await(fn()=> $this->value);\n        return 'OK';\n    }\n\n    #[Workflow\\SignalMethod]\n    public function setValue(bool $value)\n    {\n        $this->value = $value;\n    }\n}\n```\n\nIn the preceding example, the Workflow updates the protected value.\nThe main Workflow coroutine waits for the value to change by using the `Workflow::await()` function.\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-handle-workflow-logic-requirements-in-php.md","id":"php/how-to-handle-workflow-logic-requirements-in-php","title":"How to handle Workflow logic requirements in PHP","label":"Activity Execution","markdown_content":"\n\\*\\*Temporal uses the [Microsoft Azure Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover the state of a Workflow object including its local variable values.\n\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nWhen replaying, side effects (such as Activity invocations) are ignored because they are already recorded in the Workflow event history.\nWhen writing Workflow logic, the replay is not visible, so the code should be written since it executes only once.\nThis design puts the following constraints on the Workflow implementation:\n\n- Do not use any mutable global variables because multiple instances of Workflows are executed in parallel.\n- Do not call any non-deterministic functions like non seeded random or `UUID` directly from the Workflow code.\n\nAlways do the following in the Workflow implementation code:\n\n- Don’t perform any IO or service calls as they are not usually deterministic. Use Activities for this.\n- Only use `Workflow::now()` to get the current time inside a Workflow.\n- Call `yield Workflow::timer()` instead of `sleep()`.\n- Do not use any blocking SPL provided by PHP (i.e. `fopen`, `PDO`, etc) in **Workflow code**.\n- Use `yield Workflow::getVersion()` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already open Workflows.\n- Don’t access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\nWorkflow method arguments and return values are serializable to a byte array using the provided [DataConverter](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html) interface.\nThe default implementation uses JSON serializer, but you can use any alternative serialization mechanism.\n\nMake sure to annotate your `WorkflowMethod` using `ReturnType` to specify concrete return type.\n\n> You can not use the default return type declaration as Workflow methods are generators.\n\nThe values passed to Workflows through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to Workflow workers with every event that the Workflow logic needs to process.\nA large execution history can thus adversely impact the performance of your Workflow.\nTherefore, be mindful of the amount of data that you transfer via Activity invocation parameters or return values.\nOtherwise, no additional limitations exist on Activity implementations.\\*\\*\n","is_empty":false},{"file_name":"how-to-mock-activities-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-mock-activities-in-php.md","id":"php/how-to-mock-activities-in-php","title":"How to mock Activities in PHP","description":"To mock an Activity in PHP, follow the instructions in this article.","label":"Mock Activities","tags":["developer-guide","sdk","php"],"markdown_content":"\n**RoadRunner config**\n\nTo mock an Activity in PHP, use [RoadRunner Key-Value storage](https://github.com/spiral/roadrunner-kv) and add the following lines to your `tests/.rr.test.yaml` file.\n\n```yaml\n# tests/.rr.test.yaml\nkv:\n  test:\n    driver: memory\n    config:\n      interval: 10\n```\n\nIf you want to be able to mock Activities, use `WorkerFactory` from the `Temporal\\Testing` Namespace\nin your PHP Worker:\n\n```php\n// worker.test.php\nuse Temporal\\Testing\\WorkerFactory;\n\n$factory = WorkerFactory::create();\n$worker = $factory->newWorker();\n\n$worker->registerWorkflowTypes(MyWorkflow::class);\n$worker->registerActivity(MyActivity::class);\n$factory->run();\n```\n\nThen, in your tests to mock an Activity, use the`ActivityMocker` class.\n\nAssume we have the following Activity:\n\n```php\n#[ActivityInterface(prefix: \"SimpleActivity.\")]\ninterface SimpleActivityInterface\n{\n    #[ActivityMethod('doSomething')]\n    public function doSomething(string $input): string;\n```\n\nTo mock it in the test, you can do this:\n\n```php\nfinal class SimpleWorkflowTestCase extends TestCase\n{\n    private WorkflowClient $workflowClient;\n    private ActivityMocker $activityMocks;\n\n    protected function setUp(): void\n    {\n        $this->workflowClient = new WorkflowClient(ServiceClient::create('localhost:7233'));\n        $this->activityMocks = new ActivityMocker();\n\n        parent::setUp();\n    }\n\n    protected function tearDown(): void\n    {\n        $this->activityMocks->clear();\n        parent::tearDown();\n    }\n\n    public function testWorkflowReturnsUpperCasedInput(): void\n    {\n        $this->activityMocks->expectCompletion('SimpleActivity.doSomething', 'world');\n        $workflow = $this->workflowClient->newWorkflowStub(SimpleWorkflow::class);\n        $run = $this->workflowClient->start($workflow, 'hello');\n        $this->assertSame('world', $run->getResult('string'));\n    }\n}\n```\n\nIn the preceding test case, we do the following:\n\n1. Instantiate `ActivityMocker` in the `setUp()` method of the test.\n2. Clear the cache after each test in `tearDown()`.\n3. Mock an Activity call to return a string `world`.\n\nTo mock a failure, use the `expectFailure()` method:\n\n```php\n$this->activityMocks->expectFailure('SimpleActivity.echo', new \\LogicException('something went wrong'));\n```\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-register-types-with-a-worker-in-php.md","id":"php/how-to-register-types-with-a-worker-in-php","title":"How to register types with a Worker in PHP","description":"Use `registerWorkflowTypes()` to register Workflow Type and `registerActivity()` to register Activity implementation with Workers.","label":"Register Types","tags":["developer-guide","php","workers"],"markdown_content":"\nWorker listens on a Task Queue and hosts both Workflow and Activity implementations:\n\n```php\n// Workflows are stateful. So you need a type to create instances:\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n// Activities are stateless and thread safe:\n$worker->registerActivity(App\\DemoActivity::class);\n```\n\nIn case an activity class requires some external dependencies provide a callback - factory\nthat creates or builds a new activity instance. The factory should be a callable which accepts\nan instance of ReflectionClass with an activity class which should be created.\n\n```php\n$worker->registerActivity(\n    App\\DemoActivity::class,\n    fn(ReflectionClass $class) => $container->create($class->getName())\n);\n```\n\nIf you want to clean up some resources after activity is done, you may register a finalizer. This callback is called\nafter each activity invocation:\n\n```php\n$worker->registerActivityFinalizer(fn() => $kernel->showtdown());\n```\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-remove-search-attributes-from-a-workflow-in-php.md","id":"php/how-to-remove-search-attributes-from-a-workflow-in-php","title":"How to remove Search Attributes from a Workflow in PHP","label":"Remove Search Attributes","markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array `[]`.\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-send-a-signal-from-a-client-in-php.md","id":"php/how-to-send-a-signal-from-a-client-in-php","title":"How to send a Signal from a Client in PHP","description":"To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `#[SignalMethod]` in the Workflow interface, from the Client code.","label":"Send Signal from Client","tags":["php","developer-guide"],"markdown_content":"\nTo send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `#[SignalMethod]` in the Workflow interface, from the Client code.\n\nTo send a Signal to a Workflow, use `WorkflowClient->newWorkflowStub` or `WorkflowClient->newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient->newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with Workflow Id to send Signals to already running Workflows.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n\nSee [Handle Signals](/php/how-to-handle-a-signal-in-a-workflow-in-php) for details on how to handle Signals in a Workflow.\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-send-a-signal-from-a-workflow-in-php.md","id":"php/how-to-send-a-signal-from-a-workflow-in-php","title":"How to send Signal a Workflow in PHP","label":"Signal a Workflow","markdown_content":"\nTo send signal to a Workflow use `WorkflowClient`->`newWorkflowStub` or `WorkflowClient`->`newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient`->`newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with Workflow Id to send\nSignals to a running Workflow.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-send-a-signal-with-start-in-php.md","id":"php/how-to-send-a-signal-with-start-in-php","title":"How to send Signal-With-Start in PHP","label":"Signal-With-Start","markdown_content":"\nIn cases where you may not know if a Workflow is running, and want to send a Signal to it, use `startwithSignal`.\nIf a running Workflow exists, the `startwithSignal` API sends the Signal.\nIf there is no running Workflow, the API starts a new Workflow Run and delivers the Signal to it.\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->startWithSignal(\n    $workflow,\n    'setValue',\n    [true], // signal arguments\n    [] // start arguments\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-cron-schedule-in-php.md","id":"php/how-to-set-a-cron-schedule-in-php","title":"How to set a CRON schedule in PHP","label":"Activity Execution","markdown_content":"\nSet your Cron Schedule with `CronSchedule('* * * * *')`.\n\nThe following example sets a Cron Schedule in PHP:\n\n```php\n  $workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()\n          ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n          ->withCronSchedule('* * * * *')\n          // Execution timeout limits total time. Cron will stop executing after this timeout.\n          ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n          // Run timeout limits duration of a single workflow invocation.\n          ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n  );\n\n  $output->writeln(\"Starting <comment>CronWorkflow</comment>... \");\n\n  try {\n      $run = $this->workflowClient->start($workflow, 'Antony');\n      // ...\n  }\n```\n\nSetting `withCronSchedule` turns the Workflow Execution into a Temporal Cron Job.\nFor more information, see the [PHP samples](https://github.com/temporalio/samples-php/tree/master/app/src/Cron) for example code or the PHP SDK `WorkflowOptions` [source code](https://github.com/temporalio/sdk-php/blob/master/src/Client/WorkflowOptions.php).\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-for-an-activity-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-heartbeat-for-an-activity-in-php.md","id":"php/how-to-set-a-heartbeat-for-an-activity-in-php","title":"How to set a Heartbeat for an Activity in PHP","label":"Heartbeat an Activity","markdown_content":"\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-heartbeat-timeout-in-php.md","id":"php/how-to-set-a-heartbeat-timeout-in-php","title":"How to set a Heartbeat Timeout in PHP","label":"Heartbeat Timeout","markdown_content":"\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-parent-close-policy-in-php.md","id":"php/how-to-set-a-parent-close-policy-in-php","title":"How to set a Parent Close Policy in PHP","description":"Create an instance of `ChildWorkflowOptions` and use `withParentClosePolicy()` method to apply the options to a new Child Workflow object.","label":"Parent Close Policy","tags":["php","developer-guide","how-to"],"markdown_content":"\nIn PHP, a [Parent Close Policy](/concepts/what-is-a-parent-close-policy) is set via the `ChildWorkflowOptions` object and `withParentClosePolicy()` method.\nThe possible values can be obtained from the [`ParentClosePolicy`](https://github.com/temporalio/sdk-php/blob/master/src/Workflow/ParentClosePolicy.php) class.\n\n- `POLICY_TERMINATE`\n- `POLICY_ABANDON`\n- `POLICY_REQUEST_CANCEL`\n\nThen `ChildWorkflowOptions` object is used to create a new Child Workflow object:\n\n```php\n$child = Workflow::newUntypedChildWorkflowStub(\n    'child-workflow',\n    ChildWorkflowOptions::new()\n        ->withParentClosePolicy(ParentClosePolicy::POLICY_ABANDON)\n);\n\nyield $child->start();\n```\n\nIn the snippet above we:\n\n1. Create a new untyped Child Workflow stub with `Workflow::newUntypedChildWorkflowStub`.\n2. Provide `ChildWorkflowOptions` object with Parent Close Policy set to `ParentClosePolicy::POLICY_ABANDON`.\n3. Start Child Workflow Execution asynchronously using `yield` and method `start()`.\n\nWe need `yield` here to ensure that a Child Workflow Execution starts before the parent closes.\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-schedule-to-close-timeout-in-php.md","id":"php/how-to-set-a-schedule-to-close-timeout-in-php","title":"How to set Schedule-to-Close Timeout in PHP","label":"Schedule-to-Start Timeout","markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-schedule-to-start-timeout-in-php.md","id":"php/how-to-set-a-schedule-to-start-timeout-in-php","title":"How to set Schedule-to-Start Timeout in PHP","label":"Schedule-to-Start Timeout","markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToStartTimeout` set to 10 seconds.\n\n```php\n// Creating a stub for the activity.\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()\n                ->withScheduleToStartTimeout(CarbonInterval::seconds(10))\n        );\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-start-to-close-timeout-in-php.md","id":"php/how-to-set-a-start-to-close-timeout-in-php","title":"How to set Start-to-Close Timeout in PHP","label":"Start-to-Close Timeout","markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `StartToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(CarbonInterval::seconds(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-execution-timeout-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-workflow-execution-timeout-in-php.md","id":"php/how-to-set-a-workflow-execution-timeout-in-php","title":"How to set Workflow Execution Timeout in PHP","label":"Workflow Execution Timeout","markdown_content":"\nThe following code example creates a new Workflow and sets the Workflow Id.\nThen it sets the Workflow Id Reuse Policy and the Workflow Execution Timeout to 2 minutes.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    DynamicSleepWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(DynamicSleepWorkflow::WORKFLOW_ID)\n        ->withWorkflowIdReusePolicy(WorkflowIdReusePolicy::WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-workflow-id-in-php.md","id":"php/how-to-set-a-workflow-id-in-php","title":"How to set a Workflow Id in PHP","label":"Workflow Id","markdown_content":"\nThe following code example grabs the `userID` as an input and uses it to start the Workflow. The `userID` is used as Workflow Id. You can use this to cancel your Workflow later.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(string $userID);\n}\n```\n\nThe following code example, uses the input parameter `userID` as the Workflow Id.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(\n        string $userID\n    );\n}\n```\n\nYou can also set the Workflow Id as a constant, for example:\n\n```php\npublic const WORKFLOW_ID = Your-Workflow-Id\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-run-timeout-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-workflow-run-timeout-in-php.md","id":"php/how-to-set-a-workflow-run-timeout-in-php","title":"How to set Workflow Run Timeout in PHP","label":"Workflow Run Timeout","markdown_content":"\n`WorkflowRunTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-workflow-task-queue-in-php.md","id":"php/how-to-set-a-workflow-task-queue-in-php","title":"How to set a Workflow Task Queue in PHP","label":"Task Queues","markdown_content":"\nIn PHP, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```php\n// Create new Workflow Options and set the Task Queue\n$workflowOptions = WorkflowOptions::new()\n  ->withTaskQueue(\"Workflow-Task-Queue-1\")\n  // ...\n\n$yourWorkflow = $workflowClient->newWorkflowStub(\n  YourWorkflowInterface::class,\n  $workflowOptions\n);\n\n$result = $yourWorkflow->workflowMethod();\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```php\nuse Temporal\\WorkerFactory;\n\n// Create a Worker Factory\n$factory = WorkerFactory::create();\n\n// Set the Task Queue when creating the Worker\n$worker = $factory->newWorker(\"Workflow-Task-Queue-1\");\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(YourWorkflow::class);\n\n// start primary loop\n$factory->run();\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```php\nclass YourWorkflow implements YourWorkflowInterface\n{\n  private $yourActivity;\n\n  public function __construct()\n  {\n    // Create Activity options and set the Task Queue\n    $activityOptions = ActivityOptions::new()\n      ->withTaskQueue(\"Activity-Task-Queue-1\")\n      // ...\n\n    // Create a new Activity Stub and pass the options\n    $this->yourActivity = Workflow::newActivityStub(\n      YourActivityInterface::class,\n      $activityOptions\n    );\n  }\n\n  public function workflowMethod(): \\Generator\n  {\n    // Call the Activity\n    return yield $this->yourActivity->activityMethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```php\n//Create new Child Workflow Options and set the Task Queue\n$childWorkflowOptions = ChildWorkflowOptions::new()\n    ->withTaskQueue(\"Child-Workflow-Task-Queue-1\")\n    // ...\n\n// Create a new Child Workflow Stub and set the Task Queue\n$childWorkflow = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    $childWorkflowOptions\n);\n\n// Call the Child Workflow method\n$promise = $childWorkflow->workflowMethod();\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-timeout-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-a-workflow-task-timeout-in-php.md","id":"php/how-to-set-a-workflow-task-timeout-in-php","title":"How to set Workflow Task Timeout in PHP","label":"Workflow Task Timeout","markdown_content":"\n`WorkflowTaskTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowTaskTimeout(CarbonInterval::minute(1))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-activity-retry-options-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-activity-retry-options-in-php.md","id":"php/how-to-set-activity-retry-options-in-php","title":"How to set Activity Retry Options in PHP","label":"Activity Retry Options","markdown_content":"\nTo set an Activity Retry, set `{@link RetryOptions}` on `{@link ActivityOptions}`.\nThe follow example creates a new Activity with the given options.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(10))\n        ->withRetryOptions(\n            RetryOptions::new()\n                ->withInitialInterval(CarbonInterval::seconds(1))\n                ->withMaximumAttempts(5)\n                ->withNonRetryableExceptions([\\InvalidArgumentException::class])\n        )\n);\n}\n```\n\nFor an executable code sample, see [ActivityRetry sample](https://github.com/temporalio/samples-php/tree/master/app/src/ActivityRetry) in the PHP samples repository.\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-activity-timeouts-in-php.md","id":"php/how-to-set-activity-timeouts-in-php","title":"How to set Activity Timeouts in PHP","label":"Activity Timeouts","markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\n\nAvailable timeouts are:\n\n- withScheduleToCloseTimeout()\n- withStartToCloseTimeout()\n- withScheduleToStartTimeout()\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    // Set Activity Timeout duration\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(2))\n        // ->withStartToCloseTimeout(CarbonInterval::seconds(2))\n        // ->withScheduleToStartTimeout(CarbonInterval::seconds(10))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-asynchronous-activity-completion-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-asynchronous-activity-completion-in-php.md","id":"php/how-to-set-asynchronous-activity-completion-in-php","title":"How to set asynchronous Activity completion in PHP","description":"Set asynchronous Activity completion in PHP.","label":"Asynchronous Activity completion","tags":["php","how-to"],"markdown_content":"\nSometimes Workflows need to perform certain operations in parallel.\n\nInvoking activity stub without the use of `yield` will return the Activity result promise which can be resolved at later moment.\nCalling `yield` on promise blocks until a result is available.\n\n> Activity promise also exposes `then` method to construct promise chains.\n> Read more about Promises [here](https://github.com/reactphp/promise).\n\nAlternatively you can explicitly wrap your code (including `yield` constucts) using `Workflow::async` which will execute nested code in parallel with main Workflow code.\nCall `yeild` on Promise returned by `Workflow::async` to merge execution result back to primary Workflow method.\n\n```php\npublic function greet(string $name): \\Generator\n{\n    // Workflow::async runs it's activities and child workflows in a separate coroutine. Use keyword yield to merge\n    // it back to parent process.\n\n    $first = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Bye', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    $second = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hola', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Chao', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    // blocks until $first and $second complete\n    return (yield $first) . \"\\n\" . (yield $second);\n}\n```\n\n**Async completion**\n\nThere are certain scenarios when moving on from an Activity upon completion of its function is not possible or desirable.\nFor example, you might have an application that requires user input to complete the Activity.\nYou could implement the Activity with a polling mechanism, but a simpler and less resource-intensive implementation is to asynchronously complete a Temporal Activity.\n\nThere are two parts to implementing an asynchronously completed Activity:\n\n1. The Activity provides the information necessary for completion from an external system and notifies the Temporal service that it is waiting for that outside callback.\n2. The external service calls the Temporal service to complete the Activity.\n\nThe following example demonstrates the first part:\n\n<!--SNIPSTART samples-php-async-activity-completion-activity-class-->\n[app/src/AsyncActivityCompletion/GreetingActivity.php](https://github.com/temporalio/samples-php/blob/master/app/src/AsyncActivityCompletion/GreetingActivity.php)\n```php\nclass GreetingActivity implements GreetingActivityInterface\n{\n    private LoggerInterface $logger;\n\n    public function __construct()\n    {\n        $this->logger = new Logger();\n    }\n    /**\n     * Demonstrates how to implement an Activity asynchronously.\n     * When {@link Activity::doNotCompleteOnReturn()} is called,\n     * the Activity implementation function that returns doesn't complete the Activity.\n     */\n    public function composeGreeting(string $greeting, string $name): string\n    {\n        // In real life this request can be executed anywhere. By a separate service for example.\n        $this->logger->info(sprintf('GreetingActivity token: %s', base64_encode(Activity::getInfo()->taskToken)));\n        // Send the taskToken to the external service that will complete the Activity.\n        // Return from the Activity a function indicating that Temporal should wait\n        // for an async completion message.\n        Activity::doNotCompleteOnReturn();\n        // When doNotCompleteOnReturn() is invoked the return value is ignored.\n        return 'ignored';\n    }\n}\n```\n<!--SNIPEND-->\n\nThe following code demonstrates how to complete the Activity successfully using `WorkflowClient`:\n\n<!--SNIPSTART samples-php-async-activity-completion-completebytoken-->\n[app/src/AsyncActivityCompletion/CompleteCommand.php](https://github.com/temporalio/samples-php/blob/master/app/src/AsyncActivityCompletion/CompleteCommand.php)\n```php\n        $client = $this->workflowClient->newActivityCompletionClient();\n        // Complete the Activity.\n        $client->completeByToken(\n            base64_decode($input->getArgument('token')),\n            $input->getArgument('message')\n        );\n```\n<!--SNIPEND-->\n\nTo fail the Activity, you would do the following:\n\n```php\n// Fail the Activity.\n$activityClient->completeExceptionallyByToken($taskToken, new \\Error(\"activity failed\"));\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-timers-in-php.md","id":"php/how-to-set-timers-in-php","title":"How to set Timers in PHP","description":"To set a Timer in PHP, use `Workflow::timer()`.","label":"Timers","tags":["timers","sleep"],"markdown_content":"\nTo set a Timer in PHP, use `Workflow::timer()` and pass the number of seconds you want to wait before continuing.\n\nThe following example yields a sleep method for 5 minutes.\n\n```php\nyield Workflow::timer(300); // sleep for 5 minutes\n```\n\nYou cannot set a Timer invocation inside the `await` or `awaitWithTimeout` methods.\n","is_empty":false},{"file_name":"how-to-set-workflow-retry-options-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-workflow-retry-options-in-php.md","id":"php/how-to-set-workflow-retry-options-in-php","title":"How to set Workflow Retry Options in PHP","description":"A Retry Policy can be configured with an instance of the `RetryOptions` object.","label":"Workflow Retry Options","tags":["php","how-to","developer-guide"],"markdown_content":"\nA Retry Policy can be configured with an instance of the `RetryOptions` object.\nTo enable retries for a Workflow, you need to provide a Retry Policy object via `ChildWorkflowOptions` for Child Workflows or via `WorkflowOptions` for top-level Workflows.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()->withRetryOptions(\n        RetryOptions::new()->withInitialInterval(120)\n      )\n);\n```\n\nFor more detailed information about `RetryOptions` object see [retries](/php/retries) for more details.\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-set-workflow-timeouts-in-php.md","id":"php/how-to-set-workflow-timeouts-in-php","title":"How to set Workflow Timeouts in PHP","description":"Create an instance of WorkflowOptions.","label":"Workflow Timeouts","tags":["php","how-to"],"markdown_content":"\nCreate an instance of `WorkflowOptions` in the Client code and set your timeout.\n\nAvailable timeouts are:\n\n- `withWorkflowExecutionTimeout()`\n- `withWorkflowRunTimeout()`\n- `withWorkflowTaskTimeout()`\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    DynamicSleepWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(DynamicSleepWorkflow::WORKFLOW_ID)\n        ->withWorkflowIdReusePolicy(WorkflowIdReusePolicy::WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n        // Set Workflow Timeout duration\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(2))\n        // ->withWorkflowRunTimeout(CarbonInterval::minute(2))\n        // ->withWorkflowTaskTimeout(CarbonInterval::minute(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-skip-time-set-up-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-skip-time-set-up-in-php.md","id":"php/how-to-skip-time-set-up-in-php","title":"How to set up time skipping in PHP","description":"To set up time skipping, create `bootstrap.php` and add it to `phpunit.xml`.","label":"Set up time skipping","tags":["developer-guide","sdk","PHP"],"markdown_content":"\n1. In the `tests` folder, create `bootstrap.php` with the following contents:\n\n```php\ndeclare(strict_types=1);\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse Temporal\\Testing\\Environment;\n\n$environment = Environment::create();\n$environment->start();\nregister_shutdown_function(fn () => $environment->stop());\n```\n\nIf you don't want to run the test server with all of your tests, you can add a condition to start a test only if the `RUN_TEMPORAL_TEST_SERVER` environment variable is present:\n\n```php\nif (getenv('RUN_TEMPORAL_TEST_SERVER') !== false) {\n    $environment = Environment::create();\n    $environment->start('./rr serve -c .rr.silent.yaml -w tests');\n    register_shutdown_function(fn() => $environment->stop());\n}\n```\n\n2. Add `bootstrap.php` and the `TEMPORAL_ADDRESS` environment variable to `phpunit.xml`:\n\n```xml\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/9.3/phpunit.xsd\"\n         bootstrap=\"tests/bootstrap.php\"\n>\n    <php>\n        <env name=\"TEMPORAL_ADDRESS\" value=\"127.0.0.1:7233\" />\n    </php>\n</phpunit>\n```\n\n3. Add the test server executable to `.gitignore`:\n\n```gitignore\ntemporal-test-server\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-spawn-a-child-workflow-execution-in-php.md","id":"php/how-to-spawn-a-child-workflow-execution-in-php","title":"How to spawn a Child Workflow Execution in PHP","label":"Child Workflow Execution","markdown_content":"\nBesides Activities, a Workflow can also start other Workflows.\n\n`Workflow::executeChildWorkflow` and `Workflow::newChildWorkflowStub` enables the scheduling of other Workflows from within a Workflow's implementation.\nThe parent Workflow has the ability to monitor and impact the lifecycle of the Child Workflow, similar to the way it does for an Activity that it invoked.\n\n```php\n// Use one stub per child workflow run\n$child = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    ChildWorkflowOptions::new()\n        // Do not specify WorkflowId if you want Temporal to generate a unique Id\n        // for the child execution.\n        ->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW')\n        ->withExecutionStartToCloseTimeout(DateInterval::createFromDateString('30 minutes'))\n);\n\n// This is a non blocking call that returns immediately.\n// Use yield $child->workflowMethod(name) to call synchronously.\n$promise = $child->workflowMethod('value');\n\n// Do something else here.\ntry{\n    $value = yield $promise;\n} catch(TemporalException $e) {\n    $logger->error('child workflow failed');\n    throw $e;\n}\n```\n\nLet's take a look at each component of this call.\n\nBefore calling `$child->workflowMethod()`, you must configure `ChildWorkflowOptions` for the invocation.\nThese options customize various execution timeouts, and are passed into the Workflow stub defined by the `Workflow::newChildWorkflowStub`.\nOnce stub created you can invoke its Workflow method based on attribute `WorkflowMethod`.\n\nThe method call returns immediately and returns a `Promise`.\nThis allows you to execute more code without having to wait for the scheduled Workflow to complete.\n\nWhen you are ready to process the results of the Workflow, call the `yield $promise` method on the returned promise object.\n\nWhen a parent Workflow is cancelled by the user, the Child Workflow can be cancelled or abandoned based on a configurable child policy.\n\nYou can also skip the stub part of Child Workflow initiation and use `Workflow::executeChildWorkflow` directly:\n\n```php\n// Use one stub per child workflow run\n$childResult = yield Workflow::executeChildWorkflow(\n    'ChildWorkflowName',\n    ['args'],\n    ChildWorkflowOptions::new()->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW'),\n    Type::TYPE_STRING // optional: defines the return type\n);\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-spawn-a-workflow-execution-in-php.md","id":"php/how-to-spawn-a-workflow-execution-in-php","title":"How to spawn a Workflow Execution in PHP","description":"Use the `Temporal\\Client\\WorkflowClient` to start a Workflow both synchronously and asynchronously.","label":"Workflow Execution","tags":["developer-guide","php"],"markdown_content":"\nWorkflows can be started both synchronously and asynchronously.\nYou can use typed or untyped Workflows stubs available via `Temporal\\Client\\WorkflowClient`.\nTo create a Workflow Client:\n\n```php\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$workflowClient = WorkflowClient::create(ServiceClient::create('localhost:7233'));\n```\n\n**Synchronous start**\n\nA synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the\ninvocation process and will continue executing even if the waiting process crashes or stops.\n\nBe sure to acquire the Workflow interface or class name you want to start.\nFor example:\n\n```php\n#[WorkflowInterface]\ninterface AccountTransferWorkflowInterface\n{\n    #[WorkflowMethod(name: \"MoneyTransfer\")]\n    #[ReturnType('int')]\n    public function transfer(\n        string $fromAccountId,\n        string $toAccountId,\n        string $referenceId,\n        int $amountCents\n    );\n}\n```\n\nTo start the Workflow in sync mode:\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$result = $accountTransfer->transfer(\n    'fromID',\n    'toID',\n    'refID',\n    1000\n);\n```\n\n**Asynchronous start**\n\nAn asynchronous start initiates a Workflow Execution and immediately returns to the caller without waiting for a result.\nThis is the most common way to start Workflows in a live environment.\n\nTo start a Workflow asynchronously, pass the Workflow stub instance and start parameters into the `WorkflowClient`->`start` method.\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$run = $this->workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n```\n\nAfter the Workflow is started, you can receive the Workflow Id via the `WorkflowRun` object returned by the `start` method:\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getExecution()->getID());\n```\n\n**Recurring start**\n\nYou can start a Workflow Execution on a regular schedule with [the CronSchedule option](/php/distributed-cron).\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-spawn-an-activity-execution-in-php.md","id":"php/how-to-spawn-an-activity-execution-in-php","title":"How to spawn an Activity Execution in PHP","label":"Spawn an Activity Execution","markdown_content":"\nActivity implementation is an implementation of an Activity interface.\nThe following code example, uses a constructor that takes an Amazon S3 client and a local directory, and uploads a file to the S3 bucket.\nThen, the code uses a function to download a file from the S3 bucket passing a bucket name, remote name, and local name as arguments.\nFinally, it uses a function that takes a local file name as an argument and returns a string.\n\n```php\n// An implementation of an Activity interface.\nclass FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n    private S3Client $s3Client;\n\n    private string $localDirectory;\n\n    public function __construct(S3Client $s3Client, string $localDirectory) {\n        $this->s3Client = $s3Client;\n        $this->localDirectory = $localDirectory;\n    }\n\n    // Uploading a file to S3.\n    public function upload(string $bucketName, string $localName, string $targetName): void\n    {\n        $this->s3Client->putObject(\n            $bucketName,\n            $targetName,\n            fopen($this->localDirectory . $localName, 'rb+')\n        );\n    }\n\n// Downloading a file from S3.\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->s3Client->downloadObject(\n            $bucketName,\n            $remoteName,\n            fopen($this->localDirectory .$localName, 'wb+')\n        );\n    }\n\n// A function that takes a local file name as an argument and returns a string.\n    public function processFile(string $localName): string\n    {\n        // Implementation omitted for brevity.\n        return compressFile($this->localDirectory . $localName);\n    }\n\n    public function deleteLocalFile(string $fileName): void\n    {\n        unlink($this->localDirectory . $fileName);\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-php.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-php.md","id":"php/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-php","title":"How to upsert Search Attributes in PHP","label":"Upsert Search Attributes","markdown_content":"\nTo upsert Search Attributes within a Workflow, use `Workflow::upsertSearchAttributes()`.\n\n```php\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    public function getGreeting(string $name)\n    {\n        Workflow::upsertSearchAttributes(\n            [\n                'CustomKeywordField' => 'attr1-value',\n                'CustomIntField' => 123,\n            ]\n        );\n\n        // ...\n    }\n}\n```\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/php/index.md","id":"php/index","title":"How to use the Temporal PHP SDK","description":"Add the Temporal PHP SDK to your project.","tags":["developer-guide","php"],"markdown_content":"\n[![CI Status](https://github.com/temporalio/php-sdk/workflows/Unit/badge.svg)](https://github.com/temporalio/php-sdk/actions)\n[![Stable Release](https://poser.pugx.org/temporal/sdk/version)](https://packagist.org/packages/temporal/sdk)\n[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php?ref=badge_shield)\n\nThe Temporal PHP SDK is available as composer package and can be installed using the following command in a root of your project:\n\n```bash\ncomposer require temporal/sdk\n```\n\nThe Temporal PHP SDK requires the RoadRunner 2.0 application server and supervisor to run Activities and Workflows in a scalable way.\n\nInstall RoadRunner manually by downloading its binary from the [release page](https://github.com/roadrunner-server/roadrunner/releases/tag/v1.9.2).\n\nOr install RoadRunner through the CLI:\n\n```bash\ncomposer require spiral/roadrunner:v2.0 nyholm/psr7\n./vendor/bin/rr get-binary\n```\n","is_empty":false},{"file_name":"api-reference-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/api-reference-typescript.md","id":"typescript/api-reference-typescript","title":"API reference","description":"The Temporal TypeScript SDK API reference is published on typescript.temporal.io.","label":"API reference","tags":["how-to","typescript"],"markdown_content":"\nThe Temporal TypeScript SDK API reference is published to [typescript.temporal.io](https://typescript.temporal.io).\n","is_empty":false},{"file_name":"code-samples-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/code-samples-typescript.md","id":"typescript/code-samples-typescript","title":"Code samples","description":"Use the TypeScript samples library stored on GitHub to demonstrate various capabilities of Temporal.","label":"Code samples","tags":["how-to","typescript"],"markdown_content":"\nUse the [TypeScript samples library](https://github.com/temporalio/samples-typescript) stored on GitHub to demonstrate various capabilities of Temporal.\n\n**Where can I find video demos?**\n\n[Temporal TypeScript YouTube playlist](https://www.youtube.com/playlist?list=PLl9kRkvFJrlTavecydpk9r6cF7qBmQJvb).\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript.md","id":"typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript","title":"How to add custom Search Attributes to Workflow Executions at start time in TypeScript","description":"Add custom Search Attributes to Workflow Executions at start time","label":"Add custom Search Attributes to Workflow Executions at start time","tags":["developer-guide","typescript","client"],"markdown_content":"\nUse [`WorkflowOptions.searchAttributes`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions#searchattributes).\n\n<!--SNIPSTART typescript-search-attributes-client-->\n[search-attributes/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/search-attributes/src/client.ts)\n```ts\n  const handle = await client.start(example, {\n    taskQueue: 'search-attributes',\n    workflowId: 'search-attributes-example-0',\n    searchAttributes: {\n      CustomIntField: [2],\n      CustomKeywordField: ['keywordA', 'keywordB'],\n      CustomBoolField: [true],\n      CustomDatetimeField: [new Date()],\n      CustomStringField: [\n        'String field is for text. When queried, it will be tokenized for partial match. StringTypeField cannot be used in Order By',\n      ],\n    },\n  });\n\n  const { searchAttributes } = await handle.describe();\n```\n<!--SNIPEND-->\n\nThe type of `searchAttributes` is `Record<string, string[] | number[] | boolean[] | Date[]>`.\n","is_empty":false},{"file_name":"how-to-asynchronously-complete-an-activity-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-asynchronously-complete-an-activity-in-typescript.md","id":"typescript/how-to-asynchronously-complete-an-activity-in-typescript","title":"How to asynchronously complete an Activity in TypeScript","description":"To asynchronously complete an Activity in TypeScript, set `AsyncCompletionClient` to `complete`.","label":"Asynchronously complete an Activity","tags":["typescript","how-to"],"markdown_content":"\nTo asynchronously complete an Activity, call [`AsyncCompletionClient.complete`](https://typescript.temporal.io/api/classes/client.AsyncCompletionClient#complete).\n\n<!--SNIPSTART typescript-activity-complete-async -->\n[activities-examples/src/activities/async-completion.ts](https://github.com/temporalio/samples-typescript/blob/master/activities-examples/src/activities/async-completion.ts)\n```ts\nimport { CompleteAsyncError, Context } from '@temporalio/activity';\nimport { AsyncCompletionClient } from '@temporalio/client';\n\nexport async function doSomethingAsync(): Promise<string> {\n  const taskToken = Context.current().info.taskToken;\n  setTimeout(() => doSomeWork(taskToken), 1000);\n  throw new CompleteAsyncError();\n}\n\n// this work could be done in a different process or on a different machine\nasync function doSomeWork(taskToken: Uint8Array): Promise<void> {\n  const client = new AsyncCompletionClient();\n  // does some work...\n  await client.complete(taskToken, \"Job's done!\");\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-configure-tracing-in-typescript.md","id":"typescript/how-to-configure-tracing-in-typescript","title":"How to configure tracing in TypeScript","description":"Call `MockActivityEnvironment.cancel()` to cancel an Activity Context.","label":"Configure tracing","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nThe [`interceptors-opentelemetry`](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry) sample shows how to use the SDK's built-in OpenTelemetry tracing to trace everything from starting a Workflow to Workflow Execution to running an Activity from that Workflow.\n\nThe built-in tracing uses protobuf message headers (like [this one](https://github.com/temporalio/api/blob/b2b8ae6592a8730dd5be6d90569d1aea84e1712f/temporal/api/workflowservice/v1/request_response.proto#L161) when starting a Workflow) to propagate the tracing information from the client to the Workflow and from the Workflow to its successors (when Continued As New), children, and Activities.\nAll of these executions are linked with a single trace identifier and have the proper `parent -> child` span relation.\n\nTracing is compatible between different Temporal SDKs as long as compatible [context propagators](https://opentelemetry.lightstep.com/core-concepts/context-propagation/) are used.\n\n**Context propagation**\n\nThe TypeScript SDK uses the global OpenTelemetry propagator.\n\nTo extend the default ([Trace Context](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#w3ctracecontextpropagator-propagator) and [Baggage](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#baggage-propagator) propagators) to also include the [Jaeger propagator](https://www.npmjs.com/package/@opentelemetry/propagator-jaeger), follow these steps:\n\n- `npm i @opentelemetry/propagator-jaeger`\n\n- At the top level of your Workflow code, add the following lines:\n\n  ```js\n  import { propagation } from '@opentelemetry/api';\n  import {\n    CompositePropagator,\n    W3CBaggagePropagator,\n    W3CTraceContextPropagator,\n  } from '@opentelemetry/core';\n  import { JaegerPropagator } from '@opentelemetry/propagator-jaeger';\n\n  propagation.setGlobalPropagator(\n    new CompositePropagator({\n      propagators: [\n        new W3CTraceContextPropagator(),\n        new W3CBaggagePropagator(),\n        new JaegerPropagator(),\n      ],\n    }),\n  );\n  ```\n\nSimilarly, you can customize the OpenTelemetry `NodeSDK` propagators by following the instructions in the [Initialize the SDK](https://github.com/open-telemetry/opentelemetry-js/tree/main/experimental/packages/opentelemetry-sdk-node#initialize-the-sdk) section of the `README.md` file.\n","is_empty":false},{"file_name":"how-to-connect-to-a-cluster-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-connect-to-a-cluster-in-typescript.md","id":"typescript/how-to-connect-to-a-cluster-in-typescript","title":"How to connect to a Temporal Cluster in TypeScript","description":"Connect a Temporal Client to a Cluster in the TypeScript SDK.","label":"Connect a Temporal Client","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nDeclaring the `WorkflowClient()` creates a new connection to the Temporal service.\n\nIf you omit the connection and just call the `new WorkflowClient()`, you create a default connection that works locally.\nHowever, always configure your connection and Namespace when [deploying to production](/typescript/security/#encryption-in-transit-with-mtls).\n\nUse the [`connectionOptions`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions) API available in the [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.WorkflowClient) package to create a new [`client`](https://typescript.temporal.io/api/namespaces/client/) to communicate with a Temporal Cluster.\n\nUse a new `WorkflowClient()` with the requisite gRPC [`Connection`](https://typescript.temporal.io/api/classes/client.Connection#service) to connect to a Client and set your Namespace name.\n\nUse the [`connectionOptions`](https://typescript.temporal.io/api/interfaces/client.TLSConfig) API to connect a Client with mTLS.\n\n```typescript\nimport fs from \"fs-extra\";\nimport {Connection, WorkflowClient} from \"@temporalio/client\";\nimport path = from \"path\";\n\nasync function run() {\n  const cert = await fs.readFile(\"./path-to/your.pem\");\n  const key = await fs.readFile(\"./path-to/your.key\");\n\n  const connectionOptions = {\n    address: \"your-custom-namespace.tmprl.cloud:7233\",\n    tls: {\n      clientCertPair: {\n        crt: cert,\n        key: key,\n      },\n    // serverRootCACertificatePath: \"ca.cert\",\n    },\n  };\n  const connection = await Connection.connect(connectionOptions);\n\n  const client = new WorkflowClient({\n    connection,\n    // connects to 'default' namespace if not specified\n    namespace: \"your-custom-namespace\",\n  });\n\n    // . . .\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-continue-as-new-in-typescript.md","id":"typescript/how-to-continue-as-new-in-typescript","title":"How to Continue-As-New in TypeScript","description":"To Continue-As-New, use `continueAsNew`.","label":"Continue-As-New","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo cause a Workflow Execution to [Continue-As-New](/concepts/what-is-continue-as-new), the Workflow function should return the result of the [`continueAsNew`](https://typescript.temporal.io/api/namespaces/workflow#continueasnew).\n\n<!--SNIPSTART typescript-continue-as-new-workflow -->\n[continue-as-new/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/continue-as-new/src/workflows.ts)\n```ts\nimport { continueAsNew, sleep } from '@temporalio/workflow';\n\nexport async function loopingWorkflow(iteration = 0): Promise<void> {\n  if (iteration === 10) {\n    return;\n  }\n  console.log('Running Workflow iteration:', iteration);\n  await sleep(1000);\n  // Must match the arguments expected by `loopingWorkflow`\n  await continueAsNew<typeof loopingWorkflow>(iteration + 1);\n  // Unreachable code, continueAsNew is like `process.exit` and will stop execution once called.\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-create-a-temporal-client-in-typescript.md","id":"typescript/how-to-create-a-temporal-client-in-typescript","title":"How to create a Temporal Client in TypeScript","description":"Create a Temporal Client","label":"Create a Temporal Client","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nUse a new `WorkflowClient()` with the requisite gRPC [`Connection`](https://typescript.temporal.io/api/classes/client.Connection#service) to create a new Client.\n\n```typescript\nimport { Connection, WorkflowClient } from '@temporalio/client';\nconst connection = await Connection.connect(); // to configure for production\nconst client = new WorkflowClient({ connection });\n```\n\nDeclaring the `WorkflowClient()` creates a new connection to the Temporal service.\n\nIf you omit the connection and just call the `new WorkflowClient()`, you create a default connection that works locally.\nHowever, always configure your connection and Namespace when [deploying to production](/typescript/security/#encryption-in-transit-with-mtls).\n\nThe following example, creates a Client, connects to an account, and declares your Namespace.\n\n```typescript\nimport { Connection, WorkflowClient } from '@temporalio/client';\n\nconst connection = await Connection.connect({\n  address: '<Namespace_ID>.tmprl.cloud',\n});\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'your.namespace',\n});\n```\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-customize-activity-type-in-typescript.md","id":"typescript/how-to-customize-activity-type-in-typescript","title":"How to customize Activity Type in TypeScript","description":"Customize Activity Type","label":"Customize Activity Type","tags":["developer-guide","typescript"],"markdown_content":"\nYou can customize the name of the Activity when you register it with the Worker.\nIn the following example, the Activity Name is `activityFoo`.\n\n<!--SNIPSTART typescript-custom-activity-type -->\n[snippets/src/worker-activity-type-custom.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/worker-activity-type-custom.ts)\n```ts\nimport { Worker } from '@temporalio/worker';\nimport { greet } from './activities';\n\nasync function run() {\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'snippets',\n    activities: {\n      activityFoo: greet,\n    },\n  });\n\n  await worker.run();\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-customize-workflow-type-in-typescript.md","id":"typescript/how-to-customize-workflow-type-in-typescript","title":"How to customize Workflow Type in TypeScript","description":"Customize Workflow Type","label":"Customize Workflow Type","tags":["developer-guide","typescript"],"markdown_content":"\nIn TypeScript, the Workflow Type is the Workflow function name and there isn't a mechanism to customize the Workflow Type.\n\nIn the following example, the Workflow Type is the name of the function, `helloWorld`.\n\n<!--SNIPSTART typescript-workflow-type -->\n[snippets/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/workflows.ts)\n```ts\nexport async function helloWorld(): Promise<string> {\n  return '👋 Hello World!';\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-define-a-query-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-define-a-query-in-typescript.md","id":"typescript/how-to-define-a-query-in-typescript","title":"How to define a Query in TypeScript","description":"Use `defineQuery` to define a Query method for a Workflow.","label":"Define Query","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nUse [`defineQuery`](https://typescript.temporal.io/api/namespaces/workflow/#definequery) to define the name, parameters, and return value of a Query.\n\n<!--SNIPSTART typescript-define-query -->\n[state/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/state/src/workflows.ts)\n```ts\nimport { defineQuery } from '@temporalio/workflow';\n\nexport const getValueQuery = defineQuery<number | undefined, [string]>('getValue');\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-define-a-signal-in-typescript.md","id":"typescript/how-to-define-a-signal-in-typescript","title":"How to define a Signal in TypeScript","description":"Define Signal","label":"Define Signal","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`defineSignal`](https://typescript.temporal.io/api/namespaces/workflow/#definesignal)\n\n```ts\nimport { defineSignal } from '@temporalio/workflow';\n\ninterface JoinInput {\n  userId: string;\n  groupId: string;\n}\n\nexport const joinSignal = defineSignal<[JoinInput]>('join');\n```\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-define-activity-parameters-in-typescript.md","id":"typescript/how-to-define-activity-parameters-in-typescript","title":"How to define Activity Parameters in TypeScript","description":"Activity Parameters.","label":"Activity Parameters","tags":["developer-guide","go"],"markdown_content":"\nThis Activity takes a single `name` parameter of type `string`.\n\n<!--SNIPSTART typescript-activity-fn -->\n[snippets/src/activities.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/activities.ts)\n```ts\nexport async function greet(name: string): Promise<string> {\n  return `👋 Hello, ${name}!`;\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-define-activity-return-values-in-typescript.md","id":"typescript/how-to-define-activity-return-values-in-typescript","title":"How to define Activity Return Values in TypeScript","description":"Define Activity Return Values","label":"Define Activity Return Values","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nIn TypeScript, the return value is always a Promise.\n\nIn the following example, `Promise<string>` is the return value.\n\n```typescript\nexport async function greet(name: string): Promise<string> {\n  return `👋 Hello, ${name}!`;\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-define-workflow-parameters-in-typescript.md","id":"typescript/how-to-define-workflow-parameters-in-typescript","title":"How to define Workflow parameters in TypeScript","description":"Define Workflow parameters","label":"Define Workflow parameters","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nYou can define and pass parameters in your Workflow. In this example, you define your arguments in your `client.ts` file and pass those parameters to `workflow.ts` through your Workflow function.\n\nStart a Workflow with the parameters that are in the `client.ts` file. In this example we set the `name` parameter to `Temporal` and `born` to `2019`. Then set the Task Queue and Workflow Id.\n\n`client.ts`\n\n```typescript\nimport { example } from './workflows';\n\n...\nawait client.start(example, {\n  args: [{ name: 'Temporal', born: 2019 }],\n  taskQueue: 'your-queue',\n  workflowId: 'business-meaningful-id',\n});\n```\n\nIn `workflows.ts` define the type of the parameter that the Workflow function takes in. The interface `ExampleParam` is a name we can now use to describe the requirement in the previous example. It still represents having the two properties called `name` and `born` that is of the type `string`. Then define a function that takes in a parameter of the type `ExampleParam` and return a `Promise<string>`. The `Promise` object represents the eventual completion, or failure, of `await client.start()` and its resulting value.\n\n```ts\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({ name, born }: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-define-workflow-return-values-in-typescript.md","id":"typescript/how-to-define-workflow-return-values-in-typescript","title":"How to define Workflow return values in TypeScript","description":"Define Workflow return values","label":"Define Workflow return values","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo return a value of the Workflow function, use `Promise<something>`. The `Promise` is used to make asynchronous calls and comes with guarantees.\n\nThe following example uses a `Promise<string>` to eventually return a `name` and `born` parameter.\n\n```typescript\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({ name, born }: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-develop-a-worker-program-in-typescript.md","id":"typescript/how-to-develop-a-worker-program-in-typescript","title":"How to develop a Worker program in TypeScript","description":"Develop a Worker program","label":"Develop a Worker program","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nCreate a Worker with `Worker.create()` (which establishes the initial gRPC connection), then call `worker.run()` on it (to start polling the Task Queue).\n\nBelow is an example of starting a Worker that polls the Task Queue named `tutorial`.\n\n<!--SNIPSTART typescript-hello-worker {\"enable_source_link\": false}-->\n```ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  // Step 1: Register Workflows and Activities with the Worker and connect to\n  // the Temporal server.\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    activities,\n    taskQueue: 'hello-world',\n  });\n  // Worker connects to localhost by default and uses console.error for logging.\n  // Customize the Worker by passing more options to create():\n  // https://typescript.temporal.io/api/classes/worker.Worker\n  // If you need to configure server connection parameters, see docs:\n  // https://docs.temporal.io/typescript/security#encryption-in-transit-with-mtls\n\n  // Step 2: Start accepting tasks on the `hello-world` queue\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n<!--SNIPEND-->\n\n`taskQueue` is the only required option, but you will also use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nA full example for Workers looks like this:\n\n```typescript\nimport { NativeConnection, Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  const connection = await NativeConnection.connect({\n    // defaults port to 7233 if not specified\n    address: 'foo.bar.tmprl.cloud',\n    tls: {\n      // set to true if TLS without mTLS\n      // See docs for other TLS options\n      clientCertPair: {\n        crt: clientCert,\n        key: clientKey,\n      },\n    },\n  });\n\n  const worker = await Worker.create({\n    connection,\n    namespace: 'foo.bar', // as explained in Namespaces section\n    // ...\n  });\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\nSee below for more Worker options.\n\n**Workflow and Activity registration**\n\nWorkers bundle Workflow code and `node_modules` using Webpack v5 and execute them inside V8 isolates.\nActivities are directly required and run by Workers in the Node.js environment.\n\nWorkers are very flexible – you can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers in a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker. Not the path.\n- Workflow bundle:\n- Either specify a `workflowsPath` to your `workflows.ts` file to pass to Webpack, e.g., `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n- Or pass a prebuilt bundle to `workflowBundle` instead if you prefer to handle the bundling yourself.\n\n**Additional Worker Options**\n\nThis is a selected subset of options you are likely to use. Even more advanced options, particularly for performance tuning, are available in [the API reference](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions).\n\n| Options         | Description                                                                                                                           |\n| --------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| `dataConverter` | Encodes and decodes data entering and exiting a Temporal Server. Supports `undefined`, `UintBArray`, and JSON.                        |\n| `sinks`         | Allows injection of Workflow Sinks (Advanced feature: see [Logging docs](/typescript/logging))                                        |\n| `interceptors`  | A mapping of interceptor type to a list of factories or module paths (Advanced feature: see [Interceptors](/typescript/interceptors)) |\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-develop-a-workflow-definition-in-typescript.md","id":"typescript/how-to-develop-a-workflow-definition-in-typescript","title":"How to develop a Workflow Definition in TypeScript","description":"Workflow Definitions are exported async functions in Typescript.","label":"Develop a Workflow Definition","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nIn the Temporal TypeScript SDK programming model, Workflow Definitions are _just functions_, which can store state and orchestrate Activity Functions.\nThe following code snippet uses `proxyActivities` to schedule a `greet` Activity in the system to say hello.\n\nA Workflow Definition can have multiple parameters; however, we recommend using a single object parameter.\n\n```typescript\ntype ExampleArgs = {\n  name: string;\n};\n\nexport async function example(\n  args: ExampleArgs,\n): Promise<{ greeting: string }> {\n  const greeting = await greet(args.name);\n  return { greeting };\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-develop-an-activity-definition-in-typescript.md","id":"typescript/how-to-develop-an-activity-definition-in-typescript","title":"How to develop an Activity Definition in TypeScript","description":"Develop an Activity Definition","label":"Develop an Activity Definition","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n- Activities execute in the standard Node.js environment.\n- Activities cannot be in the same file as Workflows and must be separately registered.\n- Activities may be retried repeatedly, so you may need to use idempotency keys for critical side effects.\n\nActivities are _just functions_. The following is an Activity that accepts a string parameter and returns a string.\n\n<!--SNIPSTART typescript-activity-fn -->\n[snippets/src/activities.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/activities.ts)\n```ts\nexport async function greet(name: string): Promise<string> {\n  return `👋 Hello, ${name}!`;\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-emit-metrics-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-emit-metrics-typescript.md","id":"typescript/how-to-emit-metrics-typescript","title":"How to emit metrics in TypeScript","description":"Emit metrics","label":"Emit metrics","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWorkers can emit metrics and traces. There are a few [telemetry options](https://typescript.temporal.io/api/interfaces/worker.TelemetryOptions) that can be provided to [`Runtime.install`](https://typescript.temporal.io/api/classes/worker.Runtime/#install). The common options are:\n\n- `metrics: { otel: { url } }`: The URL of a gRPC [OpenTelemetry collector](https://opentelemetry.io/docs/collector/).\n- `metrics: { prometheus: { bindAddress } }`: Address on the Worker host that will have metrics for [Prometheus](https://prometheus.io/) to scrape.\n\nTo set up tracing of Workflows and Activities, use our [opentelemetry-interceptors](/typescript/logging#opentelemetry-tracing) package.\n\n```typescript\ntelemetryOptions: {\n    metrics: {\n      prometheus: { bindAddress: '0.0.0.0:9464' },\n    },\n    logging: { forward: { level: 'DEBUG' } },\n  },\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript.md","id":"typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript","title":"How to get the result of a Workflow Execution in TypeScript","description":"Get the result of a Workflow Execution","label":"Workflow result","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo return the results of a Workflow Execution:\n\n```typescript\nreturn (\n  'Completed '\n  + wf.workflowInfo().workflowId\n  + ', Total Charged: '\n  + totalCharged\n);\n```\n\n`totalCharged` is just a function declared in your code. For a full example, see [subscription-workflow-project-template-typescript/src/workflows.ts](https://github.com/temporalio/subscription-workflow-project-template-typescript/blob/main/src/workflows.ts).\n\nA Workflow function may return a result. If it doesn’t (in which case the return type is `Promise<void>`), the result will be `undefined`.\n\nIf you started a Workflow with `handle.start()`, you can choose to wait for the result anytime with `handle.result()`.\n\n```typescript\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nUsing a Workflow Handle isn't necessary with `client.execute()`.\n\nWorkflows that prematurely end will throw a `WorkflowFailedError` if you call `result()`.\n\nIf you call `result()` on a Workflow that prematurely ended for some reason, it throws a [`WorkflowFailedError` error](https://typescript.temporal.io/api/classes/client.WorkflowFailedError/) that reflects the reason. For that reason, it is recommended to catch that error.\n\n```typescript\nconst handle = client.getHandle(workflowId);\ntry {\n  const result = await handle.result();\n} catch (err) {\n  if (err instanceof WorkflowFailedError) {\n    throw new Error('Temporal workflow failed: ' + workflowId, {\n      cause: err,\n    });\n  } else {\n    throw new Error('error from Temporal workflow ' + workflowId, {\n      cause: err,\n    });\n  }\n}\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-get-the-result-of-an-activity-execution-in-typescript.md","id":"typescript/how-to-get-the-result-of-an-activity-execution-in-typescript","title":"How to get the result of an Activity Execution in TypeScript","description":"Get the result of an Activity Execution","label":"Get the result of an Activity Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nSince Activities are referenced by their string name, you can reference them dynamically to get the result of an Activity Execution.\n\n```typescript\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts['activity1']();\n\n  let result = await acts[activityName](...args);\n  return result;\n}\n```\n\nThe `proxyActivities()` returns an object that calls the Activities in the function. `acts[activityName]()` references the Activity using the Activity name, then it returns the results.\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-handle-a-query-in-a-workflow-in-typescript.md","id":"typescript/how-to-handle-a-query-in-a-workflow-in-typescript","title":"How to handle a Query in a Workflow in TypeScript","description":"To handle a Query in a Workflow, define a Query handler method using the `handle.query(query, ...args)` annotation in the Workflow interface.","label":"Handle Query","tags":["typescript","developer-guide"],"markdown_content":"\nUse [`handleQuery`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInboundCallsInterceptor/#handlequery) to handle Queries inside a Workflow.\n\nYou make a Query with `handle.query(query, ...args)`. A Query needs a return value, but can also take arguments.\n\n<!--SNIPSTART typescript-handle-query -->\n[state/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/state/src/workflows.ts)\n```ts\nexport async function trackState(): Promise<void> {\n  const state = new Map<string, number>();\n  setHandler(setValueSignal, (key, value) => void state.set(key, value));\n  setHandler(getValueQuery, (key) => state.get(key));\n  await CancellationScope.current().cancelRequested;\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-handle-a-signal-in-typescript.md","id":"typescript/how-to-handle-a-signal-in-typescript","title":"How to handle a Signal in TypeScript","description":"Handle Signal","label":"Handle Signal","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`setHandler`](https://typescript.temporal.io/api/namespaces/workflow/#sethandler)\n\n```ts\nimport { setHandler } from '@temporalio/workflow';\n\nexport async function yourWorkflow() {\n  const groups = new Map<string, Set<string>>();\n\n  setHandler(joinSignal, ({ userId, groupId }: JoinInput) => {\n    const group = groups.get(groupId);\n    if (group) {\n      group.add(userId);\n    } else {\n      groups.set(groupId, new Set([userId]));\n    }\n  });\n}\n```\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-heartbeat-an-activity-in-typescript.md","id":"typescript/how-to-heartbeat-an-activity-in-typescript","title":"How to Heartbeat an Activity in TypeScript","description":"Heartbeat Activities to track their progress and get details of the Activity Execution.","label":"Activity Heartbeat","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nLong-running Activities should Heartbeat their progress back to the Workflow for earlier detection of stalled Activities (with [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout)) and resuming stalled Activities from checkpoints (with Heartbeat details).\n\nTo set Activity Heartbeat, use `Context.current().heartbeat()` in your Activity implementation, and set `heartbeatTimeout` in your Workflow.\n\n```ts\n// activity implementation\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  for (let progress = 1; progress <= 1000; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    // record activity heartbeat\n    Context.current().heartbeat();\n  }\n}\n\n// ...\n\n// workflow code calling activity\nconst { example } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 hour',\n  heartbeatTimeout: '10s',\n});\n```\n\nIn the previous example, setting the Heartbeat informs the Temporal Server of the Activity's progress at regular intervals.\nIf the Activity stalls or the Activity Worker becomes unavailable, the absence of Heartbeats prompts the Temporal Server to retry the Activity immediately, without waiting for `startToCloseTimeout` to complete.\n\nYou can also add `heartbeatDetails` as a checkpoint to collect data about failures during the execution, and use it to resume the Activity from that point.\n\nThe following example extends the previous sample to include a `heartbeatDetails` checkpoint.\n\n```ts\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  const startingPoint = Context.current().info.heartbeatDetails || 1; // allow for resuming from heartbeat\n  for (let progress = startingPoint; progress <= 100; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    Context.current().heartbeat(progress);\n  }\n}\n```\n\nIn this example, when the `heartbeatTimeout` is reached and the Activity is retried, the Activity Worker picks up the execution from where the previous attempt left off.\n","is_empty":false},{"file_name":"how-to-list-search-attributes-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-list-search-attributes-in-typescript.md","id":"typescript/how-to-list-search-attributes-in-typescript","title":"How to list Search Attributes in TypeScript","description":"List Search Attributes","label":"List Search Attributes","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n**Listing**\n\nFor now, we can call [`client.service.listWorkflowExecutions()`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.WorkflowService-1#listworkflowexecutions). A friendlier `client.listWorkflows()` function that does Payload decoding is planned.\n\n```ts\nconst { executions, nextPageToken } = await client.service\n  .listWorkflowExecutions(\n    {\n      namespace: 'default',\n      ...(input || {}),\n    },\n  );\nconst decodedWorkflows = executions.map(\n  ({\n    execution,\n    type,\n    startTime,\n    closeTime,\n    status,\n    historyLength,\n    parentNamespaceId,\n    parentExecution,\n    executionTime,\n    memo: memoRaw,\n    searchAttributes: searchAttributesRaw,\n    // autoResetPoints,\n    taskQueue,\n    stateTransitionCount,\n  }) => {\n    let memo: Record<string, unknown> | undefined | null = null;\n    let searchAttributes: Record<string, unknown> | undefined | null = null;\n\n    try {\n      memo = mapFromPayloads(defaultConverter, memoRaw?.fields);\n      searchAttributes = mapFromPayloads(\n        searchAttributeConverter,\n        searchAttributesRaw?.indexedFields,\n      );\n    } catch (e) {\n      // unable to convert with default converter\n    }\n\n    return {\n      id: execution!.workflowId,\n      runId: execution!.runId,\n      type: type!.name,\n      status: status!,\n      taskQueue: taskQueue!,\n      historyLength: historyLength!.toInt(),\n      startTime: tsToDate(startTime!),\n      executionTime: tsToDate(executionTime!),\n      closeTime: optionalTsToDate(closeTime),\n      parentExecution,\n      parentNamespace: parentNamespaceId || null, // convert empty string to null\n      memo: memo && Object.keys(memo!).length === 0 ? null : memo, // convert empty object to null\n      searchAttributes,\n      stateTransitionCount: stateTransitionCount!.toInt(),\n    } as unknown as Workflow;\n  },\n);\n```\n","is_empty":false},{"file_name":"how-to-list-workflow-executions-using-the-client-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-list-workflow-executions-using-the-client-in-typescript.md","id":"typescript/how-to-list-workflow-executions-using-the-client-in-typescript","title":"How to list Workflow Executions using the Client in TypeScript","description":"List Workflow Executions using the Client","label":"List Workflow Executions using the Client","tags":["developer-guide","typescript","client"],"markdown_content":"\nUse [`WorkflowService.listWorkflowExecutions`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#listworkflowexecutions):\n\n```typescript\nimport { Connection } from '@temporalio/client';\n\nconst connection = await Connection.connect();\nconst response = await connection.workflowService.listWorkflowExecutions({\n  query: `ExecutionStatus = \"Running\"`,\n});\n```\n\nwhere `query` is a [List Filter](/concepts/what-is-a-list-filter/).\n","is_empty":false},{"file_name":"how-to-listen-to-heartbeats-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-listen-to-heartbeats-in-typescript.md","id":"typescript/how-to-listen-to-heartbeats-in-typescript","title":"How to listen to Heartbeats in TypeScript","description":"Listen to Heartbeats","label":"Listen to Heartbeats","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`MockActivityEnvironment`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment) is an [`EventEmitter`](https://nodejs.org/api/events.html#class-eventemitter) that emits a `heartbeat` event that you can use to listen for Heartbeats emitted by the Activity.\n\nWhen an Activity is run by a Worker, Heartbeats are throttled to avoid overloading the server.\n`MockActivityEnvironment`, however, does not throttle Heartbeats.\n\n```ts\nimport { Context } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport assert from 'assert';\n\nasync function activityFoo(): Promise<void> {\n  Context.current().heartbeat(6);\n}\n\nconst env = new MockActivityEnvironment();\n\nenv.on('heartbeat', (d: unknown) => {\n  assert(d === 6);\n});\n\nawait env.run(activityFoo);\n```\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-log-from-a-workflow-in-typescript.md","id":"typescript/how-to-log-from-a-workflow-in-typescript","title":"How to log from a Workflow in TypeScript","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","typescript","log"],"markdown_content":"\nLogging from Workflows is tricky for two reasons:\n\n1. Workflows run in a sandboxed environment and cannot do any I/O.\n1. Workflow code might get replayed at any time, generating duplicate log messages.\n\nTo work around these limitations, we recommend using the Sinks feature in the TypeScript SDK.\nSinks enable one-way export of logs, metrics, and traces from the Workflow isolate to the Node.js environment.\n\n<!--\nWorkflows in Temporal may be replayed from the beginning of their history when resumed. In order for Temporal to recreate the exact state Workflow code was in, the code is required to be fully deterministic. To prevent breaking [determinism](/typescript/determinism), in the TypeScript SDK, Workflow code runs in an isolated execution environment and may not use any of the Node.js APIs or communicate directly with the outside world. -->\n\nSinks are written as objects with methods. Similar to Activities, they are declared in the Worker and then proxied in Workflow code, and it helps to share types between both.\n\n<details>\n  <summary>Comparing Sinks, Activities and Interceptors</summary>\n\nSinks are similar to Activities in that they are both registered on the Worker and proxied into the Workflow.\nHowever, they differ from Activities in important ways:\n\n- Sink functions don't return any value back to the Workflow and cannot not be awaited.\n- Sink calls are not recorded in Workflow histories (no timeouts or retries).\n- Sink functions are _always_ run on the same Worker that runs the Workflow they are called from.\n\n</details>\n\n**Declaring the Sink Interface**\n\nExplicitly declaring a Sink's interface is optional, but is useful for ensuring type safety in subsequent steps:\n\n<!--SNIPSTART typescript-logger-sink-interface-->\n[packages/test/src/workflows/definitions.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/definitions.ts)\n```ts\nimport type { Sinks } from '@temporalio/workflow';\n\nexport interface LoggerSinks extends Sinks {\n  logger: {\n    info(message: string): void;\n  };\n}\n```\n<!--SNIPEND-->\n\n**Implementing Sinks**\n\nImplementing Sinks is a two-step process.\n\nImplement and inject the Sink function into a Worker\n\n<!--SNIPSTART typescript-logger-sink-worker-->\n[sinks/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/sinks/src/worker.ts)\n```ts\nimport { defaultSinks, InjectedSinks, Worker } from '@temporalio/worker';\nimport { MySinks } from './workflows';\n\nasync function main() {\n  const sinks: InjectedSinks<MySinks> = {\n    ...defaultSinks(),\n    alerter: {\n      alert: {\n        fn(workflowInfo, message) {\n          console.log(`sending SMS alert!\nworkflow: ${workflowInfo.runId}\nmessage: ${message}`);\n        },\n        callDuringReplay: false, // The default\n      },\n    },\n  };\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'sinks',\n    sinks,\n  });\n  await worker.run();\n  console.log('Worker gracefully shutdown');\n}\n\nmain().then(\n  () => void process.exit(0),\n  (err) => {\n    console.error(err);\n    process.exit(1);\n  }\n);\n```\n<!--SNIPEND-->\n\n- Sink function implementations are passed as an object into [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions/#sinks)\n- You can specify whether you want the injected function to be called during Workflow replay by setting the `callDuringReplay` boolean option.\n\n**Proxy and call a Sink function from a Workflow**\n\n<!--SNIPSTART typescript-logger-sink-workflow-->\n[packages/test/src/workflows/log-sample.ts](https://github.com/temporalio/sdk-typescript/blob/master/packages/test/src/workflows/log-sample.ts)\n```ts\nimport * as wf from '@temporalio/workflow';\nimport { LoggerSinks } from './definitions';\n\nconst { logger } = wf.proxySinks<LoggerSinks>();\n\nexport async function logSampleWorkflow(): Promise<void> {\n  logger.info('Workflow execution started');\n}\n```\n<!--SNIPEND-->\n\nSome important features of the [InjectedSinkFunction](https://typescript.temporal.io/api/interfaces/worker.InjectedSinkFunction) interface:\n\n- **Injected WorkflowInfo argument**: The first argument of a Sink function implementation is a [`workflowInfo` object](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo/) that contains useful metadata.\n- **Limited arguments types**: The remaining Sink function arguments are copied between the sandbox and the Node.js environment using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n- **No return value**: To prevent breaking determinism, Sink functions cannot return values to the Workflow.\n\n**Advanced: Performance considerations and non-blocking Sinks**\n\nThe injected sink function contributes to the overall Workflow Task processing duration.\n\n- If you have a long-running sink function, such as one that tries to communicate with external services, you might start seeing Workflow Task timeouts.\n- The effect is multiplied when using `callDuringReplay: true` and replaying long Workflow histories because the Workflow Task timer starts when the first history page is delivered to the Worker.\n","is_empty":false},{"file_name":"how-to-mock-activities-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-mock-activities-in-typescript.md","id":"typescript/how-to-mock-activities-in-typescript","title":"How to mock Activities in TypeScript","description":"Mock Activities","label":"Mock Activities","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nImplement only the relevant Activities for the Workflow being tested.\n\n```ts\nimport type * as activities from './activities';\n\n// Creating a mock object of the activities.\nconst mockActivities: Partial<typeof activities> = {\n  makeHTTPRequest: async () => '99',\n};\n\n// Creating a worker with the mocked activities.\nconst worker = await Worker.create({\n  activities: mockActivities,\n  // ...\n});\n```\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-register-types-with-a-worker-in-typescript.md","id":"typescript/how-to-register-types-with-a-worker-in-typescript","title":"How to register types with a Worker in TypeScript","description":"Register types.","label":"Register Types","tags":["developer-guide","typescript","workers"],"markdown_content":"\nIn development, use [`workflowsPath`](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions/#workflowspath):\n\n<!--SNIPSTART typescript-worker-create -->\n[snippets/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/worker.ts)\n```ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'snippets',\n    activities,\n  });\n\n  await worker.run();\n}\n```\n<!--SNIPEND-->\n\nIn this snippet, the Worker bundles the Workflow code at runtime.\n\nIn production, you can improve your Worker's startup time by bundling in advance: as part of your production build, call [`bundleWorkflowCode`](/typescript/workers#prebuilt-workflow-bundles):\n\n<!--SNIPSTART typescript-bundle-workflow -->\n[production/src/scripts/build-workflow-bundle.ts](https://github.com/temporalio/samples-typescript/blob/master/production/src/scripts/build-workflow-bundle.ts)\n```ts\nimport { bundleWorkflowCode } from '@temporalio/worker';\nimport { writeFile } from 'fs/promises';\nimport path from 'path';\n\nasync function bundle() {\n  const { code } = await bundleWorkflowCode({\n    workflowsPath: require.resolve('../workflows'),\n  });\n  const codePath = path.join(__dirname, '../../workflow-bundle.js');\n\n  await writeFile(codePath, code);\n  console.log(`Bundle written to ${codePath}`);\n}\n```\n<!--SNIPEND-->\n\nThen the bundle can be passed to the Worker:\n\n<!--SNIPSTART typescript-production-worker-->\n[production/src/worker.ts](https://github.com/temporalio/samples-typescript/blob/master/production/src/worker.ts)\n```ts\nconst workflowOption = () =>\n  process.env.NODE_ENV === 'production'\n    ? {\n        workflowBundle: {\n          codePath: require.resolve('../workflow-bundle.js'),\n        },\n      }\n    : { workflowsPath: require.resolve('./workflows') };\n\nasync function run() {\n  const worker = await Worker.create({\n    ...workflowOption(),\n    activities,\n    taskQueue: 'production-sample',\n  });\n\n  await worker.run();\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript.md","id":"typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript","title":"How to remove Search Attributes from a Workflow in TypeScript","description":"How to remove Search Attributes from a Workflow","label":"Remove Search Attributes from a Workflow","tags":["developer-guide","typescript","client"],"markdown_content":"\n```typescript\nimport { upsertSearchAttributes } from '@temporalio/workflow';\n\nasync function yourWorkflow() {\n  upsertSearchAttributes({ CustomIntField: [1, 2, 3] });\n\n  // ... later, to remove:\n  upsertSearchAttributes({ CustomIntField: [] });\n}\n```\n","is_empty":false},{"file_name":"how-to-replay-a-workflow-execution-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-replay-a-workflow-execution-in-typescript.md","id":"typescript/how-to-replay-a-workflow-execution-in-typescript","title":"How to replay a Workflow Execution in TypeScript","description":"Replay a Workflow Execution","label":"Replay a Workflow Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nRetrieve Event History with [`WorkflowService.getWorkflowExecutionHistory`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#getworkflowexecutionhistory).\n\n<!--SNIPSTART typescript-history-get-workflowhistory-->\n[replay-history/src/replayer.ts](https://github.com/temporalio/samples-typescript/blob/master/replay-history/src/replayer.ts)\n```ts\n  const conn = await Connection.connect(/* { address: 'temporal.prod.company.com' } */);\n  const { history } = await conn.workflowService.getWorkflowExecutionHistory({\n    namespace: 'default',\n    execution: {\n      workflowId: 'calc',\n    },\n  });\n```\n<!--SNIPEND-->\n\nThen call [`Worker.runReplayHistory`](https://typescript.temporal.io/api/classes/worker.worker/#runreplayhistory).\n\n<!--SNIPSTART typescript-history-replay-->\n[replay-history/src/replayer.ts](https://github.com/temporalio/samples-typescript/blob/master/replay-history/src/replayer.ts)\n```ts\n  await Worker.runReplayHistory(\n    {\n      workflowsPath: require.resolve('./workflows'),\n      replayName: 'calc',\n    },\n    history\n  );\n```\n<!--SNIPEND-->\n\nIf the Workflow code isn’t compatible with the Event History, `runReplayHistory` throws a [`DeterminismViolationError`](https://typescript.temporal.io/api/classes/workflow.determinismviolationerror/).\n","is_empty":false},{"file_name":"how-to-run-an-activity-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-run-an-activity-in-typescript.md","id":"typescript/how-to-run-an-activity-in-typescript","title":"How to Run an Activity when testing in isolation in TypeScript","description":"Use `MockActivityEnvironment.run()` to run a function in an Activity Context.","label":"Run an Activity when testing in isolation","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nFirst, create a [`MockActivityEnvironment`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment).\nThe constructor accepts an optional partial Activity [`Info`](https://typescript.temporal.io/api/classes/activity.Info) object in case any info fields are needed for the test.\n\nThen use [`MockActivityEnvironment.run()`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment#run) to run a function in an Activity [Context](https://typescript.temporal.io/api/classes/activity.Context).\n\n```ts\nimport { Context } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport assert from 'assert';\n\n// A function that takes two numbers and returns a promise that resolves to the sum of the two numbers\n// and the current attempt.\nasync function activityFoo(a: number, b: number): Promise<number> {\n  return a + b + Context.current().info.attempt;\n}\n\n// Create a MockActivityEnvironment with attempt set to 2. Run the activityFoo\n// function with parameters 5 and 35. Assert that the result is 42.\nconst env = new MockActivityEnvironment({ attempt: 2 });\nconst result = await env.run(activityFoo, 5, 35);\nassert.equal(result, 42);\n```\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-send-a-query-to-a-workflow-in-typescript.md","id":"typescript/how-to-send-a-query-to-a-workflow-in-typescript","title":"How to send a Query to a Workflow in TypeScript","description":"Use `WorkflowHandle.query` to query a running or completed Workflow.","label":"Send a Query","tags":["typescript","developer-guide"],"markdown_content":"\nUse [`WorkflowHandle.query`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle/#query) to query a running or completed Workflow.\n\n<!--SNIPSTART typescript-send-query -->\n[state/src/query-workflow.ts](https://github.com/temporalio/samples-typescript/blob/master/state/src/query-workflow.ts)\n```ts\nimport { WorkflowClient } from '@temporalio/client';\nimport { getValueQuery } from './workflows';\n\nasync function run(): Promise<void> {\n  const client = new WorkflowClient();\n  const handle = client.getHandle('state-id-0');\n  const meaning = await handle.query(getValueQuery, 'meaning-of-life');\n  console.log({ meaning });\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-send-a-signal-from-a-client-in-typescript.md","id":"typescript/how-to-send-a-signal-from-a-client-in-typescript","title":"How to send a Signal from a Client in TypeScript","description":"Send a Signal from Client","label":"Send a Signal from Client","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`WorkflowHandle.signal`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#signal)\n\n```typescript\nimport { WorkflowClient } from '@temporalio/client';\nimport { joinSignal } from './workflows';\n\nconst client = new WorkflowClient();\n\nconst handle = client.getHandle('workflow-id-123');\n\nawait handle.signal(joinSignal, { userId: 'user-1', groupId: 'group-1' });\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-send-a-signal-from-a-workflow-in-typescript.md","id":"typescript/how-to-send-a-signal-from-a-workflow-in-typescript","title":"How to send a Signal from Workflow in TypeScript","description":"Send a Signal from Workflow","label":"Send a Signal from Workflow","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`getExternalWorkflowHandle`](https://typescript.temporal.io/api/namespaces/workflow#getexternalworkflowhandle)\n\n```typescript\nimport { getExternalWorkflowHandle } from '@temporalio/workflow';\nimport { joinSignal } from './other-workflow';\n\nexport async function yourWorkflowThatSignals() {\n  const handle = getExternalWorkflowHandle('workflow-id-123');\n  await handle.signal(joinSignal, { userId: 'user-1', groupId: 'group-1' });\n}\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-send-a-signal-with-start-in-typescript.md","id":"typescript/how-to-send-a-signal-with-start-in-typescript","title":"How to send a Signal with Start in TypeScript","description":"Send a Signal with Start","label":"Send a Signal with Start","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`WorkflowClient.signalWithStart`](https://typescript.temporal.io/api/classes/client.WorkflowClient#signalwithstart)\n\n```typescript\nimport { WorkflowClient } from '@temporalio/client';\nimport { joinSignal, yourWorkflow } from './workflows';\n\nconst client = new WorkflowClient();\n\nawait client.signalWithStart(yourWorkflow, {\n  workflowId: 'workflow-id-123',\n  args: [{ foo: 1 }],\n  signal: joinSignal,\n  signalArgs: [{ userId: 'user-1', groupId: 'group-1' }],\n});\n```\n","is_empty":false},{"file_name":"how-to-send-logs-from-activities-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-send-logs-from-activities-in-typescript.md","id":"typescript/how-to-send-logs-from-activities-in-typescript","title":"How to send logs from Activities in TypeScript","description":"Send logs from Activities","label":"Send logs from Activities","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nActivities run in the standard Node.js environment and can use any Node.js logger.\n\n<details>\n<summary>\nInject Activity context via interceptor and log all Activity Executions\n</summary>\n\n<!--SNIPSTART typescript-activity-logging-interceptor-->\n[instrumentation/src/activities/interceptors.ts](https://github.com/temporalio/samples-typescript/blob/master/instrumentation/src/activities/interceptors.ts)\n```ts\nimport { Context } from '@temporalio/activity';\nimport { ActivityInboundCallsInterceptor, ActivityExecuteInput, Next } from '@temporalio/worker';\nimport { Logger } from 'winston';\n\n/** An Activity Context with an attached logger */\nexport interface ContextWithLogger extends Context {\n  logger: Logger;\n}\n\n/** Get the current Activity context with an attached logger */\nexport function getContext(): ContextWithLogger {\n  return Context.current() as ContextWithLogger;\n}\n\n/** Logs Activity executions and their duration */\nexport class ActivityInboundLogInterceptor implements ActivityInboundCallsInterceptor {\n  public readonly logger: Logger;\n\n  constructor(ctx: Context, logger: Logger) {\n    this.logger = logger.child({\n      activity: ctx.info,\n    });\n\n    // Set a logger instance on the current Activity Context to provide\n    // contextual logging information to each log entry generated by the Activity.\n    (ctx as ContextWithLogger).logger = this.logger;\n  }\n\n  async execute(input: ActivityExecuteInput, next: Next<ActivityInboundCallsInterceptor, 'execute'>): Promise<unknown> {\n    let error: any = undefined;\n    const startTime = process.hrtime.bigint();\n    try {\n      return await next(input);\n    } catch (err: any) {\n      error = err;\n      throw err;\n    } finally {\n      const durationNanos = process.hrtime.bigint() - startTime;\n      const durationMs = Number(durationNanos / 1_000_000n);\n      if (error) {\n        this.logger.error('activity failed', { error, durationMs });\n      } else {\n        this.logger.debug('activity completed', { durationMs });\n      }\n    }\n  }\n}\n```\n<!--SNIPEND-->\n\n</details>\n\n<details>\n<summary>\nUse the injected logger from an Activity\n</summary>\n\n<!--SNIPSTART typescript-activity-use-injected-logger -->\n[instrumentation/src/activities/index.ts](https://github.com/temporalio/samples-typescript/blob/master/instrumentation/src/activities/index.ts)\n```ts\nimport { getContext } from './interceptors';\n\nexport async function greet(name: string): Promise<string> {\n  const { logger } = getContext();\n  logger.info('Log from activity', { name });\n  return `Hello, ${name}!`;\n}\n```\n<!--SNIPEND-->\n\n</details>\n","is_empty":false},{"file_name":"how-to-send-logs-in-workers-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-send-logs-in-workers-in-typescript.md","id":"typescript/how-to-send-logs-from-workflows-in-typescript","title":"How to send logs from Workflows in TypeScript","description":"Send logs from Workflows","label":"Send logs from Workflows","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n**Logging in Workers and Clients**\n\nThe Worker comes with a default logger which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThere are 5 levels in total:\n\n- `TRACE`\n- `DEBUG`\n- `INFO`\n- `WARN`\n- `ERROR`\n\nThe reason we only offer a default logger is to minimize Worker dependencies and allow SDK users to bring their own logger.\n\n**Customizing the default logger**\n\nTemporal ships a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.DefaultLogger/) that implements the basic interface.\n\n**Set Default logger level**\n\nThe following example creates a new logger that will log all messages with a level `WARN` and higher.\n\n```ts\nimport { DefaultLogger, Runtime } from '@temporalio/worker';\n\n// Creating a new logger that will log all messages with level WARN and higher.\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\nRuntime.install({ logger });\n```\n\n**Example: Accumulate logs for testing/reporting**\n\nThe following example creates a logger that will log all the messages to an array.\n\n```ts\nimport { DefaultLogger, LogEntry } from '@temporalio/worker';\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger('TRACE', (entry) => logs.push(entry));\nlog.debug('hey', { a: 1 });\nlog.info('ho');\nlog.warn('lets', { a: 1 });\nlog.error('go');\n```\n\nThe log levels are [listed here](https://typescript.temporal.io/api/namespaces/worker#loglevel) in increasing order of severity.\n","is_empty":false},{"file_name":"how-to-set-a-cron-job-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-a-cron-job-in-typescript.md","id":"typescript/how-to-set-a-cron-job-in-typescript","title":"How to set a cron job in TypeScript","description":"Set a cron job","label":"Set a cron job","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nYou can set each Workflow to repeat on a schedule with the `cronSchedule` option:\n\n```typescript\nconst handle = await client.start(scheduledWorkflow, {\n  // ...\n  cronSchedule: '* * * * *', // start every minute\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-a-custom-logger-in-typescript.md","id":"typescript/how-to-set-a-custom-logger-in-typescript","title":"How to set a custom logger in TypeScript","description":"Set a custom logger","label":"Set a custom logger","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n**Logging in Workers and Clients**\n\nThe Worker comes with a default logger which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThe following [log levels](https://typescript.temporal.io/api/namespaces/worker#loglevel) are listed in increasing order of severity.\n\n**Customizing the default logger**\n\nTemporal uses a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.DefaultLogger/) that implements the basic interface:\n\n```ts\nimport { DefaultLogger, Runtime } from '@temporalio/worker';\n\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\nRuntime.install({ logger });\n```\n\nThe previous code example sets the default logger to only log messages with level `WARN` and higher.\n\n**Accumulate logs for testing and reporting**\n\n```ts\nimport { DefaultLogger, LogEntry } from '@temporalio/worker';\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger('TRACE', (entry) => logs.push(entry));\nlog.debug('hey', { a: 1 });\nlog.info('ho');\nlog.warn('lets', { a: 1 });\nlog.error('go');\n```\n\nA common logging use case is logging to a file to be picked up by a collector like the [Datadog Agent](https://docs.datadoghq.com/logs/log_collection/nodejs/?tab=winston30).\n\n```ts\nimport { Runtime } from '@temporalio/worker';\nimport winston from 'winston';\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  transports: [new transports.File({ filename: '/path/to/worker.log' })],\n});\nRuntime.install({ logger });\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-a-heartbeat-timeout-in-typescript.md","id":"typescript/how-to-set-a-heartbeat-timeout-in-typescript","title":"How to set a Heartbeat Timeout in TypeScript","description":"Set a Heartbeat Timeout","label":"Set a Heartbeat Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo set a Heartbeat Timeout, use [`ActivityOptions.heartbeatTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#heartbeattimeout). If the Activity takes longer than that between heartbeats, the Activity is failed.\n\n```typescript\n// Creating a proxy for the activity.\nconst { longRunningActivity } = proxyActivities<typeof activities>({\n  // translates to 300000 ms\n  scheduleToCloseTimeout: '5m',\n  // translates to 30000 ms\n  startToCloseTimeout: '30s',\n  // equivalent to '10 seconds'\n  heartbeatTimeout: 10000,\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-a-parent-close-policy-in-typescript.md","id":"typescript/how-to-set-a-parent-close-policy-in-typescript","title":"How to set Parent Close Policy in Typescript","description":"Use the `parentClosePolicy` property.","label":"Parent Close Policy","tags":["typescript","developer-guide","how-to"],"markdown_content":"\nTo specify how a Child Workflow reacts to a Parent Workflow reaching a Closed state, use the [`parentClosePolicy`](https://typescript.temporal.io/api/interfaces/workflow.ChildWorkflowOptions#parentclosepolicy) option.\n\n<!--SNIPSTART typescript-child-workflow -->\n[child-workflows/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/child-workflows/src/workflows.ts)\n```ts\nimport { executeChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(...names: string[]): Promise<string> {\n  const responseArray = await Promise.all(\n    names.map((name) =>\n      executeChild(childWorkflow, {\n        args: [name],\n        // workflowId, // add business-meaningful workflow id here\n        // // regular workflow options apply here, with two additions (defaults shown):\n        // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n        // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n      })\n    )\n  );\n  return responseArray.join('\\n');\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-a-schedule-to-close-timeout-in-typescript.md","id":"typescript/how-to-set-a-schedule-to-close-timeout-in-typescript","title":"How to set a Schedule to Close Timeout in TypeScript","description":"Set a Schedule to Close Timeout","label":"Set a Schedule to Close Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault: ∞ (infinity – no limit)\n\nIn this example, you can set the `scheduleToCloseTimeout` to 5 m.\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: '5m',\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-a-schedule-to-start-timeout-in-typescript.md","id":"typescript/how-to-set-a-schedule-to-start-timeout-in-typescript","title":"How to set a Schedule to Start Timeout in TypeScript","description":"Set a Schedule to Start Timeout","label":"Set a Schedule to Start Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault: ∞ (infinity – no limit)\n\nIn this example, you can set the `scheduleToStartTimeout` to 60 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: '5m',\n  scheduleToStartTimeout: '60s',\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-a-start-to-close-timeout-in-typescript.md","id":"typescript/how-to-set-a-start-to-close-timeout-in-typescript","title":"How to set a Start to Close Timeout in TypeScript","description":"Set a Start to Close Timeout","label":"Set a Start to Close Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault: ∞ (infinity – no limit)\n\nIn this example, you can set the `startToCloseTimeout` to 30 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '30s', // recommended\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-a-workflow-id-in-typescript.md","id":"typescript/how-to-set-a-workflow-id-in-typescript","title":"How to set a Workflow Id in TypeScript","description":"Set a Workflow Id","label":"Set a Workflow Id","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nConnect to a Client with `client.start()` and any arguments. Then specify your `taskQueue` and set your `workflowId` to a meaningful business identifier.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: 'yourWorkflowId',\n  taskQueue: 'yourTaskQueue',\n  args: ['your', 'arg', 'uments'],\n});\n```\n\nThis starts a new Client with the given Workflow Id, Task Queue name, and an argument.\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-a-workflow-task-queue-in-typescript.md","id":"typescript/how-to-set-a-workflow-task-queue-in-typescript","title":"How to set a Workflow Task Queue in TypeScript","description":"Set a Workflow Task Queue","label":"Set a Workflow Task Queue","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nA Task Queue is a dynamic queue in Temporal polled by one or more Workers.\n\nWorkers bundle Workflow code and node modules using Webpack v5 and execute them inside V8 isolates. Activities are directly required and run by Workers in the Node.js environment.\n\nWorkers are flexible. You can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers on a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker.\n- Workflow bundle, specify one of the following options:\n  - a `workflowsPath` to your `workflows.ts` file to pass to Webpack. For example, `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n  - Or pass a prebuilt bundle to `workflowBundle`, if you prefer to handle the bundling yourself.\n\n```ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  // Step 1: Register Workflows and Activities with the Worker and connect to\n  // the Temporal server.\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    activities,\n    taskQueue: 'hello-world',\n  });\n  // Worker connects to localhost by default and uses console.error for logging.\n  // Customize the Worker by passing more options to create():\n  // https://typescript.temporal.io/api/classes/worker.Worker\n  // If you need to configure server connection parameters, see docs:\n  // /typescript/security#encryption-in-transit-with-mtls\n\n  // Step 2: Start accepting tasks on the `tutorial` queue\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n`taskQueue` is the only required option; however, use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nWhen scheduling a Workflow, a `taskQueue` must be specified.\n\n```ts\nimport { Connection, WorkflowClient } from '@temporalio/client';\n// This is the code that is used to start a workflow.\nconst connection = await Connection.create();\nconst client = new WorkflowClient({ connection });\nconst result = await client.execute(yourWorkflow, {\n  // required\n  taskQueue: 'your-task-queue',\n  // required\n  workflowId: 'your-workflow-id',\n});\n```\n\nWhen creating a Worker, you must pass the `taskQueue` option to the `Worker.create()` function.\n\n```ts\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: 'your-task-queue',\n});\n```\n\nOptionally, in Workflow code, when calling an Activity, you can specify the Task Queue by passing the `taskQueue` option to `proxyActivities()`, `startChild()`, or `executeChild()`. If you do not specify a `taskQueue`, then the TypeScript SDK places Activity and Child Workflow Tasks in the same Task Queue as the Workflow Task Queue.\n","is_empty":false},{"file_name":"how-to-set-activity-timeouts-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-activity-timeouts-in-typescript.md","id":"typescript/how-to-set-activity-timeouts-in-typescript","title":"How to set Activity Timeouts in TypeScript","description":"Set Activity Timeouts","label":"Set Activity Timeouts","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nAvailable timeouts are:\n\n- [`scheduleToCloseTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions/#scheduletoclosetimeout)\n- [`startToCloseTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions/#starttoclosetimeout)\n- [`scheduleToStartTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions/#scheduletostarttimeout)\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: '5m',\n  // startToCloseTimeout: \"30s\", // recommended\n  // scheduleToStartTimeout: \"60s\",\n\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-an-activity-retry-policy-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-an-activity-retry-policy-in-typescript.md","id":"typescript/how-to-set-an-activity-retry-policy-in-typescript","title":"How to set an Activity Retry Policy in TypeScript","description":"Set an Activity Retry Policy","label":"Set an Activity Retry Policy","markdown_content":"\nTo set Activity Retry Policies in TypeScript, pass [`ActivityOptions.retry`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#retry) to [`proxyActivities`](https://typescript.temporal.io/api/namespaces/workflow/#proxyactivities).\n\n```typescript\n// Sample of typical options you can set\nconst { yourActivity } = proxyActivities<typeof activities>({\n  // ...\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-cluster-address-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-cluster-address-in-typescript.md","id":"typescript/how-to-set-cluster-address-in-typescript","title":"How to set a Cluster address in TypeScript","description":"Set Cluster address","label":"Set Cluster address","tags":["TypeScript","how-to"],"markdown_content":"\nUse the [`address`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions/#address) connection option from the [`Client`](https://typescript.temporal.io/api/namespaces/client).\n\n```typescript\nconst connection = await Connection.connect({\n  address: 'foo.bar.tmprl.cloud',\n  // ...\n});\n```\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-mtls-configuration-in-typescript.md","id":"typescript/how-to-set-mtls-configuration-in-typescript","title":"How to set mTLS configuration in TypeScript","description":"To set the mTLS configuration in TypeScript, use the `tls` connection option from the `Client` class to connect to a Temporal Client with mTLS.","label":"Set mTLS configuration","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo set the mTLS configuration in TypeScript, use the [`tls`](https://typescript.temporal.io/api/interfaces/client.ConnectionOptions/#tls) connection option from the [`Client`](https://typescript.temporal.io/api/namespaces/client) class to connect to a Temporal Client with mTLS.\n\n```typescript\nconst connection = await Connection.connect({\n  address: 'foo.bar.tmprl.cloud',\n  tls: {\n    clientCertPair: {\n      crt: clientCertPath,\n      key: clientKeyPath,\n    },\n  },\n});\nconst client = new WorkflowClient({ connection, namespace: 'foo.bar' });\n```\n\n[The Hello World mTLS sample](https://github.com/temporalio/samples-typescript/tree/main/hello-world-mtls/) demonstrates sample code used to connect to a Temporal Cloud account.\nWhen signing up to Temporal Cloud, you should receive a Namespace, a Server address, and a Client certificate and key. Use the following environment variables to set up the sample:\n\n- **TEMPORAL_ADDRESS**: looks like `foo.bar.tmprl.cloud` (NOT web.foo.bar.tmprl.cloud)\n- **TEMPORAL_NAMESPACE**: looks like `foo.bar`\n- **TEMPORAL_CLIENT_CERT_PATH**: `/tls/ca.pem` (file contents start with -----BEGIN CERTIFICATE-----)\n- **TEMPORAL_CLIENT_KEY_PATH**: `/tls/ca.key` (file contents start with -----BEGIN PRIVATE KEY-----)\n\nYou can leave the remaining variables, like `TEMPORAL_SERVER_NAME_OVERRIDE` and `TEMPORAL_SERVER_ROOT_CA_CERT_PATH`, blank.\nIf needed, you can customize `TEMPORAL_TASK_QUEUE`; the following example defaults to `hello-world-mtls`.\n\n```typescript\nexport function getEnv(): Env {\n  return {\n    // NOT web.foo.bar.tmprl.cloud\n    address: 'web.<Namespace_ID>.tmprl.cloud',\n    // as assigned\n    namespace: 'your.namespace',\n    // in project root\n    clientCertPath: 'foobar.pem',\n    clientKeyPath: 'foobar.key',\n    // just to ensure task queue is same on client and worker, totally optional\n    taskQueue: process.env.TEMPORAL_TASK_QUEUE || 'hello-world-mtls',\n    // not usually needed:\n    // serverNameOverride: process.env.TEMPORAL_SERVER_NAME_OVERRIDE,\n    // serverRootCACertificatePath: process.env.TEMPORAL_SERVER_ROOT_CA_CERT_PATH,\n  };\n}\n```\n\nIf you are using mTLS, it is completely up to you how to get the `clientCert` and `clientKey` pair into your code, whether it is reading from file system, secrets manager, or both. Just keep in mind that they are whitespace sensitive, and some environment variable systems have been known to cause frustration because they modify whitespace.\n\nThe following code example works for local development and for certifications hosted in an Amazon S3 bucket.\n\n```typescript\nlet serverRootCACertificate: Buffer | undefined;\nlet clientCertificate: Buffer | undefined;\nlet clientKey: Buffer | undefined;\nif (certificateS3Bucket) {\n  const s3 = new S3client({ region: certificateS3BucketRegion });\n  serverRootCACertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: serverRootCACertificatePath,\n  });\n  clientCertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientCertPath,\n  });\n  clientKey = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientKeyPath,\n  });\n} else {\n  serverRootCACertificate = fs.readFileSync(serverRootCACertificatePath);\n  clientCertificate = fs.readFileSync(clientCertPath);\n  clientKey = fs.readFileSync(clientKeyPath);\n}\n```\n","is_empty":false},{"file_name":"how-to-set-search-attributes-from-the-client-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-search-attributes-from-the-client-in-typescript.md","id":"typescript/how-to-set-search-attributes-from-the-client-in-typescript","title":"How to set Search Attributes from the Client in TypeScript","description":"Use Search Attributes from the Client","label":"Use Search Attributes from the Client","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWe can set [`WorkflowOptions.searchAttributes`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions#searchattributes) during `client.start()` or `client.execute()` and read with [`handle.describe()`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#describe):\n\n<!--SNIPSTART typescript-search-attributes-client -->\n[search-attributes/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/search-attributes/src/client.ts)\n```ts\n  const handle = await client.start(example, {\n    taskQueue: 'search-attributes',\n    workflowId: 'search-attributes-example-0',\n    searchAttributes: {\n      CustomIntField: [2],\n      CustomKeywordField: ['keywordA', 'keywordB'],\n      CustomBoolField: [true],\n      CustomDatetimeField: [new Date()],\n      CustomStringField: [\n        'String field is for text. When queried, it will be tokenized for partial match. StringTypeField cannot be used in Order By',\n      ],\n    },\n  });\n\n  const { searchAttributes } = await handle.describe();\n```\n<!--SNIPEND-->\n\nThe type of `searchAttributes` is `Record<string, string[] | number[] | boolean[] | Date[]>`.\n","is_empty":false},{"file_name":"how-to-set-search-attributes-in-a-workflow-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-search-attributes-in-a-workflow-in-typescript.md","id":"typescript/how-to-set-search-attributes-in-a-workflow-in-typescript","title":"How to set Search Attributes in a Workflow in TypeScript","description":"Use Search Attributes in a Workflow","label":"Use Search Attributes in a Workflow","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nInside a Workflow, we can read from [`WorkflowInfo.searchAttributes`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo#searchattributes) and call [`upsertSearchAttributes`](https://typescript.temporal.io/api/namespaces/workflow#upsertsearchattributes):\n\n<!--SNIPSTART typescript-search-attributes-workflow -->\n[search-attributes/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/search-attributes/src/workflows.ts)\n```ts\nexport async function example(): Promise<SearchAttributes> {\n  const customInt = (workflowInfo().searchAttributes.CustomIntField?.[0] as number) || 0;\n  upsertSearchAttributes({\n    // overwrite the existing CustomIntField: [2]\n    CustomIntField: [customInt + 1],\n\n    // delete the existing CustomBoolField: [true]\n    CustomBoolField: [],\n\n    // add a new value\n    CustomDoubleField: [3.14],\n  });\n  return workflowInfo().searchAttributes;\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-set-the-default-logger-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-the-default-logger-in-typescript.md","id":"typescript/how-to-set-the-default-logger-in-typescript","title":"How to set the default logger in TypeScript","description":"Set the default logger","label":"Set the default logger","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nSet the [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.DefaultLogger) to one of the following log levels: `'TRACE'` | `'DEBUG'` | `'INFO'` | `'WARN'` | `'ERROR'`.\n\nThe following is an example of setting the `DefaultLogger` to `'Debug'`.\n\n```typescript\nRuntime.install({\n  logger: new DefaultLogger('DEBUG'),\n  telemetryOptions: {\n    tracingFilter: 'temporal_sdk_core=DEBUG',\n    logging: { forward: { level: 'DEBUG' } },\n  },\n});\n```\n\nThe following code sets the `DefaultLogger` to `'Debug'` and creates a Worker that can execute Activities or Workflows.\n\n```typescript\nimport { DefaultLogger, Runtime, Worker } from '@temporalio/worker';\nimport * as activities from './activities';\nasync function main() {\n  const argv = arg({\n    '--debug': Boolean,\n  });\n  /* Setting the log level to DEBUG. */\n  if (argv['--debug']) {\n    Runtime.install({\n      logger: new DefaultLogger('DEBUG'),\n      telemetryOptions: {\n        tracingFilter: 'temporal_sdk_core=DEBUG',\n        logging: { forward: { level: 'DEBUG' } },\n      },\n    });\n  }\n  const worker = await Worker.create({\n    activities,\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'test',\n  });\n  await worker.run();\n  console.log('Worker gracefully shutdown');\n}\n```\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-the-namespace-for-a-temporal-client-in-typescript.md","id":"typescript/how-to-set-the-namespace-for-a-temporal-client-in-typescript","title":"How to set a Namespace for a Temporal Client in TypeScript","description":"Set the Namespace in Workflow Client Options Builder.","label":"Set Namespace","tags":["how-to","typescript"],"markdown_content":"\nSet the [`namespace`](https://typescript.temporal.io/api/namespaces/client/) field on the options object.\n\n```ts\nconst connection = await Connection.connect();\n// https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'your-custom-namespace',\n});\n```\n","is_empty":false},{"file_name":"how-to-set-timers-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-timers-in-typescript.md","id":"typescript/how-to-set-timers-in-typescript","title":"How to set Timers in TypeScript","description":"To set a Timer in TypeScript, use the `sleep()` function.","label":"Timers","tags":["timers","sleep"],"markdown_content":"\nTo set a Timer in TypeScript, use the [`sleep()`](https://typescript.temporal.io/api/namespaces/workflow/#sleep) function and pass how long you want to wait before continuing (using an [ms-formatted string](https://www.npmjs.com/package/ms) or number of milliseconds).\n\n```typescript\nimport { sleep } from '@temporalio/workflow';\n\nexport async function sleepWorkflow(): Promise<void> {\n  await sleep('2 months');\n  console.log('done sleeping');\n}\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-retry-options-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-workflow-retry-options-in-typescript.md","id":"typescript/how-to-set-workflow-retry-options-in-typescript","title":"How to set Workflow Retry Options in TypeScript","description":"Set Workflow Retry Options","label":"Set Workflow Retry Options","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nCreate an instance of the Retry Policy, known as [`retry`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#retry) in TypeScript, from the [`WorkflowOptions`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions) of the Client interface.\n\n<!--SNIPSTART typescript-retry-workflow -->\n[snippets/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/client.ts)\n```ts\n  const handle = await client.start(example, {\n    taskQueue,\n    workflowId,\n    retry: {\n      maximumAttempts: 3,\n    },\n  });\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-set-workflow-timeouts-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-set-workflow-timeouts-in-typescript.md","id":"typescript/how-to-set-workflow-timeouts-in-typescript","title":"How to set Workflow Timeouts in TypeScript","description":"Set Workflow Timeouts","label":"Set Workflow Timeouts","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nCreate an instance of `WorkflowOptions` from the Client and set your Workflow Timeout.\n\nAvailable timeouts are:\n\n- [`workflowExecutionTimeout​`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#workflowexecutiontimeout)\n- [`workflowRunTimeout`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#workflowruntimeout)\n- [`workflowTaskTimeout`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions/#workflowtasktimeout)\n\n<!--SNIPSTART typescript-execution-timeout -->\n[snippets/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/client.ts)\n```ts\n  await client.start(example, {\n    taskQueue,\n    workflowId,\n    workflowExecutionTimeout: '1 day',\n  });\n```\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-run-timeout -->\n[snippets/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/client.ts)\n```ts\n  await client.start(example, {\n    taskQueue,\n    workflowId,\n    workflowRunTimeout: '1 minute',\n  });\n```\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-task-timeout -->\n[snippets/src/client.ts](https://github.com/temporalio/samples-typescript/blob/master/snippets/src/client.ts)\n```ts\n  await client.start(example, {\n    taskQueue,\n    workflowId,\n    workflowTaskTimeout: '1 minute',\n  });\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-skip-time-set-up-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-skip-time-set-up-in-typescript.md","id":"typescript/how-to-skip-time-set-up-in-typescript","title":"How to set up time skipping in TypeScript","description":"To set up time skipping, use `TestWorkflowEnvironment.createTimeSkipping`.","label":"Set up time skipping","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n```bash\nnpm install @temporalio/testing\n```\n\nThe `@temporalio/testing` package downloads the test server and exports [`TestWorkflowEnvironment`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment), which you use to connect the Client and Worker to the test server and interact with the test server.\n\n[`TestWorkflowEnvironment.createTimeSkipping`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#createtimeskipping) starts the test server.\nA typical test suite should set up a single instance of the test environment to be reused in all tests (for example, in a [Jest](https://jestjs.io/) `beforeAll` hook or a [Mocha](https://mochajs.org/) `before()` hook).\n\n```typescript\nimport { TestWorkflowEnvironment } from '@temporalio/testing';\n\nlet testEnv: TestWorkflowEnvironment;\n\n// beforeAll and afterAll are injected by Jest\nbeforeAll(async () => {\n  testEnv = await TestWorkflowEnvironment.createTimeSkipping();\n});\n\nafterAll(async () => {\n  await testEnv?.teardown();\n});\n```\n\n`TestWorkflowEnvironment` has a [`client.workflow`](https://typescript.temporal.io/api/classes/testing.testworkflowenvironment/#workflowclient) and [`nativeConnection`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#nativeconnection) for creating Workers:\n\n```typescript\nimport { Worker } from '@temporalio/worker';\nimport { v4 as uuid4 } from 'uuid';\nimport { workflowFoo } from './workflows';\n\ntest('workflowFoo', async () => {\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    ...\n  });\n  const result = await worker.runUntil(\n    testEnv.client.workflow.execute(workflowFoo, {\n      workflowId: uuid4(),\n      taskQueue: 'test',\n    })\n  );\n  expect(result).toEqual('foo');\n});\n```\n\nThis test uses the test connection to create a Worker, runs the Worker until the Workflow is complete, and then makes an assertion about the Workflow’s result.\nThe Workflow is executed using `testEnv.workflowClient`, which is connected to the test server.\n","is_empty":false},{"file_name":"how-to-skip-time-skip-activities-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-skip-time-skip-activities-in-typescript.md","id":"typescript/how-to-skip-time-skip-activities-in-typescript","title":"How to skip time in Activities in TypeScript","description":"To skip time in an Activity, call `TestWorkflowEnvironment.sleep` from the mock Activity.","label":"Skip time in Activities","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nCall [`TestWorkflowEnvironment.sleep`](https://typescript.temporal.io/api/classes/testing.testworkflowenvironment/#sleep) from the mock Activity.\n\nIn the following test, `processOrderWorkflow` sends a notification to the user after one day.\nThe `processOrder` mocked Activity calls `testEnv.sleep(‘2 days’)`, during which the Workflow sends email (by calling the `sendNotificationEmail` Activity).\n\nThen, after the Workflow completes, we assert that `sendNotificationEmail` was called.\n\n<details>\n<summary>\nWorkflow implementation\n</summary>\n\n<!--SNIPSTART typescript-timer-reminder-workflow-->\n[timer-examples/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/timer-examples/src/workflows.ts)\n```ts\nexport async function processOrderWorkflow({\n  orderProcessingMS,\n  sendDelayedEmailTimeoutMS,\n}: ProcessOrderOptions): Promise<string> {\n  let processing = true;\n  // Dynamically define the timeout based on given input\n  const { processOrder } = proxyActivities<ReturnType<typeof createActivities>>({\n    startToCloseTimeout: orderProcessingMS,\n  });\n\n  const processOrderPromise = processOrder().then(() => {\n    processing = false;\n  });\n\n  await Promise.race([processOrderPromise, sleep(sendDelayedEmailTimeoutMS)]);\n\n  if (processing) {\n    await sendNotificationEmail();\n\n    await processOrderPromise;\n  }\n\n  return 'Order completed!';\n}\n```\n<!--SNIPEND-->\n\n</details>\n\n<!--SNIPSTART typescript-timer-reminder-test-->\n[timer-examples/src/test/workflows.test.ts](https://github.com/temporalio/samples-typescript/blob/master/timer-examples/src/test/workflows.test.ts)\n```ts\n  it('sends reminder email if processOrder does not complete in time', async () => {\n    // This test doesn't actually take days to complete: the TestWorkflowEnvironment starts the\n    // Test Server, which automatically skips time when there are no running Activities.\n    let emailSent = false;\n    const mockActivities: ReturnType<typeof createActivities> = {\n      async processOrder() {\n        // Test server switches to \"normal\" time while an Activity is executing.\n        // Call `env.sleep` to skip ahead 2 days, by which time sendNotificationEmail\n        // should have been called.\n        await env.sleep('2 days');\n      },\n      async sendNotificationEmail() {\n        emailSent = true;\n      },\n    };\n    const worker = await Worker.create({\n      connection: env.nativeConnection,\n      taskQueue: 'test',\n      workflowsPath: require.resolve('../workflows'),\n      activities: mockActivities,\n    });\n    await worker.runUntil(\n      env.client.workflow.execute(processOrderWorkflow, {\n        workflowId: uuid(),\n        taskQueue: 'test',\n        args: [{ orderProcessingMS: ms('3 days'), sendDelayedEmailTimeoutMS: ms('1 day') }],\n      })\n    );\n    assert.ok(emailSent);\n  });\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-skip-time-skip-automatically-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-skip-time-skip-automatically-in-typescript.md","id":"typescript/how-to-skip-time-skip-automatically-in-typescript","title":"How to skip time automatically in TypeScript","description":"Use `TestWorkflowEnvironment.workflowClient.execute()` or `.result()` to switch the test server to \"skipped\" time mode until the Workflow completes.","label":"Skip time automatically","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nThe test server starts in \"normal\" time.\nWhen you use `TestWorkflowEnvironment.workflowClient.execute()` or `.result()`, the test server switches to \"skipped\" time mode until the Workflow completes.\nIn \"skipped\" mode, timers (`sleep()` calls and `condition()` timeouts) are fast-forwarded except when Activities are running.\n\n`workflows.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\n\nexport async function sleeperWorkflow() {\n  await sleep('1 day');\n}\n```\n\n`test.ts`\n\n```ts\nimport { sleeperWorkflow } from './workflows';\n\ntest('sleep completes almost immediately', async () => {\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('./workflows'),\n  });\n  // Does not wait an entire day\n  await worker.runUntil(\n    testEnv.workflowClient.execute(sleeperWorkflow, {\n      workflowId: uuid(),\n      taskQueue: 'test',\n    }),\n  );\n});\n```\n","is_empty":false},{"file_name":"how-to-skip-time-skip-manually-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-skip-time-skip-manually-in-typescript.md","id":"typescript/how-to-skip-time-skip-manually-in-typescript","title":"How to skip time manually in TypeScript","description":"Call `testEnv.sleep()` from your test code to advance the test server's time.","label":"Skip time manually","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nYou can call `testEnv.sleep()` from your test code to advance the test server's time.\nThis is useful for testing intermediate states or indefinitely long-running Workflows.\nHowever, to use `testEnv.sleep()`, you need to avoid automatic time skipping by starting the Workflow with `.start()` instead of `.execute()` (and not calling `.result()`).\n\n`workflow.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\nimport { defineQuery, setHandler } from '@temporalio/workflow';\n\nexport const daysQuery = defineQuery('days');\n\nexport async function sleeperWorkflow() {\n  let numDays = 0;\n\n  setHandler(daysQuery, () => numDays);\n\n  for (let i = 0; i < 100; i++) {\n    await sleep('1 day');\n    numDays++;\n  }\n}\n```\n\n`test.ts`\n\n```ts\ntest('sleeperWorkflow counts days correctly', async () => {\n  // `start()` starts the test server in \"normal\" mode, not skipped time mode.\n  // If you don't advance time using `testEnv.sleep()`, then `sleeperWorkflow()`\n  // will run for days.\n  handle = await testEnv.workflowClient.start(sleeperWorkflow, {\n    workflowId: uuid4(),\n    taskQueue,\n  });\n\n  let numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 0);\n\n  // Advance the test server's time by 25 hours\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 1);\n\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 2);\n});\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-spawn-a-child-workflow-execution-in-typescript.md","id":"typescript/how-to-spawn-a-child-workflow-execution-in-typescript","title":"How to spawn a Child Workflow Execution in Typescript","label":"Child Workflow Execution","tags":["developer-guide","typescript"],"markdown_content":"\nTo start a Child Workflow and return a [handle](https://typescript.temporal.io/api/interfaces/workflow.ChildWorkflowHandle/) to it, use [`startChild`](https://typescript.temporal.io/api/namespaces/workflow/#startchild).\n\nTo start a Child Workflow Execution and await its completion, use [`executeChild`](https://typescript.temporal.io/api/namespaces/workflow/#executechild).\n\nBy default, a child is scheduled on the same Task Queue as the parent.\n\n<!--SNIPSTART typescript-child-workflow -->\n[child-workflows/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/child-workflows/src/workflows.ts)\n```ts\nimport { executeChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(...names: string[]): Promise<string> {\n  const responseArray = await Promise.all(\n    names.map((name) =>\n      executeChild(childWorkflow, {\n        args: [name],\n        // workflowId, // add business-meaningful workflow id here\n        // // regular workflow options apply here, with two additions (defaults shown):\n        // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n        // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n      })\n    )\n  );\n  return responseArray.join('\\n');\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-spawn-a-workflow-execution-in-typescript.md","id":"typescript/how-to-spawn-a-workflow-execution-in-typescript","title":"How to spawn a Workflow Execution in TypeScript","description":"Spawn a Workflow Execution","label":"Spawn a Workflow Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWhen you have a Workflow Client, you can schedule the start of a Workflow with `client.start()`, specifying `workflowId`, `taskQueue`, and `args` and returning a Workflow handle immediately after the Server acknowledges the receipt.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: 'your-workflow-id',\n  taskQueue: 'your-task-queue',\n  args: ['argument01', 'argument02', 'argument03'], // this is typechecked against workflowFn's args\n});\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nCalling `client.start()` and `client.execute()` send a command to Temporal Server to schedule a new Workflow Execution on the specified Task Queue. It does not actually start until a Worker that has a matching Workflow Type, polling that Task Queue, picks it up.\n\nYou can test this by executing a Workflow Client command without a matching Worker. Temporal Server records the command in Event History, but does not make progress with the Workflow Execution until a Worker starts polling with a matching Task Queue and Workflow Definition.\n\nWorkflow Execution run in a separate V8 isolate context in order to provide a [deterministic runtime](/typescript/determinism).\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-spawn-an-activity-execution-in-typescript.md","id":"typescript/how-to-spawn-an-activity-execution-in-typescript","title":"How to spawn an Activity Execution in TypeScript","description":"Spawn an Activity Execution","label":"Spawn an Activity Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo spawn an Activity Execution, you must retrieve the _Activity handle_ in your Workflow.\n\n```typescript\nimport { proxyActivities } from '@temporalio/workflow';\n// Only import the activity types\nimport type * as activities from './activities';\n\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\n// A workflow that calls an activity\nexport async function example(name: string): Promise<string> {\n  return await greet(name);\n}\n```\n\nThis imports the individual Activities and declares the type alias for each Activity.\n","is_empty":false},{"file_name":"how-to-strucutre-a-project-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-strucutre-a-project-in-typescript.md","id":"typescript/how-to-structure-a-project-in-typescript","title":"How to structure a project in TypeScript","description":"Structure a project","label":"Structure a project","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nA typical Temporal project written in TypeScript consists of the following components:\n\n```\nproject-root/\n  activities/\n      activity.ts\n  workflows/\n      workerflow.ts\n  workers/\n      worker.ts\n  starter-script.ts\n```\n\nActivities cannot be in the same file as Workflows and must be separately registered.\nActivities may be retried, so you may need to use [idempotency keys](https://stripe.com/blog/idempotency) for critical side effects.\n","is_empty":false},{"file_name":"how-to-test-cancel-an-activity-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-test-cancel-an-activity-in-typescript.md","id":"typescript/how-to-test-cancel-an-activity-in-typescript","title":"How to test whether an Activity reacts to a Cancellation in TypeScript","description":"Call `MockActivityEnvironment.cancel()` to cancel an Activity Context.","label":"Configure tracing","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`MockActivityEnvironment`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment) exposes a [`.cancel()`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment#cancel) method that cancels the Activity Context.\n\n```ts\nimport { CancelledFailure, Context } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport assert from 'assert';\n\nasync function activityFoo(): Promise<void> {\n  Context.current().heartbeat(6);\n  // .sleep() is Cancellation-aware, which means that on Cancellation,\n  // CancelledFailure will be thrown from it.\n  await Context.current().sleep(100);\n}\n\nconst env = new MockActivityEnvironment();\n\nenv.on('heartbeat', (d: unknown) => {\n  assert(d === 6);\n});\n\nawait assert.rejects(env.run(activityFoo), (err) => {\n  assert.ok(err instanceof CancelledFailure);\n});\n```\n","is_empty":false},{"file_name":"how-to-test-functions-in-workflow-context-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-test-functions-in-workflow-context-in-typescript.md","id":"typescript/how-to-test-functions-in-workflow-context-in-typescript","title":"How to test functions in the Workflow context in TypeScript","description":"To test a function in your Workflow code that isn’t a Workflow, put the file it’s exported from in `WorkerOptions.workflowsPath`.","label":"Test functions in Workflow context","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo test a function in your Workflow code that isn’t a Workflow, put the file it’s exported from in [WorkerOptions.workflowsPath](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#workflowspath).\nThen execute the function as if it were a Workflow:\n\n`workflows/file-with-workflow-function-to-test.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\n\nexport async function functionToTest(): Promise<number> {\n  await sleep('1 day');\n  return 42;\n}\n```\n\n`test.ts`\n\n```ts\nconst worker = await Worker.create({\n  connection: testEnv.nativeConnection,\n  workflowsPath: require.resolve(\n    './workflows/file-with-workflow-function-to-test',\n  ),\n});\n\nconst result = await worker.runUntil(\n  testEnv.workflowClient.execute(functionToTest, workflowOptions),\n);\n\nassert.equal(result, 42);\n```\n\nIf `functionToTest` starts a Child Workflow, that Workflow must be exported from the same file (so that the Worker knows about it):\n\n```ts\nimport { sleep } from '@temporalio/workflow';\nimport { someWorkflowToRunAsChild } from './some-workflow';\n\nexport { someWorkflowToRunAsChild };\n\nexport async function functionToTest(): Promise<number> {\n  const result = await wf.executeChild(someWorkflowToRunAsChild);\n  return result + 42;\n}\n```\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript.md","id":"typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript","title":"How to upsert custom Search Attributes to Workflow during Execution in TypeScript","label":"How to upsert custom Search Attributes to Workflow during Execution","tags":["developer-guide","typescript"],"markdown_content":"\nInside a Workflow, we can read from [`WorkflowInfo.searchAttributes`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo#searchattributes) and call [`upsertSearchAttributes`](https://typescript.temporal.io/api/namespaces/workflow#upsertsearchattributes):\n\n<!--SNIPSTART typescript-search-attributes-workflow -->\n[search-attributes/src/workflows.ts](https://github.com/temporalio/samples-typescript/blob/master/search-attributes/src/workflows.ts)\n```ts\nexport async function example(): Promise<SearchAttributes> {\n  const customInt = (workflowInfo().searchAttributes.CustomIntField?.[0] as number) || 0;\n  upsertSearchAttributes({\n    // overwrite the existing CustomIntField: [2]\n    CustomIntField: [customInt + 1],\n\n    // delete the existing CustomBoolField: [true]\n    CustomBoolField: [],\n\n    // add a new value\n    CustomDoubleField: [3.14],\n  });\n  return workflowInfo().searchAttributes;\n}\n```\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-use-assert-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-use-assert-typescript.md","id":"typescript/how-to-use-assert-typescript","title":"How to assert a Workflow in TypeScript","label":"Assert a Workflow","tags":["developer-guide","typescript"],"markdown_content":"\nThe Node.js [`assert`](https://nodejs.org/api/assert.html) module is included in Workflow bundles.\n\nBy default, a failed `assert` statement throws `AssertionError`, which causes a [Workflow Task](/concepts/what-is-a-workflow-task) to fail and be indefinitely retried.\n\nTo prevent this behavior, use [`workflowInterceptorModules`](https://typescript.temporal.io/api/namespaces/testing/#workflowinterceptormodules) from `@temporalio/testing`.\nThese interceptors catch an `AssertionError` and turn it into an `ApplicationFailure` that fails the entire Workflow Execution (not just the Workflow Task).\n\n`workflows/file-with-workflow-function-to-test.ts`\n\n```ts\nimport assert from 'assert';\n\nexport async function functionToTest() {\n  assert.ok(false);\n}\n```\n\n`test.ts`\n\n```ts\nimport {\n  TestWorkflowEnvironment,\n  workflowInterceptorModules,\n} from '@temporalio/testing';\n\nconst worker = await Worker.create({\n  connection: testEnv.nativeConnection,\n  interceptors: {\n    workflowModules: workflowInterceptorModules,\n  },\n  workflowsPath: require.resolve(\n    './workflows/file-with-workflow-function-to-test',\n  ),\n});\n\nawait worker.runUntil(\n  testEnv.workflowClient.execute(functionToTest, workflowOptions), // throws WorkflowFailedError\n);\n```\n","is_empty":false},{"file_name":"how-to-use-environment-variables-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-use-environment-variables-in-typescript.md","id":"typescript/how-to-use-environment-variables-in-typescript","title":"How to use environment variables in TypeScript","description":"Use Environment Variables","label":"Use Environment Variables","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n**Using in Activity code**\n\n```ts\nasync function runWorker(): Promise<void> {\n  const activities = createActivities({ apiKey: process.env.MAILGUN_API_KEY });\n\n  const worker = await Worker.create({\n    taskQueue: 'example',\n    activities,\n    workflowsPath: require.resolve('./workflows'),\n  });\n  await worker.run();\n}\n\nconst createActivities = (envVars: { apiKey: string }) => ({\n  async sendNotificationEmail(): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: 'post',\n      params: { to, from, subject, html },\n      auth: {\n        username: 'api',\n        password: envVars.apiKey,\n      },\n    });\n  },\n});\n```\n\n**Getting into Workflow**\n\nIf we needed environment variables in our Workflow, here's how we'd use a Local Activity:\n\n```ts\nconst worker = await Worker.create({\n  taskQueue: 'example',\n  activities: createActivities(process.env),\n  workflowsPath: require.resolve('./workflows'),\n});\n\ntype EnvVars = Record<string, string>;\n\nconst createActivities = (envVars: EnvVars) => ({\n  async getEnvVars(): Promise<EnvVars> {\n    return envVars;\n  },\n  async sendNotificationEmail(apiKey: string): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: 'post',\n      params: { to, from, subject, html },\n      auth: {\n        username: 'api',\n        password: apiKey,\n      },\n    });\n  },\n});\n```\n\n```ts\nconst { getEnvVars } = proxyLocalActivities({\n  startToCloseTimeout: '1m',\n});\n\nconst { sendNotificationEmail } = proxyActivities({\n  startToCloseTimeout: '1m',\n});\n\nasync function yourWorkflow() {\n  const envVars = await getEnvVars();\n  if (!envVars.apiKey) {\n    throw new Error('missing env var apiKey');\n  }\n  await sendNotificationEmail(envVars.apiKey);\n}\n```\n","is_empty":false},{"file_name":"how-to-use-signals-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-use-signals-in-typescript.md","id":"typescript/how-to-use-signals-in-typescript","title":"How to use Signals in TypeScript","description":"Use Signals","label":"Use Signals","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo add a Signal to a Workflow, call `defineSignal()` with a name, and then attach a listener with `setHandler()`.\n\n- Handlers to take arguments, which can be used inside `setHandler()` logic.\n- Signal handlers can mutate state, Signal handlers cannot return values.\n\n**Declare your Signal as constants outside the Workflow Definition**\n\n```typescript\nimport * as wf from '@temporalio/workflow';\n\nexport const unblockSignal = wf.defineSignal('unblock');\n let isBlocked = true;\n wf.setHandler(unblockSignal, () => void (isBlocked = false));\n console.log('Blocked');\n try {\n   await wf.condition(() => !isBlocked);\n   console.log('Unblocked');\n } catch (err) {\n   if (err instanceof wf.CancelledFailure) {\n     console.log('Cancelled');\n   }\n   throw err;\n }\n}\n```\n\nThis code defines a Signal as _unblock_ and declares the variable as _isBlocked_ as true. Then the code tries to execute the condition and print _Unblocked_ to the console if it becomes unblocked. Finally, the code catches any errors, and if the error is `CancelledFailure`, then it prints `Cancelled` to the console.\n\nThis helps provide type safety, since you can export the type signature of the Signal or Query to be called on the client side.\n\n##### Declare your Signals dynamically\n\nFor more flexible usecases, you may want a dynamic Signal, such as a generated identifier. You may handle it in two ways:\n\n- avoid making it dynamic by collapsing all signals in one handler and move the identifier to the payload.\n- actually make the Signal name dynamic by inlining the Signal definition per handler.\n\n```typescript\nimport * as wf from '@temporalio/workflow';\n\nwf.setHandler(`genericSignal`, (payload) => {\n  switch (payload.taskId) {\n    case taskAId:\n      // do task A things\n      break;\n    case taskBId:\n      // do task B things\n      break;\n    default:\n      throw new Error('Unexpected task.');\n  }\n});\n\n// \"inline definition\" solution\nwf.setHandler(wf.defineSignal(`task-${taskAId}`), (payload) => {\n  /* do task A things */\n});\nwf.setHandler(wf.defineSignal(`task-${taskBId}`), (payload) => {\n  /* do task B things */\n});\n\n// utility \"inline definition\" helper\nconst inlineSignal = (signalName, handler) =>\n  wf.setHandler(wf.defineSignal(signalName), handler);\ninlineSignal(`task-${taskBId}`, (payload) => {\n  /* do task B things */\n});\n```\n\n:::note\n\nThe semantics of `defineSignal()` and `defineQuery()` is intentional, in that they return Signal/Query Definitions, not unique instances of Signals and Queries themselves.\nSignals and Queries are only instantiated in `setHandler()` and are specific to a particular Workflow Execution.\n\nThese distinctions may seem minor, but they model how Temporal works under the hood, because Signals and Queries are messages identified by _just strings_ and don't have meaning independent of the Workflow having a listener to handle them.\n\nWe named it `setHandler` instead of `subscribe` because Signals and Queries can only have one handler at a time, whereas `subscribe` could imply an observable with multiple consumers, and is a higher level construct.\n:::\n\n#### Start a Signal from the Client\n\nSending Signals requires a Workflow handle from a Temporal Client.\n\n- You send a Signal with `handle.signal(signal, ...args)`. A Signal has no return value by definition.\n- You can refer to a Signal by string name, which is useful for dynamic reference, but you will lose type inference\n\nThe following code is from inside the Client code.\n\n```typescript\nimport { count, increment } from './workflow';\n\n// init client code omitted - see Client docs\nconst handle = client.getHandle(workflowId);\n\n// these three are equivalent\nawait handle.signal(increment, 1);\nawait handle.signal<[number]>('increment', 1);\nawait client.getHandle(workflowId).signal(increment, 1);\n```\n","is_empty":false},{"file_name":"how-to-use-test-frameworks-in-typescript.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/how-to-use-test-frameworks-in-typescript.md","id":"typescript/how-to-use-test-frameworks-in-typescript","title":"How to use test frameworks in TypeScript","description":"TypeScript has sample tests for Jest and Mocha.","label":"Test frameworks","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTypeScript has sample tests for [Jest](https://jestjs.io/) and [Mocha](https://mochajs.org/).\n\n**Jest**\n\n- Minimum Jest version: `27.0.0`\n- [Sample test file](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/workflows.test.ts)\n- [`jest.config.js`](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/jest.config.js) (must use [`testEnvironment: 'node'`](https://jestjs.io/docs/configuration#testenvironment-string); `testEnvironment: 'jsdom'` is not supported)\n\n**Mocha**\n\n- [Sample test file](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/mocha/workflows.test.ts)\n- Test coverage library: [`@temporalio/nyc-test-coverage`](https://github.com/temporalio/sdk-typescript/tree/main/packages/nyc-test-coverage)\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/typescript/index.md","id":"typescript/index","title":"How to use the Temporal TypeScript SDK","description":"Add the Temporal TypeScript SDK to your project.","label":"Temporal TypeScript SDK","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[![NPM](https://img.shields.io/npm/v/temporalio.svg?style=for-the-badge)](https://www.npmjs.com/search?q=author%3Atemporal-sdk-team)\n\nThis project requires Node.js 14 or later.\n\n**Create a new project**\n\n```bash\nnpx @temporalio/create@latest ./your-app\n```\n\n**Add to an existing project**\n\n```bash\nnpm install @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity @temporalio/common\n```\n\n:::note\n\nThe TypeScript SDK is designed with TypeScript-first developer experience in mind, but it works equally well with JavaScript.\n\n:::\n","is_empty":false},{"file_name":"cluster-metrics.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/references/cluster-metrics.md","id":"references/cluster-metrics","title":"Temporal Cluster metrics reference","description":"The Temporal Cluster emits a range of metrics to help operators get visibility into the Cluster’s performance and set up alerts.","label":"Cluster metrics","tags":["reference"],"markdown_content":"\nA Temporal Cluster emits a range of metrics to help operators get visibility into the Cluster’s performance and to set up alerts.\nAll metrics emitted by the Cluster are listed in [defs.go](https://github.com/temporalio/temporal/blob/master/common/metrics/defs.go).\n\nFor details on setting up metrics in your Cluster configuration, see [Temporal Cluster](/references/configuration#global).\n\nThe [dashboards repository](https://github.com/temporalio/dashboards) contains community-driven Grafana dashboard templates that can be used as a starting point for monitoring the Temporal Cluster and SDK metrics.\nYou can use these templates as references to build your own dashboards.\nFor any metrics that are missing in the dashboards, use [defs.go](https://github.com/temporalio/temporal/blob/master/common/metrics/defs.go) as a reference.\n\nNote that, apart from these metrics emitted by the Cluster, you should also monitor infrastructure-specific metrics like CPU, memory, and network for all hosts that are running Temporal Cluster services.\n\n## Common metrics\n\nTemporal emits metrics for each gRPC service request.\nThese metrics are emitted with `type`, `operation`, and `namespace` tags, which provide visibility into Service usage and show the request rates across Services, Namespaces, and Operations.\n\n- Use the `operation` tag in your query to get request rates, error rates, or latencies per operation.\n- Use the `service_name` tag with the [service role tag values](https://github.com/temporalio/temporal/blob/bba148cf1e1642fd39fa0174423b183d5fc62d95/common/metrics/defs.go#L108) to get details for the specific service.\n\nAll common tags that you can add in your query are defined in the [defs.go](https://github.com/temporalio/temporal/blob/master/common/metrics/defs.go) file.\n\nFor example, to see service requests by operation on the Frontend Service, use the following:\n\n`sum by (operation) (rate(service_requests{service_name=\"frontend\"}[2m]))`\n\nNote: All metrics queries in this topic are [Prometheus queries](https://prometheus.io/docs/prometheus/latest/querying/basics/).\n\nThe following list describes some metrics you can get started with.\n\n### `service_requests`\n\nShows service requests received per Task Queue.\nExample: Service requests by operation\n`sum(rate(service_requests{operation=\\\"AddWorkflowTask\\\"}[2m]))`\n\n### `service_latency`\n\nShows latencies for all Client request operations.\nUsually these are the starting point to investigate which operation is experiencing high-latency issues.\nExample: P95 service latency by operation for the Frontend Service\n`histogram_quantile(0.95, sum(rate(service_latency_bucket{service_name=\"frontend\"}[5m])) by (operation, le))`\n\n### `service_error_with_type`\n\n(Available only in v1.17.0+) Identifies errors encountered by the service.\nExample: Service errors by type for the Frontend Service\n`sum(rate(service_errors_with_type{service_name=\"frontend\"}[5m])) by (error_type)`\n\n### `client_errors`\n\nAn indicator for connection issues between different Server roles.\nExample: Client errors\n`sum(rate(client_errors{service_name=\"frontend\",service_role=\"history\"}[5m]))`\n\nIn addition to these, you can define some service-specific metrics to get performance details for each service.\nStart with the following list, and use [defs.go](https://github.com/temporalio/temporal/blob/master/common/metrics/defs.go) to define additional metrics as required.\n\n## Matching Service metrics\n\n### `poll_success`\n\nShows for Tasks that are successfully matched to a poller.\nExample: `sum(rate(poll_success{}[5m]))`\n\n### `poll_timeouts`\n\nShows when no Tasks are available for the poller within the poll timeout.\nExample: `sum(rate(poll_timeouts{}[5m]))`\n\n### `asyncmatch_latency`\n\nMeasures the time from creation to delivery for async matched Tasks.\nThe larger this latency, the longer Tasks are sitting in the queue waiting for your Workers to pick them up.\nExample: `histogram_quantile(0.95, sum(rate(asyncmatch_latency_bucket{service_name=~\"matching\"}[5m])) by (operation, le))`\n\n### `no_poller_tasks`\n\nEmitted whenever a task is added to a task queue that has no poller, and is a counter metric.\nThis is usually an indicator that either the Worker or the starter programs are using the wrong Task Queue.\nUse `no_poller_tasks_per_tl` to get data per Task Queue.\n\n## History Service metrics\n\nA History Task is an internal Task in Temporal that is created as part of a transaction to update Workflow state and is processed by the Temporal History service.\nIt is critical to ensure that the History Task processing system is healthy.\nThe following key metrics can be used to monitor the History Service health:\n\n### `task_requests`\n\nEmitted on every Task process request.\nExample: `sum(rate(task_requests{service=\"$service\",operation=~\"TransferActive.*\"}[1m]))`\n\n### `task_errors`\n\nEmitted on every Task process error.\nExample: `sum(rate(task_errors{operation=~\"TransferActive.*\"}[1m]))`\n\n### `task_attempt`\n\nNumber of attempts on each Task Execution.\nA Task is retried forever, and each retry increases the attempt count.\nExample: `histogram_quantile($percentile, sum(rate(task_attempt_bucket{service=\"$service\",operation=~\"TransferActive.*\"}[1m])) by (operation, le))`\n\n### `task_latency_processing`\n\nShows the processing latency per attempt.\nExample: `histogram_quantile($percentile, sum(rate(task_latency_processing_bucket{operation=~\"TransferActive.*\",service=\"$service\", service_name=\"history\"}[1m])) by (operation, le))`\n\n### `task_latency`\n\nMeasures the in-memory latency across multiple attempts.\n\n### `task_latency_queue`\n\nMeasures the duration, end-to-end, from when the Task should be executed (from the time it was fired) to when the Task is done.\n\n### `task_latency_load`\n\n(Available only in v1.18.0+) Measures the duration from Task generation to Task loading (Task schedule to start latency for persistence queue).\n\n### `task_latency_schedule`\n\n(Available only in v1.18.0+) Measures the duration from Task submission (to the Task scheduler) to processing (Task schedule to start latency for in-memory queue).\n\n### `queue_latency_schedule`\n\n(Available only in v1.18.0+) Measures the time to schedule 100 Tasks in one Task channel in the host-level Task scheduler.\nIf fewer than 100 Tasks are in the Task channel for 30 seconds, the latency is scaled to 100 Tasks upon emission.\nNote: This is still an experimental metric and is subject to change.\n\n### `task_latency_userlatency`\n\nShows the latency introduced because of Workflow logic.\nFor example, if you have one Workflow scheduling many Activities or Child Workflows at the same time, it can cause a per-Workflow lock contention.\nThe wait period for the per-Workflow lock is counted as `userlatency`.\n\nThe `operation` tag contains details about Task type and Active versus Standby statuses, and can be used to get request rates, error rates, or latencies per operation, which can help identify issues caused by database problems.\n\n## Persistence metrics\n\nTemporal Server emits metrics for every persistence database read and write.\nSome of the most important ones are the following:\n\n### `persistence_requests`\n\nEmitted on every persistence request.\nExamples:\n\n- Prometheus query for getting the total number of persistence requests by operation for the History Service:\n  `sum by (operation) (rate(persistence_requests{service=\"$service\",service_name=\"history\"}[1m]))`\n- Prometheus query for getting the total number of persistence requests by operation for the Matching Service:\n  `sum by (operation) (rate(persistence_requests{cluster=\"$cluster\",service_name=\"matching\"}[5m]))`\n\n### `persistence_errors`\n\nShows all persistence errors.\nThis metric is a good indicator for connection issues between Temporal Cluster and the persistence store.\nExample:\n\n- Prometheus query for getting all persistence errors by service (history)\n  `sum (rate(persistence_errors{service=\"$service\",service_name=\"history\"}[1m]))`\n\n### `persistence_error_with_type`\n\nShows all errors related to the persistence store with type, and contain an `error_type` tag.\n\n- Prometheus query for getting persistence errors with type by (history) and by error type:\n  `sum(rate(persistence_error_with_type{service=\"$service\",service_name=\"history\"}[1m])) by (error_type)`\n\n### `persistence_latency`\n\nShows the latency on persistence operations.\nExample:\n\n- Prometheus query for getting latency by percentile:\n  `histogram_quantile($percentile, sum(rate(persistence_latency_bucket{service=\"$service\" service_name=\"history\"}[1m])) by (operation, le))`\n","is_empty":false},{"file_name":"commands.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/references/commands.md","id":"references/commands","title":"Commands reference","description":"A Command is a requested action issued by a Worker to the Temporal Cluster after a Workflow Task Execution completes.","label":"Commands","tags":["reference"],"markdown_content":"\nA [Command](/concepts/what-is-a-command) is a requested action issued by a [Worker](/concepts/what-is-a-worker) to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) after a [Workflow Task Execution](/concepts/what-is-a-workflow-task-execution) completes.\n\nThe following is a complete list of possible Commands.\n\n### CompleteWorkflowExecution\n\nThis Command is triggered when the Workflow Function Execution returns.\nIt indicates to the Cluster that the [Workflow Execution](/concepts/what-is-a-workflow-execution) is complete.\nThe corresponding [Event](/concepts/what-is-an-event) for this Command is one of the few Events that will be the last in a Workflow Execution [Event History](/concepts/what-is-an-event-history).\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [WorkflowExecutionCompleted](/references/events/#workflowexecutioncompleted)\n\n### ContinueAsNewWorkflowExecution\n\nThis Command is triggered when there is a call to [Continue-As-New](/concepts/what-is-continue-as-new) from within the [Workflow](/concepts/what-is-a-workflow).\nThe corresponding Event for this Command is one of the few Events that will be the last in a Workflow Execution Event History.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [WorkflowExecutionContinuedAsNew](/references/events/#workflowexecutioncontinuedasnew)\n\n### FailWorkflowExecution\n\nThis Command is triggered when the Workflow Execution returns an error or an exception is thrown.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [WorkflowExecutionFailed](/references/events/#workflowexecutionfailed)\n\n### CancelWorkflowExecution\n\nThis Command is triggered when the Workflow has successfully cleaned up after receiving a Cancellation Request (which will be present as [WorkflowExecutionCancelRequestedEvent](/references/events/#workflowexecutioncancelrequested) in the Event History).\nThe Corresponding Event for this Command is one of the few Events that will be the last in a Workflow Execution Event History.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [WorkflowExecutionCanceled](/references/events/#workflowexecutioncanceled)\n\n### StartChildWorkflowExecution\n\nThis Command is triggered by a call to spawn a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution).\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [ChildWorkflowExecutionStarted](/references/events/#childworkflowexecutionstarted)\n\n### SignalExternalWorkflowExecution\n\nThis Command is triggered by a call to [Signal](/concepts/what-is-a-signal) another Workflow Execution.\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [SignalExternalWorkflowExecutionInitiated](/references/events/#signalexternalworkflowexecutioninitiated)\n\n### RequestCancelExternalWorkflowExecution\n\nThis Command is triggered by a call to request cancellation of another Workflow Execution.\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [RequestCancelExternalWorkflowExecutionInitiated](/references/events/#requestcancelexternalworkflowexecutioninitiated)\n\n### ScheduleActivityTask\n\nThis Command is triggered by a call to execute an [Activity](/concepts/what-is-an-activity).\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [ActivityTaskScheduled](/references/events/#activitytaskscheduled)\n\n### RequestCancelActivityTask\n\nThis Command is triggered by a call to request the cancellation of an [Activity Task](/concepts/what-is-an-activity-task).\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [ActivityTaskCancelRequested](/references/events/#activitytaskcancelrequested)\n\n### StartTimer\n\nThis Command is triggered by a call to start a Timer.\n\n- Awaitable: Yes, a Workflow Execution can await on the action resulting from this Command.\n- Corresponding Event: [TimerStarted](/references/events/#timerstarted)\n\n### CancelTimer\n\nThis Command is triggered by a call to cancel a Timer.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [TimerCanceled](/references/events/#timercanceled)\n\n### RecordMarker\n\nThis Command is triggered by the SDK.\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [MarkerRecorded](/references/events/#markerrecorded)\n\n### UpsertWorkflowSearchAttributes\n\nThis Command is triggered by a call to \"upsert\" Workflow [Search Attributes](/concepts/what-is-a-search-attribute).\n\n- Awaitable: No, a Workflow Execution can not await on the action resulting from this Command.\n- Corresponding Event: [UpsertWorkflowSearchAttributes](/references/events/#upsertworkflowsearchattributes)\n","is_empty":false},{"file_name":"configuration.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/references/configuration.md","id":"references/configuration","title":"Temporal Cluster configuration reference","description":"Much of the behavior of a Temporal Cluster is configured using the `development.yaml` file.","label":"Cluster configuration","tags":["reference"],"markdown_content":"\nMuch of the behavior of a Temporal Cluster is configured using the `development.yaml` file and may contain the following top-level sections:\n\n- [`global`](#global)\n- [`persistence`](#persistence)\n- [`log`](#log)\n- [`clusterMetadata`](#clustermetadata)\n- [`services`](#services)\n- [`publicClient`](#publicclient)\n- [`archival`](#archival)\n- [`dcRedirectionPolicy`](#dcredirectionpolicy)\n- [`dynamicConfigClient`](#dynamicconfigclient)\n- [`namespaceDefaults`](#namespacedefaults)\n\nChanging any properties in the `development.yaml` file requires a process restart for changes to take effect.\nConfiguration parsing code is available [here](https://github.com/temporalio/temporal/blob/master/common/config/config.go).\n\n## global\n\nThe `global` section contains process-wide configuration. See below for a minimal configuration (optional parameters are commented out.)\n\n```yaml\nglobal:\n  membership:\n    broadcastAddress: \"127.0.0.1\"\n  metrics:\n    prometheus:\n      framework: \"opentelemetry\"\n      listenAddress: \"127.0.0.1:8000\"\n```\n\n### membership\n\nThe `membership` section controls the following membership layer parameters.\n\n#### maxJoinDuration\n\nThe amount of time the service will attempt to join the gossip layer before failing.\n\nDefault is 10s.\n\n#### broadcastAddress\n\nUsed by gossip protocol to communicate with other hosts in the same Cluster for membership info.\nUse IP address that is reachable by other hosts in the same Cluster.\nIf there is only one host in the Cluster, you can use 127.0.0.1.\nCheck `net.ParseIP` for supported syntax, only IPv4 is supported.\n\n### metrics\n\nConfigures the Cluster's metric subsystem.\nSpecific provides are configured using provider names as the keys.\n\n- [`statsd`](#statsd)\n- `prometheus`\n- `m3`\n\n#### prefix\n\nThe prefix to be applied to all outgoing metrics.\n\n#### tags\n\nThe set of key-value pairs to be reported as part of every metric.\n\n#### excludeTags\n\nA map from tag name string to tag values string list.\nThis is useful to exclude some tags that might have unbounded cardinality.\nThe value string list can be used to whitelist values of that excluded tag to continue to be included.\nFor example, if you want to exclude `task_queue` because it has unbounded cardinality, but you still want to see a whitelisted value for `task_queue`.\n\n#### statsd\n\nThe `statsd` sections supports the following settings:\n\n- `hostPort`: The host:port of the statsd server.\n- `prefix`: Specific prefix in reporting to `statsd`.\n- `flushInterval`: Maximum interval for sending packets. (_Default_ 300ms).\n- `flushBytes`: Specifies the maximum UDP packet size you wish to send. (_Default_ 1432 bytes).\n\n#### prometheus\n\nThe `prometheus` sections supports the following settings:\n\n- `framework`: The framework to use, currently supports `opentelemetry` and `tally`, default is `tally`. We plan to switch default to `opentelemetry` once its API become stable.\n- `listenAddress`: Address for Prometheus to scrape metrics from.\n  The Temporal Server uses the Prometheus client API, and the `listenAddress` configuration is used to listen for metrics.\n- `handlerPath`: Metrics handler path for scraper; default is `/metrics`.\n\n#### m3\n\nThe `m3` sections supports the following settings:\n\n- `hostPort`: The host:port of the M3 server.\n- `service`: The service tag to that this client emits.\n- `queue`: M3 reporter queue size, default is 4k.\n- `packetSize`: M3 reporter max packet size, default is 32k.\n\n### pprof\n\n- `port`: If specified, this will initialize pprof upon process start on the listed port.\n\n### tls\n\nThe `tls` section controls the SSL/TLS settings for network communication and contains two subsections, `internode` and `frontend`.\nThe `internode` section governs internal service communication among roles where the `frontend` governs SDK client communication to the Frontend Service role.\n\nEach of these subsections contain a `server` section and a `client` section.\nThe `server` contains the following parameters:\n\n- `certFile`: The path to the file containing the PEM-encoded public key of the certificate to use.\n- `keyFile`: The path to the file containing the PEM-encoded private key of the certificate to use.\n- `requireClientAuth`: _boolean_ - Requires clients to authenticate with a certificate when connecting, otherwise known as mutual TLS.\n- `clientCaFiles`: A list of paths to files containing the PEM-encoded public key of the Certificate Authorities you wish to trust for client authentication. This value is ignored if `requireClientAuth` is not enabled.\n\n:::tip\n\nSee the [server samples repo](https://github.com/temporalio/samples-server/tree/master/tls) for sample TLS configurations.\n\n:::\n\nBelow is an example enabling Server TLS (https) between SDKs and the Frontend APIs:\n\n```yaml\nglobal:\n  tls:\n    frontend:\n      server:\n        certFile: /path/to/cert/file\n        keyFile: /path/to/key/file\n      client:\n        serverName: dnsSanInFrontendCertificate\n```\n\nNote, the `client` section generally needs to be provided to specify an expected DNS SubjectName contained in the presented server certificate via the `serverName` field; this is needed as Temporal uses IP to IP communication.\nYou can avoid specifying this if your server certificates contain the appropriate IP Subject Alternative Names.\n\nAdditionally, the `rootCaFiles` field needs to be provided when the client's host does not trust the Root CA used by the server.\nThe example below extends the above example to manually specify the Root CA used by the Frontend Services:\n\n```yaml\nglobal:\n  tls:\n    frontend:\n      server:\n        certFile: /path/to/cert/file\n        keyFile: /path/to/key/file\n      client:\n        serverName: dnsSanInFrontendCertificate\n        rootCaFiles:\n          - /path/to/frontend/server/CA/files\n```\n\nBelow is an additional example of a fully secured cluster using mutual TLS for both frontend and internode communication with manually specified CAs:\n\n```yaml\nglobal:\n  tls:\n    internode:\n      server:\n        certFile: /path/to/internode/cert/file\n        keyFile: /path/to/internode/key/file\n        requireClientAuth: true\n        clientCaFiles:\n          - /path/to/internode/serverCa\n      client:\n        serverName: dnsSanInInternodeCertificate\n        rootCaFiles:\n          - /path/to/internode/serverCa\n    frontend:\n      server:\n        certFile: /path/to/frontend/cert/file\n        keyFile: /path/to/frontend/key/file\n        requireClientAuth: true\n        clientCaFiles:\n          - /path/to/internode/serverCa\n          - /path/to/sdkClientPool1/ca\n          - /path/to/sdkClientPool2/ca\n      client:\n        serverName: dnsSanInFrontendCertificate\n        rootCaFiles:\n          - /path/to/frontend/serverCa\n```\n\n**Note:** In the case that client authentication is enabled, the `internode.server` certificate is used as the client certificate among services. This adds the following requirements:\n\n- The `internode.server` certificate must be specified on all roles, even for a frontend-only configuration.\n- Internode server certificates must be minted with either **no** Extended Key Usages or **both** ServerAuth and ClientAuth EKUs.\n- If your Certificate Authorities are untrusted, such as in the previous example, the internode server Ca will need to be specified in the following places:\n\n  - `internode.server.clientCaFiles`\n  - `internode.client.rootCaFiles`\n  - `frontend.server.clientCaFiles`\n\n## persistence\n\nThe `persistence` section holds configuration for the data store / persistence layer.\nBelow is an example minimal specification for a password-secured Cluster using Cassandra.\n\n```yaml\npersistence:\n  defaultStore: default\n  visibilityStore: visibility\n  numHistoryShards: 512\n  datastores:\n    default:\n      cassandra:\n        hosts: \"127.0.0.1\"\n        keyspace: \"temporal\"\n        user: \"username\"\n        password: \"password\"\n    visibility:\n      cassandra:\n        hosts: \"127.0.0.1\"\n        keyspace: \"temporal_visibility\"\n```\n\nThe following top level configuration items are required:\n\n### numHistoryShards\n\n_Required_ - The number of history shards to create when initializing the Cluster.\n\n**Warning**: This value is immutable and will be ignored after the first run.\nPlease ensure you set this value appropriately high enough to scale with the worst case peak load for this Cluster.\n\n### defaultStore\n\n_Required_ - The name of the data store definition that should be used by the Temporal server.\n\n### visibilityStore\n\n_Required_ - the name of the data store definition that should be used by the Temporal visibility server.\n\n### datastores\n\n_Required_ - contains named data store definitions to be referenced.\n\nEach definition is defined with a heading declaring a name (ie: `default:` and `visibility:` above), which contains a data store definition.\n\nData store definitions must be either `cassandra` or `sql`.\n\n#### cassandra\n\nA `cassandra` data store definition can contain the following values:\n\n- `hosts`: _Required_ - \",\" separated Cassandra endpoints, e.g. \"192.168.1.2,192.168.1.3,192.168.1.4\".\n- `port`: Default: 9042 - Cassandra port used for connection by `gocql` client.\n- `user`: Cassandra username used for authentication by `gocql` client.\n- `password`: Cassandra password used for authentication by `gocql` client.\n- `keyspace`: _Required_ - the Cassandra keyspace.\n- `datacenter`: The data center filter arg for Cassandra.\n- `maxConns`: The max number of connections to this data store for a single TLS configuration.\n- `tls`: See TLS below.\n\n#### sql\n\nA `sql` data store definition can contain the following values:\n\n- `user`: Username used for authentication.\n- `password`: Password used for authentication.\n- `pluginName`: _Required_ - SQL database type.\n  - _Valid values_: `mysql` or `postgres`.\n- `databaseName` - _required_ - the name of SQL database to connect to.\n- `connectAddr` - _required_ - the remote address of the database, e.g. \"192.168.1.2\".\n- `connectProtocol` - _required_ - the protocol that goes with the `connectAddr`\n  - _Valid values_: `tcp` or `unix`\n- `connectAttributes` - a map of key-value attributes to be sent as part of connect `data_source_name` url.\n- `maxConns` - the max number of connections to this data store.\n- `maxIdleConns` - the max number of idle connections to this data store\n- `maxConnLifetime` - is the maximum time a connection can be alive.\n- `tls` - See below.\n\n#### tls\n\nThe `tls` and `mtls` sections can contain the following values:\n\n- `enabled` - _boolean_.\n- `serverName` - name of the server hosting the data store.\n- `certFile` - path to the cert file.\n- `keyFile` - path to the key file.\n- `caFile` - path to the ca file.\n- `enableHostVerification` - _boolean_ - `true` to verify the hostname and server cert (like a wildcard for Cassandra cluster). This option is basically the inverse of `InSecureSkipVerify`. See `InSecureSkipVerify` in http://golang.org/pkg/crypto/tls/ for more info.\n\nNote: `certFile` and `keyFile` are optional depending on server config, but both fields must be omitted to avoid using a client certificate.\n\n## log\n\nThe `log` section is optional and contains the following possible values:\n\n- `stdout` - _boolean_ - `true` if the output needs to go to standard out.\n- `level` - sets the logging level.\n  - _Valid values_ - debug, info, warn, error or fatal, default to info.\n- `outputFile` - path to output log file.\n\n## clusterMetadata\n\n`clusterMetadata` contains the local cluster information. The information is used in [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication).\n\nAn example `clusterMetadata` section:\n\n```yaml\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 10\n  masterClusterName: \"active\"\n  currentClusterName: \"active\"\n  clusterInformation:\n    active:\n      enabled: true\n      initialFailoverVersion: 0\n      rpcAddress: \"127.0.0.1:7233\"\n  #replicationConsumer:\n  #type: kafka\n```\n\n- `currentClusterName` - _required_ - the name of the current cluster. **Warning**: This value is immutable and will be ignored after the first run.\n- `enableGlobalNamespace` - _Default:_ `false`.\n- `replicationConsumer` - determines which method to use to consume replication tasks. The type may be either `kafka` or `rpc`.\n- `failoverVersionIncrement` - the increment of each cluster version when failover happens.\n- `masterClusterName` - the master cluster name, only the master cluster can register/update namespace. All clusters can do namespace failover.\n- `clusterInformation` - contains the local cluster name to `ClusterInformation` definition. The local cluster name should be consistent with `currentClusterName`. `ClusterInformation` sections consist of:\n  - `enabled` - _boolean_ - whether a remote cluster is enabled for replication.\n  - `initialFailoverVersion`\n  - `rpcAddress` - indicate the remote service address (host:port). Host can be DNS name. Use `dns:///` prefix to enable round-robin between IP address for DNS name.\n\n## services\n\nThe `services` section contains configuration keyed by service role type.\nThere are four supported service roles:\n\n- `frontend`\n- `matching`\n- `worker`\n- `history`\n\nBelow is a minimal example of a `frontend` service definition under `services`:\n\n```yaml\nservices:\n  frontend:\n    rpc:\n      grpcPort: 8233\n      membershipPort: 8933\n      bindOnIP: \"0.0.0.0\"\n```\n\nThere are two sections defined under each service heading:\n\n### rpc\n\n_Required_\n\n`rpc` contains settings related to the way a service interacts with other services. The following values are supported:\n\n- `grpcPort` is the port on which gRPC will listen.\n- `membershipPort`: Port used to communicate with other hosts in the same Cluster for membership info.\n  Each service should use different port.\n  If there are multiple Temporal Clusters in your environment (Kubernetes for example), and they have network access to each other, each cCluster should use different membershipPort.\n- `bindOnLocalHost`: Determines whether uses `127.0.0.1` as the listener address.\n- `bindOnIP`: Used to bind service on specific IP, or `0.0.0.0`.\n  Check `net.ParseIP` for supported syntax, only IPv4 is supported, mutually exclusive with `BindOnLocalHost` option.\n\n**Note**: Port values are currently expected to be consistent among role types across all hosts.\n\n## publicClient\n\nThe `publicClient` a required section describing the configuration needed to for worker to connect to Temporal server for background server maintenance.\n\n- `hostPort` IPv4 host port or DNS name to reach Temporal frontend, [reference](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n\nExample:\n\n```yaml\npublicClient:\n  hostPort: \"localhost:8933\"\n```\n\nUse `dns:///` prefix to enable round-robin between IP address for DNS name.\n","is_empty":false},{"file_name":"events.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/references/events.md","id":"references/events","title":"Events reference","description":"Events are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution.","label":"Events","tags":["reference"],"markdown_content":"\n[Events](/concepts/what-is-an-event) are created by the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) in response to external occurrences and [Commands](/concepts/what-is-a-command) generated by a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nAll possible Events that could appear in a Workflow Execution [Event History](/concepts/what-is-an-event-history) are listed below.\n\n### WorkflowExecutionStarted\n\nThis is always the first [Event](/concepts/what-is-an-event) in a Workflow Execution Event History.\nIt indicates that the Cluster received a request to spawn the Workflow Execution.\n\n| Field                              | Description                                                                                                                                              |\n| ---------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| workflow_type                      | The [Name](/concepts/what-is-a-workflow-type) of [Workflow](/concepts/what-is-a-workflow) that was initiated.                                            |\n| parent_workflow_namespace          | The [Namespace](/concepts/what-is-a-namespace) of the Parent [Workflow Execution](/concepts/what-is-a-workflow-execution), if applicable.                |\n| parent_workflow_execution          | Identifies the parent Workflow and the execution run.                                                                                                    |\n| parent_initiated_event_id          | Id of the [StartWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to.                                      |\n| task_queue                         | The [Task Queue](/concepts/what-is-a-task-queue) that this [Workflow Task](/concepts/what-is-a-workflow-task) was enqueued in.                           |\n| input                              | Information that is deserialized by the SDK to provide arguments to the Workflow.                                                                        |\n| workflow_execution_timeout         | The total timeout period for a [Workflow Execution](/concepts/what-is-a-workflow-execution), including retries and continue-as-new.                      |\n| workflow_run_timeout               | Timeout of a single Workflow run.                                                                                                                        |\n| workflow_task_timeout              | Timeout of a single Workflow Task.                                                                                                                       |\n| continued_execution_run_id         | [Run Id](/concepts/what-is-a-run-id) of the previous Workflow which continued-as-new, retried or was executed by Cron into this Workflow.                |\n| initiator                          | Allows the Workflow to continue as a new Workflow Execution.                                                                                             |\n| continued_failure                  | Serialized result of a failure.                                                                                                                          |\n| last_completion_result             | Information from the previously completed [Task](/concepts/what-is-a-task), if applicable.                                                               |\n| original_execution_run_id          | The [Run Id](/concepts/what-is-a-run-id) of the original Workflow started.                                                                               |\n| identity                           | Id of the [Worker](/concepts/what-is-a-worker) that requested the start of this Workflow.                                                                |\n| first_execution_run_id             | The first [Run Id](/concepts/what-is-a-run-id), along the chain of [Continue-As-New](/concepts/what-is-continue-as-new) Runs and Reset.                  |\n| retry_policy                       | The amount of retries as determined by the service's dynamic configuration. Retries will happen until 'schedule_to_close_timeout' is reached.            |\n| attempt                            | The number of attempts that have been made to complete this Task.                                                                                        |\n| workflow_execution_expiration_time | The absolute time at which the Workflow Execution will [time out](/concepts/what-is-a-workflow-execution-timeout).                                       |\n| cron_schedule                      | Displays the Workflow's [Cron Schedule](/concepts/what-is-a-temporal-cron-job), if applicable.                                                           |\n| first_workflow_task_backoff        | Contains the amount of time between when this iteration of the Workflow was scheduled, and when it should run next. Applies to Cron Scheduling.          |\n| memo                               | Non-indexed information to show in the Workflow.                                                                                                         |\n| search_attributes                  | Provides data for setting up a Workflow's [Search Attributes](/concepts/what-is-a-search-attribute).                                                     |\n| prev_auto_reset_points             |                                                                                                                                                          |\n| header                             | Information passed by the sender of the [Signal](/concepts/what-is-a-signal) that is copied into the [Workflow Task](/concepts/what-is-a-workflow-task). |\n\n### WorkflowExecutionCompleted\n\nThis indicates that the [Workflow Execution](/concepts/what-is-a-workflow-execution) has successfully completed. The [Event](/concepts/what-is-an-event) contains Workflow Execution results.\n\n| Field                            | Description                                                                                                                                             |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| result                           | Serialized result of completed [Workflow](/concepts/what-is-a-workflow).                                                                                |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                                                         |\n| new_execution_run_id             | The [Run Id](/concepts/what-is-a-run-id) of the new Workflow Execution started as a result of a [Cron Schedule](/concepts/what-is-a-temporal-cron-job). |\n\n### WorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) indicates that the [Workflow Execution](/concepts/what-is-a-workflow-execution) has unsuccessfully completed and contains the Workflow Execution error.\n\n| Field                            | Description                                                                                                                       |\n| -------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |\n| failure                          | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                                          |\n| retry_state                      | The reason provided for whether the [Task](/concepts/what-is-a-task) should or shouldn't be retried.                              |\n| workflow_task_completed_event_id | The [Run Id](/concepts/what-is-a-run-id) of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with. |\n| new_execution_run_id             | The [Run Id](/concepts/what-is-a-run-id) of the new Workflow started by Cron or [Retry](/concepts/what-is-a-retry-policy).        |\n\n### WorkflowExecutionTimedOut\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Execution](/concepts/what-is-a-workflow-execution) has timed out by the [Temporal Server](/concepts/what-is-the-temporal-server) due to the [Workflow](/concepts/what-is-a-workflow) having not been completed within [timeout](/concepts/what-is-a-workflow-execution-timeout) settings.\n\n| Field                | Description                                                                                                                |\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| retry_state          | The reason provided for whether the [Task](/concepts/what-is-a-task) should or shouldn't be retried.                       |\n| new_execution_run_id | The [Run Id](/concepts/what-is-a-run-id) of the new Workflow started by Cron or [Retry](/concepts/what-is-a-retry-policy). |\n\n### WorkflowExecutionCancelRequested\n\nThis [Event](/concepts/what-is-an-event) type indicates that a request has been made to cancel the [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\n| Field                       | Description                                                                                                                                      |\n| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| cause                       | The user-provided reason for the cancelation request.                                                                                            |\n| external_initiated_event_id | The [Run Id](/concepts/what-is-a-run-id) of the Event in the [Workflow](/concepts/what-is-a-workflow) that requested cancelation, if applicable. |\n| external_workflow_execution | Identifies the external Workflow and the run of the its execution.                                                                               |\n| identity                    | Id of the [Worker](/concepts/what-is-a-worker) that requested cancelation.                                                                       |\n\n### WorkflowExecutionCanceled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the client has confirmed the cancelation request and the [Workflow Execution](/concepts/what-is-a-workflow-execution) has been canceled.\n\n| Field                            | Description                                                                                       |\n| -------------------------------- | ------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.   |\n| details                          | Additional information reported by the [Workflow](/concepts/what-is-a-workflow) upon cancelation. |\n\n### WorkflowExecutionSignaled\n\nThis [Event](/concepts/what-is-an-event) type indicates the [Workflow](/concepts/what-is-a-workflow) has received a [Signal](/concepts/what-is-a-signal) Event.\nThe Event type contains the Signal name, as well as a Signal payload.\n\n| Field       | Description                                                                                                                |\n| ----------- | -------------------------------------------------------------------------------------------------------------------------- |\n| signal_name | The name/type of Signal to be fired.                                                                                       |\n| input       | Information that is deserialized by the SDK to provide arguments to the Workflow function.                                 |\n| identity    | Identifies the [Worker](/concepts/what-is-a-worker) that signaled to the Workflow.                                         |\n| header      | Information passed by the sender of the Signal that is copied into the [Workflow Task](/concepts/what-is-a-workflow-task). |\n\n### WorkflowExecutionTerminated\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Execution](/concepts/what-is-a-workflow-execution) has been forcefully terminated and that likely the terminate Workflow API was called.\n\n| Field    | Description                                                          |\n| -------- | -------------------------------------------------------------------- |\n| reason   | Information provided by the user or client for Workflow termination. |\n| details  | Additional information reported by the Workflow upon termination.    |\n| identity | Identifies the Worker that requested termination.                    |\n\n### WorkflowExecutionContinuedAsNew\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Workflow has successfully completed, and a new Workflow has been started within the same transaction.\nThis Event type contains last [Workflow Execution](/concepts/what-is-a-workflow-execution) results as well as new Workflow Execution inputs.\n\n| Field                            | Description                                                                                                                    |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| new_execution_run_id             | The [Run Id](/concepts/what-is-a-run-id) of the new Workflow started by this Continue-As-New Event.                            |\n| workflow_type                    | The name/type of Workflow that was started by this Event.                                                                      |\n| task_queue                       | The [Task Queue](/concepts/what-is-a-task-queue) that this [Workflow Task](/concepts/what-is-a-workflow-task) was enqueued in. |\n| input                            | Information that is deserialized by the SDK to provide arguments to the Workflow.                                              |\n| workflow_run_timeout             | Timeout of a single Workflow run.                                                                                              |\n| workflow_task_timeout            | Timeout of a single Workflow Task.                                                                                             |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event command was reported with.                        |\n| backoff_start_interval           | The amount of time to delay the beginning of the [ContinuedAsNew](#workflowexecutioncontinuedasnew) Workflow.                  |\n| initiator                        | Allows the Workflow to continue as a new execution.                                                                            |\n| last_completion_result           | Information passed by the previously completed Task to the ongoing execution.                                                  |\n| header                           | Information passed by the sender of the Signal that is copied into the Workflow Task.                                          |\n| memo                             | Non-indexed information to show in the Workflow.                                                                               |\n| search_attributes                | Provides data for setting up a Workflow's [Search Attributes](/concepts/what-is-a-search-attribute).                           |\n\n### WorkflowTaskScheduled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) has been scheduled.\nThe SDK client should now be able to process any new history events.\n\n| Field                  | Description                                                                                           |\n| ---------------------- | ----------------------------------------------------------------------------------------------------- |\n| task_queue             | The [Task Queue](/concepts/what-is-a-task-queue) that this Workflow Task was enqueued in.             |\n| start_to_close_timeout | The time that the [Worker](/concepts/what-is-a-worker) takes to process this Task once it's received. |\n| attempt                | The number of attempts that have been made to complete this Task.                                     |\n\n### WorkflowTaskStarted\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) has started.\nThe SDK client has picked up the Workflow Task and is processing new history events.\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [WorkflowTaskScheduled](#workflowtaskscheduled) Event that this Workflow Task corresponds to. |\n| identity           | Identifies the [Worker](/concepts/what-is-a-worker) that started this Task.                                 |\n| request_id         | Identifies the Workflow Task request.                                                                       |\n\n### WorkflowTaskCompleted\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) completed.\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [WorkflowTaskScheduled](#workflowtaskscheduled) Event that this Workflow Task corresponds to. |\n| started_event_id   | The Id of the [WorkflowTaskStarted](#workflowtaskstarted) Event that this Task corresponds to.              |\n| identity           | Identity of the [Worker](/concepts/what-is-a-worker) that completed this Task.                              |\n| binary_checksum    | Binary Id of the Worker that completed this Task.                                                           |\n\nThe SDK client picked up the Workflow Task, processed new history events, and may or may not ask the [Temporal Server](/concepts/what-is-the-temporal-server) to do additional work.\nIt is possible for the following events to still occur:\n\n- [ActivityTaskScheduled](#activitytaskscheduled)\n- [TimerStarted](#timerstarted)\n- [UpsertWorkflowSearchAttributes](#upsertworkflowsearchattributes)\n- [MarkerRecorded](#markerrecorded)\n- [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated)\n- [RequestCancelExternalWorkflowExecutionInitiated](#requestcancelexternalworkflowexecutioninitiated)\n- [SignalExternalWorkflowExecutionInitiated](#signalexternalworkflowexecutioninitiated)\n- [WorkflowExecutionCompleted](#workflowexecutioncompleted)\n- [WorkflowExecutionFailed](#workflowexecutionfailed)\n- [WorkflowExecutionCanceled](#workflowexecutioncanceled)\n- [WorkflowExecutionContinuedAsNew](#workflowexecutioncontinuedasnew)\n\n### WorkflowTaskTimedOut\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) encountered a [timeout](/concepts/what-is-a-workflow-task-timeout).\nEither an SDK client with a local cache was not available at the time, or it took too long for the SDK client to process the Task.\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [WorkflowTaskScheduled](#workflowtaskscheduled) Event that this Workflow Task corresponds to. |\n| started_event_id   | The Id of the [WorkflowTaskStarted](#workflowtaskstarted) Event that this Task corresponds to.              |\n| timeout_type       | The type of timeout that has occurred.                                                                      |\n\n### WorkflowTaskFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Workflow Task](/concepts/what-is-a-workflow-task) encountered a failure.\nUsually this means that the Workflow was non-deterministic.\nHowever, the Workflow reset functionality also uses this Event.\n\n| Field              | Description                                                                                                                                             |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [WorkflowTaskScheduled](#workflowtaskscheduled) Event that this Workflow Task corresponds to.                                             |\n| started_event_id   | The Id of the [WorkflowTaskStarted](#workflowtaskstarted) Event that this Workflow Task corresponds to.                                                 |\n| failure            | Details for the Workflow Task's failure.                                                                                                                |\n| identity           | The identity of the [Worker](/concepts/what-is-a-worker) that failed this Task. The Worker must be explicitly defined to return a value for this field. |\n| base_run_id        | The original [Run Id](/concepts/what-is-a-run-id) of the Workflow.                                                                                      |\n| new_run_id         | The Run Id of the reset Workflow.                                                                                                                       |\n| fork_event_version | Identifies the Event version that was forked off to the reset Workflow.                                                                                 |\n| binary_checksum    | The Binary Id of the Worker that failed this Task. The Worker must be explicitly defined to return a value for this field.                              |\n\n### ActivityTaskScheduled\n\nThis [Event](/concepts/what-is-an-event) type indicates that an [Activity Task](/concepts/what-is-an-activity-task) was scheduled.\nThe SDK client should pick up this Activity Task and execute.\nThis Event type contains Activity inputs, as well as Activity Timeout configurations.\n\n| Field                            | Description                                                                                                                                              |\n| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| activity_id                      | The identifier assigned to this Activity by a [Worker](/concepts/what-is-a-worker) or user.                                                              |\n| activity_type                    | The [type of Activity](/concepts/what-is-an-activity-type) that was scheduled.                                                                           |\n| namespace                        | Namespace of the Workflow that the [Activity](/concepts/what-is-an-activity) resides in.                                                                 |\n| task_queue                       | The [Task Queue](/concepts/what-is-a-task-queue) that this Activity Task was enqueued in.                                                                |\n| header                           | Information passed by the sender of the [Signal](/concepts/what-is-a-signal) that is copied into the [Workflow Task](/concepts/what-is-a-workflow-task). |\n| input                            | Information that is deserialized by the SDK to provide arguments to the [Workflow](/concepts/what-is-a-workflow) function.                               |\n| schedule_to_close_timeout        | The amount of time that a caller will wait for Activity completion. Limits the amount of time that retries will be attempted for this Activity.          |\n| schedule_to_start_timeout        | Limits the time that an Activity Task can stay in a Task Queue. This timeout cannot be retried.                                                          |\n| start_to_close_timeout           | Maximum amount of execution time that an Activity is allowed after being picked up by a Worker. This timeout is retryable.                               |\n| heartbeat_timeout                | Maximum amount of time allowed between successful Worker heartbeats.                                                                                     |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                                                          |\n| retry_policy                     | The amount of retries as determined by the service's dynamic configuration. Retries will happen until `schedule_to_close_timeout` is reached.            |\n\n### ActivityTaskStarted\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Activity Task](/concepts/what-is-an-activity-task) has started executing.\nThe SDK client has picked up the Activity Task and is processing the [Activity](/concepts/what-is-an-activity) invocation.\n\n| Field              | Description                                                                                                          |\n| ------------------ | -------------------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this Task corresponds to.                   |\n| identity           | Identifies the [Worker](/concepts/what-is-a-worker) that started the Task.                                           |\n| request_id         | Identifies the Activity Task request.                                                                                |\n| attempt            | The number of attempts that have been made to complete this Task.                                                    |\n| last_failure       | Details from the most recent failure Event. Only assigned values if the Task has previously failed and been retried. |\n\n### ActivityTaskCompleted\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Activity Task](/concepts/what-is-an-activity-task) has completed.\nThe SDK client has picked up and successfully completed the Activity Task.\nThis Event type contains [Activity Execution](/concepts/what-is-an-activity-execution) results.\n\n| Field              | Description                                                                                                    |\n| ------------------ | -------------------------------------------------------------------------------------------------------------- |\n| result             | Serialized result of a completed [Activity](/concepts/what-is-an-activity).                                    |\n| scheduled_event_id | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this completion Event corresponds to. |\n| started_event_id   | The Id of the [ActivityTaskStarted](#activitytaskstarted) Event that this Task corresponds to.                 |\n| identity           | Identity of the [Worker](/concepts/what-is-a-worker) that completed this Task.                                 |\n\n### ActivityTaskFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Activity Task](/concepts/what-is-an-activity-task) has completed.\nThe SDK picked up the Activity Task but unsuccessfully completed it.\nThis Event type contains [Activity Execution](/concepts/what-is-an-activity-execution) errors.\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| failure            | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                    |\n| scheduled_event_id | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this failure Event corresponds to. |\n| started_event_id   | The Id of the [ActivityTaskStarted](#activitytaskstarted) Event that this failure corresponds to.           |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                    |\n\n### ActivityTaskTimedOut\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Activity has timed out according to the [Temporal Server](/concepts/what-is-the-temporal-server) , due to the [Activity](/concepts/what-is-an-activity) having not completed within the timeout settings.\n\n| Field              | Description                                                                                                 |\n| ------------------ | ----------------------------------------------------------------------------------------------------------- |\n| failure            | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                    |\n| scheduled_event_id | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this timeout Event corresponds to. |\n| started_event_id   | The Id of the [ActivityTaskStarted](#activitytaskstarted) Event that this timeout corresponds to.           |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                    |\n\n### ActivityTaskCancelRequested\n\nThis [Event](/concepts/what-is-an-event) type indicates that a request to cancel the [Activity](/concepts/what-is-an-activity) has occurred.\nThe SDK client will be able to confirm cancelation of an Activity during an Activity heartbeat.\n\n| Field                            | Description                                                                                                |\n| -------------------------------- | ---------------------------------------------------------------------------------------------------------- |\n| scheduled_event_id               | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this cancel Event corresponds to. |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.            |\n\n### ActivityTaskCanceled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Activity](/concepts/what-is-an-activity) has been canceled.\n\n| Field                            | Description                                                                                                                |\n| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| details                          | Additional information reported by the Activity upon confirming cancelation.                                               |\n| latest_cancel_requested_event_id | Id of the most recent [ActivityTaskCancelRequested](#activitytaskcancelrequested) Event which refers to the same Activity. |\n| scheduled_event_id               | The Id of the [ActivityTaskScheduled](#activitytaskscheduled) Event that this cancelation corresponds to.                  |\n| started_event_id                 | The Id of the [ActivityTaskStarted](#activitytaskstarted) Event that this cancelation corresponds to.                      |\n| identity                         | Identifies the [Worker](/concepts/what-is-a-worker) that requested cancelation.                                            |\n\n### TimerStarted\n\nThis [Event](/concepts/what-is-an-event) type indicates a timer has started.\n\n| Field                            | Description                                                                                     |\n| -------------------------------- | ----------------------------------------------------------------------------------------------- |\n| timer_id                         | The Id assigned for the timer by a [Worker](/concepts/what-is-a-worker) or user.                |\n| start_to_fire_timeout            | Amount of time to elapse before the timer fires.                                                |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with. |\n\n### TimerFired\n\nThis [Event](/concepts/what-is-an-event) type indicates a timer has fired.\n\n| Field            | Description                                                                      |\n| ---------------- | -------------------------------------------------------------------------------- |\n| timer_id         | The Id assigned for the timer by a [Worker](/concepts/what-is-a-worker) or user. |\n| started_event_id | The Id of the [TimerStarted](#timerstarted) Event itself.                        |\n\n### TimerCanceled\n\nThis [Event](/concepts/what-is-an-event) type indicates a Timer has been canceled.\n\n| Field                            | Description                                                                                     |\n| -------------------------------- | ----------------------------------------------------------------------------------------------- |\n| timer_id                         | The Id assigned for the timer by a [Worker](/concepts/what-is-a-worker) or user.                |\n| started_event_id                 | The Id of the [TimerStarted](#timerstarted) Event itself.                                       |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with. |\n\n### RequestCancelExternalWorkflowExecutionInitiated\n\nThis [Event](/concepts/what-is-an-event) type indicates that a [Workflow](/concepts/what-is-a-workflow) has requested that the [Temporal Server](/concepts/what-is-the-temporal-server) try to cancel another Workflow.\n\n| Field                            | Description                                                                                              |\n| -------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.          |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Workflow that`s going to be signaled for execution.    |\n| workflow_execution               | Identifies the Workflow and the run of the [Workflow Execution](/concepts/what-is-a-workflow-execution). |\n| child_workflow_only              | Set to true if this Workflow is a child of the Workflow which issued the cancelation request.            |\n| reason                           | Information provided by the user or client for Workflow cancelation.                                     |\n\n### RequestCancelExternalWorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that [Temporal Server](/concepts/what-is-the-temporal-server) could not cancel the targeted [Workflow](/concepts/what-is-a-workflow).\nThis is usually because the target Workflow could not be found.\n\n| Field                            | Description                                                                                              |\n| -------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.          |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Workflow that failed to cancel.                        |\n| workflow_execution               | Identifies the Workflow and the run of the [Workflow Execution](/concepts/what-is-a-workflow-execution). |\n| initiated_event_id               | Id of the [RequestCancelExternalWorkflowExecutionInitiated] Event this failure corresponds to.           |\n\n### ExternalWorkflowExecutionCancelRequested\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) has successfully requested the cancelation of the target [Workflow](/concepts/what-is-a-workflow).\n\n| Field              | Description                                                                                                                                                       |\n| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| initiated_event_id | Id of the [RequestCancelExternalWorkflowExecutionInitiated](#requestcancelexternalworkflowexecutioninitiated) Event that this cancelation request corresponds to. |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Workflow that was requested to cancel.                                                                          |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/concepts/what-is-a-workflow-execution).                                                          |\n\n### ExternalWorkflowExecutionSignaled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) has successfully [Signaled](/concepts/what-is-a-signal) the targeted [Workflow](/concepts/what-is-a-workflow).\n\n| Field              | Description                                                                                                                      |\n| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |\n| initiated_event_id | Id of the [SignalExternalWorkflowExecutionInitiated](#signalexternalworkflowexecutioninitiated) Event this Event corresponds to. |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Workflow that was signaled to.                                                 |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/concepts/what-is-a-workflow-execution).                         |\n\n### MarkerRecorded\n\nThis [Event](/concepts/what-is-an-event) type is transparent to the [Temporal Server](/concepts/what-is-the-temporal-server) .\nThe Server will only store it and will not try to understand it.\nThe SDK client may use it for local activities or side effects.\n\n| Field                            | Description                                                                                                  |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------ |\n| marker_name                      | Identifies various markers.                                                                                  |\n| details                          | Serialized information recorded in the marker.                                                               |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.              |\n| header                           | Information passed by the sender of the [Signal](/concepts/what-is-a-signal) that is copied into the marker. |\n| failure                          | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                     |\n\n### StartChildWorkflowExecutionInitiated\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) will try to start a Child Workflow.\n\n| Field         | Description                                                       |\n| ------------- | ----------------------------------------------------------------- |\n| namespace     | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow. |\n| workflow_id   | Identifies the Child Workflow.                                    |\n| workflow_type | The name/type of Workflow that was initiated.                     |\n\n### StartChildWorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) cannot be started / triggered.\nIt is usually due to a Child Workflow Id collision.\n\n| Field                            | Description                                                                                                              |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow.                                                        |\n| workflow_id                      | Identifies the Child Workflow.                                                                                           |\n| workflow_type                    | The name/type of Workflow that has failed.                                                                               |\n| initiated_event_id               | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                          |\n\n### ChildWorkflowExecutionStarted\n\nThis [Event](/concepts/what-is-an-event) type indicates a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) has successfully started / triggered.\nThis would also cause the [WorkflowExecutionStarted](#workflowexecutionstarted) to be recorded for the Workflow that has started.\n\n| Field              | Description                                                                                                               |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------- |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow.                                                         |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to.  |\n| workflow_execution | Identifies the Workflow and the run of the Workflow Execution.                                                            |\n| workflow_type      | The name/type of Workflow that has started execution.                                                                     |\n| header             | Information passed by the sender of the [Signal](/concepts/what-is-a-signal) that is copied into the Child Workflow Task. |\n\n### ChildWorkflowExecutionCompleted\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) has successfully completed.\nThis would also cause the [WorkflowExecutionCompleted](#workflowexecutioncompleted) to be recorded for the [Workflow](/concepts/what-is-a-workflow) that has completed.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| result             | Serialized result of the completed Child Workflow.                                                                       |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the completed Child Workflow.                                              |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/concepts/what-is-a-workflow-execution).                 |\n| workflow_type      | The name/type of Workflow that was completed.                                                                            |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event this Event corresponds to.               |\n\n### ChildWorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) has unsuccessfully completed.\nThis would also cause the [WorkflowExecutionFailed](#workflowexecutionfailed) to be recorded for the Workflow that has failed.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| failure            | Serialized result of a [Workflow](/concepts/what-is-a-workflow) failure.                                                 |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow that failed.                                            |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/concepts/what-is-a-workflow-execution).                 |\n| workflow_type      | The name/type of Workflow that has failed.                                                                               |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event this failure corresponds to.             |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                                 |\n\n### ChildWorkflowExecutionCanceled\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Child Workflow Execution has been canceled.\nThis would also cause the [WorkflowExecutionCanceled](#workflowexecutioncanceled) to be recorded for the Workflow that was canceled.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| details            | Additional information reported by the Child Workflow upon cancelation.                                                  |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow that was canceled.                                      |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/concepts/what-is-a-workflow-execution).                 |\n| workflow_type      | The name/type of Workflow that was canceled.                                                                             |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event this cancelation corresponds to.         |\n\n### ChildWorkflowExecutionTimedOut\n\nThis Event type indicates that the [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) has timed out by the [Temporal Server](/concepts/what-is-the-temporal-server).\nThis would also cause the [WorkflowExecutionTimeOut](#workflowexecutiontimedout) to be recorded for the Workflow that timed out.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow.                                                        |\n| workflow_execution | Identifies the Workflow and the run of the Workflow Execution.                                                           |\n| workflow_type      | The name/type of Workflow that has timed out.                                                                            |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event that this timeout corresponds to.        |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                                 |\n\n### ChildWorkflowExecutionTerminated\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Child Workflow Execution has been terminated.\nThis would also cause the [WorkflowExecutionTerminated](#workflowexecutionterminated) to be recorded for the Workflow that was terminated.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| namespace          | [Namespace](/concepts/what-is-a-namespace) of the Child Workflow.                                                        |\n| workflow_execution | Identifies the Workflow and the run of the Workflow Execution.                                                           |\n| workflow_type      | The name/type of Workflow that was terminated.                                                                           |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event that this termination corresponds to.    |\n| retry_state        | The reason provided for whether the Task should or shouldn't be retried.                                                 |\n\n### SignalExternalWorkflowExecutionInitiated\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) will try to [Signal](/concepts/what-is-a-signal) the targeted [Workflow](/concepts/what-is-a-workflow).\nThis Event type contains the Signal name, as well as a Signal payload.\n\n| Field                            | Description                                                                                              |\n| -------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.          |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Workflow that's to be signaled.                        |\n| workflow_execution               | Identifies the Workflow and the run of the [Workflow Execution](/concepts/what-is-a-workflow-execution). |\n| signal_name                      | The name/type of Signal to be fired.                                                                     |\n| input                            | Information that is deserialized by the SDK to provide arguments to the Workflow Function.               |\n| child_workflow_only              | Set to true if this Workflow is a child of the Workflow which issued the cancelation request.            |\n| header                           | Information to be passed from the Signal to the targeted Workflow.                                       |\n\n### SignalExternalWorkflowExecutionFailed\n\nThis [Event](/concepts/what-is-an-event) type indicates that the [Temporal Server](/concepts/what-is-the-temporal-server) cannot Signal the targeted [Workflow](/concepts/what-is-a-workflow), usually because the Workflow could not be found.\n\n| Field                            | Description                                                                                                                                                                           |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                                                                                       |\n| namespace                        | [Namespace](/concepts/what-is-a-namespace) of the Workflow that failed to execute.                                                                                                    |\n| workflow_execution               | Identifies the Workflow and the run of the [Workflow Execution](/concepts/what-is-a-workflow-execution).                                                                              |\n| initiated_event_id               | Id of the [RequestCancelExternalWorkflowExecutionInitiated](#requestcancelexternalworkflowexecutioninitiated) Event this failure [signal](/concepts/what-is-a-signal) corresponds to. |\n\n### UpsertWorkflowSearchAttributes\n\nThis [Event](/concepts/what-is-an-event) type indicates that the Workflow [Search Attributes](/concepts/what-is-a-search-attribute) should be updated and synchronized with the visibility store.\n\n| Field                            | Description                                                                                          |\n| -------------------------------- | ---------------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.      |\n| search_attributes                | Provides data for setting up a Workflow`s [Search Attributes](/concepts/what-is-a-search-attribute). |\n","is_empty":false},{"file_name":"sdk-metrics.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/references/sdk-metrics.md","id":"references/sdk-metrics","title":"SDK metrics","description":"The Temporal SDKs emit metrics from Temporal Client usage and Worker Processes.","label":"SDK metrics","tags":["reference"],"markdown_content":"\n> For Cluster metrics, see [Cluster ▶️ Production deployment ▶️ Scaling and Metrics](/server/production-deployment/#scaling-and-metrics).\n> For Cloud metrics, see [Temporal Cloud ▶️ Cloud metrics](/cloud/how-to-monitor-temporal-cloud-metrics).\n\nThe Temporal SDKs emit a set of metrics from Temporal Client usage and Worker Processes.\nAll metrics are prefixed with `temporal_` before being exported to their configured destination.\n(The prefix has been removed in the following reference.)\nCurrently, some metrics are specific to certain SDKs.\n\nMetrics are defined in the following locations (The Typescript SDK metrics are defined in the Core SDK and PHP SDK metric are defined in the Go SDK):\n\n- [Core SDK Worker metrics](https://github.com/temporalio/sdk-core/blob/master/core/src/telemetry/metrics.rs)\n- [Core SDK Client metrics](https://github.com/temporalio/sdk-core/blob/master/client/src/metrics.rs)\n- [Java SDK Worker metrics](https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/worker/MetricsType.java)\n- [Java SDK Client metrics](https://github.com/temporalio/sdk-java/blob/master/temporal-serviceclient/src/main/java/io/temporal/serviceclient/MetricsType.java)\n- [Go SDK Worker and Client metrics](https://github.com/temporalio/sdk-go/blob/c32b04729cc7691f80c16f80eed7f323ee5ce24f/internal/common/metrics/constants.go)\n\nEach metric may have some combination of the following keys attached to them:\n\n- `task-queue`: Task Queue that the Worker Entity is polling\n- `namespace`: Namespace the Worker is bound to\n- `poller_type`: One of the following:\n  - `workflow_task`\n  - `activity_task`\n  - `sticky_workflow_task`\n- `worker_type`: One of the following:\n  - `ActivityWorker`\n  - `WorkflowWorker`\n  - `LocalActivityWorker` (Go and Java only)\n- `activity_type`: The name of the Activity Function the metric is associated with\n- `workflow_type`: The name of the Workflow Function the metric is associated with\n- `operation`: RPC method name; available for metrics related to Temporal Client gRPC requests\n\nSome keys may not be available in every SDK, and Histogram metrics may have different buckets in each SDK.\n\n| Metric name                                                                             | Emitted by     | Metric type | Availability              |\n| --------------------------------------------------------------------------------------- | -------------- | ----------- | ------------------------- |\n| [activity_execution_cancelled](#activity_execution_cancelled)                           | Worker         | Counter     | Java                      |\n| [activity_execution_failed](#activity_execution_failed)                                 | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [activity_execution_latency](#activity_execution_latency)                               | Worker         | Histogram   | TypeScript, Go, PHP, Java |\n| [activity_poll_no_task](#activity_poll_no_task)                                         | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [activity_schedule_to_start_latency](#activity_schedule_to_start_latency)               | Worker         | Histogram   | TypeScript, Go, PHP, Java |\n| [activity_task_error](#activity_task_error)                                             | Worker         | Counter     | Go, PHP                   |\n| [corrupted_signals](#corrupted_signals)                                                 | Worker         | Counter     | Go, PHP, Java             |\n| [local_activity_execution_cancelled](#local_activity_execution_cancelled)               | Worker         | Counter     | Go, PHP, Java             |\n| [local_activity_execution_failed](#local_activity_execution_failed)                     | Worker         | Counter     | Go, PHP, Java             |\n| [local_activity_execution_latency](#local_activity_execution_latency)                   | Worker         | Histogram   | Go, PHP, Java             |\n| [local_activity_succeeded_endtoend_latency](#local_activity_succeeded_endtoend_latency) | Worker         | Histogram   | Go, PHP, Java             |\n| [local_activity_total](#local_activity_total)                                           | Worker         | Counter     | Go, PHP, Java             |\n| [long_request](#long_request)                                                           | Service Client | Counter     | TypeScript, Go, PHP, Java |\n| [long_request_failure](#long_request_failure)                                           | Service Client | Counter     | TypeScript, Go, PHP, Java |\n| [long_request_latency](#long_request_latency)                                           | Service Client | Histogram   | TypeScript, Go, PHP, Java |\n| [num_pollers](#num_pollers)                                                             | Worker         | Gauge       | TypeScript                |\n| [poller_start](#poller_start)                                                           | Worker         | Counter     | Go, PHP, Java             |\n| [request](#request)                                                                     | Service Client | Counter     | TypeScript, Go, PHP, Java |\n| [request_failure](#request_failure)                                                     | Service Client | Counter     | TypeScript, Go, PHP, Java |\n| [request_latency](#request_latency)                                                     | Service Client | Histogram   | TypeScript, Go, PHP, Java |\n| [sticky_cache_hit](#sticky_cache_hit)                                                   | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [sticky_cache_miss](#sticky_cache_miss)                                                 | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [sticky_cache_size](#sticky_cache_size)                                                 | Worker         | Gauge       | TypeScript, Go, PHP, Java |\n| [sticky_cache_total_forced_eviction](#sticky_cache_total_forced_eviction)               | Worker         | Counter     | Go, PHP, Java             |\n| [task_latency_load](#task_latency_load)                                                 | Worker         |             |                           |\n| [unregistered_activity_invocation](#unregistered_activity_invocation)                   | Worker         | Counter     | Go, PHP                   |\n| [worker_start](#worker_start)                                                           | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [worker_task_slots_available](#worker_task_slots_available)                             | Worker         | Gauge       | Go, PHP, Java             |\n| [workflow_active_thread_count](#workflow_active_thread_count)                           | Worker         | Gauge       | Java                      |\n| [workflow_cancelled](#workflow_cancelled)                                               | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [workflow_completed](#workflow_completed)                                               | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [workflow_continue_as_new](#workflow_continue_as_new)                                   | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [workflow_endtoend_latency](#workflow_endtoend_latency)                                 | Worker         | Histogram   | TypeScript, Go, PHP, Java |\n| [workflow_failed](#workflow_failed)                                                     | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [workflow_task_execution_failed](#workflow_task_execution_failed)                       | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [workflow_task_execution_latency](#workflow_task_execution_latency)                     | Worker         | Histogram   | TypeScript, Go, PHP, Java |\n| [workflow_task_queue_poll_empty](#workflow_task_queue_poll_empty)                       | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [workflow_task_queue_poll_succeed](#workflow_task_queue_poll_succeed)                   | Worker         | Counter     | TypeScript, Go, PHP, Java |\n| [workflow_task_replay_latency](#workflow_task_replay_latency)                           | Worker         | Histogram   | TypeScript, Go, PHP, Java |\n| [workflow_task_schedule_to_start_latency](#workflow_task_schedule_to_start_latency)     | Worker         | Histogram   | TypeScript, Go, PHP, Java |\n\n### activity_execution_cancelled\n\nAn Activity Execution was canceled.\n\n- Type: Counter\n- Available in: Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### activity_execution_failed\n\nAn Activity Execution failed.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### activity_execution_latency\n\nTime to complete an Activity Execution, from the time the Activity Task is generated to the time the language SDK responded with a completion (failure or success).\n\n- Type: Histogram\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### activity_poll_no_task\n\nAn Activity Worker poll for an Activity Task timed out, and no Activity Task is available to pick from the Task Queue.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### activity_schedule_to_start_latency\n\nThe Schedule-To-Start time of an Activity Task in milliseconds.\nA [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) can be set when an Activity Execution is spawned.\nThis metric is useful for ensuring Activity Tasks are being processed from the queue in a timely manner. Some SDKs may include\nthe `activity_type` label, but the metric should not vary by type, as it does not influence the rate at which tasks are pulled\nfrom the queue.\n\n- Type: Histogram\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`\n\n### activity_task_error\n\nAn internal error or panic occurred during Activity Task handling or execution.\n\n- Type: Counter\n- Available in: Go, PHP\n- Tags: `activity_type`, `namespace`, `task_queue`, `workflow_type`\n\n### corrupted_signals\n\nNumber of Signals whose payload could not be deserialized.\n\n- Type: Counter\n- Available in: Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### local_activity_execution_cancelled\n\nA Local Activity Execution was canceled.\n\n- Type: Counter\n- Available in: Go, PHP, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### local_activity_execution_failed\n\nA Local Activity Execution failed.\n\n- Type: Counter\n- Available in: Go, PHP, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### local_activity_execution_latency\n\nTime to complete a Local Activity Execution, from the time the first Activity Task is generated to the time the SDK responds that the execution is complete.\n\n- Type: Histogram\n- Available in: Go, PHP, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### local_activity_succeeded_endtoend_latency\n\nTotal latency of successfully finished Local Activity Executions (from schedule to completion).\n\n- Type: Histogram\n- Available in: Go, PHP, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### local_activity_total\n\nTotal number of [Local Activity Executions](/concepts/what-is-a-local-activity).\n\n- Type: Counter\n- Available in: Go, PHP, Java\n- Tags: `activity_type`, `namespace`, `task_queue`\n\n### long_request\n\nTemporal Client made an RPC long poll request.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `operation`\n\n### long_request_failure\n\nTemporal Client made an RPC long poll request that failed.\nThis number is included into the total `long_request` counter for long poll RPC requests.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `operation`\n\n### long_request_latency\n\nLatency of a Temporal Client gRPC long poll request.\n\n- Type: Histogram\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `operation`\n\n### num_pollers\n\nCurrent number of Worker Entities that are polling.\n\n- Type: Gauge\n- Available in: TypeScript\n- Tags: `namespace`, `poller_type`, `task_queue`\n\n### poller_start\n\nA Worker Entity poller was started.\n\n- Type: Counter\n- Available in: Go, PHP, Java\n- Tags: `namespace`, `task_queue`\n\n### request\n\nTemporal Client made an RPC request.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `operation`\n\n### request_failure\n\nTemporal Client made an RPC request that failed.\nThis number is included into the total `request` counter for RPC requests.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `operation`\n\n### request_latency\n\nLatency of a Temporal Client gRPC request.\n\n- Type: Histogram\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `operation`\n\n### sticky_cache_hit\n\nA Workflow Task found a cached Workflow Execution Event History to run against.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`\n\n### sticky_cache_miss\n\nA Workflow Task did not find a cached Workflow Worker.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`\n\n### sticky_cache_size\n\nCurrent cache size, expressed in number of Workflow Executions.\n\n- Type: Gauge\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace` (TypeScript, Java), `task_queue` (TypeScript)\n\n### sticky_cache_total_forced_eviction\n\nA Workflow Execution has been forced from the cache intentionally.\n\n- Type: Counter\n- Available in: Go, PHP, Java\n- Tags: `namespace`, `task_queue`\n\n### task_latency_load\n\nMeasures the duration from task generation to task loading (task schedule to start latency for persistence queue).\n\n- Type:\n- Available in:\n- Tags:\n\n### unregistered_activity_invocation\n\nA request to spawn an Activity Execution is not registered with the Worker.\n\n- Type: Counter\n- Available in: Go, PHP\n- Tags: `activity_type`, `namespace`, `task_queue`, `workflow_type`\n\n### worker_start\n\nA Worker Entity has been registered, created, or started.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `worker_type`\n\n### worker_task_slots_available\n\nThe total number of Workflow Task and Activity Task execution slots that are currently available.\nUse the `worker_type` key to differentiate execution slots.\n(Workflow Workers execute Workflow Tasks; Activity Workers execute Activity Tasks.)\n\n- Type: Gauge\n- Available in: Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `worker_type`\n\n### workflow_active_thread_count\n\nTotal amount of Workflow threads in the Worker Process.\n\n- Type: Gauge\n- Available in: Java\n\n### workflow_cancelled\n\nWorkflow Execution ended because of a cancellation request.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_completed\n\nA Workflow Execution completed successfully.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_continue_as_new\n\nA Workflow ended with Continue-As-New.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_endtoend_latency\n\nTotal Workflow Execution time from schedule to completion for a single Workflow Run. (A retried Workflow Execution is a separate Run.)\n\n- Type: Histogram\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_failed\n\nA Workflow Execution failed.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_execution_failed\n\nA Workflow Task Execution failed.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_execution_latency\n\nWorkflow Task Execution time.\n\n- Type: Histogram\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_queue_poll_empty\n\nA Workflow Worker polled a Task Queue and timed out without picking up a Workflow Task.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_queue_poll_succeed\n\nA Workflow Worker polled a Task Queue and successfully picked up a Workflow Task.\n\n- Type: Counter\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_replay_latency\n\nTime to catch up on replaying a Workflow Task.\n\n- Type: Histogram\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n\n### workflow_task_schedule_to_start_latency\n\nThe Schedule-To-Start time of a Workflow Task.\n\n- Type: Histogram\n- Available in: TypeScript, Go, PHP, Java\n- Tags: `namespace`, `task_queue`, `workflow_type`\n","is_empty":false},{"file_name":"server-options.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/references/server-options.md","id":"references/server-options","title":"Temporal Server options","description":"You can run the Temporal Server as a Go application by including the server package `go.temporal.io/server/temporal` and using it to create and start a Temporal Server.","label":"Start options","tags":["reference","web-ui"],"markdown_content":"\nYou can run the [Temporal Server](/concepts/what-is-the-temporal-server) as a Go application by including the server package `go.temporal.io/server/temporal` and using it to create and start a Temporal Server.\n\nThe Temporal Server services can be [run in various ways](/kb/all-the-ways-to-run-a-cluster).\nWe recommend this approach for a limited number of situations.\n\n```go\ns := temporal.NewServer()\nerr := s.Start()\nif err != nil{\n\tlog.Fatal(err)\n}\n```\n\n`NewServer()` accepts functions as parameters.\nEach function returns a `ServerOption` that is applied to the instance.\nSource code for parameter reference is here: https://github.com/temporalio/temporal/blob/master/temporal/server_option.go\n\n### WithConfig\n\nOverrides the default configuration with a custom configuration that is defined in the config package `go.temporal.io/server/common/service/config`.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithConfig(cfg),\n)\n```\n\n### WithConfigLoader\n\nLoad a custom configuration from a file.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithConfigLoader(configDir, env, zone),\n)\n```\n\n### ForServices\n\nSets the list of all valid temporal services.\nThe default can be used from the `go.temporal.io/server/temporal` package.\n\n```go\ns := temporal.NewServer(\n\ttemporal.ForServices(temporal.Services),\n)\n```\n\n### InterruptOn\n\nThis option provides a channel that interrupts the server on the signal from that channel.\n\n- If `temporal.InterruptOn()` is not passed, `server.Start()` is never blocked and you need to call `server.Stop()` somewhere.\n- If `temporal.InterruptOn(nil)` is passed, `server.Start()` blocks forever until the process is killed.\n- If `temporal.InterruptOn(temporal.InterruptCh())` is passed, `server.Start()` blocks until you use Ctrl+C, which then gracefully shuts the server down.\n- If `temporal.Interrupt(someCustomChan)` is passed, `server.Start()` blocks until a signal is sent to `someCustomChan`.\n\n```go\ns := temporal.NewServer(\n\ttemporal.InterruptOn(temporal.InterruptCh()),\n)\n```\n\n### WithAuthorizer\n\nSets a low level [authorization mechanism](/concepts/what-is-an-authorizer-plugin) that determines whether to allow or deny inbound API calls.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithAuthorizer(myAuthorizer),\n)\n```\n\n### WithTLSConfigFactory\n\nOverrides the default TLS configuration provider.\n`TLSConfigProvider` is defined in the `go.temporal.io/server/common/rpc/encryption` package.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithTLSConfigFactory(yourTLSConfigProvider),\n)\n```\n\n### WithClaimMapper\n\nConfigures a [mechanism to map roles](/security/#claimmapper-plugin-interface) to `Claims` for authorization.\n\n```go\ns := temporal.NewServer(\n  temporal.WithClaimMapper(func(cfg *config.Config) authorization.ClaimMapper {\n\t\treturn authorization.NewDefaultJWTClaimMapper(\n\t\t\tauthorization.NewRSAKeyProvider(cfg),\n\t\t\tcfg\n\t\t)\n\t}),\n)\n```\n\n### WithCustomMetricsReporter\n\nSets a custom tally metric reporter.\n\n```go\ns := temporal.NewServer(\n\ttemporal.WithCustomMetricsReporter(myReporter),\n)\n```\n\nYou can see the [Uber tally docs on custom reporter](https://github.com/uber-go/tally#report-your-metrics) and see a community implementation of [a reporter for Datadog's `dogstatsd` format](https://github.com/temporalio/temporal/pull/998#issuecomment-857884983).\n","is_empty":false},{"file_name":"web-ui-configuration.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/references/web-ui-configuration.md","id":"references/web-ui-configuration","title":"Temporal Web UI configuration reference","description":"The Temporal Web UI Server uses a configuration file for many of the UI's settings.","label":"Web UI configuration","tags":["reference","web-ui"],"markdown_content":"\nThe Temporal Web UI Server uses a configuration file for many of the UI's settings.\n\nAn example development.yaml file can be found in the [temporalio/ui-server repo](https://github.com/temporalio/ui-server/blob/main/config/development.yaml).\n\nMultiple configuration files can be created for configuring specific areas of the UI, such as Auth or TLS.\n\n## enableUi\n\nEnables the browser UI.\nThis configuration can be set dynamically with the [TEMPORAL_UI_ENABLED](/references/web-ui-environment-variables#temporaluienabled) environment variable.\nIf disabled—that is, set to `false`—the UI server APIs remain available.\n\n```yaml\nenableUi: true\n```\n\n## enableOpenApi\n\nEnables the UI Server's Open API reference documentation at `/openapi/`.\nThis configuration can be set dynamically with the [TEMPORAL_OPEN_API_ENABLED](/references/web-ui-environment-variables#temporalopenapienabled) environment variable.\nFor example, if you are currently viewing the Web UI at `http://localhost:8080`, the page is available at [localhost:8080/openapi/](http://localhost:8080/openapi/).\n\n```yaml\nenableOpenApi: true\n```\n\n## cors\n\nThe name of the `cors` field stands for Cross-Origin Resource Sharing.\nUse this field to provide a list of domains that are authorized to access the UI Server APIs.\n\n```yaml\ncors:\n  allowOrigins:\n    - http://localhost:3000 # used at development by https://github.com/temporalio/ui\n```\n\n## refreshInterval\n\nHow often the configuration UI Server reads the configuration file for new values.\nCurrently, only [tls](#tls) configuration values are propagated during a refresh.\n\n```yaml\nrefreshInterval: 1m\n```\n\n## temporalGrpcAddress\n\nThe frontend adddress for the Temporal Cluster.\n\nThe default address is localhost (127.0.0.1:7233).\n\n```yaml\ntemporalGrpcAddress: default\n```\n\n## port\n\nThe port used by the Temporal Web UI Server and any APIs.\n\n```yaml\nport: 8080\n```\n\n## defaultNamespace\n\nThe default Namespace that the UI loads data for.\nDefaults to `default`.\n\n```yaml\ndefaultNamespace: default\n```\n\n## showTemporalSystemNamespace\n\nWhen enabled—that is, when set to `true`—the Temporal System Namespace becomes visible in the UI.\nThe Temporal System Namespace lists Workflow Executions used by the Temporal Platform.\n\n```yaml\nshowTemporalSystemNamespace: false\n```\n\n## feedbackUrl\n\nThe URL to direct users to when they click on the Feedback button in the UI.\nIf not specified, it defaults to the UI's GitHub Issue page.\n\n```yaml\nfeedbackUrl: https://github.com/temporalio/ui/issues/new/choose\n```\n\n## notifyOnNewVersion\n\nWhen enabled—that is, when set to `true`—a notification appears in the UI when a newer version of the [Temporal Server](/clusters#temporal-server) is available.\n\n```yaml\nnotifyOnNewVersion: true\n```\n\n## auth\n\nAuth configuration.\n\n```yaml\nauth:\n  enabled: false\n  providers:\n    - label: Auth0 oidc # for internal use; in future may expose as button text\n      type: oidc # for futureproofing; only oidc is supported today\n      providerUrl: https://myorg.us.auth0.com/\n      clientId: xxxxxxxxxxxxxxxxxxxx\n      clientSecret: xxxxxxxxxxxxxxxxxxxx\n      scopes:\n        - openid\n        - profile\n        - email\n      callbackUrl: http://localhost:8080/auth/sso/callback\n      passIdToken: false\n      options: # added as URL query params when redirecting to auth provider\n        audience: myorg-dev\n        organization: org_xxxxxxxxxxxx\n        invitation:\n```\n\n## tls\n\nTransport Layer Security (TLS) configuration.\n\n```yaml\ntls:\n  caFile:\n  certFile:\n  keyFile:\n  caData:\n  certData:\n  keyData:\n  enableHostVerification: false\n  serverName:\n```\n\n## codec\n\nCodec Server configuration.\n\n```yaml\ncodec:\n  endpoint: http://your-codec-server-endpoint\n  passAccessToken: false\n```\n\n# disableWriteActions\n\nPrevents the user from terminating or canceling Workflow Executions from the Web UI.\n","is_empty":false},{"file_name":"web-ui-environment-variables.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/references/web-ui-environment-variables.md","id":"references/web-ui-environment-variables","title":"Temporal Web UI environmental variables","description":"How to set  environmental variables for Temporal Web UI.","label":"Web UI env var","tags":["docker","webui","ui server","reference"],"markdown_content":"\nYou can use environment variables to dynamically alter the configuration of your Temporal Web UI.\n\nThese can be used in many environments such as Docker.\nFor example:\n\n<!-- ```\ndocker run \\\n    -e TEMPORAL_ADDRESS=127.0.0.1:7233 \\\n    -e TEMPORAL_UI_PORT=8080 \\\n    -e TEMPORAL_AUTH_ENABLED=true \\\n    -e TEMPORAL_AUTH_PROVIDER_URL=https://accounts.google.com \\\n    -e TEMPORAL_AUTH_CLIENT_ID=xxxxx-xxxx.apps.googleusercontent.com \\\n    -e TEMPORAL_AUTH_CLIENT_SECRET=xxxxxxxxxxxxxxx \\\n    -e TEMPORAL_AUTH_CALLBACK_URL=https://xxxx.com:8080/auth/sso/callback \\\n    -e TEMPORAL_UI_ENABLED=true \\\n    -e TEMPORAL_OPENAPI_ENABLED=true \\\n    -e TEMPORAL_TLS_CA=../ca.cert \\\n    -e TEMPORAL_TLS_CERT=../cluster.pem \\\n    -e TEMPORAL_TLS_KEY=../cluster.key \\\n    -e TEMPORAL_TLS_ENABLE_HOST_VERIFICATION=true \\\n    -e TEMPORAL_TLS_SERVER_NAME=tls-server \\\n    temporalio/ui:<tag>\n``` -->\n\nThe environment variables are defined in the [UI server configuration template file](https://github.com/temporalio/ui-server/blob/main/docker/config_template.yaml) and described in more detail below.\n\n## `TEMPORAL_ADDRESS`\n\nThe [Frontend Service](/concepts/what-is-a-frontend-service) address for the Temporal Cluster.\nThis environmental variable can be set [in the base configuration file](/references/web-ui-configuration#temporalgrpcaddress) using `temporalGrpcAddress`.\n\nThis variable is required for setting other environmental variables.\n\n## `TEMPORAL_UI_PORT`\n\nThe port used by the Temporal WebUI Server and the HTTP API.\n\nThis variable is needed for `TEMPORAL_OPENAPI_ENABLED` and all auth-related settings to work properly.\n\n## `TEMPORAL_PUBLIC_PATH`\n\nStores a value such as \"\" or \"/custom-path\" that allows the UI to be served from a subpath.\n\n## `TEMPORAL_AUTH_ENABLED`\n\nEnables or disables Web UI authentication and authorization methods.\n\nWhen enabled, the Web UI will use the provider information in the [UI configuration file](/references/web-ui-configuration#auth) to verify the identity of users.\n\nAll auth-related variables can be defined when `TEMPORAL_AUTH_ENABLED` is set to \"true\".\nDisabling the variable will retain given values.\n\n## `TEMPORAL_AUTH_PROVIDER_URL`\n\nThe .well-known IDP discovery URL for authentication and authorization.\n\nThis can be set as in the UI server configuration with [auth](/references/web-ui-configuration#auth).\n\n## `TEMPORAL_AUTH_ISSUER_URL`\n\nThe URL for the authentication or authorization issuer.\n\nThis value is only needed when the issuer differes from the auth provider URL.\n\n## `TEMPORAL_AUTH_CLIENT_ID`\n\nThe client ID used for authentication or authorization.\n\nThis value is a required parameter.\n\n## `TEMPORAL_AUTH_CLIENT_SECRET`\n\nThe client secret used for authentication and authorization.\n\nClient Secrets are used by the oAuth Client for authentication.\n\n## `TEMPORAL_AUTH_CALLBACK_URL`\n\nThe callback URL used by Temporal for authentication and authorization.\n\nCallback URLs are invoked by IDP after user has finished authenticating in IDP.\n\n## `TEMPORAL_UI_ENABLED`\n\nEnables or disables the [browser UI](/references/web-ui-configuration#enableui) for the Temporal Cluster.\n\nEnabling the browser UI allows the Server to be accessed from your web browser.\nIf disabled, the server cannot be viewed on the web, but the UI server APIs remain available for use.\n\n## `TEMPORAL_OPENAPI_ENABLED`\n\nEnables or disables OpenAPI features for the Temporal Web UI.\n\nThis can be set initially with the [enableOpenAPI](/references/web-ui-configuration#enableopenapi) UI configuration.\nThe documentation can be found at `/openapi/` on your Temporal Cluster.\n\nThis variable requires `TEMPORAL_UI_ENABLED` to be set to 'true'.\n\n## `TEMPORAL_DEFAULT_NAMESPACE`\n\nThe default [Namespace](/concepts/what-is-a-namespace) that the Web UI opens first.\n\n## `TEMPORAL_FEEDBACK_URL`\n\nThe URL that users are directed to when they click the Feedback button in the UI.\n\nIf not specified, this variable defaults to the UI's GitHub Issue page.\n\n## `TEMPORAL_NOTIFY_ON_NEW_VERSION`\n\nEnables or disables notifications that appear in the UI whenever a newer version of the Temporal Cluster is available.\n\n## `TEMPORAL_CONFIG_REFRESH_INTERVAL`\n\nDetermines how often the UI Server reads the configuration file for new values.\n\n## `TEMPORAL_TLS_CA`\n\nThe path for the Transport Layer Security (TLS) Certificate Authority file.\n\nIn order to [configure TLS for your server](/references/web-ui-configuration#tls), you'll need a CA certificate issued by a trusted Certificate Authority.\nSet this variable to properly locate and use the file.\n\n## `TEMPORAL_TLS_CERT`\n\nThe path for the Transport Layer Security (TLS) Certificate.\n\nIn order to [configure TLS for your server](/references/web-ui-configuration#tls), you'll need a self-signed certificate.\nSet the path to allow the environment to locate and use the certificate.\n\n## `TEMPORAL_TLS_KEY`\n\nThe path for the Transport Layer Security (TLS) [key file](/references/web-ui-configuration#tls).\n\nA key file is used to create private and public keys for encryption and signing.\nTogether, these keys are used to create certificates.\n\n## `TEMPORAL_TLS_CA_DATA`\n\nStores the data for a TLS CA file.\n\nThis variable can be used instead of providing a path for `TEMPORAL_TLS_CA`.\n\n## `TEMPORAL_TLS_CERT_DATA`\n\nStores the data for a TLS cert file.\n\nThis variable can be used instead of providing a path for `TEMPORAL_TLS_CERT`.\n\n## `TEMPORAL_TLS_KEY_DATA`\n\nStores the data for a TLS key file.\n\nThis variable can be used instead of providing a path for `TEMPORAL_TLS_KEY`.\n\n## `TEMPORAL_TLS_ENABLE_HOST_VERIFICATION`\n\nEnables or disables [Transport Layer Security (TLS) host verification](/references/web-ui-configuration#tls).\n\nWhen enabled, TLS checks the Host Server to ensure that files are being sent to and from the correct URL.\n\n## `TEMPORAL_TLS_SERVER_NAME`\n\nThe server on which to operate [Transport Layer Security (TLS) protocols](/references/web-ui-configuration#tls).\n\nTLS allows the current server to transmit encrypted files to other URLs without having to reveal itself.\nBecause of this, TLS operates a go-between server.\n\n## `TEMPORAL_CODEC_ENDPOINT`\n\nThe endpoint for the [Codec Server](/concepts/what-is-a-codec-server), if configured.\n\n## `TEMPORAL_CODEC_PASS_ACCESS_TOKEN`\n\nWhether to send a JWT access token as ‘authorization’ header in requests with the Codec Server.\n\n## `TEMPORAL_FORWARD_HEADERS`\n\nForward-specified HTTP headers to direct from HTTP API requests to the Temporal gRPC backend.\n\n## `TEMPORAL_DISABLE_WRITE_ACTIONS`\n\nDisables any button in the UI that allows the user to modify Workflows or Activities.\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/environment-variables.md","id":"tctl-v1/environment-variables","title":"Environment variables for tctl","description":"What are the environment variables for tctl?","label":"Environment variables","tags":["tctl"],"markdown_content":"\nSetting environment variables for repeated parameters can shorten tctl commands.\n\n### TEMPORAL_CLI_ADDRESS\n\nSpecify a host and port for the Frontend Service.\nThe default is `127.0.0.1:7233`.\n\n### TEMPORAL_CLI_AUTHORIZATION_TOKEN\n\nSpecify a token to be used by the HTTP Basic Authorization plugin.\n\n<!-- TODO: Add link to \"Securing tctl\" page or its equivalent when it exists. -->\n\n### TEMPORAL_CLI_AUTH\n\nSpecify the authorization header to be set for a gRPC request.\n\n### TEMPORAL_CLI_NAMESPACE\n\nSpecify a Namespace.\nBy setting this variable, you don't need to specify a `--namespace` modifier in a tctl command.\nThe default Namespace is `default`.\n\n### TEMPORAL_CLI_PLUGIN_DATA_CONVERTER\n\nSpecify the name of the executable for a custom Data Converter plugin.\n\n### TEMPORAL_CLI_PLUGIN_HEADERS_PROVIDER\n\nSpecify the name of the executable for a headers provider plugin.\n\n### TEMPORAL_CLI_TLS_CA\n\nSpecify the path to a server Certificate Authority (CA) certificate file.\n\n### TEMPORAL_CLI_TLS_CERT\n\nSpecify the path to a public X.509 certificate file for mutual TLS authentication.\n\n### TEMPORAL_CLI_TLS_DISABLE_HOST_VERIFICATION\n\nSet to disable verification of the server certificate (and thus host verification).\n\n### TEMPORAL_CLI_TLS_KEY\n\nSpecify the path to a private key file for mutual TLS authentication.\nIf you set this variable, you must also set the `TEMPORAL_CLI_TLS_CERT` variable.\n\n### TEMPORAL_CLI_TLS_SERVER_NAME\n\nSpecify an override for the name of the target server that is used for TLS host verification.\nThe name must be one of the DNS names listed in the server TLS certificate.\nSetting this variable also enables host verification.\n\n### TEMPORAL_CONTEXT_TIMEOUT\n\nSpecify a timeout for the context of an RPC call in seconds.\nThe default value is 5.\n","is_empty":false},{"file_name":"global-modifiers.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/global-modifiers.md","id":"tctl-v1/global-modifiers","title":"tctl v1.17 global modifiers","description":"Global modifiers are provided before command modifiers.","label":"Global modifiers","tags":["operation-guide","tctl"],"markdown_content":"\nYou can supply the values for many of these modifiers by setting [environment variables](/tctl-v1/environment-variables) instead of including the modifiers in a tctl command.\n\n### --address\n\nSpecify a host and port for the Frontend Service.\nThe default is `127.0.0.1:7233`.\n\n### --auto_confirm\n\nAutomatically confirm all prompts.\n\n### --context_timeout\n\nSpecify a timeout for the context of an RPC call in seconds.\nThe default value is 5.\n\n### --data_converter_plugin\n\nSpecify the name of the executable for a headers provider plugin.\n\n### --headers_provider_plugin\n\nSpecify the name of the executable for a custom Data Converter plugin.\n\n### --help\n\nDisplay help for tctl in the CLI.\n\nAlias: `-h`\n\n### --namespace\n\nSpecify a Namespace.\nBy using this modifier, you don't need to specify a `--namespace` modifier for a sub-command.\nThe default Namespace is `default`.\n\nAlias: `--n`\n\n### --tls_ca_path\n\nSpecify the path to a server Certificate Authority (CA) certificate file.\n\n### --tls_cert_path\n\nSpecify the path to a public X.509 certificate file for mutual TLS authentication.\nIf you use this modifier, you must also use the `--tls_key_path` modifier.\n\n### --tls_disable_host_verification\n\nDisable verification of the server certificate (and thus host verification).\n\n### --tls_key_path\n\nSpecify the path to a private key file for mutual TLS authentication.\nIf you use this modifier, you must also use the `--tls_cert_path` modifier.\n\n### --tls_server_name\n\nSpecify an override for the name of the target server that is used for TLS host verification.\nThe name must be one of the DNS names listed in the server TLS certificate.\nSpecifying this modifier also enables host verification.\n\n### --version\n\nDisplay the version of tctl in the CLI.\n\n### --codec_endpoint\n\nThe URL and port number for a Codec Server.\n","is_empty":false},{"file_name":"how-to-install-tctl.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/how-to-install-tctl.md","id":"tctl-v1/how-to-install-tctl","title":"How to install tctl","description":"You can install tctl in four ways, described in this topic.","label":"Install","tags":["operation-guide","tctl"],"markdown_content":"\n> The Temporal tctl documentation covers version 1.17 of the Temporal CLI.\n\nYou can install [tctl](/tctl-v1) in the following ways.\n\n- Install locally by using [Homebrew](https://brew.sh/): `brew install tctl`\n- Run locally together with Temporal Server in [Docker Compose](https://github.com/temporalio/docker-compose): `docker exec temporal-admin-tools tctl YOUR COMMANDS HERE`\n  - To invoke [tctl](/tctl-v1) as though it is installed locally (such as `tctl namespace describe`), set an alias: `alias tctl=\"docker exec temporal-admin-tools tctl\"`\n- Run the [temporal-admin-tools](https://hub.docker.com/r/temporalio/admin-tools) Docker image:\n  - On Linux: `docker run --rm -it --entrypoint tctl --network host --env TEMPORAL_CLI_ADDRESS=localhost:7233 temporalio/admin-tools:1.14.0`\n  - On macOS or Windows: `docker run --rm -it --entrypoint tctl --env TEMPORAL_CLI_ADDRESS=host.docker.internal:7233 temporalio/admin-tools:1.14.0`\n  - If your Temporal Server is running on a remote host, change the value of `TEMPORAL_CLI_ADDRESS`.\n  - To simplify command lines, create a `tctl` alias.\n- Build it locally:\n  1. Clone the [Temporal Server repo](https://github.com/temporalio/temporal).\n  1. Run `make tctl`.\n  1. Copy the `tctl` executable to any directory that appears in the `PATH` environment variable; for example, `/usr/bin/`.\n- Install the latest version of the tctl in your `GOPATH`: `go install github.com/temporalio/tctl/cmd/tctl@latest`\n\n**Note:** To use [tctl](/tctl-v1), you must have a Temporal Server running.\n\nTo see help for [tctl](/tctl-v1) commands, enter the following commands.\n\n| Command             | Description                                                              |\n| ------------------- | ------------------------------------------------------------------------ |\n| `tctl -h`           | Display help for top-level commands and global options                   |\n| `tctl namespace -h` | Display help for [Namespace](/concepts/what-is-a-namespace) operations   |\n| `tctl workflow -h`  | Display help for [Workflow](/concepts/what-is-a-workflow) operations     |\n| `tctl taskqueue -h` | Display help for [Task Queue](/concepts/what-is-a-task-queue) operations |\n","is_empty":false},{"file_name":"workflow/cancel.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/cancel.md","id":"tctl-v1/workflow/cancel","title":"tctl workflow cancel","description":"How to cancel a Workflow Execution using tctl.","label":"cancel","tags":["tctl"],"markdown_content":"\nThe `tctl workflow cancel --query` command cancels a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nCanceling a running Workflow Execution records a `WorkflowExecutionCancelRequested` event in the History.\nA new command task will be scheduled.\nAfter cancellation, the Workflow Execution can perform cleanup work.\n\nSee also [`tctl workflow terminate --query`](/tctl-v1/workflow/terminate).\n\n`tctl workflow cancel --query <query> <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow cancel --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow cancel --run_id <id>\n```\n","is_empty":false},{"file_name":"workflow/count.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/count.md","id":"tctl-v1/workflow/count","title":"tctl workflow count","description":"How to count Workflow Executions using tctl.","label":"count","tags":["tctl"],"markdown_content":"\nThe `tctl workflow count` command counts [Workflow Executions](/concepts/what-is-a-workflow-execution).\nThis command requires Elasticsearch to be enabled.\n\n`tctl workflow count <modifiers>`\n\nThe following modifier controls the behavior of the command.\n\n### --query\n\n_Required modifier_\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute).\n\nAlias: `-q`\n\n**Example**\n\nTo count all open [Workflow Executions](/concepts/what-is-a-workflow-execution):\n\n```bash\ntctl workflow count --query 'ExecutionStatus=\"Running\"'\n```\n","is_empty":false},{"file_name":"workflow/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/describe.md","id":"tctl-v1/workflow/describe","title":"tctl workflow describe","description":"How to show information about a Workflow Execution using tctl.","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl workflow describe` command shows information about a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nThis information can be used to locate a failed Workflow Execution, for example.\n\nTo find a Workflow with a given Run Id, refer to [`tctl workflow describeid`](/tctl-v1/workflow/describeid).\n\n`tctl workflow describe <modifiers>`\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n### --workflow_id\n\n**This is a required modifier.**\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow describe --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\nIf a Run Id is not provided, the command will show the latest Workflow Execution of that Workflow Id.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow describe --run_id <id>\n```\n\n### --print_raw\n\nPrint properties exactly as they are stored.\n\n**Example**\n\n```bash\ntctl workflow describe --print_raw\n```\n\n### --reset_points_only\n\nShow only events that are eligible for reset.\nIf successful, the command returns the Run Id of all deployments, and the times at which the Events were created.\n\n**Example**\n\n```bash\ntctl workflow describe --reset_points_only\n```\n","is_empty":false},{"file_name":"workflow/describeid.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/describeid.md","id":"tctl-v1/workflow/describeid","title":"tctl workflow describeid","description":"How to show information about a Workflow Execution for a specified Workflow Id and optional Run Id using tctl.","label":"describeid","tags":["tctl"],"markdown_content":"\nThe `tctl workflow describeid` command shows information about a [Workflow Execution](/concepts/what-is-a-workflow-execution) for the specified [Workflow Id](/concepts/what-is-a-workflow-id) and optional [Run Id](/concepts/what-is-a-run-id).\n\n`tctl workflow describeid <workflow_id> <run_id> <modifiers>`\n\nThis command is a shortcut for `tctl workflow describe --workflow_id <workflowid> --run_id <runid>`.\n\nThe following modifiers control the behavior of the command.\n\n### --print_raw\n\nPrint properties exactly as they are stored.\n\n**Example**\n\n```bash\ntctl workflow describeid <workflow_id> <id> --print_raw\n```\n\n### --reset_points_only\n\nShow only events that are eligible for reset.\n\n**Example**\n\n```bash\ntctl workflow describeid <workflow_id> --reset_points_only\n```\n","is_empty":false},{"file_name":"workflow/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/index.md","id":"tctl-v1/workflow/index","title":"tctl workflow","description":"How to operate Workflow Executions using tctl.","label":"workflow","tags":["tctl"],"markdown_content":"\nThe `tctl workflow` commands enable [Workflow Execution](/concepts/what-is-a-workflow-execution) operations.\n\n- [tctl workflow cancel](/tctl-v1/workflow/cancel)\n- [tctl workflow count](/tctl-v1/workflow/count)\n- [tctl workflow describe](/tctl-v1/workflow/describe)\n- [tctl workflow describeid](/tctl-v1/workflow/describeid)\n- [tctl workflow list](/tctl-v1/workflow/list)\n- [tctl workflow listall](/tctl-v1/workflow/listall)\n- [tctl workflow listarchived](/tctl-v1/workflow/listarchived)\n- [tctl workflow observe](/tctl-v1/workflow/observe)\n- [tctl workflow observeid](/tctl-v1/workflow/observeid)\n- [tctl workflow query](/tctl-v1/workflow/query)\n- [tctl workflow reset](/tctl-v1/workflow/reset)\n- [tctl workflow reset-batch](/tctl-v1/workflow/reset-batch)\n- [tctl workflow run](/tctl-v1/workflow/run)\n- [tctl workflow scan](/tctl-v1/workflow/scan)\n- [tctl workflow show](/tctl-v1/workflow/show)\n- [tctl workflow showid](/tctl-v1/workflow/showid)\n- [tctl workflow signal](/tctl-v1/workflow/signal)\n- [tctl workflow stack](/tctl-v1/workflow/stack)\n- [tctl workflow start](/tctl-v1/workflow/start)\n- [tctl workflow terminate](/tctl-v1/workflow/terminate)\n","is_empty":false},{"file_name":"workflow/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/list.md","id":"tctl-v1/workflow/list","title":"tctl workflow list","description":"How to list open or closed Workflow Executions using tctl.","label":"list","tags":["tctl"],"markdown_content":"\nThe `tctl workflow list` command lists open or closed [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\nBy default, this command lists a maximum of 10 closed Workflow Executions.\n\n- To set the size of a page, use the `--pagesize` option.\n- To list multiple pages, use the `--more` option.\n- To list open Workflow Executions, use the `--open` option.\n\nSee also [`tctl workflow listall`](/tctl-v1/workflow/listall), [`tctl workflow listarchived`](/tctl-v1/workflow/listarchived), and [`tctl workflow scan`](/tctl-v1/workflow/scan).\n\n`tctl workflow list <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow list --print_raw_time\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow list --print_datetime\n```\n\n### --print_memo\n\nPrint a memo.\n\n**Example**\n\n```bash\ntctl workflow list --print_memo\n```\n\n### --print_search_attr\n\nPrint the [Search Attributes](/concepts/what-is-a-search-attribute).\n\n**Example**\n\n```bash\ntctl workflow list --print_search_attr\n```\n\n### --print_full\n\nPrint the full message without table formatting.\n\n**Example**\n\n```bash\ntctl workflow list --print_full\n```\n\n### --print_json\n\nPrint the raw JSON objects.\n\n**Example**\n\n```bash\ntctl workflow list --print_json\n```\n\n### --open\n\nList open [Workflow Executions](/concepts/what-is-a-workflow-execution).\n(By default, the `tctl workflow list` command lists closed Workflow Executions.)\n\n**Example**\n\n```bash\ntctl workflow list --open\n```\n\n### --earliest_time\n\nSpecify the earliest start time to list.\nSupported format are as follows:\n\n- `<year>-<month>-<day>T<hour>:<minute>:<second><+|-><offsethours>:<offsetminutes>`\n- Raw Unix Epoch time (the number of milliseconds since 0000 UTC on January 1, 1970).\n- `<n><duration`, where `<n>` is a value between 0 and 1000000, and `<duration>` is one of the following:\n  - `second` or `s`\n  - `minute` or `m`\n  - `hour` or `h`\n  - `day` or `d`\n  - `week` or `w`\n  - `month` or `M`\n  - `year` or `y`\n\n**Examples**\n\nTo specify 3:04:05 PM India Standard Time on January 2, 2022:\n\n```bash\ntctl workflow list --earliest-time '2022-01-02T15:04:05+05:30'\n```\n\nTo specify 15 minutes before the current time:\n\n```bash\ntctl workflow list --earliest-time '15minute'\n```\n\n### --latest_time\n\nSpecify the latest start time to list.\nSupported formats are as follows:\n\n- `<year>-<month>-<day>T<hour>:<minute>:<second><+|-><offsethours>:<offsetminutes>`\n- Raw Unix Epoch time (the number of milliseconds since 0000 UTC on January 1, 1970).\n- `<n><duration`, where `<n>` is a value between 0 and 1000000, and `<duration>` is one of the following:\n  - `second` or `s`\n  - `minute` or `m`\n  - `hour` or `h`\n  - `day` or `d`\n  - `week` or `w`\n  - `month` or `M`\n  - `year` or `y`\n\n**Examples**\n\nTo specify 11:02:17 PM Pacific Daylight Time on April 13, 2022:\n\n```bash\ntctl workflow list --latest_time '2022-04-13T23:02:17-07:00'\n```\n\nTo specify 10s before the current time:\n\n```bash\ntctl workflow list --latest_time '10second'\n```\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow list --workflow_id <id>\n```\n\n### --workflow_type\n\nSpecify the name of a [Workflow Type](/concepts/what-is-a-workflow-type).\n\n**Example**\n\n```bash\ntctl workflow list --workflow_type <name>\n```\n\n### --status\n\nSpecify the status of a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nSupported values are as follows:\n\n- `completed`\n- `failed`\n- `canceled`\n- `terminated`\n- `continuedasnew`\n- `timedout`\n\n**Example**\n\n```bash\ntctl workflow list --status <value>\n```\n\n### --query\n\n**How to list and filter Workflow Executions with a [List Filter](/concepts/what-is-a-list-filter) using tctl.**\n\nThe `--query` flag is supported only when [Advanced Visibility](/concepts/what-is-advanced-visibility) is configured with the Cluster.\n\nUsing the `--query` option causes tctl to ignore all other filter options, including `open`, `earliest_time`, `latest_time`, `workflow_id`, and `workflow_type`.\n\nAlias: `-q`\n\n**Example**\n\n```bashbash\ntctl workflow list --query \"WorkflowId=<your-workflow-id>\"\n```\n\nMore examples:\n\n```bashbash\ntctl workflow list \\\n  --query \"WorkflowType='main.SampleParentWorkflow' AND ExecutionStatus='Running'\"\n```\n\n```bashbash\ntctl workflow list \\\n  --query '(CustomKeywordField = \"keyword1\" and CustomIntField >= 5) or CustomKeywordField = \"keyword2\"' \\\n  --print_search_attr\n```\n\n```bashbash\ntctl workflow list \\\n  --query 'CustomKeywordField in (\"keyword2\", \"keyword1\") and CustomIntField >= 5 and CloseTime between \"2018-06-07T16:16:36-08:00\" and \"2019-06-07T16:46:34-08:00\" order by CustomDatetimeField desc' \\\n  --print_search_attr\n```\n\n```bashbash\ntctl workflow list \\\n  --query 'WorkflowType = \"main.Workflow\" and (WorkflowId = \"1645a588-4772-4dab-b276-5f9db108b3a8\" or RunId = \"be66519b-5f09-40cd-b2e8-20e4106244dc\")'\n```\n\n```bashbash\ntctl workflow list \\\n  --query 'WorkflowType = \"main.Workflow\" StartTime > \"2019-06-07T16:46:34-08:00\" and ExecutionStatus = \"Running\"'\n```\n\n### --more\n\nList more than one page.\n(By default, the `tctl workflow list` command lists one page of results.)\n\n**Example**\n\n```bash\ntctl workflow list --more\n```\n\n### --pagesize\n\nSpecify the maximum number of [Workflow Executions](/concepts/what-is-a-workflow-execution) to list on a page.\n(By default, the `tctl workflow list` command lists 10 Workflow Executions per page.)\n\n**Example**\n\n```bash\ntctl workflow list --pagesize <value>\n```\n","is_empty":false},{"file_name":"workflow/listall.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/listall.md","id":"tctl-v1/workflow/listall","title":"tctl workflow listall","description":"How to list all open or closed Workflow Executions using tctl.","label":"listall","tags":["tctl"],"markdown_content":"\nThe `tctl workflow listall` command lists all open or closed [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\nBy default, this command lists all closed Workflow Executions.\nTo list open Workflow Executions, use the `--open` option.\n\nSee also [`tctl workflow list`](/tctl-v1/workflow/list), [`tctl workflow listarchived`](/tctl-v1/workflow/listarchived), and [`tctl workflow scan`](/tctl-v1/workflow/scan).\n\n`tctl workflow listall <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n###`--print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow listall --print_raw_time\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow listall --print_datetime\n```\n\n### --print_memo\n\nPrint a memo.\n\n**Example**\n\n```bash\ntctl workflow listall --print_memo\n```\n\n### --print_search_attr\n\nPrint the [Search Attributes](/concepts/what-is-a-search-attribute).\n\n**Example**\n\n```bash\ntctl workflow listall --print_search_attr\n```\n\n### `--print_full`\n\nPrint the full message without table formatting.\n\n**Example**\n\n```bash\ntctl workflow listall --print_full\n```\n\n### --print_json\n\nPrint the raw JSON objects.\n\n**Example**\n\n```bash\ntctl workflow listall --print_json\n```\n\n### --open\n\nList open [Workflow Executions](/concepts/what-is-a-workflow-execution).\n(By default, the `tctl workflow listall` command lists closed Workflow Executions.)\n\n**Example**\n\n```bash\ntctl workflow listall --open\n```\n\n### --earliest_time\n\nSpecify the earliest start time to list. Supported format are as follows:\n\n- `<year>-<month>-<day>T<hour>:<minute>:<second><+|-><offsethours>:<offsetminutes>`\n- Raw Unix Epoch time (the number of milliseconds since 0000 UTC on January 1, 1970).\n- `<n><duration`, where `<n>` is a value between 0 and 1000000, and `<duration>` is one of the following:\n  - `second` or `s`\n  - `minute` or `m`\n  - `hour` or `h`\n  - `day` or `d`\n  - `week` or `w`\n  - `month` or `M`\n  - `year` or `y`\n\n**Examples**\n\nTo specify 3:04:05 PM India Standard Time on January 2, 2022:\n\n```bash\ntctl workflow listall --earliest-time '2022-01-02T15:04:05+05:30'\n```\n\nTo specify 15 minutes before the current time:\n\n```bash\ntctl workflow listall --earliest-time '15minute'\n```\n\n### --latest_time\n\nSpecify the latest start time to list. Supported formats are as follows:\n\n- `<year>-<month>-<day>T<hour>:<minute>:<second><+|-><offsethours>:<offsetminutes>`\n- Raw Unix Epoch time (the number of milliseconds since 0000 UTC on January 1, 1970).\n- `<n><duration`, where `<n>` is a value between 0 and 1000000, and `<duration>` is one of the following:\n  - `second` or `s`\n  - `minute` or `m`\n  - `hour` or `h`\n  - `day` or `d`\n  - `week` or `w`\n  - `month` or `M`\n  - `year` or `y`\n\nAlias: `--lt`\n\n**Examples**\n\nTo specify 11:02:17 PM Pacific Daylight Time on April 13, 2022:\n\n```bash\ntctl workflow listall --latest-time '2022-04-13T23:02:17-07:00'\n```\n\nTo specify 10 seconds before the current time:\n\n```bash\ntctl workflow listall --latest-time '10second'\n```\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow listall --workflow_id <id>\n```\n\n### --workflow_type\n\nSpecify the name of a [Workflow Type](/concepts/what-is-a-workflow-type).\n\n**Example**\n\n```bash\ntctl workflow listall --workflow_type <name>\n```\n\n### --status\n\nSpecify the status of a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nSupported values are as follows:\n\n- `completed`\n- `failed`\n- `canceled`\n- `terminated`\n- `continuedasnew`\n- `timedout`\n\n**Example**\n\n```bash\ntctl workflow listall --status <value>\n```\n\n### --query\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute).\n\nUsing the `--query` option causes tctl to ignore all other filter options, including `open`, `earliest_time`, `latest_time`, `workflow_id`, and `workflow_type`.\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl workflow listall --query <value>\n```\n","is_empty":false},{"file_name":"workflow/listarchived.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/listarchived.md","id":"tctl-v1/workflow/listarchived","title":"tctl workflow listarchived","description":"How to list archived Workflow Executions using tctl.","label":"listarchived","tags":["tctl"],"markdown_content":"\nThe `tctl workflow listarchived` command lists archived [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\nBy default, this command lists a maximum of 100 Workflow Executions.\n\n- To set the size of a page, use the `--pagesize` option.\n- To list all pages, use the `--all` option.\n\nSee also [`tctl workflow list`](/tctl-v1/workflow/list), [`tctl workflow listall`](/tctl-v1/workflow/listall), and [`tctl workflow scan`](/tctl-v1/workflow/scan).\n\n`tctl workflow listarchived <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_raw_time\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_datetime\n```\n\n### --print_memo\n\nPrint a memo.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_memo\n```\n\n### --print_search_attr\n\nPrint the [Search Attributes](/concepts/what-is-a-search-attribute).\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_search_attr\n```\n\n### --print_full\n\nPrint the full message without table formatting.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_full\n```\n\n### --print_json\n\nPrint the raw JSON objects.\n\n**Example**\n\n```bash\ntctl workflow listarchived --print_json\n```\n\n### --query\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute).\n\nConsult the documentation of the visibility archiver that is used by your [Namespace](/concepts/what-is-a-namespace) for detailed instructions.\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl workflow listarchived --query <value>\n```\n\n### --pagesize\n\nSpecify the maximum number of [Workflow Executions](/concepts/what-is-a-workflow-execution) to list on a page.\n(By default, the `tctl workflow listarchived` command lists 100 Workflow Executions per page.)\n\n**Example**\n\n```bash\ntctl workflow listarchived --pagesize <value>\n```\n\n### --all\n\nList all pages.\n\n**Example**\n\n```bash\ntctl workflow listarchived --all\n```\n","is_empty":false},{"file_name":"workflow/observe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/observe.md","id":"tctl-v1/workflow/observe","title":"tctl workflow observe","description":"How to show the progress of the Event History of a Workflow Execution using tctl.","label":"observe","tags":["tctl"],"markdown_content":"\nThe `tctl workflow observe` command shows the progress of the [Event History](/concepts/what-is-an-event-history) of a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nSee also [`tctl workflow observeid`](/tctl-v1/workflow/observeid).\n\n`tctl workflow observe <modifiers>`\n\nAlias: `o`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow observe --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow observe --run_id <id>\n```\n\n### --show_detail\n\nShow event details.\n\n**Example**\n\n```bash\ntctl workflow observe --show_detail\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow observe --max_field_length <length>\n```\n","is_empty":false},{"file_name":"workflow/observeid.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/observeid.md","id":"tctl-v1/workflow/observeid","title":"tctl workflow observeid","description":"How to show the progress of the Event History of a Workflow Execution for a specified Workflow Id and optional Run Id using tctl.","label":"observeid","tags":["tctl"],"markdown_content":"\nThe `tctl workflow observeid` command shows the progress of the [Event History](/concepts/what-is-an-event-history) of a [Workflow Execution](/concepts/what-is-a-workflow-execution) for the specified [Workflow Id](/concepts/what-is-a-workflow-id) and optional [Run Id](/concepts/what-is-a-run-id).\n\n`tctl workflow observeid <workflow_id> [<run_id>] <modifiers>`\n\nThis command is a shortcut for `tctl workflow observe --workflow_id <workflowid> [--run_id <runid>]`.\n\nThe following modifiers control the behavior of the command.\n\n### --show_detail\n\nShow event details.\n\n**Example**\n\n```bash\ntctl workflow observeid --show_detail\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow observeid --max_field_length <length>\n```\n","is_empty":false},{"file_name":"workflow/query.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/query.md","id":"tctl-v1/workflow/query","title":"tctl workflow query","description":"How to send a Query to a Workflow Execution using tctl.","label":"query","tags":["tctl"],"markdown_content":"\nAlias: `q`\n\nThe `tctl workflow query` command sends a [Query](/concepts/what-is-a-query) to a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nQueries can be used to retrieve all or part of the Workflow state with given parameters.\n\n```bash\n$ tctl workflow query --workflow_id \"HelloQuery\" --query_type \"getCount\"\nQuery result as JSON:\n3\n```\n\nQueries can also be used on completed Workflows.\nLet's complete a Workflow by updating its greeting, and then query the now-finished Workflow.\n\n```bash\n$ tctl workflow signal --workflow_id \"HelloQuery\" --name \"updateGreeting\" --input \\\"Bye\\\"\nSignal workflow succeeded.\n$ tctl workflow query --workflow_id \"HelloQuery\" --query_type \"getCount\"\nQuery result as JSON:\n4\n```\n\nQueries are written as follows:\n\n`tctl workflow query --workflow_id [modifiers]`\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id). **This modifier is required.**\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow query --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow query --run_id <id>\n```\n\n### --query_type\n\nSpecify the type of Query to run.\n\n**Example**\n\n```bash\ntctl workflow query --query_type <value>\n```\n\n### --input\n\nPass input for the Query.\nInput must be in JSON format.\nFor multiple JSON objects, concatenate them and use spaces as separators.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow query --input <json>\n```\n\n### --input_file\n\nPass input for the Query from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nInput from the command line overwrites input from the file.\n\n**Example**\n\n```bash\ntctl workflow query --input_file <filename>\n```\n\n### --query_reject_condition\n\nReject Queries based on Workflow state.\nValid values are `not_open` and `not_completed_cleanly`.\n\n**Example**\n\n```bash\ntctl workflow query --query_reject_condition <value>\n```\n","is_empty":false},{"file_name":"workflow/reset-batch.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/reset-batch.md","id":"tctl-v1/workflow/reset-batch","title":"tctl workflow reset-batch","description":"How to reset a batch of Workflow Executions using tctl.","label":"reset-batch","tags":["tctl"],"markdown_content":"\nThe `tctl workflow reset-batch` command resets a batch of [Workflow Executions](/concepts/what-is-a-workflow-execution) by [`resetType`](#resettype).\n\nResetting a Workflow allows the process to be resumed from a certain point without losing your parameters or Event History.\n\nTo reset individual Workflows, see [`tctl workflow reset`](/tctl-v1/workflow/reset).\n\n`tctl workflow reset-batch <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --input_file\n\nProvide an input file that specifies [Workflow Execution](/concepts/what-is-a-workflow-execution) to reset.\n\nEach line contains one [Workflow Id](/concepts/what-is-a-workflow-id) as the base Run and, optionally, a [Run Id](/concepts/what-is-a-run-id).\nIf a Run Id is not specified, the current Run Id is used.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --input_file <filename>\n```\n\n### --query\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute) describing the [Workflow Executions](/concepts/what-is-a-workflow-execution) to reset.\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl workflow reset-batch --query <value>\n```\n\n### --exclude_file\n\nProvide an input file that specifies [Workflow Executions](/concepts/what-is-a-workflow-execution) to exclude from resetting.\n\nEach line contains one [Workflow Id](/concepts/what-is-a-workflow-id).\n\n**Example**\n\n```bash\ntctl workflow reset-batch --exclude_file <filename>\n```\n\n### --input_separator\n\nSpecify the separator for the input file.\nThe default is a tab (`\\t`).\n\n**Example**\n\n```bash\ntctl workflow reset-batch --input_separator <string>\n```\n\n### --reason\n\nSpecify a reason for resetting the [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\n**Example**\n\n```bash\ntctl workflow reset-batch --reason <string>\n```\n\n### --input_parallism\n\nSpecify the number of goroutines to run in parallel.\nEach goroutine processes one line for every second.\nThe default is 1.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --input_parallism <value>\n```\n\n### --skip_current_open\n\nIndicate that a [Workflow Execution](/concepts/what-is-a-workflow-execution) should be skipped if the current Run is open for the same [Workflow Id](/concepts/what-is-a-workflow-id) as the base Run.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --skip_current_open\n```\n\n### --skip_base_is_not_current\n\nIndicate that a [Workflow Execution](/concepts/what-is-a-workflow-execution) should be skipped if the base Run is not the current Run.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --skip_base_is_not_current\n```\n\n### --only_non_deterministic\n\nIndicate that a [Workflow Execution](/concepts/what-is-a-workflow-execution) should be reset only if its last event is `WorkflowTaskFailed` with a nondeterministic error.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --only_non_deterministic\n```\n\n### --dry_run\n\nSimulate use of the `tctl workflow reset-batch` command without resetting any [Workflow Executions](/concepts/what-is-a-workflow-execution).\nOutput is logged to `stdout`.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --dry_run\n```\n\n### --reset_type\n\nSpecify the event type to which you want to reset.\n\n| Value                | Description                                                 |\n| -------------------- | ----------------------------------------------------------- |\n| `FirstWorkflowTask`  | Reset to the beginning of the Event History.                |\n| `LastWorkflowTask`   | Reset to the end of the Event History.                      |\n| `LastContinuedAsNew` | Reset to the end of the Event History for the previous Run. |\n| `BadBinary`          | Reset to the point where a bad binary was used.             |\n\n**Example**\n\n```bash\ntctl workflow reset-batch --reset_type <value>\n```\n\n### --reset_bad_binary_checksum\n\nSpecify the binary checksum when using `--reset_type BadBinary`.\n\n**Example**\n\n```bash\ntctl workflow reset-batch --reset_bad_binary_checksum <value>\n```\n","is_empty":false},{"file_name":"workflow/reset.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/reset.md","id":"tctl-v1/workflow/reset","title":"tctl workflow reset","description":"How to reset a Workflow Execution using tctl.","label":"reset","tags":["tctl"],"markdown_content":"\nThe `tctl workflow reset` command resets a [Workflow Execution](/concepts/what-is-a-workflow-execution) by either [`eventId`](#eventid)or [`resetType`](#resettype).\n\nResetting a Workflow allows the process to be resumed from a certain point without losing your parameters or Event History.\n\nTo run multiple Reset operations at once, see [`tctl workflow reset-batch`](/tctl-v1/workflow/reset-batch).\n\n`tctl workflow reset <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow reset --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow reset --run_id <id>\n```\n\n### --event_id\n\nSpecify the `eventId` of any event after `WorkflowTaskStarted` to which you want to reset.\nValid values are `WorkflowTaskCompleted`, `WorkflowTaskFailed`, and `WorkflowTaskTimeout`.\n\n**Example**\n\n```bash\ntctl workflow reset --event_id <id>\n```\n\n### --reason\n\nSpecify a reason for resetting the [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\n**Example**\n\n```bash\ntctl workflow reset --reason <string>\n```\n\n### --reset_type\n\nSpecify the event type to which you want to reset.\n\n| Value                | Description                                                 |\n| -------------------- | ----------------------------------------------------------- |\n| `FirstWorkflowTask`  | Reset to the beginning of the Event History.                |\n| `LastWorkflowTask`   | Reset to the end of the Event History.                      |\n| `LastContinuedAsNew` | Reset to the end of the Event History for the previous Run. |\n| `BadBinary`          | Reset to the point where a bad binary was used.             |\n\n**Example**\n\n```bash\ntctl workflow reset --reset_type <value>\n```\n\n### --reset_reapply_type\n\nSpecify the types of events to reapply after the reset point.\nValid values are `All`, `Signal`, and `None`. The default is `All`.\n\n**Example**\n\n```bash\ntctl workflow reset --reset_reapply_type <value>\n```\n\n### --reset_bad_binary_checksum\n\nSpecify the binary checksum when using `--reset_type BadBinary`.\n\n**Example**\n\n```bash\ntctl workflow reset --reset_bad_binary_checksum <value>\n```\n","is_empty":false},{"file_name":"workflow/run.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/run.md","id":"tctl-v1/workflow/run","title":"tctl workflow run","description":"How to start a new Workflow Execution and get Workflow progress using tctl.","label":"run","tags":["tctl"],"markdown_content":"\nThe `tctl workflow run` command starts a new [Workflow Execution](/concepts/what-is-a-workflow-execution) and can show the progress of a Workflow Execution.\nThe command is entered in the following format:\n\n`tctl workflow run <modifiers>`\n\nTo run a Workflow, the user must specify the following:\n\n- Task queue name (`--taskqueue`)\n- Workflow Type (`--workflow_type`)\n\n```bash\ntctl workflow run --taskqueue your-task-queue-name --workflow_type YourWorkflowDefinitionName\n```\n\nSingle quotes (`''`) are used to wrap input as JSON.\nThis command doesn't finish until the Workflow completes.\n\nThe following modifiers control the behavior of the command.\n\n### --taskqueue\n\nSpecify a [Task Queue](/concepts/what-is-a-task-queue).\n\nAlias: `--t`\n\n**Example**\n\n```bash\ntctl workflow run --taskqueue <name>\n```\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow run --workflow_id <id>\n```\n\n### --workflow_type\n\nSpecify the name of a [Workflow Type](/concepts/what-is-a-workflow-type).\n\n**Example**\n\n```bash\ntctl workflow run --workflow_type <name>\n```\n\n### --execution_timeout\n\nSpecify the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) of the [Workflow Execution](/concepts/what-is-a-workflow-execution) in seconds.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow run --execution_timeout <seconds>\n```\n\n### --workflow_task_timeout\n\nSpecify the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) of the [Workflow Task](/concepts/what-is-a-workflow-task) in seconds.\nThe default value is 10.\n\n**Example**\n\n```bash\ntctl workflow run --workflow_task_timeout <seconds>\n```\n\n### --cron\n\nSpecify a [Cron Schedule](/concepts/what-is-a-temporal-cron-job/#cron-schedules).\n\n**Example**\n\n```bash\ntctl workflow run --cron <string>\n```\n\n### --workflowidreusepolicy\n\nSpecify a [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy).\nConfigure if the same [Workflow Id](/concepts/what-is-a-workflow-id) is allowed for use in new [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nThere are three allowed values:\n\n- [**AllowDuplicateFailedOnly:**](/concepts/what-is-a-workflow-id-reuse-policy)\n- [**AllowDuplicate:**](/concepts/what-is-a-workflow-id-reuse-policy)\n- [**RejectDuplicate:**](/concepts/what-is-a-workflow-id-reuse-policy)\n\n**Examples**\n\n```bash\ntctl workflow run --workflowidreusepolicy AllowDuplicate\ntctl workflow run --workflowidreusepolicy AllowDuplicateFailedOnly\ntctl workflow run --workflowidreusepolicy RejectDuplicate\n```\n\n### --input\n\nPass input for the Workflow.\nInput must be in JSON format.\nFor multiple JSON objects, pass each in a separate `--input` option. Use `null` for null values.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow run --input <json>\n```\n\n### --input_file\n\nPass input for the Workflow from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nInput from the command line overwrites input from the file.\n\n**Example**\n\n```bash\ntctl workflow run --input_file <filename>\n```\n\n### --memo_key\n\nPass a key for a memo.\nFor multiple keys, concatenate them and use spaces as separators.\n\n**Example**\n\n```bash\ntctl workflow run --memo_key <key>\n```\n\n### --memo\n\nPass a memo.\nA memo is information in JSON format that can be shown when the Workflow is listed.\nFor multiple memos, concatenate them and use spaces as separators.\nThe order must match the order of keys in `--memo_key`.\n\n**Example**\n\n```bash\ntctl workflow run --memo <json>\n```\n\n### --memo_file\n\nPass information for a memo from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nThe order must match the order of keys in `--memo_key`.\n\n**Example**\n\n```bash\ntctl workflow run --memo_file <filename>\n```\n\n### --search_attr_key\n\nSpecify a [Search Attribute](/concepts/what-is-a-search-attribute) key.\nFor multiple keys, concatenate them and use pipes (`|`) as separators.\n\nTo list valid keys, use the `tctl cluster get-search-attributes` command.\n\n**Example**\n\n```bash\ntctl workflow run --search_attr_key <key>\n```\n\n### --search_attr_value\n\nSpecify a [Search Attribute](/concepts/what-is-a-search-attribute) value.\nFor multiple values, concatenate them and use pipes (`|`) as separators.\nIf a value is an array, use JSON format, such as `[\"a\",\"b\"]`, `[1,2]`, `[\"true\",\"false\"]`, or `[\"2022-06-07T17:16:34-08:00\",\"2022-06-07T18:16:34-08:00\"]`.\n\nTo list valid keys and value types, use the `tctl cluster get-search-attributes` command.\n\n**Example**\n\n```bash\ntctl workflow run --search_attr_value <value>\n```\n\n### --show_detail\n\nGet event details.\n\n**Example**\n\n```bash\ntctl workflow run --show_detail\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow run --max_field_length <length>\n```\n","is_empty":false},{"file_name":"workflow/scan.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/scan.md","id":"tctl-v1/workflow/scan","title":"tctl workflow scan","description":"How to quickly list Workflow Executions without sorting using tctl.","label":"scan","tags":["tctl"],"markdown_content":"\nThe `tctl workflow scan` command lists [Workflow Executions](/concepts/what-is-a-workflow-execution).\nIt is faster than the `tctl workflow listall` command, but the results are not sorted.\n\nBy default, this command lists a maximum of 2000 Workflow Executions.\nTo set the size of a page, use the `--pagesize` option.\n\nSee also [`tctl workflow list`](/tctl-v1/workflow/list), [`tctl workflow listall`](/tctl-v1/workflow/listall), and [`tctl workflow listarchived`](/tctl-v1/workflow/listarchived).\n\n`tctl workflow scan <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow scan --print_raw_time\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow scan --print_datetime\n```\n\n### --print_memo\n\nPrint a memo.\n\n**Example**\n\n```bash\ntctl workflow scan --print_memo\n```\n\n### --print_search_attr\n\nPrint the [Search Attributes](/concepts/what-is-a-search-attribute).\n\n**Example**\n\n```bash\ntctl workflow scan --print_search_attr\n```\n\n### --print_full\n\nPrint the full message without table formatting.\n\n**Example**\n\n```bash\ntctl workflow scan --print_full\n```\n\n### --print_json\n\nPrint the raw JSON objects.\n\n**Example**\n\n```bash\ntctl workflow scan --print_json\n```\n\n### --pagesize\n\nSpecify the maximum number of [Workflow Execution](/concepts/what-is-a-workflow-execution) to list on a page.\n(By default, the `tctl workflow scan` command lists 2000 Workflow Executions per page.)\n\n**Example**\n\n```bash\ntctl workflow scan --pagesize <value>\n```\n\n### --query\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute).\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl workflow scan --query <value>\n```\n","is_empty":false},{"file_name":"workflow/show.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/show.md","id":"tctl-v1/workflow/show","title":"tctl workflow show","description":"How to show Workflow History using tctl.","label":"show","tags":["tctl"],"markdown_content":"\nThe `tctl workflow show` command shows the [Event History](/concepts/what-is-an-event-history) for the specified [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\n`tctl workflow show <modifiers>`\n\nSee also [`tctl workflow showid`](/tctl-v1/workflow/showid).\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nShow the History of a [Workflow Execution](/concepts/what-is-a-workflow-execution) by specifying a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow show --workflow_id <id>\n```\n\n### --run_id\n\nShow the History of a [Workflow Execution](/concepts/what-is-a-workflow-execution) by specifying a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow show --run_id <id>\n```\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow show --print_datetime\n```\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow show --print_raw_time\n```\n\n### --output_filename\n\nSerialize an event to a file.\n\n**Example**\n\n```bash\ntctl workflow show --output_filename <filename>\n```\n\n### --print_full\n\nPrint full event details.\n\n**Example**\n\n```bash\ntctl workflow show --print_full\n```\n\n### --print_event_version\n\nPrint the event version.\n\n**Example**\n\n```bash\ntctl workflow show --print_event_version\n```\n\n### --event_id\n\nPrint the details of a specified event.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow show --event_id <id>\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 500.\n\n**Example**\n\n```bash\ntctl workflow show --max_field_length <length>\n```\n\n### --reset_points_only\n\nShow only events that are eligible for reset.\n\n**Example**\n\n```bash\ntctl workflow show --reset_points_only\n```\n","is_empty":false},{"file_name":"workflow/showid.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/showid.md","id":"tctl-v1/workflow/showid","title":"tctl workflow showid","description":"How to show Workflow History for a specified Workflow Id and optional Run Id using tctl.","label":"showid","tags":["tctl"],"markdown_content":"\nThe `tctl workflow showid` command shows the Workflow Execution Event History for the specified [Workflow Id](/concepts/what-is-a-workflow-id) and optional [Run Id](/concepts/what-is-a-run-id).\n\n`tctl workflow showid <workflow_id> [<run_id>] <modifiers>`\n\nThis command is a shortcut for `tctl workflow show --workflow_id <workflowid> [--run_id <runid>]`.\n\nExample:\n\n```bashbash\ntctl workflow showid <workflow_id>\n```\n\nExample output:\n\n```bashtext\n1  WorkflowExecutionStarted    {WorkflowType:{Name:HelloWorld}, ParentInitiatedEventId:0,\n                                TaskQueue:{Name:HelloWorldTaskQueue, Kind:Normal},\n                                Input:[Temporal], WorkflowExecutionTimeout:1h0m0s,\n                                WorkflowRunTimeout:1h0m0s, WorkflowTaskTimeout:10s,\n                                Initiator:Unspecified, LastCompletionResult:[],\n                                OriginalExecutionRunId:f0c04163-833f-490b-99a9-ee48b6199213,\n                                Identity:tctl@z0mb1e,\n                                FirstExecutionRunId:f0c04163-833f-490b-99a9-ee48b6199213,\n                                Attempt:1, WorkflowExecutionExpirationTime:2020-10-13\n                                21:41:06.349 +0000 UTC, FirstWorkflowTaskBackoff:0s}\n2  WorkflowTaskScheduled       {TaskQueue:{Name:HelloWorldTaskQueue,\n                                Kind:Normal},\n                                StartToCloseTimeout:10s, Attempt:1}\n3  WorkflowTaskStarted         {ScheduledEventId:2, Identity:15079@z0mb1e,\n                                RequestId:731f7b41-5ae4-42e4-9695-ecd857d571f1}\n4  WorkflowTaskCompleted       {ScheduledEventId:2,\n                                StartedEventId:3,\n                                Identity:15079@z0mb1e}\n5  WorkflowExecutionCompleted  {Result:[],\n                                WorkflowTaskCompletedEventId:4}\n```\n\nThe following modifiers control the behavior of the command.\n\n### --print_datetime\n\nPrint the timestamp.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --print_datetime\n```\n\n### --print_raw_time\n\nPrint the raw timestamp.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --print_raw_time\n```\n\n### --output_filename\n\nSerialize an event to a file.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --output_filename <filename>\n```\n\n### --print_full\n\nPrint full event details.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --print_full\n```\n\n### --print_event_version\n\nPrint the event version.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --print_event_version\n```\n\n### --event_id\n\nPrint the details of a specified event.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --event_id <id>\n```\n\n### --max_field_length\n\nSpecify the maximum length for each attribute field.\nThe default value is 500.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --max_field_length <length>\n```\n\n### --reset_points_only\n\nShow only events that are eligible for reset.\n\n**Example**\n\n```bash\ntctl workflow showid <workflow_id> --reset_points_only\n```\n","is_empty":false},{"file_name":"workflow/signal.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/signal.md","id":"tctl-v1/workflow/signal","title":"tctl workflow signal","description":"How to Signal a Workflow Execution using tctl.","label":"signal","tags":["tctl"],"markdown_content":"\nThe `tctl workflow signal` command [Signals](/concepts/what-is-a-signal) a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nWorkflows listen for Signals by their Signal name, and can be made to listen to one or more Signal names.\nWorkflows can also listen for SQL queries.\n\nThe Workflow below listens for instances of \"HelloSignal\":\n\n```bash\ntctl workflow start  --workflow_id \"HelloSignal\" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\\"World\\\"\n```\n\nThe Worker would return this output upon receiving the Signal:\n\n```text\n13:57:44.258 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 1: Hello World!\n```\n\nSignals can also be used to change variable values.\n\n```bash\ntctl workflow signal --workflow_id \"HelloSignal\" --name \"updateGreeting\" --input \\\"Hi\\\"\n```\n\nThe output would change from the first Signal received.\n\n```text\n13:57:44.258 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 1: Hello World!\n13:58:22.352 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 2: Hi World!\n```\n\nWhen a Signal is sent, an await condition is made to block any Signals that contain the same input value.\nHowever, changing the greeting in our example unblocks it:\n\n```bash\ntctl workflow signal --workflow_id \"HelloSignal\" --name \"updateGreeting\" --input \\\"Welcome\\\"\n```\n\nWorker output:\n\n```text\n13:57:44.258 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 1: Hello World!\n13:58:22.352 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 2: Hi World!\n13:59:29.097 [workflow-method] INFO  c.t.s.javaquickstart.GettingStarted - 3: Welcome World!\n```\n\nSending Signals does not require a running Worker.\n\n```bash\ntctl workflow signal --workflow_id \"HelloSignal\" --name \"updateGreeting\" --input \\\"Welcome\\\"\n```\n\nCLI output:\n\n```text\nSignal workflow succeeded.\n```\n\nThe Signal request is queued inside the Temporal Server until the Worker is restarted.\nIf the given Signal contains the same input as before, the queued Signal will be ignored.\n\nComplete the Workflow by sending a Signal with a \"Bye\" greeting:\n\n```bash\ntctl workflow signal --workflow_id \"HelloSignal\" --name \"updateGreeting\" --input \\\"Bye\\\"\n```\n\nCheck that the Workflow Execution has been completed.\n\n```bash\ntctl workflow showid HelloSignal\n```\n\nSignals are written as follows:\n\n```bash\ntctl workflow signal --workflow_id <id> <modifiers>\n```\n\nor\n\n```bash\ntctl workflow signal --query <query> <modifiers>\n```\n\nThe following modifiers control the behavior of the command.\nMake sure to include required modifiers in all command executions.\n\n### --workflow_id\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id). **This modifier is required.**\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow signal --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow signal --run_id <id>\n```\n\n### --name\n\nSpecify the name of a [Signal](/concepts/what-is-a-signal).\n\n**Example**\n\n```bash\ntctl workflow signal --query <query> --name <name>\n```\n\n### --input\n\nPass input for the [Signal](/concepts/what-is-a-signal).\nInput must be in JSON format.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow signal --query <query> --input <json>\n```\n\n### --input_file\n\nPass input for the [Signal](/concepts/what-is-a-signal) from a JSON file.\n\n**Example**\n\n```bash\ntctl workflow signal --query <query> --input_file <filename>\n```\n","is_empty":false},{"file_name":"workflow/stack.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/stack.md","id":"tctl-v1/workflow/stack","title":"tctl workflow stack","description":"How to query Workflow Executions with __stack_trace using tctl.","label":"stack","tags":["tctl"],"markdown_content":"\nThe `tctl workflow stack` command queries [Workflow Execution](/concepts/what-is-a-workflow-execution) with `__stack_trace` as the query type.\n\nThis command can be used to locate errors and blocks in a [Workflow Definition](/concepts/what-is-a-workflow-definition).\n\n`tctl workflow stack <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\n**This is a required modifier.**\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow stack --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow stack --run_id <id>\n```\n\n### --input\n\nPass input for the query.\nInput must be in JSON format.\nFor multiple JSON objects, concatenate them and use spaces as separators.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow stack --input <json>\n```\n\n### --input_file\n\nPass input for the query from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nInput from the command line overwrites input from the file.\n\n**Example**\n\n```bash\ntctl workflow stack --input_file <filename>\n```\n\n### --query_reject_condition\n\nReject queries based on Workflow state.\nValid values are `not_open` and `not_completed_cleanly`.\n\n**Example**\n\n```bash\ntctl workflow stack --query_reject_condition <value>\n```\n","is_empty":false},{"file_name":"workflow/start.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/start.md","id":"tctl-v1/workflow/start","title":"tctl workflow start","description":"How to start a new Workflow Execution using tctl.","label":"start","tags":["tctl"],"markdown_content":"\nThe `tctl workflow start` command starts a new [Workflow Execution](/concepts/what-is-a-workflow-execution).\nUnlike `run`, this command returns the Workflow Id and Run Id immediately after starting the Workflow.\n\n`tctl workflow start <modifiers>`\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n### --taskqueue\n\nSpecify a [Task Queue](/concepts/what-is-a-task-queue).\n\nAlias: `--t`\n\n**Example**\n\n```bash\ntctl workflow start --taskqueue <name>\n```\n\n### --workflow_id\n\n**This is a required modifier.**\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow start --workflow_id <id>\n```\n\nIf a Workflow is started without providing an Id, the Client generates one in the form of a UUID.\nTemporal recommends using a business id rather than the client-generated UUID.\n\n**Example**\n\n```bash\ntctl workflow start  --workflow_id \"HelloTemporal1\" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\\"Temporal\\\"\n```\n\n### --workflow_type\n\nSpecify the name of a [Workflow Type](/concepts/what-is-a-workflow-type).\n\n**Example**\n\n```bash\ntctl workflow start --workflow_type <name>\n```\n\n### --execution_timeout\n\nSpecify the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) of the [Workflow Execution](/concepts/what-is-a-workflow-execution) in seconds.\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl workflow start --execution_timeout <seconds>\n```\n\n### --workflow_task_timeout\n\nSpecify the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) of the [Workflow Task](/concepts/what-is-a-workflow-task) in seconds.\nThe default value is 10.\n\n**Example**\n\n```bash\ntctl workflow start --workflow_task_timeout <seconds>\n```\n\n### --cron\n\nSpecify a [Cron Schedule](/concepts/what-is-a-temporal-cron-job/#cron-schedules).\n\n**Example**\n\n```bash\ntctl workflow start --cron <string>\n```\n\n### --workflowidreusepolicy\n\nSpecify a [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy).\nConfigure if the same [Workflow Id](/concepts/what-is-a-workflow-id) is allowed for use in new [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nThere are three allowed values:\n\n- [**AllowDuplicateFailedOnly:**](/concepts/what-is-a-workflow-id-reuse-policy)\n- [**AllowDuplicate:**](/concepts/what-is-a-workflow-id-reuse-policy)\n- [**RejectDuplicate:**] (/concepts/what-is-a-workflow-id-reuse-policy)\n\n**Examples**\n\n```bash\ntctl workflow start --workflowidreusepolicy AllowDuplicate\ntctl workflow start --workflowidreusepolicy AllowDuplicateFailedOnly\ntctl workflow start --workflowidreusepolicy RejectDuplicate\n```\n\n:::note\n\nMultiple Workflows with the same Id cannot be run at the same time\n\n:::\n\n### --input\n\nPass input for the Workflow.\nInput must be in JSON format.\nFor multiple JSON objects, pass each in a separate `--input` option.\nUse `null` for null values.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl workflow start --input <json>\n```\n\n### --input_file\n\nPass input for the Workflow from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nInput from the command line overwrites input from the file.\n\n**Example**\n\n```bash\ntctl workflow start --input_file <filename>\n```\n\n### --memo_key\n\nPass a key for a memo.\nFor multiple keys, concatenate them and use spaces as separators.\n\n**Example**\n\n```bash\ntctl workflow start --memo_key <key>\n```\n\n### --memo\n\nPass information for a [memo](/concepts/what-is-a-memo) from a JSON file.\n\nMemos are immutable key/value pairs that can be attached to a workflow run when starting the workflow.\nMemos are visible when listing workflows.\n\nFor multiple memos, concatenate them and use spaces as separators.\nThe order must match the order of keys in `--memo_key`.\n\n**Example**\n\n```bash\ntctl workflow start \\\n  -tq your-task-queue \\\n  -wt your-workflow \\\n  -et 60 \\\n  -i '\"temporal\"' \\\n  -memo_key '<key values>' \\\n  -memo '<value>'\n```\n\n### --memo_file\n\nPass information for a memo from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nThe order must match the order of keys in `--memo_key`.\n\n**Example**\n\n```bash\ntctl workflow start --memo_file <filename>\n```\n\n### --search_attr_key\n\nSpecify a [Search Attribute](/concepts/what-is-a-search-attribute) name.\nFor multiple names, concatenate them and use pipes (`|`) as separators.\n\nTo list valid Search Attributes, use the `tctl cluster get-search-attributes` command.\n\n**Example**\n\n```bash\ntctl workflow start --search_attr_key <key>\n```\n\n### --search_attr_value\n\nSpecify a [Search Attribute](/concepts/what-is-a-search-attribute) value.\nFor multiple values, concatenate them and use pipes (`|`) as separators.\nIf a value is an array, use JSON format, such as `[\"a\",\"b\"]`, `[1,2]`, `[\"true\",\"false\"]`, or `[\"2022-06-07T17:16:34-08:00\",\"2022-06-07T18:16:34-08:00\"]`.\n\nTo list valid Search Attributes and value types, use the `tctl cluster get-search-attributes` command.\n\n**Example**\n\n```bash\ntctl workflow start --search_attr_value <value>\n```\n","is_empty":false},{"file_name":"workflow/terminate.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/workflow/terminate.md","id":"tctl-v1/workflow/terminate","title":"tctl workflow terminate","description":"How to terminate a Workflow Execution using tctl.","label":"terminate","tags":["tctl"],"markdown_content":"\nThe `tctl workflow terminate` command terminates a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nTerminating a running Workflow Execution records a `WorkflowExecutionTerminated` event as the closing event in the History.\nNo more command tasks will be scheduled.\n\nSee also [`tctl workflow cancel`](/tctl-v1/workflow/cancel).\n\n`tctl workflow terminate --query <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\n_Required modifier_\n\nSpecify a [Workflow Id](/concepts/what-is-a-workflow-id).\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl workflow terminate --workflow_id <id>\n```\n\n### --run_id\n\nSpecify a [Run Id](/concepts/what-is-a-run-id).\n\nIf `run_id` is not specified, `tctl` terminates the last Workflow Execution for the specified `workflow_id`.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl workflow terminate --run_id <id>\n```\n\n### --reason\n\nSpecify a reason for terminating the [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\n**Example**\n\n```bash\ntctl workflow terminate --workflow_id --reason <string>\n```\n","is_empty":false},{"file_name":"taskqueue/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/taskqueue/describe.md","id":"tctl-v1/taskqueue/describe","title":"tctl taskqueue describe","description":"How to describe the poller information of a Task Queue using tctl.","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl taskqueue describe` command describes the poller information of a [Task Queue](/concepts/what-is-a-task-queue).\n\n`tctl taskqueue describe <modifiers> <value>`\n\nThe following modifiers control the behavior of the command.\n\n### --taskqueue\n\n_Required modifier_\n\nSpecify a [Task Queue](/concepts/what-is-a-task-queue).\n\nAlias: `--t`\n\n**Example**\n\n```bash\ntctl taskqueue describe --taskqueue <value>\n```\n\n### --taskqueuetype\n\nSpecify the type of a [Task Queue](/concepts/what-is-a-task-queue).\nThe type can be `workflow` or `activity`.\nThe default is `workflow`.\n\n**Example**\n\n```bash\ntctl taskqueue describe --taskqueue <value> --taskqueuetype <type>\n```\n","is_empty":false},{"file_name":"taskqueue/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/taskqueue/index.md","id":"tctl-v1/taskqueue/index","title":"tctl taskqueue","description":"How to operate Task Queues using tctl.","label":"taskqueue","tags":["tctl"],"markdown_content":"\nThe `tctl taskqueue` command enables [Task Queue](/concepts/what-is-a-task-queue) operations.\n\nAlias: `t`\n\n- [tctl taskqueue describe](/tctl-v1/taskqueue/describe)\n- [tctl taskqueue list-partition](/tctl-v1/taskqueue/list-partition)\n","is_empty":false},{"file_name":"taskqueue/list-partition.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/taskqueue/list-partition.md","id":"tctl-v1/taskqueue/list-partition","title":"tctl taskqueue list-partition","description":"How to list Task Queue partitions and the hostname for partitions using tctl.","label":"list-partition","tags":["tctl"],"markdown_content":"\nThe `tctl taskqueue list-partition` command lists the partitions of a [Task Queue](/concepts/what-is-a-task-queue) and the hostname for the partitions.\n\n`tctl taskqueue list-partition --taskqueue <value>`\n\nThe following modifier controls the behavior of the command.\n\n### --taskqueue\n\n_Required modifier_\n\nSpecify a [Task Queue](/concepts/what-is-a-task-queue) description.\n\nAlias: `--t`\n\n**Example**\n\n```bash\ntctl taskqueue list-partition --taskqueue <value>\n```\n","is_empty":false},{"file_name":"schedule/backfill.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/schedule/backfill.md","id":"tctl-v1/schedule/backfill","title":"tctl schedule backfill","description":"How to backfill a Schedule using tctl.","label":"backfill","tags":["tctl"],"markdown_content":"\nBackfilling a Schedule means having it do now what it would have done over a specified time range (generally in the past, although it won't prevent you from giving a time range in the future).\nYou might use this to fill in runs from a time period when the Schedule was paused due to an external condition that's now resolved, or a period before the Schedule was created.\n\n```shell\ntctl schedule backfill --sid 'your-schedule-id' \\\n  --overlap-policy 'BufferAll'                \\\n  --start-time '2022-05-01T00:00:00Z'         \\\n  --end-time   '2022-05-31T23:59:59Z'\n```\n\nNote that, similar to [tctl schedule trigger](/tctl-v1/schedule/trigger) immediately, you probably want to override the Overlap Policy.\nSpecifying `AllowAll` runs all the backfilled Workflows at once; `BufferAll` runs them sequentially.\nThe other policies don't make much sense in this context.\n","is_empty":false},{"file_name":"schedule/create.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/schedule/create.md","id":"tctl-v1/schedule/create","title":"tctl schedule create","description":"How to create a Schedule using tctl.","label":"create","tags":["tctl"],"markdown_content":"\nWith tctl, create a Schedule like this:\n\n```shell\n$ tctl config set version next   # ensure you're using the new tctl\n$ tctl schedule create \\\n    --sid 'your-schedule-id' \\\n    --interval '5h/15m' \\\n    --cal '{\"dayOfWeek\":\"Fri\",\"hour\":\"11\",\"minute\":\"3\"}' \\\n    --overlap-policy 'BufferAll' \\\n    --wid 'your-workflow-id' \\\n    --tq 'your-task-queue' \\\n    --type 'YourWorkflowType'\n```\n\nThis Schedule takes action every 5 hours at 15 minutes past the hour and also at 11:03 on Fridays.\nIt starts a Workflow `YourWorkflowType` on Task Queue `your-task-queue`, giving it a Workflow Id like `your-workflow-id-2022-06-17T11:03:00Z`.\nWorkflows do not run in parallel.\nIf they would otherwise overlap, they are buffered to run sequentially.\n\nYou can also use traditional cron strings, including all features that are supported by `CronSchedule` today, such as `@weekly` and other shorthands, `@every`, and `CRON_TZ`.\n\n```shell\n$ tctl schedule create \\\n    --sid 'your-schedule-id' \\\n    --cron '3 11 * * Fri' \\\n    --wid 'your-workflow-id' \\\n    --tq 'your-task-queue' \\\n    --type 'YourWorkflowType'\n```\n\nAny combination of `--cal`, `--interval`, and `--cron` is supported and Actions will happen at any of the specified times.\nIf you use both `--time-zone` and also `CRON_TZ`, they must agree.\n\nSee `tctl schedule create --help` for the full set of available options.\n","is_empty":false},{"file_name":"schedule/delete.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/schedule/delete.md","id":"tctl-v1/schedule/delete","title":"tctl schedule delete","description":"How to delete a Schedule using tctl","label":"delete","tags":["tctl"],"markdown_content":"\nA Schedule can be deleted.\n\nDeleting a Schedule **does not** affect any Workflows started by the Schedule.\nWorkflow Executions started by Schedules can be cancelled or terminated using the same methods as any others.\nHowever, Workflow Executions started by a Schedule can be identified by the Search Attributes added to them and can be targeted by a [batch](/tctl-v1/batch/) command for termination.\n\n```shell\n$ tctl schedule delete --sid 'your-schedule-id'\n```\n","is_empty":false},{"file_name":"schedule/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/schedule/describe.md","id":"tctl-v1/schedule/describe","title":"tctl schedule describe","description":"How to describe a Schedule using tctl","label":"describe","tags":["tctl"],"markdown_content":"\nDisplay the current Schedule configuration as well as extra information about past, current, and future Runs.\n\n```shell\ntctl schedule describe --sid 'your-schedule-id'\n```\n\nBecause the Schedule Spec is converted to canonical representations, the output might not be in the same form as it was input.\n","is_empty":false},{"file_name":"schedule/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/schedule/index.md","id":"tctl-v1/schedule/index","title":"tctl schedule","description":"How to operate Schedules using tctl.","label":"schedule","tags":["tctl"],"markdown_content":"\nA [Schedule](/concepts/what-is-a-schedule) is an experimental feature available in `tctl 1.17` and `tctl next`.\n\n- [Backfill a Schedule using tctl](/tctl-v1/schedule/backfill)\n- [Create a Schedule using tctl](/tctl-v1/schedule/create)\n- [Delete a Schedule using tctl](/tctl-v1/schedule/delete)\n- [Describe a Schedule using tctl](/tctl-v1/schedule/describe)\n- [List Schedules using tctl](/tctl-v1/schedule/list)\n- [Toggle Pause on Schedule using tctl](/tctl-v1/schedule/toggle)\n- [Trigger an Action on a Schedule using tctl](/tctl-v1/schedule/trigger)\n- [Update a Schedule using tctl](/tctl-v1/schedule/update)\n","is_empty":false},{"file_name":"schedule/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/schedule/list.md","id":"tctl-v1/schedule/list","title":"tctl schedule list","description":"How to list Schedules using tctl","label":"list","tags":["tctl"],"markdown_content":"\n```shell\ntctl schedule list\n```\n\nNote that if you're using Standard Visibility, listing Schedules will currently only include Schedule Ids and no other information.\n\nBecause the Schedule Spec is converted to canonical representations, the output might not be in the same form as it was input.\n","is_empty":false},{"file_name":"schedule/toggle.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/schedule/toggle.md","id":"tctl-v1/schedule/toggle","title":"tctl schedule toggle","description":"How to toggle (pause/unpause) a Schedule using tctl.","label":"toggle","tags":["tctl"],"markdown_content":"\n```shell\n$ tctl schedule toggle --sid 'your-schedule-id' --pause --reason \"paused because the database is down\"\n$ tctl schedule toggle --sid 'your-schedule-id' --unpause --reason \"the database is back up\"\n```\n","is_empty":false},{"file_name":"schedule/trigger.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/schedule/trigger.md","id":"tctl-v1/schedule/trigger","title":"tctl schedule trigger","description":"How to trigger a Schedule Action using tctl","label":"trigger","tags":["tctl"],"markdown_content":"\nStarting a Workflow Run immediately with a Schedule, regardless of its configured Spec, is a common use case.\n\n```shell\n$ tctl schedule trigger --sid 'your-schedule-id'\n```\n\nNote that the action that it takes is subject to the Overlap Policy of the Schedule by default: if the overlap policy is `Skip` and a Workflow is already running, the triggered Action to start the next Workflow Run is skipped!\nLikewise, if the overlap policy is `BufferAll`, the triggered run is buffered behind one or more runs.\n\nIf you really want it to run right now, you can override the overlap policy for this request:\n\n```shell\n$ tctl schedule trigger --sid 'your-schedule-id' --overlap-policy 'AllowAll'\n```\n","is_empty":false},{"file_name":"schedule/update.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/schedule/update.md","id":"tctl-v1/schedule/update","title":"tctl schedule update","description":"How to update a Schedule using tctl.","label":"update","tags":["tctl"],"markdown_content":"\nAny part of the Schedule configuration can be updated at any time.\n\n`tctl schedule update` takes the same options as `tctl schedule create` and replaces the entire configuration of the schedule with what's provided.\n\nThis means if you want to change just one value, you have to provide everything else again.\n","is_empty":false},{"file_name":"namespace/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/namespace/describe.md","id":"tctl-v1/namespace/describe","title":"tctl namespace describe","description":"How to describe a Namespace using tctl.","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl namespace describe` command describes a [Namespace](/namespaces).\n\n`tctl namespace describe`\n\nThe following modifier controls the behavior of the command.\n\n### --namespace_id\n\nSpecify the ID of a Namespace to describe.\n\nThis modifier is required unless the global `--namespace` modifier is specified (`tctl --namespace <name> describe`).\n\n**Example**\n\n```bash\ntctl namespace describe --namespace_id <id>\n```\n\nExample results for a [Global Namespace](/namespaces/#global-namespaces)\n\n```bash\n$ tctl --ns canary-namespace n desc\nName: canary-namespace\nDescription: testing namespace\nOwnerEmail: dev@yourtech.io\nNamespaceData:\nStatus: REGISTERED\nRetentionInDays: 7\nEmitMetrics: true\nActiveClusterName: dc1\nClusters: dc1, dc2\n```\n","is_empty":false},{"file_name":"namespace/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/namespace/index.md","id":"tctl-v1/namespace/index","title":"tctl namespace","description":"How to operate Namespaces using tctl.","label":"namespace","tags":["tctl"],"markdown_content":"\nThe `tctl namespace` commands enable [Namespace](/concepts/what-is-a-namespace) operations.\n\nAlias: `n`\n\n- [tctl namespace describe](/tctl-v1/namespace/describe)\n- [tctl namespace list](/tctl-v1/namespace/list)\n- [tctl namespace register](/tctl-v1/namespace/register)\n- [tctl namespace update](/tctl-v1/namespace/update)\n","is_empty":false},{"file_name":"namespace/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/namespace/list.md","id":"tctl-v1/namespace/list","title":"tctl namespace list","description":"How to list all Namespaces using tctl.","label":"list","tags":["tctl"],"markdown_content":"\nThe `tctl namespace list` command lists all [Namespaces](/concepts/what-is-a-namespace).\n\n`tctl namespace list`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"namespace/register.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/namespace/register.md","id":"tctl-v1/namespace/register","title":"tctl namespace register","description":"How to register a Namespace using tctl.","label":"register","tags":["tctl"],"markdown_content":"\nThe `tctl namespace register` command registers a [Namespace](/concepts/what-is-a-namespace).\n\n`tctl namespace register`\n\nBy default, Temporal uses a \"default\" Namespace.\nCreate and register a new Namespace with the following command:\n\n```bash\ntctl --namespace your-namespace namespace register\n# OR using short alias\ntctl --ns your-namespace n re\n```\n\nThe following modifiers control the behavior of the command.\n\n### --active_cluster\n\nSpecify the name of the active [Temporal Cluster](/concepts/what-is-a-temporal-cluster/) when registering a [Namespace](/concepts/what-is-a-namespace).\nThis value changes for Global Namespaces when a failover occurs.\n\n**Example**\n\n```bash\ntctl namespace register --active_cluster <name>\n```\n\n### --clusters\n\nSpecify a list of [Temporal Clusters](/concepts/what-is-a-temporal-cluster/) when registering a [Namespace](/concepts/what-is-a-namespace).\n\nThe list contains the names of Clusters (separated by spaces) to which the Namespace can fail over.\nMake sure to include to the currently active Cluster.\nThis is a read-only setting and cannot be changed.\n\nThis modifier is valid only when the `--global_namespace` modifier is set to true.\n\n**Example**\n\n```bash\ntctl namespace register --clusters <names>\n```\n\n### --description\n\nSpecify a description when registering a [Namespace](/concepts/what-is-a-namespace).\n\n**Example**\n\n```bash\ntctl namespace register --description <value>\n```\n\n### --global_namespace\n\nSpecifies whether a [Namespace](/concepts/what-is-a-namespace) is a [Global Namespace](/namespaces/#global-namespace).\nWhen enabled, it controls the creation of replication tasks on updates allowing the state to be replicated across Clusters.\nThis is a read-only setting and cannot be changed.\n\n**Example**\n\n```bash\ntctl namespace register --global_namespace <boolean>\n```\n\n### --history_archival_state\n\nSet the state of [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n\n**Example**\n\n```bash\ntctl namespace register --history_archival_state <value>\n```\n\n### --history_uri\n\nSpecify the URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n\n**Example**\n\n```bash\ntctl namespace register --history_uri <uri>\n```\n\n### --namespace_data\n\nSpecify data for a [Namespace](/concepts/what-is-a-namespace) in the form of key-value pairs (such as `k1:v1,k2:v2,k3:v3`).\n\n**Example**\n\n```bash\ntctl namespace register --namespace_data <data>\n```\n\n### --owner_email\n\nSpecify the email address of the [Namespace](/concepts/what-is-a-namespace) owner.\n\n**Example**\n\n```bash\ntctl namespace register --owner_email <value>\n```\n\n### --retention\n\nSet the [Retention Period](/clusters#retention-period) for the [Namespace](/concepts/what-is-a-namespace).\n\nThe Retention Period applies to Closed [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\n**Example**\n\n```bash\ntctl namespace register --retention <value>\n```\n\n### --visibility_archival_state\n\nSet the visibility state for [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n\n**Example**\n\n```bash\ntctl namespace register --visibility_archival_state <value>\n```\n\n### --visibility_uri\n\nSpecify the visibility URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n\n**Example**\n\n```bash\ntctl namespace register --visibility_uri <uri>\n```\n","is_empty":false},{"file_name":"namespace/update.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/namespace/update.md","id":"tctl-v1/namespace/update","title":"tctl namespace update","description":"How to update a Namespace using tctl.","label":"update","tags":["tctl"],"markdown_content":"\nThe `tctl namespace update` command updates a [Namespace](/concepts/what-is-a-namespace).\n\n`tctl namespace update`\n\nThe following modifiers control the behavior of the command.\n\n### --active_cluster\n\nSpecify the name of the active [Temporal Cluster](/concepts/what-is-a-temporal-cluster/) when updating a [Namespace](/concepts/what-is-a-namespace).\n\n**Example**\n\n```bash\ntctl namespace update --active_cluster <name>\n```\n\n### --add_bad_binary\n\nAdd a binary checksum to use when resetting a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nTemporal will not dispatch any [Commands](/concepts/what-is-a-command) to the given binary.\n\nSee also [`--remove_bad_binary`](#--remove_bad_binary).\n\n**Example**\n\n```bash\ntctl namespace update --add_bad_binary <value>\n```\n\n### --clusters\n\nSpecify a list of [Temporal Clusters](/concepts/what-is-a-temporal-cluster/) when updating a [Namespace](/concepts/what-is-a-namespace).\n\nThe list contains the names of Clusters (separated by spaces) to which the Namespace can fail over.\n\nThis modifier is valid only when the `--global_namespace` modifier is set to true.\n\n**Example**\n\n```bash\ntctl namespace update --clusters <names>\n```\n\n### --description\n\nSpecify a description when updating a [Namespace](/concepts/what-is-a-namespace).\n\n**Example**\n\n```bash\ntctl namespace update --description <value>\n```\n\n### --history_archival_state\n\nSet the state of [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n\n**Example**\n\n```bash\ntctl namespace update --history_archival_state <value>\n```\n\n### --history_uri\n\nSpecify the URI for URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n\n**Example**\n\n```bash\ntctl namespace update --history_uri <uri>\n```\n\n### --namespace_data\n\nSpecify data for a [Namespace](/concepts/what-is-a-namespace) in the form of key-value pairs (such as `k1:v1,k2:v2,k3:v3`).\n\n**Example**\n\n```bash\ntctl namespace update --namespace_data <data>\n```\n\n### --owner_email\n\nSpecify the email address of the [Namespace](/concepts/what-is-a-namespace) owner.\n\n**Example**\n\n```bash\ntctl namespace update --owner_email <value>\n```\n\n### --reason\n\nSpecify a reason for updating a [Namespace](/concepts/what-is-a-namespace).\n\n**Example**\n\n```bash\ntctl namespace update --reason <value>\n```\n\n### --remove_bad_binary\n\nRemove a binary checksum.\n\nSee also [`--add_bad_binary`](#--add_bad_binary).\n\n**Example**\n\n```bash\ntctl namespace update --remove_bad_binary <value>\n```\n\n### --retention\n\nSpecify the number of days to retain [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\n**Example**\n\n```bash\ntctl namespace update --retention <value>\n```\n\n### --visibility_archival_state\n\nSet the visibility state for [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n\n**Example**\n\n```bash\ntctl namespace update --visibility_archival_state <value>\n```\n\n### --visibility_uri\n\nSpecify the visibility URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n\n**Example**\n\n```bash\ntctl namespace update --visibility_uri <uri>\n```\n","is_empty":false},{"file_name":"dataconverter/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/dataconverter/index.md","id":"tctl-v1/dataconverter/index","title":"tctl dataconverter","description":"How to operate custom Data Converters using tctl.","label":"dataconverter","tags":["tctl"],"markdown_content":"\nThe `tctl dataconverter` command enables custom [Data Converter](/concepts/what-is-a-data-converter) operations.\n\n- [tctl dataconverter web](/tctl-v1/dataconverter/web)\n","is_empty":false},{"file_name":"dataconverter/web.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/dataconverter/web.md","id":"tctl-v1/dataconverter/web","title":"tctl dataconverter web","description":"How to specify the WebSocket URL of a custom Data Converter using tctl.","label":"web","tags":["tctl"],"markdown_content":"\nThe `tctl dataconverter web` command specifies the WebSocket URL of a custom [Data Converter](/concepts/what-is-a-data-converter) to use with Temporal Web.\n\n`tctl dataconverter web --web_ui_url <url>`\n\nThe following modifiers control the behavior of the command.\n\n### --port\n\nSpecify a port for the WebSocket URL of a custom [Data Converter](/concepts/what-is-a-data-converter).\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl dataconverter web --web_ui_url <url> --port <value>\n```\n\n### --web_ui_url\n\n_Required modifier_\n\nSpecify the WebSocket URL of a custom [Data Converter](/concepts/what-is-a-data-converter).\n\n**Example**\n\n```bash\ntctl dataconverter web --web_ui_url <url>\n```\n","is_empty":false},{"file_name":"cluster/get-search-attributes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/cluster/get-search-attributes.md","id":"tctl-v1/cluster/get-search-attributes","title":"tctl cluster get-search-attributes","description":"How to list all Search Attributes using tctl.","label":"get-search-attributes","tags":["tctl"],"markdown_content":"\nThe `tctl cluster get-search-attributes` command lists all [Search Attributes](/concepts/what-is-a-search-attribute) that can be used in the `--query` modifier of the [`tctl workflow list`](/tctl-v1/workflow/list) command and the `--search_attr_key` and `--search_attr_value` modifiers of the [`tctl workflow run`](/tctl-v1/workflow/run) and [`tctl workflow start`](/tctl-v1/workflow/start) commands.\n\n**Example:**\n\n```bash\ntctl cluster get-search-attributes\n```\n\nThe command has no modifiers.\n\nExample output:\n\n```text\n+-----------------------+----------+\n|         NAME          |   TYPE   |\n+-----------------------+----------+\n| BinaryChecksums       | Keyword  |\n| CloseTime             | Int      |\n| CustomBoolField       | Bool     |\n| CustomDatetimeField   | Datetime |\n| CustomDoubleField     | Double   |\n| CustomIntField        | Int      |\n| CustomKeywordField    | Keyword  |\n| CustomNamespace       | Keyword  |\n| CustomStringField     | String   |\n| ExecutionStatus       | Int      |\n| ExecutionTime         | Int      |\n| Operator              | Keyword  |\n| RunId                 | Keyword  |\n| StartTime             | Int      |\n| TaskQueue             | Keyword  |\n| TemporalChangeVersion | Keyword  |\n| WorkflowId            | Keyword  |\n| WorkflowType          | Keyword  |\n+-----------------------+----------+\n```\n\nThe admin version of this command displays default and custom Search Attributes separately, and also shows the underlying Elasticsearch index schema and system Workflow status.\n","is_empty":false},{"file_name":"cluster/health.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/cluster/health.md","id":"tctl-v1/cluster/health","title":"tctl cluster health","description":"How to check the health of the Frontend Service using tctl.","label":"health","tags":["tctl"],"markdown_content":"\nThe `tctl cluster health` command checks the health of the [Frontend Service](/concepts/what-is-a-temporal-cluster/#frontend-service).\n\n`tctl cluster health`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"cluster/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/cluster/index.md","id":"tctl-v1/cluster/index","title":"tctl cluster","description":"How to operate Temporal Clusters using tctl.","label":"cluster","tags":["tctl"],"markdown_content":"\nThe `tctl cluster` command enables [Temporal Cluster](/concepts/what-is-a-temporal-cluster) operations.\n\n- [tctl cluster health](/tctl-v1/cluster/health)\n- [tctl cluster get-search-attributes](/tctl-v1/cluster/get-search-attributes)\n","is_empty":false},{"file_name":"batch/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/batch/describe.md","id":"tctl-v1/batch/describe","title":"tctl batch describe","description":"How to describe the progress of a batch job using tctl.","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl batch describe` command describes the progress of a batch job.\n\n`tctl batch describe --job_id <id>`\n\n:::note\n\n`tctl` can run `batch` and `batch-v2` commands.\n\n:::\n\nThe following modifier controls the behavior of the command.\n\n### --job_id\n\n_Required modifier_\n\nSpecify the job ID of a batch job.\n\n**Example**\n\n```bash\ntctl batch describe --job_id <id>\n```\n","is_empty":false},{"file_name":"batch/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/batch/index.md","id":"tctl-v1/batch/index","title":"tctl batch","description":"A tctl batch command enables you to affect multiple existing Workflow Executions with a single command.","label":"batch","tags":["tctl"],"markdown_content":"\n**How to run a tctl batch command.**\n\nA `tctl batch` command enables you to affect multiple existing [Workflow Executions](/concepts/what-is-a-workflow-execution) with a single command.\nA batch job runs in the background and affects Workflow Executions one at a time.\n\nUse [tctl batch start](/tctl-v1/batch/start) to start a batch job.\n\n:::note\n\n`tctl-v1` can run `batch` and `batch-v2` commands.\n\n:::\n\nWhen starting a batch job, you must provide a [List Filter](/concepts/what-is-a-list-filter) and the type of batch job that should occur.\nBatch jobs run in the background and affect Workflow Executions one at a time.\n\nThe List Filter identifies the set of Workflow Executions to be affected by the batch job.\nThe `tctl batch start` command shows you how many Workflow Executions will be affected by the batch job and asks you to confirm before proceeding.\n\nThe batch type determines what other parameters you must provide and what is being affected.\nThere are three types of batch jobs:\n\n- Signal: Send a Signal to the set of Workflow Executions that the List Filter specifies.\n- Cancel: Cancel the set of Workflow Executions that the List Filter specifies.\n- Terminate: Terminate the set of Workflow Executions that the List Filter specifies.\n\nA successfully started batch job returns a Job ID.\nYou can use this Job ID in the `tctl batch describe` command, which describes the progress of a specific batch job.\n\nYou can also use the Job ID to terminate the batch job itself.\nTerminating a batch job does not roll back the operations already performed by the batch job.\n\n### tctl batch commands\n\n- [tctl batch describe](/tctl-v1/batch/describe)\n- [tctl batch list](/tctl-v1/batch/list)\n- [tctl batch start](/tctl-v1/batch/start)\n- [tctl batch terminate](/tctl-v1/batch/terminate)\n","is_empty":false},{"file_name":"batch/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/batch/list.md","id":"tctl-v1/batch/list","title":"tctl batch list","description":"How to list batch jobs using tctl.","label":"list","tags":["tctl"],"markdown_content":"\nThe `tctl batch list` command lists all batch jobs.\n\n`tctl batch list <modifiers>`\n\n:::note\n\n`tctl-v1` can run `batch` and `batch-v2` commands.\n\n:::\n\nThe following modifier controls the behavior of the command.\n\n### --pagesize\n\nSpecify the maximum number of batch jobs to list on a page. The default value is 30.\n\n**Example**\n\n```bash\ntctl batch list --pagesize <value>\n```\n","is_empty":false},{"file_name":"batch/start.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/batch/start.md","id":"tctl-v1/batch/start","title":"tctl batch start","description":"How to start a batch job using tctl.","label":"start","tags":["tctl"],"markdown_content":"\nThe `tctl batch start` command starts a batch job.\n\n`tctl batch start --query <value> <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### `--query`\n\n_Required modifier_\n\nSpecify the [Workflow Executions](/concepts/what-is-a-workflow-execution) that this batch job should operate.\n\nThe SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute) is the same as used by the `tctl workflow list --query` command.\n\nAlias: `-q`\n\n**Example**\n\n```bash\ntctl batch start --query <value>\n```\n\n### `--reason`\n\nSpecify a reason for running this batch job.\n\n**Example**\n\n```bash\ntctl batch start --query <value> --reason <string>\n```\n\n### `--batch_type`\n\nSpecify the operation that this batch job performs. The supported operations are `signal`, `cancel`, and `terminate`.\n\n**Example**\n\n```bash\ntctl batch start --query <value> --batch_type <operation>\n```\n\n### `--signal_name`\n\nSpecify the name of a [Signal](/concepts/what-is-a-signal). This modifier is required when `--batch_type` is `signal`.\n\n**Example**\n\n```bash\ntctl batch start --query <value> --batch_type signal --signal_name <name>\n```\n\n### `--input`\n\nPass input for the [Signal](/concepts/what-is-a-signal). Input must be in JSON format.\n\nAlias: `-i`\n\n**Example**\n\n```bash\ntctl batch start --query <value> --input <json>\n```\n\n### `--rps`\n\nSpecify RPS of processing. The default value is 50.\n\n**Example**\n\n```bash\ntctl batch start --query <value> --rps <value>\n```\n\n### `--yes`\n\nDisable the confirmation prompt.\n\nAlias: `y`\n\n**Example**\n\n```bash\ntctl batch start --query <value> --yes\n```\n","is_empty":false},{"file_name":"batch/terminate.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/batch/terminate.md","id":"tctl-v1/batch/terminate","title":"tctl batch terminate","description":"How to terminate a batch job using tctl.","label":"terminate","tags":["tctl"],"markdown_content":"\nThe `tctl batch terminate` command terminates a batch job.\n\n`tctl batch terminate --job_id <id> <modifiers>`\n\n:::note\n\n`tctl-v1` can run `batch` and `batch-v2` commands.\n\n:::\n\nThe following modifiers control the behavior of the command.\n\n### `--job_id`\n\n_Required modifier_\n\nSpecify the job ID of a batch job.\n\n**Example**\n\n```bash\ntctl batch terminate --job_id <id>\n```\n\n### `--reason`\n\nSpecify a reason for terminating this batch job.\n\n**Example**\n\n```bash\ntctl batch terminate --job_id <id> --reason <string>\n```\n","is_empty":false},{"file_name":"admin/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/index.md","id":"tctl-v1/admin/index","title":"tctl admin","description":"How to run admin-level tctl commands.","label":"admin","tags":["tctl","admin"],"markdown_content":"\nA `tctl admin` command allows the user to run admin operations.\n\nModifiers:\n\n#### --help\n\n`tctl admin [--help | -h]`\n","is_empty":false},{"file_name":"admin/workflow/delete.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/workflow/delete.md","id":"tctl-v1/admin/workflow/delete","title":"tctl admin workflow delete","description":"Deleting the Workflow Execution.","label":"delete","tags":["tctl","admin","workflow"],"markdown_content":"\nThe `tctl admin workflow delete` command deletes the current [Workflow Execution](/workflows/#workflow-execution) and the mutableState record.\n\n#### --db_engine value\n\nThe type of database (DB) engine to use.\n\nDefault: \"cassandra\"\nValues: \"cassandra\", \"mysql\", \"postgres\"\n\n#### --db_address value\n\nPersistence address for the database.\n\nDefault: 127.0.0.1\n\n#### --db_port value\n\nPersistence port for the database.\n\nDefault: 9042\n\n#### --username value\n\nUsername entered into the database.\n\n#### --password value\n\nPassword entered into the database.\n\n#### --keyspace value\n\nKeyspace for the database.\n\ndefault: \"temporal\"\n\n#### --url value\n\nURL of the Elasticsearch cluster.\n\nDefault: \"http://127.0.0.1:9200\"\n\n#### --es-username value\n\nUsername for the Elasticsearch cluster.\n\n#### --es-password value\n\nPassword for the Elasticsearch cluster.\n\n#### --version value\n\nThe version of the Elasticsearch cluster for the Workflow.\n\nDefault: v7\n\nValues: v6, v7\n\n#### --index value\n\nElasticsearch index name.\n\n#### --workflow_id value\n\nAlias: `-w`\n\nThe Id of the current Workflow.\n\n#### --run_id value\n\nAlias: `-r`\n\nThe Id of the current run.\n\n#### --skip_errors\n\nSkip any errors that occur in the Workflow Execution.\n\n#### --tls\n\nEnables TLS over the database connection.\n\n:::note\n\nTLS must be enabled to use the following modifiers.\n\n:::\n\n#### --tls_cert_path value\n\nDB tls client cert path.\n\nNote: tls must be enabled\n\n#### --tls_key_path value\n\nDB tls client key path\n\nNote: tls must be enabled\n\n#### --tls_ca_path value\n\nDB tls client ca path\n\nNote: tls must be enabled\n\n#### --tls_server_name value\n\nDB tls server name\n\nNote: tls must be enabled\n\n#### --tls_disable_host_verification\n\nDB tls verify hostname and server cert\n\nNote: tls must be enabled\n","is_empty":false},{"file_name":"admin/workflow/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/workflow/describe.md","id":"tctl-v1/admin/workflow/describe","title":"tctl admin workflow describe","description":"Description of Workflow Execution.","label":"describe","tags":["tctl","admin","workflow"],"markdown_content":"\nThe `tctl admin workflow describe` command describes internal information of the current [Workflow Execution](/workflows/#workflow-execution).\n\n#### --workflow_id value\n\nAlias: `-w`\n\nThe Id of the current Workflow.\n\n#### --run_id value\n\nAlias: `-r`\n\nThe Id of the current run.\n","is_empty":false},{"file_name":"admin/workflow/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/workflow/index.md","id":"tctl-v1/admin/workflow/index","title":"tctl admin workflow","description":"Operating admin-level Workflow Executions.","label":"workflow","tags":["tctl","admin","workflow"],"markdown_content":"\nThe `tctl admin workflow` commands enable administrator-level operations on Workflow Executions.\n\n`tctl admin workflow command [modifiers] [arguments...]`\n\n- [show](/tctl-v1/admin/workflow/show)\n\n- [describe](/tctl-v1/admin/workflow/describe)\n\n- [refresh_tasks](/tctl-v1/admin/workflow/refresh_tasks)\n\n- [delete](/tctl-v1/admin/workflow/delete)\n","is_empty":false},{"file_name":"admin/workflow/refresh_tasks.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/workflow/refresh_tasks.md","id":"tctl-v1/admin/workflow/refresh_tasks","title":"tctl admin workflow refresh_tasks","description":"Refreshing Workflow Tasks.","label":"refresh_tasks","tags":["tctl","admin","workflow"],"markdown_content":"\nThe `tctl admin workflow refresh_tasks` command updates all [Tasks](/tasks) in a [Workflow](/workflows), provided that the command can fetch new information for Tasks.\n\n#### --workflow_id value\n\nAlias: `-w`\n\nThe Id of the current Workflow.\n\n#### --run_id value\n\nAlias: `-r`\n\nThe Id of the current run.\n","is_empty":false},{"file_name":"admin/workflow/show.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/workflow/show.md","id":"tctl-v1/admin/workflow/show","title":"tctl admin workflow show","description":"Showing Workflow history.","label":"show","tags":["tctl","admin","workflow"],"markdown_content":"\nThe `tctl admin workflow show` command displays Workflow history from the database.\n\n#### --workflow_id value\n\nAlias: `-w`\n\nThe current Workflow.\n\n#### --run_id value\n\nAlias: `-r`\n\nThe current RunId.\n\n#### --min_event_id value\n\nThe minimum Event Id to include in the history.\n\nDefault: 0\n\n#### --max_event_id value\n\nThe maximum Event Id to include in the history.\n\nDefault: 0\n\n#### --min_event_version value\n\nThe start Event version to be included in the history.\n\nDefault: 0\n\n#### --max_event_version value\n\nThe end Event version to be included in the history.\n\nDefault: 0\n\n#### --output_filename value\n\nThe file where the output is sent to.\n","is_empty":false},{"file_name":"admin/shard/close_shard.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/shard/close_shard.md","id":"tctl-v1/admin/shard/close_shard","title":"tctl admin shard close_shard","description":"closing a shard with a given shard Id","label":"close_shard","tags":["tctl","admin","shard"],"markdown_content":"\nThe `tctl admin shard close_shard` command closes a shard with an Id that corresponds to the value given in the command.\n\n`tctl admin shard close_shard [command options] [arguments...]`\n\nThe modifier below will change the behavior and output of the command.\n\n#### --share_id value\n\nShareId managed by the Temporal Cluster.\n","is_empty":false},{"file_name":"admin/shard/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/shard/describe.md","id":"tctl-v1/admin/shard/describe","title":"tctl admin shard describe","description":"Describes Id of shard.","label":"describe","tags":["tctl","admin","shard"],"markdown_content":"\nThe `tctl admin shard describe` command shows the Id for the specified shard.\n\nThe modifier below controls the behavior of the command.\n\n#### --share_id value\n\nThe Id of the shard to describe\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/shard/describe_task.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/shard/describe_task.md","id":"tctl-v1/admin/shard/describe_task","title":"tctl admin shard describe_task","description":"displaying information on a Task within a shard","label":"describe_task","tags":["tctl","admin","shard"],"markdown_content":"\nThe `tctl admin shard describe_task` command describes a specified Task's Task Id, Task type, shard Id, and task visibility timestamp.\n\nThe modifiers below control the output and behavior of the command. Enter all modifiers after the command as such:\n\n`tctl admin shard describe_task <modifiers>`\n\n#### --db_engine\n\nThe type of database (DB) engine for the shard to use.\n\nDefault: \"cassandra\"\n\nValues: \"cassandra\", \"mysql\", \"postgres\"\n\n<!-- todo: examples -->\n\n#### --db_address\n\nPersistence address for the database.\n\nDefault: 127.0.0.1\n\n#### --db_port\n\nPersistence port for the database.\n\nDefault: 9042\n\n#### --username\n\nUsername entered into the database.\n\n#### --password\n\nPassword entered into the database.\n\n#### --keyspace\n\nKeyspace for the database.\n\ndefault: \"temporal\"\n\n#### --tls\n\nEnables TLS over the database connection.\n\n#### --tls_cert_path\n\nDB tls client cert path.\n\nNote: tls must be enabled\n\n#### --tls_server_name\n\nDB tls server name\n\nNote: tls must be enabled\n\n#### --tls_disable_host_verification\n\nDB tls verify hostname and server cert\n\nNote: tls must be enabled\n\n#### --shard_id\n\nIdentifies the specified shard.\n\nDefault: 0\n\n#### --task_id\n\nDescribes the task.\n\nDefault: 0\n\n#### --task_type\n\nThe kind of Task that is targeted within a shard.\n\nDefault: transfer\n\nValues: transfer, timer, replication\n\n#### --task_timestamp\n\nTask visibility timestamp in nanoseconds\n\nDefault: 0\n\n#### --target_cluster\n\nTemporal cluster for the shard to use.\n\nDefault: \"active\"\n","is_empty":false},{"file_name":"admin/shard/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/shard/index.md","id":"tctl-v1/admin/shard/index","title":"tctl admin shard","description":"Admin-level operations on a specific shard","label":"shard","tags":["tctl","admin","shard"],"markdown_content":"\nThe `tctl admin shard` commands enable admin-level operations on a specified shard.\n\n#### tctl admin shard commands\n\n- [describe](/tctl-v1/admin/shard/describe)\n- [describe_task](/tctl-v1/admin/shard/describe_task)\n- [list_tasks](/tctl-v1/admin/shard/list_tasks)\n- [close_shard](/tctl-v1/admin/shard/close_shard)\n- [remove_task](/tctl-v1/admin/shard/remove_task)\n","is_empty":false},{"file_name":"admin/shard/list_tasks.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/shard/list_tasks.md","id":"tctl-v1/admin/shard/list_tasks","title":"tctl admin shard list_tasks","description":"listing tasks for a given shard Id and Task type","label":"list_tasks","tags":["tctl","admin","shard"],"markdown_content":"\nThe `tctl admin shard list_tasks` command will list the Tasks available for a given shard Id and Task type.\n\nThe modifiers below affect the output and behavior of the command.\n\n#### --more\n\nLists more pages of list tasks.\nThe default setting is to list one page of 10 list tasks.\n\n#### --pagesize value\n\nThe size of the result page.\nDefault: 10\n\n#### --target_cluster value\n\nTemporal cluster to use.\nDefault: \"active\"\n\n#### --shard_id value\n\nThe ID of the shard\n\nDefault: 0\n\n#### --task_type value\n\nThe type of Task.\n\nDefault: transfer\nValues: transfer, timer, replication, visibility\n\n#### --min_visibility_ts value\n\nThe minimum value that can be set as a Task Visibility timestamp.\n\nSupported formats include:\n\n- '2006-01-02T15:04:05+07:00'\n- Raw UnixNano\n- Time range (N-duration), where 0 < N < 1000000 and duration (full-notation/short-notation) can be:\n  - second/s\n  - minute/m\n  - week/w\n  - month/m\n  - year/y\n\n#### --max_visibility_ts value\n\nThe maximum value that can be set as a Task Visibility timestamp.\n\nSupported formats:\n\n- '2006-01-02T15:04:05+07:00'\n- Raw UnixNano\n- Time range (N-duration), where 0 < N < 1000000 and duration (full-notation/short-notation) can be:\n  - second/s\n  - minute/m\n  - week/w\n  - month/m\n  - year/y\n","is_empty":false},{"file_name":"admin/shard/remove_task.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/shard/remove_task.md","id":"tctl-v1/admin/shard/remove_task","title":"tctl admin shard remove_task","description":"removing a Task with given information","label":"remove_task","tags":["tctl","admin","shard"],"markdown_content":"\nThe `tctl admin shard remove_task` command removes a Task from the shard.\n\n`tctl admin shard remove_task [command options] [arguments...]`\n\nThe Task removed must have values that matches what is given in the command line.\n\nThe modifiers below change the behavior of the command.\n\n#### --shard_id value\n\nThe shardId for the Task to be removed.\n\nDefault: 0\n\n#### --task_id value\n\nThe taskId for the Task to be removed.\n\nDefault: 0\n\n#### --task_type value\n\nThe type of Task to remove.\n\nDefault: transfer\n\nValues: transfer, timer, replication\n\n#### --task_timestamp value\n\nThe task visibility timestamp, given in nanoseconds.\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/membership/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/membership/index.md","id":"tctl-v1/admin/membership/index","title":"tctl admin membership","description":"Run admin operations on membership","label":"membership","tags":["tctl"],"markdown_content":"\nThe `tctl admin membership` command allows admin operations to be run on membership items.\n\n### Usage\n\n`tctl admin membership command [command modifiers] [arguments...]`\n\n### Commands\n\n- [list_gossip](/tctl-v1/admin/membership/list_gossip)\n- [list_db](/tctl-v1/admin/membership/list_db)\n","is_empty":false},{"file_name":"admin/membership/list_db.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/membership/list_db.md","id":"tctl-v1/admin/membership/list_db","title":"tctl admin membership list_db","description":"How to describe Cluster membership items","label":"list_db","tags":["operation-guide","tctl"],"markdown_content":"\nThe `tctl admin membership list_db` command lists the Cluster items in a targeted membership.\n\nThe following modifiers change the behavior of the command.\n\n#### --heartbeated_within\n\nFilters the list by last Heartbeat time.\n\n<!-- todo: add supported format list-->\n\n#### --role\n\nFilters the results by membership role.\n\nDefault: all\nValues: all, frontend, history, matching, worker\n","is_empty":false},{"file_name":"admin/membership/list_gossip.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/membership/list_gossip.md","id":"tctl-v1/admin/membership/list_gossip","title":"tctl admin membership list_gossip","description":"How to describe ringpop membership items","label":"list_gossip","tags":["operation-guide","tctl"],"markdown_content":"\nThe `tctl admin membership list_gossip` command lists the ringpop membership items present on the targeted membership.\n\nThe following modifier changes the behavior of the command:\n\n#### --role value\n\nFilters the results by membership role\n\nDefault: all\nValues: all, frontend, history, matching, worker\n","is_empty":false},{"file_name":"admin/history_host/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/history_host/describe.md","id":"tctl-v1/admin/history_host/describe","title":"tctl admin history_host describe","description":"Describing the information in a history host","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl admin history_host describe` command describes the internal information of history host.\n\nThe following modifiers change the behavior of the command.\n\n#### --workflow_id\n\nAlias: `-w`\n\nThe WorkflowId of the Workflow whose history host is to be described.\n\n#### --history_address\n\nThe history address of the history host.\n\n#### --shard_id\n\nThe Id of the shard that belongs to the history host.\n\n#### --print_full\n\nPrint a full and detailed summary of the history host.\n","is_empty":false},{"file_name":"admin/history_host/get_shardid.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/history_host/get_shardid.md","id":"tctl-v1/admin/history_host/get_shardid","title":"tctl admin history_host get_shardid","description":"Providing the shardId on command","label":"get_shardid","tags":["tctl"],"markdown_content":"\nThe `tctl admin history_host get_shardid` command gets the `shardId` for a given `namespaceId` and `workflowId`.\n\nThe following modifiers change the behavior of this command.\n\n#### --namespace_id\n\nThe `namespaceId` of the history host where we're getting the `shardId`.\n\n#### --workflow_id\n\nAlias: `-w`\n\nThe WorkflowId of the history host where we're getting the shardId.\n\n#### --number_of_shards\n\nThe total amount of shards for the Temporal Cluster.\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/history_host/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/history_host/index.md","id":"tctl-v1/admin/history_host/index","title":"tctl admin history_host","description":"Overview of history_host commands","label":"history_host","tags":["tctl"],"markdown_content":"\nThe `tctl admin history_host` command runs an admin-level operation on the history host.\n\n## Usage\n\n`tctl admin history_host command [command options] [arguments...]`\n\n## Commands\n\n- [tctl admin history_host describe](/tctl-v1/admin/history_host/describe)\n- [tctl admin history_host get_shardid](/tctl-v1/admin/history_host/get_shardid)\n","is_empty":false},{"file_name":"admin/dlq/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/dlq/index.md","id":"tctl-v1/admin/dlq/index","title":"tctl admin dlq","description":"Running admin operations on DLQ.","label":"dlq","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin dlq` commands run admin operations on a given dead-letter queue (DLQ).\n\n`tctl admin dlq command [command modifiers] [arguments...]`\n\n- [tctl admin dlq read](/tctl-v1/admin/dlq/read)\n- [tctl admin dlq purge](/tctl-v1/admin/dlq/purge)\n- [tctl admin dlq merge](/tctl-v1/admin/dlq/merge)\n","is_empty":false},{"file_name":"admin/dlq/merge.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/dlq/merge.md","id":"tctl-v1/admin/dlq/merge","title":"tctl admin dlq merge","description":"Merging DLQ messages.","label":"merge","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admib dlq merge` command allows dead-letter queue (DLQ) messages to be merged.\n\nThe messages must have TaskIds with an equal or lesser value than the given TaskId.\n\n#### --dlq_type\n\nThe type of DLQ to manage.\n\nOptions: namespace, history\n\n#### --cluster\n\nSource cluster for the DLQ.\n\n#### --shard_id\n\nShardId provided for the command.\n\n#### --last_message_id\n\nIdentifies the last read message.\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/dlq/purge.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/dlq/purge.md","id":"tctl-v1/admin/dlq/purge","title":"tctl admin dlq purge","description":"Deleting DLQ messages.","label":"purge","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin dlq purge` command deletes DLQ messages that have a Task Id equal to or less than the provided Task Id.\n\n#### --dlq_type\n\nThe type of DLQ to manage.\n\nOptions: namespace, history\n\n#### --cluster\n\nSource cluster for the DLQ.\n\n#### --shard_id\n\nShardId provided for the command.\n\n#### --last_message_id\n\nIdentifies the last read message.\n\nDefault: 0\n","is_empty":false},{"file_name":"admin/dlq/read.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/dlq/read.md","id":"tctl-v1/admin/dlq/read","title":"tctl admin dlq read","description":"Reading DLQ messages.","label":"read","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin dlq read` command reads out messages from the dead-letter queue (DLQ).\n\n---\n\n#### --dlq_type\n\nThe type of DLQ to manage.\n\nOptions: namespace, history\n\n#### --cluster\n\nSource cluster for the DLQ.\n\n#### --shard_id\n\nShardId provided for the command.\n\n#### --max_message_count\n\nThe maximum number of messages to fethc.\n\nDefault: 0\n\n#### --last_message_id\n\nIdentifies the last read message.\n\nDefault: 0\n\n#### --output_filename\n\nProvides a file to write output to.\n\nOutput is written to stdout on default.\n","is_empty":false},{"file_name":"admin/decode/base64.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/decode/base64.md","id":"tctl-v1/admin/decode/base64","title":"tctl admin decode base64","description":"Decoding Payloads to Base64.","label":"base64","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin decode base64` command decodes base64 Payloads.\n\n#### --base64_data\n\nDecoded data in base64 format.\n\n#### --base64_file\n\nCreates a file with data in base64 format.\n","is_empty":false},{"file_name":"admin/decode/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/decode/index.md","id":"tctl-v1/admin/decode/index","title":"tctl admin decode","description":"Decoding payloads.","label":"decode","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin decode` command allows the user to decode payloads sent and received from executed Activities.\n\n`tctl admin decode command [command modifiers] [arguments...]`\n\n- [proto](/tctl-v1/admin/decode/proto)\n- [base64](/tctl-v1/admin/decode/base64)\n","is_empty":false},{"file_name":"admin/decode/proto.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/decode/proto.md","id":"tctl-v1/admin/decode/proto","title":"tctl admin decode proto","description":"Decoding proto payloads.","label":"proto","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin decode proto` command decodes the Payload to proto format.\n\n#### --type\n\nThe full name of the proto type to decode the Payload to.\n\n#### --hex_data\n\nDecodes the data to hex format.\n\n#### --hex_file\n\nCreates a file with the decoded hex data.\n\n#### --binary_file\n\nCreates a file with the decoded binary data.\n","is_empty":false},{"file_name":"admin/db/clean.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/db/clean.md","id":"tctl-v1/admin/db/clean","title":"tctl admin db clean","description":"How to clean up corrupted Workflows using tctl.","label":"clean","tags":["tctl","admin","db"],"markdown_content":"\nThe `tctl admin db clean` command cleans corrupted [Workflow Executions](/workflows/#workflow-executions) from the targeted database.\n\nThe modifiers below change the behavior of the command.\n\n#### --db_engine\n\nType of DB engine to use\n\nDefault: `cassandra`\nValue: `cassandra` | `mysql` | `postgres`\n\n#### --db_address\n\nPersistence address for the database.\n\nDefault: 127.0.0.1\n\n#### --db_port\n\nPersistence port for the DB.\n\nDefault: 9042\n\n#### --username\n\nDatabase username.\n\n#### --password\n\nDatabase password.\n\n#### --keyspace\n\nDatabase keyspace\n\nDefault: \"temporal\"\n\n#### --input_directory\n\nThe directory which contains the corrupted [Workflow Execution](/workflows/#workflow-executions) files from running [`scan`](/tctl-v1/admin/db/scan).\n\n#### --lower_shard_bound\n\nThe minimum amount (inclusive) of corrupt shards to handle.\n\nDefault: 0\n\n#### --upper_shard_bound\n\nThe maximum amount (exclusive) of corrupt shards to handle.\n\nDefault: 16384\n\n#### --starting_rps\n\nstarting rps of database queries.\n\nDefault: 100\n\n#### --rps\n\nTarget rps of database queries.\n\nDefault: 7000\n\n#### --concurrency\n\nNumber of threads to handle a scan.\n\nDefault: 1000\n\n#### --report_rate\n\nThe number of shards handled between each emittance of progress.\n\nDefault: 10\n\n:::note\n\nEnable `--tls` before using any of the following modifiers.\n\n:::\n\n#### --tls_cert_path\n\nWhere the tls client cert is located.\n\n#### --tls_key_path\n\nWhere the tls key is located.\n\n#### --tls_ca_pat\n\nWhere the tls ca is located.\n\n#### --tls_server_name\n\nThe name of the Db tls server.\n\n#### --tls_disable_host_verification\n\nDisables verification of the DB tls hostname and server cert.\n","is_empty":false},{"file_name":"admin/db/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/db/index.md","id":"tctl-v1/admin/db/index","title":"tctl admin db","description":"Running admin operations on database - tctl - admin - db","label":"db","markdown_content":"\nThe `tctl admin db` command runs administrator-level operations on a given database.\n\n### Usage\n\n`tctl admin db command [command modifiers] [arguments...]`\n\n### Commands\n\n- [tctl admin db scan](/tctl-v1/admin/db/scan)\n- [tctl admin db clean](/tctl-v1/admin/db/clean)\n","is_empty":false},{"file_name":"admin/db/scan.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/db/scan.md","id":"tctl-v1/admin/db/scan","title":"tctl admin db scan","description":"Scanning for corrupted executions in a database","label":"scan","tags":["tctl","admin","db"],"markdown_content":"\nThe `tctl admin db scan` command scans concrete Workflow Executions in a given database, and detects corrupted ones.\n\n#### --db_engine\n\nType of DB engine to use\n\nDefault: `cassandra`\nValue: `cassandra` | `mysql` | `postgres`\n\n#### --db_address\n\nPersistence address for the DB.\n\nDefault: 127.0.0.1\n\n#### --db_port\n\nPersistence port for the DB.\n\nDefault: 9042\n\n#### --username\n\nDB username.\n\n#### --password\n\nDB password.\n\n#### --keyspace\n\nDB keyspace\n\nDefault: \"temporal\"\n\n#### --lower_shard_bound value\n\nThe minimum amount (inclusive) of corrupt shards to handle.\n\nDefault: 0\n\n#### --upper_shard_bound\n\nThe maximum amount (exclusive) of corrupt shards to handle.\n\nDefault: 16384\n\n#### --starting_rps\n\nstarting rps of database queries.\n\nDefault: 100\n\n#### --rps value\n\nTarget rps of database queries.\n\nDefault: 7000\n\n#### --pagesize\n\nThe size of the page used to query database executions.\n\nDefault: 500\n\n#### --concurrency\n\nNumber of threads to handle a scan.\n\nDefault: 1000\n\n#### --report_rate\n\nThe number of shards handled between each emittance of progress.\n\nDefault: 10\n\n#### --tls\n\nEnable TLS over the DB connection.\n\n:::note\n\nEnable `--tls` before using any of the following modifiers.\n\n:::\n\n#### --tls_cert_path\n\nWhere the tls client cert is located.\n\n#### --tls_key_path\n\nWhere the tls key is located.\n\n#### --tls_ca_path\n\nWhere the tls ca is located.\n\n#### --tls_server_name\n\nThe name of the Db tls server.\n\n#### --tls_disable_host_verification\n\nDisables verification of the DB tls hostname and server cert.\n","is_empty":false},{"file_name":"admin/cluster/add-search-attributes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/cluster/add-search-attributes.md","id":"tctl-v1/admin/cluster/add-search-attributes","title":"tctl admin cluster add_search_attributes","description":"Adding custom Search Attributes to a Cluster.","label":"add_search_attributes","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin cluster add-search-attributes` command allows Search Attributes to be added to a Cluster.\nCustom Search Attributes can be used to make a Cluster more identifiable.\n\n:::note\nDue to Elasticsearch limitations, you can only add new custom Search Attributes. Existing Search Attributes cannot be renamed or removed from the Elasticsearch index.\n:::\n\nUse this command to add custom Search Attributes to your Temporal Cluster:\n\n```bash\ntctl admin cluster add-search-attributes --name <SearchAttributeName> --type <SearchAttributeValueType>\n```\n\n:::note\nIf you are adding custom Search Attributes to a Cluster running from the `docker-compose-es.yml` file in the [temporalio/docker-compose](https://github.com/temporalio/docker-compose) repo, make sure to increase the Docker memory to more than 6 GB.\n:::\n\n#### --skip_schema_update\n\nAllows the user to skip the Elasticsearch index schema update.\n\n:::note\nThis will only register in metadata.\n:::\n\n#### --name\n\nThe name of the Search Attribute to add. Names can have multiple values.\n\nSearch Attribute names are case sensitive.\n\n#### --type\n\nThe type of Search Attribute to add.\nMultiple values can be added at once.\n\nValues: Text, Keyword, Int, Double, Bool, Datetime\n","is_empty":false},{"file_name":"admin/cluster/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/cluster/describe.md","id":"tctl-v1/admin/cluster/describe","title":"tctl admin cluster describe","description":"Displaying Cluster information.","label":"describe","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin cluster describe` command provides information for the current Cluster.\n\nThe following modifier changes the behavior of the command:\n\n#### --cluster_value\n\nThe name of the remote Cluster within the current Cluster.\n\nThis modifier is optional, and can default to the return of current Cluster information.\n","is_empty":false},{"file_name":"admin/cluster/get-search-attributes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/cluster/get-search-attributes.md","id":"tctl-v1/admin/cluster/get-search-attributes","title":"tctl admin cluster get_search_attributes","description":"Showing existing search attributes.","label":"get_search_attributes","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin cluster get_search_attributes` command retrieves existing Search Attributes for a given Cluster.\n\nThe following modifier will change the behavior of the command:\n\n#### --print_json\n\nPrints the existing search attributes in JSON format.\n","is_empty":false},{"file_name":"admin/cluster/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/cluster/index.md","id":"tctl-v1/admin/cluster/index","title":"tctl admin cluster","description":"Running admin-level operations on clusters.","label":"cluster","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin cluster` command runs the administrator-level operations on a given Cluster.\n\n`tctl admin cluster command [command modifiers] [arguments...]`\n\n- [add_search_attributes](/tctl-v1/admin/cluster/add-search-attributes)\n- [remove_search_attributes](/tctl-v1/admin/cluster/remove-search-attributes)\n- [get_search_attributes](/tctl-v1/admin/cluster/get-search-attributes)\n- [describe](/tctl-v1/admin/cluster/describe)\n- [list](/tctl-v1/admin/cluster/list)\n- [upsert_remote_cluster](/tctl-v1/admin/cluster/upsert-remote-cluster)\n- [remove_remote_cluster](/tctl-v1/admin/cluster/upsert-remote-cluster)\n","is_empty":false},{"file_name":"admin/cluster/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/cluster/list.md","id":"tctl-v1/admin/cluster/list","title":"tctl admin cluster list","description":"Listing Cluster information.","label":"list","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin cluster list` command lists Cluster information on the given Cluster.\n\nDefault: 100\n\nThe modifier below changes the behavior of the command:\n\n#### --pagesize\n\nThe size of the page that the list is printed on.\n","is_empty":false},{"file_name":"admin/cluster/remove-remote-cluster.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/cluster/remove-remote-cluster.md","id":"tctl-v1/admin/cluster/remove-remote-cluster","title":"tctl admin cluster remove_remote_cluster","description":"Removing remote Clusters.","label":"remove_remote_cluster","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin cluster remove_remote_cluster` command removes remote Cluster information on the given Cluster.\n\nThe modifier below changes the behavior of the operation:\n\n#### --cluster\n\nThe name of the remote Cluster to remove.\n","is_empty":false},{"file_name":"admin/cluster/remove-search-attributes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/cluster/remove-search-attributes.md","id":"tctl-v1/admin/cluster/remove-search-attributes","title":"tctl admin cluster remove_search_attributes","description":"Removing custom search metadat from a Cluster.","label":"remove_search_attributes","tags":["tctl","admin"],"markdown_content":"\n> The Temporal tctl documentation covers version 1.17 of the Temporal CLI.\n\nThe `tctl admin cluster remove-search-attributes` command removes custom Search Attribute metadata from a Cluster.\nThis operation has no effect on Elasticsearch index schema.\n\nUse the following command to remove a [Search Attribute](/concepts/what-is-a-search-attribute) from a Cluster's metadata:\n\n```bash\ntctl admin cluster remove-search-attributes --name <SearchAttributeKey>\n```\n\nOnly custom Search Attributes can be removed from a Cluster's metadata.\nDefault Search Attributes cannot be removed.\n\nRemoving a Search Attribute removes it from the Cluster's metadata but does not remove it from the Elasticsearch index.\nThis means that the Search Attribute can be added back later as the same type.\nAfter a Search Attribute has been added to the Elasticsearch index, it cannot be changed.\n\nThe following modifier changes the behavior of the operation:\n\n#### --name\n\nName of the Search Attribute to remove.\n","is_empty":false},{"file_name":"admin/cluster/upsert-remote-cluster.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/admin/cluster/upsert-remote-cluster.md","id":"tctl-v1/admin/cluster/upsert-remote-cluster","title":"tctl admin cluster upsert_remote_cluster","description":"How to run admin-level tctl commands.","label":"upsert_remote_cluster","tags":["tctl","admin"],"markdown_content":"\nThe `tctl admin cluster upsert_remote_cluster` command adds or updates remote Cluster information in the current Cluster.\n\n#### --frontend_address\n\nThe remote Cluster frontend address.\n\n#### --enable_connection\n\nEnables remote Cluster connection.\n","is_empty":false},{"file_name":"activity/complete.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/activity/complete.md","id":"tctl-v1/activity/complete","title":"tctl activity complete","description":"How to provide a result and complete an Activity Execution using tctl.","label":"complete","tags":["tctl"],"markdown_content":"\nThe `tctl activity complete` command completes an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n`tctl activity complete <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify the [Workflow Id](/concepts/what-is-a-workflow-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to complete.\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl activity complete --workflow_id <id>\n```\n\n### --run_id\n\nSpecify the [Run Id](/concepts/what-is-a-run-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to complete.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl activity complete --run_id <id>\n```\n\n### --activity_id\n\nSpecify the [Activity Id](/concepts/what-is-an-activity-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to complete.\n\n**Example**\n\n```bash\ntctl activity complete --activity_id <id>\n```\n\n### --result\n\nSpecify the result of an [Activity Execution](/concepts/what-is-an-activity-execution) when using tctl to complete the Activity Execution.\n\n**Example**\n\n```bash\ntctl activity complete --result <value>\n```\n\n### --identity\n\nSpecify the identity of the operator when using tctl to complete an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n**Example**\n\n```bash\ntctl activity complete --identity <value>\n```\n","is_empty":false},{"file_name":"activity/fail.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/activity/fail.md","id":"tctl-v1/activity/fail","title":"tctl activity fail","description":"How to fail an Activity Execution using tctl.","label":"fail","tags":["tctl"],"markdown_content":"\nThe `tctl activity fail` command fails an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n`tctl activity fail [<modifiers>]`\n\nThe following modifiers control the behavior of the command.\n\n### --workflow_id\n\nSpecify the [Workflow Id](/concepts/what-is-a-workflow-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to fail.\n\nAlias: `-w`\n\n**Example**\n\n```bash\ntctl activity fail --workflow_id <id>\n```\n\n### --run_id\n\nSpecify the [Run Id](/concepts/what-is-a-run-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to fail.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntctl activity fail --run_id <id>\n```\n\n### --activity_id\n\nSpecify the [Activity Id](/concepts/what-is-an-activity-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to fail.\n\n**Example**\n\n```bash\ntctl activity fail --activity_id <id>\n```\n\n### --reason\n\nSpecify the reason for failing an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n**Example**\n\n```bash\ntctl activity fail --reason <value>\n```\n\n### --detail\n\nSpecify details of the reason for failing an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n**Example**\n\n```bash\ntctl activity fail --detail <value>\n```\n\n### --identity\n\nSpecify the identity of the operator when using tctl to fail an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n**Example**\n\n```bash\ntctl activity complete --identity <value>\n```\n","is_empty":false},{"file_name":"activity/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-v1/activity/index.md","id":"tctl-v1/activity/index","title":"tctl activity","description":"How to operate Activity Executions using tctl.","label":"activity","tags":["tctl"],"markdown_content":"\nThe `tctl activity` commands enable [Activity Execution](/concepts/what-is-an-activity-execution) operations.\n\n- [tctl activity complete](/tctl-v1/activity/complete)\n- [tctl activity fail](/tctl-v1/activity/fail)\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/environment-variables.md","id":"tctl-next/environment-variables","title":"Environment variables for tctl","description":"What are the environment variables for tctl?","label":"Environment variables","tags":["tctl"],"markdown_content":"\nSetting environment variables for repeated parameters can shorten tctl commands.\n\n### TEMPORAL_CLI_ADDRESS\n\nSpecify a host and port for the Frontend Service.\nThe default is `127.0.0.1:7233`.\n\n### TEMPORAL_CLI_AUTH\n\nSpecify the authorization header to be set for a gRPC request.\n\n### TEMPORAL_CLI_AUTHORIZATION_TOKEN\n\nSpecify a token to be used by the HTTP Basic Authorization plugin.\n\n<!-- TODO: Add link to \"Securing tctl\" page or its equivalent when it exists. -->\n\n### TEMPORAL_CLI_NAMESPACE\n\nSpecify a Namespace.\nBy setting this variable, you don't need to specify a `--namespace` modifier in a tctl command.\nThe default Namespace is `default`.\n\n### TEMPORAL_CLI_PLUGIN_DATA_CONVERTER\n\nSpecify the name of the executable for a custom Data Converter plugin.\n\n### TEMPORAL_CLI_PLUGIN_HEADERS_PROVIDER\n\nSpecify the name of the executable for a headers provider plugin.\n\n### TEMPORAL_CLI_TLS_CA\n\nSpecify the path to a server Certificate Authority (CA) certificate file.\n\n### TEMPORAL_CLI_TLS_CERT\n\nSpecify the path to a public X.509 certificate file for mutual TLS authentication.\n\n### TEMPORAL_CLI_TLS_DISABLE_HOST_VERIFICATION\n\nSet to disable verification of the server certificate (and thus host verification).\n\n### TEMPORAL_CLI_TLS_KEY\n\nSpecify the path to a private key file for mutual TLS authentication.\nIf you set this variable, you must also set the `TEMPORAL_CLI_TLS_CERT` variable.\n\n### TEMPORAL_CLI_TLS_SERVER_NAME\n\nSpecify an override for the name of the target server that is used for TLS host verification.\nThe name must be one of the DNS names listed in the server TLS certificate.\nSetting this variable also enables host verification.\n\n### TEMPORAL_CONTEXT_TIMEOUT\n\nSpecify a timeout for the context of an RPC call in seconds.\nThe default value is 5.\n","is_empty":false},{"file_name":"global-modifiers.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/global-modifiers.md","id":"tctl-next/global-modifiers","title":"tctl v2.0.0-beta global modifiers","description":"Global modifiers are provided before command modifiers.","label":"Global modifiers","tags":["tctl"],"markdown_content":"\nGlobal modifiers are provided after `tctl` in the command structure but before the commands themselves.\nFor example:\n\n```\ntctl --address <value> workflow start --task-queue <value> ...\n```\n\nYou can supply the values for many of these modifiers by setting [environment variables](/tctl-next/environment-variables) instead of including the modifiers in each tctl command.\n\n### --address\n\nSpecify a host and port for the Frontend Service.\nThe default is `127.0.0.1:7233`.\n\nAlias: `--ad`\n\n### --auto-confirm\n\nAutomatically confirm all prompts.\n\n### --context-timeout\n\nSpecify a timeout for the context of an RPC call in seconds.\nThe default value is 5.\n\nAlias: `--ct`\n\n### --data-converter-plugin\n\nSpecify the name of the executable for a custom Data Converter plugin.\n\nAlias: `--dcp`\n\n### --headers-provider-plugin\n\nSpecify the name of the executable for a headers provider plugin.\n\nAlias: `--hpp`\n\n### --help\n\nDisplay help for tctl in the CLI.\n\nAlias: `-h`\n\n### --namespace\n\nSpecify a Namespace.\nBy using this modifier, you don't need to specify a `--namespace` modifier for a sub-command.\nThe default Namespace is `default`.\n\nAlias: `--ns`\n\n### --tls-ca-path\n\nSpecify the path to a server Certificate Authority (CA) certificate file.\n\n### --tls-cert-path\n\nSpecify the path to a public X.509 certificate file for mutual TLS authentication.\nIf you use this modifier, you must also use the `--tls-key-path` modifier.\n\n### --tls-disable-host-verification\n\nDisable verification of the server certificate (and thus host verification).\n\n### --tls-key-path\n\nSpecify the path to a private key file for mutual TLS authentication.\nIf you use this modifier, you must also use the `--tls-cert-path` modifier.\n\n### --tls-server-name\n\nSpecify an override for the name of the target server that is used for TLS host verification.\nThe name must be one of the DNS names listed in the server TLS certificate.\nSpecifying this modifier also enables host verification.\n\n### --version\n\nDisplay the version of tctl in the CLI.\n\nAlias: `-v`\n\n### --codec-endpoint\n\nThe URL and port number for a Codec Server.\n","is_empty":false},{"file_name":"how-to-install-tctl.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/how-to-install-tctl.md","id":"tctl-next/how-to-install-tctl","title":"How to install tctl","description":"You can install tctl in four ways, described in this topic.","label":"Install","tags":["tctl"],"markdown_content":"\nFollow the [steps in the tctl README](https://github.com/temporalio/tctl#trying-out-new-tctl-v200-beta-with-updated-ux) to use the next version of tctl (currently tctl v2.0.0-beta).\n","is_empty":false},{"file_name":"workflow/cancel.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/cancel.md","id":"tctl-next/workflow/cancel","title":"tctl workflow cancel","description":"How to cancel a Workflow Execution using tctl.","label":"cancel","tags":["tctl"],"markdown_content":"\nThe `tctl workflow cancel` command cancels a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nCanceling a running Workflow Execution records a `WorkflowExecutionCancelRequested` event in the History.\nA new command task will be scheduled.\nAfter cancellation, the Workflow Execution can perform cleanup work.\n\nThe use of the [`--query` modifier](/tctl-next/modifiers#--query) (`tctl workflow cancel --query`) automatically starts a [batch job](/tctl-next/batch) that cancels Workflow Executions according to the List Filter provided.\n\n`tctl workflow cancel --query <value> <modifiers>`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--namespace](/tctl-next/modifiers#--namespace)\n- [--query](/tctl-next/modifiers#--query)\n- [--reason](/tctl-next/modifiers#--reason)\n- [--yes](/tctl-next/modifiers#--yes)\n\nSee also [`tctl workflow terminate`](/tctl-next/workflow#terminate).\n","is_empty":false},{"file_name":"workflow/count.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/count.md","id":"tctl-next/workflow/count","title":"tctl workflow count","description":"How to count Workflow Executions using tctl.","label":"count","tags":["tctl"],"markdown_content":"\nThe `tctl workflow count` command counts [Workflow Executions](/concepts/what-is-a-workflow-execution).\nThis command requires Elasticsearch to be enabled.\n\n`tctl workflow count <modifiers>`\n\nThe following modifier controls the behavior of the command.\n\n- [--query](/tctl-next/modifiers#--query)\n\n**Example**\n\n```bash\ntctl workflow count --query 'ExecutionStatus=\"Running\"'\n```\n","is_empty":false},{"file_name":"workflow/delete.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/delete.md","id":"tctl-next/workflow/delete","title":"tctl workflow delete","description":"Delete a Workflow using tctl.","label":"delete","tags":["tctl"],"markdown_content":"\nThe `tctl workflow delete` command deletes a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\n`tctl workflow delete`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--namespace](/tctl-next/modifiers#--namespace)\n- [--run-id](/tctl-next/modifiers#--run-id)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n","is_empty":false},{"file_name":"workflow/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/describe.md","id":"tctl-next/workflow/describe","title":"tctl workflow describe","description":"How to show information about a Workflow Execution using tctl.","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl workflow describe` command shows information about a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nThis information can be used to locate a failed Workflow Execution, for example.\n\n`tctl workflow describe <modifiers>`\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--raw](/tctl-next/modifiers#--raw)\n- [--reset-points-only](/tctl-next/modifiers#--reset-points-only)\n- [--run-id](/tctl-next/modifiers#--run-id)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n","is_empty":false},{"file_name":"workflow/execute.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/execute.md","id":"tctl-next/workflow/execute","title":"tctl workflow execute","description":"How to start a new Workflow Execution and get Workflow progress using tctl.","label":"execute","tags":["tctl"],"markdown_content":"\nThe `tctl workflow execute` command starts a new [Workflow Execution](/concepts/what-is-a-workflow-execution) and shows its progress until completion.\n\nThe command is entered in the following format:\n\n`tctl workflow execute [modifiers]`\n\nSingle quotes (`''`) are used to wrap input as JSON.\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--cron](/tctl-next/modifiers#--cron)\n- [--execution-timeout](/tctl-next/modifiers#--execution-timeout)\n- [--fields](/tctl-next/modifiers#--fields)\n- [--input](/tctl-next/modifiers#--input)\n- [--input-file](/tctl-next/modifiers#--input-file)\n- [--limit](/tctl-next/modifiers#--limit)\n- [--max-field-length](/tctl-next/modifiers#--max-field-length)\n- [--memo-key](/tctl-next/modifiers#--memo-key)\n- [--memo](/tctl-next/modifiers#--memo)\n- [--memo-file](/tctl-next/modifiers#--memo-file)\n- [--no-pager](/tctl-next/modifiers#--no-pager)\n- [--output](/tctl-next/modifiers#--output)\n- [--pager](/tctl-next/modifiers#--pager)\n- [--search-attribute-key](/tctl-next/modifiers#--search-attribute-key)\n- [--search-attribute-value](/tctl-next/modifiers#--search-attribute-value)\n- [--task-queue](/tctl-next/modifiers#--task-queue)\n- [--task-timeout](/tctl-next/modifiers#--task-timeout)\n- [--time-format](/tctl-next/modifiers#--time-format)\n- [--type](/tctl-next/modifiers#--type)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n- [--workflow-id-reuse-policy](/tctl-next/modifiers#--workflow-id-reuse-policy)\n","is_empty":false},{"file_name":"workflow/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/index.md","id":"tctl-next/workflow/index","title":"tctl workflow","description":"How to operate Workflow Executions using tctl.","label":"workflow","tags":["tctl"],"markdown_content":"\nThe `tctl workflow` commands enable [Workflow Execution](/concepts/what-is-a-workflow-execution) operations.\n\n- [tctl workflow cancel](/tctl-next/workflow#cancel)\n- [tctl workflow count](/tctl-next/workflow#count)\n- [tctl workflow describe](/tctl-next/workflow#describe)\n- [tctl workflow list](/tctl-next/workflow#list)\n- [tctl workflow query](/tctl-next/workflow#query)\n- [tctl workflow reset](/tctl-next/workflow#reset)\n- [tctl workflow reset-batch](/tctl-next/workflow#reset-batch)\n- [tctl workflow scan](/tctl-next/workflow#scan)\n- [tctl workflow show](/tctl-next/workflow#show)\n- [tctl workflow signal](/tctl-next/workflow#signal)\n- [tctl workflow stack](/tctl-next/workflow#stack)\n- [tctl workflow start](/tctl-next/workflow#start)\n- [tctl workflow terminate](/tctl-next/workflow#terminate)\n","is_empty":false},{"file_name":"workflow/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/list.md","id":"tctl-next/workflow/list","title":"tctl workflow list","description":"How to list open or closed Workflow Executions using tctl.","label":"list","tags":["tctl"],"markdown_content":"\nThe `tctl workflow list` command lists open or closed [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\nBy default, this command lists a maximum of 10 closed Workflow Executions.\n\n- To set the number of items printed, use the `--limit` option.\n- To specify fields to print, use the `--fields` option.\n- To enable or disable a pager, use `--pager <value>` or `--no-pager`.\n\n`tctl workflow list <modifiers>`\n\nThe following modifiers are supported and control the behavior of the command.\n\n- [--archived](/tctl-next/modifiers#--archived)\n- [--fields](/tctl-next/modifiers#--fields)\n- [--limit](/tctl-next/modifiers#--limit)\n- [--no-pager](/tctl-next/modifiers#--no-pager)\n- [--output](/tctl-next/modifiers#--output)\n- [--pager](/tctl-next/modifiers#--pager)\n- [--query](/tctl-next/modifiers#--query)\n- [--time-format](/tctl-next/modifiers#--time-format)\n\n**Examples**\n\nList all Workflows with the given WorkflowId or RunId:\n\n```bash\ntctl workflow list \\\n  --query 'WorkflowType = \"main.Workflow\" and (WorkflowId = \"1645a588-4772-4dab-b276-5f9db108b3a8\" or RunId = \"be66519b-5f09-40cd-b2e8-20e4106244dc\")'\n```\n\nList all open Workflows that started at a given time:\n\n```bash\ntctl workflow list \\\n  --query 'WorkflowType = \"main.Workflow\" StartTime > \"2019-06-07T16:46:34-08:00\" and ExecutionStatus = \"Running\"'\n```\n","is_empty":false},{"file_name":"workflow/query.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/query.md","id":"tctl-next/workflow/query","title":"tctl workflow query","description":"How to send a Query to a Workflow Execution using tctl.","label":"query","tags":["tctl"],"markdown_content":"\nThe `tctl workflow query` command sends a [Query](/concepts/what-is-a-query) to a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nQueries can be used to retrieve all or part of the Workflow state with given parameters.\n\n```bash\n$ tctl workflow query --workflow-id \"HelloQuery\" --query-type \"getCount\"\nQuery result as JSON:\n3\n```\n\nQueries can also be used on completed Workflows.\nLet's complete a Workflow by updating its greeting, and then query the now-finished Workflow.\n\n```bash\n$ tctl workflow signal --workflow-id \"HelloQuery\" --name \"updateGreeting\" --input \\\"Bye\\\"\nSignal workflow succeeded.\n$ tctl workflow query --workflow-id \"HelloQuery\" --query-type \"getCount\"\nQuery result as JSON:\n4\n```\n\nQueries are written as follows:\n\n`tctl workflow query --workflow-id [modifiers]`\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--input](/tctl-next/modifiers#--input)\n- [--input-file](/tctl-next/modifiers#--input-file)\n- [--query-reject-condition](/tctl-next/modifiers#--query-reject-condition)\n- [--query-type](/tctl-next/modifiers#--query-type)\n- [--run-id](/tctl-next/modifiers#--run-id)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n","is_empty":false},{"file_name":"workflow/reset-batch.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/reset-batch.md","id":"tctl-next/workflow/reset-batch","title":"tctl workflow reset-batch","description":"How to reset a batch of Workflow Executions using tctl.","label":"reset-batch","tags":["tctl"],"markdown_content":"\nThe `tctl workflow reset-batch` command resets a batch of [Workflow Executions](/concepts/what-is-a-workflow-execution) by [`resetType`](#resettype).\n\nResetting a Workflow allows the process to be resumed from a certain point without losing your parameters or Event History.\n\n`tctl workflow reset-batch <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n- [--dry-run](/tctl-next/modifiers#--dry-run)\n- [--exclude-file](/tctl-next/modifiers#--exclude-file)\n- [--input-file](/tctl-next/modifiers#--input-file)\n- [--input-parallelism](/tctl-next/modifiers#--input-parallelism)\n- [--non-deterministic](/tctl-next/modifiers#--non-deterministic)\n- [--query](/tctl-next/modifiers#--query)\n- [--reason](/tctl-next/modifiers#--reason)\n- [--reset-bad-binary-checksum](/tctl-next/modifiers#--reset-bad-binary-checksum)\n- [--reset-type](/tctl-next/modifiers#--reset-type)\n- [--skip-current-open](/tctl-next/modifiers#--skip-current-open)\n- [--skip-base-not-current](/tctl-next/modifiers#--skip-base-is-not-current)\n","is_empty":false},{"file_name":"workflow/reset.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/reset.md","id":"tctl-next/workflow/reset","title":"tctl workflow reset","description":"How to reset a Workflow Execution using tctl.","label":"reset","tags":["tctl"],"markdown_content":"\nThe `tctl workflow reset` command resets a [Workflow Execution](/concepts/what-is-a-workflow-execution) by either [`eventId`](#eventid)or [`resetType`](#resettype).\n\nResetting a Workflow allows the process to be resumed from a certain point without losing your parameters or Event History.\n\n`tctl workflow reset <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n- [--event-id](/tctl-next/modifiers#--event-id)\n- [--reason](/tctl-next/modifiers#--reason)\n- [--reset-type](/tctl-next/modifiers#--reset-type)\n- [--reset-reapply-type](/tctl-next/modifiers#--reset-reapply-type)\n- [--reset-bad-binary-checksum](/tctl-next/modifiers#--reset-bad-binary-checksum)\n- [--run-id](/tctl-next/modifiers#--run-id)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n","is_empty":false},{"file_name":"workflow/scan.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/scan.md","id":"tctl-next/workflow/scan","title":"tctl workflow scan","description":"How to quickly list Workflow Executions without sorting using tctl.","label":"scan","tags":["tctl"],"markdown_content":"\nThe `tctl workflow scan` command lists [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\nBy default, this command lists a maximum of 2000 Workflow Executions.\nTo set the size of a page, use the `--pagesize` option.\n\nSee also [`tctl workflow list`](/tctl-next/workflow#list).\n\n`tctl workflow scan <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n- [--fields](/tctl-next/modifiers#--fields)\n- [--limit](/tctl-next/modifiers#--limit)\n- [--no-pager](/tctl-next/modifiers#--no-pager)\n- [--output](/tctl-next/modifiers#--output)\n- [--pager](/tctl-next/modifiers#--pager)\n- [--query](/tctl-next/modifiers#--query)\n- [--time-format](/tctl-next/modifiers#--time-format)\n","is_empty":false},{"file_name":"workflow/show.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/show.md","id":"tctl-next/workflow/show","title":"tctl workflow show","description":"How to show Workflow History using tctl.","label":"show","tags":["tctl"],"markdown_content":"\nThe `tctl workflow show` command shows the [Event History](/concepts/what-is-an-event-history) for the specified [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\n`tctl workflow show <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n- [--fields](/tctl-next/modifiers#--fields)\n- [--follow](/tctl-next/modifiers#--follow)\n- [--limit](/tctl-next/modifiers#--limit)\n- [--max-field-length](/tctl-next/modifiers#--max-field-length)\n- [--no-pager](/tctl-next/modifiers#--no-pager)\n- [--output](/tctl-next/modifiers#--output)\n- [--output-filename](/tctl-next/modifiers#--output-filename)\n- [--pager](/tctl-next/modifiers#--pager)\n- [--reset-points-only](/tctl-next/modifiers#--reset-points-only)\n- [--run-id](/tctl-next/modifiers#--run-id)\n- [--time-format](/tctl-next/modifiers#--time-format)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n","is_empty":false},{"file_name":"workflow/signal.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/signal.md","id":"tctl-next/workflow/signal","title":"tctl workflow signal","description":"How to Signal a Workflow Execution using tctl.","label":"signal","tags":["tctl"],"markdown_content":"\nThe `tctl workflow signal` command [Signals](/concepts/what-is-a-signal) a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nThe use of the [`--query` modifier](/tctl-next/modifiers#--query) (`tctl workflow signal --query ...`) starts a [batch job](/tctl-next/batch) that sends a Signal to the Workflow Executions according to the List Filter provided.\n\n`tctl workflow signal --query <value> <modifiers>`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--namespace](/tctl-next/modifiers#--namespace)\n- [--name](/tctl-next/modifiers#--name)\n- [--input](/tctl-next/modifiers#--input)\n- [--query](/tctl-next/modifiers#--query)\n- [--reason](/tctl-next/modifiers#--reason)\n- [--yes](/tctl-next/modifiers#--yes)\n","is_empty":false},{"file_name":"workflow/stack.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/stack.md","id":"tctl-next/workflow/stack","title":"tctl workflow stack","description":"How to query Workflow Executions with --stack-trace using tctl.","label":"stack","tags":["tctl"],"markdown_content":"\nThe `tctl workflow stack` command queries [Workflow Execution](/concepts/what-is-a-workflow-execution) with `--stack-trace` as the query type.\n\n`tctl workflow stack <modifiers>`\n\nThe following modifiers control the behavior of the command.\n\n- [--input](/tctl-next/modifiers#--input)\n- [--input-file](/tctl-next/modifiers#--input-file)\n- [--query-reject-condition](/tctl-next/modifiers#--query-reject-condition)\n- [--run-id](/tctl-next/modifiers#--run-id)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n","is_empty":false},{"file_name":"workflow/start.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/start.md","id":"tctl-next/workflow/start","title":"tctl workflow start","description":"How to start a new Workflow Execution using tctl.","label":"start","tags":["tctl"],"markdown_content":"\nThe `tctl workflow start` command starts a new [Workflow Execution](/concepts/what-is-a-workflow-execution).\nThis command returns the Workflow Id and Run Id immediately after starting the Workflow.\n\n`tctl workflow start <modifiers>`\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--cron](/tctl-next/modifiers#--cron)\n- [--execution-timeout](/tctl-next/modifiers#--execution-timeout)\n- [--fields](/tctl-next/modifiers#--fields)\n- [--input](/tctl-next/modifiers#--input)\n- [--input-file](/tctl-next/modifiers#--input-file)\n- [--limit](/tctl-next/modifiers#--limit)\n- [--max-field-length](/tctl-next/modifiers#--max-field-length)\n- [--memo-key](/tctl-next/modifiers#--memo-key)\n- [--memo](/tctl-next/modifiers#--memo)\n- [--memo-file](/tctl-next/modifiers#--memo-file)\n- [--no-pager](/tctl-next/modifiers#--no-pager)\n- [--output](/tctl-next/modifiers#--output)\n- [--pager](/tctl-next/modifiers#--pager)\n- [--run-timeout](/tctl-next/modifiers#--run-timeout)\n- [--search-attribute-key](/tctl-next/modifiers#--search-attribute-key)\n- [--search-attribute-value](/tctl-next/modifiers#--search-attribute-value)\n- [--task-queue](/tctl-next/modifiers#--task-queue)\n- [--task-timeout](/tctl-next/modifiers#--task-timeout)\n- [--time-format](/tctl-next/modifiers#--time-format)\n- [--type](/tctl-next/modifiers#--type)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n- [--workflow-task-timeout](/tctl-next/modifiers#--workflow-task-timeout)\n- [--workflow-id-reuse-policy](/tctl-next/modifiers#--workflow-id-reuse-policy)\n","is_empty":false},{"file_name":"workflow/terminate.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/workflow/terminate.md","id":"tctl-next/workflow/terminate","title":"tctl workflow terminate","description":"How to terminate a Workflow Execution using tctl.","label":"terminate","tags":["tctl"],"markdown_content":"\nThe `tctl workflow terminate` command terminates a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nIf `run_id` is not specified, the command terminates the last Workflow Execution with the specified `workflow_id`.\n\nTerminating a running Workflow Execution records a `WorkflowExecutionTerminated` event as the closing event in the History.\nNo more command tasks will be scheduled.\n\nSee also [`tctl workflow cancel`](/tctl-next/workflow#cancel).\n\nThe use of the [`--query` modifier](/tctl-next/modifiers#--query) (`tctl workflow terminate --query ...`) automatically starts a [batch job](/tctl-next/batch) that Terminates Workflow Executions according to the List Filter provided.\n\n`tctl workflow terminate --query <value> <modifiers>`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--namespace](/tctl-next/modifiers#--namespace)\n- [--query](/tctl-next/modifiers#--query)\n- [--reason](/tctl-next/modifiers#--reason)\n- [--run-id](/tctl-next/modifiers#--run-id)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n- [--yes](/tctl-next/modifiers#--yes)\n","is_empty":false},{"file_name":"task-queue/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/task-queue/describe.md","id":"tctl-next/task-queue/describe","title":"tctl task-queue describe","description":"How to describe the Workers that have recently polled on a Task Queue using tctl.","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl task-queue describe` command describes the poller information of a [Task Queue](/concepts/what-is-a-task-queue).\n\n`tctl task-queue describe <modifiers>`\n\nThe Server records the last time a Worker sent a poll request.\nPoll requests can last up to a minute, so a `LastAccessTime` less than a minute ago is normal.\nIf it's over a minute ago, then likely either the Worker is at capacity (all Workflow and Activity slots are full) or it has shut down.\nOnce it has been 5 minutes since the last poll request, the Worker will no longer appear on the list.\n\nThe following modifiers are supported and control the behavior of the command.\n`--task-queue` is required.\n\n- [--fields](/tctl-next/modifiers#--fields)\n- [--namespace](/tctl-next/modifiers#--namespace)\n- [--output](/tctl-next/modifiers#--output)\n- [--task-queue](/tctl-next/modifiers#--task-queue)\n- [--task-queue-type](/tctl-next/modifiers#--task-queue-type)\n- [--time-format](/tctl-next/modifiers#--time-format)\n","is_empty":false},{"file_name":"task-queue/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/task-queue/index.md","id":"tctl-next/task-queue/index","title":"tctl task-queue","description":"How to operate Task Queues using tctl.","label":"task-queue","tags":["tctl"],"markdown_content":"\nThe `tctl task-queue` commands enable [Task Queue](/concepts/what-is-a-task-queue) operations.\n\nAlias: `tq`\n\n- [tctl task-queue describe](/tctl-next/task-queue#describe)\n- [tctl task-queue list-partition](/tctl-next/task-queue#list-partition)\n","is_empty":false},{"file_name":"task-queue/list-partition.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/task-queue/list-partition.md","id":"tctl-next/task-queue/list-partition","title":"tctl task-queue list-partition","description":"How to list Task Queue partitions and the hostname for partitions using tctl.","label":"list-partition","tags":["tctl"],"markdown_content":"\nThe `tctl task-queue list-partition` command lists the partitions of a [Task Queue](/concepts/what-is-a-task-queue) and the hostname for the partitions.\n\n`tctl task-queue list-partition --task-queue <value>`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--namespace](/tctl-next/modifiers#--namespace)\n- [--output](/tctl-next/modifiers#--output)\n- [--task-queue](/tctl-next/modifiers#--task-queue)\n","is_empty":false},{"file_name":"search-attribute/create.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/search-attribute/create.md","id":"tctl-next/search-attribute/create","title":"tctl search-attribute create","description":"How to create Search Attributes using tctl.","label":"create","tags":["tctl"],"markdown_content":"\nThe `tctl search-attribute create` command adds one or more custom Search Attributes.\n\n```bash\ntctl search-attribute create \\\n    --yes \\\n    --name CustomKeywordField --type Keyword \\\n    --name CustomStringField --type Text \\\n    --name CustomTextField --type Text \\\n    --name CustomIntField --type Int \\\n    --name CustomDatetimeField --type Datetime \\\n    --name CustomDoubleField --type Double \\\n    --name CustomBoolField --type Bool \\\n    --name SimulatedFailure --type Bool\n```\n","is_empty":false},{"file_name":"search-attribute/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/search-attribute/index.md","id":"tctl-next/search-attribute/index","title":"tctl search-attribute","description":"How to operate Search Attributes using tctl.","label":"search-attribute","tags":["tctl"],"markdown_content":"\nThe `tctl search-attribute` command enables [Search Attribute](/concepts/what-is-a-search-attribute) operations.\n\n- [tctl search-attribute create](/tctl-next/search-attribute/create)\n- [tctl search-attribute list](/tctl-next/search-attribute/list)\n- [tctl search-attribute remove](/tctl-next/search-attribute/remove)\n","is_empty":false},{"file_name":"search-attribute/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/search-attribute/list.md","id":"tctl-next/search-attribute/list","title":"tctl search-attribute list","description":"How to list Search Attributes using tctl.","label":"list","tags":["tctl"],"markdown_content":"\nThe `tctl search-attribute list` command lists all [Search Attributes](/concepts/what-is-a-search-attribute) that can be used in the `--query` modifier of the [`tctl workflow list`](/tctl-next/workflow/list) command.\n\n**Example:**\n\n```bash\ntctl search-attribute list\n```\n\nThe command has no modifiers.\n\nExample output:\n\n```text\n           Name               Type\nBatcherNamespace            Keyword\nBatcherUser                 Keyword\nBinaryChecksums             Keyword\nCloseTime                   Datetime\nCustomBoolField             Bool\nCustomDatetimeField         Datetime\nCustomDoubleField           Double\nCustomIntField              Int\nCustomKeywordField          Keyword\nCustomStringField           Text\nCustomTextField             Text\nExecutionDuration           Int\nExecutionStatus             Keyword\nExecutionTime               Datetime\nHistoryLength               Int\nRunId                       Keyword\nStartTime                   Datetime\nStateTransitionCount        Int\nTaskQueue                   Keyword\nTemporalChangeVersion       Keyword\nTemporalNamespaceDivision   Keyword\nTemporalSchedulePaused      Bool\nTemporalScheduledById       Keyword\nTemporalScheduledStartTime  Datetime\nWorkflowId                  Keyword\nWorkflowType                Keyword\n```\n","is_empty":false},{"file_name":"search-attribute/remove.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/search-attribute/remove.md","id":"tctl-next/search-attribute/remove","title":"tctl search-attribute remove","description":"How to remove Search Attributes using tctl.","label":"remove","tags":["tctl"],"markdown_content":"\nThe `tctl search-attribute remove` command removes a Search Attribute.\n\nThe following modifiers control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--name](/tctl-next/modifiers/name)\n- [--yes](/tctl-next/modifiers/yes)\n","is_empty":false},{"file_name":"schedule/backfill.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/schedule/backfill.md","id":"tctl-next/schedule/backfill","title":"tctl schedule backfill","description":"How to backfill a Schedule using tctl.","label":"backfill","tags":["tctl"],"markdown_content":"\nBackfilling a Schedule means having it do now what it would have done over a specified time range (generally in the past, although it won't prevent you from giving a time range in the future).\nYou might use this to fill in runs from a time period when the Schedule was paused due to an external condition that's now resolved, or a period before the Schedule was created.\n\n```shell\ntctl schedule backfill --sid 'your-schedule-id' \\\n  --overlap-policy 'BufferAll'                \\\n  --start-time '2022-05-01T00:00:00Z'         \\\n  --end-time   '2022-05-31T23:59:59Z'\n```\n\nNote that, similar to [tctl schedule trigger](/tctl-next/schedule#trigger) immediately, you probably want to override the Overlap Policy.\nSpecifying `AllowAll` runs all the backfilled Workflows at once; `BufferAll` runs them sequentially.\nThe other policies don't make much sense in this context.\n","is_empty":false},{"file_name":"schedule/create.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/schedule/create.md","id":"tctl-next/schedule/create","title":"tctl schedule create","description":"How to create a Schedule using tctl.","label":"create","tags":["tctl"],"markdown_content":"\nWith tctl, create a Schedule like this:\n\n```shell\n$ tctl config set version next   # ensure you're using the new tctl\n$ tctl schedule create \\\n    --sid 'your-schedule-id' \\\n    --interval '5h/15m' \\\n    --cal '{\"dayOfWeek\":\"Fri\",\"hour\":\"11\",\"minute\":\"3\"}' \\\n    --overlap-policy 'BufferAll' \\\n    --wid 'your-workflow-id' \\\n    --tq 'your-task-queue' \\\n    --type 'YourWorkflowType'\n```\n\nThis Schedule takes action every 5 hours at 15 minutes past the hour and also at 11:03 on Fridays.\nIt starts a Workflow `YourWorkflowType` on Task Queue `your-task-queue`, giving it a Workflow Id like `your-workflow-id-2022-06-17T11:03:00Z`.\nWorkflows do not run in parallel.\nIf they would otherwise overlap, they are buffered to run sequentially.\n\nYou can also use traditional cron strings, including all features that are supported by `CronSchedule` today, such as `@weekly` and other shorthands, `@every`, and `CRON_TZ`.\n\n```shell\n$ tctl schedule create \\\n    --sid 'your-schedule-id' \\\n    --cron '3 11 * * Fri' \\\n    --wid 'your-workflow-id' \\\n    --tq 'your-task-queue' \\\n    --type 'YourWorkflowType'\n```\n\nAny combination of `--cal`, `--interval`, and `--cron` is supported and Actions will happen at any of the specified times.\nIf you use both `--time-zone` and also `CRON_TZ`, they must agree.\n\nSee `tctl schedule create --help` for the full set of available options.\n","is_empty":false},{"file_name":"schedule/delete.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/schedule/delete.md","id":"tctl-next/schedule/delete","title":"tctl schedule delete","description":"How to delete a Schedule using tctl","label":"delete","tags":["tctl"],"markdown_content":"\nA Schedule can be deleted.\n\nDeleting a Schedule **does not** affect any Workflows started by the Schedule.\nWorkflow Executions started by Schedules can be cancelled or terminated using the same methods as any others.\nHowever, Workflow Executions started by a Schedule can be identified by the Search Attributes added to them and can be targeted by a [batch](/tctl-next/batch#) command for termination.\n\n```shell\n$ tctl schedule delete --sid 'your-schedule-id'\n```\n","is_empty":false},{"file_name":"schedule/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/schedule/describe.md","id":"tctl-next/schedule/describe","title":"tctl schedule describe","description":"How to describe a Schedule using tctl","label":"describe","tags":["tctl"],"markdown_content":"\nDisplay the current Schedule configuration as well as extra information about past, current, and future Runs.\n\n```shell\ntctl schedule describe --sid 'your-schedule-id'\n```\n\nBecause the Schedule Spec is converted to canonical representations, the output might not be in the same form as it was input.\n","is_empty":false},{"file_name":"schedule/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/schedule/index.md","id":"tctl-next/schedule/index","title":"tctl schedule","description":"How to operate Schedules using tctl.","label":"schedule","tags":["tctl"],"markdown_content":"\nThe `tctl schedule` commands allow for the creation and usage of [Schedules](/concepts/what-is-a-schedule).\nThis command is available in versions 1.17.0 and later for tctl.\n\nSchedules can be changed or enabled with the following commands:\n\n- [Backfill a Schedule using tctl](/tctl-next/schedule#backfill)\n- [Create a Schedule using tctl](/tctl-next/schedule#create)\n- [Delete a Schedule using tctl](/tctl-next/schedule#delete)\n- [Describe a Schedule using tctl](/tctl-next/schedule#describe)\n- [List Schedules using tctl](/tctl-next/schedule#list)\n- [Toggle Pause on Schedule using tctl](/tctl-next/schedule#toggle)\n- [Trigger an Action on a Schedule using tctl](/tctl-next/schedule#trigger)\n- [Update a Schedule using tctl](/tctl-next/schedule#update)\n","is_empty":false},{"file_name":"schedule/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/schedule/list.md","id":"tctl-next/schedule/list","title":"tctl schedule list","description":"How to list Schedules using tctl","label":"list","tags":["tctl"],"markdown_content":"\n```shell\ntctl schedule list\n```\n\nNote that if you're using Standard Visibility, listing Schedules will currently only include Schedule Ids and no other information.\n\nBecause the Schedule Spec is converted to canonical representations, the output might not be in the same form as it was input.\n","is_empty":false},{"file_name":"schedule/toggle.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/schedule/toggle.md","id":"tctl-next/schedule/toggle","title":"tctl schedule toggle","description":"How to toggle (pause/unpause) a Schedule using tctl.","label":"toggle","tags":["tctl"],"markdown_content":"\n```shell\n$ tctl schedule toggle --sid 'your-schedule-id' --pause --reason \"paused because the database is down\"\n$ tctl schedule toggle --sid 'your-schedule-id' --unpause --reason \"the database is back up\"\n```\n","is_empty":false},{"file_name":"schedule/trigger.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/schedule/trigger.md","id":"tctl-next/schedule/trigger","title":"tctl schedule trigger","description":"How to trigger a Schedule Action using tctl","label":"trigger","tags":["tctl"],"markdown_content":"\nStarting a Workflow Run immediately with a Schedule, regardless of its configured Spec, is a common use case.\n\n```shell\n$ tctl schedule trigger --sid 'your-schedule-id'\n```\n\nNote that the action that it takes is subject to the Overlap Policy of the Schedule by default: if the overlap policy is `Skip` and a Workflow is already running, the triggered Action to start the next Workflow Run is skipped!\nLikewise, if the overlap policy is `BufferAll`, the triggered run is buffered behind one or more runs.\n\nIf you really want it to run right now, you can override the overlap policy for this request:\n\n```shell\n$ tctl schedule trigger --sid 'your-schedule-id' --overlap-policy 'AllowAll'\n```\n","is_empty":false},{"file_name":"schedule/update.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/schedule/update.md","id":"tctl-next/schedule/update","title":"tctl schedule update","description":"How to update a Schedule using tctl.","label":"update","tags":["tctl"],"markdown_content":"\nAny part of the Schedule configuration can be updated at any time.\n\n`tctl schedule update` takes the same options as `tctl schedule create` and replaces the entire configuration of the schedule with what's provided.\n\nThis means if you want to change just one value, you have to provide everything else again.\n","is_empty":false},{"file_name":"namespace/delete.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/namespace/delete.md","id":"tctl-next/namespace/delete","title":"tctl namespace delete","description":"Deleting a Namespace using tctl.","label":"delete","tags":["tctl"],"markdown_content":"\nThe `tctl namespace delete` command deletes a [Namespace](/concepts/what-is-a-namespace).\n\n`tctl namespace delete`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--namespace](/tctl-next/modifiers#--namespace)\n- [--yes-mod](/tctl-next/modifiers#--yes-mod)\n","is_empty":false},{"file_name":"namespace/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/namespace/describe.md","id":"tctl-next/namespace/describe","title":"tctl namespace describe","description":"How to describe a Namespace using tctl.","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl namespace describe` command describes a [Namespace](/namespaces).\n\n`tctl namespace describe`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--namespace](/tctl-next/modifiers#--namespace)\n\n### --namespace-id\n\nSpecify the ID of a Namespace to describe.\n\nThis modifier is required unless the global `--namespace` modifier is specified (`tctl --namespace <name> describe`).\n\n**Example**\n\n```bash\ntctl namespace describe --namespace-id <id>\n```\n\nExample results for a [Global Namespace](/namespaces/#global-namespaces)\n\n```bash\n$ tctl --ns canary-namespace n desc\nName: canary-namespace\nDescription: testing namespace\nOwnerEmail: dev@yourtech.io\nNamespaceData:\nStatus: REGISTERED\nRetentionInDays: 7\nEmitMetrics: true\nActiveClusterName: dc1\nClusters: dc1, dc2\n```\n","is_empty":false},{"file_name":"namespace/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/namespace/index.md","id":"tctl-next/namespace/index","title":"tctl namespace","description":"How to operate Namespaces using tctl.","label":"namespace","tags":["tctl"],"markdown_content":"\nThe `tctl namespace` commands enable [Namespace](/concepts/what-is-a-namespace) operations.\n\nAlias: `n`\n\n- [tctl namespace describe](/tctl-next/namespace#describe)\n- [tctl namespace list](/tctl-next/namespace#list)\n- [tctl namespace register](/tctl-next/namespace#register)\n- [tctl namespace update](/tctl-next/namespace#update)\n","is_empty":false},{"file_name":"namespace/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/namespace/list.md","id":"tctl-next/namespace/list","title":"tctl namespace list","description":"How to list all Namespaces using tctl.","label":"list","tags":["tctl"],"markdown_content":"\nThe `tctl namespace list` command lists all [Namespaces](/concepts/what-is-a-namespace).\n\n`tctl namespace list`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"namespace/register.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/namespace/register.md","id":"tctl-next/namespace/register","title":"tctl namespace register","description":"How to register a Namespace using tctl.","label":"register","tags":["tctl"],"markdown_content":"\nThe `tctl namespace register` command registers a [Namespace](/concepts/what-is-a-namespace).\n\n`tctl namespace register`\n\nBy default, Temporal uses a \"default\" Namespace.\nCreate and register a new Namespace with the following command:\n\n```bash\ntctl --namespace your-namespace namespace register\n# OR using short alias\ntctl --ns your-namespace n re\n```\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--active-cluster](/tctl-next/modifiers#--active-cluster)\n- [--clusters](/tctl-next/modifiers#--clusters)\n- [--description](/tctl-next/modifiers#--description)\n- [--global-namespace](/tctl-next/modifiers#--global-namespace)\n- [--history-archival-state](/tctl-next/modifiers#--history-archival-state)\n- [--history-uri](/tctl-next/modifiers#--history-uri)\n- [--namespace-data](/tctl-next/modifiers#--namespace-data)\n- [--owner-email](/tctl-next/modifiers#--owner-email)\n- [--retention](/tctl-next/modifiers#--retention)\n- [--visibility-archival-state](/tctl-next/modifiers#--visibility-archival-state)\n- [--visibility-uri](/tctl-next/modifiers#--visibility-uri)\n","is_empty":false},{"file_name":"namespace/update.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/namespace/update.md","id":"tctl-next/namespace/update","title":"tctl namespace update","description":"How to update a Namespace using tctl.","label":"update","tags":["tctl"],"markdown_content":"\nThe `tctl namespace update` command updates a [Namespace](/concepts/what-is-a-namespace).\n\n`tctl namespace update`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--active-cluster](/tctl-next/modifiers#--active-cluster)\n- [--add-bad-binary](/tctl-next/modifiers#--add-bad-binary)\n- [--clusters](/tctl-next/modifiers#--clusters)\n- [--description](/tctl-next/modifiers#--description)\n- [--history-archival-state](/tctl-next/modifiers#--history-archival-state)\n- [--history-uri](/tctl-next/modifiers#--history-uri)\n- [--namespace-data](/tctl-next/modifiers#--namespace-data)\n- [--owner-email](/tctl-next/modifiers#--owner-email)\n- [--reason](/tctl-next/modifiers#--reason)\n- [--remove-bad-binary](/tctl-next/modifiers#--remove-bad-binary)\n- [--retention](/tctl-next/modifiers#--retention)\n- [--visibility-archival-state](/tctl-next/modifiers#--visibility-archival-state)\n- [--visibility-uri](/tctl-next/modifiers#--visibility-uri)\n","is_empty":false},{"file_name":"modifiers/active-cluster.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/active-cluster.md","id":"tctl-next/modifiers/active-cluster","title":"tctl active-cluster modifier","description":"definition for the --active-cluster modifier","label":"--active-cluster","tags":["tctl"],"markdown_content":"\nSpecify the name of the active [Temporal Cluster](/concepts/what-is-a-temporal-cluster/) when registering a [Namespace](/concepts/what-is-a-namespace).\nThis value changes for Global Namespaces when a failover occurs.\n","is_empty":false},{"file_name":"modifiers/activity-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/activity-id.md","id":"tctl-next/modifiers/activity-id","title":"tctl activity-id modifier","description":"definition for the --activity-id modifier","label":"--activity-id","tags":["tctl"],"markdown_content":"\nSpecify the [Activity Id](/concepts/what-is-an-activity-id) of an [Activity Execution](/concepts/what-is-an-activity-execution) to execute a command on.\n","is_empty":false},{"file_name":"modifiers/archived.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/archived.md","id":"tctl-next/modifiers/archived","title":"tctl archived modifier","description":"definition for the --archived modifier","label":"--archived","tags":["tctl"],"markdown_content":"\n**This is an experimental feature.**\n\nList archived Workflow Executions.\n","is_empty":false},{"file_name":"modifiers/cluster.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/cluster.md","id":"tctl-next/modifiers/cluster","title":"tctl cluster modifier","description":"definition for the --cluster modifier","label":"--cluster","tags":["tctl"],"markdown_content":"\nSpecify a list of [Temporal Clusters](/concepts/what-is-a-temporal-cluster/) when registering a [Namespace](/namespaces#).\n\nThe flag contains a single name of a Cluster to which the Namespace can fail over. For multiple Clusters pass each in a separate `--cluster` option.\nMake sure to include to the currently active Cluster.\nThis is a read-only setting and cannot be changed.\n\nThis modifier is valid only when the `--global` modifier is set to true.\n","is_empty":false},{"file_name":"modifiers/cron.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/cron.md","id":"tctl-next/modifiers/cron","title":"tctl cron modifier","description":"definition for the --cron modifier","label":"--cron","tags":["tctl"],"markdown_content":"\nSpecify a [Cron Schedule](/concepts/what-is-a-temporal-cron-job#cron-schedules).\n","is_empty":false},{"file_name":"modifiers/data.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/data.md","id":"tctl-next/modifiers/data","title":"tctl data modifier","description":"definition for the --data modifier","label":"--data","tags":["tctl"],"markdown_content":"\nSpecify data for a [Namespace](/concepts/what-is-a-namespace) in the form of key-value pairs (such as `k1:v1,k2:v2,k3:v3`).\n","is_empty":false},{"file_name":"modifiers/description.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/description.md","id":"tctl-next/modifiers/description","title":"tctl description modifier","description":"definition for the --description modifier","label":"--description","tags":["tctl"],"markdown_content":"\nSpecify a description when registering a [Namespace](/concepts/what-is-a-namespace).\n","is_empty":false},{"file_name":"modifiers/detail.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/detail.md","id":"tctl-next/modifiers/detail","title":"tctl detail modifier","description":"definition for the --detail modifier","label":"--detail","tags":["tctl"],"markdown_content":"\nSpecify details of the reason for failing an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"modifiers/dry-run.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/dry-run.md","id":"tctl-next/modifiers/dry-run","title":"tctl dry-run modifier","description":"definition for the --dry-run modifier","label":"--dry-run","tags":["tctl"],"markdown_content":"\nSimulate a reset without resetting any [Workflow Executions](/concepts/what-is-a-workflow-execution).\nOutput is logged to `stdout`.\n","is_empty":false},{"file_name":"modifiers/email.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/email.md","id":"tctl-next/modifiers/email","title":"tctl email modifier","description":"definition for the email modifier","label":"--email","tags":["tctl"],"markdown_content":"\nSpecify the email address of the [Namespace](/concepts/what-is-a-namespace) owner.\n","is_empty":false},{"file_name":"modifiers/event-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/event-id.md","id":"tctl-next/modifiers/event-id","title":"tctl event-id modifier","description":"definition for the --event-id modifier","label":"--event-id","tags":["tctl"],"markdown_content":"\nSpecify the `eventId` of any event after `WorkflowTaskStarted` to which you want to reset.\nValid values are `WorkflowTaskCompleted`, `WorkflowTaskFailed`, and `WorkflowTaskTimeout`.\n","is_empty":false},{"file_name":"modifiers/exclude-file.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/exclude-file.md","id":"tctl-next/modifiers/exclude-file","title":"tctl exclude-file modifier","description":"definition for the --exclude-file","label":"--exclude-file","tags":["tctl"],"markdown_content":"\nProvide an input file that specifies [Workflow Executions](/concepts/what-is-a-workflow-execution) to exclude from resetting.\n\nEach line contains one [Workflow Id](/concepts/what-is-a-workflow-id).\n","is_empty":false},{"file_name":"modifiers/execution-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/execution-timeout.md","id":"tctl-next/modifiers/execution-timeout","title":"tctl execution-timeout modifier","description":"definition for the --execution-timeout modifier","label":"--execution-modifier","tags":["tctl"],"markdown_content":"\nSpecify the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) of the [Workflow Execution](/concepts/what-is-a-workflow-execution) in seconds.\nThe default value is 0.\n","is_empty":false},{"file_name":"modifiers/fields.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/fields.md","id":"tctl-next/modifiers/fields","title":"tctl fields modifier","description":"definition for the --fields modifier","label":"--fields","tags":["tctl"],"markdown_content":"\nCustomize the fields to print.\nSet to 'long' to automatically print more of the main fields.\n","is_empty":false},{"file_name":"modifiers/follow.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/follow.md","id":"tctl-next/modifiers/follow","title":"tctl follow modifier","description":"definition for the --follow","label":"--follow","tags":["tctl"],"markdown_content":"\nFollows the progress of a Workflow Execution.\n","is_empty":false},{"file_name":"modifiers/global.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/global.md","id":"tctl-next/modifiers/global","title":"tctl global modifier","description":"definition for the --global modifier","label":"--global","tags":["tctl"],"markdown_content":"\nSpecifies whether a [Namespace](/concepts/what-is-a-namespace) is a [Global Namespace](/concepts/what-is-a-global-namespace).\nWhen enabled, it controls the creation of replication tasks on updates allowing the state to be replicated across Clusters.\nThis is a read-only setting and cannot be changed.\n","is_empty":false},{"file_name":"modifiers/history-archival-state.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/history-archival-state.md","id":"tctl-next/modifiers/history-archival-state","title":"tctl history-archival-state modifier","description":"definition for the --history-archival-state modifier","label":"--history-archival-state","tags":["tctl"],"markdown_content":"\nSet the state of [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n","is_empty":false},{"file_name":"modifiers/history-uri.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/history-uri.md","id":"tctl-next/modifiers/history-uri","title":"tctl history-uri modifier","description":"definition for the --history-uri modifier","label":"--history-uri","tags":["tctl"],"markdown_content":"\nSpecify the URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n","is_empty":false},{"file_name":"modifiers/id-reuse-policy.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/id-reuse-policy.md","id":"tctl-next/modifiers/id-reuse-policy","title":"tctl id-reuse-policy modifier","description":"definition for the --id-reuse-policy modifier","label":"--id-reuse-policy","tags":["tctl"],"markdown_content":"\nSpecify a [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy).\nConfigure if the same [Workflow Id](/concepts/what-is-a-workflow-id) is allowed for use in new [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\nValues: `AllowDuplicate`, `AllowDuplicateFailedOnly`, `RejectDuplicate`\n\n**Examples**\n\n```bash\ntctl workflow <command> --id-reuse-policy AllowDuplicate\ntctl workflow <command> --id-reuse-policy AllowDuplicateFailedOnly\ntctl workflow <command> --id-reuse-policy RejectDuplicate\n```\n","is_empty":false},{"file_name":"modifiers/identity.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/identity.md","id":"tctl-next/modifiers/identity","title":"tctl identity modifier","description":"definition for the --identity modifier","label":"--identity","tags":["tctl"],"markdown_content":"\nSpecify the identity of the operator when using tctl to fail an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"modifiers/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/index.md","id":"tctl-next/modifiers/index","title":"tctl modifiers reference","description":"Modifiers change the behavior of the command.","label":"modifiers","tags":["tctl"],"markdown_content":"\nModifiers change the behavior of the command.\n","is_empty":false},{"file_name":"modifiers/input-file.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/input-file.md","id":"tctl-next/modifiers/input-file","title":"tctl input-file modifier","description":"definition for the --input-file modifier","label":"--input-file","tags":["tctl"],"markdown_content":"\nPass input for the Workflow from a JSON file.\nFor multiple JSON objects, concatenate them and use spaces or newline characters as separators.\nInput from the command line overwrites input from the file.\n","is_empty":false},{"file_name":"modifiers/input-parallelism.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/input-parallelism.md","id":"tctl-next/modifiers/input-parallelism","title":"tctl input-parallelism modifier","description":"definition for the --input-parallelism modifier","label":"--input-parallelism","tags":["tctl"],"markdown_content":"\nSpecify the number of goroutines to run in parallel.\nEach goroutine processes one line for every second.\nThe default is 1.\n","is_empty":false},{"file_name":"modifiers/input.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/input.md","id":"tctl-next/modifiers/input","title":"tctl input modifier","description":"definition for the --input modifier","label":"--input","tags":["tctl"],"markdown_content":"\nPass input for the Workflow.\nInput must be in JSON format.\nFor multiple JSON objects, pass each in a separate `--input` option. Use `null` for null values.\n","is_empty":false},{"file_name":"modifiers/job-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/job-id.md","id":"tctl-next/modifiers/job-id","title":"tctl job-id modifier","description":"definition for the --job-id modifier","label":"--job-id","tags":["tctl"],"markdown_content":"\n_Required modifier_\n\nSpecify the job ID of a batch job.\n","is_empty":false},{"file_name":"modifiers/limit.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/limit.md","id":"tctl-next/modifiers/limit","title":"tctl limit modifier","description":"definition for the --limit modifier","label":"--limit","tags":["tctl"],"markdown_content":"\nSets the number of items to print.\n","is_empty":false},{"file_name":"modifiers/max-field-length.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/max-field-length.md","id":"tctl-next/modifiers/max-field-length","title":"tctl max-field-length modifier","description":"definition for the --max-field-length modifier","label":"--max-field-modifier","tags":["tctl"],"markdown_content":"\nSpecify the maximum length for each attribute field.\nThe default value is 500.\n","is_empty":false},{"file_name":"modifiers/memo-file.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/memo-file.md","id":"tctl-next/modifiers/memo-file","title":"tctl memo-file modifier","description":"definition for the --memo-file modifier","label":"--memo-file","tags":["tctl"],"markdown_content":"\nPass a memo from a file, where each line follows the format `key=value`.\nUse valid JSON formats for values.\n","is_empty":false},{"file_name":"modifiers/memo.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/memo.md","id":"tctl-next/modifiers/memo","title":"tctl memo modifier","description":"definition for the --memo modifier","label":"--memo","tags":["tctl"],"markdown_content":"\nPass a memo in the format `key=value`.\n\nA memo is information in JSON format that can be shown when the Workflow is listed.\nFor multiple memos, pass each in a separate `--memo` modifier.\n","is_empty":false},{"file_name":"modifiers/name.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/name.md","id":"tctl-next/modifiers/name","title":"tctl name modifier","description":"definition for the --name modifier","label":"--name","tags":["tctl"],"markdown_content":"\nSpecify the name of a [Signal](/concepts/what-is-a-signal).\n","is_empty":false},{"file_name":"modifiers/namespace.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/namespace.md","id":"tctl-next/modifiers/namespace","title":"tctl namespace modifier","description":"definition for the --namespace modifier","label":"--namespace","tags":["tctl"],"markdown_content":"\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n","is_empty":false},{"file_name":"modifiers/no-pager.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/no-pager.md","id":"tctl-next/modifiers/no-pager","title":"tctl no-pager modifier","description":"definition for the --no-pager modifier","label":"--no-pager","tags":["tctl"],"markdown_content":"\nDisables the interactive pager.\n","is_empty":false},{"file_name":"modifiers/non-deterministic.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/non-deterministic.md","id":"tctl-next/modifiers/non-deterministic","title":"tctl non-deterministic modifier","description":"definition for the --non-deterministic modifier","label":"--non-deterministic","tags":["tctl"],"markdown_content":"\nIndicate that a [Workflow Execution](/concepts/what-is-a-workflow-execution) should be reset only if its last event is `WorkflowTaskFailed` with a nondeterministic error.\n","is_empty":false},{"file_name":"modifiers/output-filename.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/output-filename.md","id":"tctl-next/modifiers/output-filename","title":"tctl output-filename modifier","description":"definition for the --output-filename modifier","label":"--output-filename","tags":["tctl"],"markdown_content":"\nSerialize an Event to a file.\n","is_empty":false},{"file_name":"modifiers/output.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/output.md","id":"tctl-next/modifiers/output","title":"tctl output modifier","description":"definition for the --output modifier","label":"--output","tags":["tctl"],"markdown_content":"\nSpecifies the format for printed output.\n\nValues: table, json, card\n","is_empty":false},{"file_name":"modifiers/pager.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/pager.md","id":"tctl-next/modifiers/pager","title":"tctl pager modifier","description":"definition for the --pager modifier","label":"--pager","tags":["tctl"],"markdown_content":"\nSpecifies the pager to use.\n\nValues: less, more, favoritePager..[$PAGER]\n","is_empty":false},{"file_name":"modifiers/pagesize.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/pagesize.md","id":"tctl-next/modifiers/pagesize","title":"tctl pagesize modifier","description":"definition for the --pagesize","label":"--pagesize","tags":["tctl"],"markdown_content":"\nSpecify the maximum number of batch jobs to list on a page. The default value is 30.\n","is_empty":false},{"file_name":"modifiers/query.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/query.md","id":"tctl-next/modifiers/query","title":"tctl query modifier","description":"definition for the --query modifier","label":"--query","tags":["tctl"],"markdown_content":"\n_Required modifier_\n\nThe `--query` flag is supported only when [Advanced Visibility](/concepts/what-is-advanced-visibility) is configured with the Cluster.\n\nSpecify an SQL-like query of [Search Attributes](/concepts/what-is-a-search-attribute).\n\nUsing the `--query` option causes tctl to ignore all other filter options, including `open`, `earliest-time`, `latest-time`, `workflow-id`, and `workflow-type`.\n\nAlias: `--q`\n","is_empty":false},{"file_name":"modifiers/raw.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/raw.md","id":"tctl-next/modifiers/raw","title":"tctl raw modifier","description":"definition for the tctl --raw modifier","label":"--raw","tags":["tctl"],"markdown_content":"\nPrint properties exactly as they are stored.\n","is_empty":false},{"file_name":"modifiers/reason.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/reason.md","id":"tctl-next/modifiers/reason","title":"tctl reason modifier","description":"definition for the --reason modifier","label":"--reason","tags":["tctl"],"markdown_content":"\nSpecify a reason for terminating the [Workflow Execution](/concepts/what-is-a-workflow-execution).\n","is_empty":false},{"file_name":"modifiers/reject-condition.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/reject-condition.md","id":"tctl-next/modifiers/reject-condition","title":"tctl reject-condition modifier","description":"definition for the --reject-condition modifier","label":"--reject-condition","tags":["tctl"],"markdown_content":"\nReject Queries based on Workflow state.\nValid values are `not-open` and `not-completed-cleanly`.\n","is_empty":false},{"file_name":"modifiers/reset-bad-binary-checksum.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/reset-bad-binary-checksum.md","id":"tctl-next/modifiers/reset-bad-binary-checksum","title":"tctl reset-bad-binary-checksum","description":"definition for the --reset-bad-binary-checksum modifier","label":"--reset-bad-binary-checksum","tags":["tctl"],"markdown_content":"\nSpecify the binary checksum when using `--reset-type BadBinary`.\n","is_empty":false},{"file_name":"modifiers/reset-points-only.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/reset-points-only.md","id":"tctl-next/modifiers/reset-points-only","title":"tctl reset-points-only modifier","description":"definition for the --reset-points-only modifier","label":"--reset-points-only","tags":["tctl"],"markdown_content":"\nShow only events that are eligible for reset.\n","is_empty":false},{"file_name":"modifiers/reset-reapply-type.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/reset-reapply-type.md","id":"tctl-next/modifiers/reset-reapply-type","title":"tctl reset-reapply-type modifier","description":"definition for the --reset-reapply-type modifier","label":"--reset-reapply-type","tags":["tctl"],"markdown_content":"\nSpecify the types of events to reapply after the reset point.\nValid values are `All`, `Signal`, and `None`. The default is `All`.\n\n**Example**\n\n```bash\ntctl workflow <command> --reset-reapply-type <value>\n```\n","is_empty":false},{"file_name":"modifiers/reset-type.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/reset-type.md","id":"tctl-next/modifiers/reset-type","title":"tctl reset-type modifier","description":"definition for the --reset-type modifier","label":"--reset-type","tags":["tctl"],"markdown_content":"\nSpecify the event type to which you want to reset.\n\n| Value                | Description                                                 |\n| -------------------- | ----------------------------------------------------------- |\n| `FirstWorkflowTask`  | Reset to the beginning of the Event History.                |\n| `LastWorkflowTask`   | Reset to the end of the Event History.                      |\n| `LastContinuedAsNew` | Reset to the end of the Event History for the previous Run. |\n| `BadBinary`          | Reset to the point where a bad binary was used.             |\n","is_empty":false},{"file_name":"modifiers/result.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/result.md","id":"tctl-next/modifiers/result","title":"tctl result modifier","description":"definition for the --result modifier","label":"--result","tags":["tctl"],"markdown_content":"\nSpecify the result of an [Activity Execution](/concepts/what-is-an-activity-execution) when using tctl to complete the Activity Execution.\n","is_empty":false},{"file_name":"modifiers/retention.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/retention.md","id":"tctl-next/modifiers/retention","title":"tctl retention modifier","description":"definition for the --retention modifier","label":"--retention","tags":["tctl"],"markdown_content":"\nSet the [Retention Period](/clusters#retention-period) for the [Namespace](/concepts/what-is-a-namespace).\n\nThe Retention Period applies to Closed [Workflow Executions](/concepts/what-is-a-workflow-execution).\n","is_empty":false},{"file_name":"modifiers/rps.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/rps.md","id":"tctl-next/modifiers/rps","title":"tctl rps modifier","description":"definition for the --rps modifier","label":"--rps","tags":["tctl"],"markdown_content":"\nSpecify RPS of processing. The default value is 50.\n","is_empty":false},{"file_name":"modifiers/run-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/run-id.md","id":"tctl-next/modifiers/run-id","title":"tctl run-id modifier","description":"definition for the --run-id modifier","label":"--run-id","tags":["tctl"],"markdown_content":"\nShow the History of a [Workflow Execution](/concepts/what-is-a-workflow-execution) by specifying a [Run Id](/concepts/what-is-a-run-id).\n\nAlias: `--r`\n","is_empty":false},{"file_name":"modifiers/run-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/run-timeout.md","id":"tctl-next/modifiers/run-timeout","title":"tctl run-timeout modifier","description":"definition for the --run-timeout modifier","label":"--run-timeout","tags":["tctl"],"markdown_content":"\nSingle Workflow Run timeout, in seconds.\n","is_empty":false},{"file_name":"modifiers/search-attribute.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/search-attribute.md","id":"tctl-next/modifiers/search-attribute","title":"tctl search-attribute modifier","description":"definition for the --search-attribute modifier","label":"--search-attribute","tags":["tctl"],"markdown_content":"\nPass a [Search Attribute](/visibility#search-attribute) in the format `key=value`.\nFor multiple values, pass each in a separate `--search-attribute` modifier.\n\nTo list valid keys, use the `tctl search-attribute list` command.\n","is_empty":false},{"file_name":"modifiers/signal-name.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/signal-name.md","id":"tctl-next/modifiers/name","title":"tctl name modifier","description":"definition for the name modifier","label":"--name","tags":["tctl"],"markdown_content":"\nSpecify the name of a [Signal](/concepts/what-is-a-signal).\n","is_empty":false},{"file_name":"modifiers/skip-base-is-not-current.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/skip-base-is-not-current.md","id":"tctl-next/modifiers/skip-base-is-not-current","title":"tctl skip-base-is-not-current modifier","description":"definition for the --skip-base-is-not-current modifier","label":"--skip-base-is-not-current","tags":["tctl"],"markdown_content":"\nIndicate that a [Workflow Execution](/concepts/what-is-a-workflow-execution) should be skipped if the base Run is not the current Run.\n","is_empty":false},{"file_name":"modifiers/skip-current-open.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/skip-current-open.md","id":"tctl-next/modifiers/skip-current-open","title":"tctl skip-current-open modifier","description":"definition for the --skip-current-open modifier","label":"--skip-current-open","tags":["tctl"],"markdown_content":"\nIndicate that a [Workflow Execution](/concepts/what-is-a-workflow-execution) should be skipped if the current Run is open for the same [Workflow Id](/concepts/what-is-a-workflow-id) as the base Run.\n","is_empty":false},{"file_name":"modifiers/task-queue-type.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/task-queue-type.md","id":"tctl-next/modifiers/task-queue-type","title":"tctl task-queue-type modifier","description":"definition for the --task-queue-type modifier","label":"--task-queue-type","tags":["tctl"],"markdown_content":"\nSpecify the type of a [Task Queue](/concepts/what-is-a-task-queue).\nThe type can be `workflow` or `activity`.\nThe default is `workflow`.\n","is_empty":false},{"file_name":"modifiers/task-queue.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/task-queue.md","id":"tctl-next/modifiers/task-queue","title":"tctl task-queue modifier","description":"definition for the --task-queue modifier","label":"--task-queue","tags":["tctl"],"markdown_content":"\nSpecify a [Task Queue](/concepts/what-is-a-task-queue).\n\nAlias: `--t`\n","is_empty":false},{"file_name":"modifiers/task-timeout.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/task-timeout.md","id":"tctl-next/modifiers/task-timeout","title":"tctl task-timeout modifier","description":"definition for the --task-timeout modifier","label":"--task-timeout","tags":["tctl"],"markdown_content":"\nSpecify the Start-To-Close Timeout of the [Workflow Task](/concepts/what-is-a-workflow-task) in seconds.\nThe default value is 10.\n","is_empty":false},{"file_name":"modifiers/time-format.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/time-format.md","id":"tctl-next/modifiers/time-format","title":"tctl time-format modifier","description":"definition for the --time-format modifier","label":"--time-format","tags":["tctl"],"markdown_content":"\nSpecifies the format for time values.\n\nValues: relative, iso, raw\n","is_empty":false},{"file_name":"modifiers/type.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/type.md","id":"tctl-next/modifiers/type","title":"tctl type modifier","description":"definition for the --type modifier","label":"--type","tags":["tctl"],"markdown_content":"\nSpecify the name of a [Workflow Type](/concepts/what-is-a-workflow-type).\nSpecity the type of Query to send.\n","is_empty":false},{"file_name":"modifiers/visibility-archival-state.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/visibility-archival-state.md","id":"tctl-next/modifiers/visibility-archival-state","title":"tctl visibility-archival-state modifier","description":"definition for the --visibility-archival-state modifier","label":"--visibility-archival-state","tags":["tctl"],"markdown_content":"\nSet the visibility state for [Archival](/concepts/what-is-archival).\nValid values are `disabled` and `enabled`.\n","is_empty":false},{"file_name":"modifiers/visibility-uri.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/visibility-uri.md","id":"tctl-next/modifiers/visibility-uri","title":"tctl visibility-uri modifier","description":"definition for the --visibility-uri modifier","label":"--visibility-uri","tags":["tctl"],"markdown_content":"\nSpecify the visibility URI for [Archival](/concepts/what-is-archival).\nThe URI cannot be changed after Archival is first enabled.\n","is_empty":false},{"file_name":"modifiers/workflow-id.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/workflow-id.md","id":"tctl-next/modifiers/workflow-id","title":"tctl workflow-id modifier","description":"definition for the --workflow-id modifier","label":"--workflow-id","tags":["tctl"],"markdown_content":"\n_This modifier is required._\n\nShow the History of a [Workflow Execution](/concepts/what-is-a-workflow-execution) by specifying a [Workflow Id](/concepts/what-is-a-workflow-id).\n","is_empty":false},{"file_name":"modifiers/yes.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/modifiers/yes.md","id":"tctl-next/modifiers/yes","title":"tctl yes modifier","description":"How to use the tctl-next --yes modifier.","label":"--yes","tags":["tctl"],"markdown_content":"\nUse the --yes modifier to automatically confirm all prompts.\n\nAlias: `--y`\n","is_empty":false},{"file_name":"data-converter/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/data-converter/index.md","id":"tctl-next/data-converter/index","title":"tctl data-converter","description":"How to operate custom Data Converters using tctl.","label":"data-converter","tags":["tctl"],"markdown_content":"\nThe `tctl data-converter` command enables custom [Data Converter](/concepts/what-is-a-data-converter) operations.\n\n- [tctl data-converter web](/tctl-next/data-converter#web)\n","is_empty":false},{"file_name":"data-converter/web.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/data-converter/web.md","id":"tctl-next/data-converter/web","title":"tctl data-converter web","description":"How to specify the WebSocket URL of a custom Data Converter using tctl.","label":"web","tags":["tctl"],"markdown_content":"\nThe `tctl data-converter web` command specifies the WebSocket URL of a custom [Data Converter](/concepts/what-is-a-data-converter) to use with Temporal Web.\n\n`tctl data-converter web --web-ui-url <url>`\n\nThe following modifiers control the behavior of the command.\n\n### `port`\n\nSpecify a port for the WebSocket URL of a custom [Data Converter](/concepts/what-is-a-data-converter).\nThe default value is 0.\n\n**Example**\n\n```bash\ntctl dataconverter web --web-ui-url <url> --port <value>\n```\n\n### `--web-ui-url`\n\n_Required modifier_\n\nSpecify the WebSocket URL of a custom [Data Converter](/concepts/what-is-a-data-converter).\n\n**Example**\n\n```bash\ntctl dataconverter web --web-ui-url <url>\n```\n","is_empty":false},{"file_name":"config/current-env.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/config/current-env.md","id":"tctl-next/config/current-env","title":"tctl config current-env","description":"Print the current environment name.","label":"current-env","tags":["tctl"],"markdown_content":"\nThe `tctl config current-env` command prints the name of the current environment.\n\n`tctl config current-env <modifiers>`\n\nThis command has no modifiers.\n","is_empty":false},{"file_name":"config/get.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/config/get.md","id":"tctl-next/config/get","title":"tctl config get","description":"Print configuration values.","label":"get","tags":["tctl"],"markdown_content":"\nThe `tctl config get` command prints the value of a given environmental property.\nThe command is written as follows:\n\n`tctl config get [options] [env.env_name]property_name`\n\nThis command has no modifiers.\n","is_empty":false},{"file_name":"config/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/config/index.md","id":"tctl-next/config/index","title":"tctl config","description":"Allows the tctl environment to be modified or updated.","label":"config","tags":["tctl"],"markdown_content":"\nThe `tctl config` command allows the user to configure their tctl environment.\n\n`tctl config <command> [options] [args]`\n\n- [tctl config current-env](/tctl-next/config#current-env)\n- [tctl config get](/tctl-next/config#get)\n- [tctl config set](/tctl-next/config#set)\n- [tctl config show-env](/tctl-next/config#show-env)\n- [tctl config use-env](/tctl-next/config#use-env)\n","is_empty":false},{"file_name":"config/set.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/config/set.md","id":"tctl-next/config/set","title":"tctl config set","description":"Set configuration values.","label":"set","tags":["tctl"],"markdown_content":"\nThe `tctl config set` command modifies the configuration values within your environment.\nUse this command to set the value of a given environmental property.\n\n`tctl config set [options] [env.env_name]property_name`\n\nThis command has no modifiers.\n","is_empty":false},{"file_name":"config/show-env.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/config/show-env.md","id":"tctl-next/config/show-env","title":"tctl config show-env","description":"Prints current environment properties.","label":"show-env","tags":["tctl"],"markdown_content":"\nThe `tctl config show-env` command prints the properties of the given environment.\n\n`tctl config show-env [options] ev_name`\n\nThe following modifier supports and controls the behavior of the command.\n\n- [--output](/tctl-next/modifiers#--output)\n","is_empty":false},{"file_name":"config/use-env.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/config/use-env.md","id":"tctl-next/config/use-env","title":"tctl config use-env","description":"Switches enviroments in tctl.","label":"use-env","tags":["tctl"],"markdown_content":"\nThe `tctl config use-env` command switches the environment that tctl is operating in.\n\n`tctl config use-env [options] env_name`\n\nThere are no modifiers for this command.\n","is_empty":false},{"file_name":"cluster/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/cluster/describe.md","id":"tctl-next/cluster/describe","title":"tctl cluster describe","description":"How to show information about the Cluster using tctl.","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl cluster describe` shows information about the Cluster.\n\n`tctl cluster describe`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"cluster/health.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/cluster/health.md","id":"tctl-next/cluster/health","title":"tctl cluster health","description":"How to check the health of the Frontend Service using tctl.","label":"health","tags":["tctl"],"markdown_content":"\nThe `tctl cluster health` command checks the health of the [Frontend Service](/concepts/what-is-a-temporal-cluster/#frontend-service).\n\n`tctl cluster health`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"cluster/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/cluster/index.md","id":"tctl-next/cluster/index","title":"tctl cluster","description":"How to operate Temporal Clusters using tctl.","label":"cluster","tags":["tctl"],"markdown_content":"\nThe `tctl cluster` command enables [Temporal Cluster](/concepts/what-is-a-temporal-cluster) operations.\n\n- [tctl cluster health](/tctl-next/cluster/health)\n- [tctl cluster describe](/tctl-next/cluster/describe)\n- [tctl cluster system](/tctl-next/cluster/system)\n","is_empty":false},{"file_name":"cluster/system.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/cluster/system.md","id":"tctl-next/cluster/system","title":"tctl cluster system","description":"How to check the health of the Frontend Service using tctl.","label":"system","tags":["tctl"],"markdown_content":"\nThe `tctl cluster system` command shows information about the system capabilities.\n\n`tctl cluster system`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"batch/describe.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/batch/describe.md","id":"tctl-next/batch/describe","title":"tctl batch describe","description":"How to describe the progress of a batch job using tctl.","label":"describe","tags":["tctl"],"markdown_content":"\nThe `tctl batch describe` command describes the progress of a batch job.\n\n`tctl batch describe --job-id <value> <modifiers>`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--job-id](/tctl-next/modifiers#--job-id)\n- [--namespace](/tctl-next/modifiers#--namespace)\n- [--fields](/tctl-next/modifiers#--fields)\n- [--output](/tctl-next/modifiers#--output)\n- [--time-format](/tctl-next/modifiers#--time-format)\n","is_empty":false},{"file_name":"batch/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/batch/index.md","id":"tctl-next/batch/index","title":"tctl batch","description":"How to run a tctl batch command. A tctl batch command enables you to affect multiple existing Workflow Executions with a single command.","label":"batch","tags":["tctl"],"markdown_content":"\nA \"batch\" command enables you to affect multiple existing [Workflow Executions](/concepts/what-is-a-workflow-execution) with a single command.\nA batch job runs in the background and affects Workflow Executions one at a time.\n\nIn tctl version-next you can run the typical Signal Workflow, Terminate Workflow, and Cancel Workflow batch jobs using the `tctl workflow signal`, `tctl workflow terminate`, and `tctl workflow cancel` commands respectively.\nThe batch command is automatically started when the [`--query` modifier](/tctl-next/modifiers#--query) is provided with those commands.\n\nIn tctl version-next, the `tctl batch` commands are used solely to view the status of and terminate the batch jobs.\n\nThe `--query` modifier supports a [List Filter](/concepts/what-is-a-list-filter).\nThe List Filter identifies the set of Workflow Executions to be affected by the command.\n\nA successfully started batch job returns a Job ID.\nYou can use this Job ID in the `tctl batch describe` command, which describes the progress of a specific batch job.\n\nYou can also use the Job ID to terminate the batch job itself.\nTerminating a batch job does not roll back the operations already performed by the batch job.\n\n### tctl batch-v2 commands\n\n- [tctl batch describe --job-id](/tctl-next/batch#describe)\n- [tctl batch list](/tctl-next/batch#list)\n- [tctl batch terminate --job_id](/tctl-next/batch#terminate)\n- [tctl workflow signal --query ...](/tctl-next/workflow/signal)\n- [tctl workflow terminate --query ...](/tctl-next/workflow/terminate)\n- [tctl workflow cancel --query ...](/tctl-next/workflow/cancel)\n","is_empty":false},{"file_name":"batch/list.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/batch/list.md","id":"tctl-next/batch/list","title":"tctl batch list","description":"How to list batch jobs using tctl.","label":"list","tags":["tctl"],"markdown_content":"\nThe `tctl batch list` command lists all batch jobs.\n\n`tctl batch list <modifiers>`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--namespace](/tctl-next/modifiers#--namespace)\n- [--fields](/tctl-next/modifiers#--fields)\n- [--limit](/tctl-next/modifiers#--limit)\n- [--output](/tctl-next/modifiers#--output)\n- [--no-pager](/tctl-next/modifiers#--no-pager)\n- [--pager](/tctl-next/modifiers#--pager)\n- [--time-format](/tctl-next/modifiers#--time-format)\n","is_empty":false},{"file_name":"batch/terminate.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/batch/terminate.md","id":"tctl-next/batch/terminate","title":"tctl batch terminate","description":"How to terminate a batch job using tctl.","label":"terminate","tags":["tctl"],"markdown_content":"\nThe `tctl batch terminate` command terminates a batch job.\n\n`tctl batch terminate --job-id <id> <modifiers>`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--job-id](/tctl-next/modifiers#--job-id)\n- [--namespace](/tctl-next/modifiers#--namespace)\n","is_empty":false},{"file_name":"activity/complete.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/activity/complete.md","id":"tctl-next/activity/complete","title":"tctl activity complete","description":"How to provide a result and complete an Activity Execution using tctl.","label":"complete","tags":["tctl"],"markdown_content":"\nThe `tctl activity complete` command completes an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n`tctl activity complete <modifiers>`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--activity-id](/tctl-next/modifiers#--activity-id)\n- [--identity](/tctl-next/modifiers#--identity)\n- [--reason](/tctl-next/modifiers#--reason)\n- [--run-id](/tctl-next/modifiers#--run-id)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n","is_empty":false},{"file_name":"activity/fail.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/activity/fail.md","id":"tctl-next/activity/fail","title":"tctl activity fail","description":"How to fail an Activity Execution using tctl.","label":"fail","tags":["tctl"],"markdown_content":"\nThe `tctl activity fail` command fails an [Activity Execution](/concepts/what-is-an-activity-execution).\n\n`tctl activity fail <modifiers>`\n\nThe following modifiers are supported and control the behavior of the command.\nAlways include required modifiers when executing this command.\n\n- [--activity-id](/tctl-next/modifiers#--activity-id)\n- [--detail](/tctl-next/modifiers#--detail)\n- [--identity](/tctl-next/modifiers#--identity)\n- [--reason](/tctl-next/modifiers#--reason)\n- [--run-id](/tctl-next/modifiers#--run-id)\n- [--workflow-id](/tctl-next/modifiers#--workflow-id)\n","is_empty":false},{"file_name":"activity/index.md","file_path":"/Users/ssantiago/Documents/documentation/docs-src/tctl-next/activity/index.md","id":"tctl-next/activity/index","title":"tctl activity","description":"How to operate Activity Executions using tctl.","label":"activity","tags":["tctl"],"markdown_content":"\nThe `tctl activity` commands enable [Activity Execution](/concepts/what-is-an-activity-execution) operations.\n\n- [tctl activity complete](/tctl-next/activity#complete)\n- [tctl activity fail](/tctl-next/activity#fail)\n","is_empty":false}]

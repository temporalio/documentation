[{"file_name":"activity-heartbeats.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/activity-heartbeats.md","id":1,"title":"How to Heartbeat an Activity","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.","label":"Activity Heartbeats","tags":["guide-context"],"markdown_content":"\nAn [Activity Heartbeat](/concepts/what-is-an-activity-heartbeat) is a ping from the [Worker Process](/concepts/what-is-a-worker-process) that is executing the Activity to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\nEach Heartbeat informs the Temporal Cluster that the [Activity Execution](/concepts/what-is-an-activity-execution) is making progress and the Worker has not crashed.\nIf the Cluster does not receive a Heartbeat within a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) time period, the Activity will be considered failed and another [Activity Task Execution](/concepts/what-is-an-activity-task-execution) may be scheduled according to the Retry Policy.\n\nHeartbeats may not always be sent to the Cluster—they may be [throttled](/concepts/what-is-an-activity-heartbeat#throttling) by the Worker.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\nHeartbeats can contain a `details` field describing the Activity's current progress.\nIf an Activity gets retried, the Activity can access the `details` from the last Heartbeat that was sent to the Cluster.\n","is_empty":false},{"file_name":"activity-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/activity-parameters.md","id":2,"title":"How to develop Activity Parameters","description":"When it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.","label":"Activity Parameters","tags":["guide-context"],"markdown_content":"\nThere is no explicit limit to the total number of parameters that an [Activity Definition](/concepts/what-is-an-activity-definition) may support.\nHowever, there is a limit of the total size of the data ends up encoded into a gRPC message Payload.\n\nA single argument is limited to a maximum size of 2 MB.\nAnd the total size of a gRPC message, which includes all the arguments, is limited to a maximum of 4 MB.\n\nAlso, keep in mind that all Payload data is recorded in the [Workflow Execution Event History](/concepts/what-is-an-event-history) and large Event Histories can affect Worker performance.\nThis is because the entire Event History could be transferred to a Worker Process with a [Workflow Task](/concepts/what-is-a-workflow-task).\n\n<!--TODO link to gRPC limit section when available -->\n\nSome SDKs require that you pass context objects, others do not.\nWhen it comes to your application data—that is, data that is serialized and encoded into a Payload—we recommend that you use a single object as an argument that wraps the application data passed to Activities.\nThis is so that you can change what data is passed to the Activity without breaking a function or method signature.\n","is_empty":false},{"file_name":"activity-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/activity-retry-policy.md","id":3,"title":"How to set an Activity Retry Policy","description":"Activity Executions are automatically associated with a default Retry Policy if a custom one is not provided.","label":"Activity Retry Policy","tags":["guide-context"],"markdown_content":"\nActivity Executions are automatically associated with a default [Retry Policy](/concepts/what-is-a-retry-policy) if a custom one is not provided.\n","is_empty":false},{"file_name":"activity-retry-simulator.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/activity-retry-simulator.md","id":4,"title":"How to visualize an Activity Retry Policy with timeouts","description":"Use this tool to visualize total Activity Execution times and experiment with various Activity timeouts and Retry Policies.","label":"Activity retry simulator","tags":["guide-context"],"markdown_content":"\nUse this tool to visualize total Activity Execution times and experiment with different Activity timeouts and Retry Policies.\n\nThe simulator is based on a common Activity use-case, which is to call a third party HTTP API and return the results.\nSee the example code snippets below.\n\nUse the Activity Retries settings to configure how long the API request takes to succeed or fail.\nThere is an option to generate scenarios.\nThe _Task Time in Queue_ simulates the time the Activity Task might be waiting in the Task Queue.\n\nUse the Activity Timeouts and Retry Policy settings to see how they impact the success or failure of an Activity Execution.\n\nimport RetrySimulator from '/docs/components/RetrySimulator/RetrySimulator';\n\n<RetrySimulator />\n","is_empty":false},{"file_name":"activity-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/activity-return-values.md","id":5,"title":"How to define Activity return values","description":"All data returned from an Activity must be serializable.","label":"Activity return values","tags":["guide-context"],"markdown_content":"\nAll data returned from an Activity must be serializable.\n\nThere is no explicit limit to the amount of data that can be returned by an Activity, but keep in mind that all return values are recorded in a [Workflow Execution Event History](/concepts/what-is-an-event-history).\n","is_empty":false},{"file_name":"activity-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/activity-timeouts-and-retries.md","id":6,"title":"How to set Activity timeouts and retries","description":"Each Activity timeout controls the maximum duration of a different aspect of an Activity Execution.","label":"Activity return values","tags":["guide-context"],"markdown_content":"\nEach Activity timeout controls the maximum duration of a different aspect of an Activity Execution.\nA Retry Policy works in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"add-sdk.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/add-sdk.md","id":7,"title":"How to add a Temporal SDK to your project","description":"A Temporal SDK provides a framework for Temporal Application development.","label":"Add SDK","tags":["guide-context"],"markdown_content":"\nA [Temporal SDK](/concepts/what-is-a-temporal-sdk) provides a framework for [Temporal Application](/concepts/what-is-a-temporal-application) development.\n\nAn SDK provides you with the following:\n\n- A [Temporal Client](/concepts/what-is-a-temporal-client) to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n- APIs to use within your [Workflows](/concepts/what-is-a-workflow).\n- APIs to create and manage [Worker Processes](/concepts/what-is-a-worker).\n","is_empty":false},{"file_name":"advanced-visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/advanced-visibility.md","id":8,"title":"How to use Advanced Visibility application features","description":"Advanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through a custom SQL-like List Filter.","label":"Advanced Visibility","tags":["guide-context"],"markdown_content":"\n[Advanced Visibility](concepts/advanced-visibility), within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through a custom SQL-like [List Filter](/concepts/what-is-a-list-filter).\n","is_empty":false},{"file_name":"api-reference.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/api-reference.md","id":9,"title":"How to find an SDK API reference","description":"Each SDK has its own API reference. Select a programming language and follow the link to be taken to that reference page.","label":"API reference","tags":["guide-context"],"markdown_content":"\nEach SDK has its own API reference. Select a programming language and follow the link to be taken to that reference page.\n","is_empty":false},{"file_name":"async-activity-completion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/async-activity-completion.md","id":10,"title":"How to asynchronously complete an Activity","description":"Asynchronous Activity Completion enables the Activity Function to return without the Activity Execution completing.","label":"Asynchronous Activity Completion","tags":["guide-context"],"markdown_content":"\n[Asynchronous Activity Completion](/concepts/what-is-asynchronous-activity-completion) enables the Activity Function to return without the Activity Execution completing.\n\nThere are three steps to follow:\n\n1. The Activity provides the external system with identifying information needed to complete the Activity Execution.\n   Identifying information can be a [Task Token](/concepts/what-is-a-task-token), or a combination of Namespace, Workflow Id, and Activity Id.\n2. The Activity Function completes in a way that identifies it as waiting to be completed by an external system.\n3. The Temporal Client is used to Heartbeat and complete the Activity.\n","is_empty":false},{"file_name":"child-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/child-workflows.md","id":11,"title":"How to start a Child Workflow Execution","description":"A Child Workflow Execution is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.","label":"Child Workflows","tags":["guide-context"],"markdown_content":"\nA [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) is a Workflow Execution that is scheduled from within another Workflow using a Child Workflow API.\n\nWhen using a Child Workflow API, Child Workflow related Events ([StartChildWorkflowExecutionInitiated](/references/events#startchildworkflowexecutioninitiated), [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted), [ChildWorkflowExecutionCompleted](/references/events#childworkflowexecutioncompleted), etc...) are logged in the Workflow Execution Event History.\n\nAlways block progress until the [ChildWorkflowExecutionStarted](/references/events#childworkflowexecutionstarted) Event is logged to the Event History to ensure the Child Workflow Execution has started.\nAfter that, Child Workflow Executions may be abandoned using the default _Abandon_ [Parent Close Policy](/concepts/what-is-a-parent-close-policy) set in the Child Workflow Options.\n","is_empty":false},{"file_name":"code-samples.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/code-samples.md","id":12,"title":"Where are SDK-specific code examples?","description":"You can find a complete list of executable code samples in Temporal's GitHub repository.","label":"Code samples","tags":["guide-context"],"markdown_content":"\nYou can find a complete list of executable code samples in [Temporal's GitHub repository](https://github.com/temporalio).\n\nThe [Temporal Simple Polyglot](https://github.com/temporalio/temporal-polyglot) repository showcases how Workflow Executions, written in different languages, can send messages to each other. Go, Java, PHP, and TypeScript SDKs are represented in this sample. It also shows how to properly propagate errors, including how to do so across Workflows written in different languages. For more information, see the [Polyglot Microservice Orchestration](https://www.youtube.com/playlist?list=PLl9kRkvFJrlTLo5URV5IK6lCmiM3ir3f5) video on YouTube.\n\nAdditionally, several of the [Tutorials](https://learn.temporal.io) are backed by a fully executable template application.\n","is_empty":false},{"file_name":"connect-to-a-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/connect-to-a-cluster.md","id":13,"title":"How to connect a Temporal Client to a Temporal Cluster","description":"When connecting a Temporal Client to a Temporal Cluster, you must provide the address and port number of the Temporal Cluster.","label":"Client & Cluster connection","tags":["guide-context"],"markdown_content":"\nWhen connecting a Temporal Client to a Temporal Cluster, you must provide the address and port number of the Temporal Cluster.\n\n- To connect to our Docker image, use `127.0.0.1:7233`.\n- To connect to a Temporal Cloud Namespace use `<Namespace_ID>.tmprl.cloud`.\n\n:::note\n\nThe difference between the gRPC and Temporal Web endpoints:\n\n- The gRPC endpoint has a DNS address of `<Namespace_ID>.tmprl.cloud`; for example, `accounting-production.f45a2.tmprl.cloud`.\n- The Temporal Web endpoint is `web.<Namespace_ID>.tmprl.cloud`; for example, `https://web.accounting-production.f45a2.tmprl.cloud`.\n\n:::\n","is_empty":false},{"file_name":"continue-as-new.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/continue-as-new.md","id":14,"title":"How to Continue-As-New","description":"Continue-As-New enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.","label":"Continue-As-New","tags":["guide-context"],"markdown_content":"\n[Continue-As-New](/concepts/what-is-continue-as-new) enables a Workflow Execution to close successfully and create a new Workflow Execution in a single atomic operation if the number of Events in the Event History is becoming too large.\nThe Workflow Execution spawned from the use of Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\n","is_empty":false},{"file_name":"creating-temporal-clients.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/creating-temporal-clients.md","id":15,"title":"How to create a Temporal Client","description":"A Temporal Client is needed to create Worker Entities and to communicate with a Temporal Cluster.","label":"Create Temporal Client","tags":["guide-context"],"markdown_content":"\nA [Temporal Client](/temporal#temporal-client) is needed to [run Worker Processes](#run-worker-processes) and to communicate with a [Temporal Cluster](/clusters).\nCommunication with the Temporal Cluster includes, but is not limited to, starting Workflow Executions, sending Signals to Workflow Executions, sending Queries to Workflow Executions, and getting the result of a Workflow Execution.\n\nA Temporal Client cannot be initialized and used inside Workflow code.\nHowever, it is acceptable and common to use a Temporal Client inside an Activity, to communicate with the Temporal Cluster.\n","is_empty":false},{"file_name":"cron-jobs.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/cron-jobs.md","id":16,"title":"How to use Temporal Cron Jobs","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Jobs","tags":["guide-context"],"markdown_content":"\nA [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\nA Cron Schedule is provided as an option when the call to spawn a Workflow Execution is made.\n","is_empty":false},{"file_name":"custom-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/custom-logging.md","id":17,"title":"How to provide a custom logger","description":"Use a custom logger for logging.","label":"Custom logger","tags":["guide-context"],"markdown_content":"\nUse a custom logger for logging.\n","is_empty":false},{"file_name":"customize-activity-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/customize-activity-type.md","id":18,"title":"How to customize your Activity Type","description":"You can set a custom name for your Activity Type.","label":"Activity Type","tags":["guide-context"],"markdown_content":"\nYou can set a custom name for your Activity Type.\n","is_empty":false},{"file_name":"customize-workflow-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/customize-workflow-type.md","id":19,"title":"How to customize your Workflow Type","description":"You can set a custom name for your Workflow Type.","label":"Customize Workflow Type","tags":["guide-context"],"markdown_content":"\nYou can set a custom name for your Workflow Type.\n","is_empty":false},{"file_name":"define-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/define-query.md","id":20,"title":"How to define a Query","description":"A Query has a name and can have arguments.","label":"Define Query","tags":["guide-context"],"markdown_content":"\nA Query has a name and can have arguments.\n\n- The name, also called a Query type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter/).\n","is_empty":false},{"file_name":"define-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/define-signal.md","id":21,"title":"How to define a Signal","description":"A Signal has a name and can have arguments.","label":"Define Signal","tags":["guide-context"],"markdown_content":"\nA Signal has a name and can have arguments.\n\n- The name, also called a Signal type, is a string.\n- The arguments must be [serializable](/concepts/what-is-a-data-converter/).\n","is_empty":false},{"file_name":"developing-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/developing-activities.md","id":22,"title":"How to develop a basic Activity","description":"One of the primary things that Workflows do is orchestrate the execution of Activities.","label":"Develop Activities","tags":["guide-context"],"markdown_content":"\nOne of the primary things that Workflows do is orchestrate the execution of Activities.\nActivities are normal function/method executions that can interact with the world.\nFor the Workflow to be able to execute the Activity, we must define the [Activity Definition](/concepts/what-is-an-activity-definition).\n","is_empty":false},{"file_name":"developing-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/developing-workflows.md","id":23,"title":"How to develop a basic Workflow","description":"Workflows are the fundamental unit of a Temporal Application, and it all starts with the development of a Workflow Definition.","label":"Develop Workflows","tags":["guide-context"],"markdown_content":"\nWorkflows are the fundamental unit of a Temporal Application, and it all starts with the development of a [Workflow Definition](/concepts/what-is-a-workflow-definition).\n","is_empty":false},{"file_name":"environment-variables.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/environment-variables.md","id":24,"title":"How to read and pass environment variables","description":"Environment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.","label":"Environment variables","tags":["guide-context"],"markdown_content":"\nEnvironment variables can be provided in the normal way for our language to our Client, Worker, and Activity code.\nThey can't be used normally with Workflow code, as that would be [nondeterministic](workflows#intrinsic-non-deterministic-logic) (if the environment variables changed between Workflow replays, the code that used them would behave differently).\n\nMost of the time, you can provide environment variables in your Activity function; however, if you need them in your Workflow functions, you can use the following options:\n\n- Provide environment variables as arguments when starting the Workflow.\n- Call a Local Activity at the beginning of the Workflow that returns environment variables.\n\nIn either case, the environment variables will appear in Event History, so you may want to use an [encryption Data Converter](/concepts/what-is-a-data-converter/#encryption).\n","is_empty":false},{"file_name":"features.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/features.md","id":25,"title":"How to use Workflow and Activity features","description":"The Features section of the Temporal Application development guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.","label":"Features","tags":["guide-context"],"markdown_content":"\nThe Features section of the Temporal Application development guide provides basic implementation guidance on how to use many of the development features available to Workflows and Activities in the Temporal Platform.\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Application development guide, it could be in [older docs for SDKs](/sdks).\n\n:::\n\nIn this section you can find the following:\n\n- [How to develop Signals](#signals)\n- [How to develop Queries](#queries)\n- [How to start a Child Workflow Execution](#child-workflows)\n- [How to start a Temporal Cron Job](#cron-jobs)\n- [How to use Continue-As-New](#continue-as-new)\n- [How to set Workflow timeouts & retries](#workflow-timeouts--retries)\n- [How to set Activity timeouts & retries](#activity-timeouts--retries)\n- [How to Heartbeat an Activity](#activity-heartbeats)\n- [How to Asynchronously complete an Activity](#async-activity-completion)\n","is_empty":false},{"file_name":"foundations.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/foundations.md","id":26,"title":"How to build a basic Temporal Application","description":"The Foundations section of the Temporal Application development guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application—that is, all the relevant steps to start a Workflow Execution that executes an Activity.","label":"Foundations","tags":["guide-context"],"markdown_content":"\nThe Foundations section of the Temporal Application development guide covers the minimum set of concepts and implementation details needed to build and run a [Temporal Application](/concepts/what-is-a-temporal-application)—that is, all the relevant steps to start a [Workflow Execution](/concepts/what-is-a-workflow-execution) that executes an [Activity](/concepts/what-is-an-activity-execution).\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Application development guide, it could be in [older docs for SDKs](/sdks).\n\n:::\n\nIn this section you can find the following:\n\n- [How to run a dev Cluster](#run-a-dev-cluster)\n- [How to add your SDK](#add-your-sdk)\n- [How to create a Temporal Client](#create-temporal-clients)\n- [How to develop a Workflow](#develop-workflows)\n- [How to develop an Activity](#develop-activities)\n- [How to start an Activity Execution](#start-activity-execution)\n- [How to run a Worker Process](#run-worker-processes)\n- [How to start a Workflow Execution](#start-workflow-execution)\n","is_empty":false},{"file_name":"get-activity-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/get-activity-results.md","id":27,"title":"How to get the results of an Activity Execution","description":"The call to spawn an Activity Execution generates the ScheduleActivityTask Command and provides the Workflow with an Awaitable.","label":"Get Activity results","tags":["guide-context"],"markdown_content":"\nThe call to spawn an [Activity Execution](/concepts/what-is-an-activity-execution) generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command and provides the Workflow with an Awaitable.\nWorkflow Executions can either block progress until the result is available through the Awaitable or continue progressing, making use of the result when it becomes available.\n","is_empty":false},{"file_name":"get-workflow-results.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/get-workflow-results.md","id":28,"title":"How to get the results of a Workflow Execution","description":"If the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.","label":"Get Workflow results","tags":["guide-context"],"markdown_content":"\nIf the call to start a Workflow Execution is successful, you will gain access to the Workflow Execution's Run Id.\n\nThe Workflow Id, Run Id, and Namespace may be used to uniquely identify a Workflow Execution in the system and get its result.\n\nIt's possible to both block progress on the result (synchronous execution) or get the result at some other point in time (asynchronous execution).\n\nIn the Temporal Platform, it's also acceptable to use Queries as the preferred method for accessing the state and results of Workflow Executions.\n","is_empty":false},{"file_name":"handle-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/handle-query.md","id":29,"title":"How to handle a Query","description":"Queries are handled by your Workflow.","label":"Handle Query","tags":["guide-context"],"markdown_content":"\nQueries are handled by your Workflow.\n\nDon’t include any logic that causes [Command](/concepts/what-is-a-command) generation within a Query handler (such as executing Activities).\nIncluding such logic causes unexpected behavior.\n","is_empty":false},{"file_name":"handle-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/handle-signal.md","id":30,"title":"How to handle a Signal","description":"Workflows listen for Signals by the Signal's name.","label":"Handle Signal","tags":["guide-context"],"markdown_content":"\nWorkflows listen for Signals by the Signal's name.\n","is_empty":false},{"file_name":"heartbeat-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/heartbeat-timeout.md","id":31,"title":"How to set a Heartbeat Timeout","description":"A Heartbeat Timeout works in conjunction with Activity Heartbeats.","label":"Heartbeat Timeout","tags":["guide-context"],"markdown_content":"\nA [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout) works in conjunction with [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n","is_empty":false},{"file_name":"list-filter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/list-filter.md","id":32,"title":"How to use List Filters in Advanced Visibility APIs","description":"A List Filter is the SQL-like string that is provided as the parameter to an Advanced Visibility List API.","label":"List Filter","tags":["guide-context"],"markdown_content":"\nA List Filter is the SQL-like string that is provided as the parameter to an [Advanced Visibility](/concepts/what-is-advanced-visibility) List API.\n\nA List Filter contains [Search Attribute](/concepts/what-is-a-search-attribute) names, Search Attribute values, and Operators.\n\n- The following operators are supported in List Filters:\n\n  - **AND, OR, ()**\n  - **=, !=, >, >=, <, <=**\n  - **IN**\n  - **BETWEEN ... AND**\n  - **ORDER BY**\n\n- A List Filter applies to a single Namespace.\n\n- The range of a List Filter timestamp (`StartTime`, `CloseTime`, `ExecutionTime`) cannot exceed `9223372036854775807` (that is, `maxInt64: 1001`).\n\n- A List Filter that uses a time range has a resolution of 1 ms on Elasticsearch 6 and 1 ns on Elasticsearch 7.\n\n- List Filter Search Attribute names are case-sensitive.\n\n- An Advanced List Filter API may take longer than expected if it is retrieving more than 10 million Workflow Executions.\n\n- A `ListWorkflow` API supports pagination.\n  Use the page token in the following call to retrieve the next page; continue until the page token is `null` or `nil`.\n\n- To efficiently count the number of Workflow Executions, use the `CountWorkflow` API.\n","is_empty":false},{"file_name":"logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/logging.md","id":33,"title":"How to log from a Workflow","description":"Send logs and errors to a logging service, so that when things go wrong, you can see what happened.","label":"Logging","tags":["guide-context"],"markdown_content":"\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nThe SDK core uses `WARN` for its default logging level.\n","is_empty":false},{"file_name":"metrics.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/metrics.md","id":34,"title":"How to emit metrics","description":"Each Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.","label":"Metrics","tags":["guide-context"],"markdown_content":"\nEach Temporal SDK is capable of emitting an optional set of metrics from either the Client or the Worker process.\nFor a complete list of metrics capable of being emitted, see the [SDK metrics reference](/references/sdk-metrics).\n\nMetrics can be scraped and stored in time series databases, such as:\n\n- [Prometheus](https://prometheus.io/docs/introduction/overview/)\n- [M3db](https://m3db.io/docs/)\n- [statsd](https://github.com/statsd/statsd)\n\nTemporal also provides a dashboard you can integrate with graphing services like [Grafana](https://grafana.com/docs/). For more information, see:\n\n- Temporal's implementation of the [Grafana dashboard](https://github.com/temporalio/dashboards)\n- [How to export metrics in Grafana](https://github.com/temporalio/helm-charts#exploring-metrics-via-grafana)\n","is_empty":false},{"file_name":"observability.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/observability.md","id":35,"title":"How to use Temporal Observability features","description":"The observability section of the Temporal Application development guide covers the many ways to view the current state of your Temporal Application—that is, ways to view which Workflow Executions are tracked by the Temporal Platform and the state of any specified Workflow Execution, either currently or at points of an execution","label":"Observability","tags":["guide-context"],"markdown_content":"\nThe observability section of the Temporal Application development guide covers the many ways to view the current state of your [Temporal Application](/concepts/what-is-a-temporal-application)—that is, ways to view which [Workflow Executions](/concepts/what-is-a-workflow-execution) are tracked by the [Temporal Platform](/concepts/what-is-the-temporal-platform) and the state of any specified Workflow Execution, either currently or at points of an execution.\n\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete or missing for some languages.\nInformation may change at any time.\n\nIf you can't find what you are looking for in the Application development guide, it could be in [older docs for SDKs](/sdks).\n\n:::\n\nThis section covers features related to viewing the state of the application, including:\n\n- [Metrics](#metrics)\n- [Tracing](#tracing)\n- [Logging](#logging)\n- [Visibility](#visibility)\n- [Replays](#replays)\n","is_empty":false},{"file_name":"parent-close-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/parent-close-policy.md","id":36,"title":"How to set a Parent Close Policy","description":"A Parent Close Policy determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).","label":"Parent Close Policy","tags":["guide-context"],"markdown_content":"\nA [Parent Close Policy](/concepts/what-is-a-parent-close-policy) determines what happens to a Child Workflow Execution if its Parent changes to a Closed status (Completed, Failed, or Timed Out).\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/queries.md","id":37,"title":"How to develop with Queries","description":"A Query is a synchronous operation that is used to get the state of a Workflow Execution.","label":"Queries","tags":["guide-context"],"markdown_content":"\nA [Query](/concepts/what-is-a-query) is a synchronous operation that is used to get the state of a Workflow Execution.\n","is_empty":false},{"file_name":"registering-types.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/registering-types.md","id":38,"title":"How to register types","description":"How to register Workflow and Activity Types","label":"Register types","tags":["guide-context"],"markdown_content":"\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it fails that Task.\nHowever, the failure of the Task does not cause the associated Workflow Execution to fail.\n","is_empty":false},{"file_name":"remove-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/remove-search-attributes.md","id":39,"title":"How to remove a Search Attribute from a Workflow","description":"To remove a Search Attribute that was previously set, set it to an empty array.","label":"Remove Search Attribute","tags":["guide-context"],"markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array: `[]`.\n","is_empty":false},{"file_name":"replays.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/replays.md","id":40,"title":"How to Replay a Workflow Execution","description":"Replays recreate the exact state the Workflow code was in.","label":"Replays","tags":["guide-context"],"markdown_content":"\nReplays recreate the exact state the Workflow code was in. You can replay Workflows from the beginning of their history when resumed.\n\nReplays allow code to resume only if it is compatible from a deterministic point of view.\n","is_empty":false},{"file_name":"required-activity-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/required-activity-timeout.md","id":41,"title":"How to set the required Activity Timeouts","description":"The only required value that needs to be set is either a Schedule-To-Close Timeout or a Start-To-Close Timeout","label":"Required timeout","tags":["guide-context"],"markdown_content":"\nActivity Execution semantics rely on several parameters.\nThe only required value that needs to be set is either a [Schedule-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) or a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout).\nThese values are set in the Activity Options.\n","is_empty":false},{"file_name":"run-worker-processes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/run-worker-processes.md","id":42,"title":"How to run Worker Processes","description":"The Worker Process is where Workflow Functions and Activity Functions are executed.","label":"Run Worker Processes","tags":["guide-context"],"markdown_content":"\nThe [Worker Process](/concepts/what-is-a-worker-process) is where Workflow Functions and Activity Functions are executed.\n\n- Each [Worker Entity](/concepts/what-is-a-worker-entity) in the Worker Process must register the exact Workflow Types and Activity Types it may execute.\n- Each Worker Entity must also associate itself with exactly one [Task Queue](/concepts/what-is-a-task-queue).\n- Each Worker Entity polling the same Task Queue must be registered with the same Workflow Types and Activity Types.\n\nA [Worker Entity](/concepts/what-is-a-worker-entity) is the component within a Worker Process that listens to a specific Task Queue.\n\nAlthough multiple Worker Entities can be in a single Worker Process, a single Worker Entity Worker Process may be perfectly sufficient.\nFor more information, see the [Worker tuning guide](/application-development/worker-performance).\n\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it can make progress for either a Workflow Execution or an Activity Execution.\n","is_empty":false},{"file_name":"schedule-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/schedule-to-close.md","id":43,"title":"How to set a Schedule-To-Close Timeout","description":"Use the Schedule-To-Close Timeout to limit the maximum duration of an Activity Execution.","label":"Schedule-To-Close","tags":["guide-context"],"markdown_content":"\nUse the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) to limit the maximum duration of an [Activity Execution](/concepts/what-is-an-activity-execution).\n","is_empty":false},{"file_name":"schedule-to-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/schedule-to-start.md","id":44,"title":"How to set a Schedule-To-Start Timeout","description":"Use the Schedule-To-Start Timeout to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.","label":"Schedule-To-Start","tags":["guide-context"],"markdown_content":"\nUse the [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout) to limit the maximum amount of time that an Activity Task can be enqueued to be picked up by a Worker.\n","is_empty":false},{"file_name":"search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/search-attributes.md","id":45,"title":"How to use Search Attributes","description":"Search Attributes enable complex List Filters to find the exact of Workflow Executions you are looking for.","label":"Search Attributes","tags":["guide-context"],"markdown_content":"\nThe typical method of retrieving a Workflow Execution is by its Workflow Id.\n\nHowever, sometimes you'll want to retrieve one or more Workflow Executions based on another property. For example, imagine you want to get all Workflow Executions of a certain type that have failed within a time range, so that you can start new ones with the same arguments.\n\nYou can do this with [Search Attributes](/concepts/what-is-a-search-attribute/).\n\n- [**Default** Search Attributes](/concepts/what-is-a-search-attribute/#default-search-attributes) like `WorkflowType`, `StartTime` and `ExecutionStatus` are automatically added to Workflow Executions.\n- _Custom Search Attributes_ can contain their own domain-specific data (like `customerId` or `numItems`).\n  - A few [generic Custom Search Attributes](/concepts/what-is-a-search-attribute/#custom-search-attributes) like `CustomKeywordField` and `CustomIntField` are created by default in Temporal's [Docker Compose](/clusters/quick-install/#docker-compose).\n\nThe steps to using custom Search Attributes are:\n\n- Create a new Search Attribute in your Cluster [using `tctl`](/tctl/admin/cluster/add-search-attributes) or the Cloud UI.\n- Set the value of the Search Attribute for a Workflow Execution:\n  - On the Client by including it as an option when starting the Execution.\n  - In the Workflow by calling `UpsertSearchAttributes`.\n- Read the value of the Search Attribute:\n  - On the Client by calling `DescribeWorkflow`.\n  - In the Workflow by looking at `WorkflowInfo`.\n- Query Workflow Executions by the Search Attribute using a [List Filter](/concepts/what-is-a-list-filter/):\n  - [In `tctl`](/tctl/workflow/list/#--query).\n  - In code by calling `ListWorkflowExecutions`.\n\nHere is how to query Workflow Executions:\n","is_empty":false},{"file_name":"send-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/send-query.md","id":46,"title":"How to send a Query","description":"Queries are sent from a Temporal Client.","label":null,"tags":["guide-context"],"markdown_content":"\nQueries are sent from a Temporal Client.\n","is_empty":false},{"file_name":"send-signal-from-client.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/send-signal-from-client.md","id":47,"title":"How to send a Signal from a Temporal Client","description":"When a Signal is sent successfully from the Temporal Client, the WorkflowExecutionSignaled Event appears in the Event History of the Workflow that receives the Signal.","label":"Send Signal from Client","tags":["guide-context"],"markdown_content":"\nWhen a Signal is sent successfully from the Temporal Client, the [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the Event History of the Workflow that receives the Signal.\n","is_empty":false},{"file_name":"send-signal-from-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/send-signal-from-workflow.md","id":48,"title":"How to send a Signal from a Workflow","description":"A Workflow can send a Signal to another Workflow, in which case it's called an External Signal","label":"Send Signal from Workflow","tags":["guide-context"],"markdown_content":"\nA Workflow can send a Signal to another Workflow, in which case it's called an _External Signal_.\n\nWhen an External Signal is sent:\n\n- A [SignalExternalWorkflowExecutionInitiated](/references/events#signalexternalworkflowexecutioninitiated) Event appears in the sender's Event History.\n- A [WorkflowExecutionSignaled](/references/events#workflowexecutionsignaled) Event appears in the recipient's Event History.\n","is_empty":false},{"file_name":"set-cluster-address.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/set-cluster-address.md","id":49,"title":"How to set a Cluster address on a Temporal Client","description":"Specify a host and optional port.","label":"Set Cluster address","tags":["guide-context"],"markdown_content":"\nSpecify a host and optional port.\n\n- Host default: `127.0.0.1`\n- Port default: `7233`\n\nYour address will be in the following form: `web.<Namespace_ID>.tmprl.cloud`\n\nNote the difference between the gRPC and Temporal Web endpoints:\n\n- The gRPC endpoint has a DNS address of `<Namespace_ID>.tmprl.cloud`; for example, `accounting-production.f45a2.tmprl.cloud`.\n- The Temporal Web endpoint is `web.<Namespace_ID>.tmprl.cloud`; for example, `https://web.accounting-production.f45a2.tmprl.cloud`.\n","is_empty":false},{"file_name":"set-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/set-custom-search-attributes.md","id":50,"title":"How to set custom Search Attributes","description":"After you've created custom Search Attributes in your Cluster (using `tctl` or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.","label":"Custom Search Attributes","tags":["guide-context"],"markdown_content":"\nAfter you've created custom Search Attributes in your Cluster ([using `tctl`](/tctl/admin/cluster/add-search-attributes) or the Cloud UI), you can set the values of the custom Search Attributes when starting a Workflow.\n","is_empty":false},{"file_name":"set-mtls-config.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/set-mtls-config.md","id":51,"title":"How to set mTLS for a Temporal Client","description":"When connecting to the Temporal Cloud with mTLS, you must provide the a certificate and a private key.","label":"Set mTLS","tags":["guide-context"],"markdown_content":"\nWhen connecting to the Temporal Cloud with mTLS, you must provide the following configuration details:\n\n- Client certificate for mTLS\n- Client private key for mTLS\n\nFor information about generating Client certification, see the [temporalio/client-certificate-generation](https://hub.docker.com/r/temporalio/client-certificate-generation) Docker image to generate Client-side certificates along with keys and configuration files.\n​\nThis Docker image is to be used in conjunction with the Temporal SDK.\nKeys and their configuration files are valid for 365 days from creation.\n\nFor information about configuring TLS to secure network communication with and within Temporal Cluster, see [Temporal Customization Samples](https://github.com/temporalio/samples-server).\n\nFor more information about mTLS, see [How to manage certificates](cloud/how-to-manage-certificates-in-temporal-cloud.md) in the Temporal Cloud user guide.\n","is_empty":false},{"file_name":"set-namespace.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/set-namespace.md","id":52,"title":"How to set a Namespace","description":"Namespaces are a logical unit of isolation within the Temporal Platform","label":"Set Namespace","tags":["guide-context"],"markdown_content":"\n[Namespaces](/concepts/what-is-a-namespace) are a logical unit of isolation within the Temporal Platform.\n\nTo set a custom Namespace, register your custom Namespace with the Temporal Cluster first, and then set it in the Temporal Client with the Client Options.\n\nTo register a Namespace, use `tctl --namespace your-custom-namespace namespace register`.\n\nFor more information, see [tctl namespace reference](/tctl/namespace/register).\n","is_empty":false},{"file_name":"set-task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/set-task-queue.md","id":53,"title":"How to set a Workflow's Task Queue","description":"In most SDKs, the only Workflow Option that must be set is the name of the Task Queue.","label":"Set Task Queue","tags":["guide-context"],"markdown_content":"\nIn most SDKs, the only Workflow Option that must be set is the name of the [Task Queue](/concepts/what-is-a-task-queue).\n\nFor any code to execute, a Worker Process must be running that contains a Worker Entity that is polling the same Task Queue name.\n","is_empty":false},{"file_name":"set-workflow-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/set-workflow-id.md","id":54,"title":"How to set a Workflow Id","description":"Although it is not required, we recommend providing your own Workflow Id that maps to a business process or business entity identifier, such as an order identifier or customer identifier.","label":"Workflow Id","tags":["guide-context"],"markdown_content":"\nAlthough it is not required, we recommend providing your own [Workflow Id](/concepts/what-is-a-workflow-id) that maps to a business process or business entity identifier, such as an order identifier or customer identifier.\n","is_empty":false},{"file_name":"signal-with-start.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/signal-with-start.md","id":55,"title":"How to Signal-With-Start","description":"Signal-With-Start is used from the Client","label":"Signal-With-Start","tags":["guide-context"],"markdown_content":"\nSignal-With-Start is used from the Client.\nIt takes a Workflow Id, Workflow arguments, a Signal name, and Signal arguments.\n\nIf there's a Workflow running with the given Workflow Id, it will be signaled. If there isn't, a new Workflow will be started and immediately signaled.\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/signals.md","id":56,"title":"How to develop with Signals","description":"A Signal is a message sent to a running Workflow Execution","label":"Signals","tags":["guide-context"],"markdown_content":"\nA [Signal](/concepts/what-is-a-signal) is a message sent to a running Workflow Execution.\n\nSignals are defined in your code and handled in your Workflow Definition.\nSignals can be sent to Workflow Executions from a Temporal Client or from another Workflow Execution.\n","is_empty":false},{"file_name":"spawning-activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/spawning-activities.md","id":57,"title":"How to start an Activity Execution","description":"Calls to spawn Activity Executions are written within a Workflow Definition.","label":"Activity Execution","tags":["guide-context"],"markdown_content":"\nCalls to spawn [Activity Executions](/concepts/what-is-an-activity-execution) are written within a [Workflow Definition](/concepts/what-is-a-workflow-definition).\nThe call to spawn an Activity Execution generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nThis results in the set of three [Activity Task](/concepts/what-is-an-activity-task) related Events ([ActivityTaskScheduled](/references/events/#activitytaskscheduled), [ActivityTaskStarted](/references/events/#activitytaskstarted), and ActivityTask[Closed])in your Workflow Execution Event History.\n\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the Execution history.\nThe entire Execution history is transferred from the Temporal service to Workflow Workers when a Workflow state needs to recover.\nA large Execution history can thus adversely impact the performance of your Workflow.\n\nTherefore, be mindful of the amount of data you transfer through Activity invocation parameters or Return Values.\nOtherwise, no additional limitations exist on Activity implementations.\n","is_empty":false},{"file_name":"spawning-workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/spawning-workflows.md","id":58,"title":"How to start a Workflow Execution","description":"Workflow Execution semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.","label":"Start Workflow Execution","tags":["guide-context"],"markdown_content":"\n[Workflow Execution](/concepts/what-is-a-workflow-execution) semantics rely on several parameters—that is, to start a Workflow Execution you must supply a Task Queue that will be used for the Tasks (one that a Worker is polling), the Workflow Type, language-specific contextual data, and Workflow Function parameters.\n\nIn the examples below, all Workflow Executions are started using a Temporal Client.\nTo spawn Workflow Executions from within another Workflow Execution, use either the [Child Workflow](#child-workflows) or External Workflow APIs.\n\nSee the [Customize Workflow Type](#customize-workflow-type) section to see how to customize the name of the Workflow Type.\n\nA request to spawn a Workflow Execution causes the Temporal Cluster to create the first Event ([WorkflowExecutionStarted](/references/events/#workflowexecutionstarted)) in the Workflow Execution Event History.\nThe Temporal Cluster then creates the first Workflow Task, resulting in the first [WorkflowTaskScheduled](/references/events/#workflowtaskscheduled) Event.\n","is_empty":false},{"file_name":"start-to-close.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/start-to-close.md","id":59,"title":"How to set a Start-To-Close Timeout","description":"Use the Start-To-Close Timeout to limit the maximum duration of a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["guide-context"],"markdown_content":"\nUse the [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout) to limit the maximum duration of a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n","is_empty":false},{"file_name":"tracing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/tracing.md","id":60,"title":"How to setup Tracing","description":"Tracing allows you to view the call graph of a Workflow along with its Activities and any child Workflows.","label":"Tracing","tags":["guide-context"],"markdown_content":"\nTracing allows you to view the call graph of a Workflow along with its Activities and any child Workflows.\n\nTemporal Web's tracing capabilities mainly track Activity Execution within a Temporal context. If you need custom tracing specific for your use case, you should make use of context propagation to add tracing logic accordingly.\n\nFor information about Workflow tracing, see [Tracing Temporal Workflows with DataDog](https://spiralscout.com/blog/tracing-temporal-workflow-with-datadog).\n\nFor information about how to configure exporters and instrument your code, see [Tracing Temporal Services with OTEL](https://github.com/temporalio/temporal/blob/master/develop/docs/tracing.md).\n","is_empty":false},{"file_name":"upsert-custom-search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/upsert-custom-search-attributes.md","id":61,"title":"How to upsert Search Attributes","description":"You can upsert Search Attributes to add or update Search Attributes from within Workflow code.","label":"Upsert Search Attributes","tags":["guide-context"],"markdown_content":"\nYou can upsert Search Attributes to add or update Search Attributes from within Workflow code.\n","is_empty":false},{"file_name":"visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/visibility.md","id":62,"title":"How to use Visibility APIs","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","tags":["guide-context"],"markdown_content":"\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n","is_empty":false},{"file_name":"workflow-execution-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/workflow-execution-timeout.md","id":63,"title":"How to set a Workflow Execution Timeout","description":"Use the Workflow Execution Timeout to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["guide-context"],"markdown_content":"\nUse the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) to limit the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n","is_empty":false},{"file_name":"workflow-logic-requirements.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/workflow-logic-requirements.md","id":64,"title":"How develop Workflow logic","description":"Workflow logic is constrained by deterministic execution requirements.","label":"Workflow logic requirements","tags":["guide-context"],"markdown_content":"\nWorkflow logic is constrained by [deterministic execution requirements](/concepts/what-is-a-workflow-definition/#deterministic-constraints).\nTherefore, each language is limited to the use of certain idiomatic techniques.\nHowever, each Temporal SDK provides a set of APIs that can be used inside your Workflow to interact with external (to the Workflow) application code.\n","is_empty":false},{"file_name":"workflow-parameters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/workflow-parameters.md","id":65,"title":"How to define Workflow parameters","description":"Temporal Workflows may have any number of custom parameters.","label":"Workflow parameters","tags":["guide-context"],"markdown_content":"\nTemporal Workflows may have any number of custom parameters.\nHowever, it is strongly recommended that objects are used as parameters, so that the object's individual fields may be altered without breaking the signature of the Workflow.\nAll Workflow Definition parameters must be serializable.\n","is_empty":false},{"file_name":"workflow-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/workflow-retry-policy.md","id":66,"title":"How to set a Workflow Retry Policy","description":"Use a Retry Policy to retry a Workflow Execution in the event of a failure.","label":"Workflow Retry Policy","tags":["guide-context"],"markdown_content":"\nUse a [Retry Policy](/concepts/what-is-a-retry-policy) to retry a Workflow Execution in the event of a failure.\n\nWorkflow Executions do not retry by default, and Retry Policies should be used with Workflow Executions only in certain situations.\n","is_empty":false},{"file_name":"workflow-return-values.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/workflow-return-values.md","id":67,"title":"How to define Workflow return parameters","description":"Workflow return values must also be serializable.","label":"Workflow return values","tags":["guide-context"],"markdown_content":"\nWorkflow return values must also be serializable.\nReturning results, returning errors, or throwing exceptions is fairly idiomatic in each language that is supported.\nHowever, Temporal APIs that must be used to get the result of a Workflow Execution will only ever receive one of either the result or the error.\n","is_empty":false},{"file_name":"workflow-run-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/workflow-run-timeout.md","id":68,"title":"How to set a Workflow Run Timeout","description":"Use the Workflow Run Timeout to restrict the maximum amount of time that a single Workflow Run can last.","label":"Workflow Run Timeout","tags":["guide-context"],"markdown_content":"\nUse the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) to restrict the maximum amount of time that a single [Workflow Run](/concepts/what-is-a-workflow-execution/#workflow-execution-chain) can last.\n","is_empty":false},{"file_name":"workflow-task-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/workflow-task-timeout.md","id":69,"title":"How to set a Workflow Task Timeout","description":"Use the Workflow Task Timeout to restrict the maximum amount of time that a Worker can execute a Workflow Task.","label":null,"tags":["guide-context"],"markdown_content":"\nUse the [Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout) to restrict the maximum amount of time that a Worker can execute a [Workflow Task](/concepts/what-is-a-workflow-task).\n","is_empty":false},{"file_name":"workflow-timeouts-and-retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/app-dev-context/workflow-timeouts-and-retries.md","id":70,"title":"Workflow timeouts and retries","description":"Each Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.","label":"Workflow timeouts & retries","tags":["guide-context"],"markdown_content":"\nEach Workflow timeout controls the maximum duration of a different aspect of a Workflow Execution.\nA Retry Policy can work in cooperation with the timeouts to provide fine controls to optimize the execution experience.\n","is_empty":false},{"file_name":"how-to-get-started-with-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/how-to-get-started-with-temporal-cloud.md","id":71,"title":"How to get started with Temporal Cloud","description":"Create an account, get certificates, create a Namespace, and invite users.","label":"Get started","markdown_content":"\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\n:::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\n<!--- Onboarding guide for Temporal Cloud --->\n\nYou received email from Temporal that welcomes you to your new Temporal account.\nYour email address is now the first [Global Admin](/cloud/#account-level-roles) for your account.\n\nTo get started with Temporal Cloud, following these onboarding steps:\n\n<!--- 1. [Create an account.](#create-an-account-in-temporal-cloud) --->\n\n1. [Issue CA certificates](#issue-ca-certificates).\n1. [Create a Namespace](#create-a-namespace).\n1. [Invite users](#invite-users).\n\n## Issue CA certificates\n\nYou must provide your own certificates to access Temporal Cloud.\nFor certificate requirements, see the following:\n\n- [Requirements for CA certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#requirements-for-ca-certificates)\n- [Issue root CA and end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud#issue-root-ca-and-end-entity-certificates)\n\n## Create a Namespace\n\nIf you don't already have a Namespace (or want to create another), see the following:\n\n[Create a Namespace in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud/#create-a-namespace-in-temporal-cloud)\n\n## Invite users\n\n:::caution\n\nAccess to Temporal Cloud is authorized via single sign-on (SSO), currently limited to Google OAuth.\nThe email addresses of all users who need access to Temporal Cloud must be registered with Google.\n\nIf an email address is not associated with a Google Account, the user must follow the instructions in the [Use an existing email address](https://support.google.com/accounts/answer/27441?hl=en#existingemail) section of [Create a Google Account](https://support.google.com/accounts/answer/27441).\n\n**Important:** Do _not_ create a Gmail account when creating a Google Account.\n\n:::\n\nWhen you create a user in Temporal Cloud, the prospective user receives an email invitation.\nBefore accepting the invitation, the user must be logged in to Google using the email address that received the invitation.\nThe user must then click **Accept Invite** in the message.\nAttempting to log in to Temporal Cloud without first accepting the invite doesn't work.\n\n### Roles and permissions\n\nEach user in Temporal Cloud is assigned a Role.\nEach user can be assigned permissions for individual Namespaces.\n\n- [Account-level Roles](/cloud/#account-level-roles)\n- [Namespace-level permissions](/cloud/#namespace-level-permissions)\n\n<!--- How to invite users in Temporal Cloud using Web UI --->\n\n### Invite users using Web UI\n\n1. In Temporal Web UI, click **Settings** in the lower-left portion of the window.\n1. On the **Settings** page, click **Create Users** in the upper-right portion of the window.\n1. On the **Create Users** page in the **Email Addresses** box, type or paste one or more email addresses.\n1. In **Account-Level Role**, select a [Role](/cloud/#account-level-roles).\n   The Role applies to all users whose email addresses appear in **Email Addresses**.\n1. If the account has any Namespaces, they are listed under **Grant access to Namespaces**.\n   To add a permission, select the checkbox next to a Namespace, and then select a [permission](/cloud/#namespace-level-permissions).\n   Repeat as needed.\n1. When all permissions are assigned, click **Send Invite**.\n\nTemporal sends an email message to each user.\nTo join Temporal Cloud, a user must click **Accept Invite** in the message.\n","is_empty":false},{"file_name":"how-to-manage-certificates-in-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/how-to-manage-certificates-in-temporal-cloud.md","id":72,"title":"How to manage certificates in Temporal Cloud","description":"Create certificates and use them to control access to Namespaces.","label":"Manage certificates","markdown_content":"\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\n:::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\nAccess to Temporal Cloud is secured with the mutual Transport Layer Security (mTLS) protocol.\nThis protocol requires a CA certificate from you.\n\nThe benefits of using a CA certificate include the following:\n\n- You can use your CA to issue client certificates to comply with your security policies for certificate expiration and rotation.\n  Client certificates can be issued and rotated without having to configure or update CA certificates shared with Temporal.\n- Temporal does not need to receive certificate private keys.\n  When you configure access to Temporal Cloud, no exchange of secrets is required.\n\n## Requirements for CA certificates\n\nCertificates provided to Temporal for your [Namespaces](/namespaces) _must_ meet the following requirements.\n\n### CA certificates\n\nCA certificates _must_ meet the following criteria:\n\n- The certificates must be X.509v3.\n- Each certificate in the bundle must be either a root certificate or issued by another certificate in the bundle.\n- Each certificate in the bundle must include `CA: true`.\n- A certificate cannot be a well-known CA (such as DigiCert or Let's Encrypt) _unless_ the user also specifies certificate filters.\n- The signing algorithm must include SHA-256 or stronger.\n  SHA-1 and MD5 signing algorithms are rejected.\n\n### End-entity certificates\n\nAn end-entity (leaf) certificate _must_ meet the following criteria:\n\n- The certificate must be X.509v3.\n- Basic constraints must include `CA: false`.\n- The key usage must include Digital Signature.\n- The signing algorithm must include SHA-256 or stronger.\n  SHA-1 and MD5 signing algorithms are rejected.\n\nWhen a client presents an end-entity certificate, and the whole certificate chain is constructed, each certificate in the chain (from end-entity to the root) must have a unique Distinguished Name.\n\n:::caution\n\nDistinguished Names are _not_ case sensitive; that is, uppercase letters (such as ABC) and lowercase letters (such as abc) are equivalent.\n\n:::\n\n## Issue root CA and end-entity certificates\n\nTemporal Cloud authenticates a client connection by validating the client certificate against one or more CA certificates that are configured for the specified Namespace.\n\n### Option 1: You already have certificate management infrastructure\n\nIf your existing certificate management infrastructure supports issuing CA and end-entity certificates, it satisfies the requirements.\nWhen you configure the client SDK, you must present a complete certificate chain up to the CA certificate given to Temporal.\n\n### Option 2: You have no certificate management infrastructure\n\nIf you don't have existing certificate management infrastructure, you can issue the CA and client certificates by using tools such as OpenSSL.\n\nWe also provide a tool that issues one root CA and the required end-entity certificate to use on the client SDK.\nThe tool can issue multiple end-entity certificates.\nWe've kept this tool minimal because it is a demonstration tool; **it is _not_ meant to be used in production.**\n\nYou can use this tool in two ways:\n\n- Follow the instructions for the [temporalio/client-certificate-generation](https://hub.docker.com/r/temporalio/client-certificate-generation) image in Docker Hub.\n  This procedure is the easiest because it's independent of your operating system.\n- Follow the README instructions in the [client-only](https://github.com/temporalio/samples-server/tree/main/tls/client-only) directory in our `temporalio/samples-server` repository in GitHub.\n\n:::info\n\nThe maximum number of CA certificates in a certificate bundle is 16. The payload size of a certificate bundle (before base64-encoding) is 32 KB.\n\n:::\n\n## Control authorization for Temporal Cloud Namespaces\n\nBecause Temporal Cloud uses mTLS for authorization, we recommend that an end-entity certificate be scoped to a specific Namespace.\nTemporal Cloud requires full CA chains, so you can achieve authorization in two ways.\n\n### Option 1: Issue a separate root certificate for each Namespace\n\nEach certificate must belong to a chain up to the root CA certificate.\nTemporal uses the root CA certificate as the trusted authority for access to your Namespaces.\n\n1. Ensure that your certificates meet the [Requirements for client certificates](#requirements-for-client-certificates).\n1. [Add client CA certificates to a Cloud Namespace](/cloud/tcld/namespace/accepted-client-ca/add).\n\n### Option 2: Use the same root certificate for all Namespaces but create a separate certificate filter for each Namespace\n\n[How to manage certificate filters in Temporal Cloud](#manage-certificate-filters-in-temporal-cloud)\n\n## Add, update, and remove certificates in a Temporal Cloud Namespace\n\nTo manage certificates for Temporal Cloud Namespaces, use the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/) commands.\n\n## Manage certificate filters in Temporal Cloud\n\nTo limit access to specific [end-entity certificates](/cloud/how-to-manage-certificates-in-temporal-cloud), you can create certificate filters.\nEach filter contains values for one or more of the following fields:\n\n- commonName (CN)\n- organization (O)\n- organizationalUnit (OU)\n- subjectAlternativeName (SAN)\n\nCorresponding fields in the client certificate must match every specified value in the filter.\n\nThe values for the fields are case-insensitive.\nIf no wildcard is used, each specified value must match its field exactly.\n\nTo match a substring, place a single `*` wildcard at the beginning or end (but not both) of a value.\nYou cannot use a `*` wildcard by itself.\n\nYou can create a maximum of 25 certificate filters in a Namespace.\n\nIf you provide a well-known CA certificate, you cannot clear a certificate filter.\nA well-known CA certificate is one that is typically included in the certificate store of an operating system.\n\n**Examples**\n\nIn the following example, only the CN field of the certificate's subject is checked, and it must be exactly `code.example.com`.\nThe other fields are not checked.\n\n```json\nAuthorizedClientCertificate {\n  CN : \"code.example.com\"\n}\n```\n\nIn the following example, the CN field must be `stage.example.com` and the O field must be `Example Code Inc.`\n\n```json\nAuthorizedClientCertificate {\n  CN : \"stage.example.com\"\n  O : \"Example Code Inc.\"\n}\n```\n\nWhen using a `*` wildcard, the following values are valid:\n\n- `*.example.com` matches `code.example.com` and `text.example.com`.\n- `Example Code*` matches `Example code` and `Example Code Inc`.\n\nThe following values are not valid:\n\n- `.example.*`\n- `code.*.com`\n- `*`\n\n<!--- How to manage certificate filters in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage certificate filters using Temporal Cloud UI\n\nThis functionality is in development.\n\n<!--- How to manage certificate filters in Temporal Cloud using tcld --->\n\n### Manage certificate filters using tcld\n\nTo set or clear certificate filters, use the following [tcld](/cloud/tcld) commands:\n\n- [tcld namespace certificate-filters import](/cloud/tcld/namespace/certificate-filters/import)\n- [tcld namespace certificate-filters clear](/cloud/tcld/namespace/certificate-filters/clear)\n\nTo view the current certificate filters, use the [tcld namespace certificate-filters export](/cloud/tcld/namespace/certificate-filters/export) command.\n","is_empty":false},{"file_name":"how-to-manage-namespaces-in-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/how-to-manage-namespaces-in-temporal-cloud.md","id":73,"title":"How to manage Namespaces in Temporal Cloud","description":"Create Namespaces, use Namespace endpoints for access, and obtain Namespace information.","label":"Manage Namespaces","markdown_content":"\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\n:::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\n- [Create a Namespace](#create-a-namespace-in-temporal-cloud)\n- [Access a Namespace](#access-a-namespace-in-temporal-cloud)\n- [Manage Namesapce](#manage-existing-namespaces-in-temporal-cloud)\n\n## Create a Namespace in Temporal Cloud\n\n:::info\n\nThe user who creates a [Namespace](/namespaces) is automatically granted [Namespace Admin](/cloud/#namespace-level-permissions) permission for that Namespace.\n\n:::\n\n<!--- What information do I need to create a Namespace in Temporal Cloud? --->\n\n### Information needed to create a Namespace\n\nTo create a Namespace in Temporal Cloud, gather the following information:\n\n- [Namespace Name](/cloud/#cloud-namespace), region, and environment\n- [Retention period](/clusters/#retention-period) for [Event History](/workflows#event-history) of closed [Workflow Executions](/workflows#workflow-executions)\n- [CA certificate](/cloud/how-to-manage-certificates-in-temporal-cloud#requirements-for-client-certificates) for the Namespace\n- [Roles](/cloud/#account-level-roles) for each user\n\n<!--- How to create a Namespace in Temporal Cloud using Temporal Cloud UI --->\n\n### Create a Namespace using Temporal Cloud UI\n\n1. Gather the information listed earlier in [Information needed to create a Namespace](#information-needed-to-create-a-namespace).\n1. Go to the Temporal Cloud UI and log in.\n1. On the left side of the window, click **Namespaces**.\n1. On the **Namespaces** page, click **Create Namespace** in the upper-right portion of the window.\n1. On the **Create Namespace** page in **Name**, enter the Namespace Name.\n1. In **Region**, select the region in which to host this Namespace.\n1. In **Retention Period**, select the appropriate timespan. (You can modify this value later.)\n1. In **Certificate**, paste the CA certificate for this Namespace.\n1. Click **Create Namespace**.\n\n<!--- How to create a Namespace in Temporal Cloud using tcld --->\n\n### Create a Namespace using tcld\n\nThis functionality is in development.\n\n## Access a Namespace in Temporal Cloud\n\n<!--- How to access a Namespace in Temporal Cloud --->\n\nEach Namespace in Temporal Cloud has two unique endpoints, both of which include the [Namespace Id](/cloud/#cloud-namespace-id).\n\n- For programmatic access, a gRPC endpoint in the form `<NamespaceId>.tmprl.cloud`; for example, `accounting-production.f45a2.tmprl.cloud:7233`.\n- For accessing Temporal Web UI, an HTTPS endpoint in the form `web.<namespaceId>.tmprl.cloud`; for example, `https://web.accounting-production.f45a2.tmprl.cloud`.\n\n## Manage existing Namespaces in Temporal Cloud\n\n<!--- How to manage Namespaces in Temporal Cloud using Temporal Cloud UI --->\n\n### Manage Namespaces in Temporal Cloud using Temporal Cloud UI\n\nThis functionality is in development.\n\n<!--- How to manage Namespaces in Temporal Cloud using tcld --->\n\n### Manage Namespaces in Temporal Cloud using tcld\n\nTo list Namespaces and get information about them, use the following [tcld](/cloud/tcld/) commands:\n\n- [tcld namespace list](/cloud/tcld/namespace/list)\n- [tcld namespace get](/cloud/tcld/namespace/get)\n\nTo manage certificates, use the [tcld namespace accepted-client-ca](/cloud/tcld/namespace/accepted-client-ca/) commands.\nFor more information, see [How to manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud).\n\nTo manage certificate filters, use the [tcld namespace certificate-filters](/cloud/tcld/namespace/certificate-filters/) commands.\nFor more information, see [How to manage certificate filters in Temporal Cloud](/cloud/#manage-certificate-filters-in-temporal-cloud).\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/index.md","id":74,"title":"Temporal Cloud documentation","description":"Temporal Cloud documentation, including explanations and usage.","label":"Temporal Cloud","markdown_content":"\n<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->\n\nTemporal Cloud is a managed, hosted Temporal environment that provides a platform for [Temporal Applications](/temporal/#temporal-application)—an alternative to deploying and operating your own [Temporal Cluster](/clusters).\n\nTemporal Cloud is offered in units of isolation known as [Namespaces](/namespaces). You can provision and use one or more Cloud Namespaces. A typical use case is to use separate Namespaces as development, testing, integration, staging, and production environments for an application.\n\n:::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\n- [Get started with Temporal Cloud](/cloud/how-to-get-started-with-temporal-cloud)\n- [Manage certificates in Temporal Cloud](/cloud/how-to-manage-certificates-in-temporal-cloud)\n- [Manage Namespaces in Temporal Cloud](/cloud/how-to-manage-namespaces-in-temporal-cloud)\n- [tcld (Temporal Cloud command-line interface)](/cloud/tcld)\n- [Temporal Cloud release notes](/cloud/release-notes)\n\n## Temporal Cloud Account Id\n\nA Temporal Cloud Account Id is a unique identifier for a customer for the entire time they use Temporal Cloud.\nTemporal Technologies assigns each Account Id, which is an opaque code of five or six alphanumeric characters, such as `f45a2`.\n\n## Account-level Roles\n\nWhen a Global Admin invites a user to join an account, the Global Admin selects one of the following Roles for that user:\n\n- **Global Admin**\n  - Has full administrative permissions across the account, including users and usage\n  - Has Namespace Admin [permissions](/cloud/#namespace-level-permissions) on all [Namespaces](/namespaces) in the account\n- **Developer**\n  - Can create and update Namespaces; has full control over [Workflows](/workflows)\n  - Has Namespace Admin permissions for each Namespace created by that user\n- **Read-Only:** Can only read information\n\n## Temporal Cloud Namespace Name\n\nA Cloud Namespace Name is a customer-supplied name for a [Namespace](/namespaces) in Temporal Cloud.\nEach Namespace Name, such as `accounting-production`, is unique within the scope of a customer's account.\nIt cannot be changed after the Namespace is provisioned.\n\nEach Namespace Name must conform to the following rules:\n\n- A Namespace Name must contain at least 2 characters and no more than 34 characters.\n- A Namespace Name must begin with a letter, end with a letter or number, and contain only letters, numbers, and the hyphen (-) character.\n- Each hyphen (-) character must be immediately preceded _and_ followed by a letter or number; consecutive hyphens are not permitted.\n- All letters in a Namespace Name must be lowercase.\n\n## Temporal Cloud Namespace Id\n\nA Cloud Namespace Id is a globally unique identifier for a [Namespace](/namespaces) in Temporal Cloud.\nA Namespace Id is formed by concatenating the following:\n\n1. A [Namespace Name](#temporal-cloud-namespace-name)\n1. A period (.)\n1. The [Account Id](#temporal-cloud-account-id) to which the Namespace belongs\n\nFor example, for the Account Id `f45a2` and Namespace Name `accounting-production`, the Namespace Id is `accounting-production.f45a2`.\n\n## Namespace-level permissions\n\nA [Global Admin](/cloud/#account-level-roles) can assign permissions for any [Namespace](/namespaces) in an account.\nA Developer can assign permissions for a Namespace they create.\n\nFor a Namespace, a user can have one of the following permissions:\n\n- **Namespace Admin:** Can create and edit Namespaces; can create, rename, update, and delete [Workflows](/workflows)\n- **Write:** Can create, rename, update, and delete Workflows within the Namespace\n- **Read-Only:** Can only read information from the Namespace\n","is_empty":false},{"file_name":"tcld/how-to-install-tcld.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/how-to-install-tcld.md","id":75,"title":"How to install tcld","description":"You can install tcld by using Homebrew or building from source.","label":"Install tcld","tags":["operation-guide","tcld"],"markdown_content":"\nYou can install [tcld](/cloud/tcld) in two ways.\n\n### Install tcld by using Homebrew\n\n```bash\nbrew install temporalio/brew/tcld\n```\n\n### Build tcld from source\n\n1. Verify that you have Go 1.18 or later installed.\n\n   ```bash\n   go version\n   ```\n\n   If Go 1.18 or later is not installed, follow the [Download and install](https://go.dev/doc/install) instructions on the Go website.\n\n1. Clone the tcld repository and run make.\n\n   ```bash\n   git clone https://github.com/temporalio/tcld.git\n   cd tcld\n   make\n   ```\n\n1. Copy the tcld executable to any directory that appears in the PATH environment variable, such as `/usr/local/bin`.\n\n   ```bash\n   cp tcld /usr/local/bin/tcld\n   ```\n\n1. Verify that tcld is installed.\n\n   ```bash\n   tcld version\n   ```\n","is_empty":false},{"file_name":"tcld/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/index.md","id":76,"title":"What is tcld?","description":"tcld is a command-line tool that you can use to interact with Temporal Cloud.","tags":["operation-guide","tcld"],"markdown_content":"\n:::note Beta release\n\ntcld is in beta, and access to Temporal Cloud via tcld is restricted.\n\n:::\n\n:::note Join the Temporal Cloud waitlist\n\nAccess to Temporal Cloud is currently by invitation only.\nYou can [join the waitlist](https://pages.temporal.io/cloud-early-access).\n\n:::\n\nThe Temporal Cloud CLI (tcld) is a command-line tool that you can use to interact with Temporal Cloud.\n\n- [How to install tcld](/cloud/tcld/how-to-install-tcld)\n\n## tcld commands\n\n- [`tcld login`](/cloud/tcld/login)\n- [`tcld namespace`](/cloud/tcld/namespace)\n- [`tcld request`](/cloud/tcld/request)\n- [`tcld version`](/cloud/tcld/version)\n\n## Global modifier\n\n### `--auto_confirm`\n\nAutomatically confirm all prompts.\n\nYou can specify the value for this modifier by setting the AUTO_CONFIRM environment variable.\nThe default value is `false`.\n","is_empty":false},{"file_name":"tcld/login.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/login.md","id":77,"title":"tcld login","description":"How to log in to Temporal Cloud using tcld.","label":"login","tags":["reference","tcld"],"markdown_content":"\nThe `tcld login` command logs in a user to Temporal Cloud.\n\nFollow instructions in the browser to log in to your Temporal account.\n\nAlias: `l`\n\n`tcld login`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/version.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/version.md","id":78,"title":"tcld version","description":"How to get version information about tcld.","label":"version","tags":["reference","tcld"],"markdown_content":"\nThe `tcld version` command gets version information about tcld.\n\nAlias: `v`\n\n`tcld version`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/request/get.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/request/get.md","id":79,"title":"tcld request get","description":"How to get the status of an asynchronous request in Temporal Cloud using tcld.","label":"get","tags":["reference","tcld"],"markdown_content":"\nThe `tcld request get` command gets the status of the specified request in Temporal Cloud.\n\n`tcld request get --request-id <request_id>`\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace get --namespace <namespace_id> --request-id <request_id>\n```\n\n### `--request`\n\n_Required modifier_\n\nSpecify a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace get --request-id <request_id>\n```\n","is_empty":false},{"file_name":"tcld/request/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/request/index.md","id":80,"title":"tcld request","description":"How to manage asynchronous requests in Temporal Cloud using tcld.","tags":["reference","tcld"],"markdown_content":"\nThe `tcld request` commands manage asynchronous requests in Temporal Cloud.\n\nAlias: `r`\n\n- [`tcld request get`](/cloud/tcld/request/get)\n","is_empty":false},{"file_name":"tcld/namespace/get.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/get.md","id":81,"title":"tcld namespace get","description":"How to get information about a Namespace in Temporal Cloud using tcld.","label":"get","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace get` command gets information about the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `g`\n\n`tcld namespace get`\n\nThe following modifier controls the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace get --namespace <namespace_id>\n```\n","is_empty":false},{"file_name":"tcld/namespace/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/index.md","id":82,"title":"tcld namespace","description":"How to operate Namespaces in Temporal Cloud using tcld.","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace` commands enable [Namespace](/concepts/what-is-a-namespace) operations in Temporal Cloud.\n\nAlias: `n`\n\n- [`tcld namespace list`](/cloud/tcld/namespace/list)\n- [`tcld namespace get`](/cloud/tcld/namespace/get)\n- [`tcld namespace accepted-client-ca`](/cloud/tcld/namespace/accepted-client-ca)\n- [`tcld namespace certificate-filters`](/cloud/tcld/namespace/certificate-filters)\n- [`tcld namespace search-attributes`](/cloud/tcld/namespace/search-attributes)\n","is_empty":false},{"file_name":"tcld/namespace/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/list.md","id":83,"title":"tcld namespace list","description":"How to list all Namespaces in Temporal Cloud using tcld.","label":"list","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace list` command lists all [Namespaces](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `l`\n\n`tcld namespace list`\n\nThe command has no modifiers.\n","is_empty":false},{"file_name":"tcld/namespace/search-attributes/add.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/search-attributes/add.md","id":84,"title":"tcld namespace search-attributes add","description":"How to add custom Search Attributes to a Namespace in Temporal Cloud using tcld.","label":"add","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace search-attributes add` command adds custom [Search Attributes](/concepts/what-is-a-search-attribute) to a Namespace in Temporal Cloud.\n\n`tcld namespace search-attributes add --search-attribute <value>`\n\nAlias: `a`\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --namespace <namespace_id> --search-attribute <value>\n```\n\n### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --request-id <request_id> --search-attribute <value>\n```\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --resource-version <etag> --search-attribute <value>\n```\n\n### `--search-attribute`\n\n_Required modifier; can be specified more than once_\n\nSpecify a custom Search Attribute in the form \"_name_=_type_\". Valid values for _type_ are as follows:\n\n- Bool\n- Datetime\n- Double\n- Int\n- Keyword\n- Text\n\nAlias: `--sa`\n\n**Example**\n\n```bash\ntcld namespace search-attributes add --search-attribute \"YourSearchAttribute1=Text\" --search-attribute \"YourSearchAttribute2=Double\"\n```\n","is_empty":false},{"file_name":"tcld/namespace/search-attributes/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/search-attributes/index.md","id":85,"title":"tcld namespace search-attributes","description":"How to manage Search Attributes of a Namespace in Temporal Cloud using tcld.","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace search-attributes` commands manage [Search Attributes](/concepts/what-is-a-search-attribute) of the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\nAlias: `sa`\n\n- [`tcld namespace search-attributes add`](/cloud/tcld/namespace/search-attributes/add)\n- [`tcld namespace search-attributes rename`](/cloud/tcld/namespace/search-attributes/rename)\n","is_empty":false},{"file_name":"tcld/namespace/search-attributes/rename.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/search-attributes/rename.md","id":86,"title":"tcld namespace search-attributes rename","description":"How to rename an existing custom Search Attribute in Temporal Cloud using tcld.","label":"rename","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace search-attributes rename` command renames a custom [Search Attribute](/concepts/what-is-a-search-attribute) in Temporal Cloud.\n\n`tcld namespace search-attributes rename --existing-name <value> --new-name <value>`\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --namespace <namespace_id> --existing-name <value> --new-name <value>\n```\n\n### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --request-id <request_id> --existing-name <value> --new-name <value>\n```\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --resource-version <etag> --existing-name <value> --new-name <value>\n```\n\n### `--existing-name`\n\n_Required modifier_\n\nSpecify the name of an existing Search Attribute.\n\nAlias: `--en`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --existing-name <value> --new-name <value>\n```\n\n### `--new-name`\n\n_Required modifier_\n\nSpecify a new name for the Search Attribute.\n\nAlias: `--nn`\n\n**Example**\n\n```bash\ntcld namespace search-attributes rename --existing-name <value> --new-name <value>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/clear.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/certificate-filters/clear.md","id":87,"title":"tcld namespace certificate-filters clear","description":"How to clear all certificate filters from a Namespace in Temporal Cloud using tcld.","label":"clear","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace certificate-filters clear` command clears all certificate filters from a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n:::caution\n\nUsing this command allows _any_ client certificate that chains up to a configured CA certificate to connect to the Namespace.\n\n:::\n\n`tcld namespace certificate-filters clear`\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters clear --namespace <namespace_id>\n```\n\n### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters clear --request-id <request_id>\n```\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters clear --resource-version <etag>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/export.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/certificate-filters/export.md","id":88,"title":"tcld namespace certificate-filters export","description":"How to export certificate filters from a Namespace in Temporal Cloud using tcld.","label":"export","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace certificate-filters export` command exports existing certificate filters from a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace certificate-filters export --certificate-filter-file <path>`\n\nAlias: `exp`\n\nThe following modifiers control the behavior of the command.\n\n### `--certificate-filter-file`\n\nSpecify a path to a JSON file where tcld can export the certificate filters.\n\nAliases: `--file`, `-f`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters export --certificate-filter-file <path>\n```\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --namespace <namespace_id> --certificate-filter-input <json>\n```\n\n### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --request-id <request_id> --certificate-filter-input <json>\n```\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --resource-version <etag> --certificate-filter-input <json>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/import.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/certificate-filters/import.md","id":89,"title":"tcld namespace certificate-filters import","description":"How to set certificate filters for a Namespace in Temporal Cloud using tcld.","label":"import","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace certificate-filters import` command sets certificate filters for a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace certificate-filters import --certificate-filter-file <path>`\n\nAlias: `imp`\n\nA certificate filter can include any combination (and at least one) of the following:\n\n- `commonName`\n- `organization`\n- `organizationalUnit`\n- `subjectAlternativeName`\n\nThe following modifiers control the behavior of the command.\n\n### `--certificate-filter-file`\n\n_Required modifier unless `--certificate-filter-input` is specified_\n\nSpecify a path to a JSON file that defines certificate filters to be applied to the Namespace, such as `{ \"filters\": [ { \"commonName\": \"test1\" } ] }`. The specified filters replace any existing filters.\n\nIf both `--certificate-filter-file` and `--certificate-filter-input` are specified, the command returns an error.\n\nAliases: `--file`, `-f`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --certificate-filter-file <path>\n```\n\n### `--certificate-filter-input`\n\n_Required modifier unless `--certificate-filter-file` is specified_\n\nSpecify a JSON string that defines certificate filters to be applied to the Namespace, such as `{ \"filters\": [ { \"commonName\": \"test1\" } ] }`. The specified filters replace any existing filters.\n\nIf both `--certificate-filter-input` and `--certificate-filter-file` are specified, the command returns an error.\n\nAliases: `--input`, `-i`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --certificate-filter-input <json>\n```\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --namespace <namespace_id> --certificate-filter-input <json>\n```\n\n### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --request-id <request_id> --certificate-filter-input <json>\n```\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace certificate-filters import --resource-version <etag> --certificate-filter-input <json>\n```\n","is_empty":false},{"file_name":"tcld/namespace/certificate-filters/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/certificate-filters/index.md","id":90,"title":"tcld namespace certificate-filters","description":"How to manage certificate filters for a Namespace in Temporal Cloud using tcld.","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace certificate-filters` commands manage optional certificate filters for the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud. The Namespace can use certificate filters to authorize client certificates based on distinguished name (DN) fields.\n\nAlias: `cf`\n\n- [`tcld namespace certificate-filters import`](/cloud/tcld/namespace/certificate-filters/import)\n- [`tcld namespace certificate-filters export`](/cloud/tcld/namespace/certificate-filters/export)\n- [`tcld namespace certificate-filters clear`](/cloud/tcld/namespace/certificate-filters/clear)\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/add.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/accepted-client-ca/add.md","id":91,"title":"tcld namespace accepted-client-ca add","description":"How to add client CA certificates to a Namespace in Temporal Cloud using tcld.","label":"add","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace update accepted-client-ca add` command adds client CA certificates to a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca add --ca-certificate <value>`\n\nAlias: `a`\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --namespace <namespace_id> --ca-certificate <encoded_certificate>\n```\n\n### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --ca-certificate <encoded_certificate>\n```\n\n### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca add --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/accepted-client-ca/index.md","id":92,"title":"tcld namespace accepted-client-ca","description":"How to manage the client CA certificates for a Namespace in Temporal Cloud using tcld.","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace accepted-client-ca` commands manage the client CA certificates of the specified [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud. The certificates are used to verify client connections.\n\n:::important\n\nDo not use a CA certificate that is signed with an insecure signature algorithm, such as SHA-1.\nSuch signatures will be rejected.\nExisting CA certificates that use SHA-1 can stop working without warning.\n\nFor more information about the vulnerabilities of SHA-1, see [SHAttered](https://shattered.io/).\n\n:::\n\nAlias: `ca`\n\n- [`tcld namespace accepted-client-ca add`](/cloud/tcld/namespace/accepted-client-ca/add)\n- [`tcld namespace accepted-client-ca list`](/cloud/tcld/namespace/accepted-client-ca/list)\n- [`tcld namespace accepted-client-ca set`](/cloud/tcld/namespace/accepted-client-ca/set)\n- [`tcld namespace accepted-client-ca remove`](/cloud/tcld/namespace/accepted-client-ca/remove)\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/list.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/accepted-client-ca/list.md","id":93,"title":"tcld namespace accepted-client-ca list","description":"How to list the client CA certificates for a Namespace in Temporal Cloud using tcld.","label":"list","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace accepted-client-ca list` command lists the client CA certificates that are currently configured for a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca list`\n\nAlias: `l`\n\nThe following modifier controls the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca list --namespace <namespace_id>\n```\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/remove.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/accepted-client-ca/remove.md","id":94,"title":"tcld namespace accepted-client-ca remove","description":"How to remove client CA certificates from a Namespace in Temporal Cloud using tcld.","label":"remove","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace accepted-client-ca remove` command removes client CA certificates from a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca remove --ca-certificate <value>`\n\nAlias: `r`\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --namespace <namespace_id> --ca-certificate <encoded_certificate>\n```\n\n### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate-file` is specified_\n\nSpecify the base64-encoded string of a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate` and `--ca-certificate-file` are ignored.\n\nIf `--ca-certificate-file` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --ca-certificate <encoded_certificate>\n```\n\n### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate-fingerprint` or `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf `--ca-certificate-fingerprint` is also specified, both `--ca-certificate-file` and `--ca-certificate` are ignored.\n\nIf `--ca-certificate` is also specified but `--ca-certificate-fingerprint` is not, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --ca-certificate-file <path>\n```\n\n### `--ca-certificate-fingerprint`\n\n_Required modifier unless `--ca-certificate` or `--ca-certificate-file` is specified_\n\nSpecify the fingerprint of a CA certificate.\n\nIf `--ca-certificate`, `--ca-certificate-file`, or both are also specified, they are ignored.\n\nAlias: `--fp`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca remove --ca-certificate-fingerprint <fingerprint>\n```\n","is_empty":false},{"file_name":"tcld/namespace/accepted-client-ca/set.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cloud/tcld/namespace/accepted-client-ca/set.md","id":95,"title":"tcld namespace accepted-client-ca set","description":"How to set the client CA certificates for a Namespace in Temporal Cloud using tcld.","label":"set","tags":["reference","tcld"],"markdown_content":"\nThe `tcld namespace accepted-client-ca set` command sets the client CA certificates for a [Namespace](/concepts/what-is-a-namespace) in Temporal Cloud.\n\n`tcld namespace accepted-client-ca set --ca-certificate <value>`\n\nAlias: `s`\n\n<!--- How to rollover accepted client CA certificates in Temporal Cloud using tcld --->\n\nWhen updating CA certificates, it's important to follow a rollover process.\nDoing so enables your Namespace to serve both CA certificates for a period of time until traffic to your old CA certificate ceases.\n\n1. Create a single file that contains both your old and new CA certificate PEM blocks.\n   Just concatenate the PEM blocks on adjacent lines.\n\n   ```\n   -----BEGIN CERTIFICATE-----\n   ... old CA cert ...\n   -----END CERTIFICATE-----\n   -----BEGIN CERTIFICATE-----\n   ... new CA cert ...\n   -----END CERTIFICATE-----\n   ```\n\n1. Run the `tcld namespace accepted-client-ca set` command with the CA certificate bundle file.\n\n   ```bash\n   tcld namespace accepted-client-ca set --ca-certificate-file <path>\n   ```\n\n1. Monitor traffic to your old certificate until it ceases.\n\n1. Create another file that contains only the new CA certificate.\n\n1. Run the `tcld namespace accepted-client-ca set` command again with the updated CA certificate bundle file.\n\nThe following modifiers control the behavior of the command.\n\n### `--namespace`\n\nSpecify a Namespace hosted on Temporal Cloud. If not specified, the value of the environment variable $TEMPORAL_CLOUD_NAMESPACE is used.\n\nAlias: `-n`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --namespace <namespace_id> --ca-certificate <encoded_certificate>\n```\n\n### `--request-id`\n\nSpecify a request identifier to use for the asynchronous operation. If not specified, the server assigns a request identifier.\n\nAlias: `-r`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n### `--resource-version`\n\nSpecify a resource version (ETag) to update from. If not specified, the latest version is used.\n\nAlias: `-v`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n### `--ca-certificate`\n\n_Required modifier unless `--ca-certificate-file` is specified_\n\nSpecify a base64-encoded string of a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-c`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --ca-certificate <encoded_certificate>\n```\n\n### `--ca-certificate-file`\n\n_Required modifier unless `--ca-certificate` is specified_\n\nSpecify a path to a CA certificate PEM file.\n\nIf both `--ca-certificate` and `--ca-certificate-file` are specified, only `--ca-certificate` is used.\n\nAlias: `-f`\n\n**Example**\n\n```bash\ntcld namespace accepted-client-ca set --ca-certificate-file <path>\n```\n","is_empty":false},{"file_name":"archival.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cluster-ops-context/archival.md","id":96,"title":"How to use Archival","description":"Archival is a feature that automatically backs up Workflow Execution Event Histories and Visibility data from Temporal Cluster persistence to a custom blob store.","label":"Archival","tags":["guide-context"],"markdown_content":"\n[Archival](/concepts/what-is-archival) is a feature that automatically backs up Workflow Execution Event Histories and Visibility data from Temporal Cluster persistence to a custom blob store.\n","is_empty":false},{"file_name":"intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/cluster-ops-context/intro.md","id":97,"title":"How to deploy a Temporal Cluster","description":"This guide is a work in progress","label":"Deploy a Temporal Cluster","tags":["guide-context"],"markdown_content":"\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete.\nInformation may change at any time.\n\nLegacy production deployment information is available [here](/server/production-deployment)\n\n:::\n","is_empty":false},{"file_name":"how-to-create-a-custom-archiver.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/clusters/how-to-create-a-custom-archiver.md","id":98,"title":"How to create a custom Archiver","description":"todo","label":"Custom Archiver","tags":["how-to"],"markdown_content":"\nTo archive data with a given provider, using the [Archival](/concepts/what-is-archival) feature, Temporal must have a corresponding Archiver component installed.\nThe platform does not limit you to the existing providers.\nTo use a provider that is not currently supported, you can create your own Archiver.\n\n#### Create a new package\n\nThe first step is to create a new package for your implementation in [/common/archiver](https://github.com/temporalio/temporal/tree/master/common/archiver).\nCreate a directory in the archiver folder and arrange the structure to look like the following:\n\n```\ntemporal/common/archiver\n  - filestore/                      -- Filestore implementation\n  - provider/\n      - provider.go                 -- Provider of archiver instances\n  - yourImplementation/\n      - historyArchiver.go          -- HistoryArchiver implementation\n      - historyArchiver_test.go     -- Unit tests for HistoryArchiver\n      - visibilityArchiver.go       -- VisibilityArchiver implementations\n      - visibilityArchiver_test.go  -- Unit tests for VisibilityArchiver\n```\n\n#### Archiver interfaces\n\nNext, define objects that implement the [HistoryArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L80) and the [VisibilityArchiver](https://github.com/temporalio/temporal/blob/master/common/archiver/interface.go#L121) interfaces.\n\nThe objects should live in `historyArchiver.go` and `visibilityArchiver.go`, respectively.\n\n#### Update provider\n\nUpdate the `GetHistoryArchiver` and `GetVisibilityArchiver` methods of the `archiverProvider` object in the [/common/archiver/provider/provider.go](https://github.com/temporalio/temporal/blob/master/common/archiver/provider/provider.go) file so that it knows how to create an instance of your archiver.\n\n#### Add configs\n\nAdd configs for your archiver to the `config/development.yaml` file and then modify the [HistoryArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L376) and [VisibilityArchiverProvider](https://github.com/temporalio/temporal/blob/master/common/config/config.go#L393) structs in `/common/common/config.go` accordingly.\n\n#### Custom archiver FAQ\n\n**If my custom Archive method can automatically be retried by the caller, how can I record and access progress between retries?**\n\nHandle this situation by using `ArchiverOptions`.\nHere is an example:\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n    var progress progress\n    // Check if the feature for recording progress is enabled.\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.LoadProgress(ctx, & prevProgress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n\n    // Your archiver implementation...\n\n    // Record current progress\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.RecordProgress(ctx, progress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n}\n```\n\n**If my `Archive` method encounters an error that is non-retryable, how do I indicate to the caller that it should not retry?**\n\n```go\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n\n    err: = youArchiverImpl()\n\n    if nonRetryableErr(err) {\n        if featureCatalog.NonRetryableError != nil {\n            return featureCatalog.NonRetryableError() // when the caller gets this error type back it will not retry anymore.\n        }\n    }\n}\n```\n\n**How does my history archiver implementation read history?**\n\nThe archiver package provides a utility called [HistoryIterator](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) which is a wrapper of [ExecutionManager](https://github.com/temporalio/temporal/blob/master/common/persistence/dataInterfaces.go#L1014).\n`HistoryIterator` is more simple than the `HistoryManager`, which is available in the BootstrapContainer, so archiver implementations can choose to use it when reading Workflow histories.\nSee the [historyIterator.go](https://github.com/temporalio/temporal/blob/master/common/archiver/historyIterator.go) file for more details.\nUse the [filestore historyArchiver implementation](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) as an example.\n\n**Should my archiver define its own error types?**\n\nEach archiver is free to define and return its own errors.\nHowever, many common errors that exist between archivers are already defined in [common/archiver/constants.go](https://github.com/temporalio/temporal/blob/master/common/archiver/constants.go).\n\n**Is there a generic query syntax for the visibility archiver?**\n\nCurrently, no.\nBut this is something we plan to do in the future.\nAs for now, try to make your syntax similar to the one used by our advanced list Workflow API.\n\n- [s3store](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store#visibility-query-syntax)\n- [gcloud](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud#visibility-query-syntax)\n","is_empty":false},{"file_name":"how-to-integrate-elasticsearch-into-a-temporal-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster.md","id":99,"title":"How to integrate Elasticsearch into a Temporal Cluster","description":"To integrate Elasticsearch with your Temporal Cluster, edit the `persistence` section of your `development.yaml` configuration file and run the index schema setup commands.","label":"Elasticsearch","tags":["operation-guide","filtered-lists","visibility"],"markdown_content":"\n[Advanced Visibility](/concepts/what-is-advanced-visibility) features depend on an integration with Elasticsearch.\n\nTo integrate Elasticsearch with your Temporal Cluster, edit the `persistence` section of your `development.yaml` configuration file and run the index schema setup commands.\n\n:::note\n\nThese steps are needed only if you have a \"plain\" [Temporal Server Docker image](https://hub.docker.com/r/temporalio/server).\n\nIf you operate a Temporal Cluster using our [Helm charts](https://github.com/temporalio/helm-charts) or\n[docker-compose](https://github.com/temporalio/docker-compose), the Elasticsearch index schema and index are created automatically using the [auto-setup Docker image](https://hub.docker.com/r/temporalio/auto-setup).\n\n:::\n\n:::note Supported versions\n\n- Elasticsearch v7.10 is supported from Temporal version 1.7.0 onwards\n- Elasticsearch v6.8 is supported in all Temporal versions\n- Both versions are explicitly supported with AWS Elasticsearch\n\n:::\n\n#### Edit persistence\n\n1. Add the `advancedVisibilityStore: es-visibility` key-value pair to the `persistence` section.\n   The [development_es.yaml](https://github.com/temporalio/temporal/blob/master/config/development_es.yaml) file in the `temporalio/temporal` repo is a working example.\n   The configuration instructs the Temporal Cluster how and where to connect to Elasticsearch storage.\n\n```yaml\npersistence:\n  ...\n  advancedVisibilityStore: es-visibility\n```\n\n2. Define the Elasticsearch datastore connection information under the `es-visibility` key:\n\n```yaml\npersistence:\n  ...\n  advancedVisibilityStore: es-visibility\n  datastores:\n    ...\n    es-visibility:\n      elasticsearch:\n        version: \"v7\"\n        url:\n          scheme: \"http\"\n          host: \"127.0.0.1:9200\"\n        indices:\n          visibility: temporal_visibility_v1_dev\n```\n\n#### Create index schema and index\n\nRun the following commands to create the index schema and index:\n\n```bash\n# ES_SERVER is the URL of Elasticsearch server; for example, \"http://localhost:9200\".\nSETTINGS_URL=\"${ES_SERVER}/_cluster/settings\"\nSETTINGS_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/cluster_settings_${ES_VERSION}.json\nTEMPLATE_URL=\"${ES_SERVER}/_template/temporal_visibility_v1_template\"\nSCHEMA_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/index_template_${ES_VERSION}.json\nINDEX_URL=\"${ES_SERVER}/${ES_VIS_INDEX}\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SETTINGS_URL}\" -H \"Content-Type: application/json\" --data-binary \"@${SETTINGS_FILE}\" --write-out \"\\n\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${TEMPLATE_URL}\" -H 'Content-Type: application/json' --data-binary \"@${SCHEMA_FILE}\" --write-out \"\\n\"\ncurl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${INDEX_URL}\" --write-out \"\\n\"\n```\n\n#### Set Elasticsearch privileges\n\nEnsure that the following privileges are granted for the Elasticsearch Temporal index:\n\n- **Read**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `create`, `index`, `delete`, `read`\n- **Write**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `write`\n- **Custom Search Attributes**\n  - [index privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-indices): `manage`\n  - [cluster privileges](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html#privileges-list-cluster): `monitor` or `manage`.\n\n#### Add custom Search Attributes (optional)\n\nThis step is optional.\nHere we are adding custom Search Attributes to your Cluster.\n\nRun the following `tctl` command to add the `ProductId` custom Search Attribute to the Temporal Cluster (and Elasticsearch Temporal index):\n\n```bash\ntctl admin cluster add-search-attributes --name ProductId --type Keyword\n```\n\nRun the following `tctl` command to add custom Search Attributes used by samples and SDK integration tests:\n\n```bash\ntctl --auto_confirm admin cluster add-search-attributes \\\n    --name CustomKeywordField --type Keyword \\\n    --name CustomStringField --type Text \\\n    --name CustomTextField --type Text \\\n    --name CustomIntField --type Int \\\n    --name CustomDatetimeField --type Datetime \\\n    --name CustomDoubleField --type Double \\\n    --name CustomBoolField --type Bool\n```\n","is_empty":false},{"file_name":"how-to-set-up-archival.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/clusters/how-to-set-up-archival.md","id":100,"title":"How to set up Archival","description":"This guide covers Temporal's archiving capabilities and how to set up the Archival feature.","label":"Set up Archival","tags":["how-to"],"markdown_content":"\n[Archival](/concepts/what-is-archival) consists of the following elements:\n\n- **Configuration**: Archival is controlled by the [server configuration](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L81) (i.e. the `config/development.yaml` file).\n- **Provider**: Location where the data should be archived. Supported providers are S3, GCloud, and the local file system.\n- **URI**: Specifies which provider should be used. The system uses the URI schema and path to make the determination.\n\nTake the following steps to set up Archival:\n\n1. [Set up the provider](#providers) of your choice.\n2. [Configure Archival](#configuration).\n3. [Create a Namespace](#namespace-creation) that uses a valid URI and has Archival enabled.\n\n#### Providers\n\nTemporal directly supports several providers:\n\n- **Local file system**: The [filestore archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/filestore) is used to archive data in the file system of whatever host the Temporal server is running on. This provider is used mainly for local installations and testing and should not be relied on for production environments.\n- **Google Cloud**: The [gcloud archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/gcloud) is used to connect and archive data with [Google Cloud](https://cloud.google.com/storage).\n- **S3**: The [s3store archiver](https://github.com/temporalio/temporal/tree/master/common/archiver/s3store) is used to connect and archive data with [S3](https://aws.amazon.com/s3).\n- **Custom**: If you want to use a provider that is not currently supported, you can [create your own archiver](/clusters/how-to-create-a-custom-archiver) to support it.\n\nMake sure that you save the provider's storage location URI in a place where you can reference it later, because it is passed as a parameter when you [create a Namespace](#namespace-creation).\n\n#### Configuration\n\nArchival configuration is defined in the [`config/development.yaml`](https://github.com/temporalio/temporal/blob/master/config/development.yaml#L93) file.\nLet's look at an example configuration:\n\n```yaml\n# Cluster level Archival config\narchival:\n  # Event History configuration\n  history:\n    # Archival is enabled at the cluster level\n    state: \"enabled\"\n    enableRead: true\n    # Namespaces can use either the local filestore provider or the Google Cloud provider\n    provider:\n      filestore:\n        fileMode: \"0666\"\n        dirMode: \"0766\"\n      gstorage:\n        credentialsPath: \"/tmp/gcloud/keyfile.json\"\n\n# Default values for a Namespace if none are provided at creation\nnamespaceDefaults:\n  # Archival defaults\n  archival:\n    # Event History defaults\n    history:\n      state: \"enabled\"\n      # New Namespaces will default to the local provider\n      URI: \"file:///tmp/temporal_archival/development\"\n```\n\nYou can disable Archival by setting `archival.history.state` and `namespaceDefaults.archival.history.state` to `\"disabled\"`.\n\nExample:\n\n```yaml\narchival:\n  history:\n    state: \"disabled\"\n\nnamespaceDefaults:\n  archival:\n    history:\n      state: \"disabled\"\n```\n\nThe following table showcases acceptable values for each configuration and what purpose they serve.\n\n| Config                                         | Acceptable values                                                                  | Description                                                                                                                  |\n| ---------------------------------------------- | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\n| `archival.history.state`                       | `enabled`, `disabled`                                                              | Must be `enabled` to use the Archival feature with any Namespace in the cluster.                                             |\n| `archival.history.enableRead`                  | `true`, `false`                                                                    | Must be `true` to read from the archived Event History.                                                                      |\n| `archival.history.provider`                    | Sub provider configs are `filestore`, `gstorage`, `s3`, or `your_custom_provider`. | Default config specifies `filestore`.                                                                                        |\n| `archival.history.provider.filestore.fileMode` | File permission string                                                             | File permissions of the archived files. We recommend using the default value of `\"0666\"` to avoid read/write issues.         |\n| `archival.history.provider.filestore.dirMode`  | File permission string                                                             | Directory permissions of the archive directory. We recommend using the default value of `\"0766\"` to avoid read/write issues. |\n| `namespaceDefaults.archival.history.state`     | `enabled`, `disabled`                                                              | Default state of the Archival feature whenever a new Namespace is created without specifying the Archival state.             |\n| `namespaceDefaults.archival.history.URI`       | Valid URI                                                                          | Must be a URI of the file store location and match a schema that correlates to a provider.                                   |\n\n#### Namespace creation\n\nAlthough Archival is configured at the cluster level, it operates independently within each Namespace.\nIf an Archival URI is not specified when a Namespace is created, the Namespace uses the value of `defaultNamespace.archival.history.URI` from the `config/development.yaml` file.\nThe Archival URI cannot be changed after the Namespace is created.\nEach Namespace supports only a single Archival URI, but each Namespace can use a different URI.\nA Namespace can safely switch Archival between `enabled` and `disabled` states as long as Archival is enabled at the cluster level.\n\nArchival is supported in [Global Namespaces](/concepts/what-is-a-global-namespace/) (Namespaces that span multiple clusters).\nWhen Archival is running in a Global Namespace, it first runs on the active cluster; later it runs on the standby cluster. Before archiving, a history check is done to see what has been previously archived.\n\n#### Test setup\n\nTo test Archival locally, start by running a Temporal server:\n\n```bash\n./temporal-server start\n```\n\nThen register a new Namespace with Archival enabled.\n\n```bash\n./tctl --ns samples-namespace namespace register --gd false --history_archival_state enabled --retention 3\n```\n\n:::note\n\nIf the retention period isn't set, it defaults to 2 days.\nThe minimum retention period is 1 day.\nThe maximum retention period is 30 days.\n\nSetting the retention period to 0 results in the error _A valid retention period is not set on request_.\n\n:::\n\nNext, run a sample Workflow such as the [helloworld temporal sample](https://github.com/temporalio/temporal-go-samples/tree/master/helloworld).\n\nWhen execution is finished, Archival occurs.\n\n#### Retrieve archives\n\nYou can retrieve archived Event Histories by copying the `workflowId` and `runId` of the completed Workflow from the log output and running the following command:\n\n```bash\n./temporal --ns samples-namespace wf show --wid <workflowId> --rid <runId>\n```\n","is_empty":false},{"file_name":"how-to-set-up-codec-server.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/clusters/how-to-set-up-codec-server.md","id":101,"title":"How to set up a Codec Server","description":"Implementation of a remote encryption/decryption server.","label":"Codec Server","markdown_content":"\nThe [Codec Server Go sample](https://github.com/temporalio/samples-go/tree/main/codec-server) is an example that shows how to decode a Payload that has been encoded so the Payload can be displayed by [tctl](/tctl) and the [Web UI](/web-ui).\n\nA codec HTTP protocol specifies two endpoints to handle Payload encoding and decoding.\n\nImplementations must do the following:\n\n- Send and receive Payloads protobuf as JSON.\n- Check only the final part of the incoming URL to determine whether the request is for /encode or /decode.\n\n:::note\nA Temporal Cluster should already be in operation before starting the Codec Server.\n:::\n\n## tctl\n\n[Start up the Codec Server](https://github.com/temporalio/samples-go/tree/main/codec-server).\n\nConfigure the codec endpoint:\n\n```bash\ntctl --codec_endpoint 'http://localhost:{PORT}/{namespace}' workflow show --wid codecserver_workflowID\n```\n\n## Web UI\n\n```yaml\ncodec:\n    endpoint: {{ default .Env.TEMPORAL_CODEC_ENDPOINT \"{namespace}\"}}\n```\n\nThe [codec endpoint](/references/ui-configuration#codec) can be specified in the configuration file.\nIt can also be changed during runtime.\n\nSelect the button with two arrows in the top right area of the screen.\nThis action displays the codec endpoint dialog.\n\nEnter the URL and port number for your codec endpoint.\nExit the dialog, go back to the previous page, and refresh the page.\n\nThe button should now be light blue, and your Payloads should be displayed in a readable format.\n","is_empty":false},{"file_name":"how-to-set-up-multi-cluster-replication.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/clusters/how-to-set-up-multi-cluster-replication.md","id":102,"title":"How to set up Multi-Cluster Replication","description":"Multi-Cluster Replication can be enabled by setting the appropriate values in the `clusterMetadata` section of your configuration file.","label":"Set up Multi-Cluster Replication","tags":["how-to","cluster"],"markdown_content":"\nThe [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication) feature asynchronously replicates Workflow Execution Event Histories from active Clusters to other passive Clusters, and can be enabled by setting the appropriate values in the `clusterMetadata` section of your configuration file.\n\n1. `enableGlobalNamespace` must be set to `true`.\n2. `failoverVersionIncrement` has to be equal across connected Clusters.\n3. `initialFailoverVersion` in each Cluster has to assign a different value.\n   No equal value is allowed across connected Clusters.\n\nAfter the above conditions are satisfied, you can start to configure a multi-cluster setup.\n\n#### Set up Multi-Cluster Replication prior to v1.14\n\nYou can set this up with [`clusterMetadata` configuration](/references/configuration#clustermetadata); however, this is meant to be only a conceptual guide rather than a detailed tutorial.\nPlease reach out to us if you need to set this up.\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\n#### Set up Multi-Cluster Replication in v1.14 and later\n\nYou still need to set up local cluster [`clusterMetadata` configuration](/references/configuration#clustermetadata)\n\nFor example:\n\n```yaml\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: false\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterB\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\nThen you can use the `tctl admin` tool to add cluster connections. All operations should be executed in both Clusters.\n\n```shell\n# Add cluster B connection into cluster A\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\"\n# Add cluster A connection into cluster B\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\"\n\n# Disable connections\ntctl -address 127.0.0.1:7233 admin cluster upsert-remote-cluster --frontend_address \"localhost:8233\" --enable_connection false\ntctl -address 127.0.0.1:8233 admin cluster upsert-remote-cluster --frontend_address \"localhost:7233\" --enable_connection false\n\n# Delete connections\ntctl -address 127.0.0.1:7233 admin cluster remove-remote-cluster --cluster \"clusterB\"\ntctl -address 127.0.0.1:8233 admin cluster remove-remote-cluster --cluster \"clusterA\"\n```\n","is_empty":false},{"file_name":"how-to-upgrade-the-temporal-server-version.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/clusters/how-to-upgrade-the-temporal-server-version.md","id":103,"title":"How to upgrade the Temporal Server version","description":"If a newer version of the Temporal Server is available, a notification appears in the Temporal Web UI.","label":"Upgrade Server","tags":["how-to"],"markdown_content":"\nIf a newer version of the [Temporal Server](/concepts/what-is-the-temporal-server) is available, a notification appears in the Temporal Web UI.\n\n:::info\n\nIf you are using a version that is older than 1.0.0, reach out to us at [community.temporal.io](http://community.temporal.io) to ask how to upgrade.\n\n:::\n\nFirst check to see if an upgrade to the database schema is required for the version you wish to upgrade to.\nIf a database schema upgrade is required, it will be called out directly in the [release notes](https://github.com/temporalio/temporal/releases).\nSome releases require changes to the schema, and some do not.\nWe ensure that any consecutive versions are compatible in terms of database schema upgrades, features, and system behavior, however there is no guarantee that there is compatibility between _any_ 2 non-consecutive versions.\n\nUse one of the upgrade tools to upgrade your database schema to be compatible with the Temporal Server version being upgraded to.\n\nIf you are using a schema tools version prior to 1.8.0, we strongly recommend _never_ using the \"dryrun\" (`-y`, or `--dryrun`) options in any of your schema update commands.\nUsing this option might lead to potential loss of data, as when using it will create a new database and drop your\nexisting one.\nThis flag was removed in the 1.8.0 release.\n\n### Upgrade Cassandra schema\n\nIf you are using Cassandra for your Cluster's persistence, use the `temporal-cassandra-tool` to upgrade both the default and visibility schemas.\n\n**Example default schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/temporal/versioned\n\n```\n\n**Example visibility schema upgrade:**\n\n```bash\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal_visibility \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/visibility/versioned\n\n```\n\n### Upgrade MySQL / PostgreSQL schema\n\nIf you are using MySQL or PostgreSQL use the `temporal-sql-tool`, which works similarly to the `temporal-cassandra-tool`.\n\nRefer to this [Makefile](https://github.com/temporalio/temporal/blob/v1.4.1/Makefile#L367-L383) for context.\n\n#### PostgreSQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal update-schema -d ./schema/postgresql/v96/temporal/versioned\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal_visibility update-schema -d ./schema/postgresql/v96/visibility/versioned\n```\n\n#### MySQL\n\n**Example default schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal update-schema -d ./schema/mysql/v57/temporal/versioned/\n```\n\n**Example visibility schema upgrade:**\n\n```bash\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal_visibility update-schema -d ./schema/mysql/v57/visibility/versioned/\n```\n\n### Roll-out technique\n\nWe recommend preparing a staging Cluster and then do the following to verify the upgrade is successful:\n\n1. Create some simulation load on the staging cluster.\n2. Upgrade the database schema in the staging cluster.\n3. Wait and observe for a few minutes to verify that there is no unstable behavior from both the server and the simulation load logic.\n4. Upgrade the server.\n5. Now do the same to the live environment cluster.\n","is_empty":false},{"file_name":"quick-install.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/clusters/quick-install.md","id":104,"title":"How to quickly install a Temporal Cluster for testing and local development","description":"There are four ways to quickly install and run a Temporal Cluster.","label":"Quick install","markdown_content":"\nWhenever you are developing Temporal Applications, you'll want to have a [Temporal Cluster](/concepts/what-is-a-temporal-cluster) up and running.\nYou can interact with a Cluster through [Temporal Client](/concepts/what-is-a-temporal-client) APIs and [tctl](/tctl) commands.\n\nThere are four ways to quickly install and run a Temporal Cluster:\n\n- [Docker](#docker-compose): Using Docker Compose makes it easy to develop your Temporal Application locally.\n- [Gitpod](#gitpod): One-click deployments are available for Go and TypeScript.\n- [Helm charts](#helm-charts): Deploying a Cluster to [Kubernetes](https://kubernetes.io/) is an easy way to test the system and develop Temporal Applications.\n- [Render](#render): Our [temporalio/docker-compose](https://github.com/temporalio/docker-compose) experience has been translated to Render's Blueprint format for an alternative cloud connection.\n\n**We do not recommend using any of these methods in a [full (production) environment](/server/production-deployment).**\n\n#### Docker Compose\n\nUse Docker Compose and Temporal Cluster Docker images to quickly install and run a Temporal Cluster locally while developing Workflows.\n\nYou must have [Docker](https://docs.docker.com/engine/install) and [Docker Compose](https://docs.docker.com/compose/install) installed.\n\nThen clone the [temporalio/docker-compose](https://github.com/temporalio/docker-compose) repository and run `docker-compose up` from the root of that repo:\n\n```bash\ngit clone https://github.com/temporalio/docker-compose.git\ncd  docker-compose\ndocker-compose up\n```\n\nWhen the Temporal Cluster is running, the Temporal Web UI becomes available in your browser: [localhost:8080](http://localhost:8080/)\n\nThe preceding steps start and run a Temporal Cluster using a default configuration.\nTo try other configurations (different dependencies and databases), or to try a custom Docker image, follow the [temporalio/docker-compose README](https://github.com/temporalio/docker-compose/blob/main/README.md).\n\n#### Gitpod\n\nYou can run a Temporal Cluster and develop Temporal Applications in your browser using [Gitpod](https://www.gitpod.io/).\n\nOne-click deployments are available for the [temporalio/samples-go](https://github.com/temporalio/samples-go) repo and the [temporalio/samples-typescript](https://github.com/temporalio/samples-typescript) repo.\n\nA one-click deployment starts a Temporal Cluster using a Temporal Cluster Docker image, starts a Worker Process, and starts one of the application's sample Workflows.\n\nIt can take up to a full minute for the one-click deployments to get fully up and running.\nWhen it is running, you can customize the application samples.\n\n#### Helm charts\n\nUse [Temporal Helm charts](https://github.com/temporalio/helm-charts) to deploy the Temporal Server to a [Kubernetes](https://kubernetes.io/) cluster.\n\nDeploying the Temporal Cluster with Helm is not recommended for a production environment, but it is a great way to test the system while developing Workflows.\n\n#### Render\n\n[temporal-render-simple](https://github.com/temporalio/temporal-render-simple) translates our docker-compose to Render by using the [Auto-Setup Docker image](/blog/auto-setup).\nWe do not recommend using this technique for production because all four Temporal internal services (Frontend, Matching, History, and Worker) are run in one process, but the benefit is one-click deployments.\n\n[Deploy to Render](https://render.com/deploy?repo=https://github.com/temporalio/temporal-render-simple)\n","is_empty":false},{"file_name":"intro.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concept-context/intro.md","id":105,"title":"Temporal core concepts","description":"Temporal core concepts explained","label":"Temporal core concepts","tags":["guide-context"],"markdown_content":"\n:::info WORK IN PROGRESS\n\nThis guide is a work in progress.\nSome sections may be incomplete.\nInformation may change at any time.\n\n:::\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/index.md","id":106,"title":"Concepts","description":"The following concepts have specific definitions within the context of the Temporal Platform.","tags":["references"],"markdown_content":"\nThe following terms have specific definitions within the context of the [Temporal Platform](/concepts/what-is-the-temporal-platform).\n\n- [Activity](/concepts/what-is-an-activity)\n- [Activity Definition](/concepts/what-is-an-activity-definition)\n- [Activity Execution](/concepts/what-is-an-activity-execution)\n- [Activity Heartbeat](/concepts/what-is-an-activity-heartbeat)\n- [Activity Id](/concepts/what-is-an-activity-id)\n- [Activity Task](/concepts/what-is-an-activity-task)\n- [Activity Task Execution](/concepts/what-is-an-activity-task-execution)\n- [Activity Type](/concepts/what-is-an-activity-type)\n- [Advanced Visibility](/concepts/what-is-advanced-visibility)\n- [Archival](/concepts/what-is-archival)\n- [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution)\n- [Command](/concepts/what-is-a-command)\n- [Continue-As-New](/concepts/what-is-continue-as-new)\n- [Data Converter](/concepts/what-is-a-data-converter)\n- [Event](/concepts/what-is-an-event)\n- [Event History](/concepts/what-is-an-event-history)\n- [List Filter](/concepts/what-is-a-list-filter)\n- [Local Activity](/concepts/what-is-a-local-activity)\n- [Namespace](/concepts/what-is-a-namespace)\n- [Parent Close Policy](/concepts/what-is-a-parent-close-policy)\n- [Query](/concepts/what-is-a-query)\n- [Retry Policy](/concepts/what-is-a-retry-policy)\n- [Run Id](/concepts/what-is-a-run-id)\n- [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout)\n- [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout)\n- [Search Attribute](/concepts/what-is-a-search-attribute)\n- [Side Effect](/concepts/what-is-a-side-effect)\n- [Signal](/concepts/what-is-a-signal)\n- [Standard Visibility](/concepts/what-is-standard-visibility)\n- [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout)\n- [Task](/concepts/what-is-a-task)\n- [Task Queue](/concepts/what-is-a-task-queue)\n- [Task Token](/concepts/what-is-a-task-token)\n- [Temporal](/concepts/what-is-temporal)\n- [Temporal Platform](/concepts/what-is-the-temporal-platform)\n- [Temporal SDK](/concepts/what-is-a-temporal-sdk)\n- [Worker](/concepts/what-is-a-worker)\n- [Workflow](/concepts/what-is-a-workflow)\n- [Workflow Definition](/concepts/what-is-a-workflow-definition)\n- [Workflow Execution](/concepts/what-is-a-workflow-execution)\n- [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout)\n- [Workflow Id](/concepts/what-is-a-workflow-id)\n- [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy)\n- [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout)\n- [Workflow Task](/concepts/what-is-a-workflow-task)\n- [Workflow Task Execution](/concepts/what-is-a-workflow-task-execution)\n- [Workflow Task Timeout](/concepts/what-is-a-workflow-task-timeout)\n- [Workflow Type](/concepts/what-is-a-workflow-type)\n","is_empty":false},{"file_name":"what-is-a-child-workflow-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-child-workflow-execution.md","id":107,"title":"What is a Child Workflow Execution?","description":"A Child Workflow Execution is a Workflow Execution that is spawned from within another Workflow.","label":"Child Workflow Execution","tags":["explanation","child-workflow"],"markdown_content":"\nA Child Workflow Execution is a [Workflow Execution](/concepts/what-is-a-workflow-execution) that is spawned from within another Workflow.\n\n- [How to start a Child Workflow Execution](/application-development/features#child-workflows)\n\nA Workflow Execution can be both a Parent and a Child Workflow Execution because any Workflow can spawn another Workflow.\n\n![Parent & Child Workflow Execution entity relationship](/diagrams/parent-child-workflow-execution-relationship.svg)\n\nA Parent Workflow Execution must await on the Child Workflow Execution to spawn.\nThe Parent can optionally await on the result of the Child Workflow Execution.\nConsider the Child's [Parent Close Policy](/concepts/what-is-a-parent-close-policy) if the Parent does not await on the result of the Child, which includes any use of Continue-As-New by the Parent.\n\nWhen a Parent Workflow Execution reaches a Closed status, the Cluster propagates Cancellation Requests or Terminations to Child Workflow Executions depending on the Child's Parent Close Policy.\n\nIf a Child Workflow Execution uses Continue-As-New, from the Parent Workflow Execution's perspective the entire chain of Runs is treated as a single execution.\n\n![Parent & Child Workflow Execution entity relationship with Continue As New](/diagrams/parent-child-workflow-execution-with-continue-as-new.svg)\n\n### When to use Child Workflows\n\n**Consider Workflow Execution Event History size limits.**\n\nAn individual Workflow Execution has an [Event History](/concepts/what-is-an-event-history) size limit, which imposes a couple of considerations for using Child Workflows.\n\nOn one hand, because Child Workflow Executions have their own Event Histories, they are often used to partition large workloads into smaller chunks.\nFor example, a single Workflow Execution does not have enough space in its Event History to spawn 100,000 [Activity Executions](/concepts/what-is-an-activity-execution).\nBut a Parent Workflow Execution can spawn 1,000 Child Workflow Executions that each spawn 1,000 Activity Executions to achieve a total of 1,000,000 Activity Executions.\n\nOn the other hand, because a Parent Workflow Execution Event History contains [Events](/concepts/what-is-an-event) that correspond to the status of the Child Workflow Execution, a single Parent should not spawn more than 1,000 Child Workflow Executions.\n\nIn general, however, Child Workflow Executions result in more overall Events recorded in Event Histories than Activities.\nBecause each entry in an Event History is a _cost_ in terms of compute resources, this could become a factor in very large workloads.\nTherefore, we recommend starting with a single Workflow implementation that uses Activities until there is a clear need for Child Workflows.\n\n**Consider each Child Workflow Execution as a separate service.**\n\nBecause a Child Workflow Execution can be processed by a completely separate set of [Workers](/concepts/what-is-a-worker) than the Parent Workflow Execution, it can act as an entirely separate service.\nHowever, this also means that a Parent Workflow Execution and a Child Workflow Execution do not share any local state.\nAs all Workflow Executions, they can communicate only via asynchronous [Signals](/concepts/what-is-a-signal).\n\n**Consider that a single Child Workflow Execution can represent a single resource.**\n\nAs all Workflow Executions, a Child Workflow Execution can create a one to one mapping with a resource.\nFor example, a Workflow that manages host upgrades could spawn a Child Workflow Execution per host.\n","is_empty":false},{"file_name":"what-is-a-cloud-account-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-cloud-account-id.md","id":108,"title":"What is a Temporal Cloud Account Id?","description":"A Temporal Cloud Account Id is a unique identifier for a customer.","label":"Temporal Cloud Account Id","tags":["explanation"],"markdown_content":"\nA Temporal Cloud Account Id is a unique identifier for a customer for the entire time they use Temporal Cloud.\nTemporal Technologies assigns each Account Id, which is an opaque code of five or six alphanumeric characters, such as `f45a2`.\n","is_empty":false},{"file_name":"what-is-a-cloud-namespace-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-cloud-namespace-id.md","id":109,"title":"What is a Cloud Namespace Id?","description":"A Cloud Namespace Id is a globally unique identifier for a Namespace in Temporal Cloud.","label":"Cloud Namespace Id","tags":["explanation"],"markdown_content":"\nA Cloud Namespace Id is a globally unique identifier for a [Namespace](/namespaces) in Temporal Cloud.\nA Namespace Id is formed by concatenating the following:\n\n1. A [Namespace Name](/concepts/what-is-a-cloud-namespace-name)\n1. A period (.)\n1. The [Account Id](/concepts/what-is-a-cloud-account-id) to which the Namespace belongs\n\nFor example, for the Account Id `f45a2` and Namespace Name `accounting-production`, the Namespace Id is `accounting-production.f45a2`.\n","is_empty":false},{"file_name":"what-is-a-cloud-namespace-name.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-cloud-namespace-name.md","id":110,"title":"What is a Cloud Namespace Name?","description":"A Cloud Namespace Name is a customer-supplied name for a Namespace in Temporal Cloud.","label":"Cloud Namespace Name","tags":["explanation"],"markdown_content":"\nA Cloud Namespace Name is a customer-supplied name for a [Namespace](/namespaces) in Temporal Cloud.\nEach Namespace Name, such as `accounting-production`, is unique within the scope of a customer's account.\nIt cannot be changed after the Namespace is provisioned.\n\nEach Namespace Name must conform to the following rules:\n\n- A Namespace Name must contain at least 2 characters and no more than 34 characters.\n- A Namespace Name must begin with a letter, end with a letter or number, and contain only letters, numbers, and the hyphen (-) character.\n- Each hyphen (-) character must be immediately preceded _and_ followed by a letter or number; consecutive hyphens are not permitted.\n- All letters in a Namespace Name must be lowercase.\n","is_empty":false},{"file_name":"what-is-a-codec-server.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-codec-server.md","id":111,"title":"What is a Codec Server?","description":"Explanation and implementation of a remote encryption/decryption server.","label":"Codec Server","markdown_content":"\nA Codec Server is a feature that can perform additional levels of encoding and decoding on Payloads that are handled by [tctl](/tctl) or the [Web UI](/web-ui).\n\n- [How to set up a Codec Server](/clusters/how-to-set-up-codec-server/)\n\nThe Web UI and tctl both use a default [Data Converter](/concepts/what-is-a-data-converter), which is capable of serialization only.\n\nCodec Servers can encrypt, compress, and change the format of a Payload object.\nThese measures can further secure your data.\n\n![](/img/tctl-diagram-codec-server.svg)\n\n## Use case: tctl\n\nSuppose that you want to view Workflow History.\nThis information needs to be decoded before it can be viewed.\n\nYou can use [tctl workflow showid](/tctl/workflow/showid) to view a Workflow Execution Event History.\n\n```bash\n    tctl workflow showid <workflowID>\n```\n\nWith a Codec Server, the Payload is decoded before being deserialized by tctl's default Data Converter. The default Data Converter sends the Payload to a given endpoint, and receives a decoded Payload if the API returns a successful result.\n\nThe Data Converter passes this result back to the command line, which prints the decoded result.\n\n## Use case - Web UI\n\nWorkflow Execution Event History is available in the Web UI.\nPayload information for each Event is captured within Event 'input' and 'result' fields.\nWithout a Codec Server, this information remains encoded.\n\nPassing these Payloads through a Codec Server returns decoded results to the Web UI.\nMake sure to [enter a valid URL and port](/clusters/how-to-set-up-codec-server#web-ui) for the codec endpoint when configuring the Codec Server.\n","is_empty":false},{"file_name":"what-is-a-command.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-command.md","id":112,"title":"What is a Command?","description":"A Command is a requested action issued by a Worker to the Temporal Cluster after a Workflow Task Execution completes.","label":"Command","tags":["explanation"],"markdown_content":"\nA Command is a requested action issued by a [Worker](/concepts/what-is-a-worker) to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) after a [Workflow Task Execution](/concepts/what-is-a-workflow-task-execution) completes.\n\nThe action that the Cluster takes is recorded in the [Workflow Execution's](/concepts/what-is-a-workflow-execution) [Event History](/concepts/what-is-an-event-history) as an [Event](/concepts/what-is-an-event).\nThe Workflow Execution can await on some of the Events that come as a result from some of the Commands.\n\nCommands are generated by the use of Workflow APIs in your code. During a Workflow Task Execution there may be several Commands that are generated.\nThe Commands are batched and sent to the Cluster as part of the Workflow Task Execution completion request, after the Workflow Task has progressed as far as it can with the Workflow function.\nThere will always be [WorkflowTaskStarted](/references/events/#workflowtaskstarted) and [WorkflowTaskCompleted](/references/events/#workflowtaskcompleted) Events in the Event History when there is a Workflow Task Execution completion request.\n\n![Commands are generated by the use of Workflow APIs in your code](/diagrams/commands.svg)\n\nCommands are described in the [Command reference](/references/commands) and are defined in the [Temporal gRPC API](https://github.com/temporalio/api/blob/master/temporal/api/command/v1/message.proto).\n","is_empty":false},{"file_name":"what-is-a-data-converter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-data-converter.md","id":113,"title":"What is a Data Converter?","description":"A Data Converter is a Temporal SDK component that encodes and decodes data entering and exiting a Temporal Server.","label":"Data Converter","tags":["explanation"],"markdown_content":"\nA Data Converter is a Temporal SDK component that encodes and decodes data entering and exiting a Temporal Server.\n\n- TypeScript: [Data Converters](/typescript/data-converters)\n- Go: [Create a custom Data Converter](/go/how-to-create-a-custom-data-converter-in-go)\n\n![Data Converter encodes and decodes data](/diagrams/default-data-converter.svg)\n\nData is encoded before it is sent to a Temporal Server, and it is decoded when it is received from a Temporal Server.\n\nThe main pieces of data that run through the Data Converter are arguments and return values:\n\n- The Client:\n  - Encodes Workflow, Signal, and Query arguments.\n  - Decodes Workflow and Query return values.\n- The Worker:\n  - Decodes Workflow, Signal, and Query arguments.\n  - Encodes Workflow and Query return values.\n  - Decodes and encodes Activity arguments and return values.\n\nEach piece of data (like a single argument or return value) is encoded as a [`Payload`](https://github.com/temporalio/api/blob/2f980f7ce4349e808b16ec0f21e0fe675f79330f/temporal/api/common/v1/message.proto#L49) Protobuf message, which consists of binary `data` and key-value `metadata`.\n\n## Default Data Converter\n\nEach Temporal SDK includes a default Data Converter.\nIn most SDKs, the default converter supports binary, JSON, and Protobufs.\n(In SDKs that cannot determine parameter types at runtime—like TypeScript—Protobufs aren't included in the default converter.)\nIt tries to encode values in the following order:\n\n- Null\n- Binary\n- Protobuf JSON\n- JSON\n\nFor example:\n\n- If a value is an instance of a Protobuf message, it will be encoded with [proto3 JSON](https://developers.google.com/protocol-buffers/docs/proto3#json).\n- If a value isn't null, binary, or a Protobuf, it will be encoded as JSON. If any part of it is not serializable as JSON (for example, a Date—see [JSON data types](https://en.wikipedia.org/wiki/JSON#Data_types)), an error will be thrown.\n\nThe default converter also supports decoding binary Protobufs.\n\n## Custom Data Converter\n\nApplications can create their own custom Data Converters to alter the format (for example using [MessagePack](https://msgpack.org/) instead of JSON) or add compression or encryption.\n\nTo use a custom Data Converter, provide it in the following contexts:\n\n- The Client and Worker in the SDKs you use.\n- Temporal Web via [`tctl data-converter web`](/tctl/dataconverter/web) (for displaying decoded data in the Web UI).\n- `tctl` via [`--data-converter-plugin`](/tctl/#--data-converter-plugin) (for displaying decoded headers in `tctl` output).\n\nCustom Data Converters are not applied to all data:\n\n- `searchAttributes` are always encoded with JSON.\n- Headers are not encoded by the SDK (the one exception will be—when implemented—the SDK [running OTel baggage through custom Codecs](https://github.com/temporalio/sdk-typescript/issues/514)).\n\n### Payload Codecs\n\nIn [TypeScript](/typescript/data-converters#custom-data-converter) and [Go](https://pkg.go.dev/go.temporal.io/sdk/converter#PayloadCodec), data conversion happens in two stages:\n\n1. A Payload Converter converts a value into a [`Payload`](https://github.com/temporalio/api/blob/2f980f7ce4349e808b16ec0f21e0fe675f79330f/temporal/api/common/v1/message.proto#L49).\n2. A Payload Codec transforms an array of Payloads (for example, a list of Workflow arguments) into another array of Payloads.\n\nThe Payload Codec is an optional step that happens between the wire and the Payload Converter:\n\n```\nTemporal Server <--> Wire <--> Payload Codec <--> Payload Converter <--> User code\n```\n\nCommon Payload Codec transformations are compression and encryption.\n\nIn codec implementations, we recommended running the function (whether it be compressing, encrypting, etc) on the entire input Payload, and putting the result in a new Payload's `data` field. That way, the input Payload's headers are preserved. See, for example:\n\n- [`ZlibCodec`](https://github.com/temporalio/sdk-go/blob/706516c7077ba2e9b40304aeddbed47e25b2a68f/converter/codec.go#L77-L105) in the Go SDK\n- [Encryption Data Converter](https://github.com/temporalio/samples-go/blob/15be864c80d4d983ebb8a8fbd3fa5263bcef6930/encryption/data_converter.go#L100-L126) in Go's encryption sample\n\n### Encryption\n\nDoing encryption in a custom Data Converter ensures that all application data is encrypted during the following actions:\n\n- Being sent to/from Temporal Server.\n- Moving inside Temporal Server.\n- Stored by Temporal Server.\n\nThen data exists unencrypted in memory only on the Client and in the Worker Process that is executing Workflows and Activities on hosts that the application developer controls.\n\nOur encryption samples use AES GCM with 256-bit keys:\n\n- [TypeScript sample](https://github.com/temporalio/samples-typescript/tree/main/encryption)\n- [Go sample](https://github.com/temporalio/samples-go/tree/main/encryption)\n- [Java sample](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/encryptedpayloads)\n","is_empty":false},{"file_name":"what-is-a-global-namespace.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-global-namespace.md","id":114,"title":"What is a Global Namespace?","description":"A Global Namespace is a Namespace that exists across Clusters when Multi-Cluster Replication is set up.","label":"Global Namespace","tags":["explanation"],"markdown_content":"\nA Global Namespace is a [Namespace](/concepts/what-is-a-namespace) that exists across Clusters when [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication) is set up.\n\n- [How to register a Global Namespace](/tctl/namespace/register/#--global-namespace)\n- [How to change the active Cluster for a Global Namespace](/tctl/namespace/update/#--active-cluster)\n\nThe Global Namespace feature enables Workflow Executions to progress through another Cluster in the event of a failover.\n\nA Global Namespace may be replicated to any number of Clusters, but is active in only one Cluster at any given time.\n\nFor a failover to be successful, Worker Processes must be polling for Tasks for the Global Namespace on all Clusters.\n\nA Global Namespace has a failover version.\nBecause a failover can be triggered from any Cluster, the failover version prevents certain conflicts from occurring if a failover is mistakenly triggered simultaneously on two Clusters.\n\nOnly the active Cluster dispatches [Tasks](/concepts/what-is-a-task); however, certain conflicts are possible.\nUnlike regular Namespaces, which provide at-most-once semantics for an Activity Execution, Global Namespaces can support only at-least-once semantics (see [Conflict resolution](/concepts/what-is-multi-cluster-replication/#conflict-resolution)).\nWorker Processes on the standby Clusters are idle until a failover occurs and their Cluster becomes active.\n\nTemporal Application API calls made to a non-active Cluster are rejected with a **NamespaceNotActiveError** which contains the name of the current active Cluster.\nIt is the responsibility of the Temporal Application to call the Cluster that is currently active.\n","is_empty":false},{"file_name":"what-is-a-heartbeat-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-heartbeat-timeout.md","id":115,"title":"What is a Heartbeat Timeout?","description":"A Heartbeat Timeout is the maximum time between Activity Heartbeats.","label":"Heartbeat Timeout","tags":["explanation","timeouts"],"markdown_content":"\nA Heartbeat Timeout is the maximum time between [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat).\n\n- [How to set a Heartbeat Timeout](/application-development/features#heartbeat-timeout)\n\n![Heartbeat Timeout periods](/diagrams/heartbeat-timeout.svg)\n\nIf this timeout is reached, the Activity Task fails and a retry occurs if a [Retry Policy](/concepts/what-is-a-retry-policy) dictates it.\n","is_empty":false},{"file_name":"what-is-a-list-filter.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-list-filter.md","id":116,"title":"What is a List Filter?","description":"A List Filter is the SQL-like string that is provided as the parameter to an Advanced Visibility List API.","label":"List Filter","tags":["explanation","filtered-lists","visibility"],"markdown_content":"\nA List Filter is the SQL-like string that is provided as the parameter to an [Advanced Visibility](/concepts/what-is-advanced-visibility) List API.\n\n- [How to use a List Filter using tctl](/tctl/workflow/list/#--query)\n\nThe following is an example List Filter:\n\n```\nWorkflowType = \"main.YourWorkflowDefinition\" and ExecutionStatus != \"Running\" and (StartTime > \"2021-06-07T16:46:34.236-08:00\" or CloseTime > \"2021-06-07T16:46:34-08:00\") order by StartTime desc\n```\n\n[More example List Filters](#example-list-filters)\n\nA List Filter contains [Search Attribute](/concepts/what-is-a-search-attribute) names, Search Attribute values, and Operators.\n\n- The following operators are supported in List Filters:\n\n  - **=, !=, >, >=, <, <=**\n  - **AND, OR, ()**\n  - **BETWEEN ... AND**\n  - **IN**\n  - **ORDER BY**\n\n- A List Filter applies to a single Namespace.\n\n- The range of a List Filter timestamp (StartTime, CloseTime, ExecutionTime) cannot exceed 9223372036854775807 (that is, maxInt64 - 1001).\n\n- A List Filter that uses a time range has a resolution of 1 ms on Elasticsearch 6 and 1 ns on Elasticsearch 7.\n\n- List Filter Search Attribute names are case sensitive.\n\n- An Advanced List Filter API may take longer than expected if it is retrieving a large number of Workflow Executions (more than 10 million).\n\n- A `ListWorkflow` API supports pagination.\n  Use the page token in the following call to retrieve the next page; continue until the page token is `null`/`nil`.\n\n- To efficiently count the number of Workflow Executions, use the `CountWorkflow` API.\n\n#### Example List Filters\n\n```sql\nWorkflowId = '<workflow-id>'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or WorkflowId = '<another-workflow-id>'\n```\n\n```sql\nWorkflowId = '<workflow-id>' order by StartTime desc\n```\n\n```sql\nWorkflowId = '<workflow-id>' and ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' or ExecutionStatus = 'Running'\n```\n\n```sql\nWorkflowId = '<workflow-id>' and StartTime > '2021-08-22T15:04:05+00:00'\n```\n\n```sql\nExecutionTime between '2021-08-22T15:04:05+00:00' and '2021-08-28T15:04:05+00:00'\n```\n\n```sql\nExecutionTime < '2021-08-28T15:04:05+00:00' or ExecutionTime > '2021-08-22T15:04:05+00:00'\n```\n\n```sql\norder by ExecutionTime\n```\n\n```sql\norder by StartTime desc, CloseTime asc\n```\n\n```sql\norder by CustomIntField asc\n```\n","is_empty":false},{"file_name":"what-is-a-local-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-local-activity.md","id":117,"title":"What is a Local Activity?","description":"A Local Activity is an Activity Execution that executes in the same process as the Workflow Execution that spawns it.","label":"Local Activity","tags":["explanation"],"markdown_content":"\nA Local Activity is an [Activity Execution](/concepts/what-is-an-activity-execution) that executes in the same process as the [Workflow Execution](/concepts/what-is-a-workflow-execution) that spawns it.\n\nSome Activity Executions are very short-living and do not need the queuing semantic, flow control, rate limiting, and routing capabilities.\nFor this case, Temporal supports the Local Activity feature.\n\nThe main benefit of Local Activities is that they use less Temporal service resources (e.g. lower state transitions) and have much lower latency overhead (because no need to roundtrip to the Cluster) compared to normal Activity Executions.\nHowever, Local Activities are subject to shorter durations and a lack of rate limiting.\n\nConsider using Local Activities for functions that are the following:\n\n- can be implemented in the same binary as the Workflow that calls them.\n- do not require global rate limiting.\n- do not require routing to a specific Worker or Worker pool.\n- no longer than a few seconds, inclusive of retries (shorter than the Workflow Task Timeout, which is 10 seconds by default).\n\nUsing a Local Activity without understanding its limitations can cause various production issues.\n**We recommend using regular Activities unless your use case requires very high throughput and large Activity fan outs of very short-lived Activities.**\nMore guidance in choosing between [Local Activity vs Activity](https://community.temporal.io/t/local-activity-vs-activity/290/3) is available in our forums.\n","is_empty":false},{"file_name":"what-is-a-memo.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-memo.md","id":118,"title":"What is a Memo?","description":"A Memo is a non-indexed user-supplied set of Workflow Execution metadata that is displayed with Filtered List results.","label":"Memo","tags":["explanation"],"markdown_content":"\nA Memo is a non-indexed user-supplied set of Workflow Execution metadata that is displayed with Filtered List results.\n","is_empty":false},{"file_name":"what-is-a-namespace.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-namespace.md","id":119,"title":"What is a Namespace?","description":"A Namespace is a unit of isolation within the Temporal Platform","label":"Namespace","tags":["explanation"],"markdown_content":"\nA Namespace is a unit of isolation within the Temporal Platform.\n\n- [How to list Namespaces in a Cluster using tctl](/tctl/namespace/list)\n- [How to register a new Namespace using tctl](/tctl/namespace/register)\n- [How to set the Namespace for a Temporal Client](/application-development/foundations#set-namespace)\n- [How to view (describe) Namespace metadata and details using tctl](/tctl/namespace/describe)\n\nA single Namespace is still multi-tenant.\nYou can use Namespaces to match the development lifecycle; for example, having separate `dev` and `prod` Namespaces.\nOr you could use them to ensure Workflow Executions between different teams never communicate; such as ensuring that the `teamA` Namespace never impacts the `teamB` Namespace.\n\n- If no other Namespace is specified, the Temporal Cluster uses the Namespace \"default\" for all Temporal SDKs and tctl.\n  - If you are deploying through Docker Compose or using the [auto-setup image](https://github.com/temporalio/docker-builds/blob/main/docker/auto-setup.sh) in a custom Docker Compose application, the Namespace \"default\" is created, through the auto-setup script.\n  - If you are deploying through the [Temporal Helm charts](https://github.com/temporalio/helm-charts), you can create the \"default\" Namespace by using tctl; for example, `tctl namespace default`.\n    We recommend using the default Namespace if you aren’t using multiple Namespaces.\n- **Case Insensitive**: Because of DNS, Namespaces are case insensitive on the network and routing side.\n  We recommend using lowercase for namespace names to avoid potential issues.\n- **Membership**: [Task Queue](/concepts/what-is-a-task-queue) names and [Workflow Ids](/concepts/what-is-a-workflow-id) must all correspond to a specific Namespace.\n  For example, when a Workflow Execution is spawned, it does so within a specific Namespace.\n- **Uniqueness**: Temporal guarantees a unique Workflow Id within a Namespace.\n  Workflow Executions may have the same Workflow Id if they are in different Namespaces.\n- **Namespace Configuration**: Various configuration options like the retention period and the [Archival](/concepts/what-is-archival) destination are configured per Namespace through a special CRUD API or through [`tctl`](/tctl).\n","is_empty":false},{"file_name":"what-is-a-parent-close-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-parent-close-policy.md","id":120,"title":"What is a Parent Close Policy?","description":"If a Workflow Execution is a Child Workflow Execution, a Parent Close Policy determines what happens to the Workflow Execution if its Parent Workflow Execution changes to a Closed status (Completed, Failed, Timed out).","label":"Parent Close Policy","tags":["explanation","child-workflow-executions"],"markdown_content":"\nA Parent Close Policy determines what happens to a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) if its Parent changes to a Closed status (Completed, Failed, or Timed out).\n\n- [How to set a Parent Close Policy](/application-development/features#parent-close-policy)\n\nThere are three possible values:\n\n- **Abandon**: the Child Workflow Execution is not affected.\n- **Request Cancel**: a Cancellation request is sent to the Child Workflow Execution.\n- **Terminate** (default): the Child Workflow Execution is forcefully Terminated.\n\n[`ParentClosePolicy`](https://github.com/temporalio/api/blob/c1f04d0856a3ba2995e92717607f83536b5a44f5/temporal/api/enums/v1/workflow.proto#L44) proto definition.\n\nEach Child Workflow Execution may have its own Parent Close Policy.\nThis policy applies only to Child Workflow Executions and has no effect otherwise.\n\n![Parent Close Policy entity relationship](/diagrams/parent-close-policy.svg)\n\nYou can set policies per child, which means you can opt out of propagating terminates / cancels on a per-child basis.\nThis is useful for starting Child Workflows asynchronously (see [relevant issue here](https://community.temporal.io/t/best-way-to-create-an-async-child-workflow/114) or the corresponding SDK docs).\n","is_empty":false},{"file_name":"what-is-a-query.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-query.md","id":121,"title":"What is a Query?","description":"A Query is a synchronous operation that is used to report the state of a Workflow Execution.","label":"Query","tags":["queries","explanation"],"markdown_content":"\nA Query is a synchronous operation that is used to get the state of a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nThe state of a running Workflow Execution is constantly changing.\nQueries are available to expose the internal Workflow Execution state to the external world.\n\n- [How to send a Query using tctl](/tctl/workflow/query)\n- [How to send and handle Queries with an SDK](/application-development/features#queries)\n\nQueries are sent from a Temporal Client to a Workflow Execution.\nThe API call is synchronous.\nThe Query is identified at both ends by a Query name.\nThe Workflow must have a Query handler that is developed to handle that Query and provide data that represents the state of the Workflow Execution.\n\nQueries are strongly consistent and are guaranteed to return the most recent state.\nThis means that the data reflects the state of all confirmed Events that came in before the Query was sent.\nAn Event is considered confirmed if the call creating the Event returned success.\nEvents that are created while the Query is outstanding may or may not be reflected in the Workflow state the Query result is based on.\n\nA Query can carry arguments to specify the data it is requesting.\nAnd each Workflow can expose data to multiple types of Queries.\n\nA Query must never mutate the state of the Workflow Execution—that is, Queries are _read-only_ and cannot contain any blocking code.\nThis means, for example, that Query handling logic cannot schedule Activity Executions.\n\nSending Queries to completed Workflow Executions is supported, though Query reject conditions can be configured per Query.\n\n#### Stack Trace Query\n\nIn many SDKs, the Temporal Client exposes a predefined `__stack_trace` Query that returns the stack trace of all the threads owned by that Workflow Execution.\nThis is a great way to troubleshoot a Workflow Execution in production.\nFor example, if a Workflow Execution has been stuck at a state for longer than an expected period of time, you can send a `__stack_trace` Query to return the current call stack.\nThe `__stack_trace` Query name does not require special handling in your Workflow code.\n","is_empty":false},{"file_name":"what-is-a-retention-period.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-retention-period.md","id":122,"title":"What is a Retention Period?","description":"A Retention Period is the amount of time a Workflow Execution Event History remains in the Cluster's persistence store.","label":"Retention Period","tags":["explanation"],"markdown_content":"\nA Retention Period is the amount of time a Workflow Execution Event History remains in the Cluster's persistence store.\n\n- [How to set the Retention Period for the Namespace](/tctl/namespace/register/#--retention)\n\nA Retention Period applies to a single [Namespace](/concepts/what-is-a-namespace) and is set when the Namespace is registered.\n\nIf the Retention Period isn't set, it defaults to 2 days.\nThe minimum Retention Period is 1 day.\nThe maximum Retention Period is 30 days.\nSetting the Retention Period to 0 results in the error _A valid retention period is not set on request_.\n","is_empty":false},{"file_name":"what-is-a-retry-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-retry-policy.md","id":123,"title":"What is a Retry Policy?","description":"A Retry Policy is a collection of attributes that instructs the Temporal Server how to retry a failure of a Workflow Execution or an Activity Task Execution.","label":"Retry Policy","tags":["explanation"],"markdown_content":"\nA Retry Policy is a collection of attributes that instructs the Temporal Server how to retry a failure of a [Workflow Execution](/concepts/what-is-a-workflow-execution) or an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n(Retry Policies do not apply to [Workflow Task Executions](/concepts/what-is-a-workflow-task-execution), which always retry indefinitely.)\n\n- [Activity retry simulator](/application-development/features#activity-retry-simulator)\n- [How to set a custom Retry Policy for an Activity](/application-development/features#activity-retry-policy)\n- [How to set a Retry Policy for a Workflow](/application-development/features#workflow-retry-policy)\n\n<!-- ![Diagram that shows the retry interval and its formula](/img/retry-interval-diagram.png) -->\n\n## Default behavior\n\n- **Workflow Execution**: When a Workflow Execution is spawned, it is not associated with a default Retry Policy and thus does not retry by default.\n  The intention is that a Workflow Definition should be written to never fail due to intermittent issues; an Activity is designed to handle such issues.\n\n- **Activity Execution**: When an Activity Execution is spawned, it is associated with a default Retry Policy, and thus Activity Task Executions are retried by default.\n  When an Activity Task Execution is retried, the Cluster places a new [Activity Task](/concepts/what-is-an-activity-task) into its respective [Activity Task Queue](/concepts/what-is-a-task-queue), which results in a new Activity Task Execution.\n\n## Custom Retry Policy\n\nTo use a custom Retry Policy, provide it as an options parameter when starting a Workflow Execution or Activity Execution.\nOnly certain scenarios merit starting a Workflow Execution with a custom Retry Policy, such as the following:\n\n- A [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) or some other stateless, always-running Workflow Execution that can benefit from retries.\n- A file-processing or media-encoding Workflow Execution that downloads files to a host.\n\n## Properties\n\n### Default values for Retry Policy\n\n```\nInitial Interval     = 1 second\nBackoff Coefficient  = 2.0\nMaximum Interval     = 100 × Initial Interval\nMaximum Attempts     = ∞\nNon-Retryable Errors = []\n```\n\n### Initial Interval\n\n- **Description**: Amount of time that must elapse before the first retry occurs.\n  - **The default value is 1 second.**\n- **Use case**: This is used as the base interval time for the [Backoff Coefficient](#backoff-coefficient) to multiply against.\n\n### Backoff Coefficient\n\n- **Description**: The value dictates how much the _retry interval_ increases.\n  - **The default value is 2.0.**\n  - A backoff coefficient of 1.0 means that the retry interval always equals the [Initial Interval](#initial-interval).\n- **Use case**: Use this attribute to increase the interval between retries.\n  By having a backoff coefficient greater than 1.0, the first few retries happen relatively quickly to overcome intermittent failures, but subsequent retries happen farther and farther apart to account for longer outages.\n  Use the [Maximum Interval](#maximum-interval) attribute to prevent the coefficient from increasing the retry interval too much.\n\n### Maximum Interval\n\n- **Description**: Specifies the maximum interval between retries.\n  - **The default value is 100 times the [Initial Interval](#initial-interval).**\n- **Use case**: This attribute is useful for [Backoff Coefficients](#backoff-coefficient) that are greater than 1.0 because it prevents the retry interval from growing infinitely.\n\n### Maximum Attempts\n\n- **Description**: Specifies the maximum number of execution attempts that can be made in the presence of failures.\n  - **The default is unlimited.**\n  - If this limit is exceeded, the execution fails without retrying again. When this happens an error is returned.\n  - Setting the value to 0 also means unlimited.\n  - Setting the value to 1 means a single execution attempt and no retries.\n  - Setting the value to a negative integer results in an error when the execution is invoked.\n- **Use case**: Use this attribute to ensure that retries do not continue indefinitely.\n  However, in the majority of cases, we recommend relying on the Workflow Execution Timeout, in the case of [Workflows](#workflow), or Schedule-To-Close Timeout, in the case of [Activities](#activity), to limit the total duration of retries instead of using this attribute.\n\n### Non-Retryable Errors\n\n- **Description**: Specifies errors that shouldn't be retried.\n  - **Default is none.**\n  - If one of those errors occurs, the [Activity Task Execution](#activity-task-execution) or [Workflow Execution](#workflow-execution) is not retried.\n- **Use case**: There may be errors that you know of that should not trigger a retry.\n  In this case you can specify them such that if they occur, the given execution will not be retried.\n\n## Retry interval\n\nThe wait time before a retry is the _retry interval_. A retry interval is the smaller of two values:\n\n- The [Initial Interval](#initial-interval) multiplied by the [Backoff Coefficient](#backoff-coefficient) raised to the power of the number of retries.\n- The [Maximum Interval](#maximum-interval).\n\n## Event History\n\nThere are some subtle nuances to how Events are recorded to an Event History when a Retry Policy comes into play.\n\n- For an Activity Execution, the [ActivityTaskStarted](/concepts/what-is-an-event#activitytaskstarted) Event will not show up in the Workflow Execution Event History until the Activity Execution has completed or failed (having exhausted all retries).\n  This is to avoid filling the Event History with noise.\n  Use the Describe API to get a pending Activity Execution's attempt count.\n\n- For a Workflow Execution with a Retry Policy, if the Workflow Execution fails, the Workflow Execution will [Continue-As-New](/concepts/what-is-continue-as-new) and the associated Event is written to the Event History.\n  The [WorkflowExecutionContinuedAsNew](/concepts/what-is-an-event#workflowexecutioncontinuedasnew) Event will have an \"initiator\" field that will specify the Retry Policy as the value and the new Run Id for the next retry attempt.\n  The new Workflow Execution is created immediately.\n  But the first Workflow Task won't be scheduled until the backoff duration is exhausted.\n  That duration is recorded as the `firstWorkflowTaskBackoff` field of the new run's `WorkflowExecutionStartedEventAttributes` event.\n","is_empty":false},{"file_name":"what-is-a-run-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-run-id.md","id":124,"title":"What is a Run Id?","description":"A Run Id is a globally unique, platform-level identifier for a Workflow Execution.","label":"Run Id","tags":["explanation"],"markdown_content":"\nA Run Id is a globally unique, platform-level identifier for a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nTemporal guarantees that only one Workflow Execution with a given [Workflow Id](/concepts/what-is-a-workflow-id) can be in an Open state at any given time.\nBut when a Workflow Execution reaches a Closed state, it is possible to have another Workflow Execution in an Open state with the same Workflow Id.\nFor example, a Temporal Cron Job is a chain of Workflow Executions that all have the same Workflow Id.\nEach Workflow Execution within the chain is considered a _Run_.\n\nA Run Id uniquely identifies a Workflow Execution even if it shares a Workflow Id with other Workflow Executions.\n","is_empty":false},{"file_name":"what-is-a-schedule-to-close-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-schedule-to-close-timeout.md","id":125,"title":"What is a Schedule-To-Close Timeout?","description":"A Schedule-To-Close Timeout is the maximum amount of time allowed for the overall Activity Execution, from when the first Activity Task is scheduled to when the last Activity Task, in the chain of Activity Tasks that make up the Activity Execution, reaches a Closed status.","label":"Schedule-To-Close Timeout","tags":["explanation","timeouts"],"markdown_content":"\nA Schedule-To-Close Timeout is the maximum amount of time allowed for the overall [Activity Execution](/concepts/what-is-an-activity-execution), from when the first [Activity Task](/concepts/what-is-an-activity-task) is scheduled to when the last Activity Task, in the chain of Activity Tasks that make up the Activity Execution, reaches a Closed status.\n\n- [How to set a Schedule-To-Close Timeout](/go/how-to-set-a-schedule-to-close-timeout-in-go)\n\n![Schedule-To-Close Timeout period](/diagrams/schedule-to-close-timeout.svg)\n\nExample Schedule-To-Close Timeout period for an Activity Execution that has a chain Activity Task Executions:\n\n![Schedule-To-Close Timeout period with a retry](/diagrams/schedule-to-close-timeout-with-retry.svg)\n\n**The default Schedule-To-Close Timeout is ∞ (infinity).**\n\nAn Activity Execution must have either this timeout (Schedule-To-Close) or [Start-To-Close](/concepts/what-is-a-start-to-close-timeout) set.\nBy default, an Activity Execution Retry Policy dictates that retries will occur for up to 10 years.\nThis timeout can be used to control the overall duration of an Activity Execution in the face of failures (repeated Activity Task Executions), without altering the Maximum Attempts field of the Retry Policy.\n","is_empty":false},{"file_name":"what-is-a-schedule-to-start-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-schedule-to-start-timeout.md","id":126,"title":"What is a Schedule-To-Start Timeout?","description":"A Schedule-To-Start Timeout is the maximum amount of time that is allowed from when an Activity Task is placed in a Task Queue to when a Worker picks it up from the Task Queue.","label":"Schedule-To-Start Timeout","tags":["explanation","timeouts"],"markdown_content":"\nA Schedule-To-Start Timeout is the maximum amount of time that is allowed from when an [Activity Task](/concepts/what-is-an-activity-task) is scheduled (that is, placed in a Task Queue) to when a [Worker](/concepts/what-is-a-worker) starts (that is, picks up from the Task Queue) that Activity Task.\nIn other words, it's a limit for how long an Activity Task can be enqueued.\n\n[How to set a Schedule-To-Start Timeout](/go/how-to-set-a-schedule-to-start-timeout-in-go)\n\nThe moment that the Task is picked by the Worker from the Task Queue is considered to be the start of the Activity Task for the purposes of the Schedule-To-Start Timeout and associated metrics.\nThis definition of \"Start\" avoids issues that a clock difference between the Temporal Cluster and a Worker might create.\n\n![Schedule-To-Start Timeout period](/diagrams/schedule-to-start-timeout.svg)\n\n\"Schedule\" in Schedule-To-Start and Schedule-To-Close have different frequency guarantees.\n\nThe Schedule-To-Start Timeout is enforced for each Activity Task, whereas the Schedule-To-Close Timeout is enforced once per Activity Execution.\nThus, \"Schedule\" in Schedule-To-Start refers to the scheduling moment of _every_ Activity Task in the sequence of Activity Tasks that make up the Activity Execution, while\n\"Schedule\" in Schedule-To-Close refers to the _first_ Activity Task in that sequence.\n\nA [Retry Policy](/concepts/what-is-a-retry-policy) attached to an Activity Execution retries an Activity Task.\n\n![Start-To-Close Timeout period with retries](/diagrams/schedule-to-start-timeout-with-retry.svg)\n\nThis timeout has two primary use cases:\n\n1. Detect whether an individual Worker has crashed.\n2. Detect whether the fleet of Workers polling the Task Queue is not able to keep up with the rate of Activity Tasks.\n\n**The default Schedule-To-Start Timeout is ∞ (infinity).**\n\nIf this timeout is used, we recommend setting this timeout to the maximum time a Workflow Execution is willing to wait for an Activity Execution in the presence of all possible Worker outages, and have a concrete plan in place to reroute Activity Tasks to a different Task Queue.\nThis timeout **does not** trigger any retries regardless of the Retry Policy, as a retry would place the Activity Task back into the same Task Queue.\nWe do not recommend using this timeout unless you know what you are doing.\n\nIn most cases, we recommend monitoring the `temporal_activity_schedule_to_start_latency` metric to know when Workers slow down picking up Activity Tasks, instead of setting this timeout.\n","is_empty":false},{"file_name":"what-is-a-schedule.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-schedule.md","id":127,"title":"What is a Schedule","description":"A Schedule enables the scheduling of Workflow Executions.","label":"Schedule","tags":["explanation","term"],"markdown_content":"\nA Schedule contains instructions for starting a [Workflow Execution](/concepts/what-is-a-workflow-execution) at specific times.\nSchedules provide a more flexible and user-friendly approach than [Temporal Cron Jobs](/concepts/what-is-a-temporal-cron-job).\n\n- [How to enable Schedules](#how-to-enable-schedules)\n- [How to operate Schedules using tctl](/tctl/schedule/)\n\nA Schedule has identity, and is independent of a Workflow Execution.\nThis differs from a Temporal Cron Job, which relies on a cron schedule as a property of the Workflow Execution.\n\n### Action\n\nThe Action of a Schedule is where the Workflow Execution properties are established, such as Workflow Type, Task Queue, parameters, and timeouts.\n\nWorkflow Executions started by a Schedule have the following additional properties:\n\n- The Action's timestamp is appended to the Workflow Id.\n- The `TemporalScheduledStartTime` [Search Attribute](/concepts/what-is-a-search-attribute) is added to the Workflow Execution.\n  The Action's timestamp is the value.\n- The `TemporalScheduledById` Search Attribute is added to the Workflow Execution.\n  The Schedule Id is the value.\n\n### Spec\n\nThere are two ways to express a Schedule Spec:\n\n- A simple interval, like \"every 30 minutes\" (measured from the Unix epoch, and optionally including a phase offset).\n- A calendar-based expression, similar to the \"cron expressions\" supported by lots of software, including the older Temporal Cron feature.\n\nCalendar expressions are given as separate named fields.\n\nFor example, in tctl they can be provided as JSON:\n\n```json\n{\n  \"year\": \"2022\",\n  \"month\": \"Jan,Apr,Jul,Oct\",\n  \"dayOfMonth\": \"1,15\",\n  \"hour\": \"11-14\"\n}\n```\n\nThe following calendar fields are available:\n\n- `year`\n- `month`\n- `dayOfMonth`\n- `dayOfWeek`\n- `hour`\n- `minute`\n- `second`\n\nEach field may contain a comma-separated list of ranges (or `*`), and each range may include a skip value following a slash.\n\nFor `month`, names of months may be used instead of integers (case-insensitive, abbreviations permitted).\nFor `dayOfWeek`, day-of-week names may be used.\n\nOther Spec features:\n\n**Multiple intervals/calendar expressions:** A Spec can have combinations of multiple intervals and/or calendar expressions to define a specific Schedule.\n\n**Time bounds:** Provide an absolute start or end time (or both) with a Spec to ensure that no actions are taken before the start time or after the end time.\n\n**Exclusions:** A Spec can contain exclusions in the form of zero or more calendar expressions.\nThis can be used to express scheduling like \"each Monday at noon except for holidays.\nYou'll have to provide your own set of exclusions and include it in each schedule; there are no pre-defined sets.\n(This feature isn't currently exposed in tctl or the Temporal Web UI.)\n\n**Jitter:** If given, a random offset between zero and the maximum jitter is added to each Action time (but bounded by the time until the next scheduled Action).\n\n**Time zones:** By default, calendar-based expressions are interpreted in UTC.\nTemporal recommends using UTC to avoid various surprising properties of time zones.\nIf you don't want to use UTC, you can provide the name of a time zone.\nThe time zone definition is loaded on the Temporal Server Worker Service from either disk or the fallback embedded in the binary.\n\nFor more operational control, embed the contents of the time zone database file in the Schedule Spec itself.\n(Note: this isn't currently exposed in tctl or the web UI.)\n\n### Pause\n\nA Schedule can be Paused.\nWhen a Schedule is Paused, the Spec has no effect.\nHowever, you can still force manual actions by using the [tctl schedule trigger](/tctl/schedule/trigger) command.\n\nTo assist communication among developers and operators, a “notes” field can be updated on pause or resume to store an explanation for the current state.\n\n### Backfill\n\nA Schedule can be Backfilled.\nWhen a Schedule is Backfilled, all the Actions that would have been taken over a specified time period are taken now (in parallel if the `AllowAll` [Overlap Policy](#overlap-policy) is used; sequentially if `BufferAll` is used).\nYou might use this to fill in runs from a time period when the Schedule was paused due to an external condition that's now resolved, or a period before the Schedule was created.\n\n### Limit number of Actions\n\nA Schedule can be limited to a certain number of scheduled Actions (that is, not trigger immediately).\nAfter that it will act as if it were paused.\n\n### Policies\n\nA Schedule supports a set of Policies that enable customizing behavior.\n\n#### Overlap Policy\n\nThe Overlap Policy controls what happens when it is time to start a Workflow Execution but a previously started Workflow Execution is still running.\nThe following options are available:\n\n- `Skip`: **Default**.\n  Nothing happens; the Workflow Execution is not started.\n- `BufferOne`: Starts the Workflow Execution as soon as the current one completes.\n  The buffer is limited to one.\n  If another Workflow Execution is supposed to start, but one is already in the buffer, only the one in the buffer eventually starts.\n- `BufferAll`: Allows an unlimited number of Workflows to buffer.\n  They are started sequentially.\n- `CancelOther`: Cancels the running Workflow Execution, and then starts the new one after the old one completes cancellation.\n- `TerminateOther`: Terminates the running Workflow Execution and starts the new one immediately.\n- `AllowAll` Starts any number of concurrent Workflow Executions.\n  With this policy (and only this policy), more than one Workflow Execution, started by the Schedule, can run simultaneously.\n\n#### Catchup Window\n\nThe Temporal Cluster might be down or unavailable at the time when a Schedule should take an Action.\nWhen it comes back up, the Catchup Window controls which missed Actions should be taken at that point.\nThe default is one minute, which means that the Schedule attempts to take any Actions that wouldn't be more than one minute late.\nAn outage that lasts longer than the Catchup Window could lead to missed Actions.\n(But you can always [Backfill](#backfill).)\n\n#### Pause-on-failure\n\nIf this policy is set, a Workflow Execution started by a Schedule that ends with a failure or timeout (but not Cancellation or Termination) causes the Schedule to automatically pause.\n\nNote that with the `AllowAll` Overlap Policy, this pause might not apply to the next Workflow Execution, because the next Workflow Execution might have started before the failed one finished.\nIt applies only to Workflow Executions that were scheduled to start after the failed one finished.\n\n### Last completion result\n\nA Workflow started by a Schedule can obtain the completion result from the most recent successful run.\n(How you do this depends on the SDK you're using.)\n\nFor overlap policies that don't allow overlap, “the most recent successful run” is straightforward to define.\nFor the `AllowAll` policy, it refers to the run that completed most recently, at the time that the run in question is started.\nConsider the following overlapping runs:\n\n```\ntime -------------------------------------------->\n A     |----------------------|\n B               |-------|\n C                          |---------------|\n D                                |--------------T\n```\n\nIf D asks for the last completion result at time T, it gets the result of A.\nNot B, even though B started more recently, because A completed later.\nAnd not C, even though C completed after A, because the result for D is captured when D is started, not when it's queried.\n\nFailures and timeouts do not affect the last completion result.\n\n### Last failure\n\nA Workflow started by a Schedule can obtain the details of the failure of the most recent run that ended at the time when the Workflow in question was started. Unlike last completion result, a _successful_ run _does_ reset the last failure.\n\n### How to enable Schedules\n\n:::info Experimental\n\nThe Scheduled Workflows feature is available in Temporal Server version 1.17.\nHowever the feature is in an experimental stage and is disabled by default.\n\nInternally, a Schedule is implemented as a Workflow.\nThese implementation Workflow Executions are visible to you as you navigate the Web UI and use tctl, though you should not interact with it directly.\n\nIn later versions the implementation Workflows will cease to be visible by default.\n\n:::\n\n**Requirements**\n\n- Temporal Server version 1.17 or later.\n- [Advanced Visibility](/concepts/what-is-advanced-visibility) optional.\n- The following dynamic config values:\n\n```yaml\nfrontend.enableSchedules:\n  - value: true\nworker.enableScheduler:\n  - value: true\nmatching.numTaskqueueReadPartitions:\n  - value: 1\n    constraints:\n      taskQueueName: temporal-sys-scheduler-tq\nmatching.numTaskqueueWritePartitions:\n  - value: 1\n    constraints:\n      taskQueueName: temporal-sys-scheduler-tq\n```\n\nOnly the first two values are required; the second two are suggested because, by default, only one Worker runs per Task Queue, so more than one partition is not useful.\nSetting the Task Queue to use one partition reduces latency.\n\nIf you're familiar with Dynamic Config, you can also constrain these settings per Namespace as needed for your installation.\n","is_empty":false},{"file_name":"what-is-a-search-attribute.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-search-attribute.md","id":128,"title":"What is a Search Attribute?","description":"A Search Attribute is an indexed name used in List Filters to filter a list of Workflow Executions that have the Search Attribute in their metadata.","label":"Search Attribute","tags":["explanation","filtered-lists","visibility"],"markdown_content":"\nA Search Attribute is an indexed field used in a [List Filter](/concepts/what-is-a-list-filter) to filter a list of [Workflow Executions](/concepts/what-is-a-workflow-execution) that have the Search Attribute in their metadata.\n\nIf a [Temporal Cluster](/concepts/what-is-a-temporal-cluster) does not have [Elasticsearch integrated](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster), but a Workflow Execution is spawned and tagged with Search Attributes, no errors occur.\nHowever, you won't be able to use [Advanced Visibility](/concepts/what-is-advanced-visibility) List APIs and List Filters to find and list the Workflow Execution.\n\nWhen using [Continue-As-New](/concepts/what-is-continue-as-new) or a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job), Search Attributes are carried over to the new Workflow Run by default.\n\n#### Search Attributes maximums\n\nDefault total maximum number of Search Attribute **keys** per Temporal Cluster is 100.\n\n<!-- TODO - [How to configure maximum number of Search Attribute keys per Cluster](#) -->\n\nDefault single Search Attribute **value** size limit is 2 KB.\n\n<!-- TODO - [How to configure Search Attribute value size limit](#) -->\n\nTotal Search Attribute size: 40 KB\n\n<!-- TODO - [How to configure total Search Attribute size limite](#) -->\n\n<!-- temp keeping for reference\nThis is configurable with [`SearchAttributesNumberOfKeysLimit`, `SearchAttributesTotalSizeLimit` and `SearchAttributesSizeOfValueLimit`](https://github.com/temporalio/temporal/blob/v1.7.0/service/history/configs/config.go#L440-L442), if you know what you are doing.\n-->\n\n#### Default Search Attributes\n\nA Temporal Cluster that is integrated with Elasticsearch has a set of default Search Attributes already available.\nThese Search Attributes are created when the initial index is created.\n\n| NAME                  | TYPE     | DEFINITION                                                                                                                                                                   |\n| --------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| WorkflowType          | Keyword  | The type of Workflow.                                                                                                                                                        |\n| WorkflowId            | Keyword  | Identifies the Workflow Execution.                                                                                                                                           |\n| ExecutionStatus       | Keyword  | The current state of the Workflow Execution.                                                                                                                                 |\n| StartTime             | Datetime | The time at which the Workflow Execution started.                                                                                                                            |\n| CloseTime             | Datetime | The time at which the Workflow Execution completed.                                                                                                                          |\n| ExecutionTime         | Datetime | Same as StartTime for the most cases but different for cron Workflows and retried Workflows. For them it is the time at which the Workflow Execution actually begin running. |\n| RunId                 | Keyword  | Identifies the current Workflow Execution Run.                                                                                                                               |\n| ExecutionDuration     | Int      | The time needed to run the Workflow Execution. Available only for closed Workflows.                                                                                          |\n| HistoryLength         | Int      | The number of events in the history of Workflow Execution. Available only for closed Workflows.                                                                              |\n| StateTransitionCount  | Int      | The number of times that Workflow Execution has persisted its state. Available only for closed Workflows.                                                                    |\n| TaskQueue             | Keyword  | Task Queue used by Workflow Execution.                                                                                                                                       |\n| TemporalChangeVersion | Keyword  | If workflow versioning is enabled, list of change/version pairs will be stored here.                                                                                         |\n| BinaryChecksums       | Keyword  | List of binary Ids of Workers that run the Workflow Execution.                                                                                                               |\n| BatcherNamespace      | Keyword  | Used by internal batcher to indicate the Namespace where batch operation was applied to.                                                                                     |\n| BatcherUser           | Keyword  | Used by internal batcher to indicate the user who started the batch operation.                                                                                               |\n\n- All default Search Attributes are reserved and read-only.\n  (You cannot create a custom one with the same name or alter the existing one.)\n\n- ExecutionStatus values correspond to Workflow Execution Statuses: Running, Completed, Failed, Canceled, Terminated, ContinuedAsNew, TimedOut.\n\n- StartTime, CloseTime, and ExecutionTime are stored as dates but are supported by queries that use either EpochTime in nanoseconds or a string in [RFC3339Nano format](https://pkg.go.dev/time#pkg-constants) (such as \"2006-01-02T15:04:05.999999999Z07:00\").\n\n- ExecutionDuration is stored in nanoseconds but is supported by queries that use integers in nanoseconds, [Golang duration format](https://pkg.go.dev/time#ParseDuration), or \"hh:mm:ss\" format.\n\n- CloseTime, HistoryLength, StateTransitionCount, and ExecutionDuration are present only in a Closed Workflow Execution.\n\n- ExecutionTime can differ from StartTime in retry and cron use cases.\n\n#### Custom Search Attributes\n\nCustom Search Attributes can be [added to a Temporal Cluster only by using `tctl`](/tctl/admin/cluster/add-search-attributes).\nAdding a Search Attribute makes it available to use with Workflow Executions within that Cluster.\n\nThere is no hard limit on the number of attributes you can add.\nHowever, we recommend enforcing the following limits:\n\n- Number of Search Attributes: 100 per Workflow\n- Size of each value: 2 KB per value\n- Total size of names and values: 40 KB per Workflow\n\n:::note\n\nDue to Elasticsearch limitations, you can only add Search Attributes.\nIt is not possible to rename Search Attributes or remove them from the index schema.\n\n:::\n\nThe [temporalio/auto-setup](https://hub.docker.com/r/temporalio/auto-setup) Docker image uses a pre-defined set of custom Search Attributes that are handy for testing.\nTheir names indicate their types:\n\n- CustomBoolField\n- CustomDatetimeField\n- CustomDoubleField\n- CustomIntField\n- CustomKeywordField\n- CustomTextField\n\n#### Types\n\nSearch Attributes must be one of the following types:\n\n- Bool\n- Datetime\n- Double\n- Int\n- Keyword\n- Text\n\nNote:\n\n- **Double** is backed up by `scaled_float` Elasticsearch type with scale factor 10000 (4 decimal digits).\n- **Datetime** is backed up by `date` type with milliseconds precision in Elasticsearch 6 and `date_nanos` type with nanoseconds precision in Elasticsearch 7.\n- **Int** is 64-bit integer (`long` Elasticsearch type).\n- **Keyword** and **Text** types are concepts taken from Elasticsearch. Each word in a **Text** is considered a searchable keyword.\n  For a UUID, that can be problematic because Elasticsearch indexes each portion of the UUID separately.\n  To have the whole string considered as a searchable keyword, use the **Keyword** type.\n  For example, if the key `ProductId` has the value of `2dd29ab7-2dd8-4668-83e0-89cae261cfb1`:\n  - As a **Keyword** it would be matched only by `ProductId = \"2dd29ab7-2dd8-4668-83e0-89cae261cfb1`.\n  - As a **Text** it would be matched by `ProductId = 2dd8`, which could cause unwanted matches.\n- The **Text** type cannot be used in the \"Order By\" clause.\n\n- [How to view Search Attributes using tctl](/tctl/cluster/get-search-attributes)\n\n#### Search Attributes as Workflow Execution metadata\n\nTo actually have results from the use of a [List Filter](/concepts/what-is-a-list-filter), Search Attributes must be added to a Workflow Execution as metadata.\nHow to do this entirely depends on the method by which you spawn the Workflow Execution:\n\n- [How to set Search Attributes as Workflow Execution metadata in Go](/go/startworkflowoptions-reference/#searchattributes)\n","is_empty":false},{"file_name":"what-is-a-side-effect.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-side-effect.md","id":129,"title":"What is a Side Effect?","description":"A Side Effect is a way to execute a short, nondeterministic code snippet, such as generating a UUID, that executes the provided function once and records its result into the Workflow Execution Event History.","label":"Side Effect","tags":["explanation"],"markdown_content":"\nA Side Effect is a way to execute a short, nondeterministic code snippet, such as generating a UUID, that executes the provided function once and records its result into the Workflow Execution Event History.\n\nA Side Effect does not re-execute upon replay, but instead returns the recorded result.\n\nDo not ever have a Side Effect that could fail, because failure could result in the Side Effect function executing more than once.\nIf there is any chance that the code provided to the Side Effect could fail, use an Activity.\n","is_empty":false},{"file_name":"what-is-a-signal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-signal.md","id":130,"title":"What is a Signal?","description":"A Signal is an asynchronous request to a Workflow Execution.","label":"Signal","tags":["signals","explanation"],"markdown_content":"\nA Signal is an asynchronous request to a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\n- [How to develop, send, and handle Signals in code](/application-development/features#signals)\n- [How to send a Signal using tctl](/tctl/workflow/signal)\n\nA Signal delivers data to a running Workflow Execution.\nIt cannot return data to the caller; to do so, use a [Query](#queries) instead.\nThe Workflow code that handles a Signal can mutate Workflow state.\nA Signal can be sent from a Temporal Client or a Workflow.\nWhen a Signal is sent, it is received by the Cluster and recorded as an Event to the Workflow Execution [Event History](#event-history).\nA successful response from the Cluster means that the Signal has been persisted and will be delivered at least once to the Workflow Execution.[^1]\nThe next scheduled Workflow Task will contain the Signal Event.\n\nA Signal must include a destination (Namespace and Workflow Id) and name.\nIt can include a list of arguments.\n\nSignal handlers are Workflow functions that listen for Signals by the Signal name.\nSignals are delivered in the order they are received by the Cluster.\nIf multiple deliveries of a Signal would be a problem for your Workflow, add idempotency logic to your Signal handler that checks for duplicates.\n\n[^1]: The Cluster usually deduplicates Signals, but does not guarantee deduplication: During shard migration, two Signal Events (and therefore two deliveries to the Workflow Execution) can be recorded for a single Signal because the deduping info is stored only in memory.\n","is_empty":false},{"file_name":"what-is-a-start-to-close-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-start-to-close-timeout.md","id":131,"title":"What is a Start-To-Close Timeout?","description":"A Start-To-Close Timeout is the maximum time allowed for a single Activity Task Execution.","label":"Start-To-Close Timeout","tags":["explanation","timeouts"],"markdown_content":"\nA Start-To-Close Timeout is the maximum time allowed for a single [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n\n- [How to set a Start-To-Close Timeout](/go/how-to-set-a-start-to-close-timeout-in-go)\n\n**The default Start-To-Close Timeout is the same as the default [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout).**\n\nAn Activity Execution must have either this timeout (Start-To-Close) or the [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout) set.\nWe recommend always setting this timeout; however, make sure that it is always set to be longer than the maximum possible time for the Activity Execution to take place.\nFor long running Activity Executions, we recommend also using [Activity Heartbeats](/concepts/what-is-an-activity-heartbeat) and [Heartbeat Timeouts](/concepts/what-is-a-heartbeat-timeout).\n\nThe main use case for the Start-To-Close timeout is to detect when a Worker crashes after it has started executing an Activity Task.\n\n![Start-To-Close Timeout period](/diagrams/start-to-close-timeout.svg)\n\nA [Retry Policy](/concepts/what-is-a-retry-policy) attached to an Activity Execution retries an Activity Task Execution.\nThus, the Start-To-Close Timeout is applied to each Activity Task Execution within an Activity Execution.\n\nIf the first Activity Task Execution returns an error the first time, then the full Activity Execution might look like this:\n\n![Start-To-Close Timeout period with retries](/diagrams/start-to-close-timeout-with-retry.svg)\n\nIf this timeout is reached, the following actions occur:\n\n- An [ActivityTaskTimedOut](/references/events/#activitytasktimedout) Event is written to the Workflow Execution's mutable state.\n- If a Retry Policy dictates a retry, the Temporal Cluster schedules another Activity Task.\n  - The attempt count increments by 1 in the Workflow Execution's mutable state.\n  - The Start-To-Close Timeout timer is reset.\n","is_empty":false},{"file_name":"what-is-a-sticky-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-sticky-execution.md","id":132,"title":"What is a Sticky Execution?","description":"A Sticky Execution is a when a Worker Entity caches the Workflow Execution Event History and creates a dedicated Task Queue to listen on.","label":"Sticky Execution","tags":["explanation"],"markdown_content":"\nA Sticky Execution is when a Worker Entity caches the Workflow Execution Event History and creates a dedicated Task Queue to listen on.\n\nA Sticky Execution occurs after a Worker Entity completes the first Workflow Task in the chain of Workflow Tasks for the Workflow Execution.\n\nThe Worker Entity caches the Workflow Execution Event History and begins polling the dedicated Task Queue for Workflow Tasks that contain updates, rather than the entire Event History.\n\nIf the Worker Entity does not pick up a Workflow Task from the dedicated Task Queue in an appropriate amount of time, the Cluster will resume Scheduling Workflow Tasks on the original Task Queue.\nAnother Worker Entity can then resume the Workflow Execution, and can set up its own Sticky Execution for future Workflow Tasks.\n\n- [How to set a `StickyScheduleToStartTimeout` on a Worker Entity in Go](/go/how-to-set-workeroptions-in-go/#stickyscheduletostarttimeout)\n\nSticky Executions are the default behavior of the Temporal Platform.\n","is_empty":false},{"file_name":"what-is-a-task-queue.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-task-queue.md","id":133,"title":"What is a Task Queue?","description":"A Task Queue is a first-in, first-out queue that a Worker Process polls for Tasks.","label":"Task Queue","tags":["explanation"],"markdown_content":"\nA Task Queue is a lightweight, dynamically allocated queue that one or more [Worker Entities](/concepts/what-is-a-worker-entity) poll for [Tasks](/concepts/what-is-a-task).\n\nTask Queues do not have any ordering guarantees.\nIt is possible to have a Task that stays in a Task Queue for a period of time, if there is a backlog that wasn't drained for that time.\n\nThere are two types of Task Queues, Activity Task Queues and Workflow Task Queues.\n\n![Task Queue component](/diagrams/task-queue.svg)\n\nTask Queues are very lightweight components.\nTask Queues do not require explicit registration but instead are created on demand when a Workflow Execution or Activity spawns or when a Worker Process subscribes to it.\nWhen a Task Queue is created, both a Workflow Task Queue and an Activity Task Queue are created under the same name.\nThere is no limit to the number of Task Queues a Temporal Application can use or a Temporal Cluster can maintain.\n\nWorkers poll for Tasks in Task Queues via synchronous RPC.\nThis implementation offers several benefits:\n\n- A Worker Process polls for a message only when it has spare capacity, avoiding overloading itself.\n- In effect, Task Queues enable load balancing across many Worker Processes.\n- Task Queues enable what we call [Task Routing](/concepts/what-is-task-routing), which is the routing of specific Tasks to specific Worker Processes or even a specific process.\n- Task Queues support server-side throttling, which enables you to limit the Task dispatching rate to the pool of Worker Processes while still supporting Task dispatching at higher rates when spikes happen.\n- When all Worker Processes are down, messages simply persist in a Task Queue, waiting for the Worker Processes to recover.\n- Worker Processes do not need to advertise themselves through DNS or any other network discovery mechanism.\n- Worker Processes do not need to have any open ports, which is more secure.\n\nAll Workers listening to a given Task Queue must have identical registrations of Activities and/or Workflows.\nThe one exception is during a Server upgrade, where it is okay to have registration temporarily misaligned while the binary rolls out.\n\n#### Where to set Task Queues\n\nThere are four places where the name of the Task Queue can be set by the developer.\n\n1. A Task Queue must be set when spawning a Workflow Execution:\n\n- [How to start a Workflow Execution using an SDK](/application-development/foundations#set-task-queue)\n- [How to start a Workflow Execution using tctl](/tctl/workflow/start#--taskqueue)\n\n2. A Task Queue name must be set when creating a Worker Entity and when running a Worker Process:\n\n- [How to develop a Worker Program](/application-development/foundations#run-worker-processes)\n\nNote that all Worker Entities listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker Entity polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. A Task Queue name can be provided when spawning an Activity Execution:\n\nThis is optional.\nAn Activity Execution inherits the Task Queue name from its Workflow Execution if one is not provided.\n\n- [How to start an Activity Execution](/application-development/foundations#start-activity-execution)\n\n4. A Task Queue name can be provided when spawning a Child Workflow Execution:\n\nThis is optional.\nA Child Workflow Execution inherits the Task Queue name from its Parent Workflow Execution if one is not provided.\n\n- [How to start a Child Workflow Execution](/application-development/features#child-workflows)\n","is_empty":false},{"file_name":"what-is-a-task-token.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-task-token.md","id":134,"title":"What is a Task Token?","description":"A Task Token is a unique Id that correlates to an Activity Execution.","label":"Task Token","tags":["explanation"],"markdown_content":"\nA Task Token is a unique Id that correlates to an [Activity Execution](/concepts/what-is-an-activity-execution).\n\nActivity Execution completion calls take either a single Task Token, or the [Namespace](/concepts/what-is-a-namespace), [Workflow Id](/concepts/what-is-a-workflow-id), and [Activity Id](/concepts/what-is-an-activity-id) as a set of arguments.\n","is_empty":false},{"file_name":"what-is-a-task.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-task.md","id":135,"title":"What is a Task?","description":"A Task is the context needed to make progress with a specific Workflow Execution or Activity Execution.","label":"Task","tags":["explanation"],"markdown_content":"\nA Task is the context that a Worker needs to progress with a specific [Workflow Execution](/concepts/what-is-a-workflow-execution) or [Activity Execution](/concepts/what-is-an-activity-execution).\n\nThere are two types of Tasks:\n\n- [Activity Task](/concepts/what-is-an-activity-task)\n- [Workflow Task](/concepts/what-is-a-workflow-task)\n","is_empty":false},{"file_name":"what-is-a-temporal-application.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-temporal-application.md","id":136,"title":"What is a Temporal Application","description":"A Temporal Application is a set of Workflow Executions.","label":"Temporal Application","tags":["explanation"],"markdown_content":"\nA Temporal Application is a set of [Temporal Workflow Executions](/concepts/what-is-a-workflow-execution).\nEach Temporal Workflow Execution has exclusive access to its local state, executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions and the environment via message passing.\n\nA Temporal Application can consist of millions to billions of Workflow Executions.\nWorkflow Executions are lightweight components.\nA Workflow Execution consumes few compute resources; in fact, if a Workflow Execution is suspended, such as when it is in a waiting state, the Workflow Execution consumes no compute resources at all.\n\n**Reentrant Process**\n\nA Temporal Workflow Execution is a Reentrant Process. A Reentrant Process is resumable, recoverable, and reactive.\n\n- Resumable: Ability of a process to continue execution after execution was suspended on an _awaitable_.\n- Recoverable: Ability of a process to continue execution after execution was suspended on a _failure_.\n- Reactive: Ability of a process to react to external events.\n\nTherefore, a Temporal Workflow Execution executes a [Temporal Workflow Definition](/concepts/what-is-a-workflow-definition), also called a Temporal Workflow Function, your application code, exactly once and to completion—whether your code executes for seconds or years, in the presence of arbitrary load and arbitrary failures.\n","is_empty":false},{"file_name":"what-is-a-temporal-client.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-temporal-client.md","id":137,"title":"What is a Temporal Client","description":"TODO","label":"Temporal Client","tags":["explanation"],"markdown_content":"\nA Temporal Client is available in each SDK and provides a set of APIs to communicate with a [Temporal Cluster](/concepts/what-is-a-temporal-cluster).\n\nThe most common operations that a Temporal Client enables you to perform are the following:\n\n- Get the result of Workflow Execution.\n- List Workflow Executions.\n- Query a Workflow Execution.\n- Signal a Workflow Execution.\n- Start a Workflow Execution.\n","is_empty":false},{"file_name":"what-is-a-temporal-cluster.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-temporal-cluster.md","id":138,"title":"What is a Temporal Cluster?","description":"A Temporal Cluster is the Temporal Server paired with persistence.","label":"Temporal Cluster","tags":["explanation"],"markdown_content":"\nA Temporal Cluster is the group of services, known as the [Temporal Server](/concepts/what-is-the-temporal-server), combined with persistence stores, that together act as a component of the Temporal Platform.\n\n- [How to quickly install a Temporal Cluster for testing and development](/clusters/quick-install)\n- [Cluster deployment guide](/cluster-deployment-guide)\n\n![A Temporal Cluster (Server + persistence)](/diagrams/temporal-cluster.svg)\n\n#### Persistence\n\nA Temporal Cluster's only required dependency for basic operation is a database.\nMultiple types of databases that are supported.\n\n![Persistence](/diagrams/temporal-database.svg)\n\nThe database stores the following types of data:\n\n- Tasks: Tasks to be dispatched.\n- State of Workflow Executions:\n  - Execution table: A capture of the mutable state of Workflow Executions.\n  - History table: An append only log of Workflow Execution History Events.\n- Namespace metadata: Metadata of each Namespace in the Cluster.\n- Visibility data: Enables operations like \"show all running Workflow Executions\".\n  For production environments, we recommend using Elasticsearch.\n\nAn Elasticsearch database can be added to enable [Advanced Visibility](/concepts/what-is-advanced-visibility).\n\n**Versions**\n\nTemporal tests compatibility by spanning the **minimum** and **maximum** stable non-EOL major versions for each supported database.\nAs of time of writing, these specific versions are used in our test pipelines and actively tested before we release any version of Temporal:\n\n- **Cassandra v3.11 and v4.0**\n- **PostgreSQL v10.18 and v13.4**\n- **MySQL v5.7 and v8.0** (specifically 8.0.19+ due to a bug)\n\nWe update these support ranges once a year.\nThe release notes of each Temporal Server declare when we plan to drop support for database versions reaching End of Life.\n\n- Because Temporal Server primarily relies on core database functionality, we do not expect compatibility to break often.\n  Temporal has no opinions on database upgrade paths; as long as you can upgrade your database according to each project's specifications, Temporal should work with any version within supported ranges.\n- We do not run tests with vendors like Vitess and CockroachDB, so you rely on their compatibility claims if you use them.\n  Feel free to discuss them with fellow users [in our forum](https://community.temporal.io/).\n- Temporal is [working on official SQLite v3.x persistence](https://github.com/temporalio/temporal/pulls?q=is%3Apr+sort%3Aupdated-desc+sqlite), but this is meant only for development and testing, not production usage.\n  Cassandra, MySQL, and PostgreSQL schemas are supported and thus can be used as the Server's database.\n\n#### Monitoring & observation\n\nTemporal emits metrics by default in a format that is supported by Prometheus.\nMonitoring and observing those metrics is optional.\nAny software that can pull metrics that supports the same format could be used, but we ensure it works with Prometheus and Grafana versions only.\n\n- **Prometheus >= v2.0**\n- **Grafana >= v2.5**\n\n#### Visibility\n\nTemporal has built-in [Visibility](/concepts/what-is-visibility) features.\nTo enhance this feature, Temporal supports an [integration with Elasticsearch](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster).\n\n- Elasticsearch v7.10 is supported from Temporal version 1.7.0 onwards\n- Elasticsearch v6.8 is supported in all Temporal versions\n- Both versions are explicitly supported with AWS Elasticsearch\n","is_empty":false},{"file_name":"what-is-a-temporal-cron-job.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-temporal-cron-job.md","id":139,"title":"What is a Temporal Cron Job?","description":"A Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.","label":"Temporal Cron Job","tags":["explanation"],"markdown_content":"\nA Temporal Cron Job is the series of Workflow Executions that occur when a Cron Schedule is provided in the call to spawn a Workflow Execution.\n\n![Temporal Cron Job timeline](/diagrams/temporal-cron-job.svg)\n\nA Temporal Cron Job is similar to a classic unix cron job.\nJust as a unix cron job accepts a command and a schedule on which to execute that command, a Cron Schedule can be provided with the call to spawn a Workflow Execution.\nIf a Cron Schedule is provided, the Temporal Server will spawn an execution for the associated Workflow Type per the schedule.\n\nEach Workflow Execution within the series is considered a Run.\n\n- Each Run receives the same input parameters as the initial Run.\n- Each Run inherits the same Workflow Options as the initial Run.\n\nThe Temporal Server spawns the first Workflow Execution in the chain of Runs immediately.\nHowever, it calculates and applies a backoff (`firstWorkflowTaskBackoff`) so that the first Workflow Task of the Workflow Execution does not get placed into a Task Queue until the scheduled time.\nAfter each Run Completes, Fails, or reaches the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout), the same thing happens: the next run will be created immediately with a new `firstWorkflowTaskBackoff` that is calculated based on the current Server time and the defined Cron Schedule.\n\nThe Temporal Server spawns the next Run only after the current Run has Completed, Failed, or has reached the Workflow Run Timeout.\nThis means that, if a Retry Policy has also been provided, and a Run Fails or reaches the Workflow Run Timeout, the Run will first be retried per the Retry Policy until the Run Completes or the Retry Policy has been exhausted.\nIf the next Run, per the Cron Schedule, is due to spawn while the current Run is still Open (including retries), the Server automatically starts the new Run after the current Run completes successfully.\nThe start time for this new Run and the Cron definitions are used to calculate the `firstWorkflowTaskBackoff` that is applied to the new Run.\n\nA [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) is used to limit how long a Workflow can be executing (have an Open status), including retries and any usage of Continue As New.\nThe Cron Schedule runs until the Workflow Execution Timeout is reached or you terminate the Workflow.\n\n![Temporal Cron Job Run Failure with a Retry Policy](/diagrams/temporal-cron-job-failure-with-retry.svg)\n\n### Cron Schedules\n\nCron Schedules are interpreted in UTC time by default.\n\nThe Cron Schedule is provided as a string and must follow one of two specifications:\n\n**Classic specification**\n\nThis is what the \"classic\" specification looks like:\n\n```\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12)\n│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n│ │ │ │ │\n* * * * *\n```\n\nFor example, `15 8 * * *` causes a Workflow Execution to spawn daily at 8:15 AM UTC.\nUse the [crontab guru site](https://crontab.guru/) to test your cron expressions.\n\n### `robfig` predefined schedules and intervals\n\nYou can also pass any of the [predefined schedules](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Predefined_schedules) or [intervals](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-Intervals) described in the [`robfig/cron` documentation](https://pkg.go.dev/github.com/robfig/cron/v3).\n\n```\n| Schedules              | Description                                | Equivalent To |\n| ---------------------- | ------------------------------------------ | ------------- |\n| @yearly (or @annually) | Run once a year, midnight, Jan. 1st        | 0 0 1 1 *     |\n| @monthly               | Run once a month, midnight, first of month | 0 0 1 * *     |\n| @weekly                | Run once a week, midnight between Sat/Sun  | 0 0 * * 0     |\n| @daily (or @midnight)  | Run once a day, midnight                   | 0 0 * * *     |\n| @hourly                | Run once an hour, beginning of hour        | 0 * * * *     |\n```\n\nFor example, \"@weekly\" causes a Workflow Execution to spawn once a week at midnight between Saturday and Sunday.\n\nIntervals just take a string that can be accepted by [time.ParseDuration](http://golang.org/pkg/time/#ParseDuration).\n\n```\n@every <duration>\n```\n\n### Time zones\n\n_This feature only applies in Temporal 1.15 and up_\n\nYou can change the time zone that a Cron Schedule is interpreted in by prefixing the specification with `CRON_TZ=America/New_York ` (or your [desired time zone from tz](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)). `CRON_TZ=America/New_York 15 8 * * *` therefore spawns a Workflow Execution every day at 8:15 AM New York time, subject to caveats listed below.\n\nConsider that using time zones in production introduces a surprising amount of complexity and failure modes!\n**If at all possible, we recommend specifying Cron Schedules in UTC (the default)**.\n\nIf you need to use time zones, here are a few edge cases to keep in mind:\n\n- **Beware Daylight Saving Time**: If a Temporal Cron Job is scheduled around the time when daylight saving time (DST) begins or ends (for example, `30 2 * * *`), **it might run zero, one, or two times in a day**! The Cron library that we use does not do any special handling of DST transitions. Avoid schedules that include times that fall within DST transition periods.\n  - For example, in the US, DST begins at 2 AM. When you \"fall back,\" the clock goes `1:59 … 1:00 … 1:01 … 1:59 … 2:00 … 2:01 AM` and any Cron jobs that fall in that 1 AM hour are fired again. The inverse happens when clocks \"spring forward\" for DST, and Cron jobs that fall in the 2 AM hour are skipped.\n  - In other time zones like Chile and Iran, DST \"spring forward\" is at midnight. 11:59 PM is followed by 1 AM, which means `00:00:00` never happens.\n- **Self Hosting note**: If you manage your own Temporal Cluster, you are responsible for ensuring that it has access to current `tzdata` files. The official Docker images are built with [tzdata](https://docs.w3cub.com/go/time/tzdata/index) installed (provided by Alpine Linux), but ultimately you should be aware of how tzdata is deployed and updated in your infrastructure.\n- **Updating Temporal**: If you use the official Docker images, note that an upgrade of the Temporal Cluster may include an update to the tzdata files, which may change the meaning of your Cron Schedule. You should be aware of upcoming changes to the definitions of the time zones you use, particularly around daylight saving time start/end dates.\n- **Absolute Time Fixed at Start**: The absolute start time of the next Run is computed and stored in the database when the previous Run completes, and is not recomputed. This means that if you have a Cron Schedule that runs very infrequently, and the definition of the time zone changes between one Run and the next, the Run might happen at the wrong time. For example, `CRON_TZ=America/Los_Angeles 0 12 11 11 *` means \"noon in Los Angeles on November 11\" (normally not in DST). If at some point the government makes any changes (for example, move the end of DST one week later, or stay on permanent DST year-round), the meaning of that specification changes. In that first year, the Run happens at the wrong time, because it was computed using the older definition.\n\n### How to stop a Temporal Cron Job\n\nA Temporal Cron Job does not stop spawning Runs until it has been Terminated or until the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) is reached.\n\nA Cancellation Request affects only the current Run.\n\nUse the Workflow Id in any requests to Cancel or Terminate.\n\n**Implementation guides:**\n\n- [How to set a Cron Schedule in Go](/go/startworkflowoptions-reference/#cronschedule)\n- [How to set a Cron Schedule in Java](/java/reference-workflowoptions/#cronschedule)\n- [How to set a Cron Schedule in PHP](/php/distributed-cron)\n- [How to set a Cron Schedule in Typescript](/typescript/clients)\n","is_empty":false},{"file_name":"what-is-a-temporal-sdk.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-temporal-sdk.md","id":140,"title":"What is a Temporal SDK?","description":"A Temporal SDK is a language-specific library that offers APIs to construct and use a Temporal Client to communicate with a Temporal Cluster, develop Workflow Definitions, and develop Worker Programs.","label":"Temporal SDK","tags":["explanation"],"markdown_content":"\nA Temporal SDK is a language-specific library that offers APIs to do the following:\n\n1. Construct and use a [Temporal Client](/concepts/what-is-a-temporal-client)\n2. Develop [Workflow Definitions](/concepts/what-is-a-workflow-definition)\n3. Develop [Worker Programs](/concepts/what-is-a-worker-program)\n\nA Temporal SDK enables you to write your application code using the full power of the programming language, while the Temporal Platform handles the durability, reliability, and scalability of the application.\n\nTemporal currently offers the following SDKs:\n\n- [Get started with the Go SDK](/application-development/foundations/?lang=go#add-your-sdk)\n- [Get started with the Java SDK](/application-development/foundations/?lang=java#add-your-sdk)\n- [Get started with the PHP SDK](/application-development/foundations/?lang=php)\n- [Get started with the Python SDK](/application-development/foundations/?lang=python#add-your-sdk)\n- [How to use the TypeScript SDK](/application-development/foundations/?lang=typescript#add-your-sdk)\n\nEach SDK emits metrics which can be ingested into monitoring platforms.\nSee the [SDK metrics reference](/references/sdk-metrics) for a complete list.\n\n### SDKs in development\n\nThe following SDKs are in alpha/pre-alpha development stages, but are not yet supported in the application development guide:\n\n- [.NET](https://github.com/temporalio/sdk-dotnet)\n- [Rust](https://github.com/temporalio/sdk-core)\n- [Ruby](https://github.com/temporalio/sdk-ruby)\n\n### Third-party SDKs\n\nThe following third-party SDKs exist but are not supported in the [Application development guide](/application-development):\n\n- [Scala](https://github.com/vitaliihonta/zio-temporal) from [@vitaliihonta](https://github.com/vitaliihonta)\n- [Ruby](https://github.com/coinbase/temporal-ruby) from [@coinbase](https://github.com/coinbase)\n","is_empty":false},{"file_name":"what-is-a-worker-entity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-worker-entity.md","id":141,"title":"What is a Worker Entity?","description":"A Worker Entity is the individual Worker within a Worker Process that listens to a specific Task Queue.","label":"Worker Entity","tags":["explanation"],"markdown_content":"\nA Worker Entity is the individual Worker within a Worker Process that listens to a specific Task Queue.\n\nA Worker Entity listens and polls on a single Task Queue.\nA Worker Entity contains both a Workflow Worker and an Activity Worker so that it may make progress of either a Workflow Execution or an Activity Execution.\n\n**Can a Worker handle more Workflow Executions than its cache size or number of supported threads?**\n\nYes it can.\nHowever, the trade off is added latency.\n\nWorkers are stateless, so any Workflow Execution in a blocked state can be safely removed from a Worker.\nLater on, it can be resurrected on the same or different Worker when the need arises (in the form of an external event).\nTherefore, a single Worker can handle millions of open Workflow Executions, assuming it can handle the update rate and that a slightly higher latency is not a concern.\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)\n","is_empty":false},{"file_name":"what-is-a-worker-process.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-worker-process.md","id":142,"title":"What is a Worker Process?","description":"A Worker Process is responsible for polling a Task Queue, dequeueing a Task, executing your code in response to a Task, and responding to the Temporal Server with the results.","label":"Worker Process","tags":["explanation"],"markdown_content":"\n![Component diagram of a Worker Process and the Temporal Server](/diagrams/worker-and-server-component.svg)\n\nA Worker Process is responsible for polling a [Task Queue](/concepts/what-is-a-task-queue), dequeueing a [Task](/concepts/what-is-a-task), executing your code in response to a Task, and responding to the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) with the results.\n\nMore formally, a Worker Process is any process that implements the Task Queue Protocol and the Task Execution Protocol.\n\n- A Worker Process is a Workflow Worker Process if the process implements the Workflow Task Queue Protocol and executes the Workflow Task Execution Protocol to make progress on a Workflow Execution.\n  A Workflow Worker Process can listen on an arbitrary number of Workflow Task Queues and can execute an arbitrary number of Workflow Tasks.\n- A Worker Process is an Activity Worker Process if the process implements the Activity Task Queue Protocol and executes the Activity Task Processing Protocol to make progress on an Activity Execution.\n  An Activity Worker Process can listen on an arbitrary number of Activity Task Queues and can execute an arbitrary number of Activity Tasks.\n\n**Worker Processes are external to a Temporal Cluster.**\nTemporal Application developers are responsible for developing [Worker Programs](/concepts/what-is-a-worker-program) and operating Worker Processes.\nSaid another way, the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) (including the Temporal Cloud) doesn't execute any of your code (Workflow & Activity Definitions) on Temporal Cluster machines. The Cluster is solely responsible for orchestrating state transitions and providing Tasks to the next available Worker Entity.\n\nWhile data transferred in Event Histories is [secured by mTLS](/server/security/#encryption-of-network-traffic), by default, it is still readable at rest in the Temporal Cluster.\n\nTo solve this, Temporal SDKs offer a [Data Converter API](/concepts/what-is-a-data-converter) that you can use to customize the serialization of data going out of and coming back in to a Worker Entity, with the net effect of guaranteeing that the Temporal Cluster cannot read sensitive business data.\n\nIn many of our tutorials, we show you how to run both a Temporal Cluster and one Worker on the same machine for local development.\nHowever, a production-grade Temporal Application typically has a _fleet_ of Worker Processes, all running on hosts external to the Temporal Cluster.\nA Temporal Application can have as many Worker Processes as needed.\n\nA Worker Process can be both a Workflow Worker Process and an Activity Worker Process.\nMany SDKs support the ability to have multiple Worker Entities in a single Worker Process.\n(Worker entity creation and management differ between SDKs.)\nA single Worker Entity can listen to only a single Task Queue.\nBut if a Worker Process has multiple Worker Entities, the Worker Process could be listening to multiple Task Queues.\n\n![Entity relationship diagram (meta model) of Worker Processes, Task Queues, and Tasks](/diagrams/worker-and-server-entity-relationship.svg)\n\nWorker Processes executing Activity Tasks must have access to any resources needed to execute the actions that are defined in Activity Definitions, such as the following:\n\n- Network access for external API calls.\n- Credentials for infrastructure provisioning.\n- Specialized GPUs for machine learning utilities.\n\nThe Temporal Cluster itself has [internal workers](/blog/workflow-engine-principles/#system-workflows-1910) for system Workflow Executions.\nHowever, these internal workers are not visible to the developer.\n","is_empty":false},{"file_name":"what-is-a-worker-program.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-worker-program.md","id":143,"title":"What is a Worker Program?","description":"A Worker Program is the static code that defines the constraints of the Worker Process, developed using the APIs of a Temporal SDK.","label":"Worker Program","tags":["explanation"],"markdown_content":"\nA Worker Program is the static code that defines the constraints of the Worker Process, developed using the APIs of a Temporal SDK.\n\n**Implementation guide:**\n\n- [How to develop a Worker Program](/application-development/foundations#run-worker-processes)\n","is_empty":false},{"file_name":"what-is-a-worker.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-worker.md","id":144,"title":"What is a Worker?","description":"In day-to-day conversations, the term Worker is used to denote both a Worker Program and a Worker Process. Temporal documentation aims to be explicit and differentiate between them.","label":"Worker","tags":["explanation"],"markdown_content":"\nIn day-to-day conversations, the term Worker is used to denote either a [Worker Program](/concepts/what-is-a-worker-program), a [Worker Process](/concepts/what-is-a-worker-process), or a [Worker Entity](/concepts/what-is-a-worker-entity).\nTemporal documentation aims to be explicit and differentiate between them.\n","is_empty":false},{"file_name":"what-is-a-workflow-definition.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-definition.md","id":145,"title":"What is a Workflow Definition?","description":"A Workflow Definition is the code that defines the constraints of a Workflow Execution.","label":"Workflow Definition","tags":["explanation"],"markdown_content":"\nA Workflow Definition is the code that defines the constraints of a Workflow Execution.\n\n- [How to develop a Workflow Definition](/application-development/foundations#develop-workflows)\n\nA Workflow Definition is often also referred to as a Workflow Function.\nIn Temporal's documentation, a Workflow Definition refers to the source for the instance of a Workflow Execution, while a Workflow Function refers to the source for the instance of a Workflow Function Execution.\n\nA Workflow Execution effectively executes once to completion, while a Workflow Function Execution occurs many times during the life of a Workflow Execution.\n\nWe strongly recommend that you write a Workflow Definition in a language that has a corresponding Temporal SDK.\n\n### Deterministic constraints\n\nA critical aspect of developing Workflow Definitions is ensuring they exhibit certain deterministic traits – that is, making sure that the same Commands are emitted in the same sequence, whenever a corresponding Workflow Function Execution (instance of the Function Definition) is re-executed.\n\nThe execution semantics of a Workflow Execution include the re-execution of a Workflow Function.\nThe use of Workflow APIs in the function is what generates [Commands](/concepts/what-is-a-command).\nCommands tell the Cluster which Events to create and add to the Workflow Execution's Event History.\nWhen a Workflow Function executes, the Commands that are emitted are compared with the existing Event History.\nIf a corresponding Event already exists within the Event History that maps to the generation of that Command in the same sequence, and some specific metadata of that Command matches with some specific metadata of the Event, then the Function Execution progresses.\n\nFor example, using an SDK's \"Execute Activity\" API generates the [ScheduleActivityTask](/references/commands/#scheduleactivitytask) Command.\nWhen this API is called upon re-execution, that Command is compared with the Event that is in the same location within the sequence.\nThe Event in the sequence must be an [ActivityTaskScheduled](/references/events/#activitytaskscheduled) Event, where the Activity name is the same as what is in the Command.\n\nIf a generated Command doesn't match what it needs to in the existing Event History, then the Workflow Execution returns a _non-deterministic_ error.\n\nThe following are the two reasons why a Command might be generated out of sequence or the wrong Command might be generated altogether:\n\n1. Code changes are made to a Workflow Definition that is in use by a running Workflow Execution.\n2. There is intrinsic non-deterministic logic (such as inline random branching).\n\n### Code changes can cause non-deterministic behavior\n\nThe Workflow Definition can change in very limited ways once there is a Workflow Execution depending on it.\nTo alleviate non-deterministic issues that arise from code changes, we recommend using [Workflow Versioning](#workflow-versioning).\n\nFor example, let's say we have a Workflow Definition that defines the following sequence:\n\n1. Start and wait on a Timer/sleep.\n2. Spawn and wait on an Activity Execution.\n3. Complete.\n\nWe start a Worker and spawn a Workflow Execution that uses that Workflow Definition.\nThe Worker would emit the [StartTimer](/references/commands/#starttimer) Command and the Workflow Execution would become suspended.\n\nBefore the Timer is up, we change the Workflow Definition to the following sequence:\n\n1. Spawn and wait on an Activity Execution.\n2. Start and wait on a Timer/sleep.\n3. Complete.\n\nWhen the Timer fires, the next Workflow Task will cause the Workflow Function to re-execute.\nThe first Command the Worker sees would be ScheduleActivityTask Command, which wouldn't match up to the expected [TimerStarted](/references/events/#timerstarted) Event.\n\nThe Workflow Execution would fail and return a non-deterministic error.\n\nThe following are examples of minor changes that would not result in non-determinism errors when re-executing a History which already contain the Events:\n\n- Changing the duration of a Timer.\n- Changing the arguments to:\n  - The Activity Options in a call to spawn an Activity Execution (local or nonlocal).\n  - The Child Workflow Options in a call to spawn a Child Workflow Execution.\n  - Call to Signal an External Workflow Execution.\n\n### Intrinsic non-deterministic logic\n\nIntrinsic non-determinism is when a Workflow Function Execution might emit a different sequence of Commands on re-execution, regardless of whether all the input parameters are the same.\n\nFor example, a Workflow Definition can not have inline logic that branches (emits a different Command sequence) based off a local time setting or a random number.\nIn the representative pseudocode below, the `local_clock()` function returns the local time, rather than Temporal-defined time:\n\n```text\nfn your_workflow() {\n  if local_clock().is_before(\"12pm\") {\n    await workflow.sleep(duration_until(\"12pm\"))\n  } else {\n    await your_afternoon_activity()\n  }\n}\n```\n\nEach Temporal SDK offers APIs that enable Workflow Definitions to have logic that gets and uses time, random numbers, and data from unreliable resources.\nWhen those APIs are used, the results are stored as part of the Event History, which means that a re-executed Workflow Function will issue the same sequence of Commands, even if there is branching involved.\n\nIn other words, all operations that do not purely mutate the Workflow Execution's state should occur through a Temporal SDK API.\n\n### Workflow Versioning\n\nThe Workflow Versioning feature enables the creation of logical branching inside a Workflow Definition based on a developer specified version identifier.\nThis feature is useful for Workflow Definition logic needs to be updated, but there are running Workflow Executions that currently depends on it.\nIt is important to note that a practical way to handle different versions of Workflow Definitions, without using the versioning API, is to run the different versions on separate Task Queues.\n\n- [How to version Workflow Definitions in Go](/go/versioning)\n- [How to version Workflow Definitions in Java](/java/versioning)\n- [How to version Workflow Definitions in TypeScript](/typescript/patching)\n\n### Handling unreliable Worker Processes\n\nYou do not handle Worker Process failure or restarts in a Workflow Definition.\n\nWorkflow Function Executions are completely oblivious to the Worker Process in terms of failures or downtime.\nThe Temporal Platform ensures that the state of a Workflow Execution is recovered and progress resumes if there is an outage of either Worker Processes or the Temporal Cluster itself.\nThe only reason a Workflow Execution might fail is due to the code throwing an error or exception, not because of underlying infrastructure outages.\n","is_empty":false},{"file_name":"what-is-a-workflow-execution-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-execution-timeout.md","id":146,"title":"What is a Workflow Execution Timeout?","description":"A Workflow Execution Timeout is the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.","label":"Workflow Execution Timeout","tags":["explanation","timeouts"],"markdown_content":"\nA Workflow Execution Timeout is the maximum time that a Workflow Execution can be executing (have an Open status) including retries and any usage of Continue As New.\n\n- [How to set a Workflow Execution Timeout](/go/how-to-set-a-workflow-execution-timeout-in-go)\n\n![Workflow Execution Timeout period](/diagrams/workflow-execution-timeout.svg)\n\n**The default value is ∞ (infinite).**\nIf this timeout is reached, the Workflow Execution changes to a Timed Out status.\nThis timeout is different from the [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout).\nThis timeout is most commonly used for stopping the execution of a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job) after a certain amount of time has passed.\n","is_empty":false},{"file_name":"what-is-a-workflow-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-execution.md","id":147,"title":"What is a Workflow Execution?","description":"A Temporal Workflow Execution is a durable, scalable, reliable, and reactive function execution. It is the main unit of execution of a Temporal Application.","label":"Workflow Execution","tags":["explanation"],"markdown_content":"\nA Temporal Workflow Execution is a durable, reliable, and scalable function execution.\nIt is the main unit of execution of a [Temporal Application](/concepts/what-is-a-temporal-application).\n\n- [How to start a Workflow Execution using an SDK](/application-development/foundations#start-workflow-execution)\n- [How to start a Workflow Execution using tctl](/tctl/workflow/start)\n\nEach Temporal Workflow Execution has exclusive access to its local state.\nIt executes concurrently to all other Workflow Executions, and communicates with other Workflow Executions through [Signals](/concepts/what-is-a-signal) and the environment through [Activities](/concepts/what-is-an-activity).\nWhile a single Workflow Execution has limits on size and throughput, a Temporal Application can consist of millions to billions of Workflow Executions.\n\n**Durability**\n\nDurability is the absence of an imposed time limit.\n\nA Workflow Execution is durable because it executes a Temporal Workflow Definition (also called a Temporal Workflow Function), your application code, effectively once and to completion—whether your code executes for seconds or years.\n\n**Reliability**\n\nReliability is responsiveness in the presence of failure.\n\nA Workflow Execution is reliable, because it is fully recoverable after a failure.\nThe Temporal Platform ensures the state of the Workflow Execution persists in the face of failures and outages and resumes execution from the latest state.\n\n**Scalability**\n\nScalability is responsiveness in the presence of load.\n\nA single Workflow Execution is limited in size and throughput but is scalable because it can [Continue-As-New](/concepts/what-is-continue-as-new) in response to load.\nA Temporal Application is scalable because the Temporal Platform is capable of supporting millions to billions of Workflow Executions executing concurrently, which is realized by the design and nature of the [Temporal Cluster](/concepts/what-is-a-temporal-cluster) and [Worker Processes](/concepts/what-is-a-worker-process).\n\n### Commands & awaitables\n\nA Workflow Execution does two things:\n\n1. Issue [Commands](/concepts/what-is-a-command).\n2. Wait on an Awaitables (often called Futures).\n\n![Command generation and waiting](/diagrams/workflow-execution-progession-simple.svg)\n\nCommands are issued and Awaitables are provided by the use of Workflow APIs in the [Workflow Definition](/concepts/what-is-a-workflow-definition).\n\nCommands are generated whenever the Workflow Function is executed.\nThe Worker Process supervises the Command generation and makes sure that it maps to the current Event History.\n(For more information, see [Deterministic constraints](/concepts/what-is-a-workflow-definition/#deterministic-constraints).)\nThe Worker Process batches the Commands and then suspends progress to send the Commands to the Cluster whenever the Workflow Function reaches a place where it can no longer progress without a result from an Awaitable.\n\nA Workflow Execution may only ever block progress on an Awaitable that is provided through a Temporal SDK API.\nAwaitables are provided when using APIs for the following:\n\n- Awaiting: Progress can block using explicit \"Await\" APIs.\n- Requesting cancellation of another Workflow Execution: Progress can block on confirmation that the other Workflow Execution is cancelled.\n- Sending a [Signal](/concepts/what-is-a-signal): Progress can block on confirmation that the Signal sent.\n- Spawning a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution): Progress can block on confirmation that the Child Workflow Execution started, and on the result of the Child Workflow Execution.\n- Spawning an [Activity Execution](/concepts/what-is-an-activity-execution): Progress can block on the result of the Activity Execution.\n- Starting a Timer: Progress can block until the Timer fires.\n\n### Status\n\nA Workflow Execution can be either Open or Closed.\n\n![Workflow Execution statuses](/diagrams/workflow-execution-statuses.svg)\n\n**Open**\n\n- Running: The only Open status for a Workflow Execution.\n  When the Workflow Execution is Running, it is either actively progressing or is waiting on something.\n\n**Closed**\n\nA Closed status means that the Workflow Execution cannot make further progress because of one of the following reasons:\n\n- Cancelled: The Workflow Execution successfully handled a cancellation request.\n- Completed: The Workflow Execution has completed successfully.\n- Continued-As-New: The Workflow Execution [Continued-As-New](/concepts/what-is-continue-as-new).\n- Failed: The Workflow Execution returned an error and failed.\n- Terminated: The Workflow Execution was terminated.\n- Timed Out: The Workflow Execution reached a timeout limit.\n\n### Workflow Execution Chain\n\nA Workflow Execution Chain is a sequence of Workflow Executions that share the same Workflow Id.\nEach link in the Chain is often called a Workflow Run.\nEach Workflow Run in the sequence is connected by one of the following:\n\n- [Continue-As-New](/concepts/what-is-continue-as-new)\n- [Retries](/concepts/what-is-a-retry-policy)\n- [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job)\n\nA Workflow Execution is uniquely identified by its [Namespace](/concepts/what-is-a-namespace), [Workflow Id](/concepts/what-is-a-workflow-id), and [Run Id](/concepts/what-is-a-run-id).\n\nThe [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) applies to a Workflow Execution Chain.\nThe [Workflow Run Timeout](/concepts/what-is-a-workflow-run-timeout) applies to a single Workflow Execution (Workflow Run).\n\n### Event loop\n\nA Workflow Execution is made up of a sequence of [Events](/concepts/what-is-an-event) called an [Event History](/concepts/what-is-an-event-history).\nEvents are created by the Temporal Cluster in response to either Commands or actions requested by a Temporal Client (such as a request to spawn a Workflow Execution).\n\n![Workflow Execution](/diagrams/workflow-execution-swim-lane-01.svg)\n\n### Time constraints\n\n**Is there a limit to how long Workflows can run?**\n\nNo, there is no time constraint on how long a Workflow Execution can be Running.\n\nHowever, Workflow Executions intended to run indefinitely should be written with some care.\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\nThere is a hard limit of 50,000 Events in a Workflow Execution Event History, as well as a hard limit of 50 MB in terms of size.\nThe Temporal Cluster logs a warning at every 10,000 Events.\nWhen the Event History reaches 50,000 Events or the size limit of 50 MB, the Workflow Execution is forcefully terminated.\n\nTo prevent _runaway_ Workflow Executions, you can use the Workflow Execution Timeout, the Workflow Run Timeout, or both.\nA Workflow Execution Timeout can be used to limit the duration of Workflow Execution Chain, and a Workflow Run Timeout can be used to limit the duration an individual Workflow Execution (Run).\n\nYou can use the [Continue-As-New](/concepts/what-is-continue-as-new) feature to close the current Workflow Execution and create a new Workflow Execution in a single atomic operation.\nThe Workflow Execution spawned from Continue-As-New has the same Workflow Id, a new Run Id, and a fresh Event History and is passed all the appropriate parameters.\nFor example, it may be reasonable to use Continue-As-New once per day for a long-running Workflow Execution that is generating a large Event History.\n","is_empty":false},{"file_name":"what-is-a-workflow-id-reuse-policy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-id-reuse-policy.md","id":148,"title":"What is a Workflow Id Reuse Policy?","description":"A Workflow Id Reuse Policy determines whether a Workflow Execution is allowed to spawn with a particular Workflow Id, if that Workflow Id has been used with a previous, and now Closed, Workflow Execution.","label":"Workflow Id Reuse Policy","tags":["explanation"],"markdown_content":"\nA Workflow Id Reuse Policy determines whether a Workflow Execution is allowed to spawn with a particular Workflow Id, if that Workflow Id has been used with a previous, and now Closed, Workflow Execution.\n\nIt is not possible for a new Workflow Execution to spawn with the same Workflow Id as another Open Workflow Execution.\nAn attempt to spawn a Workflow Execution with a Workflow Id that is the same as the Id of a currently Open Workflow Execution results in a `Workflow execution already started` error.\n\nA Workflow Id Reuse Policy has three possible values:\n\n- **Allow Duplicate** The Workflow Execution is allowed to exist regardless of the Closed status of a previous Workflow Execution with the same Workflow Id.\n  **This is the default policy, if one is not specified.**\n  Use this when it is OK to have a Workflow Execution with the same Workflow Id as a previous, but now Closed, Workflow Execution.\n- **Allow Duplicate Failed Only**: The Workflow Execution is allowed to exist only if a previous Workflow Execution with the same Workflow Id does not have a Completed status.\n  Use this policy when there is a need to re-execute a Failed, Timed Out, Terminated or Cancelled Workflow Execution and guarantee that the Completed Workflow Execution will not be re-executed.\n- **Reject Duplicate**: The Workflow Execution cannot exist if a previous Workflow Execution has the same Workflow Id, regardless of the Closed status.\n  Use this when there can only be one Workflow Execution per Workflow Id within a Namespace for the given retention period.\n\nA Workflow Id Reuse Policy applies only if a Closed Workflow Execution with the same Workflow Id exists within the Retention Period of the associated Namespace.\nFor example, if the Namespace's retention period is 30 days, a Workflow Id Reuse Policy can only compare the Workflow Id of the spawning Workflow Execution against the Closed Workflow Executions for the last 30 days.\n\nIf there is an attempt to spawn a Workflow Execution with a Workflow Id Reuse Policy that won't allow it the Server will prevent the Workflow Execution from spawning.\n","is_empty":false},{"file_name":"what-is-a-workflow-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-id.md","id":149,"title":"What is a Workflow Id?","description":"A Workflow Id is a customizable, application-level identifier for a Workflow Execution that is unique to an Open Workflow Execution within a Namespace.","label":"Workflow Id","tags":["explanation"],"markdown_content":"\nA Workflow Id is a customizable, application-level identifier for a [Workflow Execution](/concepts/what-is-a-workflow-execution) that is unique to an Open Workflow Execution within a [Namespace](/namespaces).\n\n- [How to set a Workflow Id](/go/how-to-set-a-workflow-id-in-go)\n\nA Workflow Id is meant to be a business-process identifier such as customer identifier or order identifier.\n\nA [Workflow Id Reuse Policy](/concepts/what-is-a-workflow-id-reuse-policy) can be used to manage whether a Workflow Id can be re-used.\nThe Temporal Platform guarantees uniqueness of the Workflow Id within a [Namespace](/concepts/what-is-a-namespace) based on the Workflow Id Reuse Policy.\n\nIt is not possible for a new Workflow Execution to spawn with the same Workflow Id as another Open Workflow Execution, regardless of the Workflow Id Reuse Policy.\nAn attempt to spawn a Workflow Execution with a Workflow Id that is the same as the Id of a currently Open Workflow Execution results in a `Workflow execution already started` error.\n\nA Workflow Execution can be uniquely identified across all Namespaces by its [Namespace](/concepts/what-is-a-namespace), Workflow Id, and [Run Id](/concepts/what-is-a-run-id).\n","is_empty":false},{"file_name":"what-is-a-workflow-run-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-run-timeout.md","id":150,"title":"What is a Workflow Run Timeout?","description":"This is the maximum amount of time that a single Workflow Run is restricted to.","label":"Workflow Run Timeout","tags":["explanation","timeouts"],"markdown_content":"\nA Workflow Run Timeout is the maximum amount of time that a single Workflow Run is restricted to.\n\n- [How to set a Workflow Run Timeout](/go/startworkflowoptions-reference/#workflowruntimeout)\n\n![Workflow Run Timeout period](/diagrams/workflow-run-timeout.svg)\n\n**The default is set to the same value as the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout).**\nThis timeout is most commonly used to limit the execution time of a single [Temporal Cron Job Execution](/concepts/what-is-a-temporal-cron-job).\n\nIf the Workflow Run Timeout is reached, the Workflow Execution is Terminated.\n","is_empty":false},{"file_name":"what-is-a-workflow-task-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-task-execution.md","id":151,"title":"What is a Workflow Task Execution?","description":"A Workflow Task Execution is when a Worker picks up a Workflow Task and uses it to make progress on the execution of a Workflow function.","label":"Workflow Task Execution","tags":["explanation"],"markdown_content":"\nA Workflow Task Execution is when a Worker picks up a Workflow Task and uses it to make progress on the execution of a Workflow function.\n","is_empty":false},{"file_name":"what-is-a-workflow-task-timeout.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-task-timeout.md","id":152,"title":"What is a Workflow Task Timeout?","description":"A Workflow Task Timeout is the maximum amount of time that the Temporal Server will wait for a Worker to start processing a Workflow Task after the Task has been pulled from the Task Queue.","label":"Workflow Task Timeout","tags":["explanation","timeouts"],"markdown_content":"\nA Workflow Task Timeout is the maximum amount of time allowed for a [Worker](/concepts/what-is-a-worker) to execute a [Workflow Task](/concepts/what-is-a-workflow-task) after the Worker has pulled that Workflow Task from the [Task Queue](/concepts/what-is-a-task-queue).\n\n![Workflow Task Timeout period](/diagrams/workflow-task-timeout.svg)\n\n**The default value is 10 seconds.**\nThis timeout is primarily available to recognize whether a Worker has gone down so that the Workflow Execution can be recovered on a different Worker.\nThe main reason for increasing the default value would be to accommodate a Workflow Execution that has a very long Workflow Execution History that could take longer than 10 seconds for the Worker to load.\n\n**Implementation guides:**\n\n- [How to set a Workflow Task Timeout](/go/startworkflowoptions-reference/#workflowtasktimeout)\n","is_empty":false},{"file_name":"what-is-a-workflow-task.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-task.md","id":153,"title":"What is a Workflow Task?","description":"A Workflow Task is a Task that contains the context needed to make progress with a Workflow Execution.","label":"Workflow Task","tags":["explanation"],"markdown_content":"\nA Workflow Task is a Task that contains the context needed to make progress with a Workflow Execution.\n\n- Every time a new external event that might affect a Workflow state is recorded, a Workflow Task that contains the event is added to a Task Queue and then picked up by a Workflow Worker.\n- After the new event is handled, the Workflow Task is completed with a list of [Commands](/concepts/what-is-a-command).\n- Handling of a Workflow Task is usually very fast and is not related to the duration of operations that the Workflow invokes.\n","is_empty":false},{"file_name":"what-is-a-workflow-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow-type.md","id":154,"title":"What is a Workflow Type?","description":"A Workflow Type is a name that maps to a Workflow Definition.","label":"Workflow Type","tags":["explanation"],"markdown_content":"\nA Workflow Type is a name that maps to a Workflow Definition.\n\n- A single Workflow Type can be instantiated as multiple Workflow Executions.\n- A Workflow Type is scoped by a Task Queue.\n  It is acceptable to have the same Workflow Type name map to different Workflow definitions if they are using completely different Workers.\n\n![Workflow Type cardinality with Workflow Definitions and Workflow Executions](/diagrams/workflow-type-cardinality.svg)\n","is_empty":false},{"file_name":"what-is-a-workflow.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-a-workflow.md","id":155,"title":"What is a Workflow?","description":"In day-to-day conversations, the term \"Workflow\" frequently denotes either a Workflow Type, a Workflow Definition, or a Workflow Execution.","label":"Workflow","tags":["explanation"],"markdown_content":"\nIn day-to-day conversations, the term _Workflow_ frequently denotes either a [Workflow Type](/concepts/what-is-a-workflow-type), a [Workflow Definition](/concepts/what-is-a-workflow-definition), or a [Workflow Execution](/concepts/what-is-a-workflow-execution).\nTemporal documentation aims to be explicit and differentiate between them.\n","is_empty":false},{"file_name":"what-is-advanced-visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-advanced-visibility.md","id":156,"title":"What is Advanced Visibility?","description":"Advanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through an SQL-like query syntax.","label":"Advanced Visibility","tags":["explanation","filtered-lists","visibility"],"markdown_content":"\nAdvanced Visibility, within the Temporal Platform, is the subsystem and APIs that enable the listing, filtering, and sorting of Workflow Executions through a custom SQL-like [List Filter](/concepts/what-is-a-list-filter).\n\nTo use Advanced Visibility, your Temporal Cluster must be [integrated with Elasticsearch](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster).\nWe highly recommend operating a Temporal Cluster with Elasticsearch for any use case that spawns more than just a few Workflow Executions.\nElasticsearch takes on the Visibility request load, relieving potential performance issues.\n","is_empty":false},{"file_name":"what-is-an-activity-definition.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-activity-definition.md","id":157,"title":"What is an Activity Definition?","description":"An Activity Definition is the code that defines the constraints of an Activity Task Execution.","label":"Activity Definition","tags":["explanation"],"markdown_content":"\nAn Activity Definition is the code that defines the constraints of an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\n\n- [How to develop an Activity Definition](/application-development/foundations#develop-activities)\n\nThe term 'Activity Definition' is used to refer to the full set of primitives in any given language SDK that provides an access point to an Activity Function Definition——the method or function that is invoked for an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\nTherefore, the terms Activity Function and Activity Method refer to the source of an instance of an execution.\n\nActivity Definitions are named and referenced in code by their [Activity Type](/concepts/what-is-an-activity-type).\n\n![Activity Definition](/diagrams/activity-definition.svg)\n\n#### Constraints\n\nActivity Definitions are executed as normal functions.\n\nIn the event of failure, the function begins at its initial state when retried (except when Activity Heartbeats are established).\n\nTherefore, an Activity Definition has no restrictions on the code it contains.\n\n#### Parameters\n\nAn Activity Definition can support as many parameters as needed.\n\nAll values passed through these parameters are recorded in the [Event History](/concepts/what-is-an-event-history) of the Workflow Execution.\nReturn values are also captured in the Event History for the calling Workflow Execution.\n\nActivity Definitions must contain the following parameters:\n\n- Context: an optional parameter that provides Activity context within multiple APIs.\n- Heartbeat: a notification from the Worker to the Temporal Cluster that the Activity Execution is progressing. Cancelations are allowed only if the Activity Definition permits Heartbeating.\n- Timeouts: intervals that control the execution and retrying of Activity Task Executions.\n\nOther parameters, such as [Retry Policies](/concepts/what-is-a-retry-policy) and return values, can be seen in the implementation guides, listed in the next section.\n","is_empty":false},{"file_name":"what-is-an-activity-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-activity-execution.md","id":158,"title":"What is an Activity Execution?","description":"An Activity Execution is the full chain of Activity Task Executions.","label":"Activity Execution","tags":["explanation"],"markdown_content":"\nAn Activity Execution is the full chain of [Activity Task Executions](/concepts/what-is-an-activity-task-execution).\n\n- [How to spawn an Activity Execution](/application-development/foundations#start-activity-execution)\n\n![Activity Execution](/diagrams/activity-execution.svg)\n\nAn Activity Execution has no time limit.\nActivity Execution time limits and retries can be optimized for each situation within the Temporal Application.\n\nIf for any reason an Activity Execution does not complete (exhausts all retries), the error is returned to the [Workflow](/workflows), which decides how to handle it.\n\n### Request Cancellation\n\nA Workflow can request to cancel an Activity Execution.\nWhen an Activity Execution is canceled, or its Workflow Execution has completed or failed, the context passed into its function is canceled, which also sets its channel’s closed state to `Done`.\nAn Activity can use that to perform any necessary cleanup and abort its execution.\n\nCancellation requests are only delivered to Activity Executions that Heartbeat:\n\n- The Heartbeat request fails with a special error indicating that the Activity Execution is canceled.\n  Heartbeats can also fail when the Workflow Execution that spawned it is in a completed state.\n- The Activity should perform all necessary cleanup and report when it is done.\n- The Workflow can decide if it wants to wait for the Activity cancellation confirmation or proceed without waiting.\n","is_empty":false},{"file_name":"what-is-an-activity-heartbeat.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-activity-heartbeat.md","id":159,"title":"What is an Activity Heartbeat?","description":"An Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster. Each ping informs the Temporal Cluster that the Activity Execution is making progress and the Worker has not crashed.","label":"Activity Heartbeat","tags":["explanation"],"markdown_content":"\nAn Activity Heartbeat is a ping from the Worker that is executing the Activity to the Temporal Cluster.\nEach ping informs the Temporal Cluster that the Activity Execution is making progress and the Worker has not crashed.\n\n- [How to Heartbeat an Activity](/application-development/features#activity-heartbeats)\n\nActivity Heartbeats work in conjunction with a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout).\n\nActivity Heartbeats are implemented within the Activity Definition.\nCustom progress information can be included in the Heartbeat which can then be used by the Activity Execution should a retry occur.\n\nAn Activity Heartbeat can be recorded as often as needed (e.g. once a minute or every loop iteration).\nIt is often a good practice to Heartbeat on anything but the shortest Activity Function Execution.\nTemporal SDKs control the rate at which Heartbeats are sent to the Cluster.\n\nHeartbeating is not required from [Local Activities](/concepts/what-is-a-local-activity), and does nothing.\n\nFor _long-running_ Activities, we recommend using a relatively short Heartbeat Timeout and a frequent Heartbeat.\nThat way if a Worker fails it can be handled in a timely manner.\n\nA Heartbeat can include an application layer payload that can be used to _save_ Activity Execution progress.\nIf an [Activity Task Execution](/concepts/what-is-an-activity-task-execution) times out due to a missed Heartbeat, the next Activity Task can access and continue with that payload.\n\nActivity Cancellations are delivered to Activities from the Cluster when they Heartbeat. Activities that don't Heartbeat can't receive a Cancellation.\nHeartbeat throttling may lead to Cancellation getting delivered later than expected.\n\n#### Throttling\n\nHeartbeats may not always be sent to the Cluster—they may be throttled by the Worker.\nThe throttle interval is the smaller of the following:\n\n- If `heartbeatTimeout` is provided, `heartbeatTimeout * 0.8`; otherwise, `defaultHeartbeatThrottleInterval`\n- `maxHeartbeatThrottleInterval`\n\n`defaultHeartbeatThrottleInterval` is 30 seconds by default, and `maxHeartbeatThrottleInterval` is 60 seconds by default.\nEach can be set in Worker options.\n\nThrottling is implemented as follows:\n\n- After sending a Heartbeat, the Worker sets a timer for the throttle interval.\n- The Worker stops sending Heartbeats, but continues receiving Heartbeats from the Activity and remembers the most recent one.\n- When the timer fires, the Worker:\n  - Sends the most recent Heartbeat.\n  - Sets the timer again.\n\n#### Which Activities should Heartbeat?\n\nHeartbeating is best thought about not in terms of time, but in terms of \"How do you know you are making progress?\"\nFor short-term operations, progress updates are not a requirement.\nHowever, checking the progress and status of Activity Executions that run over long periods is almost always useful.\n\nConsider the following when setting Activity Hearbeats:\n\n- Your underlying task must be able to report definite progress.\n  Note that your Workflow cannot read this progress information while the Activity is still executing (or it would have to store it in Event History).\n  You can report progress to external sources if you need it exposed to the user.\n\n- Your Activity Execution is long-running, and you need to verify whether the Worker that is processing your Activity is still alive and has not run out of memory or silently crashed.\n\nFor example, the following scenarios are suitable for Heartbeating:\n\n- Reading a large file from Amazon S3.\n- Running a ML training job on some local GPUs.\n\nAnd the following scenarios are not suitable for Heartbeating:\n\n- Making a quick API call.\n- Reading a small file from disk.\n","is_empty":false},{"file_name":"what-is-an-activity-id.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-activity-id.md","id":160,"title":"What is an Activity Id?","description":"A unique identifier for an Activity Execution.","label":"Activity Id","tags":["explanation"],"markdown_content":"\nA unique identifier for an [Activity Execution](/concepts/what-is-an-activity-execution).\nThe identifier can be generated by the system, or it can be provided by the Workflow code that spawns the Activity Execution.\nAn Activity Id can be used to complete the Activity asynchronously.\n","is_empty":false},{"file_name":"what-is-an-activity-task-execution.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-activity-task-execution.md","id":161,"title":"What is an Activity Task Execution?","description":"An Activity Task Execution is the execution of an Activity Type.","label":"Activity Task Execution","tags":["explanation"],"markdown_content":"\nAn Activity Task Execution is when the Worker uses the Context provided from the [Activity Task](/concepts/what-is-an-activity-task) and executes the [Activity Definition](/concepts/what-is-an-activity-definition) (also known as the Activity Function).\n\nThe [ActivityTaskScheduled Event](/references/events#activitytaskscheduled) corresponds to when the Temporal Cluster puts the Activity Task into the Task Queue.\n\nThe [ActivityTaskStarted Event](/references/events#activitytaskstarted) corresponds to when the Worker picks up the Activity Task from the Task Queue.\n\nEither [ActivityTaskCompleted](/references/events#activitytaskcompleted) or one of the other Closed Activity Task Events corresponds to when the Worker has yielded back to the Temporal Cluster.\n\nThe API to schedule an Activity Execution provides an \"effectively once\" experience, even though there may be several Activity Task Executions that take place to successfully complete an Activity.\n\nOnce an Activity Task finishes execution, the Worker responds to the Cluster with a specific Event:\n\n- ActivityTaskCanceled\n- ActivityTaskCompleted\n- ActivityTaskFailed\n- ActivityTaskTerminated\n- ActivityTaskTimedOut\n","is_empty":false},{"file_name":"what-is-an-activity-task.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-activity-task.md","id":162,"title":"What is an Activity Task?","description":"An Activity Task contains the context needed to make an Activity Task Execution.","label":"Activity Task","tags":["explanation"],"markdown_content":"\nAn Activity Task contains the context needed to proceed with an [Activity Task Execution](/concepts/what-is-an-activity-task-execution).\nActivity Tasks largely represent the Activity Task Scheduled Event, which contains the data needed to execute an Activity Function.\n\nIf Heartbeat data is being passed, an Activity Task will also contain the latest Heartbeat details.\n","is_empty":false},{"file_name":"what-is-an-activity-type.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-activity-type.md","id":163,"title":"What is an Activity Type?","description":"An Activity Type is the mapping of a name to an Activity Definition.","label":"Activity Type","tags":["explanation"],"markdown_content":"\nAn Activity Type is the mapping of a name to an Activity Definition.\n\nActivity Types are scoped through Task Queues.\n","is_empty":false},{"file_name":"what-is-an-activity.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-activity.md","id":164,"title":"What is an Activity?","description":"In day-to-day conversations, the term \"Activity\" frequently denotes either an Activity Type, an Activity Definition, or an Activity Execution.","label":"Activity","tags":["explanation"],"markdown_content":"\nIn day-to-day conversations, the term _Activity_ frequently denotes either an [Activity Definition](/concepts/what-is-an-activity-definition), an [Activity Type](/concepts/what-is-an-activity-type), or an [Activity Execution](/concepts/what-is-an-activity-execution).\nTemporal documentation aims to be explicit and differentiate between them.\n\nAn Activity is a normal function or object method that executes a single, well-defined action (either short or long running), such as calling another service, transcoding a media file, or sending an email message.\n\nWorkflow code orchestrates the execution of Activities, persisting the results.\nIf an Activity Function Execution fails, any future execution starts from initial state (except Heartbeats).\nTherefore, an Activity function is allowed to contain any code without restrictions.\n\nActivity Functions are executed by Worker Processes.\nWhen the Activity Function returns, the Worker sends the results back to the Temporal Cluster as part of the `ActivityTaskCompleted` Event.\nThe Event is added to the Workflow Execution's Event History.\n","is_empty":false},{"file_name":"what-is-an-event-history.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-event-history.md","id":165,"title":"What is an Event History?","description":"An append log of Events that represents the full state a Workflow Execution.","label":"Event History","tags":["explanation"],"markdown_content":"\nAn append-log of [Events](/concepts/what-is-an-event) for your application.\n\n- Event History is durably persisted by the Temporal service, enabling seamless recovery of your application state from crashes or failures.\n- It also serves as an audit log for debugging.\n\n**Event History limits**\nThe Temporal Cluster stores the complete Event History for the entire lifecycle of a Workflow Execution.\nThere is a hard limit of 50,000 Events in a Workflow Execution Event History, as well as a hard limit of 50 MB in terms of size.\nThe Temporal Cluster logs a warning at every 10,000 Events.\nWhen the Event History reaches 50,000 Events or the size limit of 50 MB, the Workflow Execution is forcefully terminated.\n","is_empty":false},{"file_name":"what-is-an-event.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-an-event.md","id":166,"title":"What is an Event?","description":"Events are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution.","label":"Event","tags":["explanation"],"markdown_content":"\nEvents are created by the Temporal Cluster in response to external occurrences and Commands generated by a Workflow Execution. Each Event corresponds to an `enum` that is defined in the [Server API](https://github.com/temporalio/api/blob/master/temporal/api/enums/v1/event_type.proto).\n\nAll Events are recorded in the [Event History](/concepts/what-is-an-event-history).\n\nA list of all possible Events that could appear in a Workflow Execution Event History is provided in the [Event reference](/references/events).\n","is_empty":false},{"file_name":"what-is-archival.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-archival.md","id":167,"title":"What is Archival?","description":"Archival is a feature that automatically backs up Event Histories from Temporal Cluster persistence to a custom blob store after the Closed Workflow Execution retention period is reached.","label":"Archival","tags":["explanation"],"markdown_content":"\nArchival is a feature that automatically backs up [Event Histories](/concepts/what-is-an-event-history) and Visibility records from Temporal Cluster persistence to a custom blob store.\n\n- [How to create a custom Archiver](/clusters/how-to-create-a-custom-archiver)\n- [How to set up Archival](/clusters/how-to-set-up-archival)\n\nWorkflow Execution Event Histories are backed up after the [Retention Period](/concepts/what-is-a-namespace/#retention-period) is reached.\nVisibility records are backed up immediately after a Workflow Execution reaches a Closed status.\n\nArchival enables Workflow Execution data to persist as long as needed, while not overwhelming the Cluster's persistence store.\n\nThis feature is helpful for compliance and debugging.\n\nTemporal's Archival feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nArchival is not supported when running Temporal via docker-compose and is disabled by default when installing the system manually and when deploying through [helm charts](https://github.com/temporalio/helm-charts/blob/master/templates/server-configmap.yaml) (but can be enabled in the [config](https://github.com/temporalio/temporal/blob/master/config/development.yaml)).\n","is_empty":false},{"file_name":"what-is-asynchronous-activity-completion.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-asynchronous-activity-completion.md","id":168,"title":"What is Asynchronous Activity Completion?","description":"Asynchronous Activity Completion occurs when an external system provides the final result of a computation, started by an Activity, to the Temporal System.","label":"Asynchronous Activity Completion","tags":["explanation"],"markdown_content":"\nAsynchronous Activity Completion is a feature that enables an Activity Function to return without causing the Activity Execution to complete.\nThe Temporal Client can then be used to both Heartbeat Activity Execution progress and eventually provide a result.\n\n- [How to complete an Activity Asynchronously](/application-development/features#async-activity-completion)\n\n#### When to use Async Completion\n\nThe intended use-case for this feature is when an external system has the final result of a computation, started by an Activity.\n\nConsider using Asynchronous Activities instead of Signals if the external process is unreliable and might fail to send critical status updates through a Signal.\n\nConsider using [Signals](/concepts/what-is-a-signal) as an alternative to Asynchronous Activities to return data back to a Workflow Execution if there is a human in the process loop.\nThe reason is that a human in the loop means multiple steps in the process.\nThe first is the Activity Function that stores state in an external system and at least one other step where a human would “complete” the activity.\nIf the first step fails, you want to detect that quickly and retry instead of waiting for the entire process, which could be significantly longer when humans are involved.\n","is_empty":false},{"file_name":"what-is-continue-as-new.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-continue-as-new.md","id":169,"title":"What is Continue-As-New?","description":"Continue-As-New is the mechanism by which all relevant state is passed to a new Workflow Execution with a fresh Event History.","label":"Continue-As-New","tags":["explanation","continue-as-new"],"markdown_content":"\nContinue-As-New is a mechanism by which the latest relevant state is passed to a new Workflow Execution, with a fresh Event History.\n\nAs a precautionary measure, the Temporal Platform limits the total [Event History](/concepts/what-is-an-event-history) to 50,000 Events or 50 MB, and will warn you every 10,000 Events or 10 MB.\nTo prevent a Workflow Execution Event History from exceeding this limit and failing, use Continue-As-New to start a new Workflow Execution with a fresh Event History.\n\nAll values passed to a Workflow Execution through parameters or returned through a result value are recorded into the Event History.\nA Temporal Cluster stores the full Event History of a Workflow Execution for the duration of a Namespace's retention period.\nA Workflow Execution that periodically executes many Activities has the potential of hitting the size limit.\n\nA very large Event History can adversely affect the performance of a Workflow Execution.\nFor example, in the case of a Workflow Worker failure, the full Event History must be pulled from the Temporal Cluster and given to another Worker via a Workflow Task.\nIf the Event history is very large, it may take some time to load it.\n\nThe Continue-As-New feature enables developers to complete the current Workflow Execution and start a new one atomically.\n\nThe new Workflow Execution has the same Workflow Id, but a different Run Id, and has its own Event History.\n\nIn the case of [Temporal Cron Jobs](/concepts/what-is-a-temporal-cron-job), Continue-As-New is actually used internally for the same effect.\n\n- [How to Continue-As-New](/application-development/features#continue-as-new)\n","is_empty":false},{"file_name":"what-is-logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-logging.md","id":170,"markdown_content":"The `log` section is optional and contains the following possible values:\n\n- `stdout` - _boolean_ - `true` if the output needs to go to standard out.\n- `level` - sets the logging level.\n  - _Valid values_ - debug, info, warn, error or fatal, default to info.\n- `outputFile` - path to output log file.\n","is_empty":false},{"file_name":"what-is-multi-cluster-replication.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-multi-cluster-replication.md","id":171,"title":"What is Multi-Cluster Replication?","description":"todo","label":"Multi-Cluster Replication","tags":["explanation"],"markdown_content":"\nMulti-Cluster Replication is a feature which asynchronously replicates Workflow Executions from active Clusters to other passive Clusters, for backup and state reconstruction.\nWhen necessary, for higher availability, Cluster operators can failover to any of the backup Clusters.\n\nTemporal's Multi-Cluster Replication feature is considered **experimental** and not subject to normal [versioning and support policy](/clusters).\n\nTemporal automatically forwards Start, Signal, and Query requests to the active Cluster.\nThis feature must be enabled through a Dynamic Config flag per [Global Namespace](/concepts/what-is-a-global-namespace).\n\nWhen the feature is enabled, Tasks are sent to the Parent Task Queue partition that matches that Namespace, if it exists.\n\nAll Visibility APIs can be used against active and standby Clusters.\nThis enables [Temporal Web](https://github.com/temporalio/temporal-web) to work seamlessly for Global Namespaces.\nApplications making API calls directly to the Temporal Visibility API continue to work even if a Global Namespace is in standby mode.\nHowever, they might see a lag due to replication delay when querying the Workflow execution state from a standby Cluster.\n\n#### Namespace Versions\n\nA _version_ is a concept in Multi-Cluster Replication that describes the chronological order of events per Namespace.\n\nWith Multi-Cluster Replication, all Namespace change events and Workflow Execution History events are replicated asynchronously for high throughput.\nThis means that data across clusters is **not** strongly consistent.\nTo guarantee that Namespace data and Workflow Execution data will achieve eventual consistency (especially when there is a data conflict during a failover), a **version** is introduced and attached to Namespaces.\nAll Workflow Execution History entries generated in a Namespace will also come with the version attached to that Namespace.\n\nAll participating Clusters are pre-configured with a unique initial version and a shared version increment:\n\n- `initial version < shared version increment`\n\nWhen performing failover for a Namespace from one Cluster to another Cluster, the version attached to the Namespace will be changed by the following rule:\n\n- for all versions which follow `version % (shared version increment) == (active cluster's initial version)`, find the smallest version which has `version >= old version in namespace`\n\nWhen there is a data conflict, a comparison will be made and Workflow Execution History entries with the highest version will be considered the source of truth.\n\nWhen a cluster is trying to mutate a Workflow Execution History, the version will be checked.\nA cluster can mutate a Workflow Execution History only if the following is true:\n\n- The version in the Namespace belongs to this cluster, i.e.\n  `(version in namespace) % (shared version increment) == (this cluster's initial version)`\n- The version of this Workflow Execution History's last entry (event) is equal or less than the version in the Namespace, i.e.\n  `(last event's version) <= (version in namespace)`\n\n<details>\n<summary>Namespace version change example\n</summary>\n\nAssuming the following scenario:\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: Namespace α is registered, with active Cluster set to Cluster A\n\n```\nnamespace α's version is 1\nall workflows events generated within this namespace, will come with version 1\n```\n\nT = 1: namespace β is registered, with active Cluster set to Cluster B\n\n```\nnamespace β's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 2: Namespace α is updated to with active Cluster set to Cluster B\n\n```\nnamespace α's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\nT = 3: Namespace β is updated to with active Cluster set to Cluster A\n\n```\nnamespace β's version is 11\nall workflows events generated within this namespace, will come with version 11\n```\n\n</details>\n\n#### Version history\n\nVersion history is a concept which provides a high level summary of version information in regards to Workflow Execution History.\n\nWhenever there is a new Workflow Execution History entry generated, the version from Namespace will be attached.\nThe Workflow Executions's mutable state will keep track of all history entries (events) and the corresponding version.\n\n<details>\n<summary>Version history example (without data conflict)\n</summary>\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Shared version increment: 10\n\nT = 0: adding event with event ID == 1 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 1               | 1       |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 2 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 2: adding event with event ID == 3 & version == 1\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 3               | 1       |\n| 2        | 1             |                 |         |\n| 3        | 1             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 3: Namespace failover triggered, Namespace version is now 2\nadding event with event ID == 4 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 3               | 1       |\n| 2        | 1             | 4               | 2       |\n| 3        | 1             |                 |         |\n| 4        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 4: adding event with event ID == 5 & version == 2\n\nView in both Cluster A & B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 3               | 1       |\n| 2        | 1             | 5               | 2       |\n| 3        | 1             |                 |         |\n| 4        | 2             |                 |         |\n| 5        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\n</details>\n\nSince Temporal is AP, during failover (change of active Temporal Cluster Namespace), there can exist cases where more than one Cluster can modify a Workflow Execution, causing divergence of Workflow Execution History. Below shows how the version history will look like under such conditions.\n\n<details>\n<summary>Version history example (with data conflict)\n</summary>\n\nBelow, shows version history of the same Workflow Execution in 2 different Clusters.\n\n- Cluster A comes with initial version: 1\n- Cluster B comes with initial version: 2\n- Cluster C comes with initial version: 3\n- Shared version increment: 10\n\nT = 0:\n\nView in both Cluster B & C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             | 3               | 2       |\n| 3        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 1: adding event with event ID == 4 & version == 2 in Cluster B\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             | 4               | 2       |\n| 3        | 2             |                 |         |\n| 4        | 2             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 1: namespace failover to Cluster C, adding event with event ID == 4 & version == 3 in Cluster C\n\n```\n| -------- | ------------- | --------------- | ------- |\n| Events                   | Version History           |\n| -------- | ------------- | --------------- | ------- |\n| Event ID | Event Version | Event ID        | Version |\n| -------- | ------------- | --------------- | ------- |\n| 1        | 1             | 2               | 1       |\n| 2        | 1             | 3               | 2       |\n| 3        | 2             | 4               | 3       |\n| 4        | 3             |                 |         |\n| -------- | ------------- | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster C arrives in Cluster B\n\nNote: below are a tree structures\n\n```\n                | -------- | ------------- |\n                | Events                   |\n                | -------- | ------------- |\n                | Event ID | Event Version |\n                | -------- | ------------- |\n                | 1        | 1             |\n                | 2        | 1             |\n                | 3        | 2             |\n                | -------- | ------------- |\n                           |\n           | ------------- | ------------ |\n           |                              |\n| -------- | ------------- |   | -------- | ------------- |\n| Event ID | Event Version |   | Event ID | Event Version |\n| -------- | ------------- |   | -------- | ------------- |\n| 4        | 2             |   | 4        | 3             |\n| -------- | ------------- |   | -------- | ------------- |\n\n          | --------------- | ------- |\n          | Version History           |\n          | --------------- | ------- |\n          | Event ID        | Version |\n          | --------------- | ------- |\n          | 2               | 1       |\n          | 3               | 2       |\n          | --------------- | ------- |\n                            |\n                  | ------- | ------------------- |\n                  |                               |\n| --------------- | ------- |   | --------------- | ------- |\n| Event ID        | Version |   | Event ID        | Version |\n| --------------- | ------- |   | --------------- | ------- |\n| 4               | 2       |   | 4               | 3       |\n| --------------- | ------- |   | --------------- | ------- |\n```\n\nT = 2: replication task from Cluster B arrives in Cluster C, same as above\n\n</details>\n\n#### Conflict resolution\n\nWhen a Workflow Execution History diverges, proper conflict resolution is applied.\n\nIn Multi-cluster Replication, Workflow Execution History Events are modeled as a tree, as shown in the second example in [Version History](#version-history).\n\nWorkflow Execution Histories that diverge will have more than one history branch.\nAmong all history branches, the history branch with the highest version is considered the `current branch` and the Workflow Execution's mutable state is a summary of the current branch.\nWhenever there is a switch between Workflow Execution History branches, a complete rebuild of the Workflow Execution's mutable state will occur.\n\nTemporal Multi-Cluster Replication relies on asynchronous replication of Events across Clusters, so in the case of a failover it is possible to have an Activity Task dispatched again to the newly active Cluster due to a replication task lag.\nThis also means that whenever a Workflow Execution is updated after a failover by the new Cluster, any previous replication tasks for that Execution cannot be applied.\nThis results in loss of some progress made by the Workflow Execution in the previous active Cluster.\nDuring such conflict resolution, Temporal re-injects any external Events like Signals in the new Event History before discarding replication tasks.\nEven though some progress could roll back during failovers, Temporal provides the guarantee that Workflow Executions won’t get stuck and will continue to make forward progress.\n\nActivity Execution completions are not forwarded across Clusters.\nAny outstanding Activities will eventually time out based on the configuration.\nYour application should have retry logic in place so that the Activity gets retried and dispatched again to a Worker after the failover to the new Cluster.\nHandling this is similar to handling an Activity Task timeout caused by a Worker restarting.\n\n#### Zombie Workflows\n\nThere is an existing contract that for any Namespace and Workflow Id combination, there can be at most one run (Namespace + Workflow Id + Run Id) open / executing.\n\nMulti-cluster Replication aims to keep the Workflow Execution History as up-to-date as possible among all participating Clusters.\n\nDue to the nature of Multi-cluster Replication (for example, Workflow Execution History events are replicated asynchronously) different Runs (same Namespace and Workflow Id) can arrive at the target Cluster at different times, sometimes out of order, as shown below:\n\n```\n| ------------- |          | ------------- |          | ------------- |\n|   Cluster A   |          | Network Layer |          |   Cluster B   |\n| ------------- |          | ------------- |          | ------------- |\n        |                          |                          |\n        | Run 1 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        | Run 2 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          | Run 2 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n        |                          | Run 1 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n| ------------- |          | ------------- |          | ------------- |\n|   Cluster A   |          | Network Layer |          |   Cluster B   |\n| ------------- |          | ------------- |          | ------------- |\n```\n\nSince Run 2 appears in Cluster B first, Run 1 cannot be replicated as \"runnable\" due to the rule `at most one Run open` (see above), thus the \"zombie\" Workflow Execution state is introduced.\nA \"zombie\" state is one in which a Workflow Execution which cannot be actively mutated by a Cluster (assuming the corresponding Namespace is active in this Cluster). A zombie Workflow Execution can only be changed by a replication Task.\n\nRun 1 will be replicated similar to Run 2, except when Run 1's execution will become a \"zombie\" before Run 1 reaches completion.\n\n#### Workflow Task processing\n\nIn the context of Multi-cluster Replication, a Workflow Execution's mutable state is an entity which tracks all pending tasks.\nPrior to the introduction of Multi-cluster Replication, Workflow Execution History entries (events) are from a single branch, and the Temporal Server will only append new entries (events) to the Workflow Execution History.\n\nAfter the introduction of Multi-cluster Replication, it is possible that a Workflow Execution can have multiple Workflow Execution History branches.\nTasks generated according to one history branch may become invalidated by switching history branches during conflict resolution.\n\nExample:\n\nT = 0: task A is generated according to Event Id: 4, version: 2\n\n```\n| -------- | ------------- |\n| Events                   |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 1        | 1             |\n| 2        | 1             |\n| 3        | 2             |\n| -------- | ------------- |\n           |\n           |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event\n| -------- | ------------- |\n```\n\nT = 1: conflict resolution happens, Workflow Execution's mutable state is rebuilt and history Event Id: 4, version: 3 is written down to persistence\n\n```\n                | -------- | ------------- |\n                | Events                   |\n                | -------- | ------------- |\n                | Event ID | Event Version |\n                | -------- | ------------- |\n                | 1        | 1             |\n                | 2        | 1             |\n                | 3        | 2             |\n                | -------- | ------------- |\n                           |\n           | ------------- | -------------------------------------------- |\n           |                                                              |\n| -------- | ------------- |                                   | -------- | ------------- |\n| Event ID | Event Version |                                   | Event ID | Event Version |\n| -------- | ------------- |                                   | -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event  | 4        | 3             | <-- current branch / mutable state\n| -------- | ------------- |                                   | -------- | ------------- |\n```\n\nT = 2: task A is loaded.\n\nAt this time, due to the rebuild of a Workflow Execution's mutable state (conflict resolution), Task A is no longer relevant (Task A's corresponding Event belongs to non-current branch).\nTask processing logic will verify both the Event Id and version of the Task against a corresponding Workflow Execution's mutable state, then discard task A.\n","is_empty":false},{"file_name":"what-is-standard-visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-standard-visibility.md","id":172,"title":"What is Standard Visibility?","description":"Standard Visibility, within the Temporal Platform, is the subsystem and APIs that list Workflow Executions by a predefined set of filters.","label":"Standard Visibility","tags":["explanation","filtered-lists","visibility"],"markdown_content":"\nStandard Visibility, within the Temporal Platform, is the subsystem and APIs that list Workflow Executions by a predefined set of filters.\n\nOpen Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, or Run Id.\n\nClosed Workflow Executions can be filtered by a time constraint and either a Workflow Type, Workflow Id, Run Id, or Execution Status (Completed, Failed, Timed Out, Terminated, Canceled, or Continued-As-New).\n","is_empty":false},{"file_name":"what-is-task-routing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-task-routing.md","id":173,"title":"What is Task Routing?","description":"Task Routing is when a Task Queue is paired with one or more Worker Processes, primarily for Activity Task Executions.","label":"Task Routing","tags":["explanation"],"markdown_content":"\nTask Routing is simply when a Task Queue is paired with one or more Workers, primarily for Activity Task Executions.\n\nThis could also mean employing multiple Task Queues, each one paired with a Worker Process.\n\nTask Routing has many applicable use cases.\n\n### Flow control\n\nA Worker that consumes from a Task Queue asks for an Activity Task only when it has available capacity, so it is never overloaded by request spikes.\nIf Activity Tasks get created faster than Workers can process them, they are backlogged in the Task Queue.\n\n### Throttling\n\nThe rate at which each Activity Worker polls for and processes Activity Tasks is configurable per Worker.\nWorkers do not exceed this rate even if it has spare capacity.\nThere is also support for global Task Queue rate limiting.\nThis limit works across all Workers for the given Task Queue.\nIt is frequently used to limit load on a downstream service that an Activity calls into.\n\n### Specific environments\n\nIn some cases, you might need to execute Activities in a dedicated environment.\nTo send Activity Tasks to this environment, use a dedicated Task Queue.\n\n#### Route Activity Tasks to a specific host\n\nIn some use cases, such as file processing or machine learning model training, an Activity Task must be routed to a specific Worker Process or Worker Entity.\n\nFor example, suppose that you have a Workflow with the following three separate Activities:\n\n- Download a file.\n- Process the file in some way.\n- Upload a file to another location.\n\nThe first Activity, to download the file, could occur on any Worker on any host.\nHowever, the second and third Activities must be executed by a Worker on the same host where the first Activity downloaded the file.\n\nIn a real-life scenario, you might have many Worker Processes scaled over many hosts.\nYou would need to develop your Temporal Application to route Tasks to specific Worker Processes when needed.\n\nCode samples:\n\n- [Go file processing example](https://github.com/temporalio/samples-go/tree/master/fileprocessing)\n- [Java file processing example](https://github.com/temporalio/samples-java/tree/master/src/main/java/io/temporal/samples/fileprocessing)\n- [PHP file processing example](https://github.com/temporalio/samples-php/tree/master/app/src/FileProcessing)\n\n#### Sessions\n\nSome SDKs provide a Session API that provides a straightforward way to ensure that Activity Tasks are executed with the same Worker without requiring you to manually specify Task Queue names.\nIt also includes features like **concurrent session limitations** and **worker failure detection**.\n\n- [How to create Worker Sessions in Go](/go/how-to-create-a-worker-session-in-go)\n\n#### Route Activity Tasks to a specific process\n\nSome Activities load large datasets and cache them in the process.\nThe Activities that rely on those datasets should be routed to the same process.\n\nIn this case, a unique Task Queue would exist for each Worker Process involved.\n\n#### Workers with different capabilities\n\nSome Workers might exist on GPU boxes versus non-GPU boxes.\nIn this case, each type of box would have its own Task Queue and a Workflow can pick one to send Activity Tasks.\n\n### Multiple priorities\n\nIf your use case involves more than one priority, you can create one Task Queue per priority, with a Worker pool per priority.\n\n### Versioning\n\nTask Routing is the simplest way to version your code.\n\nIf you have a new backward-incompatible Activity Definition, start by using a different Task Queue.\n","is_empty":false},{"file_name":"what-is-temporal-cloud.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-temporal-cloud.md","id":174,"title":"What is Temporal Cloud?","description":"Temporal Cloud is a managed, hosted Temporal environment that provides a platform for Temporal Applications.","label":"Temporal Cloud","tags":["explanation"],"markdown_content":"\nTemporal Cloud is a managed, hosted Temporal environment that provides a platform for [Temporal Applications](/temporal/#temporal-application)—an alternative to deploying and operating your own [Temporal Cluster](/clusters).\n\nTemporal Cloud is offered in units of isolation known as [Namespaces](/namespaces). You can provision and use one or more Cloud Namespaces. A typical use case is to use separate Namespaces as development, testing, integration, staging, and production environments for an application.\n","is_empty":false},{"file_name":"what-is-temporal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-temporal.md","id":175,"title":"What is Temporal?","description":"Temporal is a scalable and reliable runtime for Reentrant Processes called Temporal Workflow Executions.","label":"Temporal","tags":["explanation"],"markdown_content":"\nTemporal is a scalable and reliable runtime for Reentrant Processes called [Temporal Workflow Executions](/concepts/what-is-a-workflow-execution).\n\n<!-- TODO content more appropriate for blog\n:::note [Temporal's tenth rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule)\n\nAny sufficiently complex distributed system contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of temporal.io.\n\n:::\n-->\n\n![The Temporal System](/diagrams/temporal-system-simple.svg)\n","is_empty":false},{"file_name":"what-is-the-temporal-platform.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-the-temporal-platform.md","id":176,"title":"What is the Temporal Platform?","description":"The Temporal Platform consists of a Temporal Cluster and Worker Processes.","label":"Temporal Platform","tags":["explanation"],"markdown_content":"\nThe Temporal Platform consists of a [Temporal Cluster](/concepts/what-is-a-temporal-cluster) and [Worker Processes](/concepts/what-is-a-worker-process).\nTogether these components create a runtime for Workflow Executions.\n\n![The Temporal Platform (runtime)](/diagrams/temporal-platform-simple.svg)\n\nThe Temporal Cluster is open source and can be operated by you.\nThe Temporal Cloud is a set of Clusters operated by us.\n\nWorker Processes are hosted by you and execute your code.\nThey communicate with a Temporal Cluster via gRPC.\n","is_empty":false},{"file_name":"what-is-the-temporal-server.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-the-temporal-server.md","id":177,"title":"What is the Temporal Server?","description":"The Temporal Server is a grouping of four horizontally scalable services.","label":"Temporal Server","tags":["explanation"],"markdown_content":"\nThe Temporal Server consists of four independently scalable services:\n\n- Frontend gateway: for rate limiting, routing, authorizing.\n- History subsystem: maintains data (mutable state, queues, and timers).\n- Matching subsystem: hosts Task Queues for dispatching.\n- Worker Service: for internal background Workflows.\n\nFor example, a real-life production deployment can have 5 Frontend, 15 History, 17 Matching, and 3 Worker Services per cluster.\n\nThe Temporal Server services can run independently or be grouped together into shared processes on one or more physical or virtual machines.\nFor live (production) environments, we recommend that each service runs independently, because each one has different scaling requirements and troubleshooting becomes easier.\nThe History, Matching, and Worker Services can scale horizontally within a Cluster.\nThe Frontend Service scales differently than the others because it has no sharding or partitioning; it is just stateless.\n\nEach service is aware of the others, including scaled instances, through a membership protocol via [Ringpop](https://github.com/temporalio/ringpop-go).\n\n#### Versions and support\n\nAll Temporal Server releases abide by the [Semantic Versioning Specification](https://semver.org/).\n\nFairly precise upgrade paths and support have been established starting from Temporal `v1.7.0`.\n\nWe provide maintenance support for previously published minor and major versions by continuing to release critical bug fixes related to security, the prevention of data loss, and reliability, whenever they are found.\n\nWe aim to publish incremental upgrade guides for each minor and major version, which include specifics about dependency upgrades that we have tested for (such as Cassandra 3.0 -> 3.11).\n\nWe offer maintenance support of the last three **minor** versions after a release and do not plan to \"backport\" patches beyond that.\n\nWe offer maintenance support of **major** versions for at least 12 months after a GA release, and we provide at least 6 months' notice before EOL/deprecating support.\n\n#### Dependencies\n\nTemporal offers official support for, and is tested against, dependencies with the exact versions described in the `go.mod` file of the corresponding release tag.\n(For example, [v1.5.1](https://github.com/temporalio/temporal/tree/v1.5.1) dependencies are documented in [the go.mod for v1.5.1](https://github.com/temporalio/temporal/blob/v1.5.1/go.mod).)\n\n#### Frontend Service\n\nThe Frontend Service is a stateless gateway service that exposes a strongly typed [Proto API](https://github.com/temporalio/api/blob/master/temporal/api/workflowservice/v1/service.proto).\nThe Frontend Service is responsible for rate limiting, authorizing, validating, and routing all inbound calls.\n\n![Frontend Service](/diagrams/temporal-frontend-service.svg)\n\nTypes of inbound calls include the following:\n\n- Domain CRUD\n- External events\n- Worker polls\n- Visibility requests\n- Admin operations via [tctl](/tctl) (the Temporal CLI)\n- Calls from a remote Cluster related to [Multi-Cluster Replication](/concepts/what-is-multi-cluster-replication)\n\nEvery inbound request related to a Workflow Execution must have a Workflow Id, which is hashed for routing purposes.\nThe Frontend Service has access to the hash rings that maintain service membership information, including how many nodes (instances of each service) are in the Cluster.\n\nInbound call rate limiting is applied per host and per namespace.\n\nThe Frontend Service talks to the Matching Service, History Service, Worker Service, the database, and Elasticsearch (if in use).\n\n- It uses the grpcPort 7233 to host the service handler.\n- It uses port 6933 for membership-related communication.\n\n#### History Service\n\nThe History Service tracks the state of Workflow Executions.\n\n![History Service](/diagrams/temporal-history-service.svg)\n\nThe History Service scales horizontally via individual shards, configured during the Cluster's creation.\nThe number of shards remains static for the life of the Cluster (so you should plan to scale and over-provision).\n\nEach shard maintains data (routing identifiers, mutable state) and queues.\nA History shard maintains four types of queues:\n\n- Transfer queue: transfers internal tasks to the Matching Service.\n  Whenever a new Workflow Task needs to be scheduled, the History Service transactionally dispatches it to the Matching Service.\n- Timer queues: durably persists Timers.\n- Replicator queue: asynchronously replicates Workflow Executions from active Clusters to other passive Clusters (experimental Multi-Cluster feature).\n- Visibility queue: pushes data to the visibility index (Elasticsearch).\n\nThe History Service talks to the Matching Service and the Database.\n\n- It uses grpcPort 7234 to host the service handler.\n- It uses port 6934 for membership-related communication.\n\n#### Matching Service\n\nThe Matching Service is responsible for hosting Task Queues for Task dispatching.\n\n![Matching Service](/diagrams/temporal-matching-service.svg)\n\nIt is responsible for matching Workers to Tasks and routing new Tasks to the appropriate queue.\nThis service can scale internally by having multiple instances.\n\nIt talks to the Frontend Service, History Service, and the database.\n\n- It uses grpcPort 7235 to host the service handler.\n- It uses port 6935 for membership related communication.\n\n#### Worker Service\n\nThe Worker Service runs background processing for the replication queue, system Workflows, and (in versions older than 1.5.0) the Kafka visibility processor.\n\n![Worker Service](/diagrams/temporal-worker-service.svg)\n\nIt talks to the Frontend Service.\n\n- It uses port 6939 for membership-related communication.\n","is_empty":false},{"file_name":"what-is-the-temporal-web-ui.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-the-temporal-web-ui.md","id":178,"title":"What is the Temporal Web UI?","description":"The Temporal Web UI","label":"Temporal Web UI","tags":["term","web-ui"],"markdown_content":"\n:::info Upgrade available\n\nTemporal Web UI v2 is now generally available.\n\nTemporal Web UI v1 is being deprecated on September 30, 2022.\n\n:::\n\nThe Temporal Web UI is a GUI that provides users with Workflow Execution state and metadata and is intended to be used to debug execution issues.\nIt ships with every [docker-compose](/application-development/foundations#docker-compose) update and is available with [Temporal Cloud](/cloud).\n\nYou can configure the Temporal Web UI to work in your own environment.\nSee the [UI configuration reference](/references/ui-configuration).\n\nWeb UI open source repos:\n\n- [temporalio/ui](https://github.com/temporalio/ui)\n- [temporalio/ui-server](https://github.com/temporalio/ui-server)\n\nThe Web UI is packed with several features.\n\n### Namespace selection\n\nUsers can switch between Namespaces by clicking the Namespace Switcher icon in the left navigation.\nClicking the Namespace Switcher reveals a side panel where users can search for a Namespace or select a Namespace from the list.\nAfter a Namespace is selected, the user is redirected to the Recent Workflows page for that Namespace.\nIn Temporal Cloud, users can access only Namespaces that they have been granted access to.\n\n### Recent Workflows\n\nThe Recent Workflows page lists the most recent 1,000 Workflow Executions in the past 24 hours, by default.\nUsers can list Workflow Executions by any of the following:\n\n- [Workflow ID](/concepts/what-is-a-workflow-id)\n- [Workflow Type](/concepts/what-is-a-workflow-type)\n- Status\n- Date & Time—users can set their preferred date & time format as one of the following:\n  - UTC\n  - Local\n  - Relative\n- A [List Filter](/concepts/what-is-a-list-filter)\n\nSelect a Workflow Execution to see a breakdown of the Workflow Execution's History, Workers, and pending Activities.\n\n#### History\n\nThis is a view of the [Events](/concepts/what-is-an-event) and Event fields that make up the Workflow Execution.\nApproximately [40 different Events](/references/events) can appear in a Workflow Execution's Event History.\nThe top of the page lists the following execution metadata:\n\n- [Workflow Type](/concepts/what-is-a-workflow-type)\n- [Run ID](/concepts/what-is-a-run-id)\n- Start Time and Close Time\n- [Task Queue](/concepts/what-is-a-task-queue)\n- Parent and Parent ID\n- State Transitions\n\nThe Input and Results section displays the function arguments and return values for debugging purposes.\nResults are not available until the Workflow finishes.\n\nThe Recent Events tab has the following views:\n\n- Timeline: A chronological or reverse-chronological order of events with a summary.\n  Clicking into an Event displays all details for that Event.\n  Clicking “Expand all” displays all Event details.\n  Similarly, clicking “Collapse all” collapses the table and displays only the summary.\n- Compact: A logical grouping of Activities, Signals and Timers.\n- JSON: The full JSON code for the workflow.\n\n#### Download Event History\n\nThe entire Workflow Execution Event History, in JSON format, can be downloaded from this screen.\n\n#### Terminate Workflow\n\nWorkflow Executions can be Terminated directly from the UI.\nA custom note can be logged from the UI when that happens.\n\n#### Workers\n\nDisplays the Workers currently polling on the Workflow Task Queue with a count.\nIf no Workers are polling, an error displays.\n\n#### Pending Activities\n\nDisplays a summary of recently active and/or pending Activity Executions.\nClicking a pending Activity directs the user to the Pending Activities tab to view details.\n\n#### Stack Trace\n\nThe screen shows the captured result from the [\\_\\_stack_trace](/workflows#stack-trace-query) Query.\nThe Query is performed when the tab is selected.\nIt works only if a Worker is running and available to return the stack trace.\n\n#### Queries\n\nLists all Queries sent to the Workflow Execution.\n\n### Settings\n\nDisplays the following information:\n\n- Description of the Namespace.\n- Owner: Namespace owner.\n- Global?: Whether the Namespace is a Global Namespace\n- Retention Period: Namespace Retention Period\n- History Archival: Whether History Archival is enabled\n- Visibility Archival: Whether Visibility Archival is enabled\n- Failover Version: Namespace Failover Version\n- Clusters: Cluster information\n\n### Archival\n\n[Archival](/concepts/what-is-archival) feature information.\n\n### Import Event History\n\nNavigate to `/import` to import an Event History in JSON format and populate a Workflow details page.\n\n### Data Encoder\n\nThe Web UI can use the same Data Converter that Workers use for inputs and return values.\nThe UI supports both a Remote Codec endpoint and/or the tctl plugin port.\n","is_empty":false},{"file_name":"what-is-visibility.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/what-is-visibility.md","id":179,"title":"What is Visibility?","description":"The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.","label":"Visibility","markdown_content":"\nThe term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.\n","is_empty":false},{"file_name":"why-temporal.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/concepts/why-temporal.md","id":180,"title":"What are the differences between Temporal and a traditional system?","description":"This page compares a function execution in a traditional system and a Workflow Execution in Temporal.","tags":["explanation"],"markdown_content":"\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nOne of the aspects of the Temporal System is that it abstracts the complexity of a distributed system.\nDistributed systems exist to scale computation across multiple machines as the potential load of a system changes.\nIn theory, a distributed system facilitates a reliable and highly performant application.\n\nHowever, any failure that leaves the downstream part of the application waiting for a response can make things very complicated, especially at a large scale.\n\n![Distributed application failures](/diagrams/basic-distributed-system.svg)\n\nHow will a downstream part of the application know if there was a failure before or a failure after changes to the state if there is no response?\nHow will the application track and reconcile an inconsistent state?\n\nIn traditional systems, a large investment is often made to maintain the health of each individual component, visualize the health of the overall system, define timeout constraints for computations, orchestrate retries for computations that fail, and maintain a consistent state.\n\nThese systems are often a mixture of stateless services, databases, cron jobs, and queues.\nAnd as these systems scale, responding to multiple asynchronous events, communicating with unreliable external resources, or tracking the state of something very complex becomes more and more challenging.\n\nTemporal restructures the use of services, databases, cron jobs, queues, host processes, and SDKs, into the Temporal Platform, and addresses failures head on.\n\nIn a traditional system, the service exists to spawn function executions.\nThe Temporal Platform exists to facilitate [Workflow Executions](/concepts/what-is-a-workflow-execution).\n\n![Temporal vs Traditional system](/diagrams/temporal-vs-traditional.svg)\n\nAlthough the two systems seem similar at first glance, they differ in several significant ways.\n\n**Failure**\n\nWith a traditional system, a service function execution is both volatile and short-lived.\n\n- If a function execution fails, it's not resumable because all execution state is lost. The longer a function execution awaits, the higher the chance of failure.\n- A traditional function execution typically has a limited lifespan, often measured in minutes.\n\nWith Temporal, a Workflow Execution is resumable.\n\n- A Workflow Execution is fully resumable after a failure.\n- Temporal imposes no deadlines on Workflow Executions.\n\n**State**\n\nWith a traditional system, stoppage or failure means that all execution state is lost.\nYour application (or a supporting component) must monitor the service's response to initiate a retry of the service execution.\nA retry starts from its _initial_ state.\n\nWith Temporal, computation resumes from its _latest_ state. All progress is retained.\n\n**Communication**\n\nWith a traditional system, you can't communicate with a function execution.\n\nWith Temporal, [Signals](/concepts/what-is-a-signal) and [Queries](/concepts/what-is-a-query) enable data to be sent to or extracted from a Workflow Execution.\n\n**Scope**\n\nWith a traditional system, a service function execution can at best represent a business process.\nTypically, it represents only a part of a business process.\n\nA Temporal Workflow Execution can represent a business process or an entire business object.\n\n### Example subscription use case\n\nLet's look at a subscription-based use case to compare the difference between a Temporal Application and other traditional approaches.\n\nThe basic business steps are as follows:\n\n1. A customer signs up for a service that has a trial period.\n2. After the trial period, if the customer has not canceled, they should be charged once a month.\n3. The customer has to be notified via email about the charges and should be able to cancel the subscription at any time.\n\nThis business logic is not very complicated and can be expressed in a few dozen lines of code.\nAny practical implementation also has to ensure that the business process is fault-tolerant and scalable.\n\n**Database-centric design approach**\n\nThe first approach might be to center everything around a database where an application process would periodically scan the database tables for customers in specific states, execute necessary actions, and update the database to reflect changes.\n\nHowever, there are various drawbacks.\n\n- The most obvious one is that the application state machine of the customer's state quickly becomes extremely complicated.\n  For example, if a credit card charge attempt fails or sending an email fails due to a downstream system's unavailability, the state is now in limbo.\n- Failed calls likely need to be retried for a long time, and these calls need to be throttled to not overload external resources.\n- There needs to be logic to handle corrupted customer records to avoid blocking the whole process.\n- Additionally, databases have performance and scalability limitations (eventually requiring sharding) and are not efficient for scenarios that require constant polling.\n\n**Queue system design approach**\n\nThe next commonly employed approach is to use a timer service and queues.\nUpdates are pushed to a queue while a service consumes them one at a time, updating a database, and possibly pushing more messages into other downstream queues.\nA timer service can be used to schedule queue polling or database actions.\n\nWhile this approach has shown to scale a bit better, the programming model can become very complex and error-prone, as there are usually no transactional updates between a queuing system, a timer service, and a database.\n\n**Temporal design approach**\n\nThe Temporal Platform approach aims to encapsulate and implement the entire business logic in a simple function or object method.\nThanks to the Temporal Platform, the function/method is durably stateful, and the implementer doesn't need to employ any additional systems to ensure consistency and fault tolerance.\n\nHere are example Workflow Definitions that implement the subscription management use case in Java, Go, Typescript and PHP:\n\n<Tabs\ndefaultValue=\"java\"\nvalues={[\n{label: 'Go', value: 'go'},\n{label: 'Java', value: 'java'},\n{label: 'Typescript', value: 'ts'},\n{label: 'PHP', value: 'php'},\n]\n}>\n\n<TabItem value=\"go\">\n\n<!--SNIPSTART subscription-go-workflow-definition-->\n<!--SNIPEND-->\n\n</TabItem>\n<TabItem value=\"java\">\n\n<!--SNIPSTART subscription-java-workflow-definition-implementation-->\n<!--SNIPEND-->\n\n</TabItem>\n<TabItem value=\"ts\">\n\n<!--SNIPSTART subscription-ts-workflow-definition-->\n<!--SNIPEND-->\n\n</TabItem>\n<TabItem value=\"php\">\n\n<!--SNIPSTART subscription-php-workflow-definition-implementation-->\n<!--SNIPEND-->\n\n</TabItem>\n</Tabs>\n\nAgain, it is important to note that this is working application code that directly implements the business logic.\nIf any of the operations take a long time, the code is not going to change.\n\nIt is completely okay to be blocked on `chargeCustomerForBillingPeriod` for a day or more if the downstream processing service is down or not responding.\nIn the same way, it is a completely normal operation to sleep for 30 days directly inside the Workflow code.\nThis is possible because infrastructure failures won't affect the Workflow state—including threads, blocking calls, and any variables.\n\nThe Temporal Platform has practically no scalability limits on the number of open Workflow Executions, so this code can be used over and over even if your application has hundreds of millions of customers.\n","is_empty":false},{"file_name":"api-reference-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/api-reference-go.md","id":181,"title":"API reference","label":"API reference","markdown_content":"\nThe Temporal Go SDK API reference is published on [pkg.go.dev](https://pkg.go.dev/go.temporal.io/sdk).\n","is_empty":false},{"file_name":"code-samples-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/code-samples-go.md","id":182,"title":"Code samples","label":"Code samples","markdown_content":"\n- [Go Samples repo](https://github.com/temporalio/samples-go#samples-directory)\n- [Background Check application](https://github.com/temporalio/background-checks): Provides a non-trivial Temporal Application implementation in conjunction with [application documentaion](https://learn.temporal.io/examples/go/background-checks/).\n- [Hello world application template in Go](https://github.com/temporalio/hello-world-project-template-go): Provides a quick-start development app for users.\n  This sample works in conjunction with the [\"Hello World!\" from scratch tutorial in Go](https://learn.temporal.io/getting_started/go/hello_world_in_go/).\n- [Money transfer application template in Go](https://github.com/temporalio/money-transfer-project-template-go): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Go](https://learn.temporal.io/getting_started/go/first_program_in_go/).\n- [Subscription-style Workflow Definition in Go](https://github.com/temporalio/subscription-workflow-project-template-go): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n- [eCommerce application example in Go](https://github.com/temporalio/temporal-ecommerce): Showcases a per-user shopping cart–style Workflow Definition that includes an API for adding and removing items from the cart as well as a web UI.\n  This application sample works in conjunction with the [eCommerce in Go tutorial](/blog/tags/go-ecommerce-tutorial).\n","is_empty":false},{"file_name":"error-handling.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/error-handling.md","id":183,"title":"Error Handling in Go","markdown_content":"\nAn Activity, or a Child Workflow, might fail, and you could handle errors differently based on the different\nerror cases.\n\nIf the Activity returns an error as `errors.New()` or `fmt.Errorf()`, that error is converted into `*temporal.ApplicationError`.\n\nIf the Activity returns an error as `temporal.NewNonRetryableApplicationError(\"error message\", details)`, that error is returned as `*temporal.ApplicationError`.\n\nThere are other types of errors such as `*temporal.TimeoutError`, `*temporal.CanceledError` and\n`*temporal.PanicError`.\nFollowing is an example of what your error code might look like:\n\nHere's an example of handling Activity errors within Workflow code that differentiates between different error types.\n\n```go\nerr := workflow.ExecuteActivity(ctx, YourActivity, ...).Get(ctx, nil)\nif err != nil {\n\tvar applicationErr *ApplicationError\n\tif errors.As(err, &applicationErr) {\n\t\t// retrieve error message\n\t\tfmt.Println(applicationError.Error())\n\n\t\t// handle Activity errors (created via NewApplicationError() API)\n\t\tvar detailMsg string // assuming Activity return error by NewApplicationError(\"message\", true, \"string details\")\n\t\tapplicationErr.Details(&detailMsg) // extract strong typed details\n\n\t\t// handle Activity errors (errors created other than using NewApplicationError() API)\n\t\tswitch applicationErr.Type() {\n\t\tcase \"CustomErrTypeA\":\n\t\t\t// handle CustomErrTypeA\n\t\tcase CustomErrTypeB:\n\t\t\t// handle CustomErrTypeB\n\t\tdefault:\n\t\t\t// newer version of Activity could return new errors that Workflow was not aware of.\n\t\t}\n\t}\n\n\tvar canceledErr *CanceledError\n\tif errors.As(err, &canceledErr) {\n\t\t// handle cancellation\n\t}\n\n\tvar timeoutErr *TimeoutError\n\tif errors.As(err, &timeoutErr) {\n\t\t// handle timeout, could check timeout type by timeoutErr.TimeoutType()\n        switch err.TimeoutType() {\n        case commonpb.ScheduleToStart:\n                // Handle ScheduleToStart timeout.\n        case commonpb.StartToClose:\n                // Handle StartToClose timeout.\n        case commonpb.Heartbeat:\n                // Handle heartbeat timeout.\n        default:\n        }\n\t}\n\n\tvar panicErr *PanicError\n\tif errors.As(err, &panicErr) {\n\t\t// handle panic, message and stack trace are available by panicErr.Error() and panicErr.StackTrace()\n\t}\n}\n```\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-go.md","id":184,"title":"How to add custom Search Attributes to Workflow Executions at start time in Go","description":"Add custom Search Attributes to Workflow Executions at start time","label":"Add custom Search Attributes to Workflow Executions at start time","tags":["developer-guide","go","client"],"markdown_content":"\nProvide key-value pairs in [`StartWorkflowOptions.SearchAttributes`](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions).\n\nSearch Attributes are represented as `map[string]interface{}`.\nThe values in the map must correspond to the [Search Attribute's value type](/concepts/what-is-a-search-attribute/#types):\n\n- Bool = `bool`\n- Datetime = `time.Time`\n- Double = `float64`\n- Int = `int64`\n- Keyword = `string`\n- Text = `string`\n\nIf you had custom Search Attributes `CustomerId` of type Keyword and `MiscData` of type Text, you would provide `string` values:\n\n```go\nfunc (c *Client) CallYourWorkflow(ctx context.Context, workflowID string, payload map[string]interface{}) error {\n    // ...\n    searchAttributes := map[string]interface{}{\n        \"CustomerId\": payload[\"customer\"],\n        \"MiscData\": payload[\"miscData\"]\n    }\n    options := client.StartWorkflowOptions{\n        SearchAttributes:   searchAttributes\n        // ...\n    }\n    we, err := c.Client.ExecuteWorkflow(ctx, options, app.YourWorkflow, payload)\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-asynchronously-complete-an-activity-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-asynchronously-complete-an-activity-in-go.md","id":185,"title":"How to asynchronously complete an Activity in Go","description":"todo","label":"Asynchronous Activity Completion","tags":["how-to","go"],"markdown_content":"\n1. Provide the external system with the a Task Token to complete the Activity Execution.\n   To do this, use the `GetInfo()` API from the `go.temporal.io/sdk/activity` package.\n\n```go\n// Retrieve the Activity information needed to asynchronously complete the Activity.\nactivityInfo := activity.GetInfo(ctx)\ntaskToken := activityInfo.TaskToken\n// Send the taskToken to the external service that will complete the Activity.\n```\n\n2. Return an `activity.ErrResultPending` error to indicate that the Activity is completing asynchronously.\n\n```go\nreturn \"\", activity.ErrResultPending\n```\n\n3. Use the Temporal Client to complete the Activity using the Task Token.\n\n```go\n// Instantiate a Temporal service client.\n// The same client can be used to complete or fail any number of Activities.\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n\n// Complete the Activity.\ntemporalClient.CompleteActivity(context.Background(), taskToken, result, nil)\n```\n\nFollowing are the parameters of the `CompleteActivity` function:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `result`: The return value to record for the Activity. The type of this value must match the type\n  of the return value declared by the Activity function.\n- `err`: The error code to return if the Activity terminates with an error.\n\nIf `error` is not null, the value of the `result` field is ignored.\n\nTo fail the Activity, you would do the following:\n\n```go\n// Fail the Activity.\nclient.CompleteActivity(context.Background(), taskToken, nil, err)\n```\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-configure-tracing-in-go.md","id":186,"title":"How to configure tracing in Go","description":"Configure tracing","label":"Configure tracing","tags":["go","how-to"],"markdown_content":"\nThe Go SDK provides support for distributed tracing through [OpenTracing](https://opentracing.io/).\nTracing allows you to view the call graph of a Workflow along with its Activities and any child Workflows.\n\nTracing can be configured by providing an [opentracing.Tracer](https://pkg.go.dev/github.com/opentracing/opentracing-go#Tracer)\nimplementation in [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions) during client instantiation.\n\nFor more details on how to configure and leverage tracing, see the [OpenTracing documentation](https://opentracing.io/docs/getting-started/).\n\nThe OpenTracing support has been validated using [Jaeger](https://www.jaegertracing.io/), but other implementations mentioned [here](https://opentracing.io/docs/supported-tracers/) should also work.\n\nTracing functionality utilizes generic context propagation provided by the Client.\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-continue-as-new-in-go.md","id":187,"title":"How to Continue-As-New-in-Go","description":"To cause a Workflow Execution to Continue-As-New, the Workflow function should return the result of the `NewContinueAsNewError()` API available from the `go.temporal.io/sdk/workflow` package.","label":"Continue-As-New","tags":["go","developer-guide"],"markdown_content":"\nTo cause a Workflow Execution to [Continue-As-New](/concepts/what-is-continue-as-new), the Workflow function should return the result of the [`NewContinueAsNewError()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#NewContinueAsNewError) API available from the `go.temporal.io/sdk/workflow` package.\n\n```go\nfunc SimpleWorkflow(ctx workflow.Context, value string) error {\n    ...\n    return workflow.NewContinueAsNewError(ctx, SimpleWorkflow, value)\n}\n```\n\nTo check whether a Workflow Execution was spawned as a result of Continue-As-New, you can check if `workflow.GetInfo(ctx).ContinuedExecutionRunID` is not nil.\n\n**Notes**\n\n- To prevent Signal loss, be sure to perform an asynchronous drain on the Signal channel.\n  Failure to do so can result in buffered Signals being ignored and lost.\n- Make sure that the previous Workflow and the Continue-As-New Workflow are referenced by the same alias.\n  Failure to do so can cause the Workflow to Continue-As-New on an entirely different Workflow.\n","is_empty":false},{"file_name":"how-to-create-a-custom-data-converter-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-create-a-custom-data-converter-in-go.md","id":188,"title":"How to create a custom Data Converter in Go","description":"Wrap your custom functionality around the default Data Converter.","label":"Custom Data Converter","tags":["go","developer-guide"],"markdown_content":"\nWrap your custom functionality around the default [Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter).\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-create-a-temporal-client-in-go.md","id":189,"title":"How to create a Temporal Client in Go","description":"Use the `NewClient()` API available in the `go.temporal.io/sdk/client` package to create a new `Client`.","label":"Temporal Client","tags":["go","how-to"],"markdown_content":"\nUse the [`Dial()`](https://pkg.go.dev/go.temporal.io/sdk/client#Dial) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to create a new [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nIf you don't provide [`HostPort`](https://pkg.go.dev/go.temporal.io/sdk@v1.15.0/internal#ClientOptions), the Client defaults the address and port number to `127.0.0.1:7233`.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n}\n```\n\nTo connect to your Cluster, specify `HostPort` followed by your Cluster address.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{\n    HostPort: \"web.<Namespace_ID>.tmprl.cloud.\",\n  })\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-create-a-worker-session-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-create-a-worker-session-in-go.md","id":190,"title":"How to create a Worker Session in Go","description":"First, enable Sessions on the Worker via the Worker Options and then use the `CreateSession` API to create a Context object that can be passed to the calls to spawn Activity Executions.","label":"Worker Session","tags":["go","developer-guide"],"markdown_content":"\nFirst, [enable Sessions on the Worker via the Worker Options](/go/how-to-set-workeroptions-in-go#enablesessionworker).\n\nNext, use the [`CreateSession`](https://pkg.go.dev/go.temporal.io/sdk/workflow#CreateSession) API to create a Context object that can be passed to calls to spawn Activity Executions.\n\nPass an instance of `workflow.Context` and [`SessionOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SessionOptions) to the `CreateSession` API call and get a Session Context which contains metadata information of the Session.\n\nUse the Session Context to spawn all Activity Executions that should belong to the Session.\nAll associated Activity Tasks are then processed by the same Worker Entity.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, fileID string) (err error) {\n // ...\n sessionOptions := &workflow.SessionOptions{\n   CreationTimeout:  time.Minute,\n   ExecutionTimeout: time.Minute,\n }\n sessionCtx, err := workflow.CreateSession(ctx, sessionOptions)\n if err != nil {\n   return err\n }\n defer workflow.CompleteSession(sessionCtx)\n\n var activityResult1 *ActivityResult1\n err = workflow.ExecuteActivity(sessionCtx, ActivityFunction1, param1).Get(sessionCtx, &activityResult1)\n if err != nil {\n   return err\n }\n\n var activityResult2 *ActivityResult2\n err = workflow.ExecuteActivity(sessionCtx, ActivityFunction2, *activityResult1).Get(sessionCtx, &activityResult2)\n if err != nil {\n   return err\n }\n\n return workflow.ExecuteActivity(sessionCtx, uploadFileActivityName, *activityResult2).Get(sessionCtx, nil)\n}\n```\n\nWhen the `CreateSession` API is called, the Task Queue name that is specified in the `ActivityOptions` is used (or in the `StartWorkflowOptions` if the Task Queue name is not specified in `ActivityOptions`), and a Session is created with one of the Workers polling that Task Queue.\n\nThe Session Context is cancelled if the Worker executing this Session dies or `CompleteSession()` is called.\nWhen using the returned Session Context to spawn Activity Executions, a `workflow.ErrSessionFailed` error may be returned if the Session framework detects that the Worker executing this Session has died.\nThe failure of Activity Executions won't affect the state of the Session, so you still need to handle the errors returned from your Activities and call `CompleteSession()` if necessary.\n\n`CreateSession()` will return an error if the context passed in already contains an open Session.\nIf all the Workers are currently busy and unable to handle a new Session, the framework will keep retrying until the `CreationTimeout` you specified in `SessionOptions` has passed before returning an error (check the **Concurrent Session Limitation** section for more details).\n\n`CompleteSession()` releases the resources reserved on the Worker, so it's important to call it as soon as you no longer need the Session.\nIt will cancel the session context and therefore all the Activity Executions using that Session Context.\nNote that it's safe to call `CompleteSession()` on a failed Session, meaning that you can call it from a `defer` function after the Session is successfully created.\n\n#### Session metadata\n\n```go\ntype SessionInfo struct {\n // A unique Id for the session\n SessionID         string\n // The hostname of the worker that is executing the session\n HostName          string\n // ... other unexported fields\n}\n\nfunc GetSessionInfo(ctx Context) *SessionInfo\n```\n\nThe Session Context also stores some Session metadata, which can be retrieved by the `GetSessionInfo()` API.\nIf the Context passed in doesn't contain any Session metadata, this API will return a `nil` pointer.\n\n#### Limiting concurrent Sessions\n\nTo limit the number of concurrent Sessions running on a Worker, set the `MaxConcurrentSessionExecutionSize` field of `worker.Options` to the desired value.\nBy default, this field is set to a very large value, so there's no need to manually set it if no limitation is needed.\n\nIf a Worker hits this limitation, it won't accept any new `CreateSession()` requests until one of the existing sessions is completed. `CreateSession()` will return an error if the session can't be created within `CreationTimeout`.\n\n#### Recreate Session\n\nFor long-running Sessions, you may want to use the `ContinueAsNew` feature to split the Workflow into multiple runs when all Activities need to be executed by the same Worker.\nThe `RecreateSession()` API is designed for such a use case.\n\n```go\nfunc RecreateSession(ctx Context, recreateToken []byte, sessionOptions *SessionOptions) (Context, error)\n```\n\nIts usage is the same as `CreateSession()` except that it also takes in a `recreateToken`, which is needed to create a new Session on the same Worker as the previous one.\nYou can get the token by calling the `GetRecreateToken()` method of the `SessionInfo` object.\n\n```go\ntoken := workflow.GetSessionInfo(sessionCtx).GetRecreateToken()\n```\n\n**Is there a complete example?**\n\nYes, the [file processing example](https://github.com/temporalio/samples-go/tree/master/fileprocessing) in the [temporalio/samples-go](https://github.com/temporalio/samples-go) repo has been updated to use the session framework.\n\n**What happens to my Activity if the Worker dies?**\n\nIf your Activity has already been scheduled, it will be canceled.\nIf not, you will get a `workflow.ErrSessionFailed` error when you call `workflow.ExecuteActivity()`.\n\n**Is the concurrent session limitation per process or per host?**\n\nIt's per Worker Process, so make sure there's only one Worker Process running on the host if you plan to use this feature.\n\n**Future Work**\n\n- Right now, a Session is considered failed if the Worker Process dies.\n  However, for some use cases, you may only care whether the Worker host is alive or not.\n  For these use cases, the Session should be automatically re-established if the Worker Process is restarted.\n\n- The current implementation assumes that all Sessions are consuming the same type of resource and there's only one global limitation.\n  Our plan is to allow you to specify what type of resource your Session will consume and enforce different limitations on different types of resources.\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-customize-activity-type-in-go.md","id":191,"title":"How to customize Activity Type in Go","description":"To customize the Workflow Type set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.","label":"Customize Activity Type","tags":["developer-guide","go"],"markdown_content":"\nTo customize the Activity Type, set the `Name` parameter with `RegisterOptions` when registering your Activity with a Worker.\n\n- Type: `string`\n- Default: function name\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  Name: \"YourActivityName\",\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-customize-workflow-type-in-go.md","id":192,"title":"How to customize Workflow Type in Go","description":"To customize the Workflow Type set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.","label":"Customize Workflow Type","tags":["developer-guide","go"],"markdown_content":"\nTo customize the Workflow Type, set the `Name` parameter with `RegisterOptions` when registering your Workflow with a Worker.\n\n- Type: `string`\n- Default: function name\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := workflow.RegisterOptions{\n  Name: \"YourWorkflowName\",\n  // ...\n}\nw.RegisterWorkflowWithOptions(YourWorkflowDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-define-a-query-type-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-define-a-query-type-in-go.md","id":193,"title":"How to define a Query Type in Go","description":"A Query type, also called a Query name, is a `string` value.","label":"Query type","tags":["go","how-to"],"markdown_content":"\nIn Go, a Query type, also called a Query name, is a `string` value.\n\n```go\nqueryType := \"your_query_name\"\n```\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-define-a-signal-in-go.md","id":194,"title":"How to define a Signal in Go","description":"Structs should be used to define Signals and carry data.","label":"Define Signal","tags":["go","developer-guide"],"markdown_content":"\nStructs should be used to define Signals and carry data, as long as the struct is [serializable via the Data Converter](https://pkg.go.dev/go.temporal.io/sdk/converter#CompositeDataConverter.ToPayload).\nThe `Receive()` method on the Data Converter decodes the data into the Struct within the Workflow.\nOnly public fields are serializable.\n\n```go\nMySignal struct {\n\tMessage string // serializable\n\tmessage string // not serializable\n}\n```\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-define-activity-parameters-in-go.md","id":195,"title":"How to define Activity Parameters in Go","description":"The only required parameter is `context.Context`, but Activities can support many custom parameters.","label":"Activity Parameters","tags":["developer-guide","go"],"markdown_content":"\nThe first parameter of an Activity Definition is `context.Context`.\nThis parameter is optional for an Activity Definition, though it is recommended, especially if the Activity is expected to use other Go SDK APIs.\n\nAn Activity Definition can support as many other custom parameters as needed.\nHowever, all parameters must be serializable (parameters can’t be channels, functions, variadic, or unsafe pointers), and it is recommended to pass a single struct that can be updated later.\n\n```go\ntype YourActivityParam struct {\n ActivityParamFieldOne string\n ActivityParamFieldTwo int\n}\n\ntype YourActivityStruct struct {\n // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-define-activity-return-values-in-go.md","id":196,"title":"How to define Activity return values in Go","description":"A Go-based Activity Definition can return either just an `error` or a `customValue, error` combination.","label":"Activity return values","tags":["developer-guide","go"],"markdown_content":"\nA Go-based Activity Definition can return either just an `error` or a `customValue, error` combination (same as a Workflow Definition).\nYou may wish to use a `struct` type to hold all custom values, just keep in mind they must all be serializable.\n\n```go\ntype YourActivityResult struct{\n  ActivityResultFieldOne string\n  ActivityResultFieldTwo int\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResult, error) {\n  // ...\n  result := YourActivityResult {\n    ActivityResultFieldOne: a.ActivityFieldOne,\n    ActivityResultFieldTwo: a.ActivityFieldTwo,\n  }\n  return result, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-define-workflow-parameters-in-go.md","id":197,"title":"How to define Workflow parameters in Go","description":"A Go-based Workflow Definition must accept `workflow.Context` and may support multiple custom parameters.","label":"Workflow parameters","tags":["go","how-to"],"markdown_content":"\nThe first parameter of a Go-based Workflow Definition must be of the [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context) type, as it is used by the Temporal Go SDK to pass around Workflow Execution context, and virtually all the Go SDK APIs that are callable from the Workflow require it.\nIt is acquired from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package.\n\n```go\nimport (\n   \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param string) error {\n // ...\n}\n```\n\nThe `workflow.Context` entity operates similarly to the standard `context.Context` entity provided by Go.\nThe only difference between `workflow.Context` and `context.Context` is that the `Done()` function, provided by `workflow.Context`, returns `workflow.Channel` instead of the standard Go `chan`.\n\nThe second parameter, `string`, is a custom parameter that is passed to the Workflow when it is invoked.\nA Workflow Definition may support multiple custom parameters, or none.\nThese parameters can be regular type variables or safe pointers.\nHowever, the best practice is to pass a single parameter that is of a `struct` type, so there can be some backward compatibility if new parameters are added.\n\n```go\ntype YourWorkflowParam struct {\n WorkflowParamFieldOne string\n WorkflowParamFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n // ...\n}\n```\n\nAll Workflow Definition parameters must be serializable, regardless of whether pointers or regular type values are used.\nParameters can’t be channels, functions, variadic, or unsafe pointers.\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-define-workflow-return-values-in-go.md","id":198,"title":"How to define Workflow return values in Go","description":"A Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.","label":"Workflow return values","tags":["go","how-to"],"markdown_content":"\nA Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.\nAgain, the best practice here is to use a `struct` type to hold all custom values.\n\n```go\ntype YourWorkflowResponse struct{\n WorkflowResultFieldOne string\n WorkflowResultFieldTwo int\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n if err != nil {\n   return \"\", err\n }\n responseVar := YourWorkflowResponse {\n   FieldOne: \"super\",\n   FieldTwo: 1,\n }\n return responseVar, nil\n}\n```\n\nA Workflow Definition written in Go can return both a custom value and an error.\nHowever, it's not possible to receive both a custom value and an error in the calling process, as is normal in Go.\nThe caller will receive either one or the other.\nReturning a non-nil `error` from a Workflow indicates that an error was encountered during its execution and the Workflow Execution should be terminated, and any custom return values will be ignored by the system.\n","is_empty":false},{"file_name":"how-to-develop-a-worker-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-develop-a-worker-in-go.md","id":199,"title":"How to develop a Worker in Go","description":"Develop an instance of a Worker by calling `worker.New()`, available via the `go.temporal.io/sdk/worker` package.","label":"Develop Worker","tags":["developer-guide","go","workers"],"markdown_content":"\nCreate an instance of [`Worker`](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) by calling [`worker.New()`](https://pkg.go.dev/go.temporal.io/sdk/worker#New), available through the `go.temporal.io/sdk/worker` package, and pass it the following parameters:\n\n1. An instance of the Temporal Go SDK `Client`.\n1. The name of the Task Queue that it will poll.\n1. An instance of [`worker.Options`](/go/how-to-set-workeroptions-in-go), which can be empty.\n\nThen, register the Workflow Types and the Activity Types that the Worker will be capable of executing.\n\nLastly, call either the `Start()` or the `Run()` method on the instance of the Worker.\nRun accepts an interrupt channel as a parameter, so that the Worker can be stopped in the terminal.\nOtherwise, the `Stop()` method must be called to stop the Worker.\n\n```go\npackage main\n\nimport (\n   \"go.temporal.io/sdk/client\"\n   \"go.temporal.io/sdk/worker\"\n)\n\nfunc main() {\n   c, err := client.Dial(client.Options{})\n   if err != nil {\n       // ...\n   }\n   defer c.Close()\n   w := worker.New(c, \"your-task-queue\", worker.Options{})\n   w.RegisterWorkflow(YourWorkflowDefinition)\n   w.RegisterActivity(YourActivityDefinition)\n   err = w.Run(worker.InterruptCh())\n   if err != nil\n       // ...\n   }\n // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n}\n\nfunc YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResponse, error) {\n // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-develop-a-worker-program-in-go.md","id":200,"title":"How to develop a Worker Program in Go","description":"Create a new instance of a Worker by calling `worker.New()`, available via the `go.temporal.io/sdk/worker` package.","label":"Worker Program","tags":["developer-guide","go","workers"],"markdown_content":"\nCreate an instance of [`Worker`](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) by calling [`worker.New()`](https://pkg.go.dev/go.temporal.io/sdk/worker#New), available via the `go.temporal.io/sdk/worker` package, and pass it the following parameters:\n\n1. An instance of the Temporal Go SDK `Client`.\n2. The name of the Task Queue that it will poll.\n3. An instance of [`worker.Options`](/go/how-to-set-workeroptions-in-go), which can be empty.\n\nThen, register the Workflow Types and the Activity Types that the Worker will be capable of executing.\n\nLastly, call either the `Start()` or the `Run()` method on the instance of the Worker.\nRun accepts an interrupt channel as a parameter, so that the Worker can be stopped in the terminal.\nOtherwise, the `Stop()` method must be called to stop the Worker.\n\n```go\npackage main\n\nimport (\n   \"go.temporal.io/sdk/client\"\n   \"go.temporal.io/sdk/worker\"\n)\n\nfunc main() {\n   c, err := client.Dial(client.Options{})\n   if err != nil {\n       // ...\n   }\n   defer c.Close()\n   w := worker.New(c, \"your-task-queue\", worker.Options{})\n   w.RegisterWorkflow(YourWorkflowDefinition)\n   w.RegisterActivity(YourActivityDefinition)\n   err = w.Run(worker.InterruptCh())\n   if err != nil\n       // ...\n   }\n // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n}\n\nfunc YourActivityDefinition(ctx context.Context, param YourActivityParam) (YourActivityResponse, error) {\n // ...\n}\n```\n\nStart the Worker Process by running `go run <filename>.go`.\n\n:::tip\n\nIf you have [`gow`](https://github.com/mitranim/gow) installed, the Worker Process automatically \"reloads\" when you update the file:\n\n```bash\ngo install github.com/mitranim/gow@latest\ngow run worker/main.go # automatically reload when file changed\n```\n\n:::\n\nThe `RegisterWorkflow()` and `RegisterActivity()` calls essentially create an in-memory mapping between the Workflow Types and their implementations, inside the Worker process.\n\nNotice that the Task Queue name is the same as the name provided when the [Workflow Execution is spawned](/go/how-to-spawn-a-workflow-execution-in-go).\n\nThe name of the Task Queue that is provided to the Worker must be the same Task Queue name that is provided with the invocation of the Workflow Execution.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n#### Registering Activity `structs`\n\nPer [Activity Definition](/go/how-to-develop-an-activity-definition-in-go) best practices, you may have an Activity struct that has multiple methods and fields. When you use `RegisterActivity()` for an Activity struct, that Worker has access to all exported methods.\n\n#### Registering multiple Types\n\nTo register multiple Activity Types and/or Workflow Types with the Worker Entity, just make multiple Activity registration calls, but make sure each Type name is unique:\n\n```go\nw.registerActivity(ActivityA)\nw.registerActivity(ActivityB)\nw.registerActivity(ActivityC)\nw.registerWorkflow(WorkflowA)\nw.registerWorkflow(WorkflowB)\nw.registerWorkflow(WorkflowC)\n```\n\n#### Registering with options\n\nOptions can be applied when the Type is registered.\n\nFor example, an Activity Type name can be customized to something other than the function name using the [`RegisterActivityWithOptions`](/go/how-to-set-registeractivityoptions-in-go) call.\n\nAnd a Workflow Type name can be customized to something other than the function name using the [`RegisterWorkflowWithOptions`](/go/how-to-set-registerworkflowoptions-in-go) call.\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-develop-a-workflow-definition-in-go.md","id":201,"title":"How to develop a Workflow Definition in Go","description":"In the Temporal Go SDK programming model, a Workflow Definition is an exportable function.","label":"Workflow Definition","tags":["developer-guide","go"],"markdown_content":"\nIn the Temporal Go SDK programming model, a [Workflow Definition](/concepts/what-is-a-workflow-definition) is an exportable function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context) error {\n  // ...\n  return nil\n}\n```\n\nIn Go, by default, the Workflow Type name is the same as the function name.\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-develop-a-workflow-in-go.md","id":202,"title":"How to develop a Workflow in Go","description":"In the Temporal Go SDK programming model, a Workflow Definition is an exportable function.","label":"Workflow Development","tags":["developer-guide","go"],"markdown_content":"\nimport WorkflowDefinition from './how-to-develop-a-workflow-definition-in-go.md'\n\n<WorkflowDefinition/>\n\n### Parameters\n\nimport WorkflowParameters from './how-to-define-workflow-parameters-in-go.md'\n\n<WorkflowParameters/>\n\n### Return values\n\nimport WorkflowReturn from './how-to-define-workflow-return-values-in-go.md'\n\n<WorkflowReturn/>\n\n### Logic requirements\n\nimport LogicRequirements from './how-to-handle-workflow-logic-requirements-in-go.md'\n\n<LogicRequirements/>\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-develop-an-activity-definition-in-go.md","id":203,"title":"How to develop an Activity Definition in Go","description":"In the Temporal Go SDK programming model, an Activity Definition is an exportable function or `stuct` method.","label":"Activity Definition","tags":["developer-guide","go"],"markdown_content":"\nIn the Temporal Go SDK programming model, an Activity Definition is an exportable function or a `struct` method.\n\n**Function**\n\n```go\n// basic function signature\nfunc YourActivityDefinition(ctx context.Context) error {\n // ...\n return nil\n}\n\n// with parameters and return values\nfunc SimpleActivity(ctx context.Context, value string) (string, error)\n```\n\n**Struct method**\n\n```go\ntype YourActivityStruct struct {\n ActivityFieldOne string\n ActivityFieldTwo int\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinition(ctx context.Context) error {\n // ...\n}\n\nfunc(a *YourActivityStruct) YourActivityDefinitionTwo(ctx context.Context) error {\n // ...\n}\n```\n\nAn _Activity struct_ can have more than one method, with each method acting as a separate Activity Type.\nActivities written as struct methods can use shared struct variables, such as:\n\n- an application level DB pool\n- client connection to another service\n- reusable utilities\n- any other expensive resources that you only want to initialize once per process\n\nBecause this is such a common need, the rest of this guide shows Activities written as `struct` methods.\n","is_empty":false},{"file_name":"how-to-develop-an-activity-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-develop-an-activity-in-go.md","id":204,"title":"How to develop an Activity in Go","description":"In the Temporal Go SDK programming model, an Activity Definition is an exportable function or `stuct` method.","label":"Activity Development","tags":["developer-guide","go"],"markdown_content":"\nimport ActivityDefinition from './how-to-develop-an-activity-definition-in-go.md'\n\n<ActivityDefinition/>\n\n### Parameters\n\nimport ActivityParameters from './how-to-define-activity-parameters-in-go.md'\n\n<ActivityParameters/>\n\n### Return values\n\nimport ActivityReturnValues from './how-to-define-activity-return-values-in-go.md'\n\n<ActivityReturnValues/>\n","is_empty":false},{"file_name":"how-to-emit-metrics-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-emit-metrics-in-go.md","id":205,"title":"How to emit metrics in Go","description":"Emit metrics","label":"Emit metrics","tags":["go","how-to"],"markdown_content":"\nTo emit metrics from the Temporal Client in Go, create a [metrics handler](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler) from the [Client Options](https://pkg.go.dev/go.temporal.io/sdk@v1.15.0/internal#ClientOptions) and specify a listener address to be used by Prometheus.\n\n```go\nclient.Options{\n\t\tMetricsHandler: sdktally.NewMetricsHandler(newPrometheusScope(prometheus.Configuration{\n\t\t\tListenAddress: \"0.0.0.0:9090\",\n\t\t\tTimerType:     \"histogram\",\n\t\t}\n```\n\nThe Go SDK currently supports the [Tally](https://pkg.go.dev/go.temporal.io/sdk/contrib/tally) library; however, Tally offers [extensible custom metrics reporting](https://github.com/uber-go/tally#report-your-metrics), which is exposed through the [`WithCustomMetricsReporter`](https://docs.temporal.io/docs/server/options/#withcustommetricsreporter) API.\n\nFor more information, see the [Go sample for metrics](https://github.com/temporalio/samples-go/tree/main/metrics).\n","is_empty":false},{"file_name":"how-to-execute-a-side-effect-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-execute-a-side-effect-in-go.md","id":206,"title":"How to execute a Side Effect in Go","description":"Use the SideEffect API from the `go.temporal.io/sdk/workflow` package to execute a Side Effect directly in your Workflow.","label":"Side Effect","tags":["developer-guide","go"],"markdown_content":"\nUse the [`SideEffect`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SideEffect) API from the `go.temporal.io/sdk/workflow` package to execute a [Side Effect](/concepts/what-is-a-side-effect) directly in your Workflow.\n\nPass it an instance of `context.Context` and the function to execute.\n\nThe `SideEffect` API returns a Future, an instance of [`converter.EncodedValue`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SideEffect).\n\nUse the `Get` method on the Future to retrieve the result of the Side Effect.\n\n#### Correct implementation\n\nThe following example demonstrates the correct way to use `SideEffect`:\n\n```go\nencodedRandom := workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {\n return rand.Intn(100)\n})\n\nvar random int\nencodedRandom.Get(&random)\n// ...\n}\n```\n\n#### Incorrect implementation\n\nThe following example demonstrates how NOT to use `SideEffect`:\n\n```go\n// Warning: This is an incorrect example.\n// This code is nondeterministic.\nvar random int\nworkflow.SideEffect(func(ctx workflow.Context) interface{} {\n      random = rand.Intn(100)\n      return nil\n})\n// random will always be 0 in replay, so this code is nondeterministic.\n```\n\nOn replay the provided function is not executed, the random number will always be 0, and the Workflow Execution could take a different path, breaking determinism.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-get-the-result-of-a-workflow-execution-in-go.md","id":207,"title":"How to get the result of a Workflow Execution in Go","description":"Use the Future returned by `ExecuteWorkflow` API call to retrieve the result.","label":"Workflow Execution result","tags":["developer-guide","go"],"markdown_content":"\nThe `ExecuteWorkflow` call returns an instance of [`WorkflowRun`](https://pkg.go.dev/go.temporal.io/sdk/client#WorkflowRun), which is the `workflowRun` variable in the following line.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, app.YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n // ...\n}\n```\n\nThe instance of `WorkflowRun` has the following three methods:\n\n- `GetWorkflowID()`: Returns the Workflow Id of the invoked Workflow Execution.\n- `GetRunID()`: Always returns the Run Id of the initial Run (See [Continue As New](#)) in the series of Runs that make up the full Workflow Execution.\n- `Get`: Takes a pointer as a parameter and populates the associated variable with the Workflow Execution result.\n\nTo wait on the result of Workflow Execution in the same process that invoked it, call `Get()` on the instance of `WorkflowRun` that is returned by the `ExecuteWorkflow()` call.\n\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n}\n```\n\nHowever, the result of a Workflow Execution can be obtained from a completely different process.\nAll that is needed is the [Workflow Id](#).\n(A [Run Id](#) is optional if more than one closed Workflow Execution has the same Workflow Id.)\nThe result of the Workflow Execution is available for as long as the Workflow Execution Event History remains in the system.\n\n<!-- TODO (See [How long do Workflow Execution Histories persist](#)). -->\n\nCall the `GetWorkflow()` method on an instance of the Go SDK Client and pass it the Workflow Id used to spawn the Workflow Execution.\nThen call the `Get()` method on the instance of `WorkflowRun` that is returned, passing it a pointer to populate the result.\n\n```go\n // ...\n workflowID := \"Your-Custom-Workflow-Id\"\n workflowRun := c.GetWorkflow(context.Background, workflowID)\n\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n```\n\n**Get last completion result**\n\nIn the case of a [Temporal Cron Job](/concepts/what-is-a-temporal-cron-job), you might need to get the result of the previous Workflow Run and use it in the current Workflow Run.\n\nTo do this, use the [`HasLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#HasLastCompletionResult) and [`GetLastCompletionResult`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLastCompletionResult) APIs, available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package, directly in your Workflow code.\n\n```go\ntype CronResult struct {\n Count int\n}\n\nfunc YourCronWorkflowDefinition(ctx workflow.Context) (CronResult, error) {\n count := 1\n\n if workflow.HasLastCompletionResult(ctx) {\n   var lastResult CronResult\n   if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {\n     count = count + lastResult.Count\n   }\n }\n\n newResult := CronResult {\n   Count: count,\n }\n return newResult, nil\n}\n```\n\nThis will work even if one of the cron Workflow Runs fails.\nThe next Workflow Run gets the result of the last successfully Completed Workflow Run.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-get-the-result-of-an-activity-execution-in-go.md","id":208,"title":"How to get the result of an Activity Execution in Go","description":"Use the Future returned from the `ExecuteActivity` API call to retrieve the result.","label":"Activity Execution result","tags":["developer-guide","go"],"markdown_content":"\nThe `ExecuteActivity` API call returns an instance of [`workflow.Future`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Futures) which has the following two methods:\n\n- `Get()`: Takes an instance of the `workflow.Context`, that was passed to the Activity Execution, and a pointer as parameters.\n  The variable associated with the pointer is populated with the Activity Execution result.\n  This call blocks until the results are available.\n- `IsReady()`: Returns `true` when the result of the Activity Execution is ready.\n\nCall the `Get()` method on the instance of `workflow.Future` to get the result of the Activity Execution.\nThe type of the result parameter must match the type of the return value declared by the Activity function.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n var yourActivityResult YourActivityResult\n if err := future.Get(ctx, &yourActivityResult); err != nil {\n   // ...\n }\n // ...\n}\n```\n\nUse the `IsReady()` method first to make sure the `Get()` call doesn't cause the Workflow Execution to wait on the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n // ...\n if(future.IsReady()) {\n   var yourActivityResult YourActivityResult\n   if err := future.Get(ctx, &yourActivityResult); err != nil {\n     // ...\n   }\n }\n // ...\n}\n```\n\nIt is idiomatic to invoke multiple Activity Executions from within a Workflow.\nTherefore, it is also idiomatic to either block on the results of the Activity Executions or continue on to execute additional logic, checking for the Activity Execution results at a later time.\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-handle-a-query-in-a-workflow-in-go.md","id":209,"title":"How to handle a Query in a Workflow in Go","description":"Use the `SetQueryHandler` API to set a Query Handler that listens for a Query by name.","label":"Handling Queries","tags":["go","how-to"],"markdown_content":"\nUse the `SetQueryHandler` API from the `go.temporal.io/sdk/workflow` package to set a Query Handler that listens for a Query by name.\n\nThe handler must be a function that returns two values:\n\n1. A serializable result\n2. An error\n\nThe handler function can receive any number of input parameters, but all input parameters must be serializable.\nThe following sample code sets up a Query Handler that handles the `current_state` Query type:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n  currentState := \"started\" // This could be any serializable struct.\n  queryType := \"current_state\"\n  err := workflow.SetQueryHandler(ctx, queryType, func() (string, error) {\n    return currentState, nil\n  })\n  if err != nil {\n    currentState = \"failed to register query handler\"\n    return err\n  }\n  // Your normal Workflow code begins here, and you update the currentState as the code makes progress.\n  currentState = \"waiting timer\"\n  err = NewTimer(ctx, time.Hour).Get(ctx, nil)\n  if err != nil {\n    currentState = \"timer failed\"\n    return err\n  }\n  currentState = \"waiting activity\"\n  ctx = WithActivityOptions(ctx, yourActivityOptions)\n  err = ExecuteActivity(ctx, YourActivity, \"your_input\").Get(ctx, nil)\n  if err != nil {\n    currentState = \"activity failed\"\n    return err\n  }\n  currentState = \"done\"\n  return nil\n}\n```\n\nFor example, suppose your query handler function takes two parameters:\n\n```go\nerr := workflow.SetQueryHandler(ctx, \"current_state\", func(prefix string, suffix string) (string, error) {\n    return prefix + currentState + suffix, nil\n})\n```\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-handle-a-signal-in-go.md","id":210,"title":"How to handle a Signal in Go","description":"Use the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.","label":"Handle Signal","tags":["go","how-to"],"markdown_content":"\nUse the `GetSignalChannel()` API from the `go.temporal.io/sdk/workflow` package to get the Signal Channel.\nGet a new [`Selector`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Selector) and pass it the Signal Channel and a callback function to handle the payload.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  // ...\n  var signal MySignal\n  signalChan := workflow.GetSignalChannel(ctx, \"your-signal-name\")\n  selector := workflow.NewSelector(ctx)\n  selector.AddReceive(signalChan, func(channel workflow.ReceiveChannel, more bool) {\n      channel.Receive(ctx, &signal)\n      // ...\n  })\n  selector.Select(ctx)\n  if len(signal.Message) > 0 && signal.Message != \"SOME_VALUE\" {\n      return errors.New(\"signal\")\n  }\n  // ...\n}\n```\n\nIn the example above, the Workflow code uses `workflow.GetSignalChannel` to open a `workflow.Channel` for the Signal type (identified by the Signal name).\nWe then use a [`workflow.Selector`](/go/selectors) and the `AddReceive()` to wait on a Signal from this channel.\nThe `more` bool in the callback function indicates that channel is not closed and more deliveries are possible.\n\nBefore completing the Workflow or using [Continue-As-New](/application-development/features#continue-as-new), make sure to do an asynchronous drain on the Signal channel.\nOtherwise, the Signals will be lost.\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-handle-workflow-logic-requirements-in-go.md","id":211,"title":"How to handle Workflow logic requirements in Go","description":"todo","label":"Workflow logic requirements","tags":["go","how-to"],"markdown_content":"\nIn Go, Workflow Definition code cannot directly do the following:\n\n- Iterate over maps using `range`, because with `range` the order of the map's iteration is randomized.\n  Instead you can collect the keys of the map, sort them, and then iterate over the sorted keys to access the map.\n  This technique provides deterministic results.\n  You can also use a Side Effect or an Activity to process the map instead.\n- Call an external API, conduct a file I/O operation, talk to another service, etc. (Use an Activity for these.)\n\nThe Temporal Go SDK has APIs to handle equivalent Go constructs:\n\n- `workflow.Now()` This is a replacement for `time.Now()`.\n- `workflow.Sleep()` This is a replacement for `time.Sleep()`.\n- `workflow.GetLogger()` This ensures that the provided logger does not duplicate logs during a replay.\n- `workflow.Go()` This is a replacement for the `go` statement.\n- `workflow.Channel` This is a replacement for the native `chan` type.\n  Temporal provides support for both buffered and unbuffered channels.\n- `workflow.Selector` This is a replacement for the `select` statement. Learn more on the [Go SDK Selectors](/go/selectors) page\n- `workflow.Context` This is a replacement for `context.Context`. Learn more on the [Go SDK Context Propagation](/go/tracing) page.\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-heartbeat-an-activity-in-go.md","id":212,"title":"How to Heartbeat an Activity in Go","description":"Use, the `RecordHeartbeat` API to report that the execution is alive and progressing.","label":"Activity Heartbeats","tags":["go","developer-guide"],"markdown_content":"\nTo [Heartbeat](/concepts/what-is-an-activity-heartbeat) in an Activity in Go, use the `RecordHeartbeat` API.\n\n```go\nimport (\n    // ...\n    \"go.temporal.io/sdk/workflow\"\n    // ...\n)\n\nfunc YourActivityDefinition(ctx, YourActivityDefinitionParam) (YourActivityDefinitionResult, error) {\n    // ...\n    activity.RecordHeartbeat(ctx, details)\n    // ...\n}\n```\n\nWhen an Activity Task Execution times out due to a missed Heartbeat, the last value of the `details` variable above is returned to the calling Workflow in the `details` field of `TimeoutError` with `TimeoutType` set to `Heartbeat`.\n\nYou can also Heartbeat an Activity from an external source:\n\n```go\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n// Record heartbeat.\nerr := temporalClient.RecordActivityHeartbeat(ctx, taskToken, details)\n```\n\nThe parameters of the `RecordActivityHeartbeat` function are:\n\n- `taskToken`: The value of the binary `TaskToken` field of the `ActivityInfo` struct retrieved inside\n  the Activity.\n- `details`: The serializable payload containing progress information.\n\nIf an Activity Execution Heartbeats its progress before it failed, the retry attempt will have access to the progress information, so that the Activity Execution can resume from the failed state.\nHere's an example of how this can be implemented:\n\n```go\nfunc SampleActivity(ctx context.Context, inputArg InputParams) error {\n    startIdx := inputArg.StartIndex\n    if activity.HasHeartbeatDetails(ctx) {\n        // Recover from finished progress.\n        var finishedIndex int\n        if err := activity.GetHeartbeatDetails(ctx, &finishedIndex); err == nil {\n            startIdx = finishedIndex + 1 // Start from next one.\n        }\n    }\n\n    // Normal Activity logic...\n    for i:=startIdx; i<inputArg.EndIdx; i++ {\n        // Code for processing item i goes here...\n        activity.RecordHeartbeat(ctx, i) // Report progress.\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-list-workflow-executions-using-the-client-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-list-workflow-executions-using-the-client-in-go.md","id":213,"title":"How to list Workflow Executions using the Client in Go","description":"List Workflow Executions using the Client","label":"List Workflow Executions using the Client","tags":["developer-guide","go","client"],"markdown_content":"\nUse [`Client.ListWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/client#Client.ListWorkflow).\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-log-from-a-workflow-in-go.md","id":214,"title":"How to log from a Workflow in TypeScript","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","go","log"],"markdown_content":"\nIn Workflow Definitions you can use [`workflow.GetLogger(ctx)`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLogger) to write logs.\n\n```go\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"go.temporal.io/sdk/activity\"\n\t\"go.temporal.io/sdk/workflow\"\n)\n\n// Workflow is a standard workflow definition.\n// Note that the Workflow and Activity don't need to care that\n// their inputs/results are being compressed.\nfunc Workflow(ctx workflow.Context, name string) (string, error) {\n// ...\n\nworkflow.WithActivityOptions(ctx, ao)\n\n// Getting the logger from the context.\n\tlogger := workflow.GetLogger(ctx)\n// Logging a message with the key value pair `name` and `name`\n\tlogger.Info(\"Compressed Payloads workflow started\", \"name\", name)\n\n\tinfo := map[string]string{\n\t\t\"name\": name,\n\t}\n\n\n\tlogger.Info(\"Compressed Payloads workflow completed.\", \"result\", result)\n\n\treturn result, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-register-types-with-a-worker-in-go.md","id":215,"title":"How to register types with a Worker in Go","description":"The `RegisterWorkflow()` and `RegisterActivity()` calls create an in-memory mapping between the Workflow Types and their implementations.","label":"Register Types","tags":["developer-guide","go","workers"],"markdown_content":"\nThe `RegisterWorkflow()` and `RegisterActivity()` calls essentially create an in-memory mapping between the Workflow Types and their implementations, inside the Worker process.\n\n**Registering Activity `structs`**\n\nPer [Activity Definition](/go/how-to-develop-an-activity-definition-in-go) best practices, you might have an Activity struct that has multiple methods and fields.\nWhen you use `RegisterActivity()` for an Activity struct, that Worker has access to all exported methods.\n\n**Registering multiple Types**\n\nTo register multiple Activity Types and/or Workflow Types with the Worker Entity, just make multiple Activity registration calls, but make sure each Type name is unique:\n\n```go\nw.registerActivity(ActivityA)\nw.registerActivity(ActivityB)\nw.registerActivity(ActivityC)\nw.registerWorkflow(WorkflowA)\nw.registerWorkflow(WorkflowB)\nw.registerWorkflow(WorkflowC)\n```\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-remove-search-attributes-from-a-workflow-in-go.md","id":216,"title":"How to remove Search Attributes from a Workflow in Go","description":"How to remove Search Attributes from a Workflow","label":"How to remove Search Attributes from a Workflow","tags":["developer-guide","go"],"markdown_content":"\n**There is no support for removing a field.**\n\nHowever, to achieve a similar effect, set the field to some placeholder value.\nFor example, you could set `CustomKeywordField` to `impossibleVal`.\nThen searching `CustomKeywordField != 'impossibleVal'` will match Workflows with `CustomKeywordField` not equal to `impossibleVal`, which includes Workflows without the `CustomKeywordField` set.\n","is_empty":false},{"file_name":"how-to-replay-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-replay-a-workflow-execution-in-go.md","id":217,"title":"How to replay a Workflow Execution in Go","description":"Use the `WorkflowReplayer` API to replay an existing Workflow Execution from an Event History to replicate errors.","label":"WorkflowReplayer","tags":["go","how-to"],"markdown_content":"\nUse the [worker.WorflowReplayer](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowReplayer) to replay an existing Workflow Execution from its Event History to replicate errors.\n\nFor example, the following code retrieves the Event History of a Workflow:\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/api/enums/v1\"\n\t\"go.temporal.io/api/history/v1\"\n\t\"go.temporal.io/sdk/client\"\n)\n\nfunc GetWorkflowHistory(ctx context.Context, client client.Client, id, runID string) (*history.History, error) {\n\tvar hist history.History\n\titer := client.GetWorkflowHistory(ctx, id, runID, false, enums.HISTORY_EVENT_FILTER_TYPE_ALL_EVENT)\n\tfor iter.HasNext() {\n\t\tevent, err := iter.Next()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thist.Events = append(hist.Events, event)\n\t}\n\treturn &hist, nil\n}\n```\n\nThis history can then be used to _replay_.\nFor example, the following code creates a `WorkflowReplayer` and register the `YourWorkflow` Workflow function.\nThen it calls the `ReplayWorkflowHistory` to _replay_ the Event History and return an error code.\n\n```go\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n)\n\nfunc ReplayWorkflow(ctx context.Context, client client.Client, id, runID string) error {\n\thist, err := GetWorkflowHistory(ctx, client, id, runID)\n\tif err != nil {\n\t\treturn err\n\t}\n\treplayer := worker.NewWorkflowReplayer()\n\treplayer.RegisterWorkflow(YourWorkflow)\n\treturn replayer.ReplayWorkflowHistory(nil, hist)\n}\n```\n\nThe code above will cause the Worker to re-execute the Workflow's Workflow Function using the original Event History.\nIf a noticeably different code path was followed or some code caused a deadlock, it will be returned in the error code.\nReplaying a Workflow Execution locally is a good way to see exactly what code path was taken for given input and events.\n","is_empty":false},{"file_name":"how-to-replay-tests-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-replay-tests-in-go.md","id":218,"markdown_content":"","is_empty":false},{"file_name":"how-to-request-cancellation-of-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-request-cancellation-of-a-workflow-execution-in-go.md","id":219,"title":"How to request Cancellation of a Workflow Execution in Go","description":"Use the `CancelWorkflow` API to cancel a Workflow Execution using its Id.","tags":["developer-guide","go"],"markdown_content":"\nUse the `CancelWorkflow` API to cancel a Workflow Execution using its Id.\n\n<!--SNIPSTART samples-go-cancellation-cancel-workflow-execution-trigger-->\n<!--SNIPEND-->\n\n#### How to clean up after a Workflow is cancelled\n\nWorkflow Definitions can be written to handle execution cancellation requests with Go's `defer` and the `workflow.NewDisconnectedContext` API.\nIn the Workflow Definition below, there is a special Activity that handles clean up should the execution be cancelled.\n\n<!--SNIPSTART samples-go-cancellation-workflow-definition-->\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-send-a-query-to-a-workflow-execution-in-go.md","id":220,"title":"How to send a Query to a Workflow Execution in Go","description":"Use the `QueryWorkflow()` API to send a Query to a Workflow in Go.","label":"Sending Queries","tags":["go","how-to"],"markdown_content":"\nUse the `QueryWorkflow()` API or the `QueryWorkflowWithOptions` API on the Temporal Client to send a Query to a Workflow Execution.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType)\nif err != nil {\n  // ...\n}\n// ...\n```\n\nYou can pass an arbitrary number of arguments to the `QueryWorkflow()` function.\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflow(context.Background(), workflowID, runID, queryType, \"foo\", \"baz\")\nif err != nil {\n  // ...\n}\n// ...\n```\n\nThe `QueryWorkflowWithOptions()` API provides similar functionality, but with the ability to set additional configurations through [QueryWorkflowWithOptionsRequest](https://pkg.go.dev/go.temporal.io/sdk/client#QueryWorkflowWithOptionsRequest).\nWhen using this API, you will also receive a structured response of type [QueryWorkflowWithOptionsResponse](https://pkg.go.dev/go.temporal.io/sdk/client#QueryWorkflowWithOptionsResponse).\n\n```go\n// ...\nresponse, err := temporalClient.QueryWorkflowWithOptions(context.Background(), &client.QueryWorkflowWithOptionsRequest{\n    WorkflowID: workflowID,\n    RunID: runID,\n    QueryType: queryType,\n    Args: args,\n})\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-send-a-signal-from-a-client-in-go.md","id":221,"title":"How to send a Signal from a Temporal Client in Go","description":"Use the `SignalWorkflow()` method on an instance of the Go SDK Temporal Client to send a Signal to a Workflow Execution.","label":"Send Signal from Client","tags":["go","how-to"],"markdown_content":"\nUse the `SignalWorkflow()` method on an instance of the [Go SDK Temporal Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) to send a [Signal](/concepts/what-is-a-signal) to a [Workflow Execution](/concepts/what-is-a-workflow-execution).\n\nPass in both the [Workflow Id](/concepts/what-is-a-workflow-id) and [Run Id](/concepts/what-is-a-run-id) to uniquely identify the Workflow Execution.\nIf only the Workflow Id is supplied (provide an empty string as the Run Id param), the Workflow Execution that is Running receives the Signal.\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWorkflow(context.Background(), \"your-workflow-id\", runID, \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n// ...\n```\n\nPossible errors:\n\n- `serviceerror.NotFound`\n- `serviceerror.Internal`\n- `serviceerror.Unavailable`\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-send-a-signal-from-a-workflow-in-go.md","id":222,"title":"How to send a Signal from a Workflow in Go","description":"A Signal can be sent from within a Workflow to a different Workflow Execution using the `SignalExternalWorkflow` API from the `go.temporal.io/sdk/workflow` package.","label":"Send Signal from Workflow","tags":["go","how-to"],"markdown_content":"\nA Signal can be sent from within a Workflow to a different Workflow Execution using the [`SignalExternalWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SignalExternalWorkflow) API from the `go.temporal.io/sdk/workflow` package.\n\n```go\n// ...\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  //...\n  signal := MySignal {\n    Message: \"Some important data\",\n  }\n  err :=  workflow.SignalExternalWorkflow(ctx, \"some-workflow-id\", \"\", \"your-signal-name\", signalData).Get(ctx, nil)\n  if err != nil {\n    // ...\n  }\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-send-a-signal-with-start-in-go.md","id":223,"title":"How to send a Signal-With-Start in Go","description":"Use the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.","label":"Signal-With-Start","tags":["go","how-to"],"markdown_content":"\nUse the `SignalWithStartWorkflow()` API on the Go SDK Temporal Client to start a Workflow Execution (if not already running) and pass it the Signal at the same time.\n\nBecause the Workflow Execution might not exist, this API does not take a Run ID as a parameter\n\n```go\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWithStartWorkflow(context.Background(), \"your-workflow-id\", \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-cron-schedule-in-go.md","id":224,"title":"How to set a Cron Schedule in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `CronSchedule` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Cron Schedule","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `CronSchedule` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-custom-logger-in-go.md","id":225,"title":"How to set a custom logger in Go","description":"Set a custom logger","label":"Custom logger","tags":["go","how-to"],"markdown_content":"\nThis field sets a custom Logger that is used for all logging actions of the instance of the Temporal Client.\n\nAlthough the Go SDK does not support most third-party logging solutions natively, [our friends at Banzai Cloud](https://github.com/sagikazarmark) built the adapter package [logur](https://github.com/logur/logur) which makes it possible to use third party loggers with minimal overhead.\nMost of the popular logging solutions have existing adapters in Logur, but you can find a full list [in the Logur Github project](https://github.com/logur?q=adapter-).\n\nHere is an example of using Logur to support [Logrus](https://github.com/sirupsen/logrus):\n\n```go\npackage main\nimport (\n  \"go.temporal.io/sdk/client\"\n\n\t\"github.com/sirupsen/logrus\"\n\tlogrusadapter \"logur.dev/adapter/logrus\"\n\t\"logur.dev/logur\"\n)\n\nfunc main() {\n  // ...\n  logger := logur.LoggerToKV(logrusadapter.New(logrus.New()))\n  clientOptions := client.Options{\n    Logger: logger,\n  }\n  temporalClient, err := client.Dial(clientOptions)\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-heartbeat-timeout-in-go.md","id":226,"title":"How to set a Heartbeat Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `HeartbeatTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Retry Policy","tags":["go","how-to"],"markdown_content":"\nTo set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout), Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  HeartbeatTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-parent-close-policy-in-go.md","id":227,"title":"How to set a Parent Close Policy in Go","description":"Create an instance of `ChildWorkflowOptions` from the `go.temporal.io/sdk/workflow` package, set the `ParentClosePolicy` field, apply the options to the instance of `workflow.Context`, and pass the context to the `ExecuteChildWorkflow` call.","label":"Parent Close Policy","tags":["go","how-to"],"markdown_content":"\nIn Go, a Parent Close Policy is set on the `ParentClosePolicy` field of an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions).\nThe possible values can be obtained from the [`go.temporal.io/api/enums/v1`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy) package.\n\n- `PARENT_CLOSE_POLICY_ABANDON`\n- `PARENT_CLOSE_POLICY_TERMINATE`\n- `PARENT_CLOSE_POLICY_REQUEST_CANCEL`\n\nThe Child Workflow Options are then applied to the instance of `workflow.Context` by using the `WithChildOptions` API, which is then passed to the `ExecuteChildWorkflow()` call.\n\n- Type: [`ParentClosePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#ParentClosePolicy)\n- Default: `PARENT_CLOSE_POLICY_ABANDON`\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n  // ...\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    // ...\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // ...\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-schedule-to-close-timeout-in-go.md","id":228,"title":"How to set a Schedule-To-Close Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Schedule-To-Close Timeout","tags":["go","how-to"],"markdown_content":"\nTo set a [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `time.Duration`\n- Default: ∞ (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-schedule-to-start-timeout-in-go.md","id":229,"title":"How to set a Schedule-To-Start Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Schedule-To-Close Timeout","tags":["go","how-to"],"markdown_content":"\nTo set a [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `ScheduleToStartTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: `time.Duration`\n- Default: ∞ (infinity - no limit)\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-start-to-close-timeout-in-go.md","id":230,"title":"How to set a Start-To-Close Timeout in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Start-To-Close Timeout","tags":["go","how-to"],"markdown_content":"\nTo set a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout), create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `StartToCloseTimeout` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `time.Duration`\n- Default: Same as the `ScheduleToCloseTimeout`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  StartToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-execution-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-workflow-execution-timeout-in-go.md","id":231,"title":"How to set a Workflow Execution Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Execution Timeout","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowExecutionTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  WorkflowExecutionTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-workflow-id-in-go.md","id":232,"title":"How to set a custom Workflow Id in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Id","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `ID` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: System generated UUID\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  ID: \"Your-Custom-Workflow-Id\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-retry-policy-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-workflow-retry-policy-in-go.md","id":233,"title":"How to set a Workflow Retry Policy in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `RetryPolicy` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Retry Policy","tags":["go","how-to"],"markdown_content":"\nCreate an instance of a [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy) from the `go.temporal.io/sdk/temporal` package and provide it as the value to the `RetryPolicy` field of the instance of `StartWorkflowOptions`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default: None\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\nworkflowOptions := client.StartWorkflowOptions{\n  RetryPolicy: retrypolicy,\n  // ...\n}\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-run-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-workflow-run-timeout-in-go.md","id":234,"title":"How to set a Workflow Run Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Run Timeout","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowRunTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: Same as [`WorkflowExecutionTimeout`](#workflowexecutiontimeout)\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowRunTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-workflow-task-queue-in-go.md","id":235,"title":"How to set the Task Queue for Workflow Execution in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Task Queue","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `TaskQueue` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `string`\n- Default: None, this is a required field to be set by the developer\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  TaskQueue: \"your-task-queue\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-timeout-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-a-workflow-task-timeout-in-go.md","id":236,"title":"How to set a Workflow Task Timeout in Go","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Task Timeout","tags":["go","how-to"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, set the `WorkflowTaskTimeout` field, and pass the instance to the `ExecuteWorkflow` call.\n\n- Type: `time.Duration`\n- Default: `time.Seconds * 10`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowTaskTimeout: time.Second * 10,\n  //...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-an-activity-retry-policy-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-an-activity-retry-policy-in-go.md","id":237,"title":"How to set an Activity Retry Policy in Go","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.","label":"Retry Policy","tags":["go","how-to"],"markdown_content":"\nTo set a [RetryPolicy](/concepts/what-is-a-retry-policy), Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package, set the `RetryPolicy` field, and then use the `WithActivityOptions()` API to apply the options to the instance of `workflow.Context`.\n\n- Type: [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)\n- Default:\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100, // 100 * InitialInterval\n  MaximumAttempts: 0, // Unlimited\n  NonRetryableErrorTypes: []string, // empty\n}\n```\n\nProviding a Retry Policy here is a customization, and overwrites individual Field defaults.\n\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\n\nactivityoptions := workflow.ActivityOptions{\n  RetryPolicy: retrypolicy,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-childworkflowoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-childworkflowoptions-in-go.md","id":238,"title":"How to set ChildWorkflowOptions in Go","description":"Used to set all Child Workflow Execution specific options","label":"ChildWorkflowOptions","tags":["go","developer-guide"],"markdown_content":"\nUsed to set all child Workflow specific options\n\n| Field                    | Description                                                                       | Type                   |\n| ------------------------ | --------------------------------------------------------------------------------- | ---------------------- |\n| Namespace                | Set the namespace of the Child Workflow Execution                                 | string                 |\n| WorkflowID               | Set the Id of the Child Workflow to be scheduled                                  | string                 |\n| TaskQueue                | Set Task Queue that the child Workflow needs to be scheduled on                   | string                 |\n| WorkflowExecutionTimeout | Set the end to end timeout for the child Workflow execution including retries     | time.Duration          |\n| WorkflowRunTimeout       | Set the timeout for a single run of the child Workflow execution                  | time.Duration          |\n| WorkflowTaskTimeout      | Set the maximum execution time of a single Workflow Task                          | time.Duration          |\n| WaitForCancellation      | Set to wait for canceled child Workflow to be ended                               | bool                   |\n| WorkflowIDReusePolicy    | Set if server allow reuse of Workflow Id                                          | WorkflowIdReusePolicy  |\n| RetryPolicy              | Set how to retry child Workflow if error happens                                  | RetryPolicy            |\n| CronSchedule             | Set the cron schedule for child Workflow                                          | string                 |\n| Memo                     | Set non-indexed info that will be shown in list child Workflow                    | map[string]interface{} |\n| SearchAttributes         | Set indexed info that can be used in query of List/Scan/Count child Workflow APIs | map[string]interface{} |\n| ParentClosePolicy        | Set policy to decide what to do for the child when the parent closes              | ParentClosePolicy      |\n\n### Parent Close Policy\n\nimport ParentClosePolicy from './how-to-set-a-parent-close-policy-in-go.md'\n\n<ParentClosePolicy/>\n","is_empty":false},{"file_name":"how-to-set-clientoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-clientoptions-in-go.md","id":239,"title":"How to set ClientOptions in Go","description":"Create an instance of `Options` from the `go.temporal.io/sdk/client` package and pass it the call to create a new Temporal Client.","label":"ClientOptions","tags":["go","developer-guide"],"markdown_content":"\nCreate an instance of [`Options`](https://pkg.go.dev/go.temporal.io/sdk/client#Options) from the `go.temporal.io/sdk/client` package and pass it the call to create a new Temporal Client.\n\n| Field                                       | Required | Type                                                                                       |\n| ------------------------------------------- | -------- | ------------------------------------------------------------------------------------------ |\n| [`HostPort`](#hostport)                     | No       | `string`                                                                                   |\n| [`Namespace`](#namespace)                   | No       | `string`                                                                                   |\n| [`Logger`](#logger)                         | No       | [`log.Logger`](https://pkg.go.dev/go.temporal.io/sdk/log#Logger)                           |\n| [`MetricsHandler`](#metricshandler)         | No       | [`metrics.Handler`](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler) |\n| [`Identity`](#identify)                     | No       | `string`                                                                                   |\n| [`DataConverter`](#dataconverter)           | No       | [`converter.DataConverter`](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter) |\n| [`ContextPropagators`](#contextpropagators) | No       | [`[]ContextPropagator`](https://pkg.go.dev/go.temporal.io/sdk/internal#ContextPropagator)  |\n| [`ConnectionOptions`](#connectionoptions)   | No       | [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/internal#ConnectionOptions)    |\n| [`HeadersProvider`](#headersprovider)       | No       | [`HeadersProvider`](https://pkg.go.dev/go.temporal.io/sdk/internal#HeadersProvider)        |\n| [`TrafficController`](#trafficcontroller)   | No       | [`TrafficController`](https://pkg.go.dev/go.temporal.io/sdk/internal#TrafficController)    |\n| [`Interceptors`](#interceptors)             | No       | [`[]ClientInterceptor`](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientInterceptor)  |\n\n### `HostPort`\n\n**How to set the Temporal Client's host:port connection in Go**\n\n- Type: `string`\n- Default: [`client.DefaultHostPort`](https://pkg.go.dev/go.temporal.io/sdk/client#pkg-constants) (127.0.0.1:7233)\n\n```go\nclientOptions := client.Options{\n  HostPort: client.DefaultHostPort,\n}\ntemporalClient, err := client.Dial(clientOptions)\n```\n\nThe `HostPort` value is a gRPC address and therefore can also support a special-formatted address of `<resolver>:///<value>` that will use a registered resolver.\nBy default all hosts returned from the resolver will be used in a round-robin fashion.\n\nThe \"dns\" resolver is registered by default.\nUsing a `dns:///` prefixed address will cause a periodic round-robin resolution of all IPs for all DNS addresses.\n\nA custom resolver can be created to provide multiple hosts in other ways.\nFor example, to manually provide multiple IPs to round-robin across, a `google.golang.org/grpc/resolver/` manual resolver can be created and registered with a custom scheme:\n\n```go\nbuilder := manual.NewBuilderWithScheme(\"myresolver\")\nbuilder.InitialState(resolver.State{Addresses: []resolver.Address{{Addr: \"1.2.3.4:1234\"},{Addr: \"2.3.4.5:2345\"}}})\nresolver.Register(builder)\ntemporalClient, err := client.Dial(client.Options{HostPort: \"myresolver:///ignoredvalue\"})\n```\n\nOther more advanced resolvers can also be registered.\n\n### `Namespace`\n\nimport Namespace from './how-to-set-the-namespace-for-a-temporal-client-in-go.md'\n\n<Namespace/>\n\n### `Logger`\n\n**How to use a custom logger in Go**\n\nThis field sets a custom Logger that is used for all logging actions of the instance of the Temporal Client.\n\nAlthough the Go SDK does not support most third-party logging solutions natively, [our friends at Banzai Cloud](https://github.com/sagikazarmark) built the adapter package [logur](https://github.com/logur/logur) which makes it possible to use third party loggers with minimal overhead.\nMost of the popular logging solutions have existing adapters in Logur, but you can find a full list [in the Logur Github project](https://github.com/logur?q=adapter-).\n\nHere is an example of using Logur to support [Logrus](https://github.com/sirupsen/logrus):\n\n```go\npackage main\nimport (\n  \"go.temporal.io/sdk/client\"\n\n\t\"github.com/sirupsen/logrus\"\n\tlogrusadapter \"logur.dev/adapter/logrus\"\n\t\"logur.dev/logur\"\n)\n\nfunc main() {\n  // ...\n  logger := logur.LoggerToKV(logrusadapter.New(logrus.New()))\n  clientOptions := client.Options{\n    Logger: logger,\n  }\n  temporalClient, err := client.Dial(clientOptions)\n  // ...\n}\n```\n\n### `MetricsHandler`\n\nSets the metric scope, which metrics should be reported\n\n- Type: [`metrics.Handler`](https://pkg.go.dev/go.temporal.io/sdk/internal/common/metrics#Handler)\n- Default: None\n\n### `Identity`\n\nSets an identify that can be used to track this host for debugging\n\n### `DataConverter`\n\nSets DataConverter to customize serialization/deserialization of arguments in Temporal\n\n- Type: [`converter.DataConverter`](https://pkg.go.dev/go.temporal.io/sdk/converter#DataConverter)\n\n### `ContextPropagators`\n\nSets ContextPropagators that allows users to control the context information passed through a Workflow\n\n- Type: `[]ContextPropagator`\n\n### `ConnectionOptions`\n\nSets options for server connection that allow users to control features of connections such as TLS settings\n\n- Type: `ConnectionOptions`\n\n### `HeadersProvider`\n\nSets custom request headers\n\n- Type: `HeadersProvider`\n\n### `TrafficController`\n\nSet to induce artificial failures in test scenarios\n\n- Type: `TrafficController`\n\n### `Interceptors`\n\ngRPC interceptors that are applied to every RPC call performed by this connection.\nBy default, an interceptor is included; it automatically retries retryable errors.\nIf you do not want to perform automatic retries, set this to an empty list (or a list with your own interceptors).\n\n- Type: `[]ClientInterceptor`\n","is_empty":false},{"file_name":"how-to-set-connectionoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-connectionoptions-in-go.md","id":240,"title":"How to set ConnectionOptions in Go","description":"Options to control optional connection params","label":"ConnectionOptions","tags":["go","developer-guide"],"markdown_content":"\n- Options to control optional connection params\n\n| Option                       | Description                                                                   | Type          |\n| ---------------------------- | ----------------------------------------------------------------------------- | ------------- |\n| TLS                          | Configures connection level security credentials                              | tls.Config    |\n| Authority                    | Set the value to be used as the :authority pseudo-header                      | string        |\n| DisableHealthCheck           | Disable health check                                                          | bool          |\n| HealthCheckAttemptTimeout    | Specify how to long to wait for service response on each health check attempt | time.Duration |\n| HealthCheckTimeout           | Set the default health check timeout                                          | time.Duration |\n| EnableKeepAliveCheck         | Set enable keep alive check                                                   | bool          |\n| KeepAliveTime                | Set the keep alive time                                                       | time.Duration |\n| KeepAliveTimeout             | Set the keep alive timeout                                                    | time.Duration |\n| KeepAlivePermitWithoutStream | Set if client sends keepalive pings even with no active RPCs                  | bool          |\n","is_empty":false},{"file_name":"how-to-set-executelocalactivityoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-executelocalactivityoptions-in-go.md","id":241,"title":"How to set ExecuteLocalActivityOptions in Go","description":"Used to set local activity specific parameters that will be stored inside of a context","label":"ExecuteLocalActivityOptions","tags":["go","developer-guide"],"markdown_content":"\n- Used to set local activity specific parameters that will be stored inside a context\n\n| Option                 | Description                                                         | Type          |\n| ---------------------- | ------------------------------------------------------------------- | ------------- |\n| ScheduleToCloseTimeout | Set the end to end timeout for the local activity including retries | time.Duration |\n| StartToCloseTimeout    | Set timeout for a single execution of the local activity            | time.Duration |\n| RetryPolicy            | Set how to retry Activity if error happens                          | time.Duration |\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-mtls-configuration-in-go.md","id":242,"title":"How to set mTLS configuration in Go","description":"Use the `ConnectionOptions` API available in the `go.temporal.io/sdk/client` package to connect a Client with mTLS.","label":"Set mTLS configuration","tags":["developer-guide","sdk","Go"],"markdown_content":"\nUse the [`ConnectionOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#ConnectionOptions) API available in the [`go.temporal.io/sdk/client`](https://pkg.go.dev/go.temporal.io/sdk/client) package to connect a Client with mTLS.\n\n```go\n\tcert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tclient, err := client.Dial(client.Options{\n\t\tHostPort:  \"foo.bar.tmprl.cloud:7233\",\n\t\tNamespace: \"foo.bar\",\n\t\tConnectionOptions: client.ConnectionOptions{\n\t\t\tTLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n\t\t},\n\t})\n```\n","is_empty":false},{"file_name":"how-to-set-registeractivityoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-registeractivityoptions-in-go.md","id":243,"title":"How to set RegisterActivityOptions in Go","description":"Create an instance of `RegisterOptions` from the `go.temporal.io/sdk/activity` package and pass it to the `RegisterActivityWithOptions` call when registering the Activity Type with the Worker.","label":"RegisterActivityOptions","tags":["developer-guide"],"markdown_content":"\nCreate an instance of [`RegisterOptions`](https://pkg.go.dev/go.temporal.io/sdk/activity#RegisterOptions) from the `go.temporal.io/sdk/activity` package and pass it to the [`RegisterActivityWithOptions`](https://pkg.go.dev/go.temporal.io/sdk/worker#ActivityRegistry) call when registering the Activity Type with the Worker.\n\nOptions for registering an Activity\n\n| Field                                                             | Required | Type     |\n| ----------------------------------------------------------------- | -------- | -------- |\n| [`Name`](#name)                                                   | No       | `string` |\n| [`DisableAlreadyRegisteredCheck`](#disablealreadyregisteredcheck) | No       | `bool`   |\n| [`SkipInvalidStructFunctions`](#skipinvalidstructfunctions)       | No       | `bool`   |\n\n### `Name`\n\nimport CustomizeActivityType from './how-to-customize-activity-type-in-go.md'\n\n<CustomizeActivityType/>\n\n### `DisableAlreadyRegisteredCheck`\n\nDisables the check to see if the Activity has already been registered.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  DisableAlreadyRegisteredCheck: false,\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n\n### `SkipInvalidStructFunctions`\n\nWhen registering a struct that has Activities, skip functions that are not valid.\nIf false, registration panics.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  SkipInvalidStructFunctions: false,\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-registerworkflowoptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-registerworkflowoptions-in-go.md","id":244,"title":"How to set RegisterWorkflowOptions in Go","description":"Create an instance of `RegisterOptions` from the `go.temporal.io/sdk/workflow` package and pass it to the `RegisterWorkflowWithOptions` call when registering the Workflow Type with the Worker","label":"RegisterWorkflowOptions","tags":["developer-guide","go"],"markdown_content":"\nCreate an instance of [`RegisterOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#RegisterOptions) from the `go.temporal.io/sdk/workflow` package and pass it to the [`RegisterWorkflowWithOptions`](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowRegistry) call when registering the Workflow Type with the Worker.\n\n- Used to set options for registering a Workflow\n\n| Field                                                             | Required | Type     |\n| ----------------------------------------------------------------- | -------- | -------- |\n| [`Name`](#name)                                                   | No       | `string` |\n| [`DisableAlreadyRegisteredCheck`](#disablealreadyregisteredcheck) | No       | `bool`   |\n\n## `Name`\n\nimport CustomizeWorkflowType from './how-to-customize-workflow-type-in-go.md'\n\n<CustomizeWorkflowType/>\n\n### `DisableAlreadyRegisteredCheck`\n\nDisables the check to see if the Workflow Type has already been registered.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := workflow.RegisterOptions{\n  DisableAlreadyRegisteredCheck: `false`,\n  // ...\n}\nw.RegisterWorkflowWithOptions(YourWorkflowDefinition, registerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-session-options-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-session-options-in-go.md","id":245,"title":"How to set SessionOptions in Go","description":"Create an instance of `SessionOptions` and pass it to the `CreateSession()` API call.","label":"SessionOptions","tags":["developer-guide"],"markdown_content":"\nCreate an instance of [`SessionOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#SessionOptions) and pass them to the [`CreateSession()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#CreateSession)\n\n| Field                                   | Required | Type            |\n| --------------------------------------- | -------- | --------------- |\n| [`ExecutionTimeout`](#executiontimeout) | No       | `time.Duration` |\n| [`CreationTimeout`](#creationtimeout)   | No       | `time.Duration` |\n| [`HeartbeatTimeout`](#heartbeattimeout) | No       | `time.Duration` |\n\n### ExecutionTimeout\n\nSpecifies the maximum amount of time the session can run.\n\n- Type: `time.Duration`\n- Default:\n\n### CreationTimeout\n\nSpecifies how long session creation can take before returning an error.\n\n- Type: `time.Duration`\n- Default:\n\n### HeartbeatTimeout\n\nSpecifies the heartbeat timeout.\n\n- Type: `time.Duration`\n- Default:\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-the-namespace-for-a-temporal-client-in-go.md","id":246,"title":"How to set a Namespace for a Temporal Client in Go","description":"Set the Namespace field on an instance of the Client Options.","label":"Set Namespace","tags":["how-to","go"],"markdown_content":"\nSet the `Namespace` field on an instance of the Client Options.\n\n```go\n// ...\nclientOptions := client.Options{\n  Namespace: \"your-custom-namespace\",\n}\ntemporalClient, err := client.Dial(clientOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-set-workeroptions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-set-workeroptions-in-go.md","id":247,"title":"How to set WorkerOptions in Go","description":"Create an instance of `Options` from the `go.temporal.io/sdk/worker` package, set any of the optional fields, and pass the instance to the `New` call.","label":"WorkerOptions","tags":["developer-guide","options","go"],"markdown_content":"\nCreate an instance of [`Options`](https://pkg.go.dev/go.temporal.io/sdk/worker#Options) from the `go.temporal.io/sdk/worker` package, set any of the optional fields, and pass the instance to the [`New`](https://pkg.go.dev/go.temporal.io/sdk/worker#New) call.\n\n| Field                                                                                 | Required | Type                                                                                          |\n| ------------------------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------- |\n| [`MaxConcurrentActivityExecutionSize`](#maxconcurrentactivityexecutionsize)           | No       | `int`                                                                                         |\n| [`WorkerActivitiesPerSecond`](#workeractivitiespersecond)                             | No       | `float64`                                                                                     |\n| [`MaxConcurrentLocalActivityExecutionSize`](#maxconcurrentlocalactivityexecutionsize) | No       | `int`                                                                                         |\n| [`WorkerLocalActivitiesPerSecond`](#workerlocalactivitiespersecond)                   | No       | `float64`                                                                                     |\n| [`TaskQueueActivitiesPerSecond`](#taskqueueactivitiespersecond)                       | No       | `float64`                                                                                     |\n| [`MaxConcurrentActivityTaskPollers`](#maxconcurrentactivitytaskpollers)               | No       | `int`                                                                                         |\n| [`MaxConcurrentWorkflowTaskExecutionSize`](#maxconcurrentworkflowtaskexecutionsize)   | No       | `int`                                                                                         |\n| [`MaxConcurrentWorkflowTaskPollers`](#maxconcurrentworkflowtaskpollers)               | No       | `int`                                                                                         |\n| [`EnableLoggingInReplay`](#enablelogginginreplay)                                     | No       | `bool`                                                                                        |\n| [`DisableStickyExecution`](#disablestickyexecution)                                   | No       | `bool`                                                                                        |\n| [`StickyScheduleToStartTimeout`](#stickyscheduletostarttimeout)                       | No       | [`time.Duration`](https://pkg.go.dev/time#Duration)                                           |\n| [`BackgroundActivityContext`](#backgroundactivitycontext)                             | No       | [`context.Context`](https://pkg.go.dev/context#Context)                                       |\n| [`WorkflowPanicPolicy`](#workflowopanicpolicy)                                        | No       | [`WorkflowPanicPolicy`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowPanicPolicy)   |\n| [`WorkerStopTimeout`](#workerstoptimeout)                                             | No       | [`time.Duration`](https://pkg.go.dev/time#Duration)                                           |\n| [`EnableSessionWorker`](#enablesessionworker)                                         | No       | `bool`                                                                                        |\n| [`MaxConcurrentSessionExecutionSize`](#maxconcurrentsessionexecutionsize)             | No       | `int`                                                                                         |\n| [`WorkflowInterceptorChainFactories`](#workflowinterceptorchainfactories)             | No       | [`[]WorkflowInterceptor`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowInterceptor) |\n| [`LocalActivityWorkerOnly`](#localactivityworkeronly)                                 | No       | `bool`                                                                                        |\n| [`Identity`](#identity)                                                               | No       | `string`                                                                                      |\n| [`DeadlockDetectionTimeout`](#deadlockdetectiontimeout)                               | No       | [`time.Duration`](https://pkg.go.dev/time#Duration)                                           |\n\n### `MaxConcurrentActivityExecutionSize`\n\nSets the maximum concurrent Activity Executions for the Worker.\n\n- Type: `int`\n- Default: `1000`\n\nA value of `0` sets to the default.\n\n```go\n// ...\nworkerOptions := worker.Options{\n  MaxConcurrentActivityExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkerActivitiesPerSecond`\n\nRate limits the number of Activity Task Executions started per second for the Worker.\n\n- Type: `float64`\n- Default: `100000`\n\nA value of `0` sets to the default.\n\nIntended use case is to limit resources used by the Worker.\n\nNotice that the value type is a float so that the value can be less than 1 if needed.\nFor example, if set to 0.1, Activity Task Executions will happen once every ten seconds.\nThis can be used to protect down stream services from flooding with requests.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tWorkerActivitiesPerSecond: 100000,\n  // ..\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentLocalActivityExecutionSize`\n\nSet the maximum concurrent [Local Activity Executions](/concepts/what-is-a-local-activity) for the Worker.\n\n- Type: `int`\n- Default: `1000`\n\nA value of `0` sets to the default value.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentLocalActivityExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkerLocalActivitiesPerSecond`\n\nRate limits the number of Local Activity Executions per second executed for the Worker.\n\n- Type: `float64`\n- Default: `100000`\n\nA value of `0` sets to the default value.\n\nIntended use case is to limit resources used by the Worker.\n\nNotice that the value type is a float so that the value can be less than 1 if needed.\nFor example, if set to 0.1, Local Activity Task Executions will happen once every ten seconds.\nThis can be used to protect down stream services from flooding with requests.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tWorkerLocalActivitiesPerSecond: 100000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `TaskQueueActivitiesPerSecond`\n\nRate limits the number of Activity Executions that can be started per second.\n\n- Type: `float64`\n- Default: `100000`\n\nA value of `0` sets to the default value.\n\nThis rate is managed by the Temporal Cluster and limits the Activity Tasks per second for the entire Task Queue. This is in contrast to [`WorkerActivityTasksPerSecond`](#workeractivitytaskspersecond) controls activities only per Worker.\n\nNotice that the number is represented in float, so that you can set it to less than 1 if needed.\nFor example, set the number to 0.1 means you want your Activity to be executed once for every 10 seconds.\nThis can be used to protect down stream services from flooding.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tTaskQueueActivitiesPerSecond: 100000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentActivityTaskPollers`\n\nSets the maximum number of goroutines to concurrently poll the Task Queue for Activity Tasks.\n\n- Type: `int`\n- Default: `2`\n\nChanging this value will affect the rate at which the Worker is able to consume Activity Tasks from the Task Queue.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentActivityTaskPollers: 2,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentWorkflowTaskExecutionSize`\n\nSets the maximum number of concurrent Workflow Task Executions the Worker can have.\n\n- Type: `int`\n- Default: `1000`\n\nA value of `0` sets to the default value.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentWorkflowTaskExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentWorkflowTaskPollers`\n\nSets the maximum number of goroutines that will concurrently poll the Task Queue for Workflow Tasks.\n\n- Type: `int`\n- Default: `2`\n\nChanging this value will affect the rate at which the Worker is able to consume Workflow Tasks from the Task Queue.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentWorkflowTaskPollers: 2,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `EnableLoggingInReplay`\n\nSet to enable logging in Workflow Execution replays.\n\n- type: `bool`\n- Default: `false`\n\nIn Workflow Definitions you can use [`workflow.GetLogger(ctx)`](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetLogger) to write logs.\nBy default, the logger will skip logging during replays, so you do not see duplicate logs.\n\nThis is only really useful for debugging purpose.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tEnableLoggingInReplay: false,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `DisableStickyExecution`\n\n:::caution Deprecated\n\nWhen DisableStickyExecution is `true` it can harm performance.\nIt will be removed soon.\nSee [`SetStickyWorkflowCacheSize`](https://pkg.go.dev/go.temporal.io/sdk/worker#SetStickyWorkflowCacheSize) instead.\n\n:::\n\nSet to disable Sticky Executions\n\n- Type: `bool`\n- Default: `false`\n\nSticky Execution runs Workflow Tasks of a Workflow Execution on same host (could be a different Worker, as long as it is on the same host).\nThis is an optimization for Workflow Executions.\nWhen sticky execution is enabled, Worker keeps the Workflow state in memory.\nNew Workflow Task contains the new history events will be dispatched to the same Worker.\nIf this Worker crashes, the sticky Workflow Task will timeout after `StickyScheduleToStartTimeout`, and Temporal Cluster will clear the stickiness for that Workflow Execution and automatically reschedule a new Workflow Task that is available for any Worker to pick up and resume the progress.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tStickyScheduleToStartTimeout: time.Second(5),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `StickyScheduleToStartTimeout`\n\nSets the Sticky Execution Schedule-To-Start Timeout for Workflow Tasks.\n\n- Type: [`time.Duration`](https://pkg.go.dev/time#Duration)\n- Default value is `5`\n\nThe resolution is in seconds.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tStickyScheduleToStartTimeout: time.Second(5),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `BackgroundActivityContext`\n\n:::caution Not recommended\n\nThis method of passing dependencies between Activity Task Executions is not recommended anymore.\n\nInstead, we recommend using a struct with fields that contain dependencies and [develop Activity Definitions](/go/how-to-develop-an-activity-definition-in-go) as struct methods and then pass all the dependencies on the structure initialization.\n\n:::\n\n- Type: [`context.Context`](https://pkg.go.dev/context#Context)\n\nSets the background `context.Context` for all Activity Types registered with the Worker.\n\nThe context can be used to pass external dependencies such as database connections to Activity Task Executions.\n\n```go\n// ...\nctx := context.WithValue(context.Background(), \"your-key\", \"your-value\")\nworkerOptions := worker.Options{\n\tBackgroundActivityContext: ctx,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkflowPanicPolicy`\n\nSets how the Workflow Worker handles a non-deterministic Workflow Execution History Event and other panics from Workflow Definition code.\n\n- Type: [`WorkflowPanicPolicy`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowPanicPolicy)\n- Default: `BlockWorkflow`\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tDisableStickyExecution: internal.BlockWorkflow,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkerStopTimeout`\n\nSets the Worker's graceful stop timeout\n\n- Type: [`time.Duration`](https://pkg.go.dev/time#Duration)\n- Default: `0`\n\nValue resolution is in seconds.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tWorkerStopTimeout: time.Second(0),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `EnableSessionWorker`\n\nEnables Sessions for Activity Workers.\n\n- Type: `bool`\n- Default: `false`\n\nWhen `true` the Activity Worker creates a Session to sequentially process Activity Tasks for the given Task Queue.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tEnableSessionWorker: true,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `MaxConcurrentSessionExecutionSize`\n\nSets the maximum number of concurrent Sessions that the Worker can support.\n\n- Type: `int`\n- Default: 1000\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tMaxConcurrentSessionExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `WorkflowInterceptorChainFactories`\n\nSpecifies the factories used to instantiate the Workflow interceptor chain.\n\n- Type: [`[]WorkflowInterceptor`](https://pkg.go.dev/go.temporal.io/sdk/internal#WorkflowInterceptor)\n\nThe chain is instantiated for each replay of a Workflow Execution.\n\n### `LocalActivityWorkerOnly`\n\nSets the Worker to only handle Workflow Tasks and local Activity Tasks.\n\n- Type: `bool`\n- Default: `false`\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tLocalActivityWorkerOnly: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `Identity`\n\nSets the Temporal Client-level Identity value, overwriting the existing one.\n\n- Type: string\n- Default: client identity\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tIdentity: \"your_custom_identity\",\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n### `DeadlockDetectionTimeout`\n\nSets the maximum time that a Workflow Task can execute for.\n\n- Type: [`time.Duration`](https://pkg.go.dev/time#Duration)\n- Default: 1\n\nResolution is in seconds.\n\n```go\n// ...\nworkerOptions := worker.Options{\n\tDeadlockDetectionTimeout: time.Second(1),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-spawn-a-child-workflow-execution-in-go.md","id":248,"title":"How to spawn a Child Workflow Execution in Go","description":"Use the `ExecuteChildWorkflow`, available from the `go.temporal.io/sdk/workflow` package, to spawn a Child Workflow Execution in Go.","label":"Child Workflow Execution","tags":["developer-guide","go"],"markdown_content":"\nTo spawn a [Child Workflow Execution](/concepts/what-is-a-child-workflow-execution) in Go, use the [`ExecuteChildWorkflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ExecuteChildWorkflow) API, which is available from the `go.temporal.io/sdk/workflow` package.\n\nThe `ExecuteChildWorkflow` call requires an instance of [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context), with an instance of [`workflow.ChildWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowOptions) applied to it, the Workflow Type, and any parameters that should be passed to the Child Workflow Execution.\n\n`workflow.ChildWorkflowOptions` contain the same fields as `client.StartWorkflowOptions`.\nWorkflow Option fields automatically inherit their values from the Parent Workflow Options if they are not explicitly set.\nIf a custom `WorkflowID` is not set, one is generated when the Child Workflow Execution is spawned.\nUse the [`WithChildOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithChildOptions) API to apply Child Workflow Options to the instance of `workflow.Context`.\n\nThe `ExecuteChildWorkflow` call returns an instance of a [`ChildWorkflowFuture`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ChildWorkflowFuture).\n\nCall the `.Get()` method on the instance of `ChildWorkflowFuture` to wait for the result.\n\n```go\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{}\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  var result ChildResp\n  err := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{}).Get(ctx, &result)\n  if err != nil {\n    // ...\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\nTo asynchronously spawn a Child Workflow Execution, the Child Workflow must have an \"Abandon\" Parent Close Policy set in the Child Workflow Options.\nAdditionally, the Parent Workflow Execution must wait for the \"ChildWorkflowExecutionStarted\" event to appear in its event history before it completes.\n\nIf the Parent makes the `ExecuteChildWorkflow` call and then immediately completes, the Child Workflow Execution will not spawn.\n\nTo be sure that the Child Workflow Execution has started, first call the `GetChildWorkflowExecution` method on the instance of the `ChildWorkflowFuture`, which will return a different Future.\nThen call the `Get()` method on that Future, which is what will wait until the Child Workflow Execution has spawned.\n\n```go\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // Wait for the Child Workflow Execution to spawn\n  var childWE workflow.Execution\n  if err := childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE); err != nil {\n     return err\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-spawn-a-workflow-execution-in-go.md","id":249,"title":"How to spawn a Workflow Execution in Go","description":"Use the `ExecuteWorkflow()` method on the Go SDK `Client`, which is available via `Dial()` in the `go.temporal.io/sdk/client` package.","label":"Workflow Execution","tags":["developer-guide","go"],"markdown_content":"\nTo spawn a [Workflow Execution](/concepts/what-is-a-workflow-execution), use the `ExecuteWorkflow()` method on the Go SDK [`Client`](https://pkg.go.dev/go.temporal.io/sdk/client#Client).\n\nThe `ExecuteWorkflow()` API call requires an instance of [`context.Context`](https://pkg.go.dev/context#Context), an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk/client#StartWorkflowOptions), a Workflow Type name, and all variables to be passed to the Workflow Execution.\nThe `ExecuteWorkflow()` call returns a Future, which can be used to get the result of the Workflow Execution.\n\n```go\npackage main\n\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n  workflowOptions := client.StartWorkflowOptions{\n    // ...\n  }\n  workflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n  if err != nil {\n    // ...\n  }\n  // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n}\n```\n\nIf the invocation process has access to the function directly, then the Workflow Type name parameter can be passed as if the function name were a variable, without quotations.\n\n```go\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n```\n\nIf the invocation process does not have direct access to the statically defined Workflow Definition, for example, if the Workflow Definition is in an un-importable package, or it is written in a completely different language, then the Workflow Type can be provided as a `string`.\n\n```go\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, \"YourWorkflowDefinition\", param)\n```\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-spawn-an-activity-execution-in-go.md","id":250,"title":"How to spawn an Activity Execution in Go","description":"Use the `ExecuteActivity()` API call available from the `go.temporal.io/sdk/workflow` package.","label":"Activity Execution","tags":["developer-guide","go"],"markdown_content":"\nTo spawn an [Activity Execution](/concepts/what-is-an-activity-execution), use the [`ExecuteActivity()`](https://pkg.go.dev/go.temporal.io/workflow#ExecuteActivity) API call inside your Workflow Definition.\nThe API is available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/workflow) package.\n\nThe `ExecuteActivity()` API call requires an instance of `workflow.Context`, the Activity function name, and any variables to be passed to the Activity Execution.\n\n```go\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/workflow\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n  yourActivityParam := YourActivityParam{\n    // ...\n  }\n  var activities *YourActivityStruct\n  future := workflow.ExecuteActivity(ctx, activities.YourActivityDefinition, yourActivityParam)\n  // ...\n}\n\nfunc (a *YourActivityStruct) YourActivityDefinition(ctx context.Context, param YourActivityParam) error {\n  // ...\n}\n```\n\nThe Activity function name can be provided as a variable object (no quotations) or as a string.\n\n```go\n// ...\n  future := workflow.ExecuteActivity(ctx, \"YourActivityDefinition\", yourActivityParam)\n// ...\n```\n\nThe benefit of passing the actual function object is that the framework can validate the parameters against the Activity Definition.\n\nThe `ExecuteActivity` call returns a Future, which can be used to get the result of the Activity Execution.\n","is_empty":false},{"file_name":"how-to-test-workflow-definitions-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-test-workflow-definitions-in-go.md","id":251,"title":"How to test Workflow Definitions in Go","label":"Testing and debugging","markdown_content":"\nThe Temporal Go SDK provides a test framework to facilitate testing Workflow implementations.\n\nThis framework is suited for implementing unit tests as well as functional tests of the Workflow logic.\n\nThe following code implements unit tests for the `SimpleWorkflow` sample:\n\n```go\npackage sample\n\nimport (\n        \"context\"\n        \"errors\"\n        \"testing\"\n\n        \"github.com/stretchr/testify/mock\"\n        \"github.com/stretchr/testify/suite\"\n\n        \"go.temporal.io/sdk/activity\"\n        \"go.temporal.io/sdk/testsuite\"\n)\n\ntype UnitTestSuite struct {\n        suite.Suite\n        testsuite.WorkflowTestSuite\n\n        env *testsuite.TestWorkflowEnvironment\n}\n\nfunc (s *UnitTestSuite) SetupTest() {\n        s.env = s.NewTestWorkflowEnvironment()\n}\n\nfunc (s *UnitTestSuite) AfterTest(suiteName, testName string) {\n        s.env.AssertExpectations(s.T())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n\nfunc TestUnitTestSuite(t *testing.T) {\n        suite.Run(t, new(UnitTestSuite))\n}\n```\n\n#### Setup\n\nTo run unit tests, we first define a test suite struct that absorbs both the\nbasic suite functionality from [testify](https://pkg.go.dev/github.com/stretchr/testify/suite)\nvia `suite.Suite` and the suite functionality from the Temporal test framework via\n`testsuite.WorkflowTestSuite`. Because every test in this test suite will test our Workflow, we\nadd a property to our struct to hold an instance of the test environment. This allows us to initialize\nthe test environment in a setup method. For testing Workflows, we use a `testsuite.TestWorkflowEnvironment`.\n\nNext, we implement a `SetupTest` method to set up a new test environment before each test. Doing so\nensures that each test runs in its own isolated sandbox. We also implement an `AfterTest` function\nwhere we assert that all the mocks we set up were indeed called by invoking `s.env.AssertExpectations(s.T())`.\n\nTimeout for the entire test can be set using `SetTestTimeout` in the Workflow or Activity environment.\n\nFinally, we create a regular test function recognized by the `go test` command, and pass the struct to `suite.Run`.\n\n#### A Simple Test\n\nThe simplest test case we can write is to have the test environment execute the Workflow and then\nevaluate the results.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\nCalling `s.env.ExecuteWorkflow(...)` executes the Workflow logic and any invoked Activities inside the\ntest process. The first parameter of `s.env.ExecuteWorkflow(...)` contains the Workflow functions,\nand any subsequent parameters contain values for custom input parameters declared by the Workflow\nfunction.\n\n> Note that unless the Activity invocations are mocked or Activity implementation\n> replaced (see [Activity mocking and overriding](#activity-mocking-and-overriding)), the test environment\n> will execute the actual Activity code including any calls to outside services.\n\nAfter executing the Workflow in the above example, we assert that the Workflow ran through completion\nvia the call to `s.env.IsWorkflowComplete()`. We also assert that no errors were returned by asserting\non the return value of `s.env.GetWorkflowError()`. If our Workflow returned a value, we could have\nretrieved that value via a call to `s.env.GetWorkflowResult(&value)` and had additional asserts on that\nvalue.\n\n#### Activity mocking and overriding\n\nWhen running unit tests on Workflows, we want to test the Workflow logic in isolation. Additionally,\nwe want to inject Activity errors during our test runs. The test framework provides two mechanisms\nthat support these scenarios: Activity mocking and Activity overriding. Both of these mechanisms allow\nyou to change the behavior of Activities invoked by your Workflow without the need to modify the actual\nWorkflow code.\n\nLet's take a look at a test that simulates a test that fails via the \"Activity mocking\" mechanism.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n```\n\nThis test simulates the execution of the Activity `SimpleActivity` that is invoked by our Workflow\n`SimpleWorkflow` returning an error. We accomplish this by setting up a mock on the test environment\nfor the `SimpleActivity` that returns an error.\n\n```go\ns.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n  \"\", errors.New(\"SimpleActivityFailure\"))\n```\n\nWith the mock set up we can now execute the Workflow via the `s.env.ExecuteWorkflow(...)` method and\nassert that the Workflow completed successfully and returned the expected error.\n\nSimply mocking the execution to return a desired value or error is a pretty powerful mechanism to\nisolate Workflow logic. However, sometimes we want to replace the Activity with an alternate implementation\nto support a more complex test scenario. Let's assume we want to validate that the Activity gets called\nwith the correct parameters.\n\n```go\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\nIn this example, we provide a function implementation as the parameter to `Return`. This allows us to\nprovide an alternate implementation for the Activity `SimpleActivity`. The framework will execute this\nfunction whenever the Activity is invoked and pass on the return value from the function as the result\nof the Activity invocation. Additionally, the framework will validate that the signature of the \"mock\"\nfunction matches the signature of the original Activity function.\n\nSince this can be an entire function, there is no limitation as to what we can do here. In this\nexample, we assert that the `value` param has the same content as the value param we passed to the Workflow.\n\n#### Queries\n\n`TestWorkflowEnvironment` instances have a [`QueryWorkflow()` method](https://pkg.go.dev/go.temporal.io/temporal/internal#TestWorkflowEnvironment.QueryWorkflow) that lets you query the state of the currently running Workflow.\nFor example, suppose you have a Workflow that lets you query the progress of a long running task as shown below.\n\n```go\nfunc ProgressWorkflow(ctx workflow.Context, percent int) error {\n\tlogger := workflow.GetLogger(ctx)\n\n\terr := workflow.SetQueryHandler(ctx, \"getProgress\", func(input []byte) (int, error) {\n\t\treturn percent, nil\n\t})\n\tif err != nil {\n\t\tlogger.Info(\"SetQueryHandler failed.\", \"Error\", err)\n\t\treturn err\n\t}\n\n\tfor percent = 0; percent<100; percent++ {\n                // Important! Use `workflow.Sleep()`, not `time.Sleep()`, because Temporal's\n                // test environment doesn't stub out `time.Sleep()`.\n\t\tworkflow.Sleep(ctx, time.Second*1)\n\t}\n\n\treturn nil\n}\n```\n\nThis Workflow tracks the current progress of a task in percentage terms, and increments the percentage by 1 every second.\nBelow is how you would write a test case that queries this Workflow.\nNote that you should always query the Workflow either after `ExecuteWorkflow()` is done or in a `RegisterDelayedCallback()` callback, otherwise you'll get a `runtime error` panic.\n\n```go\nfunc (s *UnitTestSuite) Test_ProgressWorkflow() {\n\tvalue := 0\n\n\t// After 10 seconds plus padding, progress should be 10.\n\t// Note that `RegisterDelayedCallback()` doesn't actually make your test wait for 10 seconds!\n\t// Temporal's test framework advances time internally, so this test should take < 1 second.\n\ts.env.RegisterDelayedCallback(func() {\n\t\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\t\ts.NoError(err)\n\t\terr = res.Get(&value)\n\t\ts.NoError(err)\n\t\ts.Equal(10, value)\n\t}, time.Second*10+time.Millisecond*1)\n\n\ts.env.ExecuteWorkflow(ProgressWorkflow, 0)\n\n\ts.True(s.env.IsWorkflowCompleted())\n\n\t// Once the workflow is completed, progress should always be 100\n\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\ts.NoError(err)\n\terr = res.Get(&value)\n\ts.NoError(err)\n\ts.Equal(value, 100)\n}\n```\n\n:::note\n\n`RegisterDelayedCallback` can also be used to send [Signals](/concepts/what-is-a-signal).\nWhen using \"Signal-With-Start\", set the delay to `0`.\n:::\n\n#### Debugging\n\nYou can use a debugger tool provided by your favorite IDE to debug your Workflow Definitions prior to testing or executing them.\n\nThe Temporal Go SDK includes deadlock detection which fails a Workflow Task in case the code blocks over a second without relinquishing execution control.\nBecause of this you can often encounter a `PanicError: Potential deadlock detected` while stepping through Workflow Definitions during debugging.\n\nTo alleviate this issue, you can set the `TEMPORAL_DEBUG` environment variable to `true` before debugging your Workflow Definition.\n\n:::note\n\nMake sure to set `TEMPORAL_DEBUG` to true only during debugging.\n\n:::\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-go.md","id":252,"title":"How to upsert custom Search Attributes to Workflow during Execution","label":"How to upsert custom Search Attributes to Workflow during Execution","tags":["developer-guide","go"],"markdown_content":"\nIn advanced cases, you may want to dynamically update these attributes as the Workflow progresses.\n[UpsertSearchAttributes](https://pkg.go.dev/go.temporal.io/sdk/workflow#UpsertSearchAttributes) is used to add or update Search Attributes from within Workflow code.\n\n`UpsertSearchAttributes` will merge attributes to the existing map in the Workflow.\nConsider this example Workflow code:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n\n    attr1 := map[string]interface{}{\n        \"CustomIntField\": 1,\n        \"CustomBoolField\": true,\n    }\n    workflow.UpsertSearchAttributes(ctx, attr1)\n\n    attr2 := map[string]interface{}{\n        \"CustomIntField\": 2,\n        \"CustomKeywordField\": \"seattle\",\n    }\n    workflow.UpsertSearchAttributes(ctx, attr2)\n}\n```\n\nAfter the second call to `UpsertSearchAttributes`, the map will contain:\n\n```go\nmap[string]interface{}{\n    \"CustomIntField\": 2, // last update wins\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"seattle\",\n}\n```\n","is_empty":false},{"file_name":"how-to-use-queries-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-use-queries-in-go.md","id":253,"title":"How to use Queries in Go","description":"A Query is sent from a Temporal Client to a Workflow Execution and is identified by its name.","label":"Queries","tags":["go","developer-guide"],"markdown_content":"\nimport QueryType from './how-to-define-a-query-type-in-go.md'\n\n<QueryType/>\n\n### Send Query\n\nimport SendQuery from './how-to-send-a-query-to-a-workflow-execution-in-go.md'\n\n<SendQuery/>\n\n### Handle Query\n\nimport HandleQuery from './how-to-handle-a-query-in-a-workflow-in-go.md'\n\n<HandleQuery/>\n","is_empty":false},{"file_name":"how-to-use-signals-in-go.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/how-to-use-signals-in-go.md","id":254,"title":"How to use Signals in Go","description":"Use the `SignalWorkflow()` method on and instance of the Go SDK Temporal Client to send a Signal to a Workflow Execution.","label":"Signals","tags":["go","developer-guide"],"markdown_content":"\nTo use Signals in Go, first define your Signal type and then add a Signal handler to your Workflow Definition.\nSignals can then be sent via the Temporal Client or from within a Workflow.\n\n### Define Signal type\n\nimport DefineSignal from './how-to-define-a-signal-in-go.md'\n\n<DefineSignal/>\n\n### Handle Signal\n\nimport HandleSignal from './how-to-handle-a-signal-in-go.md'\n\n<HandleSignal/>\n\n### Send Signal from Temporal Client\n\nimport SendSignalClient from './how-to-send-a-signal-from-a-client-in-go.md'\n\n<SendSignalClient/>\n\n### Send Signal from within a Workflow\n\nimport SendSignalWorkflow from './how-to-send-a-signal-from-a-workflow-in-go.md'\n\n<SendSignalWorkflow/>\n\n### Signal-With-Start\n\nimport SignalWithStart from './how-to-send-a-signal-with-start-in-go.md'\n\n<SignalWithStart/>\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/index.md","id":255,"title":"How to use the Temporal Go SDK","description":"Add the Temporal Go SDK to your project.","tags":["developer-guide","go"],"markdown_content":"\n[![Build Status](https://badge.buildkite.com/ce6df3b1a8b375270261ae70fb2d2756af298fef3a0dac4d20.svg?theme=github&branch=master)](https://buildkite.com/temporal/temporal-go-client) [![Coverage Status](https://coveralls.io/repos/github/temporalio/temporal-go-sdk/badge.svg?branch=master)](https://coveralls.io/github/temporalio/temporal-go-sdk?branch=master) [![Go reference](https://pkg.go.dev/badge/go.temporal.io/sdk)](https://pkg.go.dev/go.temporal.io/sdk)\n\nAdd the [Temporal Go SDK](https://github.com/temporalio/sdk-go) to your project:\n\n```bash\ngo get -u go.temporal.io/sdk@latest\n```\n\nOr clone the Go SDK repo to your preferred location:\n\n```bash\ngit clone git@github.com:temporalio/sdk-go.git\n```\n","is_empty":false},{"file_name":"reference-activityoptions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/reference-activityoptions.md","id":256,"title":"Go ActivityOptions reference","description":"Create an instance of `ActivityOptions` from the `go.temporal.io/sdk/workflow` package and use `WithActivityOptions()` to apply it to the instance of `workflow.Context`.","label":"Activity Options reference","tags":["developer-guide","go"],"markdown_content":"\nCreate an instance of [`ActivityOptions`](https://pkg.go.dev/go.temporal.io/sdk/workflow#ActivityOptions) from the `go.temporal.io/sdk/workflow` package and use [`WithActivityOptions()`](https://pkg.go.dev/go.temporal.io/sdk/workflow#WithActivityOptions) to apply it to the instance of `workflow.Context`.\n\nThe instance of `workflow.Context` is then passed to the `ExecuteActivity()` call.\n\n| Field                                               | Required                          | Type                                                                        |\n| --------------------------------------------------- | --------------------------------- | --------------------------------------------------------------------------- |\n| [`ActivityID`](#activityid)                         | No                                | `string`                                                                    |\n| [`TaskQueueName`](#taskqueuename)                   | No                                | `string`                                                                    |\n| [`ScheduleToCloseTimeout`](#scheduletoclosetimeout) | Yes (or `StartToCloseTimeout`)    | `time.Duration`                                                             |\n| [`ScheduleToStartTimeout`](#scheduletostarttimeout) | No                                | `time.Duration`                                                             |\n| [`StartToCloseTimeout`](#scheduletoclosetimeout)    | Yes (or `ScheduleToCloseTimeout`) | `time.Duration`                                                             |\n| [`HeartbeatTimeout`](#heartbeattimeout)             | No                                | `time.Duration`                                                             |\n| [`WaitForCancellation`](#waitforcancellation)       | No                                | `bool`                                                                      |\n| [`OriginalTaskQueueName`](#originaltaskqueuename)   | No                                | `string`                                                                    |\n| [`RetryPolicy`](#retrypolicy)                       | No                                | [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy) |\n\n### `ActivityID`\n\n- Type: `string`\n- Default: None\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  ActivityID: \"your-activity-id\",\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n- [What is an Activity Id](/concepts/what-is-an-activity-id)\n\n### `TaskQueueName`\n\n- Type: `string`\n- Default: Inherits the TaskQueue name from the Workflow.\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  TaskQueueName: \"your-task-queue-name\",\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n- [What is a Task Queue](/concepts/what-is-a-task-queue)\n\n### `ScheduleToCloseTimeout`\n\nimport ScheduleToCloseTimeout from './how-to-set-a-schedule-to-close-timeout-in-go.md'\n\n<ScheduleToCloseTimeout/>\n\n### `ScheduleToStartTimeout`\n\nimport ScheduleToStartTimeout from './how-to-set-a-schedule-to-start-timeout-in-go.md'\n\n<ScheduleToStartTimeout/>\n\n### `StartToCloseTimeout`\n\nimport StartToCloseTimeout from './how-to-set-a-start-to-close-timeout-in-go.md'\n\n<StartToCloseTimeout/>\n\n### `HeartbeatTimeout`\n\nimport HeartbeatTimeout from './how-to-set-a-heartbeat-timeout-in-go.md'\n\n<HeartbeatTimeout/>\n\n### `WaitForCancellation`\n\nIf `true` the Activity Execution will finish executing should there be a Cancellation request.\n\n- Type: `bool`\n- Default: `false`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  WaitForCancellation: false,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n### `OriginalTaskQueueName`\n\n```go\nactivityoptions := workflow.ActivityOptions{\n  OriginalTaskQueueName: \"your-original-task-queue-name\",\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n### `RetryPolicy`\n\nimport RetryPolicy from './how-to-set-an-activity-retry-policy-in-go.md'\n\n<RetryPolicy/>\n","is_empty":false},{"file_name":"reference-startworkflowoptions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/reference-startworkflowoptions.md","id":257,"title":"Go StartWorkflowOptions reference","description":"Create an instance of `StartWorkflowOptions` from the `go.temporal.io/sdk/client` package, and pass the instance to the `ExecuteWorkflow` call.","label":"Workflow Options reference","tags":["developer-guide","options"],"markdown_content":"\nCreate an instance of [`StartWorkflowOptions`](https://pkg.go.dev/go.temporal.io/sdk@v1.10.0/client#StartWorkflowOptions) from the `go.temporal.io/sdk/client` package, and pass the instance to the `ExecuteWorkflow` call.\n\nThe following fields are available:\n\n| Field                                                                                   | Required | Type                                                                                            |\n| --------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------- |\n| [`ID`](#id)                                                                             | No       | `string`                                                                                        |\n| [`TaskQueue`](#taskqueue)                                                               | **Yes**  | `string`                                                                                        |\n| [`WorkflowExecutionTimeout`](#workflowexecutiontimeout)                                 | No       | `time.Duration`                                                                                 |\n| [`WorkflowRunTimeout`](#workflowruntimeout)                                             | No       | `time.Duration`                                                                                 |\n| [`WorkflowTaskTimeout`](#workflowtasktimeout)                                           | No       | `time.Duration`                                                                                 |\n| [`WorkflowIDReusePolicy`](#workflowidreusepolicy)                                       | No       | [`WorkflowIdReusePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#WorkflowIdReusePolicy) |\n| [`WorkflowExecutionErrorWhenAlreadyStarted`](#workflowexecutionerrorwhenalreadystarted) | No       | `bool`                                                                                          |\n| [`RetryPolicy`](#retrypolicy)                                                           | No       | [`RetryPolicy`](https://pkg.go.dev/go.temporal.io/sdk/temporal#RetryPolicy)                     |\n| [`CronSchedule`](#cronschedule)                                                         | No       | `string`                                                                                        |\n| [`Memo`](#memo)                                                                         | No       | `map[string]interface{}`                                                                        |\n| [`SearchAttributes`](#searchattributes)                                                 | No       | `map[string]interface{}`                                                                        |\n\n### `ID`\n\nimport WorkflowId from './how-to-set-a-workflow-id-in-go.md'\n\n<WorkflowId/>\n\n### `TaskQueue`\n\nimport TaskQueue from './how-to-set-a-workflow-task-queue-in-go.md'\n\n<TaskQueue/>\n\n### `WorkflowExecutionTimeout`\n\nimport WFETimeout from './how-to-set-a-workflow-execution-timeout-in-go.md'\n\n<WFETimeout/>\n\n### `WorkflowRunTimeout`\n\nimport WFRTimeout from './how-to-set-a-workflow-run-timeout-in-go.md'\n\n<WFRTimeout/>\n\n### `WorkflowTaskTimeout`\n\nimport WFTTimeout from './how-to-set-a-workflow-task-timeout-in-go.md'\n\n<WFTTimeout/>\n\n### `WorkflowIDReusePolicy`\n\n- Type: [`WorkflowIdReusePolicy`](https://pkg.go.dev/go.temporal.io/api/enums/v1#WorkflowIdReusePolicy)\n- Default: `enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE`\n\nSet a value from the `go.temporal.io/api/enums/v1` package.\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowIdReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n### `WorkflowExecutionErrorWhenAlreadyStarted`\n\n- Type: `bool`\n- Default: `false`\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowExecutionErrorWhenAlreadyStarted: false,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n### `RetryPolicy`\n\nimport RetryPolicy from './how-to-set-a-workflow-retry-policy-in-go.md'\n\n<RetryPolicy/>\n\n### `CronSchedule`\n\n- Type: `string`\n- Default: None\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n[Sample](https://github.com/temporalio/samples-go/tree/master/cron)\n\n### `Memo`\n\n- Type: `map[string]interface{}`\n- Default: Empty\n\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  Memo: map[string]interface{}{\n    \"description\": \"Test search attributes workflow\",\n  },\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n### `SearchAttributes`\n\n**How to set Workflow Execution Search Attributes in Go**\n\n- Type: `map[string]interface{}`\n- Default: Empty.\n\nThese are the corresponding [Search Attribute value types](/concepts/what-is-a-search-attribute/#types) in Go:\n\n- Keyword = string\n- Int = int64\n- Double = float64\n- Bool = bool\n- Datetime = time.Time\n- Text = string\n\n```go\nsearchAttributes := map[string]interface{}{\n  \"CustomIntField\": 1,\n  \"MiscData\": \"yellow\",\n}\nworkflowOptions := client.StartWorkflowOptions{\n  SearchAttributes: searchAttributes,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n","is_empty":false},{"file_name":"search-apis.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/search-apis.md","id":258,"title":"Using Custom Searchable Attributes in Go","label":"Search Attributes","markdown_content":"\n## Overview\n\nSearch Attributes enable complex and business-logic-focused search queries for Workflow Executions.\nThese are often queried through the Temporal Web UI, but you can also query from within your Workflow code.\n\nMany [Search Attributes](/concepts/what-is-a-search-attribute) are added to Workflow Executions by default.\nBut these are necessarily focused on Temporal internal state tracking.\n\nFor more debugging and monitoring, you might want to add your own domain-specific Search Attributes, such as `customerId` or `numItems`, that can serve as useful search filters.\n\nThe [Go SDK Client](https://pkg.go.dev/go.temporal.io/sdk/client#Client) offers APIs for configuring Search Attributes.\nThere are also APIs on the SDK client for listing Workflows by status.\nGo samples for Search Attributes can be found at [`temporalio/samples-go`](https://github.com/temporalio/samples-go/tree/master/searchattributes).\n\n## Value types\n\nHere are the [Search Attribute value types](/concepts/what-is-a-search-attribute/#types) and their corresponding types in Go:\n\n- Bool = bool\n- Datetime = time.Time\n- Double = float64\n- Int = int64\n- Keyword = string\n- Text = string\n\n## Tagging Search Attributes at Workflow creation\n\nYou can provide key-value pairs as Search Attributes in [StartWorkflowOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions).\nIn Go, Search Attributes are represented as `map[string]interface{}`.\nThe value provided in the map must be the same type that was added to a Cluster.\n\nThis can be useful for tagging executions with useful attributes you may want to search up later. For example:\n\n```go\nfunc (c *Client) CallYourWorkflow(ctx context.Context, workflowID string, payload map[string]interface{}) error {\n    // ...\n    searchAttributes := map[string]interface{}{\n        \"CustomerId\": payload[\"customer\"],\n        \"MiscData\": payload[\"miscData\"]\n    }\n    options := client.StartWorkflowOptions{\n        ID:                 workflowID,\n        TaskQueue:          app.MyTaskQueue,\n        SearchAttributes:   searchAttributes\n    }\n    we, err := c.Client.ExecuteWorkflow(ctx, options, app.YourWorkflow, payload)\n    // ...\n}\n```\n\n## Upsert Search Attributes during Workflow Execution\n\nIn advanced cases, you may want to dynamically update these attributes as the Workflow progresses.\n[UpsertSearchAttributes](https://pkg.go.dev/go.temporal.io/sdk/workflow#UpsertSearchAttributes) is used to add or update Search Attributes from within Workflow code.\n\n`UpsertSearchAttributes` will merge attributes to the existing map in the Workflow.\nConsider this example Workflow code:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n\n    attr1 := map[string]interface{}{\n        \"CustomIntField\": 1,\n        \"CustomBoolField\": true,\n    }\n    workflow.UpsertSearchAttributes(ctx, attr1)\n\n    attr2 := map[string]interface{}{\n        \"CustomIntField\": 2,\n        \"CustomKeywordField\": \"seattle\",\n    }\n    workflow.UpsertSearchAttributes(ctx, attr2)\n}\n```\n\nAfter the second call to `UpsertSearchAttributes`, the map will contain:\n\n```go\nmap[string]interface{}{\n    \"CustomIntField\": 2, // last update wins\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"seattle\",\n}\n```\n\n## Removing Search Attributes\n\n**There is no support for removing a field.**\n\nHowever, to achieve a similar effect, set the field to some placeholder value.\nFor example, you could set `CustomKeywordField` to `impossibleVal`.\nThen searching `CustomKeywordField != 'impossibleVal'` will match Workflows with `CustomKeywordField` not equal to `impossibleVal`, which includes Workflows without the `CustomKeywordField` set.\n\n## Retrieving Search Attributes\n\nUse the `SearchAttributes` property of `workflow.GetInfo` to get a specific Search Attribute:\n\n```go\n// Get search attributes that were provided when workflow was started.\ninfo := workflow.GetInfo(ctx)\nval := info.SearchAttributes.IndexedFields[\"CustomIntField\"]\n```\n\n## Querying Search Attributes within a Workflow\n\nYou can programmatically retrieve attributes from a Workflow Execution with `GetSearchAttributes`, and log out all fields with `GetIndexedFields`:\n\n```go\nsearchAttributes := workflowExecution.GetSearchAttributes()\nvar builder strings.Builder\nfor k, v := range searchAttributes.GetIndexedFields() {\n    var currentVal interface{}\n    err := converter.GetDefaultDataConverter().FromPayload(v, &currentVal)\n    if err != nil {\n        logger.Error(fmt.Sprintf(\"Get search attribute for key %s failed.\", k), \"Error\", err)\n        return err\n    }\n    builder.WriteString(fmt.Sprintf(\"%s=%v\\n\", k, currentVal))\n}\n```\n\n## Testing Search Attributes\n\nThe Go SDK's test suite comes with corresponding methods for mocking and asserting these operations:\n\n```go\nfunc Test_Workflow(t *testing.T) {\n\ttestSuite := &testsuite.WorkflowTestSuite{}\n\tenv := testSuite.NewTestWorkflowEnvironment()\n\tenv.RegisterActivity(ListExecutions)\n\n\t// mock search attributes on start\n\t_ = env.SetSearchAttributesOnStart(map[string]interface{}{\"CustomIntField\": 1})\n\n\t// mock upsert operations\n\tattributes := map[string]interface{}{\n\t\t\"CustomIntField\":      2, // update CustomIntField from 1 to 2, then insert other fields\n\t\t\"CustomKeywordField\":  \"Update1\",\n\t\t\"CustomBoolField\":     true,\n\t\t\"CustomDoubleField\":   3.14,\n\t\t\"CustomDatetimeField\": env.Now().UTC(),\n\t\t\"CustomStringField\":   \"String field is for text. When query, it will be tokenized for partial match. StringTypeField cannot be used in Order By\",\n\t}\n\tenv.OnUpsertSearchAttributes(attributes).Return(nil).Once()\n\n\tattributes = map[string]interface{}{\n\t\t\"CustomKeywordField\": \"Update2\",\n\t}\n\tenv.OnUpsertSearchAttributes(attributes).Return(nil).Once()\n\n\t// mock activity\n\tenv.OnActivity(ListExecutions, mock.Anything, mock.Anything).Return([]*workflowpb.WorkflowExecutionInfo{{}}, nil).Once()\n\n\tenv.ExecuteWorkflow(SearchAttributesWorkflow)\n\trequire.True(t, env.IsWorkflowCompleted())\n\trequire.NoError(t, env.GetWorkflowError())\n}\n```\n\n## Full Search Attributes example code\n\nYou can find full example Search Attributes sample code [in the Temporal `samples-go` repo](https://github.com/temporalio/samples-go/tree/master/searchattributes).\n","is_empty":false},{"file_name":"selectors.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/selectors.md","id":259,"title":"Go SDK Selectors","label":"Selectors","markdown_content":"\n## Overview\n\nIn Go, the `select` statement lets a goroutine wait on multiple communication operations.\nA `select` **blocks until one of its cases can run**, then it executes that case.\nIt chooses one at random if multiple are ready.\n\nHowever, a normal Go select statement can not be used inside of Workflows directly because of the random nature.\nTemporal's Go SDK `Selector`s are similar and act as a replacement.\nThey can block on sending and receiving from Channels but as a bonus can listen on Future deferred work.\nUsage of Selectors to defer and process work (in place of Go's `select`) are necessary in order to ensure deterministic Workflow code execution (though using `select` in Activity code is fine).\n\n## Full API Example\n\nThe API is sufficiently different from `select` that it bears documenting:\n\n```go\nfunc SampleWorkflow(ctx workflow.Context) error {\n\t// standard Workflow setup code omitted...\n\n\t// API Example: declare a new selector\n\tselector := workflow.NewSelector(ctx)\n\n\t// API Example: defer code execution until the Future that represents Activity result is ready\n\twork := workflow.ExecuteActivity(ctx, ExampleActivity)\n\tselector.AddFuture(work, func(f workflow.Future) {\n\t\t// deferred code omitted...\n\t})\n\n\t// more parallel timers and activities initiated...\n\n\t// API Example: receive information from a Channel\n\tvar signalVal string\n\tchannel := workflow.GetSignalChannel(ctx, channelName)\n\tselector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {\n\t\t// matching on the channel doesn't consume the message.\n\t \t// So it has to be explicitly consumed here\n\t\tc.Receive(ctx, &signalVal)\n\t\t// do something with received information\n\t})\n\n\t// API Example: block until the next Future is ready to run\n\t// important! none of the deferred code runs until you call selector.Select\n\tselector.Select(ctx)\n\n\t// Todo: document selector.HasPending\n}\n```\n\n## Using Selectors with Futures\n\nYou usually add `Future`s after `Activities`:\n\n```go\n\t// API Example: defer code execution until after an activity is done\n\twork := workflow.ExecuteActivity(ctx, ExampleActivity)\n\tselector.AddFuture(work, func(f workflow.Future) {\n\t\t// deferred code omitted...\n\t})\n```\n\n`selector.Select(ctx)` is the primary mechanism which blocks on and executes `Future` work.\nIt is intentionally flexible; you may call it conditionally or multiple times:\n\n```go\n\t// API Example: blocking conditionally\n  if somecondition != nil {\n\t\tselector.Select(ctx)\n  }\n\n\t// API Example: popping off all remaining Futures\n  for i := 0; i < len(someArray); i++ {\n\t\tselector.Select(ctx) // this will wait for one branch\n\t\t// you can interrupt execution here\n\t}\n```\n\nA Future matches only once per Selector instance even if Select is called multiple times.\nIf multiple items are available, the order of matching is not defined.\n\n### Using Selectors with Timers\n\nAn important use case of futures is setting up a race between a timer and a pending activity, effectively adding a \"soft\" timeout that doesn't result in any errors or retries of that activity.\n\nFor example, [the Timer sample](https://github.com/temporalio/samples-go/blob/master/timer) shows how you can write a long running order processing operation where:\n\n- if processing takes too long, we send out a notification email to user about the delay, but we won't cancel the operation\n- if the operation finishes before the timer fires, then we want to cancel the timer.\n\n```go\nvar processingDone bool\nf := workflow.ExecuteActivity(ctx, OrderProcessingActivity)\nselector.AddFuture(f, func(f workflow.Future) {\n\tprocessingDone = true\n\t// cancel timerFuture\n\tcancelHandler()\n})\n\n// use timer future to send notification email if processing takes too long\ntimerFuture := workflow.NewTimer(childCtx, processingTimeThreshold)\nselector.AddFuture(timerFuture, func(f workflow.Future) {\n\tif !processingDone {\n\t\t// processing is not done yet when timer fires, send notification email\n\t\t_ = workflow.ExecuteActivity(ctx, SendEmailActivity).Get(ctx, nil)\n\t}\n})\n\n// wait the timer or the order processing to finish\nselector.Select(ctx)\n```\n\nWe create timers with the `workflow.NewTimer` API.\n\n## Using Selectors with Channels\n\n`selector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {})` is the primary mechanism which receives messages from `Channels`.\n\n```go\n\t// API Example: receive information from a Channel\n\tvar signalVal string\n\tchannel := workflow.GetSignalChannel(ctx, channelName)\n\tselector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {\n\t\tc.Receive(ctx, &signalVal)\n\t\t// do something with received information\n\t})\n```\n\nMerely matching on the channel doesn't consume the message; it has to be explicitly consumed with a `c.Receive(ctx, &signalVal)` call.\n\n## Querying Selector State\n\nYou can use the `selector.HasPending` API to ensure that signals are not lost when a Workflow is closed (e.g. by `ContinueAsNew`).\n\n## Learn More\n\nUsage of Selectors is best learned by example:\n\n- Setting up a race condition between an Activity and a Timer, and conditionally execute ([Timer example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/timer/workflow.go))\n- Receiving information in a Channel ([Mutex example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/mutex/mutex_workflow.go))\n- Looping through a list of work and scheduling them all in parallel ([DSL example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/dsl/workflow.go))\n- Executing activities in parallel, pick the first result, cancel remainder ([Pick First example](https://github.com/temporalio/samples-go/blob/14980b3792cc3a8447318fefe9a73fe0a580d4b9/pickfirst/pickfirst_workflow.go))\n","is_empty":false},{"file_name":"tracing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/tracing.md","id":260,"title":"Tracing and Context Propagation","markdown_content":"\n## Tracing\n\nThe Go SDK provides support for distributed tracing through [OpenTracing](https://opentracing.io/).\nTracing allows you to view the call graph of a Workflow along with its Activities and any child Workflows.\n\nTracing can be configured by providing an [opentracing.Tracer](https://pkg.go.dev/github.com/opentracing/opentracing-go#Tracer)\nimplementation in [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions) during client instantiation.\nFor more details on how to configure and leverage tracing, see the [OpenTracing documentation](https://opentracing.io/docs/getting-started/).\n\nThe OpenTracing support has been validated using [Jaeger](https://www.jaegertracing.io/), but other implementations mentioned [here](https://opentracing.io/docs/supported-tracers/) should also work.\nTracing functionality utilizes generic context propagation provided by the client.\n\n## Context Propagation\n\nTemporal provides a standard way to propagate a custom context across a Workflow.\nYou can configure a context propagator in via the [ClientOptions](https://pkg.go.dev/go.temporal.io/sdk/internal#ClientOptions).\nThe context propagator extracts and passes on information present in `context.Context` and `workflow.Context` objects across the Workflow.\nOnce a context propagator is configured, you should be able to access the required values in the context objects as you would normally do in Go.\nYou can see how the Go SDK implements a [tracing context propagator](https://github.com/temporalio/sdk-go/blob/master/internal/tracer.go).\n\n### Server-Side Headers\n\nOn the server side, Temporal provides a mechanism for propagating context across Workflow transitions called headers.\n\n```proto\nmessage Header {\n    map<string, Payload> fields = 1;\n}\n```\n\n`Client` leverages headers to pass around additional context information.\n[HeaderReader](https://pkg.go.dev/go.temporal.io/sdk/internal#HeaderReader) and [HeaderWriter](https://pkg.go.dev/go.temporal.io/sdk/internal#HeaderWriter) are interfaces that allow reading and writing to the Temporal Server headers.\nThe SDK includes [implementations](https://github.com/temporalio/sdk-go/blob/master/internal/headers.go) for these interfaces.\n`HeaderWriter` sets a value for a header.\nHeaders are held as a map, so setting a value for the same key will overwrite its previous value.\n`HeaderReader` gets a value of a header.\nIt also can iterate through all headers and execute the provided handler function on each header, so that your code can operate on select headers you need.\n\n```go\ntype HeaderWriter interface {\n\tSet(string, *commonpb.Payload)\n}\n\ntype HeaderReader interface {\n\tGet(string) (*commonpb.Payload, bool)\n\tForEachKey(handler func(string, *commonpb.Payload) error) error\n}\n```\n\n### Context Propagators\n\nYou can propagate additional context through Workflow execution by using a context propagator.\nA context propagator needs to implement the `ContextPropagator` interface that includes the following four methods:\n\n```go\ntype ContextPropagator interface {\n  Inject(context.Context, HeaderWriter) error\n\n  Extract(context.Context, HeaderReader) (context.Context, error)\n\n  InjectFromWorkflow(Context, HeaderWriter) error\n\n  ExtractToWorkflow(Context, HeaderReader) (Context, error)\n}\n```\n\n- `Inject` reads select context keys from a Go [context.Context](https://golang.org/pkg/context/#Context) object and writes them into the headers using the [HeaderWriter](https://pkg.go.dev/go.temporal.io/sdk/internal#HeaderWriter) interface.\n- `InjectFromWorkflow` operates similar to `Inject` but reads from a [workflow.Context](https://pkg.go.dev/go.temporal.io/sdk/internal#Context) object.\n- `Extract` picks select headers and put their values into the [context.Context](https://golang.org/pkg/context/#Context) object.\n- `ExtractToWorkflow` operates similar to `Extract` but write to a [workflow.Context](https://pkg.go.dev/go.temporal.io/sdk/internal#Context) object.\n\nThe [tracing context propagator](https://github.com/temporalio/sdk-go/blob/master/internal/tracer.go) shows a sample implementation of a context propagator.\n\n### Is there a complete example?\n\nThe [context propagation sample](https://github.com/temporalio/samples-go/blob/master/ctxpropagation/) configures a custom context propagator and shows context propagation of custom keys across a Workflow and an Activity.\nIt also uses Jaeger for tracing.\n\n### Can I configure multiple context propagators?\n\nYes. Multiple context propagators help to structure code with each propagator having its own scope of responsibility.\n\n## Useful Resources\n\n- [Passing Context with Temporal](https://spiralscout.com/blog/passing-context-with-temporal) by SpiralScout\n","is_empty":false},{"file_name":"versioning.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/versioning.md","id":261,"title":"Versioning","markdown_content":"\nThe definition code of a Temporal Workflow must be deterministic because Temporal uses event sourcing\nto reconstruct the Workflow state by replaying the saved history event data on the Workflow\ndefinition code. This means that any incompatible update to the Workflow definition code could cause\na non-deterministic issue if not handled correctly.\n\n## Introduction to Versioning\n\nBecause we design for potentially long running Workflows at scale, versioning with Temporal works differently. We explain more in this optional 30 minute introduction: [https://www.youtube.com/watch?v=kkP899WxgzY](https://www.youtube.com/watch?v=kkP899WxgzY)\n\n## workflow.GetVersion()\n\nConsider the following Workflow definition:\n\n```go\nfunc YourWorkflow(ctx workflow.Context, data string) (string, error) {\n        ao := workflow.ActivityOptions{\n                ScheduleToStartTimeout: time.Minute,\n                StartToCloseTimeout:    time.Minute,\n        }\n        ctx = workflow.WithActivityOptions(ctx, ao)\n        var result1 string\n        err := workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n        if err != nil {\n                return \"\", err\n        }\n        var result2 string\n        err = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\n        return result2, err\n}\n```\n\nNow let's say we have replaced ActivityA with ActivityC, and deployed the updated code. If there\nis an existing Workflow execution that was started by the original version of the Workflow code, where\nActivityA had already completed and the result was recorded to history, the new version of the Workflow\ncode will pick up that Workflow execution and try to resume from there. However, the Workflow will fail\nbecause the new code expects a result for ActivityC from the history data, but instead it gets the\nresult for ActivityA. This causes the Workflow to fail on the non-deterministic error.\n\nThus we use `workflow.GetVersion().`\n\n```go\nvar err error\nv := workflow.GetVersion(ctx, \"Step1\", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n}\nif err != nil {\n        return \"\", err\n}\n\nvar result2 string\nerr = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\nreturn result2, err\n```\n\nWhen `workflow.GetVersion()` is run for the new Workflow execution, it records a marker in the Workflow\nhistory so that all future calls to `GetVersion` for this change Id--`Step 1` in the example--on this\nWorkflow execution will always return the given version number, which is `1` in the example.\n\nIf you make an additional change, such as replacing ActivityC with ActivityD, you need to\nadd some additional code:\n\n```go\nv := workflow.GetVersion(ctx, \"Step1\", workflow.DefaultVersion, 2)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else if v == 1 {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n```\n\nNote that we have changed `maxSupported` from 1 to 2. A Workflow that had already passed this\n`GetVersion()` call before it was introduced will return `DefaultVersion`. A Workflow that was run\nwith `maxSupported` set to 1, will return 1. New Workflows will return 2.\n\nAfter you are sure that all of the Workflow executions prior to version 1 have completed, you can\nremove the code for that version. It should now look like the following:\n\n```go\nv := workflow.GetVersion(ctx, \"Step1\", 1, 2)\nif v == 1 {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n```\n\nYou'll note that `minSupported` has changed from `DefaultVersion` to `1`. If an older version of the\nWorkflow execution history is replayed on this code, it will fail because the minimum expected version\nis 1. After you are sure that all of the Workflow executions for version 1 have completed, then you\ncan remove 1 so that your code would look like the following:\n\n```go\n_ := workflow.GetVersion(ctx, \"Step1\", 2, 2)\nerr = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n```\n\nNote that we have preserved the call to `GetVersion()`. There are two reasons to preserve this call:\n\n1. This ensures that if there is a Workflow execution still running for an older version, it will\n   fail here and not proceed.\n2. If you need to make additional changes for `Step1`, such as changing ActivityD to ActivityE, you\n   only need to update `maxVersion` from 2 to 3 and branch from there.\n\nYou only need to preserve the first call to `GetVersion()` for each `changeID`. All subsequent calls to\n`GetVersion()` with the same change Id are safe to remove. If necessary, you can remove the first\n`GetVersion()` call, but you need to ensure the following:\n\n- All executions with an older version are completed.\n- You can no longer use `Step1` for the changeId. If you need to make changes to that same part in\n  the future, such as change from ActivityD to ActivityE, you would need to use a different changeId\n  like `Step1-fix2`, and start minVersion from DefaultVersion again. The code would look like the\n  following:\n\n```go\nv := workflow.GetVersion(ctx, \"Step1-fix2\", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityE, data).Get(ctx, &result1)\n}\n```\n\nUpgrading a Workflow is straightforward if you don't need to preserve your currently running\nWorkflow executions. You can simply terminate all of the currently running Workflow executions and\nsuspend new ones from being created while you deploy the new version of your Workflow code, which does\nnot use `GetVersion()`, and then resume Workflow creation. However, that is often not the case, and\nyou need to take care of the currently running Workflow executions, so using `GetVersion()` to update\nyour code is the method to use.\n\nHowever, if you want your currently running Workflows to proceed based on the current Workflow logic,\nbut you want to ensure new Workflows are running on new logic, you can define your Workflow as a\nnew `WorkflowType`, and change your start path (calls to `StartWorkflow()`) to start the new Workflow\ntype.\n\n## Sanity checking\n\nThe Temporal client SDK performs a sanity check to help prevent obvious incompatible changes.\nThe sanity check verifies whether a Command made in replay matches the event recorded in history,\nin the same order. The Command is generated by calling any of the following methods:\n\n- workflow.ExecuteActivity()\n- workflow.ExecuteChildWorkflow()\n- workflow.NewTimer()\n- workflow.RequestCancelWorkflow()\n- workflow.SideEffect()\n- workflow.SignalExternalWorkflow()\n- workflow.Sleep()\n\nAdding, removing, or reordering any of the above methods triggers the sanity check and results in\na non-deterministic error.\n\nThe sanity check does not perform a thorough check. For example, it does not check on the Activity's\ninput arguments or the timer duration. If the check is enforced on every property, then it becomes\ntoo restricted and harder to maintain the Workflow code. For example, if you move your Activity code\nfrom one package to another package, that changes the `ActivityType`, which technically becomes a different\nActivity. But, we don't want to fail on that change, so we only check the function name part of the\n`ActivityType`.\n","is_empty":false},{"file_name":"workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/go/workflows.md","id":262,"title":"Workflows in Go","description":"In the Temporal Go SDK programming model, a Workflow is an exportable function that adheres to a set of rules.","label":"Workflows","markdown_content":"\n### External Workflows\n\nYou can execute Workflows (including those from other language SDKs) by their type name:\n\n```go\n\nworkflowID := \"yourWorkflow_\" + uuid.New()\nworkflowOptions := client.StartWorkflowOptions{\n  ID:        workflowID,\n  TaskQueue: \"mytaskqueue\",\n}\n\nwe, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, \"MySimpleWorkflow\")\nif err != nil {\n  log.Fatalln(\"Unable to execute workflow\", err)\n}\nlog.Println(\"Started workflow\", \"WorkflowID\", we.GetID(), \"RunID\", we.GetRunID())\n```\n\nIn the above example, `client` is imported from the \"go.temporal.io/sdk/client\" package. And `temporalClient` is an instance of the Temporal Client instantiated outside the snippet.\nHere we spawn a Workflow Execution by its Workflow Type name `MySimpleWorkflow`. By default, the\nWorkflow type is the name of the Workflow function, for example:\n\n```go\nfunc MySimpleWorkflow(ctx workflow.Context) error {\n // Workflow code here...\n}\n```\n\nNote that you can also set the Workflow type via `RegisterWorkflowOptions` when registering your Workflow\nwith the Worker, for example:\n\n```go\nrwo := workflow.RegisterOptions {\n   Name: \"YourWorkflow\", // Set \"YourWorkflow\" as the Workflow type\n}\nw.RegisterWorkflowWithOptions(dynamic.SampleGreetingsWorkflow, rwo)\n```\n\n### Querying Workflow State\n\nWhen you start a Workflow with `ExecuteWorkflow`, a `WorkflowExecution` is returned (which is the `we` variable above).\nThe `WorkflowExecution` can be used to get the result or capture the `WorkflowId`.\nYou can retrieve the result of the Workflow **from a completely different process**, as long as you have the `WorkflowId`, by using `client.GetWorkflow`.\n\n```go\nwe = client.GetWorkflow(workflowID)\nvar result string\nwe.Get(ctx, &result)\n```\n\n## How to cancel a Workflow Execution\n\nUse the `CancelWorkflow` API to cancel a Workflow Execution using its Id.\n\n<!--SNIPSTART samples-go-cancellation-cancel-workflow-execution-trigger-->\n<!--SNIPEND-->\n\n### How to clean up after a Workflow is cancelled\n\nWorkflow Definitions can be written to handle execution cancellation requests with Go's `defer` and the `workflow.NewDisconnectedContext` API.\nIn the Workflow Definition below, there is a special Activity that handles clean up should the execution be cancelled.\n\n<!--SNIPSTART samples-go-cancellation-workflow-definition-->\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/activities.md","id":263,"title":"Activities in Java","label":"Activities","markdown_content":"\n## What is an Activity?\n\nActivities are implementations of certain tasks which need to be performed during a Workflow execution.\nThey can be used to interact with external systems, such as databases, services, etc.\n\nWorkflows orchestrate invocations of Activities.\n\nJust like [Workflows](./workflows.md), Activities must be registered with a [Worker](./workers.md).\n\n### Activity interface\n\nSimilar to Workflows, Activities in Temporal Java SDK programming model are classes which implement\nthe ActivityInterface Interface.\n\nActivity Interfaces are Java Interfaces which are annotated with the `@ActivityInterface` annotation:\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    String composeGreeting(String greeting, String language);\n}\n```\n\nEach method defined in the Activity interface defines a separate Activity method.\nYou can annotate each method in the Activity interface with the `@ActivityMethod`\nannotation, but this is completely optional, for example:\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod(name = \"greet\")\n    String composeGreeting(String greeting, String language);\n}\n```\n\nNote that the `@ActivityMethod` annotation has a `name` parameter which can be used to define the Activity type.\nIf it is specified like in the example above the type would be \"greet\".\nIf not specified, the Activity method name (with the first letter capitalized) is used by default, so in the example again it would be `composeGreeting`.\n\n### Activity implementation\n\nAn Activity implementation is Java class which implements an Activity Interface, for example:\n\n```java\n  public class MultiLanguageGreeting implements GreetingsActivities {\n    private final TranslationService translationService;\n\n    public MultiLanguageGreeting(TranslationService translationService) {\n      this.translationService = translationService;\n    }\n\n    @Override\n    public String composeGreeting(String greeting, String language) {\n      return translationService.translate(greeting, language);\n    }\n  }\n```\n\n## Registering Activities with a Worker\n\nJust like Workflows, Activities need to be registered with a Worker, for example:\n\n```java\n    Worker worker = factory.newWorker(TASK_QUEUE);\n    ...\n    // register the Activity\n    worker.registerActivitiesImplementations(new MultiLanguageGreeting(translationService));\n```\n\nNote that when registering Activities, we register an instance of the Activity implementation, and can pass any\nnumber of dependencies in its constructor, such as the database connections, services, etc.\n\n## Invoking Activities inside Workflows\n\nSimilar to Workflows, Activities should only be instantiated via stubs.\n\n`Workflow.newActivityStub` returns a client-side stub that implements an Activity interface.\nIt takes Activity type and Activity options as arguments.\nActivity options allow you to specify different Activity timeout and retry options.\n\nCalling a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if an Activity's execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\nLet's take a look at an example Workflow that calls Activities:\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) {\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    // ...\n}\n```\n\nIn this example we use `Workflow.newActivityStub` to create a client-side stub of our file processing Activity.\nWe also define ActivityOptions and set the setStartToCloseTimeout timeout to one hour, meaning that we set the total execution timeout for each of its method invocations to one hour (from when the Activity execution is started to when it completes).\n\nWorkflow can create multiple Activity stubs. Each activity stub can have its own ActivityOptions defined, for example:\n\n```java\npublic FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue1\")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue2\")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n```\n\n### Invoking Activities Asynchronously\n\nSometimes Workflows need to perform certain operations in parallel.\nThe Temporal Java SDK provides the `Async` class which includes static methods used to invoke any Activity asynchronously.\nThe calls return a result of type `Promise` which is similar to the Java `Future` and `CompletionStage`.\n\nWhen you need to get the results of an async invoked Activity method, you can use the `Promise` `get` method to block until the Activity method result is available.\n\nTo convert the following synchronous Activity method call:\n\n```java\nString localName = activities.download(sourceBucket, sourceFile);\n```\n\nTo asynchronous style, the method reference is passed to `Async.function` or `Async.procedure`\nfollowed by Activity arguments:\n\n```java\nPromise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);\n```\n\nThen to wait synchronously for the result you can do the following:\n\n```java\nString localName = localNamePromise.get();\n```\n\nHere is the above example rewritten to call download and upload Activity methods in parallel, on multiple files:\n\n```java\n  public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n      // Download all files in parallel.\n      for (String sourceFilename : args.getSourceFilenames()) {\n        Promise<String> localName =\n            Async.function(activities::download, args.getSourceBucketName(), sourceFilename);\n        localNamePromises.add(localName);\n      }\n      List<String> localNames = new ArrayList<>();\n      for (Promise<String> localName : localNamePromises) {\n        localNames.add(localName.get());\n      }\n      processedNames = activities.processFiles(localNames);\n\n      // Upload all results in parallel.\n      List<Promise<Void>> uploadedList = new ArrayList<>();\n      for (String processedName : processedNames) {\n        Promise<Void> uploaded =\n            Async.procedure(\n                activities::upload,\n                args.getTargetBucketName(),\n                args.getTargetFilename(),\n                processedName);\n        uploadedList.add(uploaded);\n      }\n      // Wait for all uploads to complete.\n      Promise.allOf(uploadedList).get();\n    } finally {\n      for (Promise<String> localNamePromise : localNamePromises) {\n        // Skip files that haven't completed downloading.\n        if (localNamePromise.isCompleted()) {\n          activities.deleteLocalFile(localNamePromise.get());\n        }\n      }\n      if (processedNames != null) {\n        for (String processedName : processedNames) {\n          activities.deleteLocalFile(processedName);\n        }\n      }\n    }\n  }\n```\n\n## Invoking Activities via `Workflow.newUntypedActivityStub`\n\nIt is also possible to invoke Activities inside Workflows using `Workflow.newUntypedActivityStub`, meaning you can\ninvoke them without referencing an interface it implements.\nThis is useful in scenarios where the Activity type is not known at compile time, or to invoke\nActivities implemented in different programming languages.\n\n```java\n   // Workflow code\n    ActivityOptions activityOptions =\n        ActivityOptions.newBuilder()\n        .setStartToCloseTimeout(Duration.ofSeconds(3))\n        .setTaskQueue(\"simple-queue-node\")\n        .build();\n\n    ActivityStub activity = Workflow.newUntypedActivityStub(activityOptions);\n    activity.execute(\"ComposeGreeting\", String.class, \"Hello World\" , \"Spanish\");\n```\n\n## Activity Execution Context\n\n`ActivityExecutionContext` is a context object passed to each Activity implementation by default.\nYou can access it in your Activity implementations via `Activity.getExecutionContext()`.\n\nIt provides getters to access information about the Workflow that invoked the Activity.\nNote that the Activity context information is stored in a thread-local variable.\nTherefore, calls to `getExecutionContext()` succeed only within the thread that invoked the Activity function.\n\nFollowing is an example of using the `ActivityExecutionContext`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n    ActivityInfo info = ctx.getInfo();\n\n    log.info(\"namespace=\" +  info.getActivityNamespace());\n    log.info(\"workflowId=\" + info.getWorkflowId());\n    log.info(\"runId=\" + info.getRunId());\n    log.info(\"activityId=\" + info.getActivityId());\n    log.info(\"activityTimeout=\" + info.getStartToCloseTimeoutSeconds());\n\n    return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n  }\n    ...\n}\n```\n\n## Asynchronous Activity Completion\n\nSometimes an Activity lifecycle goes beyond a synchronous method invocation.\nFor example, a request can be put in a queue and later a reply comes and is picked up by a different Worker process.\nThe whole request-reply interaction can be modeled as a single Activity.\n\nTo indicate that an Activity should not be completed upon its method return, call `ActivityExecutionContext.doNotCompleteOnReturn()` from the original Activity thread.\n\nThen later, when replies come, complete the Activity using the `ActivityCompletionClient`.\nTo correlate Activity invocation with completion use either a `TaskToken` or Workflow and Activity IDs.\n\nFollowing is an example of using `ActivityExecutionContext.doNotCompleteOnReturn()`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n\n    // Used to correlate reply\n    byte[] taskToken = ctx.getInfo().getTaskToken();\n    asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n    ctx.doNotCompleteOnReturn();\n\n    // Return value is ignored when doNotCompleteOnReturn was called.\n    return \"ignored\";\n  }\n  ...\n}\n```\n\nWhen the download is complete, the download service potentially can complete the Activity, or fail it from a different process, for example:\n\n```java\n  public <R> void completeActivity(byte[] taskToken, R result) {\n    completionClient.complete(taskToken, result);\n  }\n\n  public void failActivity(byte[] taskToken, Exception failure) {\n    completionClient.completeExceptionally(taskToken, failure);\n  }\n```\n\n## Activity heartbeats\n\nActivities can be long-running.\nIn these cases the Activity execution timeouts should be set to be longer than the maximum predicted time of the Activity execution.\nIn those cases it can happen that an Activity execution is started and cannot proceed, or fails to continue its execution for some reasons.\nWith our long set execution timeout the calling Workflow will not be able to time out the Activity and retry it or fail it until this timeout is reached.\n\nIn order to react quickly to crashes of long-running Activities you can use the Activity heartbeat mechanism.\nYou can set a short heartbeat timeout in order to detect Activity issues and react to them without having to wait for the long Activity execution timeout to complete first.\n\n`Activity.getExecutionContext().heartbeat()` lets the Temporal service know that the Activity is still alive.\n\nThe `Activity.getExecutionContext().heartbeat()` can take an argument which represents heartbeat\n`details`.\nIf an Activity times out, the last heartbeat `details` will be included in the thrown `ActivityTimeoutException` which can be caught by the calling Workflow.\nThe Workflow then can use the `details` information to pass to the next Activity invocation if needed.\n\nIn the case of Activity retries, the last Heartbeat's `details` are available and can be extracted from the last fail attempt using `Activity.getExecutionContext().getHeartbeatDetails(Class<V> detailsClass)`\n\nFollowing is an example of using Activity heartbeat:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n    InputStream inputStream = openInputStream(file);\n    try {\n      byte[] bytes = new byte[MAX_BUFFER_SIZE];\n      while ((read = inputStream.read(bytes)) != -1) {\n        totalRead += read;\n        f.write(bytes, 0, read);\n        // Let the Server know about the download progress.\n        Activity.getExecutionContext().heartbeat(totalRead);\n      }\n    } finally{\n      inputStream.close();\n    }\n  }\n  ...\n}\n```\n\n## Throwing Activity errors\n\nIf there is a need to throw checked Exception from Activity methods which do not support re-throwing checked Exceptions in their signatures,\nyou should wrap them using the `Activity.wrap` method and re-throw the Exceptions.\n\nThere is no need to wrap unchecked Exceptions, but it's safe to do so if you want to.\n\nIn addition, when wrapping checked Exceptions, the original Exception is attached as a cause to the wrapped one, and is not lost.\n\nHere is an example of catching a checked Exception and wrapping it:\n\n```java\ntry {\n  return someCall();\n} catch (Exception e) {\n  throw Activity.wrap(e);\n}\n```\n\nNote that any Exception thrown from an Activity is converted to `io.temporal.failure.ApplicationFailure`, unless the thrown Exception extends `io.temporal.failure.TemporalException` .\n","is_empty":false},{"file_name":"api-reference-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/api-reference-java.md","id":264,"title":"API reference","label":"API reference","markdown_content":"\nThe Temporal Java SDK API reference is published on [javadoc.io](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/index.html).\n","is_empty":false},{"file_name":"code-samples-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/code-samples-java.md","id":265,"title":"Code samples","label":"Code samples","markdown_content":"\n- [Java samples library](https://github.com/temporalio/samples-java)\n- [Hello world application template in Java](https://github.com/temporalio/hello-world-project-template-java): Provides a quick-start development app for users.\n  Works in conjunction with the [\"Hello World!\" from scratch tutorial in Java](https://learn.temporal.io/getting_started/java/hello_world_in_java/).\n- [Money transfer application template in Java](https://github.com/temporalio/money-transfer-project-template-java): Provides a quick-start development app for users.\n  It demonstrates a basic \"money transfer\" Workflow Definition and works in conjunction with the [Run your first app tutorial in Java](https://learn.temporal.io/getting_started/java/first_program_in_java/).\n- [Subscription-style Workflow Definition in Java](https://github.com/temporalio/subscription-workflow-project-template-java): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n","is_empty":false},{"file_name":"distributed-cron.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/distributed-cron.md","id":266,"title":"Distributed CRON","markdown_content":"\n<!-- prettier-ignore -->\nimport * as WhatIsATemporalCronJob from '../concepts/what-is-a-temporal-cron-job.md'\n\nThis is how you set a cron schedule in Java:\n\n```java\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder()\n            .setWorkflowId(WORKFLOW_ID)\n            .setTaskQueue(TASK_QUEUE)\n            .setCronSchedule(\"* * * * *\")\n            .setWorkflowExecutionTimeout(Duration.ofMinutes(3))\n            .setWorkflowRunTimeout(Duration.ofMinutes(1))\n            .build();\n\n    // Create the workflow client stub. It is used to start our workflow execution.\n    GreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);\n```\n\nSetting `setCronSchedule` turns the Workflow Execution into a <preview page={WhatIsATemporalCronJob}>Temporal Cron Job</preview>\n\nYou can check our [Java samples](https://github.com/temporalio/samples-java/blob/master/src/main/java/io/temporal/samples/hello/HelloCron.java) for example code.\n\nJava SDK `workflowOptions` source code: https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.html\n\n## Retrieve last successful result\n\nSometimes it is useful to obtain the progress of previous successful runs.\nThis is supported by one new APIs in the Java SDK:\n`GetLastCompletionResult`. The method returns null if there is no previous completion. Below is an example of how\nto use this in Java:\n\n```java\npublic String cronWorkflow() {\n    String lastProcessedFileName = Workflow.getLastCompletionResult(String.class);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the cron schedule runs failed. The\nnext schedule will still get the last successful result if it ever successfully\ncompleted at least once. For example, for a daily cron Workflow, if the first day\nrun succeeds and the second day fails, then the third day run will still get\nthe result from first day's run using these APIs.\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-continue-as-new-in-java.md","id":267,"title":"How to Continue-As-New in Java","description":"To cause a Workflow to Continue-As-New, use `Workflow.continueAsNew()`.","label":"Continue-As-New","tags":["java","developer-guide"],"markdown_content":"\nTemporal SDK allows you to use [Continue-As-New](/concepts/what-is-continue-as-new) in various ways.\n\nTo continue execution of the same Workflow that is currently running, use:\n\n```java\nWorkflow.continueAsNew(input1, ...);\n```\n\nTo continue execution of a currently running Workflow as a completely different Workflow type, use `Workflow.newContinueAsNewStub()`.\nFor example, in a Workflow class called `YourWorkflow`, we can create a Workflow stub with a different type, and call its Workflow method to continue execution as that type:\n\n```java\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class);\nconinueAsNew.greet(input);\n```\n\nTo provide `ContinueAsNewOptions` options in `Workflow.newContinueAsNewStub()` use:\n\n```java\nContinueAsNewOptions options = ContinueAsNewOptions.newBuilder()\n        .setTaskQueue(\"newTaskQueueName\")\n        .build();\n\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class, options);\n// ...\ncontinueAsNew.greet(input);\n```\n\nProviding these options allows you to continue Workflow Execution as a new Workflow run, with a different Workflow Type, and on a different Task Queue.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-create-a-temporal-client-in-java.md","id":268,"title":"How to create a Temporal Client in Java","description":"To initialize a Workflow Client, create an instance of a `WorkflowClient`, create a client-side `WorkflowStub`, and then call a Workflow method (annotated with the `@WorkflowMethod` annotation).","label":"Temporal Client","tags":["java","developer-guide"],"markdown_content":"\nTo initialize a Workflow Client, create an instance of a `WorkflowClient`, create a client-side `WorkflowStub`, and then call a Workflow method (annotated with `@WorkflowMethod`).\n\nTo start a Workflow Execution, your Temporal Server must be running, and your front-end service must be accepting gRPC calls.\n\nTo establish a connection with the front-end service, use `WorkflowServiceStubs`.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n```\n\nYou can provide `WorkflowServiceStubsOptions` to override the default values for the gRPC calls.\n\nFor example, the default front-end service gRPC address is set to `127.0.0.1:7233`, where `7233` is the default port for the Temporal Frontend Service.\n\nIf your server is running on a different host or port from the default, you can set it as shown in the following example.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newInstance(\n                    WorkflowServiceStubsOptions.newBuilder()\n                     .setTarget(TARGET_ENDPOINT)\n                            .build());\n\n```\n\nAfter the connection to the Temporal Frontend Service is established, create a Client for the service stub.\nThe Workflow Client helps with client-side APIs and is required by Workers.\n\nCreate an instance of a `WorkflowClient` for the Workflow service stub, and use `WorkflowClientOptions` to set options for the Workflow Client.\nThe following example shows how to create a `WorkflowClient` instance called \"client\" for the `WorkflowServiceStubs` \"service\" that we created in the previous example, and set `Namespace` option for the `WorkflowClient`.\n\n```java\nWorkflowClient client = WorkflowClient.newInstance(\n                service,\n                WorkflowClientOptions.newBuilder()\n                        .setNamespace(“Abc”)\n                    .build());\n\n```\n\nFor more information, see [WorkflowClientOptions](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowClientOptions.Builder.html).\n\n`WorkflowService` and `WorkflowClient` creation is a heavyweight operation, and will be resource-intensive if created each time you start a Workflow or send a Signal to it.\nThe recommended way is to create them once and reuse where possible.\n\nWith the Client defined, you can start interacting with the Temporal Frontend Service.\n\nTo initialize a Workflow in the Client, create a `WorkflowStub`, and start the Workflow Execution with `WorkflowClient.start()`.\nStarting Workflows or sending Signals or Queries to Workflows from within a Client must be done using `WorkflowStubs`.\n\n```java\nWorkflowClient workflowClient =  WorkflowClient.newInstance(service, clientOptions);\n // Create a Workflow stub.\n YourWorkflow workflow = workflowClient.newWorkflowStub(YourWorkflow.class);\n // Start Workflow asynchronously and call its \"yourWFMethod\" Workflow method\n WorkflowClient.start(workflow::yourWFMethod);\n```\n\nFor more information, see the following:\n\n- [How to spawn a Workflow Execution in Java](/java/how-to-spawn-a-workflow-execution-in-java)\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-customize-activity-type-in-java.md","id":269,"title":"How to customize Activity Type in Java","description":"The Activity Type defaults to method name with the first letter of the method name capitalized, and can be customized using `namePrefix()` or `{ActivityMethod.name()}` to ensure they are distinct.","label":"Customize Activity Type","tags":["developer-guide","java"],"markdown_content":"\nThe Activity Type defaults to method name, with the first letter of the method name capitalized, and can be customized using `namePrefix()` or `{ActivityMethod.name()}` to ensure they are distinct.\n\nIn the following example, the Activity Type defaults to `ComposeGreeting`.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nTo overwrite this default naming and assign a custom Activity Type, use the `@ActivityMethod` annotation with the `name` parameter.\nIn the following example, the Activity Type is set to \"greet\".\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod(name = \"greet\")\n    String composeGreeting(String greeting, String language);\n}\n```\n\nYou can also define a prefix for all of your Activity Types using the `namePrefix` parameter with the `@ActivityInterface` annotation.\nThe following example shows a `namePrefix` parameter applied to the `@ActivityInterface`, and two Activity methods, of which one is defined using the `@ActivityMethod` annotation.\n\n```java\n@ActivityInterface(namePrefix = \"A_\")\nPublic interface GreetingActivities {\n    String sendGreeting(String input);\n\n  @ActivityMethod(name = \"abc\")\n  String composeGreeting(String greeting, String language);\n}\n```\n\nIn this example, the Activity type for the first method is set to `A_SendGreeting`.\nThe Activity type for the method annotated with `@ActivityMethod` is set to `A_abc`.\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-customize-workflow-type-in-java.md","id":270,"title":"How to customize Workflow Type in Java","description":"The Workflow Type defaults to the short name of the Workflow interface, and can be customized with the `name` parameter.","label":"Customize Workflow Type","tags":["developer-guide","java"],"markdown_content":"\nThe Workflow Type defaults to the short name of the Workflow interface.\nIn the following example, the Workflow Type defaults to `NotifyUserAccounts`.\n\n```java\n  @WorkflowInterface\n\n  public interface NotifyUserAccounts {\n    @WorkflowMethod\n    void notify(String[] accountIds);\n}\n```\n\nTo overwrite this default naming and assign a custom Workflow Type, use the `@WorkflowMethod` annotation with the `name` parameter.\nIn the following example, the Workflow Type is set to `Abc`.\n\n```java\n@WorkflowInterface\n\n  public interface NotifyUserAccounts {\n  @WorkflowMethod(name = \"Abc\")\n  void notify(String[] accountIds);\n  }\n```\n\nWhen you set the Workflow Type this way, the value of the `name` parameter does not have to start with an uppercase letter.\n","is_empty":false},{"file_name":"how-to-define-a-query-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-define-a-query-in-java.md","id":271,"title":"How to define a Query in Java","description":"Create a Query handler using the `@QueryMethod` annotation in the Workflow interface.","label":"Define Query","tags":["java","developer-guide"],"markdown_content":"\nTo define a Query, define the method name and the result type of the Query.\n\n```java\nquery(String queryType, Class<R> resultClass, Type resultType, Object... args);\n\n  /* @param queryType name of the Query handler. Usually it is a method name.\n   * @param resultClass class of the Query result type\n   * @param args optional Query arguments\n   * @param <R> type of the Query result\n  */\n```\n\nQuery methods can take in any number of input parameters which can be used to limit the data that is returned.\n\nUse the Query method names to send and receive Queries.\n\nQuery methods must never change any Workflow state including starting Activities or blocking threads in any way.\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-define-a-signal-in-java.md","id":272,"title":"How to define Signals in Java","description":"Define a Signal method with `@SignalMethod` annotation in the Workflow interface.","label":"Define Signal","tags":["java","developer-guide"],"markdown_content":"\nThe `@SignalMethod` annotation indicates that the method is used to handle and react to external Signals.\n\n```java\n @SignalMethod\n    void mySignal(String signalName);\n```\n\nThe method can have parameters that contain the Signal payload and must be serializable by the default Jackson JSON Payload Converter.\n\n```java\nvoid mySignal(String signalName, Object... args);\n```\n\nThis method does not return a value and must have a `void` return type.\n\nThings to consider when defining Signals:\n\n- Use Workflow object constructors and initialization blocks to initialize the internal data structures if possible.\n- Signals might be received by a Workflow before the Workflow method is executed.\n  When implementing Signals in scenarios where this can occur, assume that no parts of Workflow code ran.\n  In some cases, Signal method implementation might require some initialization to be performed by the Workflow method code first—for example, when the Signal processing depends on, and is defined by the Workflow input.\n  In this case, you can use a flag to determine whether the Workflow method is already triggered; if not, persist the Signal data into a collection for delayed processing by the Workflow method.\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-define-activity-parameters-in-java.md","id":273,"title":"How to define Activity paramters in Java","description":"An Activity interface can have any number of parameters.","label":"Activity parameters","tags":["developer-guide","java"],"markdown_content":"\nAn Activity interface can have any number of parameters.\nAll inputs should be serializable by the default Jackson JSON Payload Converter.\n\nWhen implementing Activities, be mindful of the amount of data that you transfer using the Activity invocation parameters or return values as these are recorded in the Workflow Execution Events History.\nLarge Events Histories can adversely impact performance.\n\nYou can create a custom object, and pass it to the Activity interface, as shown in the following example.\n\n```java\n@ActivityInterface\npublic interface YourActivities {\n    String getCustomObject(CustomObj customobj);\n    void sendCustomObject(CustomObj customobj, String abc);\n}\n```\n\nThe `execute` method in the dynamic Activity interface implementation takes in `EncodedValues` that are inputs to the Activity Execution, as shown in the following example.\n\n```java\n // Dynamic Activity implementation\n  public static class DynamicActivityImpl implements DynamicActivity {\n    @Override\n    public Object execute(EncodedValues args) {\n      String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n      return activityType\n          + \": \"\n          + args.get(0, String.class)\n          + \" \"\n          + args.get(1, String.class)\n          + \" from: \"\n          + args.get(2, String.class);\n    }\n  }\n```\n\nFor more details, see [Dynamic Activity Reference](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/DynamicActivity.html).\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-define-activity-return-values-in-java.md","id":274,"title":"How to define Activity return values in Java","description":"Activity return values must be serializable and deserializable by the provided `DataConverter`","label":"Activity return values","tags":["developer-guide","java"],"markdown_content":"\nActivity return values must be serializable and deserializable by the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.11.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicActivity` can return type Object.\nEnsure that your Workflow or Client can handle an Object type return or is able to convert the Object type response.\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-define-workflow-parameters-in-java.md","id":275,"title":"How to define Workflow Parameters in Java","description":"A method annotated with `@WorkflowMethod` can have any number of parameters.","label":"Workflow parameters","tags":["developer-guide","java"],"markdown_content":"\nA method annotated with `@WorkflowMethod` can have any number of parameters.\n\nWe recommend passing a single parameter that contains all the input fields to allow for adding fields in a backward-compatible manner.\n\nNote that all inputs should be serializable by the default Jackson JSON Payload Converter.\n\nYou can create a custom object and pass it to the Workflow method, as shown in the following example.\n\n```java\n//...\n@WorkflowInterface\npublic interface YourWorkflow {\n    @WorkflowMethod\n    String yourWFMethod(CustomObj customobj);\n// ...\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-define-workflow-return-values-in-java.md","id":276,"title":"How to define Workflow return values in Java","description":"Workflow method arguments and return values must be serializable and deserializable using the provided `DataConverter`.","label":"Workflow return values","tags":["developer-guide","java"],"markdown_content":"\nWorkflow method arguments and return values must be serializable and deserializable using the provided [`DataConverter`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.11.0/io/temporal/common/converter/DataConverter.html).\n\nThe `execute` method for `DynamicWorkflow` can return type Object.\nEnsure that your Client can handle an Object type return or is able to convert the Object type response.\n\nRelated references:\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n- Java DataConverter reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html>\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-develop-a-worker-program-in-java.md","id":277,"title":"How to develop a Worker Program in Java","description":"Use the `newWorker` method on an instance of a `WorkerFactory` to create a new Worker in Java.","tags":["developer-guide","java","workers"],"markdown_content":"\nUse the `newWorker` method on an instance of a [`WorkerFactory`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/worker/WorkerFactory.html) to create a new Worker in Java.\n\nA single Worker Entity can contain many Worker Objects.\nCall the `start()` method on the instance of the `WorkerFactory` to start all the Workers created in this process.\n\n```java\n// ...\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.serviceclient.WorkflowServiceStubs;\nimport io.temporal.worker.Worker;\nimport io.temporal.worker.WorkerFactory;\n\npublic class YourWorker {\n\n  public static void main(String[] args) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker yourWorker = factory.newWorker(\"your_task_queue\");\n\n    // Register Workflow\n    // and/or register Activities\n\n    factory.start();\n  }\n}\n```\n\nAfter creating the Worker entity, register all Workflow Types and all Activity Types that the Worker can execute.\nA Worker can be registered with just Workflows, just Activities, or both.\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-develop-a-workflow-definition-in-java.md","id":278,"title":"How to develop a Workflow Definition in Java","description":"In the Temporal Java SDK programming model, a Workflow is a class which implements a Workflow interface.","label":"Workflow Definition","tags":["java","developer-guide"],"markdown_content":"\nIn the Temporal Java SDK programming model, a Workflow definition comprises a Workflow interface annotated with `@WorkflowInterface` and a Workflow implementation that implements the Workflow interface.\n\nThe Workflow interface is a Java interface and is annotated with `@WorkflowInterface`.\nEach Workflow interface must have only one method annotated with `@WorkflowMethod`.\nThe method name can be used to denote the Workflow Type.\n\n```java\n// Workflow interface\n@WorkflowInterface\npublic interface YourWorkflow {\n\n    @WorkflowMethod\n    String yourWFMethod(Arguments args);\n}\n```\n\nHowever, when using dynamic Workflows, do not specify a `@WorkflowMethod`, and implement the `DynamicWorkflow` directly in the Workflow implementation code.\n\nThe `@WorkflowMethod` identifies the method that is the starting point of the Workflow Execution.\nThe Workflow Execution completes when this method completes.\n\nYou can create interface inheritance hierarchies to reuse components across other Workflow interfaces.\nThe interface inheritance approach does not apply to `@WorkflowMethod` annotations.\n\nA Workflow implementation implements a Workflow interface.\n\n```java\n// Define the Workflow implementation which implements our getGreeting Workflow method.\n  public static class GreetingWorkflowImpl implements GreetingWorkflow {\n      ...\n    }\n  }\n```\n\nTo call Activities in your Workflow, call the Activity implementation.\n\nUse `ExternalWorkflowStub` to start or send Signals from within a Workflow to other running Workflow Executions.\n\nYou can also invoke other Workflows as Child Workflows with `Workflow.newChildWorkflowStub()` or `Workflow.newUntypedChildWorkflowStub()` within a Workflow Definition.\n\nUse [`DynamicWorkflow`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/DynamicWorkflow.html) to implement Workflow Types dynamically.\nRegister a Workflow implementation type that extends `DynamicWorkflow` to implement any Workflow Type that is not explicitly registered with the Worker.\n\nThe dynamic Workflow interface is implemented with the `execute` method. This method takes in `EncodedValues` that are inputs to the Workflow Execution.\nThese inputs can be specified by the Client when invoking the Workflow Execution.\n\n```java\npublic class MyDynamicWorkflow implements DynamicWorkflow {\n   @Override\n    public Object execute(EncodedValues args) {\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-develop-a-workflow-in-java.md","id":279,"title":"How to develop a Workflow in Java","description":"In the Temporal Java SDK programming model, a Workflow is a class which implements a Workflow interface.","label":"Workflow Development","tags":["developer-guide","java"],"markdown_content":"\nimport WorkflowDefinition from './how-to-develop-a-workflow-definition-in-java.md'\n\n<WorkflowDefinition/>\n\n### Customize Workflow Type\n\nimport CustomizeWorkflowType from './how-to-customize-workflow-type-in-java.md'\n\n<CustomizeWorkflowType/>\n\n### Parameters\n\nimport WorkflowParameters from './how-to-define-workflow-parameters-in-java.md'\n\n<WorkflowParameters/>\n\n### Return values\n\nimport WorkflowReturn from './how-to-define-workflow-return-values-in-java.md'\n\n<WorkflowReturn/>\n\n### Logic requirements\n\nimport LogicRequirements from './how-to-handle-workflow-logic-requirements-in-java.md'\n\n<LogicRequirements/>\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-develop-an-activity-definition-in-java.md","id":280,"title":"How to develop an Activity Definition in Java","description":"In the Temporal Java SDK programming model, Activities are classes which implement the Activity Interface.","label":"Activity Definition","tags":["java","developer-guide"],"markdown_content":"\nAn [Activity Definition](/concepts/what-is-an-activity) is a combination of the Temporal Java SDK [Activity](https://www.javadoc.io/static/io.temporal/temporal-sdk/0.19.0/io/temporal/activity/Activity.html) Class implementing a specially annotated interface.\n\nAn Activity interface is annotated with `@ActivityInterface` and an Activity implementation implements this Activity interface.\nTo handle Activity types that do not have an explicitly registered handler, you can directly implement a dynamic Activity.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    String composeGreeting(String greeting, String language);\n}\n```\n\nEach method defined in the Activity interface defines a separate Activity method.\nYou can annotate each method in the Activity interface with the `@ActivityMethod` annotation, but this is completely optional.\nThe following example uses the `@ActivityMethod` annotation for the method defined in the previous example.\n\n```java\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\nAn Activity implementation is a Java class that implements an Activity annotated interface.\n\n```java\n// Implementation for the GreetingActivities interface example from in the previous section\n static class GreetingActivitiesImpl implements GreetingActivities {\n    @Override\n    public String composeGreeting(String greeting, String name) {\n      return greeting + \" \" + name + \"!\";\n    }\n  }\n```\n\nUse `DynamicActivity` to implement any number of Activity types dynamically.\nWhen an Activity implementation that extends `DynamicActivity` is registered, it is called for any Activity type invocation that doesn't have an explicitly registered handler.\n\nThe dynamic Activity interface is implemented with the `execute` method, as shown in the following example.\n\n```java\n // Dynamic Activity implementation\n  public static class DynamicGreetingActivityImpl implements DynamicActivity {\n    @Override\n    public Object execute(EncodedValues args) {\n      String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n      return activityType\n          + \": \"\n          + args.get(0, String.class)\n          + \" \"\n          + args.get(1, String.class)\n          + \" from: \"\n          + args.get(2, String.class);\n    }\n  }\n```\n\nUse `Activity.getExecutionContext()` to get information about the Activity type that should be implemented dynamically.\n","is_empty":false},{"file_name":"how-to-develop-an-activity-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-develop-an-activity-in-java.md","id":281,"title":"How to develop an Activity in Java","description":"In the Temporal Java SDK programming model, Activities are classes which implement the Activity Interface.","label":"Activity Development","tags":["developer-guide","java"],"markdown_content":"\nimport ActivityDefinition from './how-to-develop-an-activity-definition-in-java.md'\n\n<ActivityDefinition/>\n\n### Customize Activity Type\n\nimport CustomizeActivityType from './how-to-customize-activity-type-in-java.md'\n\n<CustomizeActivityType/>\n\n### Parameters\n\nimport ActivityParameters from './how-to-define-activity-parameters-in-java.md'\n\n<ActivityParameters/>\n\n### Return values\n\nimport ActivityReturnValues from './how-to-define-activity-return-values-in-java.md'\n\n<ActivityReturnValues/>\n","is_empty":false},{"file_name":"how-to-emit-metrics-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-emit-metrics-in-java.md","id":282,"title":"How to emit metrics in Java","description":"To emit metrics with the Java SDK, use `WorkflowServiceStubsOptions.Builder.setMetricsScope` to set the metrics scope in your Worker or Client code.","label":"Emit metrics","tags":["developer-guide","java"],"markdown_content":"\nTo emit metrics with the Java SDK, use [`MicrometerClientStatsReporter`](https://github.com/temporalio/sdk-java/blob/55ee7894aec427d7e384c3519732bdd61119961a/src/main/java/io/temporal/common/reporter/MicrometerClientStatsReporter.java#L34) class to integrate with Micrometer MeterRegistry configured for your metrics backend.\n[Micrometer](https://micrometer.io/docs) is a popular Java framework that provides integration with Prometheus and other backends.\n\nThe following example shows how to use `MicrometerClientStatsReporter` to define the metrics scope and set it with the `WorkflowServiceStubsOptions`.\n\n```java\n//...\n   // see the Micrometer documentation for configuration details on other supported monitoring systems.\n   // in this example shows how to set up Prometheus registry and stats reported.\n   PrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\n   StatsReporter reporter = new MicrometerClientStatsReporter(registry);\n    // set up a new scope, report every 10 seconds\n     Scope scope = new RootScopeBuilder()\n             .reporter(reporter)\n             .reportEvery(com.uber.m3.util.Duration.ofSeconds(10));\n   // for Prometheus collection, expose a scrape endpoint.\n   //...\n   // add metrics scope to WorkflowServiceStub options\n   WorkflowServiceStubsOptions stubOptions =\n       WorkflowServiceStubsOptions.newBuilder().setMetricsScope(scope).build();\n//...\n```\n\nFor more details, see the [Java SDK Samples](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/metrics).\nFor details on configuring a Prometheus scrape endpoint with Micrometer, see <https://micrometer.io/docs/registry/prometheus#_configuring>.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-get-the-result-of-a-workflow-execution-in-java.md","id":283,"title":"How to get the result of a Workflow Execution in Java","description":"A synchronous Workflow Execution blocks your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure). An asynchronous Workflow Execution immediately returns a value to the caller.","label":"Workflow Execution Result","tags":["java","developer-guide"],"markdown_content":"\nA synchronous Workflow Execution blocks your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure).\n\nThe following example is a type-safe approach for getting the results of a synchronous Workflow Execution.\n\n```java\n FileProcessingWorkflow workflow = client.newWorkflowStub(\n                FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setWorkflowId(workflowId)\n                        .setTaskQueue(taskQueue)\n                        .build();\n\n// start sync and wait for results (or failure)\nString result = workflow.processfile(new Argument());\n```\n\nAn asynchronous Workflow Execution immediately returns a value to the caller.\n\nThe following examples show how to get the results of a Workflow Execution through typed and untyped `WorkflowStub`.\n\n- **Typed WorkflowStub Example**\n\n  ```java\n  // create typed Workflow stub\n  FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setTaskQueue(taskQueue)\n                        .setWorkflowId(workflowId)\n                        .build());\n  // use WorkflowClient.execute (if your Workflow takes in arguments) or WorkflowClient.start (for zero arguments)\n  WorkflowClient.start(workflow::greetCustomer);\n  ```\n\n- **Untyped WorkflowStub Example**\n\n  ```java\n  WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n                  WorkflowOptions.newBuilder()\n                          .setWorkflowId(workflowId)\n                          .setTaskQueue(taskQueue)\n                          .build());\n\n  // blocks until Workflow Execution has been started (not until it completes)\n  untyped.start(argument);\n  ```\n\nIf you need to wait for a Workflow Execution to complete after an asynchronous start, the most straightforward way is to call the blocking Workflow instance again.\n\nNote that if `WorkflowOptions.WorkflowIdReusePolicy` is not set to `AllowDuplicate`, then instead of throwing `DuplicateWorkflowException`, it reconnects to an existing Workflow and waits for its completion.\n\nThe following example shows how to do this from a different process than the one that started the Workflow Execution.\n\n```java\nYourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflow.yourMethod();\n```\n\nAnother way to connect to an existing Workflow and wait for its completion from another process, is to use `UntypedWorkflowStub`. For example:\n\n```java\nWorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = untyped.getResult(String.class);\n```\n\n**Get last (successful) completion result**\n\nFor a Temporal Cron Job, get the result of previous successful runs using `GetLastCompletionResult()`.\nThe method returns `null` if there is no previous completion.\nThe following example shows how to implement this in a Workflow.\n\n```java\npublic String cronWorkflow() {\n    String lastProcessedFileName = Workflow.getLastCompletionResult(String.class);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the Cron schedule runs failed.\nThe next schedule will still get the last successful result if it ever successfully completed at least once.\nFor example, for a daily cron Workflow, if the run succeeds on the first day and fails on the second day, then the third day run will get the result from first day's run using these APIs.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-get-the-result-of-an-activity-execution-in-java.md","id":284,"title":"How to get the result of an Activity Execution","description":"To get the results of an asynchronously invoked Activity method, use the `Promise` `get` method to block until the Activity method result is available.","label":"Activity Execution Result","tags":["java","developer-guide"],"markdown_content":"\nTo get the results of an asynchronously invoked Activity method, use the `Promise` `get` method to block until the Activity method result is available.\n\nSometimes an Activity Execution lifecycle goes beyond a synchronous method invocation.\nFor example, a request can be put in a queue and later a reply comes and is picked up by a different Worker process.\nThe whole request-reply interaction can be modeled as a single Activity.\n\nTo indicate that an Activity should not be completed upon its method return, call `ActivityExecutionContext.doNotCompleteOnReturn()` from the original Activity thread.\n\nThen later, when replies come, complete the Activity using the `ActivityCompletionClient`.\nTo correlate Activity invocation with completion use either a `TaskToken` or Workflow and Activity IDs.\n\nFollowing is an example of using `ActivityExecutionContext.doNotCompleteOnReturn()`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n\n    // Used to correlate reply\n    byte[] taskToken = ctx.getInfo().getTaskToken();\n\n    asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n    ctx.doNotCompleteOnReturn();\n\n    // Return value is ignored when doNotCompleteOnReturn was called.\n    return \"ignored\";\n  }\n  ...\n}\n```\n\nWhen the download is complete, the download service potentially can complete the Activity, or fail it from a different process, for example:\n\n```java\n  public <R> void completeActivity(byte[] taskToken, R result) {\n    completionClient.complete(taskToken, result);\n  }\n\n  public void failActivity(byte[] taskToken, Exception failure) {\n    completionClient.completeExceptionally(taskToken, failure);\n  }\n```\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-handle-a-query-in-a-workflow-in-java.md","id":285,"title":"How to handle a Query in a Workflow in Java","description":"To handle a Query in a Workflow, define a Query handler method using the `@QueryMethod` annotation in the Workflow interface.","label":"Handle Query","tags":["java","developer-guide"],"markdown_content":"\nTo handle a Query in the Workflow, create a Query handler using the `@QueryMethod` annotation in the Workflow interface and define it in the Workflow implementation.\n\nThe `@QueryMethod` annotation indicates that the method is used to handle a Query that is sent to the Workflow Execution.\nThe method can have parameters that can be used to filter data that the Query returns.\nBecause the method returns a value, it must have a return type that is not `void`.\n\nThe Query name defaults to the name of the method.\nIn the following example, the Query name defaults to `getStatus`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod\n   String getStatus();\n}\n```\n\nTo overwrite this default naming and assign a custom Query name, use the `@QueryMethod` annotation with the `name` parameter. In the following example, the Query name is set to \"history\".\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n   @QueryMethod(name = \"history\")\n   String getStatus();\n}\n```\n\nA Workflow Definition interface can define multiple methods annotated with `@QueryMethod`, but the method names or the `name` parameters for each must be unique.\n\nThe following Workflow interface has a Query method `getCount()` to handle Queries to this Workflow.\n\n```java\n  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @QueryMethod\n    int getCount();\n  }\n```\n\nThe following example is the Workflow implementation with the Query method defined in the `HelloWorld` Workflow interface from the previous example.\n\n```java\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = \"Hello\";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!\"Bye\".equals(greeting)) {\n        logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n```\n\n**Dynamic Query Handler**\nYou can also implement Query handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicQueryListener` in the Workflow implementation code.\n\n```java\n      Workflow.registerListener(\n        (DynamicQueryHandler)\n            (queryName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Queries sent to the Workflow without a defined handler will be delivered to the `DynamicQueryHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicQueryHandler` can be implemented in both regular and dynamic Workflow implementations.\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-handle-a-signal-in-a-workflow-in-java.md","id":286,"title":"How to handle Signals in an Workflow in Java","description":"Use the `@SignalMethod` annotation to handle Signals within the Workflow interface.","label":"Handle Signals","tags":["java","developer-guide"],"markdown_content":"\nUse the `@SignalMethod` annotation to handle Signals in the Workflow interface.\n\nThe Signal type defaults to the name of the method. In the following example, the Signal type defaults to `retryNow`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod\n   void retryNow();\n}\n```\n\nTo overwrite this default naming and assign a custom Signal type, use the `@SignalMethod` annotation with the `name` parameter.\nIn the following example, the Signal type is set to `retrysignal`.\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n   @WorkflowMethod\n   String processFile(Arguments args);\n\n   @SignalMethod(name = \"retrysignal\")\n   void retryNow();\n}\n```\n\nA Workflow interface can define any number of methods annotated with `@SignalMethod`, but the method names or the `name` parameters for each must be unique.\n\nIn the following example, we define a Signal method `updateGreeting` to update the greeting in the Workflow.\nWe set a `Workflow.await` in the Workflow implementation to block the current Workflow Execution until the provided unblock condition is evaluated to `true`.\nIn this case, the unblocking condition is evaluated to `true` when the Signal to update the greeting is received.\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n}\n```\n\n```java\npublic class HelloWorldImpl implements HelloWorld {\n    private final Logger workflowLogger = Workflow.getLogger(HelloWorldImpl.class);\n    private String greeting;\n\n    @Override\n    public void sayHello(String name) {\n        int count = 0;\n        while (!\"Bye\".equals(greeting)) {\n            String oldGreeting = greeting;\n            Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n        }\n        workflowLogger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n        this.greeting = greeting;\n    }\n}\n```\n\nThis Workflow completes when the Signal updates the greeting to `Bye`.\n\n**Dynamic Signal Handler**\nYou can also implement Signal handlers dynamically. This is useful for library-level code and implementation of DSLs.\n\nUse `Workflow.registerListener(Object)` to register an implementation of the `DynamicSignalListener` in the Workflow implementation code.\n\n```java\n      Workflow.registerListener(\n        (DynamicSignalHandler)\n            (signalName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\nWhen registered, any Signals sent to the Workflow without a defined handler will be delivered to the `DynamicSignalHandler`.\nNote that you can only register one `Workflow.registerListener(Object)` per Workflow Execution.\n`DynamicSignalHandler` can be implemented in both regular and dynamic Workflow implementations.\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-handle-workflow-logic-requirements-in-java.md","id":287,"title":"How to handle Workflow Logic Requirements in Java","description":"When defining Workflows using the Temporal Java SDK, the Workflow code must be written to execute effectively once and to completion.","label":"Workflow logic requirements","tags":["developer-guide","java"],"markdown_content":"\nWhen defining Workflows using the Temporal Java SDK, the Workflow code must be written to execute effectively once and to completion.\n\nThe following constraints apply when writing Workflow Definitions:\n\n- Do not use mutable global variables in your Workflow implementations.\n  This will ensure that multiple Workflow instances are fully isolated.\n- Your Workflow code must be deterministic.\n  Do not call non-deterministic functions (such as non-seeded random or `UUID.randomUUID()`) directly from the Workflow code.\n  The Temporal SDK provides specific API for calling non-deterministic code in your Workflows.\n- Do not use programming language constructs that rely on system time.\n  For example, only use `Workflow.currentTimeMillis()` to get the current time inside a Workflow.\n- Do not use native Java `Thread` or any other multi-threaded classes like `ThreadPoolExecutor`.\n  Use `Async.function` or `Async.procedure`, provided by the Temporal SDK, to execute code asynchronously.\n- Do not use synchronization, locks, or other standard Java blocking concurrency-related classes besides those provided by the Workflow class.\n  There is no need for explicit synchronization because multi-threaded code inside a Workflow is executed one thread at a time and under a global lock.\n  - Call `Workflow.sleep` instead of `Thread.sleep`.\n  - Use `Promise` and `CompletablePromise` instead of `Future` and `CompletableFuture`.\n  - Use `WorkflowQueue` instead of `BlockingQueue`.\n- Use `Workflow.getVersion` when making any changes to the Workflow code.\n  Without this, any deployment of updated Workflow code might break already running Workflows.\n- Do not access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow Execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n- Use `DynamicWorkflow` when you need a default Workflow that can handle all Workflow Types that are not registered with a Worker.\n  A single implementation can implement a Workflow Type which by definition is dynamically loaded from some external source.\n  All standard `WorkflowOptions` and determinism rules apply to Dynamic Workflow implementations.\n\nJava Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-heartbeat-an-activity-in-java.md","id":288,"title":"How to Heartbeat an Activity in Java","description":"To inform the Temporal service that the Activity is still alive, use `Activity.getExecutionContext().heartbeat()` in the Activity implementation code.","label":"Activity Heartbeat","tags":["java","developer-guide"],"markdown_content":"\nTo Heartbeat an Activity Execution in Java, use the `Activity.getExecutionContext().heartbeat()` Class method.\n\n```java\npublic class YourActivityDefinitionImpl implements YourActivityDefinition {\n\n  @Override\n  public String yourActivityMethod(YourActivityMethodParam param) {\n    // ...\n    Activity.getExecutionContext().heartbeat(details);\n    // ...\n  }\n  // ...\n}\n```\n\nThe method takes an optional argument, the `details` variable above that represents latest progress of the Activity Execution.\nThis method can take a variety of types such as an exception object, custom object, or string.\n\nIf the Activity Execution times out, the last Heartbeat `details` are included in the thrown `ActivityTimeoutException`, which can be caught by the calling Workflow.\nThe Workflow can then use the `details` information to pass to the next Activity invocation if needed.\n\nIn the case of Activity retries, the last Heartbeat's `details` are available and can be extracted from the last failed attempt by using `Activity.getExecutionContext().getHeartbeatDetails(Class<V> detailsClass)`\n","is_empty":false},{"file_name":"how-to-pass-an-authorization-header-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-pass-an-authorization-header-in-java.md","id":289,"title":"How to provide an Authorization Token in Java (JWT)","description":"Providing authorization header to Temporal Server in Java SDK including JWT tokens","label":"Authorization","tags":["developer-guide","java","auth"],"markdown_content":"\nimport RelatedReadList from '../components/RelatedReadList.js'\n\nThe Temporal Server [expects](/server/security/#authentication) an `authorization` gRPC header with an authorization token to be passed with API calls if [requests authorization](/server/security/#authorization) is configured.\n\nAuthorization Tokens may be provided to the Temporal Java SDK by implementing a `io.temporal.authorization.AuthorizationTokenSupplier` interface.\nThe implementation should be used to create `io.temporal.authorization.AuthorizationGrpcMetadataProvider` that may be configured on ServiceStub gRPC interceptors list.\n\nThe implementation is called for each SDK gRPC request and may supply dynamic tokens.\n\n**JWT**\n\nOne of the token types that may be passed this way are JWT tokens.\nTemporal Server provides a [default implementation of JWT authentication](/server/security/#default-jwt-claimmapper).\n\n**Example**\n\n```java\n  AuthorizationTokenSupplier tokenSupplier =\n    //your implementation of token supplier\n    () -> \"Bearer <Base64 url-encoded value of the token for default JWT ClaimMapper>\";\n  WorkflowServiceStubsOptions serviceStubOptions =\n    WorkflowServiceStubsOptions.newBuilder()\n      //other service stub options\n      .addGrpcMetadataProvider(new AuthorizationGrpcMetadataProvider(tokenSupplier))\n      .build();\n  WorkflowServiceStubs service = WorkflowServiceStubs.newServiceStubs(serviceStubOptions);\n  WorkflowClient client = WorkflowClient.newInstance(service);\n```\n\nRelated read:\n\n- [How to secure a Temporal Cluster](/server/security)\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-register-types-with-a-worker-in-java.md","id":290,"title":"How to register types with a Worker in Java","description":"Use `worker.registerWorkflowImplementationTypes` to register Workflow type and `worker.registerActivitiesImplementations` to register Activity implementation with Workers.","label":"Register Types","tags":["developer-guide","java","workers"],"markdown_content":"\nUse `worker.registerWorkflowImplementationTypes` to register Workflow type and `worker.registerActivitiesImplementations` to register Activity implementation with Workers.\n\nFor Workflows, the Workflow Type is registered with a Worker.\nA Workflow Type can be registered only once per Worker entity.\nIf you define multiple Workflow implementations of the same type, you get an exception at the time of registration.\n\nFor Activities, Activity implementation instances are registered with a Worker because they are stateless and thread-safe.\nYou can pass any number of dependencies in the Activity implementation constructor, such as the database connections, services, etc.\n\nThe following example shows how to register a Workflow and an Activity with a Worker.\n\n```java\n    Worker worker = workerFactory.newWorker(\"your_task_queue\");\n    ...\n    // Register Workflow\n    worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n    // Register Activity\n    worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n```\n\nWhen you register a single instance of an Activity, you can have multiple instances of Workflow Executions calling the same Activity.\nActivity code must be thread-safe because the same instance of the Activity code is run for every Workflow Execution that calls it.\n\nFor `DynamicWorkflow`, only one Workflow implementation that extends `DynamicWorkflow` can be registered with a Worker.\nThe following example shows how to register the `DynamicWorkflow` and `DynamicActivity` implementation with a Worker.\n\n```java\n  public static void main(String[] arg) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker(TASK_QUEUE);\n\n    /* Register the Dynamic Workflow implementation with the Worker. Workflow implementations\n    ** must be known to the Worker at runtime to dispatch Workflow Tasks.\n    */\n    worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    // Start all the Workers that are in this process.\n    factory.start();\n\n    /* Create the Workflow stub. Note that the Workflow type is not explicitly registered with the Worker. */\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n    /**\n     * Register Dynamic Activity implementation with the Worker. Since Activities are stateless\n     * and thread-safe, we need to register a shared instance.\n    */\n    worker.registerActivitiesImplementations(new DynamicGreetingActivityImpl());\n\n    /* Start Workflow Execution and immmediately send Signal. Pass in the Workflow args and Signal args. */\n    workflow.signalWithStart(\"greetingSignal\", new Object[] {\"John\"}, new Object[] {\"Hello\"});\n\n    // Wait for the Workflow to finish getting the results.\n    String result = workflow.getResult(String.class);\n\n    System.out.println(result);\n\n    System.exit(0);\n  }\n}\n```\n\nYou can register multiple type-specific Workflow implementations alongside a single `DynamicWorkflow` implementation.\nYou can register only one Activity instance that implements `DynamicActivity` with a Worker.\n","is_empty":false},{"file_name":"how-to-send-a-query-to-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-send-a-query-to-a-workflow-in-java.md","id":291,"title":"How to send a Query in Java","description":"To send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.","label":"Send Query","tags":["java","developer-guide"],"markdown_content":"\nTo send a Query to a Workflow Execution from an external process, call the Query method (defined in the Workflow) from a `WorkflowStub` within the Client code.\n\nFor example, the following Client code calls a Query method `queryGreeting()` defined in the `GreetingWorkflow` Workflow interface.\n\n```java\n // Create our workflow options\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder()\n        .setWorkflowId(WORKFLOW_ID)\n        .setTaskQueue(TASK_QUEUE).build();\n\n    // Create the Temporal client stub. It is used to start our workflow execution.\n    GreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);\n\n    // Start our workflow asynchronously to not use another thread to query.\n    WorkflowClient.start(workflow::createGreeting, \"World\");\n\n    // Query the Workflow to get the current value of greeting and print it.\n    System.out.println(workflow.queryGreeting());\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-send-a-signal-from-a-client-in-java.md","id":292,"title":"How to send a Signal from a Client in Java","description":"To send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.","label":"Send Signal from Client","tags":["java","developer-guide"],"markdown_content":"\nTo send a Signal to a Workflow Execution from a Client, call the Signal method, annotated with `@SignalMethod` in the Workflow interface, from the Client code.\n\nIn the following Client code example, we start the Workflow `greetCustomer` and call the Signal method `addCustomer` that is handled in the Workflow.\n\n```java\n// create a typed Workflow stub for GreetingsWorkflow\nGreetingsWorkflow workflow = client.newWorkflowStub(GreetingsWorkflow.class,\n        WorkflowOptions.newBuilder()\n                // set the Task Queue\n                .setTaskQueue(taskQueue)\n                // Workflow Id is recommended but not required\n                .setWorkflowId(workflowId)\n                .build());\n\n// start the Workflow\nWorkflowClient.start(workflow::greetCustomer);\n// send a Signal to the Workflow\nCustomer customer = new Customer(\"John\", \"Spanish\", \"john@john.com\");\nworkflow.addCustomer(customer); //addCustomer is the Signal method defined in the greetCustomer Workflow.\n```\n\nSee [Handle Signals](/java/how-to-handle-a-signal-in-a-workflow-in-java) for details on how to handle Signals in a Workflow.\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-send-a-signal-from-a-workflow-in-java.md","id":293,"title":"How to send a Signal from a Workflow in Java","description":"To send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow.","label":"Send Signal from Workflow","tags":["java","developer-guide"],"markdown_content":"\nTo send a Signal from within a Workflow to a different Workflow Execution, initiate an `ExternalWorkflowStub` in the implementation of the current Workflow and call the Signal method defined in the other Workflow.\n\nThe following example shows how to use an untyped `ExternalWorkflowStub` in the Workflow implementation to send a Signal to another Workflow.\n\n```java\n    public String sendGreeting(String name) {\n\n        // initiate ExternalWorkflowStub to call another Workflow by its Id \"ReplyWF\"\n        ExternalWorkflowStub callRespondWorkflow = Workflow.newUntypedExternalWorkflowStub(\"ReplyWF\");\n\n        String responseTrigger = activity.greeting(\"Hello\", name);\n\n        // send a Signal from this sendGreeting Workflow to the other Workflow\n        // by calling the Signal method name \"getGreetCall\" defined in that Workflow.\n        callRespondWorkflow.signal(\"getGreetCall\", responseTrigger);\n\n        return responseTrigger;\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-send-a-signal-with-start-in-java.md","id":294,"title":"How to send a Signal-with-Start in Java","description":"To send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart` with a `WorkflowStub` in the Client code.","label":"Signal with Start","tags":["java","developer-guide"],"markdown_content":"\nTo send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart` with a `WorkflowStub` in the Client code.\nThis method ensures that if the Workflow Execution is in a closed state, a new Workflow Execution is spawned and the Signal is delivered to the running Workflow Execution.\n\nNote that when the `SignalwithStart` spawns a new Workflow Execution, the Signal is delivered before the call to your `@WorkflowMethod`.\nThis means that the Signal handler in your Workflow interface code will execute before the `@WorkfowMethod`.\nYou must ensure that your code logic can deal with this.\n\nIn the following example, the Client code uses `SignalwithStart` to send the Signal `setCustomer` to the `UntypedWorkflowStub` named `GreetingWorkflow`.\nIf the `GreetingWorkflow` Workflow Execution is not running, the `SignalwithStart` starts the Workflow Execution.\n\n```java\n...\npublic static void signalWithStart() {\n        // WorkflowStub is a client-side stub to a single Workflow instance\n        WorkflowStub untypedWorkflowStub = client.newUntypedWorkflowStub(\"GreetingWorkflow\",\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(workflowId)\n                .setTaskQueue(taskQueue)\n                .build());\n\n        untypedWorkflowStub.signalWithStart(\"setCustomer\", new Object[] {customer2}, new Object[] {customer1});\n\n        printWorkflowStatus();\n\n        try {\n            String greeting = untypedWorkflowStub.getResult(String.class);\n            printWorkflowStatus();\n            System.out.println(\"Greeting: \" + greeting);\n        } catch(WorkflowFailedException e) {\n            System.out.println(\"Workflow failed: \" + e.getCause().getMessage());\n            printWorkflowStatus();\n        }\n    }\n...\n```\n\nThe following example shows the Workflow interface for the `GreetingWorkflow` called in the previous example.\n\n```java\n...\n@WorkflowInterface\npublic interface GreetingWorkflow {\n    @WorkflowMethod\n    String greet(Customer customer);\n\n    @SignalMethod\n    void setCustomer(Customer customer);\n\n    @QueryMethod\n    Customer getCustomer();\n...\n}\n```\n\nNote that the Signal handler `setCustomer` is executed before the `@WorkflowMethod` `greet` is called.\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-cron-schedule-in-java.md","id":295,"title":"How to set a Cron Schedule in Java","description":"Set the Cron Schedule with the `WorkflowStub` instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`","label":"Cron Schedule","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the Cron Schedule with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setCronSchedule`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\nSetting `setCronSchedule` changes the Workflow Execution into a Temporal Cron Job.\nThe default timezone for a Cron is UTC.\n\n- Type: `String`\n- Default: None\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    YourWorker.yourclient.newWorkflowStub(\n        YourWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(YourWorker.TASK_QUEUE)\n                // Set Cron Schedule\n                .setCronSchedule(\"* * * * *\")\n                .build());\n```\n\nFor more details, see the [Cron Sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/hello/HelloCron.java)\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-heartbeat-timeout-in-java.md","id":296,"title":"How to set a Heartbeat Timeout in Java","description":"To set a Heartbeat Timeout, use `ActivityOptions.newBuilder.setHeartbeatTimeout​`].","label":"Heartbeat Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set a [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout), use [`ActivityOptions.newBuilder.setHeartbeatTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: None\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  private final GreetingActivities activities =\n      Workflow.newActivityStub(\n          GreetingActivities.class,\n          ActivityOptions.newBuilder()\n              // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n              // required when setting Activity options.\n              .setStartToCloseTimeout(Duration.ofSeconds(5))\n              .setHeartbeatTimeout(Duration.ofSeconds(2))\n              .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                          // required when setting Activity options.\n                                            .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                            .setHeartbeatTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-parent-close-policy-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-parent-close-policy-in-java.md","id":297,"title":"How to set Parent Close Policy in Java","description":"Set `Parent Close Policy` on an instance of `ChildWorkflowOptions` using `ChildWorkflowOptions.newBuilder().setParentClosePolicy`.","label":"Parent Close Policy","tags":["java","developer-guide","how-to"],"markdown_content":"\nSet [Parent Close Policy](/concepts/what-is-a-parent-close-policy) on an instance of `ChildWorkflowOptions` using [`ChildWorkflowOptions.newBuilder().setParentClosePolicy`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/ChildWorkflowOptions.Builder.html).\n\n- Type: `ChildWorkflowOptions.Builder`\n- Default: None.\n\n```java\n   public void parentWorkflow() {\n       ChildWorkflowOptions options =\n          ChildWorkflowOptions.newBuilder()\n              .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)\n              .build();\n       MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, options);\n       Async.procedure(child::<workflowMethod>, <args>...);\n       Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(child);\n       // Wait for child to start\n       childExecution.get()\n  }\n```\n\nIn this example, we are:\n\n1. Setting `ChildWorkflowOptions.ParentClosePolicy` to `ABANDON` when creating a Child Workflow stub.\n2. Starting Child Workflow Execution asynchronously using `Async.function` or `Async.procedure`.\n3. Calling `Workflow.getWorkflowExecution(…)` on the child stub.\n4. Waiting for the `Promise` returned by `getWorkflowExecution` to complete.\n   This indicates whether the Child Workflow started successfully (or failed).\n5. Completing parent Workflow Execution asynchronously.\n\nSteps 3 and 4 are needed to ensure that a Child Workflow Execution starts before the parent closes.\nIf the parent initiates a Child Workflow Execution and then completes immediately after, the Child Workflow will never execute.\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-schedule-to-close-timeout-in-java.md","id":298,"title":"How to set a Schedule-To-Close Timeout in Java","description":"To set a Schedule-To-Close Timeout, use `ActivityOptions.newBuilder.setScheduleToCloseTimeout​`].","label":"Schedule-To-Close Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set a [Schedule-To-Close Timeout](/concepts/what-is-a-schedule-to-close-timeout), use [`ActivityOptions.newBuilder.setScheduleToCloseTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `StartToCloseTimeout` must be set.\n\n- Type: `Duration`\n- Default: Unlimited.\n  Note that if `WorkflowRunTimeout` and/or `WorkflowExecutionTimeout` are defined in the Workflow, all Activity retries will stop when either or both of these timeouts are reached.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                      \"GetCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                          .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-schedule-to-start-timeout-in-java.md","id":299,"title":"How to set a Schedule-To-Start Timeout in Java","description":"To set a Schedule-To-Start Timeout, use `ActivityOptions.newBuilder.setScheduleToStartTimeout​`].","label":"Schedule-To-Start Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set a [Schedule-To-Start Timeout](/concepts/what-is-a-schedule-to-start-timeout), use [`ActivityOptions.newBuilder.setScheduleToStartTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `Duration`\n- Default: Unlimited. This timeout is non-retryable.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                          // required when setting Activity options.\n                          .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n             WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"GetCustomerGreeting\",\n                                ActivityOptions.newBuilder()\n                                    .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                    .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-start-to-close-timeout-in-java.md","id":300,"title":"How to set a Start-To-Close Timeout in Java","description":"To set a Start-To-Close Timeout, use `ActivityOptions.newBuilder.setStartToCloseTimeout​`].","label":"Start-To-Close Timeout","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set a [Start-To-Close Timeout](/concepts/what-is-a-start-to-close-timeout), use [`ActivityOptions.newBuilder.setStartToCloseTimeout​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\nThis or `ScheduleToClose` must be set.\n\n- Type: `Duration`\n- Default: Defaults to [`ScheduleToCloseTimeout`](#scheduletoclosetimeout) value\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n              ActivityOptions.newBuilder()\n                      .setStartToCloseTimeout(Duration.ofSeconds(2))\n                      .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // Set Activity Execution timeout (single run)\n                                            .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-execution-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-workflow-execution-timeout-in-java.md","id":301,"title":"How to set a Workflow Execution Timeout in Java","description":"Set the Workflow Execution Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowExecutionTimeout`.","label":"Workflow Execution Timeout","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the [Workflow Execution Timeout](/concepts/what-is-a-workflow-execution-timeout) with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowExecutionTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Execution Timeout duration\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-workflow-id-in-java.md","id":302,"title":"How to set a custom Workflow Id in Java","description":"Set the Workflow Id with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowId​`.","label":"Workflow Id","tags":["Java","how-to","developer-guide"],"markdown_content":"\nSet the Workflow Id with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowId​`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                // Set the Workflow Id\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-run-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-workflow-run-timeout-in-java.md","id":303,"title":"How to set a Workflow Run Timeout in Java","description":"Set the Workflow Run Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowRunTimeout`.","label":"Workflow Run Timeout","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the Workflow Run Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowRunTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: Same as [WorkflowExecutionTimeout](/java/how-to-set-a-workflow-execution-timeout-in-java).\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Run Timeout duration\n                .setWorkflowRunTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-workflow-task-queue-in-java.md","id":304,"title":"How to set the Task Queue for Workflow Execution in Java","description":"Set the Workflow Task Queue with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setTaskQueue`.","label":"Task Queue","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the Workflow Task Queue with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setTaskQueue`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `String`\n- Default: none\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                // Set the Task Queue\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-timeout-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-a-workflow-task-timeout-in-java.md","id":305,"title":"How to set a Workflow Task Timeout in Java","description":"Set the Workflow Task Timeout with the `WorkflowStub` instance in the Client code using `WorkflowOptions.Builder.setWorkflowTaskTimeout`.","label":"Workflow Task Timeout","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet the Workflow Task Timeout with the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance in the Client code using [`WorkflowOptions.Builder.setWorkflowTaskTimeout`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `time.Duration`\n- Default: 10 seconds.\n- Values: Maximum accepted value is 60 seconds.\n\n```java\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Task Timeout duration\n                .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-activity-retry-options-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-activity-retry-options-in-java.md","id":306,"title":"How to set Activity Retry Options in Java","description":"To set a Heartbeat Timeout, use `ActivityOptions.newBuilder.setHeartbeatTimeout​`].","label":"Activity Retry Options","tags":["Java","how-to","developer-guide"],"markdown_content":"\nTo set [Retry Options](/concepts/what-is-a-retry-policy), use [`ActivityOptions.newBuilder.setRetryOptions()`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: Server-defined Activity Retry policy.\n\n- With `ActivityStub`\n\n  ```java\n  private final ActivityOptions options =\n      ActivityOptions.newBuilder()\n          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n          // required when setting Activity options.\n          .setStartToCloseTimeout(Duration.ofSeconds(5))\n          .setRetryOptions(\n              RetryOptions.newBuilder()\n                  .setInitialInterval(Duration.ofSeconds(1))\n                  .setMaximumInterval(Duration.ofSeconds(10))\n                  .build())\n          .build();\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                // required when setting Activity options.\n                                .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                .setRetryOptions(\n                                      RetryOptions.newBuilder()\n                                          .setDoNotRetry(NullPointerException.class.getName())\n                                          .build())\n                                .build()))\n                .build();\n  ```\n","is_empty":false},{"file_name":"how-to-set-activityoptions-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-activityoptions-in-java.md","id":307,"title":"How to set ActivityOptions in Java","description":"Use `ActivityOptions` to configure how to invoke an Activity Execution.","label":"Set Activity Options","tags":["java","developer-guide"],"markdown_content":"\nUse `ActivityOptions` to configure how to invoke an Activity Execution.\nNote that Activity options must be set before the Activity Execution is invoked.\n\nYou can set Activity options for Activities within a Workflow or define specific Activity options per Activity Type within a Worker.\n\n## Setting Activity options within a Workflow\n\nUse `ActivityOptions` with `ActivityStub` to set options for invoking Activities within a Workflow.\nThe following example shows how to set `ActivityOptions` for Activities within a Workflow.\n\n```java\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofSeconds(5))\n                        // if task queue not set, it will be same Task Queue as what the Workflow uses\n                        .setTaskQueue(\"yourTaskQueue\")\n                        // If RetryOptions are not explicitly set, Activities have a default RetryOption that apply.\n                       .setRetryOptions(RetryOptions.newBuilder()\n                                .build())\n                        .build());\n\n```\n\nNote that these Activity options will apply for all the Activities defined in the _GreetingActivities_ Activity interface.\nYou can create multiple Activity stubs within a Workflow, and each can have different Activity options defined.\n\n## Setting per-Activity options when registering a Workflow with a Worker\n\nTo set different options per Activity type, use `.setActivityOptions` with `WorkflowImplementationOptions`.\nNote that if you define options per Activity Type with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically within `ActivityOptions` in a Workflow will override this setting.\n\nThe following example shows how to set Activity options for Activity Types with `WorkflowImplementationOptions`.\n\n```java\n WorkflowImplementationOptions options =\n                WorkflowImplementationOptions.newBuilder()\n                        // setActivityOptions allows you to set different ActivityOption per Activity type.\n                        // By default Activity type is the name of Activity method (with first letter capitalized.)\n                        .setActivityOptions(\n                                ImmutableMap.of(\n                                        \"GetCustomerGreeting\",\n                                        ActivityOptions.newBuilder()\n                                                // Set Activity execution timeout (including retries)\n                                                .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                                .build(),\n                                        \"EmailCustomerGreeting\",\n                                        ActivityOptions.newBuilder()\n                                                // Set Activity execution timeout (single run)\n                                                .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                                .setRetryOptions(\n                                                        RetryOptions.newBuilder()\n                                                                // ActivityTypeB activity type shouldn't retry on NPE\n                                                                .setDoNotRetry(NullPointerException.class.getName())\n                                                                .build())\n                                                .build()))\n                        .build();\n// ...\nworker.registerWorkflowImplementationTypes(options, YourWorkflowImpl.class);\n```\n\nFor more details, see [Activity Options Reference](/java/reference-activityoptions).\n","is_empty":false},{"file_name":"how-to-set-child-workflow-options-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-child-workflow-options-in-java.md","id":308,"title":"How to set ChildWorkflowOptions in Java","description":"Set Child Workflow specific options with the `ChildWorkflowOptions` class.","label":"Child Workflow Options","tags":["java","developer-guide"],"markdown_content":"\nSet Child Workflow specific options with the `ChildWorkflowOptions.Builder` class and [methods](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.8.0/io/temporal/workflow/ChildWorkflowOptions.Builder.html).\n\n| Option                                                  | Required | Type                         |\n| ------------------------------------------------------- | -------- | ---------------------------- |\n| [`Namespace`](#namespace)                               | No       | String                       |\n| [`WorkflowId`](#workflowId)                             | No       | String                       |\n| [`ParentClosePolicy`](#parentclosepolicy)               | No       | ChildWorkflowOptions.Builder |\n| [`WorkflowIdReusePolicy`](#workflowidreusepolicy)       | No       | WorkflowIdReusePolicy        |\n| [`WorkflowExecutionTimeout`](#workflowexecutiontimeout) | No       | Duration                     |\n| [`WorkflowRunTimeout`](#workflowruntimeout)             | No       | Duration                     |\n| [`WorkflowTaskTimeout`](#workflowtasktimeout)           | No       | Duration                     |\n| [`RetryOptions`](#retryoptions)                         | No       | RetryOptions                 |\n| [`CronSchedule`](#cronschedule)                         | No       | String                       |\n| [`Memo`](#memo)                                         | No       | String                       |\n| [`SearchAttributes`](#searchattributes)                 | No       | Map<String, Object>          |\n\n### `Namespace`\n\n- Type: `String`\n- Default: Inherits the `namespace` value set from the parent Workflow.\n\n```java\npublic void parentWorkflow() {\n   ChildWorkflowOptions options = ChildWorkflowOptions.newBuilder()\n        .setNamespace(\"childWorkflowNamespace\")\n        .build();\n   GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class, options);\n  }\n```\n\nSee [What is a Namespace?](/concepts/what-is-a-namespace)\n\n### `WorkflowId`\n\n- Type: `String`\n- Default: none\n\n```java\n private void parentWorkflow() {\n        ChildWorkflowOptions options =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowId(\"childWorkflow1\")\n                        .build();\n\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a WorkflowId?](/concepts/what-is-a-workflow-id)\n\n### `ParentClosePolicy`\n\nimport ParentClosePolicy from './how-to-set-a-parent-close-policy-in-java.md'\n\n<ParentClosePolicy/>\n\n### `WorkflowIdReusePolicy`\n\n- Type: `WorkflowIdReusePolicy`\n- Default: `enums.AllowDuplicateFailedOnly` is the default value. It means that the Workflow can start a new run if the previous run failed, was canceled, or was terminated.\n- Values: `AllowDuplicate` allows a new run independently of the previous run closure status.\n  `RejectDuplicate` doesn't allow a new run independently of the previous run closure status.\n\n```java\n private void parentWorkflow() {\n        ChildWorkflowOptions options = ChildWorkflowOptions.newBuilder()\n        .setWorkflowId(\"YourWorkflowId\")\n        .setWorkflowRunTimeout(Duration.ofSeconds(5))\n        .setWorkflowIdReusePolicy(\n                WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE\n        )\n        .build();\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a Workflow Id Reuse Policy?](/concepts/what-is-a-workflow-id-reuse-policy)\n\n### `WorkflowExecutionTimeout`\n\n- Type: `time.Duration`\n- Default: Unlimited\n\n```java\n private void parentWorkflow() {\n        ChildWorkflowOptions childWorkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                        .build();\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a Workflow Execution Timeout?](/concepts/what-is-a-workflow-execution-timeout)\n\n### `WorkflowRunTimeout`\n\n- Type: `time.Duration`\n- Default: Same as [WorkflowExecutionTimeout](#WorkflowExecutionTimeout).\n\n```java\nprivate void parentWorkflow() {\n        ChildWorkflowOptions childWorkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowRunTimeout(Duration.ofSeconds(4))\n                        .build();\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a Workflow Run Timeout?](/concepts/what-is-a-workflow-run-timeout)\n\n### `WorkflowTaskTimeout`\n\n- Type: `time.Duration`\n- Default: 10 seconds.\n- Values: Maximum accepted value is 60 seconds.\n\n```java\n private void parentWorkflow() {\n        ChildWorkflowOptions childWorkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                        .build();\n        // Get the Child Workflow stub\n        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, childWorkflowOptions);\n        // invoke Child Workflow and wait for it to complete\n        child.executeChild();\n    }\n```\n\nSee [What is a Workflow Task Timeout?](/concepts/what-is-a-workflow-task-timeout)\n\n### `RetryOptions`\n\n- Type: `RetryOptions`\n- Default: `Null` which means no retries will be attempted.\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setWorkflowExecutionTimeout(Duration.ofSeconds(10)\n                        .setRetryOptions(RetryOptions.newBuilder()\n                                .build())\n                        .build();\n         ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, ChildworkflowOptions);\n         child.executeChild();\n```\n\nSee [What is a Retry Policy?](/concepts/what-is-a-retry-policy)\n\n### `CronSchedule`\n\n- Type: `String`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        .setCronSchedule(\"@every 10s\")\n                        .build();\n         ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, ChildworkflowOptions);\n         child.executeChild();\n```\n\nSee [Cron Schedules](/concepts/what-is-a-temporal-cron-job#cron-schedules)\n\n### `Memo`\n\n- Type: `String`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // You can set additional non-indexed info via Memo\n                        .setMemo(ImmutableMap.of(\n                                \"memoKey\", \"memoValue\"\n                        ))\n                        .build();\n```\n\nSee [What is a Memo?](/concepts/what-is-a-memo)\n\n### `SearchAttributes`\n\n- Type: `Map<String, Object>`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // You can set search attributes just like in WorkflowOptions\n                        // make sure that these search attributes were added before\n                        .setSearchAttributes(ImmutableMap.of(\"MySearchAttributeNAme\", \"value\"))\n                        .build();\n```\n\nSee [What is a Search Attribute?](/concepts/what-is-a-search-attribute)\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-mtls-configuration-in-java.md","id":309,"title":"How to set mTLS configuration in Java","description":"To set the mTLS configuration in Java, provide the certificate and private key in an instance of `WorkflowServiceStub`.","label":"Set mTLS configuration","tags":["developer-guide","sdk","java"],"markdown_content":"\nTo set the mTLS configuration in Java, provide the certificate and private key in an instance of `WorkflowServiceStub`.\n\nThe following example shows how to set up certificates and pass the `SSLContext` for the Client.\n\n```java\nimport io.temporal.serviceclient.SimpleSslContextBuilder;\n...\n// Load your client certificate, which should look like:\n    // -----BEGIN CERTIFICATE-----\n    // ...\n    // -----END CERTIFICATE-----\n    InputStream clientCert = new FileInputStream(System.getenv(\"TEMPORAL_CLIENT_CERT\"));\n    // PKCS8 client key, which should look like:\n    // -----BEGIN PRIVATE KEY-----\n    // ...\n    // -----END PRIVATE KEY-----\n    InputStream clientKey = new FileInputStream(System.getenv(\"TEMPORAL_CLIENT_KEY\"));\n    // For Temporal Cloud this would likely be ${namespace}.tmprl.cloud:7233\n    String targetEndpoint = System.getenv(\"TEMPORAL_ENDPOINT\");\n    // Your registered Namespace.\n    String namespace = System.getenv(\"TEMPORAL_NAMESPACE\");\n    // Create SSL enabled client by passing SslContext, created by SimpleSslContextBuilder.\n    WorkflowServiceStubs service =\n        WorkflowServiceStubs.newInstance(\n            WorkflowServiceStubsOptions.newBuilder()\n                .setSslContext(SimpleSslContextBuilder.forPKCS8(clientCert, clientKey).build())\n                .setTarget(targetEndpoint)\n                .build());\n\n```\n\nFor more information, see [Sample](https://github.com/temporalio/samples-java/blob/main/src/main/java/io/temporal/samples/ssl/SslEnabledWorker.java).\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-the-namespace-for-a-temporal-client-in-java.md","id":310,"title":"How to set a Namespace for a Temporal Client in Java","description":"Use the setNamespace method on Workflow Client Options Builder.","label":"Set Namespace","tags":["how-to","java"],"markdown_content":"\nUse the `setNamespace()` method on Workflow Client Options Builder.\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\nWorkflowClientOptions clientOptions = WorkflowClientOptions.newBuilder()\n        .setNamespace(\"your-custom-namespace\").build();\nWorkflowClient workflowClient =  WorkflowClient.newInstance(service, clientOptions);\n```\n","is_empty":false},{"file_name":"how-to-set-workflow-retry-options-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-workflow-retry-options-in-java.md","id":311,"title":"How to set Workflow Retry Options in Java","description":"Set Workflow Retry Options in the `WorkflowStub` instance using `WorkflowOptions.Builder.setWorkflowRetryOptions`.","label":"Workflow Retry Options","tags":["java","how-to","developer-guide"],"markdown_content":"\nSet Workflow Retry Options in the [`WorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) instance using [`WorkflowOptions.Builder.setWorkflowRetryOptions`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html).\n\n- Type: `RetryOptions`\n- Default: `Null` which means no retries will be attempted.\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Retry Options\n                .setRetryOptions(RetryOptions.newBuilder()\n                .build());\n```\n","is_empty":false},{"file_name":"how-to-set-workflowclientoptions-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-workflowclientoptions-in-java.md","id":312,"title":"How to set WorkflowClientOptions in Java","description":"Set `WorkflowClient` specific options with the `WorkflowClientOptions` class.","label":"WorkflowClientOptions","tags":["java","developer-guide"],"markdown_content":"\nSet `WorkflowClient` specific options with the `WorkflowClientOptions` class.\n\nThe following table lists the options used to configure `WorkflowClient`.\n\n| Option                  | Description                                                                       | Type                        |\n| ----------------------- | --------------------------------------------------------------------------------- | --------------------------- |\n| setDataConverter        | Set data converter                                                                | DataConverter               |\n| setInterceptors         | Set interceptors used to intercept Workflow Client calls                          | WorkflowClientInterceptor[] |\n| setIdentity             | Set human-readable identity of the Worker                                         | String                      |\n| setBinaryChecksum       | Set Worker binary checksum                                                        | String                      |\n| setContextPropagators   | Set the Context Propagators                                                       | List< ContextPropagator >   |\n| setQueryRejectCondition | Set conditions for when a Query should be rejected by closed and failed Workflows | QueryRejectCondition        |\n","is_empty":false},{"file_name":"how-to-set-workflowservicestuboptions-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-set-workflowservicestuboptions-in-java.md","id":313,"title":"How to set WorkflowServiceStubOptions in Java","description":"Set `WorkflowServiceStub` specific options with the `WorkflowServiceStubOptions` class.","label":"WorkflowServiceStubOptions","tags":["java","developer-guide"],"markdown_content":"\nSet `WorkflowServiceStub`-specific options with the `WorkflowServiceStubOptions` class.\nThe following table lists the options used to configure `WorkflowServiceStub`.\n\n| Option                             | Description                                                                 | Type            |\n| ---------------------------------- | --------------------------------------------------------------------------- | --------------- |\n| setChannel                         | Sets gRPC channel to use. Exclusive with target and sslContext              | ManagedChannel  |\n| setSslContext                      | Sets gRPC SSL Context to use                                                | SslContext      |\n| setEnableHttps                     | Sets option to enable SSL/TLS/HTTPS for gRPC                                | boolean         |\n| setTarget                          | Sets a target string                                                        | String          |\n| setRpcTimeout                      | Sets the rpc timeout value for non query and non long poll calls            | Duration        |\n| setRpcLongPollTimeout              | Sets the rpc timeout value                                                  | Duration        |\n| setRpcQueryTimeout                 | Sets the rpc timeout for queries                                            | Duration        |\n| setRpcRetryOptions                 | Set the rpc retry options                                                   | RpcRetryOptions |\n| setConnectionBackoffResetFrequency | Sets frequency at which gRPC connection backoff should be reset practically | Duration        |\n| setGrpcReconnectFrequency          | Sets frequency at which gRPC channel will be moved into an idle state       | Duration        |\n| setQueryRpcTimeout                 | Set the query rpc options                                                   | Duration        |\n| setHeaders                         | Set the headers                                                             | Metadata        |\n| setBlockingStubInterceptor         | Set blocking stub interceptor                                               | Function        |\n| setFutureStubInterceptor           | Set the future stub interceptor                                             | Function        |\n| setMetricsScope                    | Set the metric scope                                                        | Scope           |\n| setEnableKeepAlive                 | Set keep alive ping from client to the server                               | boolean         |\n| setKeepAliveTime                   | Set the keep alive time                                                     | Duration        |\n| setKeepAliveTimeout                | Set the keep alive timeout                                                  | Duration        |\n| setKeepAlivePermitWithoutStream    | Set if client sends keepalive pings even with no active RPCs                | boolean         |\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-spawn-a-child-workflow-execution-in-java.md","id":314,"title":"How to spawn a Child Workflow Execution in Java","description":"The first call to the Child Workflow stub can be synchronous or asynchronous using `Async.function(Functions.Func)` or `Async.procedure(Functions.Proc)`, and must always be to a method annotated with `@WorkflowMethod`.","label":"Child Workflow Execution","tags":["java","developer-guide"],"markdown_content":"\nThe first call to the Child Workflow stub must always be its Workflow method (method annotated with `@WorkflowMethod`).\nSimilar to Activities, invoking Child Workflow methods can be made synchronous or asynchronous by using `Async#function` or `Async#procedure`.\nThe synchronous call blocks until a Child Workflow method completes.\nThe asynchronous call returns a `Promise` which can be used to wait for the completion of the Child Workflow method, as in the following example:\n\n```java\nGreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\nPromise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n// ...\ngreeting.get()\n```\n\nTo execute an untyped Child Workflow asynchronously, call `executeAsync` on the `ChildWorkflowStub`, as shown in the following example.\n\n```java\n//...\nChildWorkflowStub childUntyped =\n    Workflow.newUntypedChildWorkflowStub(\n        \"GreetingChild\", // your workflow type\n        ChildWorkflowOptions.newBuilder().setWorkflowId(\"childWorkflow\").build());\n\nPromise<String> greeting =\n    childUntyped.executeAsync(String.class, String.class, \"Hello\", name);\nString result = greeting.get();\n//...\n```\n\nThe following examples show how to spawn a Child Workflow:\n\n- Spawn a Child Workflow from a Workflow:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n  @WorkflowMethod\n  String composeGreeting(String greeting, String name);\n  }\n  // Child Workflow implementation not shown\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n  @Override\n  public String getGreeting(String name) {\n      GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n      // This is a blocking call that returns only after child has completed.\n      return child.composeGreeting(\"Hello\", name );\n  }\n  }\n  ```\n\n- Spawn two Child Workflows (with the same type) in parallel:\n\n  ```java\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n\n          // Workflows are stateful, so a new stub must be created for each new child.\n          GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting1 = Async.function(child1::composeGreeting, \"Hello\", name);\n\n          // Both children will run concurrently.\n          GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting2 = Async.function(child2::composeGreeting, \"Bye\", name);\n\n          // Do something else here.\n          ...\n          return \"First: \" + greeting1.get() + \", second: \" + greeting2.get();\n      }\n  }\n  ```\n\n- Send a Signal to a Child Workflow from the parent:\n\n  ```java\n  // Child Workflow interface\n  @WorkflowInterface\n  public interface GreetingChild {\n      @WorkflowMethod\n      String composeGreeting(String greeting, String name);\n\n      @SignalMethod\n      void updateName(String name);\n  }\n\n  // Parent Workflow implementation\n  public class GreetingWorkflowImpl implements GreetingWorkflow {\n\n      @Override\n      public String getGreeting(String name) {\n          GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n          Promise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n          child.updateName(\"Temporal\");\n          return greeting.get();\n      }\n  }\n  ```\n\n- Sending a Query to Child Workflows from within the parent Workflow code is not supported. However, you can send a Query to Child Workflows from Activities using `WorkflowClient`.\n\nRelated reads:\n\n- [How to set a Child Workflow Options in Java](/java/how-to-set-child-workflow-options-in-java)\n\n- [How to develop a Workflow Definition in Java](/java/how-to-develop-a-workflow-definition-in-java)\n\n- Java Workflow reference: <https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/package-summary.html>\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-spawn-a-workflow-execution-in-java.md","id":315,"title":"How to spawn a Workflow Execution in Java","description":"Use `WorkflowStub` to start a Workflow Execution from within a Client, and `ExternalWorkflowStub` to start a different Workflow Execution from within a Workflow.","label":"Workflow Execution","tags":["java","developer-guide"],"markdown_content":"\nUse `WorkflowStub` to start a Workflow Execution from within a Client, and `ExternalWorkflowStub` to start a different Workflow Execution from within a Workflow.\n\nSee [`SignalwithStart`](/java/how-to-send-a-signal-with-start-in-java) to start a Workflow Execution to receive a Signal from within another Workflow.\n\n**Using `WorkflowStub`**\n\n`WorkflowStub` is a proxy generated by the `WorkflowClient`.\nEach time a new Workflow Execution is started, an instance of the Workflow implementation object is created.\nThen, one of the methods (depending on the Workflow Type of the instance) annotated with `@WorkflowMethod` can be invoked.\nAs soon as this method returns, the Workflow Execution is considered to be complete.\n\nYou can use a typed or untyped `WorkflowStub` in the client code.\n\n- Typed `WorkflowStub` are useful because they are type safe and allow you to invoke your Workflow methods such as `@WorkflowMethod`, `@QueryMethod`, and `@SignalMethod` directly.\n- An untyped `WorkflowStub` does not use the Workflow interface, and is not type safe. It is more flexible because it has methods from the `WorkflowStub` interface, such as `start`, `signalWithStart`, `getResults` (sync and async), `query`, `signal`, `cancel` and `terminate`.\n  Note that the Temporal Java SDK also provides typed `WorkflowStub` versions for these methods.\n  When using untyped `WorkflowStub`, we rely on the Workflow Type, Activity Type, Child Workflow Type, as well as Query and Signal names.\n  For details, see [Temporal Client](/java/how-to-create-a-temporal-client-in-java).\n\nA Workflow Execution can be started either synchronously or asynchronously.\n\n- Synchronous invocation starts a Workflow and then waits for its completion. If the process that started the Workflow crashes or stops waiting, the Workflow continues executing.\n  Because Workflows are potentially long-running, and Client crashes happen, it is not very commonly found in production use.\n  The following example is a type-safe approach for starting a Workflow Execution synchronously.\n\n  ```java\n    NotifyUserAccounts workflow = client.newWorkflowStub(\n          NotifyUserAccounts.class,\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(\"notifyAccounts\")\n                  .setTaskQueue(taskQueue)\n                  .build()\n          );\n\n  // start the Workflow and wait for a result.\n    workflow.notify(new String[] { \"Account1\", \"Account2\", \"Account3\", \"Account4\", \"Account5\",\n                  \"Account6\", \"Account7\", \"Account8\", \"Account9\", \"Account10\"});\n      }\n  // notify(String[] accountIds) is a Workflow method defined in the Workflow Definition.\n  ```\n\n- Asynchronous start initiates a Workflow Execution and immediately returns to the caller. This is the most common way to start Workflows in production code.\n  The `WorkflowClient`<https://github.com/temporalio/sdk-java/blob/master/temporal-sdk/src/main/java/io/temporal/client/WorkflowClient.java)> provides some static methods, such as `start`, `execute`, `signalWithStart` etc., that help with starting your Workflows asynchronously.\n\n  The following examples show how to start Workflow Executions asynchronously, with either typed or untyped `WorkflowStub`.\n\n  - **Typed WorkflowStub Example**\n\n    ```java\n    // create typed Workflow stub\n    FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n          WorkflowOptions.newBuilder()\n                  .setTaskQueue(taskQueue)\n                  .setWorkflowId(workflowId)\n                  .build());\n    // use WorkflowClient.execute to return future that contains Workflow result or failure, or\n    // use WorkflowClient.start to return WorkflowId and RunId of the started Workflow).\n    WorkflowClient.start(workflow::greetCustomer);\n    ```\n\n  - **Untyped WorkflowStub Example**\n\n    ```java\n    WorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n          WorkflowOptions.newBuilder()\n                  .setWorkflowId(workflowId)\n                  .setTaskQueue(taskQueue)\n                  .build());\n\n    // blocks until Workflow Execution has been started (not until it completes)\n    untyped.start(argument);\n    ```\n\nYou can call a Dynamic Workflow implementation using an untyped `WorkflowStub`.\nThe following example shows how to call the Dynamic Workflow implementation in the Client code.\n\n```java\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    /**\n      * Note that for this part of the client code, the dynamic Workflow implementation must\n      * be known to the Worker at runtime in order to dispatch Workflow tasks, and may be defined\n      * in the Worker definition as:*/\n    // worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    /* Create the Workflow stub to call the dynamic Workflow.\n    * Note that the Workflow type is not explicitly registered with the Worker.*/\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n```\n\n`DynamicWorkflow` can be used to invoke different Workflow Types.\nTo check what type is running when your Dynamic Workflow `execute` method runs, use `getWorkflowType()` in the implementation code.\n\n```java\nString type = Workflow.getInfo().getWorkflowType();\n```\n\nSee [Workflow Execution Result](/java/how-to-get-the-result-of-a-workflow-execution-in-java) for details on how to get the results of the Workflow Execution.\n\n**Using `ExternalWorkflowStub`**\n\nUse `ExternalWorkflowStub` within a Workflow to invoke, and send Signals to, other Workflows by type.\n\nThis helps particularly for executing Workflows written in other language SDKs, as shown in the following example.\n\n```java\n@Override\n  public String yourWFMethod(String name) {\n      ExternalWorkflowStub callOtherWorkflow = Workflow.newUntypedExternalWorkflowStub(\"OtherWFId\");\n    }\n```\n\nSee the [Temporal Polyglot](https://github.com/tsurdilo/temporal-polyglot) code for examples of executing Workflows written in other language SDKs.\n\n**Recurring start**\n\nYou can start a Workflow Execution on a regular schedule by using [`setCronSchedule`](/java/reference-workflowoptions/#cronschedule) Workflow option in the Client code.\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-spawn-an-activity-execution-in-java.md","id":316,"title":"How to spawn an Activity Execution in Java","description":"Invoke Activities using `Workflow.newActivityStub`(type-safe) or `Workflow.newUntypedActivityStub` (untyped) from within a Workflow.","label":"Activity Execution","tags":["java","developer-guide"],"markdown_content":"\nActivities are remote procedure calls that must be invoked from within a Workflow using `ActivityStub`.\nActivities are not executable on their own. You cannot start an Activity Execution by itself.\n\nNote that before an Activity Execution is invoked:\n\n- Activity options (either [`setStartToCloseTimeout`](/concepts/what-is-a-start-to-close-timeout) or [`ScheduleToCloseTimeout`](/concepts/what-is-a-schedule-to-close-timeout) are required) must be set for the Activity.\n  For details, see [Set Activity Options](/java/how-to-set-activityoptions-in-java) and [Activity Options reference](/java/reference-activityoptions).\n- The Activity must be registered with a Worker.\n  See [Worker Program](/java/how-to-develop-a-worker-program-in-java)\n- Activity code must be thread-safe.\n\nActivities should only be instantiated using stubs from within a Workflow.\nAn `ActivityStub` returns a client-side stub that implements an Activity interface.\nYou can invoke Activities using `Workflow.newActivityStub`(type-safe) or `Workflow.newUntypedActivityStub` (untyped).\n\nCalling a method on the Activity interface schedules the Activity invocation with the Temporal service, and generates an [`ActivityTaskScheduled` Event](/concepts/what-is-an-event#activitytaskscheduled).\n\nActivities can be invoked synchronously or asynchronously.\n\n**Invoking Activities Synchronously**\n\nIn the following example, we use the type-safe `Workflow.newActivityStub` within the \"FileProcessingWorkflow\" Workflow implementation to create a client-side stub of the `FileProcessingActivities` class. We also define `ActivityOptions` and set `setStartToCloseTimeout` option to one hour.\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) {\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    // ...\n}\n```\n\nA Workflow can have multiple Activity stubs. Each Activity stub can have its own `ActivityOptions` defined.\nThe following example shows a Workflow implementation with two typed Activity stubs.\n\n```java\npublic FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue1\")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue2\")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n```\n\nTo invoke Activities inside Workflows without referencing the interface it implements, use an untyped Activity stub `Workflow.newUntypedActivityStub`.\nThis is useful when the Activity type is not known at compile time, or to invoke Activities implemented in different programming languages.\n\n```java\n   // Workflow code\n    ActivityOptions activityOptions =\n        ActivityOptions.newBuilder()\n        .setStartToCloseTimeout(Duration.ofSeconds(3))\n        .setTaskQueue(\"simple-queue-node\")\n        .build();\n\n    ActivityStub activity = Workflow.newUntypedActivityStub(activityOptions);\n    activity.execute(\"ComposeGreeting\", String.class, \"Hello World\" , \"Spanish\");\n```\n\n**Invoking Activities Asynchronously**\n\nSometimes Workflows need to perform certain operations in parallel.\nThe Temporal Java SDK provides the `Async` class which includes static methods used to invoke any Activity asynchronously.\nThe calls return a result of type `Promise` which is similar to the Java `Future` and `CompletionStage`.\nWhen invoking Activities, use `Async.function` for Activities that return a result, and `Async.procedure` for Activities that return void.\n\nIn the following asynchronous Activity invocation, the method reference is passed to `Async.function` followed by Activity arguments.\n\n```java\nPromise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);\n```\n\nThe following example shows how to call two Activity methods, \"download\" and \"upload\", in parallel on multiple files.\n\n```java\n  public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n      // Download all files in parallel.\n      for (String sourceFilename : args.getSourceFilenames()) {\n        Promise<String> localName =\n            Async.function(activities::download, args.getSourceBucketName(), sourceFilename);\n        localNamePromises.add(localName);\n      }\n      List<String> localNames = new ArrayList<>();\n      for (Promise<String> localName : localNamePromises) {\n        localNames.add(localName.get());\n      }\n      processedNames = activities.processFiles(localNames);\n\n      // Upload all results in parallel.\n      List<Promise<Void>> uploadedList = new ArrayList<>();\n      for (String processedName : processedNames) {\n        Promise<Void> uploaded =\n            Async.procedure(\n                activities::upload,\n                args.getTargetBucketName(),\n                args.getTargetFilename(),\n                processedName);\n        uploadedList.add(uploaded);\n      }\n      // Wait for all uploads to complete.\n      Promise.allOf(uploadedList).get();\n    } finally {\n      for (Promise<String> localNamePromise : localNamePromises) {\n        // Skip files that haven't completed downloading.\n        if (localNamePromise.isCompleted()) {\n          activities.deleteLocalFile(localNamePromise.get());\n        }\n      }\n      if (processedNames != null) {\n        for (String processedName : processedNames) {\n          activities.deleteLocalFile(processedName);\n        }\n      }\n    }\n  }\n```\n\n**Activity Execution Context**\n\n`ActivityExecutionContext` is a context object passed to each Activity implementation by default.\nYou can access it in your Activity implementations via `Activity.getExecutionContext()`.\n\nIt provides getters to access information about the Workflow that invoked the Activity.\nNote that the Activity context information is stored in a thread-local variable.\nTherefore, calls to `getExecutionContext()` succeed only within the thread that invoked the Activity function.\n\nFollowing is an example of using the `ActivityExecutionContext`:\n\n```java\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n    ActivityInfo info = ctx.getInfo();\n\n    log.info(\"namespace=\" +  info.getActivityNamespace());\n    log.info(\"workflowId=\" + info.getWorkflowId());\n    log.info(\"runId=\" + info.getRunId());\n    log.info(\"activityId=\" + info.getActivityId());\n    log.info(\"activityTimeout=\" + info.getStartToCloseTimeout();\n\n    return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n  }\n    ...\n}\n```\n\nFor details on getting the results of an Activity Execution, see [Activity Execution Result](/java/how-to-get-the-result-of-an-activity-execution-in-java).\n","is_empty":false},{"file_name":"how-to-use-queries-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-use-queries-in-java.md","id":317,"title":"How to use Queries in Java","description":"Define a Query method inside the Workflow interface, annotated with the `@QueryMethod` annotation and call the method from an external process.","label":"Queries","tags":["java","developer-guide"],"markdown_content":"\nTo use Queries to query the state of a Workflow at any stage of the Workflow Execution, create a Query handler using the `@QueryMethod` annotation in the Workflow interface and call the method in your external process.\n\nYou can send a Query to an open or closed Workflow Execution.\n\nWhen using Queries, the following restrictions apply:\n\n- It cannot modify Workflow state in any way.\n- It is not allowed to block its thread in any way.\n\n### Define Query Method\n\nimport DefineQuery from './how-to-define-a-query-in-java.md'\n\n<DefineQuery/>\n\n### Handle Query\n\nimport HandleQuery from './how-to-handle-a-query-in-a-workflow-in-java.md'\n\n<HandleQuery/>\n\n### Send Query from Temporal Client\n\nimport SendQuery from './how-to-send-a-query-to-a-workflow-in-java.md'\n\n<SendQuery/>\n","is_empty":false},{"file_name":"how-to-use-signals-in-java.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/how-to-use-signals-in-java.md","id":318,"title":"How to use Signals in Java","description":"Initiate the Signal method with `@SignalMethod` annotation in the Workflow interface and call it either directly from the Client or from within another Workflow.","label":"Signals","tags":["java","developer-guide"],"markdown_content":"\nTo use Signals in Java, initiate the Signal method with `@SignalMethod` annotation in the Workflow interface and call the Signal method either directly from the Client or use `ExternalWorkflowStub` to call the Signal method from within another Workflow.\n\nA Signal method can be called from either a Client or another Workflow to send Signals to this Workflow.\n\nNote that you can send a Signal only to running Workflow Executions.\nYou can use Signals to update the state of a running Workflow Execution.\n\n### Define Signal Method\n\nimport DefineSignal from './how-to-define-a-signal-in-java.md'\n\n<DefineSignal/>\n\n### Handle Signal\n\nimport HandleSignal from './how-to-handle-a-signal-in-a-workflow-in-java.md'\n\n<HandleSignal/>\n\n### Send Signal from Temporal Client\n\nimport SendSignalClient from './how-to-send-a-signal-from-a-client-in-java.md'\n\n<SendSignalClient/>\n\n### Send Signal from within a Workflow\n\nimport SendSignalWorkflow from './how-to-send-a-signal-from-a-workflow-in-java.md'\n\n<SendSignalWorkflow/>\n\n### Signal-With-Start\n\nimport SignalWithStart from './how-to-send-a-signal-with-start-in-java.md'\n\n<SignalWithStart/>\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/index.md","id":319,"title":"How to use the Temporal Java SDK","description":"Add the Temporal Java SDK to your project.","label":"Java How-to","tags":["developer-guide","Java"],"markdown_content":"\n[![Build status](https://badge.buildkite.com/663f6d1be81be6700c28c242b35905f20b68c4fda7b2c7c4e3.svg?branch=master)](https://buildkite.com/temporal/java-sdk-public)\n\nAdd the [Temporal Java SDK](https://github.com/temporalio/sdk-java) to your project as a dependency:\n\n**[Apache Maven](https://maven.apache.org/)**:\n\n```maven\n<dependency>\n  <groupId>io.temporal</groupId>\n  <artifactId>temporal-sdk</artifactId>\n  <version>1.11.0</version>\n</dependency>\n```\n\n**[Gradle Groovy DSL](https://gradle.org/)**:\n\n```groovy\nimplementation 'io.temporal:temporal-sdk:1.11.0'\n```\n\n**Other**:\n\nAdditional scripts for each SDK version are available here: [https://search.maven.org/artifact/io.temporal/temporal-sdk](https://search.maven.org/artifact/io.temporal/temporal-sdk).\nSelect an SDK version to see available scripts.\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/queries.md","id":320,"title":"Queries in Java","label":"Queries","tags":["java"],"markdown_content":"\nWorkflow queries can be used to query a Workflow state by external processes at any time during its execution.\nQuery methods can only be defined inside Workflows Interfaces and are methods annotated with the `@QueryMethod` annotation, for example:\n\n```java\n  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @QueryMethod\n    int getCount();\n  }\n```\n\nNotice that the `getCount` method is annotated with `@QueryMethod`.\nThere can be multiple Query methods per Workflow interface.\n\nThe `QueryMethod` annotation has an optional `name` property which can be used to define the query type.\nIf not specified it defaults to the method name.\n\nLet's look at a Workflow implementation and its query method:\n\n```java\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = \"Hello\";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!\"Bye\".equals(greeting)) {\n        logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n```\n\nThe restrictions on the implementation of the Query method are the following:\n\n- It can not modify Workflow state in any way.\n- It is not allowed to block its thread in any way.\n\nThe Query method usually just returns a value derived from the fields of the Workflow object.\n\nQuery methods can take in any number of input parameters which can be used to limit the data that is returned for example.\n","is_empty":false},{"file_name":"reference-activityoptions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/reference-activityoptions.md","id":321,"title":"Java ActivityOptions reference","description":"Use `ActivityOptions` to configure how to invoke an Activity Execution.","label":"Activity Options reference","tags":["developer-guide","how-to","java"],"markdown_content":"\nUse [`ActivityOptions`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/activity/ActivityOptions.Builder.html) to configure how to invoke an Activity Execution.\n\nYou can set Activity Options using an `ActivityStub` within a Workflow implementation, or per-Activity using `WorkflowImplementationOptions` within a Worker.\nNote that if you define options per-Activity Type options with `WorkflowImplementationOptions.setActivityOptions()`, setting them again specifically with `ActivityStub` in a Workflow will override this setting.\n\nThe following table lists all `ActivityOptions` that can be configured for an Activity invocation.\n\n| Option                                                 | Required                                           | Type                     |\n| ------------------------------------------------------ | -------------------------------------------------- | ------------------------ |\n| [`setScheduleToCloseTimeout`](#scheduletoclosetimeout) | Yes (if `StartToCloseTimeout` is not specified)    | Duration                 |\n| [`setScheduleToStartTimeout`](#scheduletostarttimeout) | No                                                 | Duration                 |\n| [`setStartToCloseTimeout`](#starttoclosetimeout)       | Yes (if `ScheduleToCloseTimeout` is not specified) | Duration                 |\n| [`setHeartbeatTimeout`](#heartbeattimeout)             | No                                                 | Duration                 |\n| [`setTaskQueue`](#taskqueue)                           | No                                                 | String                   |\n| [`setRetryOptions`](#retryoptions)                     | No                                                 | RetryOptions             |\n| [`setCancellationType`](#cancellationtype)             | No                                                 | ActivityCancellationType |\n\n### `ScheduleToCloseTimeout`\n\nimport ScheduleToCloseTimeout from './how-to-set-a-schedule-to-close-timeout-in-java.md'\n\n<ScheduleToCloseTimeout/>\n\n### `ScheduleToStartTimeout`\n\nimport ScheduleToStartTimeout from './how-to-set-a-schedule-to-start-timeout-in-java.md'\n\n<ScheduleToStartTimeout/>\n\n### `StartToCloseTimeout`\n\nimport StartToCloseTimeout from './how-to-set-a-start-to-close-timeout-in-java.md'\n\n<StartToCloseTimeout/>\n\n### `HeartbeatTimeout`\n\nimport HeartbeatTimeout from './how-to-set-a-heartbeat-timeout-in-java.md'\n\n<HeartbeatTimeout/>\n\n### `TaskQueue`\n\n- Type: `String`\n- Default: Defaults to the Task Queue that the Workflow was started with.\n\n- With `ActivityStub`\n\n  ```java\n  GreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are required when\n                          // setting Activity options.\n                          .setStartToCloseTimeout(Duration.ofSeconds(5))\n                          .setTaskQueue(\"yourTaskQueue\")\n                          .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                            // required when setting Activity options.\n                                            .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                            .setTaskQueue(\"yourTaskQueue\")\n                                            .build()))\n                      .build();\n  ```\n\nSee [Task Queue](/concepts/what-is-a-task-queue)\n\n### `RetryOptions`\n\nimport ActivityRetryOptions from './how-to-set-activity-retry-options-in-java.md'\n\n<ActivityRetryOptions/>\n\n### `setCancellationType`\n\n- Type: `ActivityCancellationType`\n- Default: `ActivityCancellationType.TRY_CANCEL`\n\n- With `ActivityStub`\n\n  ```java\n  private final GreetingActivities activities =\n    Workflow.newActivityStub(\n        GreetingActivities.class,\n        ActivityOptions.newBuilder()\n            .setCancellationType(ActivityCancellationType.WAIT_CANCELLATION_COMPLETED)\n            .build());\n  ```\n\n- With `WorkflowImplementationOptions`\n\n  ```java\n  WorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                .setCancellationType(ActivityCancellationType.WAIT_CANCELLATION_COMPLETED)\n                                .build()))\n                .build();\n  ```\n","is_empty":false},{"file_name":"reference-workflowoptions.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/reference-workflowoptions.md","id":322,"title":"Java WorkflowOptions reference","description":"Create a `newWorkflowStub` in the Temporal Client code, call the instance of the Workflow, and set the Workflow options with the `WorkflowOptions.Builder` class.","label":"Workflow Options reference","tags":["developer-guide","options"],"markdown_content":"\nCreate a [`newWorkflowStub`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html) in the Temporal Client code, call the instance of the Workflow, and set the Workflow options with the [`WorkflowOptions.Builder`](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html) class.\n\nThe following fields are available:\n\n| Option                                                  | Required             | Type                                                                                                                 |\n| ------------------------------------------------------- | -------------------- | -------------------------------------------------------------------------------------------------------------------- |\n| [`WorkflowId`](#id)                                     | No (but recommended) | String                                                                                                               |\n| [`TaskQueue`](#taskqueue)                               | **Yes**              | String                                                                                                               |\n| [`WorkflowExecutionTimeout`](#workflowexecutiontimeout) | No                   | `Duration`                                                                                                           |\n| [`WorkflowRunTimeout`](#workflowruntimeout)             | No                   | `Duration`                                                                                                           |\n| [`WorkflowTaskTimeout`](#workflowtasktimeout)           | No                   | `Duration`                                                                                                           |\n| [`WorkflowIdReusePolicy`](#workflowidreusepolicy)       | No                   | `WorkflowIdReusePolicy`                                                                                              |\n| [`RetryOptions`](#retryoptions)                         | No                   | [`RetryOptions`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.11.0/io/temporal/common/RetryOptions.html) |\n| [`CronSchedule`](#cronschedule)                         | No                   | String                                                                                                               |\n| [`Memo`](#memo)                                         | No                   | string                                                                                                               |\n| [`SearchAttributes`](#searchattributes)                 | No                   | Map<String, Object>                                                                                                  |\n\n### `Id`\n\nimport WorkflowId from './how-to-set-a-workflow-id-in-java.md'\n\n<WorkflowId/>\n\n### `TaskQueue`\n\nimport TaskQueue from './how-to-set-a-workflow-task-queue-in-java.md'\n\n<TaskQueue/>\n\n### `WorkflowExecutionTimeout`\n\nimport WFETimeout from './how-to-set-a-workflow-execution-timeout-in-java.md'\n\n<WFETimeout/>\n\n### `WorkflowRunTimeout`\n\nimport WFRTimeout from './how-to-set-a-workflow-run-timeout-in-java.md'\n\n<WFRTimeout/>\n\n### `WorkflowTaskTimeout`\n\nimport WFTTimeout from './how-to-set-a-workflow-task-timeout-in-java.md'\n\n<WFTTimeout/>\n\n### `WorkflowIDReusePolicy`\n\n- Type: `WorkflowIdReusePolicy`\n- Default: `enums.AllowDuplicateFailedOnly` is the default value. It means that the Workflow can start a new run if the previous run failed, was canceled, or was terminated.\n- Values: `AllowDuplicate` allows a new run independently of the previous run closure status.\n  `RejectDuplicate` doesn't allow a new run independently of the previous run closure status.\n\n````java\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Id Reuse Policy\n                .setWorkflowIdReusePolicy(\n                        WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE)\n                .build());\n````\n\n### `RetryOptions`\n\nimport RetryOptions from './how-to-set-workflow-retry-options-in-java.md'\n\n<RetryOptions/>\n\n### `CronSchedule`\n\nimport CronSchedule from './how-to-set-a-cron-schedule-in-java.md'\n\n<CronSchedule/>\n\n### `Memo`\n\n- Type: `String`\n- Default: None\n\n```java\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Memo. You can set additional non-indexed info via Memo\n                        .setMemo(ImmutableMap.of(\n                                \"memoKey\", \"memoValue\"\n                        ))\n                .build());\n```\n\n### `SearchAttributes`\n\nSearch Attributes are additional indexed information attributed to Workflow and used for search and visibility.\nThese can be used in a query of List/Scan/Count Workflow APIs.\nThe key and its value type must be registered on Temporal server side.\n\n- Type: `Map<String, Object>`\n- Default: None\n\n```java\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // Set Search Attributes\n                        .setSearchAttributes(ImmutableMap.of(\"MySearchAttributeNAme\", \"value\"))\n                        .build();\n```\n\nThe following Java types are supported:\n\n- String\n- Long, Integer, Short, Byte\n- Boolean\n- Double\n- OffsetDateTime\n- Collection of the types in this list.\n","is_empty":false},{"file_name":"side-effect.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/side-effect.md","id":323,"title":"SideEffect","markdown_content":"\nWorkflow code must be deterministic.\nThis is important so Temporal can replay your Workflow to the point of failure and continue its execution.\n\nWorkflow code that includes arbitrary side effects (for example getting a random number or generating a random UUID, etc), can cause unpredictable results during replay.\n\nBeing able to add some non-deterministic code inside your Workflow is in some cases important, and you can do that using `Workflow.sideEffect`.\n\nThe following sample demonstrates how to use it:\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.sideEffect( int.class, () -> {\n        Random random = new SecureRandom();\n        return random.nextInt();\n    });\n\n    String userHome = Workflow.sideEffect(String.class, () -> System.getenv(\"USER_HOME\"));\n\n    if(randomInt % 2 == 0) {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n\nThe result of `Workflow.sideEffect` is recorded into the Workflow history, meaning that during a replay it will be returned from the history without executing its code again.\n\nNote that you shouldn't modify the Workflow state inside `Workflow.sideEffect`.\nFor that you should only use the `Workflow.sideEffect` return value.\n\nThe Temporal Java SDK provides deterministic methods to generate a random number, or a random UUID as well:\n\n```java\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.newRandom().nextInt();\n\n    String randomUUID = Workflow.randomUUID().toString();\n\n    // ...\n}\n```\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/signals.md","id":324,"title":"Signals in Java","label":"Signals","tags":["java"],"markdown_content":"\nimport {RelatedReadContainer, RelatedReadItem} from '../components/RelatedReadList.js'\n\n<!-- prettier-ignore -->\nimport * as WhatIsASignal from '../concepts/what-is-a-signal.md'\n\n<RelatedReadContainer>\n  <RelatedReadItem page={WhatIsASignal} />\n</RelatedReadContainer>\n\nSignal methods can only be defined inside Workflows Interfaces and are methods annotated with the `@SignalMethod` annotation, for example:\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n\n    @SignalMethod\n    void exit();\n}\n```\n\nA Workflow interface can define any number of signal methods.\n\nNote that the `@SignalMethod` interface has a `name` parameter which can be used to set the signal type.\nIf not specified, the signal type defaults to the name of the method.\n\nThe following example shows how signals can be used to update the Workflow state.\nYou can use the `Workflow.await` to block the current Workflow execution until the provided unblock condition is evaluated\nto `true`. In our case, the unblocking condition is evaluated to `true` when we receive a signal that updates the greeting\nto something different from the current greeting. This workflow completes when the greeting becomes \"Bye\".\n\n```java\n@WorkflowInterface\npublic interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n}\n```\n\n```java\npublic class HelloWorldImpl implements HelloWorld {\n    private final Logger workflowLogger = Workflow.getLogger(HelloWorldImpl.class);\n    private String greeting;\n\n    @Override\n    public void sayHello(String name) {\n        int count = 0;\n        while (!\"Bye\".equals(greeting)) {\n            String oldGreeting = greeting;\n            Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n        }\n        workflowLogger.info(++count + \": \" + greeting + \" \" + name + \"!\");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n        this.greeting = greeting;\n    }\n}\n```\n","is_empty":false},{"file_name":"task-queues.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/task-queues.md","id":325,"title":"Task Queues in Java","label":"Task Queues","markdown_content":"\nIn Java, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```java\npublic class InitiateWorkflow {\n\n  public static void main(String[] args) throws Exception {\n    // Create the WorkflowClient\n    // ...\n    WorkflowOptions options = WorkflowOptions.newBuilder()\n      .setTaskQueue(\"Workflow-Task-Queue-1\")\n      .build();\n    // pass the options to the Workflow stub\n    HelloWorldWorkflow workflow = client.newWorkflowStub(\n      WorkflowImplementation.class,\n      options\n    );\n    // Call the Workflow method on the implementation\n    // ...\n  }\n}\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```java\npublic class YourWorker {\n\n  public static void main(String[] args) {\n    // Create the WorkflowClient\n    // ...\n    // Create a Worker factory that can be used to create Workers that poll specific Task Queues.\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker(\"Workflow-Task-Queue-1\");\n    // Register Workflow implementation classes\n    worker.registerWorkflowImplementationTypes(YourdWorkflowImpl.class);\n    // Start polling the Task Queue.\n    factory.start();\n  }\n}\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```java\npublic class YourWorkflowImpl implements YourWorkflow {\n\n  ActivityOptions activityOptions = ActivityOptions.newBuilder()\n    .setTaskQueue(\"Activity-Task-Queue-1\")\n    // ...\n    .build();\n  // Pass the options to the new ActivityStub\n  private final YourActivity yourActivity = Workflow.newActivityStub(\n    YourActivity.class,\n    activityOptions\n  );\n  // Call the Activity from within the Workflow method\n  @Override\n  public String workflowMethod() {\n    return yourActivity.somemethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```java\npublic static class YourWorkflowImpl implements YourWorkflow {\n\n  @Override\n  public String workflowMethod() {\n\n    // Set the Task Queue in the Child Workflow options\n    ChildWorkflowOptions childWorkflowOptions =\n      ChildWorkflowOptions.newBuilder()\n        .setTaskQueue(\"Child-Workflow-Task-Queue-1\")\n        // ...\n        .build();\n    // Pass the options to the new Child Workflow Stub\n    ChildWorkflow childWorkflow = Workflow.newChildWorkflowStub(\n      ChildWorkflow.class,\n      childWorkflowOptions\n    );\n    // Call the Child Workflow method\n    String result = childWorkflow.workflowMethod(...);\n    return result;\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.\n","is_empty":false},{"file_name":"testing-and-debugging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/testing-and-debugging.md","id":326,"title":"Testing and Debugging","label":"Testing and Debugging","markdown_content":"\n## Overview\n\nThe Temporal Java SDK provides a test framework to facilitate Workflow unit and integration testing.\nThe test framework provides a `TestWorkflowEnvironment` class which includes an in-memory implementation\nof the Temporal service that supports automatic time skipping. This allows you to\neasily test long-running Workflows in seconds, without having to change your Workflow code.\n\nYou can use the provided `TestWorkflowEnvironment` with a Java unit testing framework of your choice,\nsuch as JUnit.\n\n## Setup testing dependency\n\nTo start using the Java SDK test framework, you need to add [`io.temporal:temporal-testing`](https://search.maven.org/artifact/io.temporal/temporal-testing)\nas a dependency to your project:\n\n**[Apache Maven](https://maven.apache.org/)**:\n\n```maven\n<dependency>\n    <groupId>io.temporal</groupId>\n    <artifactId>temporal-testing</artifactId>\n    <version>1.11.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\n**[Gradle Groovy DSL](https://gradle.org/)**:\n\n```groovy\ntestImplementation (\"io.temporal:temporal-testing:1.11.0\")\n```\n\nMake sure to set the version that matches your dependency version of the [Temporal Java SDK](https://github.com/temporalio/sdk-java).\n\n## Sample unit tests\n\nThe following code implements unit tests for the `HelloActivity` sample:\n\n```java\npublic class HelloActivityTest {\n\n    private TestWorkflowEnvironment testEnv;\n    private Worker worker;\n    private WorkflowClient client;\n\n    // Set up the test workflow environment\n    @Before\n    public void setUp() {\n        testEnv = TestWorkflowEnvironment.newInstance();\n        worker = testEnv.newWorker(TASK_QUEUE);\n        // Register your workflow implementations\n        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n\n        client = testEnv.getWorkflowClient();\n    }\n\n    // Clean up test environment after tests are completed\n    @After\n    public void tearDown() {\n        testEnv.close();\n    }\n\n    @Test\n    public void testActivityImpl() {\n        // This uses the actual activity impl\n        worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n\n        // Start test environment\n        testEnv.start();\n\n        // Create the workflow stub\n        GreetingWorkflow workflow =\n                client.newWorkflowStub(\n                        GreetingWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).build());\n\n        // Execute our workflow waiting for it to complete\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n    }\n}\n```\n\nIn cases where you do not wish to execute your actual Activity implementations during\nunit testing, you can use a framework such as Mockito to mock them.\n\nThe following code implements a unit test for the `HelloActivity` sample which shows\nhow activities can be mocked:\n\n```java\npublic class HelloActivityTest {\n\n    private TestWorkflowEnvironment testEnv;\n    private Worker worker;\n    private WorkflowClient client;\n\n    // Set up the test workflow environment\n    @Before\n    public void setUp() {\n        testEnv = TestWorkflowEnvironment.newInstance();\n        worker = testEnv.newWorker(TASK_QUEUE);\n        // Register your workflow implementations\n        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n\n        client = testEnv.getWorkflowClient();\n    }\n\n    // Clean up test environment after tests are completed\n    @After\n    public void tearDown() {\n        testEnv.close();\n    }\n\n    @Test\n    public void testMockedActivity() {\n        // Mock our workflow activity\n        GreetingActivities activities = mock(GreetingActivities.class);\n        when(activities.composeGreeting(\"Hello\", \"World\")).thenReturn(\"Hello Mocked World!\");\n        worker.registerActivitiesImplementations(activities);\n\n        // Start test environment\n        testEnv.start();\n\n        // Create the workflow stub\n        GreetingWorkflow workflow =\n                client.newWorkflowStub(\n                        GreetingWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).build());\n\n        // Execute our workflow waiting for it to complete\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello Mocked World!\", greeting);\n    }\n}\n```\n\n## Testing with JUnit4\n\nFor Junit4 tests, Temporal provides the TestWorkflowRule class which simplifies the Temporal test environment setup, as well as the\ncreation and shutdown of Workflow Workers in your tests.\n\nMake sure to set the version that matches your dependency version of the [Temporal Java SDK](https://github.com/temporalio/sdk-java).\n\nWe can now rewrite our above mentioned \"HelloActivityTest\" test class as follows:\n\n```java\npublic class HelloActivityJUnit4Test {\n    @Rule\n    public TestWorkflowRule testWorkflowRule =\n            TestWorkflowRule.newBuilder()\n                    .setWorkflowTypes(GreetingWorkflowImpl.class)\n                    .setActivityImplementations(new GreetingActivitiesImpl())\n                    .build();\n\n    @Test\n    public void testActivityImpl() {\n        // Get a workflow stub using the same task queue the worker uses.\n        GreetingWorkflow workflow =\n                testWorkflowRule\n                        .getWorkflowClient()\n                        .newWorkflowStub(\n                                GreetingWorkflow.class,\n                                WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build());\n        // Execute a workflow waiting for it to complete.\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n\n        testWorkflowRule.getTestEnvironment().shutdown();\n    }\n}\n```\n\n## Testing with JUnit5\n\nFor Junit5 tests, Temporal also provides the TestWorkflowExtension helped class which can be used to simplify the Temporal test environment setup\nas well as Workflow Worker startup and shutdowns.\n\nTo start using JUnit5 TestWorkflowExtension in your tests with [Gradle](https://gradle.org/), you need to enable capability [`io.temporal:temporal-testing-junit5`]:\n\nMake sure to set the version that matches your dependency version of the [Temporal Java SDK](https://github.com/temporalio/sdk-java).\n\nWe can now use JUnit5 and rewrite our above mentioned \"HelloActivityTest\" test class as follows:\n\n```java\npublic class HelloActivityJUnit5Test {\n    @RegisterExtension\n    public static final TestWorkflowExtension testWorkflowExtension =\n            TestWorkflowExtension.newBuilder()\n                    .setWorkflowTypes(GreetingWorkflowImpl.class)\n                    .setActivityImplementations(new GreetingActivitiesImpl())\n                    .build();\n\n    @Test\n    public void testActivityImpl(\n            TestWorkflowEnvironment testEnv, Worker worker, GreetingWorkflow workflow) {\n        // Execute a workflow waiting for it to complete.\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n    }\n}\n```\n\nYou can find all unit tests for the [Temporal Java samples](https://github.com/temporalio/samples-java) repository in [its test package](https://github.com/temporalio/samples-java/tree/master/src/test/java/io/temporal/samples).\n\n## Debugging\n\nIn addition to writing unit and integration tests, debugging your Workflows is also a very\nvaluable testing tool. You can debug your Workflow code using a debugger provided\nby your favorite Java IDE.\n\nNote that when debugging your Workflow code, the Temporal Java SDK includes deadlock detection\nwhich fails a Workflow Task in case the code blocks over a second without relinquishing\nexecution control. Because of this you can often encounter the `PotentialDeadlockException`\nException while stepping through Workflow code during debugging.\n\nTo alleviate this issue, you can set the `TEMPORAL_DEBUG` environment variable to true before debugging your\nWorkflow code. Make sure to set `TEMPORAL_DEBUG` to true only during debugging.\n","is_empty":false},{"file_name":"versioning.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/versioning.md","id":327,"title":"Versioning","markdown_content":"\nAs outlined in the _Workflow Implementation Constraints_ section, Workflow code has to be deterministic by taking the same\ncode path when replaying history events. Any Workflow code change that affects the order in which commands are generated breaks\nthis assumption. The solution that allows updating code of already running Workflows is to keep both the old and new code.\nWhen replaying, use the code version that the events were generated with and when executing a new code path, always take the\nnew code.\n\n## Introduction to Versioning\n\nBecause we design for potentially long running workflows at scale, versioning with Temporal works differently than with other workflow systems. We explain more in this optional 30 minute introduction: [https://www.youtube.com/watch?v=kkP899WxgzY](https://www.youtube.com/watch?v=kkP899WxgzY)\n\n## Java Versioning API\n\nUse the `Workflow.getVersion` function to return a version of the code that should be executed and then use the returned\nvalue to pick a correct branch. Let's look at an example.\n\n```java\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\nNow we decide to calculate the processed file checksum and pass it to upload.\nThe correct way to implement this change is:\n\n```java\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        int version = Workflow.getVersion(\"checksumAdded\", Workflow.DEFAULT_VERSION, 1);\n        if (version == Workflow.DEFAULT_VERSION) {\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } else {\n            long checksum = activities.calculateChecksum(processedName);\n            activities.uploadWithChecksum(\n                args.getTargetBucketName(), args.getTargetFilename(), processedName, checksum);\n        }\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\nLater, when all Workflows that use the old version are completed, the old branch can be removed.\n\n```java\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        // getVersion call is left here to ensure that any attempt to replay history\n        // for a different version fails. It can be removed later when there is no possibility\n        // of this happening.\n        Workflow.getVersion(\"checksumAdded\", 1, 1);\n        long checksum = activities.calculateChecksum(processedName);\n        activities.uploadWithChecksum(\n            args.getTargetBucketName(), args.getTargetFilename(), processedName, checksum);\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\nThe Id that is passed to the `getVersion` call identifies the change. Each change is expected to have its own Id. But if\na change spawns multiple places in the Workflow code and the new code should be either executed in all of them or\nin none of them, then they have to share the Id.\n","is_empty":false},{"file_name":"workers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/workers.md","id":328,"title":"Workers in Java","label":"Workers","markdown_content":"\n## What is a Worker?\n\nA Worker is a service that executes [Workflows](/java/workflows) and [Activities](/java/activities).\nWorkers are defined and executed on user controlled hosts.\nYou can use the `WorkerFactory` class to create and run as many Workers as your use case demands, across any number of hosts.\n\nWorkers poll Task Queues for Tasks, execute chunks of code in response to those Tasks, and then communicate the results back to the Temporal Server.\n\nAs a developer, running Workers is a fairly simple procedure,\nbecause the Java SDK handles all the communication between the Worker and the Temporal Server behind the scenes.\n\n## How to start a Worker\n\nTo start a Worker you need to:\n\n1. Create a WorkflowClient instance\n2. Optionally create WorkerOptions\n3. Create a WorkerFactory instance\n4. Create a Worker using the created WorkerFactory's `newWorker` method\n5. Register Workflows and Activities this Worker should execute\n\nAs a simple example, let's say we want our Worker to be able to execute the following Workflow implementation:\n\n```java\npublic static class EmployeeWorkflowImpl implements EmployeeWorkflow {\n\n    private final EmployeeActivities activities =\n        Workflow.newActivityStub(\n                EmployeeActivities.class,\n            ActivityOptions.newBuilder().setStartToCloseTimeout(Duration.ofSeconds(2)).build());\n\n    @Override\n    public Employee getEmployee(String id) {\n      return activities.getEmployeeById(id);\n    }\n  }\n```\n\nOur Workflow invokes `EmployeeActivities` Activities. We can register our Workflow with our Worker:\n\n```java\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\nWorkflowClient client = WorkflowClient.newInstance(service);\nWorkerFactory factory = WorkerFactory.newInstance(client);\n\nWorker worker = factory.newWorker(TASK_QUEUE_NAME);\n\nworker.registerWorkflowImplementationTypes(EmployeeWorkflowImpl.class);\n```\n\nNote that in order to execute our `EmployeeWorkflowImpl` Workflow implementation, there is no need to register any Activities.\nOnly if our created Worker is also used to host the Activity implementations we should register them as well by adding for example:\n\n```java\nString connectionUrl = \"jdbc:sqlserver://localhost:1433;databaseName=EmployeesDb;user=user;password=pass\";\nworker.registerActivitiesImplementations(new EmployeeActivitiesImpl(connectionUrl));\n```\n\nFor Workflows we register the Workflow type.\nFor Activities, since they are stateless and thread-safe, we need\nto register an Activity instance.\n\nWhen you start a Workflow or when a Workflow needs to invoke an Activity, the Temporal Server adds\na new task to the Workflows / Activity Task Queue. Any Worker polling that Task Queue and has that Workflow / Activity\nregistered can pick up the new task and execute it.\n","is_empty":false},{"file_name":"workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/java/workflows.md","id":329,"title":"Workflows in Java","description":"The core abstraction of the Temporal solution is a fault-oblivious stateful Workflow.","label":"Workflows","markdown_content":"\nimport RelatedReadList from '../components/RelatedReadList.js'\n\n## What is a Workflow?\n\nWorkflows are resilient programs, meaning that they will continue execution even in the presence of\ndifferent failure conditions.\n\nWorkflows encapsulate execution/orchestration of Tasks which include Activities and child Workflows.\nThey also need to react to external events, respond to query requests, and deal with Timeouts.\n\nIn the Temporal Java SDK programming model, a Workflow is a class which implements a Workflow Interface:\n\n```java\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n  // ...\n}\n```\n\nThe Workflow Interface is a Java interface which is annotated with the `@WorkflowInterface` annotation.\n\n## Workflow Interface\n\nWorkflow interface methods must have one of the following annotations:\n\n- **@WorkflowMethod** denotes the starting point of Workflow execution. Workflow execution completes when this methods returns.\n- **@SignalMethod** indicates that this method is a signal handler method and that it can react to external signals. It can have parameters which can contain the signal payload. It does not return a value, so it must have a `void` return type.\n- **@QueryMethod** indicates that this method can be used to query the Workflow's state at any time during its execution.\n  It can have parameters which can be used to filter a subset of the Workflow's state that it returns. Since it does return a value it must have a non `void` return type.\n\nWorkflow interfaces can define only a single method annotated with `@WorkflowMethod`. They can define\nany number of methods annotated with `@SignalMethod` and `@QueryMethod`, for example:\n\n```java\n@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n    @WorkflowMethod\n    String processFile(Arguments args);\n\n    @QueryMethod(name=\"history\")\n    List<String> getHistory();\n\n    @QueryMethod\n    String getStatus();\n\n    @SignalMethod\n    void retryNow();\n\n    @SignalMethod\n    void abandon();\n}\n```\n\nThe `@WorkflowMethod` annotation has a `name` parameter, for example: `@WorkflowMethod(name = \"YourWorkflowType\")`.\nIt can be used to denote the Workflow type. If not set, the Workflow type defaults to the short name of the Workflow interface,\nin the example above being `FileProcessingWorkflow`.\nMethods annotated with `@WorkflowMethod` can have any number of parameters.\nWe recommend passing a single parameter that contains all the input fields.\nThis allows adding fields in a backward compatible manner.\n\nThe `@QueryMethod` annotation also has a `name` parameter, for example: `@QueryMethod(name = \"history\")`. It can be\nused to denote the query name. If not set, the query name defaults to the name of the method, in the example above\nbeing `getStatus`.\n\nThe `@SignalMethod` too has a `name` parameter, for example: `@SignalMethod(name = \"mysignal\")`. It can be used to denote the\nsignal type. If not set, the signal type defaults to the name of the method, in the example above being `retryNow` and `abandon`.\n\n### Workflow Interface Inheritance\n\nWorkflow interfaces can form inheritance hierarchies. It may be useful for creating components reusable across multiple\nWorkflow interfaces. For example imaging a UI or CLI button that allows to call `retryNow` signal on any Workflow. To implement\nthis feature you can redesign the above interface to:\n\n```java\npublic interface Retryable {\n    @SignalMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface FileProcessingWorkflow extends Retryable {\n\n    @WorkflowMethod\n    String processFile(Arguments args);\n\n    @QueryMethod(name=\"history\")\n    List<String> getHistory();\n\n    @QueryMethod\n    String getStatus();\n\n    @SignalMethod\n    void abandon();\n}\n```\n\nThen some other Workflow interface can extend just `Retryable`, for example:\n\n```java\n@WorkflowInterface\npublic interface MediaProcessingWorkflow extends Retryable {\n\n    @WorkflowMethod\n    String processBlob(Arguments args);\n}\n```\n\nNow if we have two running Workflows, one that implements the `FileProcessingWorkflow` interface and another that implements the\n`MediaProcessingWorkflow` interface, we can signal to both using their common interface and knowing their workflowIds, for example:\n\n```java\nRetryable r1 = client.newWorkflowStub(Retryable.class, firstWorkflowId);\nRetryable r2 = client.newWorkflowStub(Retryable.class, secondWorkflowId);\nr1.retryNow();\nr2.retryNow();\n```\n\nThe same technique can be used to query Workflows using a base Workflow interface.\n\nNote that this approach does not apply to `@WorkflowMethod` annotations, meaning that when using a base interface, it should\nnot include any `@WorkflowMethod` methods.\nTo illustrate this, lets' say that we define the following **invalid** code:\n\n```java\n// INVALID CODE!\npublic interface BaseWorkflow {\n    @WorkflowMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface Workflow1 extends BaseWorkflow {}\n\n@WorkflowInterface\npublic interface Workflow2 extends BaseWorkflow {}\n```\n\nIf we attempt to register implementations of Workflow1 and Workflow2 with a Worker will fail. Let's say that we have:\n\n```java\nworker.registerWorkflowImplementationTypes(\n        Workflow1Impl.class, Workflow2Impl.class);\n```\n\nThis registration will fail with:\n\n```text\njava.lang.IllegalStateException: BaseWorkflow workflow type is already registered with the worker\n```\n\n## Implementing Workflows\n\nA Workflow implementation implements a Workflow interface. Each time a new Workflow execution is started,\na new instance of the Workflow implementation object is created.\nThen, one of the methods\n(depending on which Workflow type has been started) annotated with `@WorkflowMethod` can be invoked.\nAs soon as this method returns, the Workflow execution is considered as completed.\n\nWorkflow methods annotated with `@QueryMethod` and `@SignalMethod` can be invoked during a Workflow's execution.\n\nNote that methods annotated with `@QueryMethod` can be invoked even when a Workflow is in the `Completed`\nstate.\n\n### Workflow Implementation Constraints\n\nTemporal uses the [Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover\nthe state of a Workflow object including its threads and local variable values.\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nNote that during replay, successfully executed Activities are not re-executed as their results are already recorded\nin the Workflow event history.\n\nEven though Temporal has the replay capability, which brings resilience to your Workflows, you should never think about\nthis capability when writing your Workflows.\nInstead, you should focus on implementing your business logic/requirements and write your Workflows\nas they would execute only once.\n\nThere are some things however to think about when writing your Workflows, namely determinism and isolation.\nWe summarize these constraints here:\n\nThey shouldn't use any constructs that rely on system time.\n\n- Do not use any mutable global variables in your Workflow implementations. This will assure that multiple Workflow instances are fully isolated.\n- Do not call any non-deterministic functions like non seeded random or UUID.randomUUID() directly from the Workflow code. The Temporal SDK provides specific API for calling non-deterministic code in your Workflows, which we will show later on in this document.\n- Perform all IO operations and calls to third-party services on Activities and not Workflows, as they are usually non-deterministic in nature.\n- Do not use any programming language constructs that rely on system time. For example, only use `Workflow.currentTimeMillis()` to get the current time inside a Workflow.\n- Do not use native Java `Thread` or any other multi-threaded classes like `ThreadPoolExecutor`. Use `Async.function` or `Async.procedure`,\n  provided by the Temporal SDK, to execute code asynchronously.\n- Don't use any synchronization, locks, and other standard Java blocking concurrency-related classes besides those provided\n  by the Workflow class. There is no need in explicit synchronization because multi-threaded code inside a Workflow is\n  executed one thread at a time and under a global lock.\n  - Call `Workflow.sleep` instead of `Thread.sleep`.\n  - Use `Promise` and `CompletablePromise` instead of `Future` and `CompletableFuture`.\n  - Use `WorkflowQueue` instead of `BlockingQueue`.\n- Use `Workflow.getVersion` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already running Workflows.\n- Don’t access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\n### Workflow Method Arguments\n\n- [What is a Data Converter?](/concepts/what-is-a-data-converter)\n\nJava DataConverter reference: https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html\n\n## Workflow Activities\n\nTo learn about Workflow Activities visit [this page](/java/activities).\n\n## Child Workflows\n\nBesides Activities, a Workflow can also start other Workflows.\n\n<RelatedReadList\nreadlist={[\n[\"What is a Child Workflow Execution?\",\"/concepts/what-is-a-child-workflow-execution\",\"explanation\"],  \n]}\n/>\n\n### Java Child Workflow API\n\n`Workflow.newChildWorkflowStub` returns a client-side stub that implements a child Workflow interface.\nIt takes a child Workflow type and optional child Workflow options as arguments. Workflow options can be used\nto set timeout, retry options, and task queue settings for example.\nNote that by default a child Workflow inherits the Workflow options of its parent. You can however overwrite these\nby passing in custom Workflow options when creating the child Workflow stub.\n\nThe first call to the child Workflow stub must always be its Workflow method (method annotated with `@WorkflowMethod`).\n\nSimilar to Activities, invoking child Workflow methods can be made synchronous or asynchronous by using `Async#function` or `Async#procedure`.\nThe synchronous call blocks until a child Workflow method completes. The asynchronous call\nreturns a `Promise` that can be used to wait for the completion of the child Workflow method, for example:\n\n```java\nGreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\nPromise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n// ...\ngreeting.get()\n```\n\nNote that querying child Workflows from within the parent Workflow code is not supported. You can however\nquery child Workflows from Activities using `WorkflowClient`.\n\nFollowing are examples of using a child Workflow inside a Workflow:\n\n```java\n// Child Workflow interface\n@WorkflowInterface\npublic interface GreetingChild {\n   @WorkflowMethod\n   String composeGreeting(String greeting, String name);\n}\n// Child Workflow implementation not shown\n\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n   @Override\n   public String getGreeting(String name) {\n       GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n       // This is a blocking call that returns only after child has completed.\n       return child.composeGreeting(\"Hello\", name );\n   }\n}\n```\n\nRunning two children (with the same type) in parallel:\n\n```java\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n\n        // Workflows are stateful, so a new stub must be created for each new child.\n        GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting1 = Async.function(child1::composeGreeting, \"Hello\", name);\n\n        // Both children will run concurrently.\n        GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting2 = Async.function(child2::composeGreeting, \"Bye\", name);\n\n        // Do something else here.\n        ...\n        return \"First: \" + greeting1.get() + \", second: \" + greeting2.get();\n    }\n}\n```\n\nSending a signal to a child Workflow from the parent:\n\n```java\n// Child Workflow interface\n@WorkflowInterface\npublic interface GreetingChild {\n    @WorkflowMethod\n    String composeGreeting(String greeting, String name);\n\n    @SignalMethod\n    void updateName(String name);\n}\n\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n        GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n        child.updateName(\"Temporal\");\n        return greeting.get();\n    }\n}\n```\n\n### ParentClosePolicy\n\nWhen creating a Child Workflow, you can define a `ParentClosePolicy` that terminates, cancels, or abandons the Workflow Execution if the child's parent stops execution.\n\n- `ABANDON`: When the parent stops, don't do anything with the Child Workflow.\n- `TERMINATE`: When the parent stops, terminate the Child Workflow\n- `REQUEST_CANCEL`: When the parent stops, terminate the Child Workflow\n\nYou can set policies per child, which means you can opt out of propagating terminates / cancels on a per-child basis.\nThis is useful for starting Child Workflows asynchronously:\n\n```java\n   public void parentWorkflow() {\n       ChildWorkflowOptions options =\n          ChildWorkflowOptions.newBuilder()\n              .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)\n              .build();\n       MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, options);\n       Async.procedure(child::<workflowMethod>, <args>...);\n       Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(child);\n       // Wait for child to start\n       childExecution.get()\n  }\n```\n\n1. Set `ChildWorkflowOptions.ParentClosePolicy` to `ABANDON` when creating a Child Workflow stub.\n2. Start Child Workflow Execution asynchronously using `Async.function` or `Async.procedure`.\n3. Call `Workflow.getWorkflowExecution(…)` on the child stub\n4. Wait for the Promise returned by `getWorkflowExecution` to complete.\n   This indicates that the child successfully started (or start failed).\n5. Complete Parent Workflow Execution asynchronously\n\nSteps 3 and 4 are needed to ensure that a Child Workflow Execution starts before the parent closes.\nIf the parent initiates a Child Workflow Execution and then immediately completes, the child would never execute.\n\n## Starting Workflow Executions\n\nIn the Temporal Java SDK, Workflows can be started both synchronously and asynchronously.\nTo do either, you must initialize an instance of a `WorkflowClient`, create a client side Workflow stub,\nand then call a Workflow method (annotated with the `@WorkflowMethod` annotation).\n\n### Asynchronous start\n\nAn asynchronous start initiates a Workflow execution and immediately returns to the caller.\nThis is the most common way to start Workflows in a live environment.\n\n<!--SNIPSTART money-transfer-project-template-java-workflow-initiator-->\n<!--SNIPEND-->\n\nIf you need to wait for the completion of a Workflow after an asynchronous start, the most straightforward way is to call the blocking Workflow instance again.\n\nIf `WorkflowOptions.WorkflowIdReusePolicy` is not set to `AllowDuplicate`, then instead of throwing `DuplicateWorkflowException`,\nit reconnects to an existing Workflow and waits for its completion.\n\nThe following example shows how to do this from a different process than the one that started the Workflow Execution.\n\n```java\nYourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflow.yourMethod();\n```\n\nAnother way to connect to an existing workflow and wait for its completion from another process is to use\n`UntypedWorkflowStub`, for example:\n\n```java\nWorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflowStub.getResult(String.class);\n```\n\n### Synchronous start\n\nA Synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the invocation process and will continue executing even if the waiting process crashes or was stopped.\n\n<!--SNIPSTART hello-world-project-template-java-workflow-initiator-->\n<!--SNIPEND-->\n\n### Recurring start\n\nYou can start a Workflow Execution on a regular schedule with [the CronSchedule option](distributed-cron).\n\n### External Workflows\n\nWorkflows can execute (and signal to) other workflows purely by name.\nThis helps particularly for executing workflows from other language SDKs.\nSee our [Temporal Polyglot example](https://github.com/tsurdilo/temporal-polyglot) for more.\n\n## Large Event Histories\n\nTemporal SDK allows you to manually use [Continue-As-New](/concepts/what-is-continue-as-new) in a number of ways:\n\nIf you are continuing execution of the same workflow that is currently running you can do:\n\n```java\nWorkflow.continueAsNew(input1, ...);\n```\n\nIt is also possible to continue execution as a completely different Workflow type.\nIn a Workflow class called `YourWorkflow` for example, we can create a Workflow Stub with a different type and\ncall its Workflow method to continue execution as that type:\n\n```java\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class);\ncontinueAsNew.greet(input);\n```\n\n`Workflow.newContinueAsNewStub` also allows to provide `ContinueAsNewOptions` options, for example:\n\n```java\nContinueAsNewOptions options = ContinueAsNewOptions.newBuilder()\n        .setTaskQueue(\"newTaskQueueName\")\n        .build();\n\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class, options);\n// ...\ncontinueAsNew.greet(input);\n```\n\nThis allows you to continue workflow execution as a new Workflow run with a different Workflow type,\nand on a different Task Queue.\n\nAnother way to deal with the execution history size limits is to use Child Workflows, however\nthey themselves could eventually, if long running, experience the same issue in which case you can again\napply the \"ContinueAsNew\" feature if needed.\n\n\"ContinueAsNew\" can also be used in [child Workflows](#child-workflows). Note that in this case the parent Workflow\nis not aware if its child Workflows called \"ContinueAsNew\". This way a child Workflow can call \"ContinueAsNew\" as many times\nas it needs, and the parent Workflow will get notified when the last run of the child Workflow completes or fails.\n\nIf you need to know whether a Workflow was started via `continueAsNew`, you can check `Workflow.getInfo().getContinuedExecutionRunId().isPresent()`.\n","is_empty":false},{"file_name":"api-reference-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/api-reference-python.md","id":330,"title":"API reference","label":"API reference","markdown_content":"\nThe Temporal Python SDK API reference is published on [python.temporal.io](https://python.temporal.io/index.html).\n","is_empty":false},{"file_name":"code-samples-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/code-samples-python.md","id":331,"title":"Code samples","label":"Code samples","markdown_content":"\n- [Python samples library](https://github.com/temporalio/samples-python)\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-python.md","id":332,"title":"How to set custom Search Attributes in Python","description":"To set custom Search Attributes, use the `search_attributes` parameter of 'start_workflow()'.","label":"Set custom Search Attributes","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo set custom Search Attributes, use the `search_attributes` parameter of the ['start_workflow()'](https://python.temporal.io/temporalio.client.client#start_workflow) method.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    search_attributes={\"Your-Custom-Keyword-Field\": [\"value\"]},\n)\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-continue-as-new-in-python.md","id":333,"title":"How to Continue-As-New in Python","description":"Continue-As-New","label":"Continue-As-New","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo Continue-As-New in Python, call the [`continue_as_new()`](https://python.temporal.io/temporalio.workflow.html#continue_as_new) function from inside your Workflow, which will stop the Workflow immediately and Continue-As-New.\n\n```python\nworkflow.continue_as_new(\"your-workflow-name\")\n```\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-create-a-temporal-client-in-python.md","id":334,"title":"How to create a Temporal Client in Python","description":"Create a Temporal Client","label":"Create a Temporal Client","tags":["developer-guide","sdk","python"],"markdown_content":"\nUse [`connect()`](https://python.temporal.io/temporalio.client.client#connect) method on the [`Client`](https://python.temporal.io/temporalio.client.client) class to create and connect to a Temporal Server at a given address and Namespace.\n\nSpecify the `target_host` parameter as a string.\n\n**Connect to Docker**\n\n```python\nawait Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n```\n\n**Connect to your Cluster**\n\n```python\nawait Client.connect(\n    \"web.<Namespace_ID>.tmprl.cloud\", namespace=\"your-custom-namespace\"\n)\n```\n\nA `Client` does not have an explicit close.\n","is_empty":false},{"file_name":"how-to-customize-activity-type-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-customize-activity-type-in-python.md","id":335,"title":"How to customize Activity Type in Python","description":"Customize your Activity Type.","label":"Customize Activity Type","tags":["developer-guide","sdk","python"],"markdown_content":"\nYou can customize the Activity name with a custom name in the decorator argument. For example, `@activity.defn(name=\"your-activity\")`. If the name parameter is not specified, the Activity name defaults to the function name.\n\n```python\n@activity.defn(name=\"your-activity\")\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n","is_empty":false},{"file_name":"how-to-customize-workflow-type-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-customize-workflow-type-in-python.md","id":336,"title":"How to customize Workflow types in Python","description":"Customize Workflow types.","label":"Customize Workflow types","tags":["developer-guide","sdk","python"],"markdown_content":"\nYou can customize the Workflow name with a custom name in the decorator argument. For example, `@workflow.defn(name=\"your-workflow-name\")`. If the name parameter is not specified, the Workflow name defaults to the function name.\n\n```python\n@workflow.defn(name=\"your-workflow-name\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-define-a-query-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-define-a-query-in-python.md","id":337,"title":"How to define a Query in Python","description":"Define a Query","label":"Define a Query","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo define a Query, set the Query decorator [`@workflow.query`](https://python.temporal.io/temporalio.workflow.html#query) on the Query function inside your Workflow.\n\n```python\n@workflow.query\nasync def current_greeting(self) -> str:\n    return self._current_greeting\n```\n\nThe [`@workflow.query`](https://python.temporal.io/temporalio.workflow.html#query) decorator defines a method as a Query. Queries can be asynchronous or synchronous methods and can be inherited; however, if a method is overridden, the override must also be decorated. Queries should return a value.\n\n**Dynamic Queries**\n\nYou can use `@workflow.query(dynamic=True)`, which means all other unhandled Query's fall through to this.\n\nFor example:\n\n```python\n@workflow.query(dynamic=True)\ndef query_dynamic(self, name: str, *args: Any) -> str:\n    return f\"query_dynamic {name}: {args[0]}\"\n```\n\n**Customize names**\n\nYou can have a name parameter to customize the Query's name, otherwise it defaults to the unqualified method `__name__`.\n\nThe following example sets a custom Query name.\n\n```python\n@workflow.query(name=\"Custom-Name\")\ndef query(self, arg: str) -> None:\n    self._last_event = f\"query: {arg}\"\n```\n\n:::note\n\nYou can either set the `name` or the `dynamic` parameter in a Query's decorator, but not both.\n\n:::\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-define-a-signal-in-python.md","id":338,"title":"How to define a Signal in Python","description":"Define a Signal","label":"Define a Signal","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo define a Signal, set the Signal decorator [`@workflow.signal`](https://python.temporal.io/temporalio.workflow.html#signal) on the Signal function inside your Workflow.\n\n```python\n@workflow.signal\ndef your_signal(self, value: str) -> None:\n    self._signal = value\n```\n\nThe [`@workflow.signal`](https://python.temporal.io/temporalio.workflow.html#signal) decorator defines a method as a Signal. Signals can be asynchronous or synchronous methods and can be inherited; however, if a method is overridden, the override must also be decorated.\n\n**Dynamic Signals**\n\nYou can use `@workflow.signal(dynamic=True)`, which means all other unhandled Signals fall through to this.\n\nYour method parameters must be `self`, a string signal name, and a `*args` variable argument parameter.\n\nFor example:\n\n```python\n@workflow.signal(dynamic=True)\ndef signal_dynamic(self, name: str, *args: Any) -> None:\n    self._last_event = f\"signal_dynamic {name}: {args[0]}\"\n```\n\n**Customize name**\n\nNon-dynamic methods can only have positional arguments. Temporal suggests taking a single argument that is an\nobject or data class of fields that can be added to as needed.\n\nReturn values from Signal methods are ignored.\n\nYou can have a name parameter to customize the Signal's name, otherwise it defaults to the unqualified method `__name__`.\n\nThe following example sets a custom Signal name.\n\n```python\n@workflow.signal(name=\"Custom-Name\")\ndef signal(self, arg: str) -> None:\n    self._last_event = f\"signal: {arg}\"\n```\n\n:::note\n\nYou can either set the `name` or the `dynamic` parameter in a Signal's decorator, but not both.\n\n:::\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-define-activity-parameters-in-python.md","id":339,"title":"How to define Activity Parameters in Python","description":"Activities can support many custom parameters.","label":"Activity Parameters","tags":["developer-guide","python"],"markdown_content":"\nActivity parameters are the function parameters of the function decorated with `@activity.defn`.\nThese can be any data type Temporal can convert, including ['dataclasses'](https://docs.python.org/3/library/dataclasses.html) when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single `dataclass` parameter containing all input fields.\nFor example:\n\n```python\n@dataclass\nclass YourParams:\n    your_int_param: int\n    your_str_param: str\n\n\n@activity.defn\nasync def your_activity(params: YourParams) -> None:\n    ...\n```\n","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-define-activity-return-values-in-python.md","id":340,"title":"How to define Activity return values in Python","description":"Activity return values","label":"Activity return values","tags":["developer-guide","python"],"markdown_content":"\nAn Activity Execution can return inputs and other Activity values.\n\nThe following example defines an Activity that takes a string as input and returns a string.\n\n```python\n@activity.defn\nasync def say_hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-define-workflow-parameters-in-python.md","id":341,"title":"How to define Workflow parameters","description":"Define Workflow parameters","label":"Define Workflow parameters","tags":["developer-guide","sdk","python"],"markdown_content":"\nWorkflow parameters are the method parameters of the singular method decorated with `@workflow.run`.\nThese can be any data type Temporal can convert, including ['dataclasses'](https://docs.python.org/3/library/dataclasses.html) when properly type-annotated.\nTechnically this can be multiple parameters, but Temporal strongly encourages a single `dataclass` parameter containing all input fields.\nFor example:\n\n```python\n@dataclass\nclass YourParams:\n    your_int_param: int\n    your_str_param: str\n\n\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, params: YourParams) -> None:\n        ...\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-define-workflow-return-values-in-python.md","id":342,"title":"How to define Workflow return values","description":"Define Workflow return values","label":"Define Workflow return values","tags":["developer-guide","sdk","python"],"markdown_content":"\nA Workflow Execution can return the results of a Workflow.\n\nTo return the results of a Workflow Execution, use either [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) asynchronous methods.\n\n```python\nhandle = await client.start_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n\nresult = await handle.result()\n```\n\n`execute_workflow()` is a helper function for `start_workflow()` and `handle.result()`.\n\n```python\nhandle = await client.execute_workflow(\n    \"your-workflow-name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-develop-a-worker-program-in-python.md","id":343,"title":"How to develop a Worker Program in Python","description":"Create a new instance of a Worker.","label":"Worker Program","tags":["developer-guide","python","workers"],"markdown_content":"\nTo develop a Worker, use the [`Worker()`](https://python.temporal.io/temporalio.worker.worker#__init__) constructor and add your Client, Task Queue, Workflows, and Activities as arguments.\n\nThe following code example creates a Worker that polls for tasks from the Task Queue and executes the Workflow.\n\n```python\nworker = Worker(\n    client,\n    task_queue=\"your-task-queue\",\n    workflows=[YourWorkflow],\n    activities=[your_activity],\n)\n```\n\nThe following code example shows a Worker hosting Workflows and Activities.\n\n```python\nasync def run_worker(stop_event: asyncio.Event):\n    # Create Client connected to server at the given address\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    # Run the worker until the event is set\n    worker = Worker(\n        client,\n        task_queue=\"your-task-queue\",\n        workflows=[YourWorkflow],\n        activities=[your_activity],\n    )\n    async with worker:\n        await stop_event.wait()\n```\n\nThe `asyncio.Event` that will be set when the Worker should stop.\nAlthough this example accepts a stop event and uses `async with`, you can also use [`run()`](https://python.temporal.io/temporalio.worker.Worker.html#run) and [`shutdown()`](https://python.temporal.io/temporalio.worker.Worker.html#shutdown).\nThe `shutdown()` operation waits on all Activities to complete, so if a long-running Activity does not at least respect cancellation, the shutdown might never complete.\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-develop-a-workflow-definition-in-python.md","id":344,"title":"How to develop a Workflow definition in Python","description":"Develop a Workflow definition","label":"Develop a Workflow definition","tags":["developer-guide","sdk","python"],"markdown_content":"\nWorkflows in Python are defined as classes.\n\nSpecify the [`@workflow.defn`](https://python.temporal.io/temporalio.workflow.html#defn) decorator on the Workflow class to register a Workflow class.\n\nUse the [`@workflow.run`](https://python.temporal.io/temporalio.workflow.html#run) to mark the entry point method to be invoked. This must be set on one asynchronous method defined on the same class as `@workflow.defn`. Run methods have positional parameters.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-develop-an-activity-definition-in-python.md","id":345,"title":"How to develop an Activity Definition in Python","description":"Develop an Activity Definition","label":"Develop an Activity Definition","tags":["developer-guide","sdk","python"],"markdown_content":"\nYou can develop an Activity Definition by using the [`@activity.defn`](https://python.temporal.io/temporalio.activity.html#defn) decorator.\n\n```python\n@activity.defn\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\nYou can register the function as an Activity with a custom name through a decorator argument. For example, `@activity.defn(name=\"your-activity\")`.\n\n```python\n@activity.defn(name=\"your-activity\")\nasync def your_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n**Types of Activities**\n\nThe following lists the different types of _Activity callables_:\n\n- [Asynchronous Activities](#asynchronous-activities)\n- [Synchronous Activities](#synchronous-activities)\n\n:::note Positional arguments\n\nOnly positional arguments are supported by Activities.\n\n:::\n\n##### [Asynchronous Activities](#asynchronous-activities)\n\nAsynchronous Activities (recommended) are functions using `async def`. When using asynchronous Activities there aren't any additional Worker parameters needed.\n\nCancellation for asynchronous activities is done by means of the\n[`asyncio.Task.cancel`](https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel) operation. This means that `asyncio.CancelledError` will be raised (and can be caught, but it is not recommended).\n\nAn Activity must Heartbeat to receive cancellation.\n\n##### [Synchronous Activities](#synchronous-activities)\n\nThe [`activity_executor`](https://python.temporal.io/temporalio.worker.workerconfig#activity_exector) Worker parameter must be set with a [`concurrent.futures.Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor) instance to use for executing the Activities.\n\nCancellation for synchronous Activities is done in the background and the Activity must choose to listen for it and react appropriately.\n\nAn Activity must Heartbeat to receive cancellation.\n\n- ###### [Synchronous Multithreaded Activities](#synchronous-multithreaded-activities)\n\nMultithreaded Activities are functions that use `activity_executor` set to an instance of [`concurrent.futures.ThreadPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor).\n\nBesides `activity_executor`, no other additional Worker parameters are required for synchronous multithreaded Activities.\n\n- ###### [Synchronous Multiprocess/Other Activities](#synchronous-multiprocess)\n\nIf `activity_executor` is set to an instance of [`concurrent.futures.Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor) that is not `concurrent.futures.ThreadPoolExecutor`, then the synchronous activities are considered multiprocess/other activities.\n\nThese require special primitives for heartbeating and cancellation. The `shared_state_manager` Worker parameter must be set to an instance of [`worker.SharedStateManager`](https://python.temporal.io/temporalio.worker.sharedstatemanager). The most common implementation can be created by passing a [`multiprocessing.managers.SyncManager`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.SyncManager) (for example, as a result of [`multiprocessing.managers.Manager()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Manager)) to [`worker.SharedStateManager.create_from_multiprocessing()`](https://python.temporal.io/temporalio.worker.sharedstatemanager#create_from_multiprocessing).\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-get-the-result-of-a-workflow-execution-in-python.md","id":346,"title":"How to get the result of a Workflow Execution in python","description":"Workflow Execution result","label":"Workflow Execution result","tags":["developer-guide","python"],"markdown_content":"\nUse [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.client#get_workflow_handle) to return a Workflow handle.\nThen use the [`result`](https://python.temporal.io/temporalio.client.workflowhandle#result) method to await on the result of the Workflow.\n\n```python\nhandle = await client.start_workflow(\n    YourWorkflow.run, \"some arg\", id=\"your-workflow-id\", task_queue=\"your-task-queue\"\n)\n\n# Wait for result\nresult = await handle.result()\nprint(f\"Result: {result}\")\n```\n\nTo get a handle for an existing Workflow by its Id, you can use [`get_workflow_handle()`](https://python.temporal.io/temporalio.client.client#get_workflow_handle), or use [`get_workflow_handle_for()`](https://python.temporal.io/temporalio.client.client#get_workflow_handle_for) for type safety.\n\nThen use [`describe()`](https://python.temporal.io/temporalio.client.workflowhandle#describe) to get the current status of the Workflow.\nIf the Workflow does not exist, this call fails.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-get-the-result-of-an-activity-execution-in-python.md","id":347,"title":"How to get the result of an Activity Execution in Python","description":"Get the result of an Activity Execution","label":"Get the result of an Activity Execution","tags":["developer-guide","sdk","python"],"markdown_content":"\nUse [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) to start an Activity and return its handle, [`ActivityHandle`](https://python.temporal.io/temporalio.workflow.activityhandle). Use [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) to return the results.\n\nYou must provide either `schedule_to_close_timeout` or `start_to_close_timeout`.\n\n`execute_activity()` is a shortcut for `await start_activity()`. An asynchronous `execute_activity()` helper is provided which takes the same arguments as `start_activity()` and `await`s on the result. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-handle-a-query-in-a-workflow-in-python.md","id":348,"title":"How to handle a Query in a Workflow","description":"Handle a Query in a Workflow","label":"Handle a Query in a Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo send a Query from to the Workflow, use the [`query`](https://python.temporal.io/temporalio.client.workflowhandle#query) method from the [`WorkflowHandle`](https://python.temporal.io/temporalio.client.workflowhandle) class.\n\n```python\nawait handle.query(\"some query\")\n```\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-handle-a-signal-in-a-workflow-in-python.md","id":349,"title":"How to handle a Signal in a Workflow","description":"Handle a Signal in a Workflow","label":"Handle a Signal in a Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo send a Signal to the Workflow, use the [`signal`](https://python.temporal.io/temporalio.client.workflowhandle#signal) method from the [`WorkflowHandle`](https://python.temporal.io/temporalio.client.workflowhandle) class.\n\n```python\nawait handle.signal(\"some signal\")\n```\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-handle-workflow-logic-requirements-in-python.md","id":350,"title":"How to handle Workflow logic requirements in Python","description":"Handle Workflow logic requirements","label":"Handle Workflow logic requirements","tags":["developer-guide","sdk","python"],"markdown_content":"\nWorkflow code must be deterministic. This means:\n\n- no threading\n- no randomness\n- no external calls to processes\n- no network I/O\n- no global state mutation\n- no system date or time\n\nAll API safe for Workflows used in the [`temporalio.workflow`](https://python.temporal.io/temporalio.workflow.html) must run in the implicit [`asyncio` event loop](https://docs.python.org/3/library/asyncio-eventloop.html) and be _deterministic_.\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-heartbeat-an-activity-in-python.md","id":351,"title":"How to heartbeat an Activity in Python","description":"Heartbeat an Activity","label":"Heartbeat an Activity","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo Heartbeat an Activity Execution in Python, use the [`heartbeat()`](https://python.temporal.io/temporalio.activity.html#heartbeat) API.\n\n```python\n@activity.defn\nasync def your_activity_definition() -> str:\n    activity.heartbeat(\"heartbeat details!\")\n```\n\nIn addition to obtaining cancellation information, Heartbeats also support detail data that persists on the server for retrieval during Activity retry.\nIf an Activity calls `heartbeat(123, 456)` and then fails and is retried, `heartbeat_details` returns an iterable containing `123` and `456` on the next Run.\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-log-from-a-workflow-in-python.md","id":352,"title":"How to log from a Workflow in Python","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","python"],"markdown_content":"\nYou can log from a Workflow using Python's standard library, by importing the logging module `import logging`.\n\nSet your logging configuration to a level you want to expose logs to.\nThe following example sets the logging information level to `INFO`.\n\n```python\nlogging.basicConfig(level=logging.INFO)\n```\n\nThen in your Workflow, set your [`logger`](https://python.temporal.io/temporalio.workflow.html#logger) and level on the Workflow. The following example logs the Workflow.\n\n```python\n@workflow.defn\nclass SayHelloWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        workflow.logger.info(f\"Running workflow with parameter {name}\")\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=10)\n        )\n```\n\nThe following is an example output:\n\n```\nINFO:temporalio.workflow:Running workflow with parameter Temporal ({'attempt': 1, 'your-custom-namespace': 'default', 'run_id': 'your-run-id', 'task_queue': 'your-task-queue', 'workflow_id': 'your-workflow-id', 'workflow_type': 'SayHelloWorkflow'})\n```\n\n:::note\n\nLogs are skipped during replay by default.\n\n:::\n","is_empty":false},{"file_name":"how-to-register-types-with-a-worker-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-register-types-with-a-worker-in-python.md","id":353,"title":"How to register types with a Worker in Python","description":"Register types with a Worker","label":"Register types with a Worker","tags":["developer-guide","sdk","python"],"markdown_content":"\nWhen a `Worker` is created, it accepts a list of Workflows in the `workflows` parameter, a list of Activities in the `activities` parameter, or both.\n\n```python\nworker = Worker(\n    client,\n    task_queue=\"your-task-queue\",\n    workflows=[YourWorkflow1, YourWorkflow2],\n    activities=[your_activity_1, your_activity_2],\n)\n```\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-remove-search-attributes-from-a-workflow-in-python.md","id":354,"title":"How to remove Search Attributes in Python","description":"To remove a Search Attribute, use `upsert_search_attributes()` with an empty list as its value.","label":"Remove Search Attributes","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo remove a Search Attribute, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) function with an empty list as its value.\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": []})\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-send-a-signal-with-start-in-python.md","id":355,"title":"How to send a Signal-With-Start in Python","description":"Signal-With-Start","label":"Signal-With-Start","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo send a Signal-With-Start in Python, use the [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) method and pass the `start_signal` argument with the name of your Signal, instead of using a traditional Workflow start.\n\n```python\nasync def main():\n    client = await Client.connect(\"localhost:7233\", namespace=\"your-namespace\")\n\n    handle = await client.start_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n        start_signal=\"your-signal-name\",\n    )\n```\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-a-cron-schedule-in-python.md","id":356,"title":"How to set a Cron Schedule in Python","description":"Set a Cron Scheduler in Python","label":"Cron Schedule","tags":["python","how-to"],"markdown_content":"\nYou can set each Workflow to repeat on a schedule with the `cron_schedule` option from either the [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) asynchronous methods:\n\n```python\nawait client.start_workflow(\n    \"your_workflow_name\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n    cron_schedule=\"* * * * *\",\n)\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-a-heartbeat-timeout-in-python.md","id":357,"title":"How to set a Heartbeat Timeout in Python","description":"Set a Heartbeat Timeout","label":"Set a Heartbeat Timeout","tags":["developer-guide","sdk","python"],"markdown_content":"\n[`heartbeat_timeout`](https://python.temporal.io/temporalio.worker.startactivityinput#heartbeat_timeout) is a class variable for the [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) function used to set the maximum time between Activity Heartbeats.\n\n```python\nworkflow.start_activity(\n    activity=\"your-activity\",\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`. `execute_activity()` should be used in most cases unless advanced task capabilities are needed.\n\n```python\nworkflow.execute_activity(\n    activity=\"your-activity\",\n    name,\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-a-schedule-to-close-timeout-in-python.md","id":358,"title":"How to set a schedule to close timeout in Python","description":"Set a schedule to close timeout","label":"Set a schedule to close timeout","tags":["developer-guide","sdk","python"],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code example sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_close_timeout` to 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-a-schedule-to-start-timeout-in-python.md","id":359,"title":"How to set a schedule to start timeout in Python","description":"Set a schedule to start timeout","label":"Set a schedule to start timeout","tags":["developer-guide","sdk","python"],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\nThe following code sets a Schedule-to-Close timeout in Python, by calling the Activity with the argument `name` and setting the `schedule_to_start_timeout` to 1 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            name,\n            schedule_to_close_timeout=5000,\n            schedule_to_start_timeout=1000,\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-a-start-to-close-timeout-in-python.md","id":360,"title":"How to set a start to close timeout in Python","description":"Set a start to close timeout","label":"Set a start to close timeout","tags":["developer-guide","sdk","python"],"markdown_content":"\nActivity options are set as keyword arguments after the Activity arguments. At least one of `start_to_close_timeout` or `schedule_to_close_timeout` must be provided.\n\n```python\nstart_to_close_timeout = timedelta(seconds=5)\n```\n\nThe following code example executes an Activity with a `start_to_close_timeout` of 5 seconds.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, start_to_close_timeout=timedelta(seconds=5)\n        )\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-a-workflow-id-in-python.md","id":361,"title":"How to set a Workflow Id in Python","description":"Set a Workflow Id","label":"Set a Workflow Id","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo set a Workflow Id in Python, specify the `id` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) methods.\n\nThe `id` argument should be a unique identifier for the Workflow Execution.\n\n```python\nresult = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-a-workflow-task-queue-in-python.md","id":362,"title":"How to set the Task Queue for Workflow Execution in Python","description":"Task Queue","label":"Task Queue","tags":["python","how-to"],"markdown_content":"\nTo set a Task Queue in Python, specify the `task_queue` argument when executing a Workflow with either [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) methods.\n\n```python\nresult = await client.execute_workflow(\n    \"your-workflow-name\",\n    \"some arg\",\n    id=\"your-workflow-id\",\n    task_queue=\"your-task-queue\",\n)\n```\n","is_empty":false},{"file_name":"how-to-set-cluster-address-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-cluster-address-in-python.md","id":363,"title":"How to set a Cluster address in Python","description":"Set Cluster address","label":"Set Cluster address","tags":["python","how-to"],"markdown_content":"\nTo use a custom Cluster address, set the `target_url` parameter of the [`Client`](https://python.temporal.io/temporalio.client.client) class.\n\n```python\nclient = await Client.connect(\n    \"foo.bar.tmprl.cloud\",\n    # ...\n)\n```\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-mtls-configuration-in-python.md","id":364,"title":"How to set mTLS configuration in Python","description":"Use the `tls_config` parameter from the `Client` class to connect a Client with mTLS.","label":"Set mTLS configuration","tags":["developer-guide","sdk","python"],"markdown_content":"\nUse the `tls_config` parameter from the [`Client`](https://python.temporal.io/temporalio.client.client) class to connect a Client with mTLS.\n\nThe following example connects your Client to your address. The `tls_config` options uses variables that reference the certificate and private key.\n\n```python\nawait Client.connect(\n    \"foo.bar.tmprl.cloud\",\n    namespace=\"foo.bar\",\n    tls_config=TLSConfig(\n        client_cert=client_cert,\n        client_private_key=client_private_key,\n    ),\n)\n```\n\n[The Hello World mTLS sample](https://github.com/temporalio/samples-python/blob/main/hello/hello_mtls.py) demonstrates sample code used to connect to a Temporal Cloud account with the `argparse` library.\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-set-the-namespace-for-a-temporal-client-in-python.md","id":365,"title":"How to set a Namespace for a Temporal Client in Python","description":"Set Namespace","label":"Set Namespace","tags":["python","how-to"],"markdown_content":"\nTo specify a Namespace, set the `namespace` parameter from the [`connect()`](https://python.temporal.io/temporalio.client.client#connect) method.\n\n```python\nawait Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n```\n\n`Client` can be directly instantiated with a service of another, such as when you need to create another Client to use an additional Namespace.\n\nClients also provide a shallow copy of their config for use in making slightly different Clients backed by the same connection with [`config`](https://python.temporal.io/temporalio.client.client#config). The following example creates a new Client with the same connection but a different Namespace.\n\n```python\nconfig = client.config()\nconfig[\"namespace\"] = \"your-other-namespace\"\nother_ns_client = Client(**config)\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-spawn-a-workflow-execution-in-python.md","id":366,"title":"How to spawn a Workflow Execution in Python","description":"Spawn a Workflow Execution","label":"Spawn a Workflow Execution","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo start a Workflow Execution in python, use either the [`start_workflow()`](https://python.temporal.io/temporalio.client.client#start_workflow) or [`execute_workflow()`](https://python.temporal.io/temporalio.client.client#execute_workflow) asynchronous methods in the Client.\n\nThe following code example starts a Workflow and returns its handle.\n\n```python\nasync def main():\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    handle = await client.start_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n```\n\nThe following code example starts a Workflow and waits for completion.\n\n```python\nasync def main():\n    client = await Client.connect(\"127.0.0.1:7233\", namespace=\"your-custom-namespace\")\n\n    handle = await client.execute_workflow(\n        \"your-workflow-name\",\n        \"some arg\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n```\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-spawn-an-activity-execution-in-python.md","id":367,"title":"How to spawn an Activity Execution in Python","description":"Use the `execute_activity()` operation from within your Workflow Definition.","label":"Activity Execution","tags":["developer-guide","python"],"markdown_content":"\nTo spawn an Activity Execution, use the [`execute_activity()`](https://python.temporal.io/temporalio.workflow.html#execute_activity) operation from within your Workflow Definition.\n\n```python\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n`execute_activity()` is a shortcut for [`start_activity()`](https://python.temporal.io/temporalio.workflow.html#start_activity) that waits on its result.\n\nTo get just the handle to wait and cancel separately, use `start_activity()`.\nIn most cases, use `execute_activity()` unless advanced task capabilities are needed.\n\nA single argument to the Activity is positional. Multiple arguments are not supported in the type-safe form of `start_activity()` or `execute_activity()` and must be supplied by the `args` keyword argument.\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-python.md","id":368,"title":"How to upsert custom Search Attributes","description":"To upsert custom Search Attributes, use [`upsert_search_attributes()`] and set it to an empty list.","label":"Upsert custom Search Attributes","tags":["developer-guide","sdk","python"],"markdown_content":"\nTo upsert custom Search Attributes, use the [`upsert_search_attributes()`](https://python.temporal.io/temporalio.workflow.html#upsert_search_attributes) function and set it to an empty list.\n\nThe keys are added to or replace the existing Search Attributes, similar to [`dict.update()`](https://docs.python.org/3/library/stdtypes.html#dict.update).\n\n```python\nworkflow.upsert_search_attributes({\"Your-Custom-Keyword-Field\": [\"new-value\"]})\n```\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/python/index.md","id":369,"title":"How to add the Temporal Python SDK","description":"Add the Temporal Python SDK to your project.","tags":["developer-guide","python"],"markdown_content":"\n[![Python 3.7+](https://img.shields.io/pypi/pyversions/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n[![PyPI](https://img.shields.io/pypi/v/temporalio.svg?style=for-the-badge)](https://pypi.org/project/temporalio)\n\nTo install the latest version of the Temporal Python package, run the following command.\n\n```bash\npip install temporalio\n```\n","is_empty":false},{"file_name":"activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/activities.md","id":370,"title":"Activities in PHP","label":"Activities","markdown_content":"\n## Activity interface\n\nAn Activity is a manifestation of a particular Task in the business logic.\n\nActivities are defined as methods of a plain PHP interface annotated with `#[ActivityInterface]` (you can use PHP 8 attributes\nin PHP7 as well).\n\nEach method defines a single Activity type.\nA single Workflow can use more than one Activity interface and call more that one Activity method from the same interface.\n\nThe only requirement is that Activity method arguments and return values are serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\n\nFollowing is an example of an interface that defines four Activities:\n\n```php\n#[ActivityInterface]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName): void;\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName): void;\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName): void;\n}\n```\n\nWe recommend to use a single value type argument for Activity methods.\nIn this way, adding new arguments as fields to the value type is a backwards-compatible change.\n\nAn optional `#[ActivityMethod]` annotation can be used to override a default Activity name.\n\nOption `prefix` of `ActivityInterface` annotation will allow you to define your own prefix for all activity names (by\ndefault it's empty).\n\n```php\n#[ActivityInterface(\"file_activities.\")]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName);\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName);\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName);\n}\n```\n\n## Implementing Activities\n\nActivity implementation is an implementation of an Activity interface.\nA single instance of the Activities implementation is shared across multiple simultaneous Activity invocations.\nTherefore, the Activity implementation code must be _stateless_.\n\nThe values passed to Activities through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to Workflow workers when a Workflow state needs to recover.\nA large execution history can thus adversely impact the performance of your Workflow.\nTherefore, be mindful of the amount of data you transfer via Activity invocation parameters or return values.\n\nOtherwise, no additional limitations exist on Activity implementations.\n\n```php\nclass FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n    private S3Client $s3Client;\n\n    private string $localDirectory;\n\n    public function __construct(S3Client $s3Client, string $localDirectory) {\n        $this->s3Client = $s3Client;\n        $this->localDirectory = $localDirectory;\n    }\n\n    public function upload(string $bucketName, string $localName, string $targetName): void\n    {\n        $this->s3Client->putObject(\n            $bucketName,\n            $targetName,\n            fopen($this->localDirectory . $localName, 'rb+')\n        );\n    }\n\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->s3Client->downloadObject(\n            $bucketName,\n            $remoteName,\n            fopen($this->localDirectory .$localName, 'wb+')\n        );\n    }\n\n    public function processFile(string $localName): string\n    {\n        // Implementation omitted for brevity.\n        return compressFile($this->localDirectory . $localName);\n    }\n\n    public function deleteLocalFile(string $fileName): void\n    {\n        unlink($this->localDirectory . $fileName);\n    }\n}\n```\n\n### Accessing Activity Info\n\nThe [Activity](https://github.com/temporalio/sdk-php/blob/master/src/Activity.php) class provides static getters to access information about the Workflow that invoked it.\nNote that this information is stored in a thread local variable.\nTherefore, calls to Activity accessors succeed only in the process that invoked the Activity function.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->logger->info(\"namespace=\" +  Activity.getNamespace());\n\n        $info = Activity::getInfo();\n\n        $this->logger->info(\"workflowId=\" + $info->workflowExecution->getID());\n        $this->logger->info(\"runId=\" + $info->workflowExecution->getRunID());\n        $this->logger->info(\"activityId=\" + $info->id);\n        $this->logger->info(\"activityDeadline=\" + $info->deadline);\n\n        // ...\n    }\n\n    // ...\n}\n```\n\n### Activity Heart Beating\n\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n\n## Calling Activities\n\n`Workflow::newActivityStub` returns a client-side stub an implements an Activity interface.\nThe client-side stub can be used within the Workflow code.\nIt takes the Activity's type and `ActivityOptions` as arguments.\n\nCalling (via `yield`) a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if Activity execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\n```php\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    private $greetingActivity;\n\n    public function __construct()\n    {\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n        );\n    }\n\n    public function greet(string $name): \\Generator\n    {\n        // This is a blocking call that returns only after the activity has completed.\n        return yield $this->greetingActivity->composeGreeting('Hello', $name);\n    }\n}\n```\n\nIf different Activities need different options, like timeouts or a task queue, multiple client-side stubs can be created with different options.\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 minutes'))\n);\n```\n\n## Calling Activities Asynchronously\n\nSometimes Workflows need to perform certain operations in parallel.\n\nInvoking activity stub without the use of `yield` will return the activity result promise which can be resolved at later moment.\nCalling `yield` on promise blocks until a result is available.\n\n> Activity promise also exposes `then` method to construct promise chains.\n> Read more about Promises [here](https://github.com/reactphp/promise).\n\nAlternatively you can explicitly wrap your code (including `yield` constucts) using `Workflow::async` which will execute nested code in parallel with main workflow code.\nCall `yeild` on Promise returned by `Workflow::async` to merge execution result back to primary workflow method.\n\n```php\npublic function greet(string $name): \\Generator\n{\n    // Workflow::async runs it's activities and child workflows in a separate coroutine. Use keyword yield to merge\n    // it back to parent process.\n\n    $first = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Bye', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    $second = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hola', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Chao', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    // blocks until $first and $second complete\n    return (yield $first) . \"\\n\" . (yield $second);\n}\n```\n\n## Async completion\n\nThere are certain scenarios when moving on from an Activity upon completion of its function is not possible or desirable.\nFor example, you might have an application that requires user input to complete the Activity.\nYou could implement the Activity with a polling mechanism, but a simpler and less resource-intensive implementation is to asynchronously complete a Temporal Activity.\n\nThere are two parts to implementing an asynchronously completed Activity:\n\n1. The Activity provides the information necessary for completion from an external system and notifies the Temporal service that it is waiting for that outside callback.\n2. The external service calls the Temporal service to complete the Activity.\n\nThe following example demonstrates the first part:\n\n<!--SNIPSTART samples-php-async-activity-completion-activity-class-->\n<!--SNIPEND-->\n\nThe following code demonstrates how to complete the Activity successfully using `WorkflowClient`:\n\n<!--SNIPSTART samples-php-async-activity-completion-completebytoken-->\n<!--SNIPEND-->\n\nTo fail the Activity, you would do the following:\n\n```php\n// Fail the Activity.\n$activityClient->completeExceptionallyByToken($taskToken, new \\Error(\"activity failed\"));\n```\n\n## Local Activity\n\nTo create a Local Activity you should use `#[LocalActivityInterface]` (instead of `#[ActivityInterface]`):\n\n```php\nuse Temporal\\Activity\\LocalActivityInterface;\n\n#[LocalActivityInterface]\ninterface GreetingActivityInterface\n{\n    #[ActivityMethod(\"greet\")]\n    public function greet(): string;\n}\n```\n\nLocal Activity requires `LocalActivityOptions`:\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    LocalActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n```\n\nLocal Activities have a limited set of options, including: `ScheduleToCloseTimeout`, `StartToCloseTimeout`, `RetryPolicy`.\n","is_empty":false},{"file_name":"code-samples-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/code-samples-php.md","id":371,"title":"Code samples","label":"Code samples","markdown_content":"\n- [PHP samples repo](https://github.com/temporalio/samples-php)\n\n- [Subscription-style Workflow Definition in PHP](https://github.com/temporalio/subscription-workflow-project-template-php): Demonstrates some of the patterns that could be implemented for a subscription-style business process.\n","is_empty":false},{"file_name":"distributed-cron.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/distributed-cron.md","id":372,"title":"Distributed CRON","markdown_content":"\n<!-- prettier-ignore -->\nimport * as WhatIsATemporalCronJob from '../concepts/what-is-a-temporal-cron-job.md'\n\nThis is how you set a Cron Schedule in PHP:\n\n```php\n  $workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()\n          ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n          ->withCronSchedule('* * * * *')\n          // Execution timeout limits total time. Cron will stop executing after this timeout.\n          ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n          // Run timeout limits duration of a single workflow invocation.\n          ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n  );\n\n  $output->writeln(\"Starting <comment>CronWorkflow</comment>... \");\n\n  try {\n      $run = $this->workflowClient->start($workflow, 'Antony');\n      // ...\n  }\n```\n\nSetting `withCronSchedule` turns the Workflow Execution into a <preview page={WhatIsATemporalCronJob}>Temporal Cron Job</preview>\n\nYou can check our [PHP samples](https://github.com/temporalio/samples-php/tree/master/app/src/Cron) for example code.\n\nPHP SDK `WorkflowOptions` source code: https://github.com/temporalio/sdk-php/blob/master/src/Client/WorkflowOptions.php\n\n## Retrieve last successful result\n\nSometimes it is useful to obtain the progress of previous successful runs.\nThis is supported by two APIs in the PHP SDK:\n`Workflow::hasLastCompletionResult` and `Workflow::getLastCompletionResult`. Below is an example of how\nto use this in PHP:\n\n```php\npublic function cronWorkflow() {\n    $lastProcessedFileName = Workflow::getLastCompletionResult(Type::TYPE_STRING);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return $lastProcessedFileName;\n}\n```\n\nNote that this works even if one of the cron schedule runs failed. The\nnext schedule will still get the last successful result if it ever successfully\ncompleted at least once. For example, for a daily cron Workflow, if the first day\nrun succeeds and the second day fails, then the third day run will still get\nthe result from first day's run using these APIs.\n","is_empty":false},{"file_name":"error-handling.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/error-handling.md","id":373,"title":"Error handling in PHP","label":"Error handling","markdown_content":"\nAn Activity, or a child Workflow, might fail, and you could handle errors differently based on the different\nerror cases.\n\nIf the Activity returns throws an exception, that exception will\nbe converted to `Temporal\\Exception\\Failure\\ApplicationFailure` and wrapped\ninside `Temporal\\Exception\\Failure\\ActivityFailure` or `Temporal\\Exception\\Failure\\ChildWorkflowFailure`.\n\nIt is possible to throw `ApplicationFailure` manually with the ability to set `nonRetryable` flag.\n\nThere are other types of exceptions such as `TimeoutFailure`, `CanceledFailure` and\n`ServerFailure`.\n\n> All temporal related exceptions has suffix `Failure` for easier comprehension.\n\nHere's an example of handling Activity errors within Workflow code that differentiates between different error types.\n\n```php\nuse Temporal\\Exception\\Failure;\nuse Temporal\\Api\\Enums\\V1\\TimeoutType;\n\n$yourActivity = Workflow::newActivityStub(\n    YourActivityInterface::class,\n    ActivityOptions::new()->withScheduleToStartTimeout(60)\n);\n\ntry {\n    yield $yourActivity->doSomething();\n} catch(Failure\\ActivityFailure $e) {\n    $cause = $e->getPrevious();\n\n    if ($cause instanceof Failure\\ApplicationFailure) {\n        // domain code error\n        $originalError = $cause->getType();\n        $originalMessage = $cause->getOriginalMessage();\n\n        // optional: additional error details\n        $value = $cause->getDetails()->getValue(0, Type::TYPE_STRING);\n    }\n\n     if ($cause instanceof Failure\\TimeoutFailure) {\n        switch ($cause->getTimeoutType()) {\n            case TimeoutType::TIMEOUT_TYPE_START_TO_CLOSE:\n                // handle start to close timeout\n                break;\n            case TimeoutType::TIMEOUT_TYPE_SCHEDULE_TO_CLOSE:\n                // handle schedule to close timeout\n                break;\n            case TimeoutType::TIMEOUT_TYPE_SCHEDULE_TO_START:\n                // handle schedule to start timeout\n                break;\n            case TimeoutType::TIMEOUT_TYPE_HEARTBEAT:\n                // handle heartbeat timeout\n\n                // last recorded heartbeat (optional)\n                $heartbeatDetails = $cause->getLastHeartbeatDetails();\n                break;\n        }\n    }\n\n    if($cause instanceof Failure\\CanceledFailure){\n        // activity was canceled\n    }\n\n    if ($cause instanceof Failure\\ServerFailure) {\n        // handle server error\n    }\n}\n```\n","is_empty":false},{"file_name":"how-to-continue-as-new-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-continue-as-new-in-php.md","id":374,"title":"How to Continue-As-New in PHP","label":"Continue-As-New","markdown_content":"\nWorkflows that need to rerun periodically could naively be implemented as a big **while** loop with a sleep where the entire logic of the Workflow is inside the body of the **while** loop.\nThe problem with this approach is that the history for that Workflow will keep growing to a point where it reaches the maximum size enforced by the service.\n\n**ContinueAsNew** is the low level construct that enables implementing such Workflows without the risk of failures down the road.\nThe operation atomically completes the current execution and starts a new execution of the Workflow with the same **Workflow Id**.\nThe new execution will not carry over any history from the old execution.\n\nTo trigger this behavior, use `Workflow::continueAsNew` or `Workflow::newContinueAsNewStub` method:\n\n```php\n#[Workflow\\WorkflowMethod]\npublic function periodic(string $name, int $value = 0)\n{\n    for ($i = 0; $i < 100; $i++) {\n        // do something\n        $value++;\n    }\n\n    // maintain $value counter between runs\n    return Workflow::newContinueAsNewStub(self::class)->periodic($name, $value);\n}\n```\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-create-a-temporal-client-in-php.md","id":375,"title":"How to create a Temporal Client in PHP","label":"Temporal Client","markdown_content":"\nThe following example represents a console command that starts a Workflow, prints its IDs, and then waits for its result:\n\n<!--SNIPSTART php-hello-client {\"enable_source_link\": true}-->\n<!--SNIPEND-->\n\nThe `WorkflowClientInterface` in the snippet is an entry point to get access to Workflow.\nUse an instance of `WorkflowClientInterface` to create, retrieve, or start a Workflow.\nHere we create an instance of `GreetingWorkflowInterface` with a Workflow Execution Timeout of one minute.\n\nThen we print some information and start the Workflow.\n","is_empty":false},{"file_name":"how-to-create-local-activities-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-create-local-activities-in-php.md","id":376,"title":"How to execute a Local Activity in PHP","label":"Local Activity","markdown_content":"\nTo execute a Local Activity, use `#[LocalActivityInterface]`.\n\n```php\nuse Temporal\\Activity\\LocalActivityInterface;\n\n#[ActivityInterface]\ninterface YourActivityInterface\n{\n    #[ActivityMethod(\"youractivity\")]\n    public function youractivity(): string;\n}\n```\n\nLocal Activities requires `LocalActivityOptions`:\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    YourActivityInterface::class,\n    LocalActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n```\n\nLocal Activity Execution options include the following:\n\n- `ScheduleToCloseTimeout`\n- `StartToCloseTimeout`\n- `RetryPolicy`.\n","is_empty":false},{"file_name":"how-to-define-a-query-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-define-a-query-in-php.md","id":377,"title":"How to define a Query in PHP","label":"Define a Query","markdown_content":"\nWorkflows can answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow type defaults to `\"FileProcessingWorkflow\"`.\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-define-a-signal-in-php.md","id":378,"title":"How to define a Signal in PHP","label":"Define a Signal","markdown_content":"\nWorkflows can answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, Signal and Query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow type defaults to `\"FileProcessingWorkflow\"`.\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-define-activity-parameters-in-php.md","id":379,"title":"Define Activity parameters in PHP","label":"Activity parameters","markdown_content":"\nEach method defines a single Activity type.\nA single Workflow can use more than one Activity interface and call more than one Activity method from the same interface.\n\nThe only requirement is that Activity method arguments and return values are serializable to a byte array using the provided [DataConverter](https://github.com/temporalio/sdk-php/blob/master/src/DataConverter/DataConverterInterface.php) interface.\nThe default implementation uses a JSON serializer, but an alternative implementation can be easily configured.\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-define-workflow-return-values-in-php.md","id":380,"title":"Define Workflow return values in PHP","label":"Workflow return values","markdown_content":"\nA Workflow method returns a Generator.\nTo properly typecast the Workflow's return value in the client code, use the `#[ReturnType()]` annotation.\n\n```php\n#[YourWorkflowInterface]\ninterface FileProcessingWorkflow {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-develop-a-worker-program-in-php.md","id":381,"title":"How to develop a Worker Program in PHP","description":"Use the `newWorker()` method on an instance of a `WorkerFactory` to create a new Worker in PHP.","tags":["developer-guide","php","workers"],"markdown_content":"\nThe [RoadRunner application server](https://roadrunner.dev/) will launch multiple Temporal PHP Worker processes based on provided `.rr.yaml` configuration.\n\nEach Worker might connect to one or multiple Task Queues.\nWorker poll _Temporal service_ for tasks, performs those tasks, and communicates task execution results back to the _Temporal service_.\n\nWorker code are developed, deployed, and operated by Temporal customers.\nTo create a worker use `Temporal\\WorkerFactory`:\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nuse Temporal\\WorkerFactory;\n\nini_set('display_errors', 'stderr');\ninclude \"vendor/autoload.php\";\n\n// factory initiates and runs task queue specific activity and workflow workers\n$factory = WorkerFactory::create();\n\n// Worker that listens on a Task Queue and hosts both workflow and activity implementations.\n$worker = $factory->newWorker();\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n\n// Activities are stateless and thread safe. So a shared instance is used.\n$worker->registerActivity(App\\DemoActivity::class);\n\n// In case an activity class requires some external dependencies provide a callback - factory\n// that creates or builds a new activity instance. The factory should be a callable which accepts\n// an instance of ReflectionClass with an activity class which should be created.\n$worker->registerActivity(App\\DemoActivity::class, fn(ReflectionClass $class) => $container->create($class->getName()));\n\n// start primary loop\n$factory->run();\n```\n\nYou can configure task queue name using first argument of `WorkerFactory`->`newWorker`:\n\n```php\n$worker = $factory->newWorker('your-task-queue');\n```\n\nAs mentioned above you can create as many Task Queue connections inside a single Worker Process as you need.\n\nTo configure additional WorkerOptions use `Temporal\\Worker\\WorkerOptions`:\n\n```php\nuse Temporal\\Worker\\WorkerOptions;\n\n$worker = $factory->newWorker(\n    'your-task-queue',\n    WorkerOptions::new()\n        ->withMaxConcurrentWorkflowTaskPollers(10)\n);\n```\n\nMake sure to point the Worker file in application server configuration:\n\n```yaml\nrpc:\n  listen: tcp://127.0.0.1:6001\n\nserver:\n  command: \"php worker.php\"\n\ntemporal:\n  address: \"temporal:7233\"\n  activities:\n    num_workers: 10\n```\n\n> You can serve HTTP endpoints using the same server setup.\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-develop-a-workflow-definition-in-php.md","id":382,"title":"Develop a Workflow Definition in PHP","label":"Workflow Definition","markdown_content":"\nIn PHP, a Workflow is a class method. Classes must implement interfaces that are annotated with `#[YourWorkflowInterface]`. The method that is the Workflow must be annotated with `#[WorkflowMethod]`.\n\n```php\nuse Temporal\\Workflow\\YourWorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\n\n#[YourWorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-develop-an-activity-definition-in-php.md","id":383,"title":"Develop an Activity Definition in PHP","label":"Activity Definition","markdown_content":"\nActivities are defined as methods of a plain PHP interface annotated with `#[YourActivityInterface]`.\n(You can also use PHP 8 attributes in PHP 7.)\n\nFollowing is an example of an interface that defines four Activities:\n\n```php\n#[YourActivityInterface]\n// Defining an interface for the activities.\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName): void;\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName): void;\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName): void;\n}\n```\n\n**How to customize an Activity type**\n\nWe recommend to use a single value type argument for Activity methods.\nIn this way, adding new arguments as fields to the value type is a backward-compatible change.\n\nAn optional `#[ActivityMethod]` annotation can be used to override a default Activity name.\n\nYou can define your own prefix for all Activity names by adding the `prefix` option to the `YourActivityInterface` annotation.\n(The default prefix is empty.)\n\n```php\n#[YourActivityInterface(\"file_activities.\")]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName);\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName);\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName);\n}\n```\n\nThe `#[YourActivityInterface(\"file_activities.\")]` is an annotation that tells the PHP SDK to generate a class to implement the `FileProcessingActivities` interface. The functions define Activites that are used in the Workflow.\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-get-the-result-of-a-workflow-execution-in-php.md","id":384,"title":"How to get the result of an Workflow Execution in PHP","label":"Workflow Execution","markdown_content":"\nIf you need to wait for the completion of a Workflow after an asynchronous start, make a blocking call to\nthe `WorkflowRun`->`getResult` method.\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getResult());\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-get-the-result-of-an-activity-execution-in-php.md","id":385,"title":"How to get the result of an Activity Execution in PHP","label":"Activity Execution","markdown_content":"\n`Workflow::newActivityStub`returns a client-side stub an implements an Activity interface. The client-side stub can be used within the Workflow code. It takes the Activity's type and`ActivityOptions` as arguments.\n\nCalling (via `yield`) a method on this interface invokes an Activity that implements this method.\nAn Activity invocation synchronously blocks until the Activity completes, fails, or times out.\nEven if Activity execution takes a few months, the Workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the Workflow.\nThe business logic code just sees a single method call.\n\n```php\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    private $greetingActivity;\n\n    public function __construct()\n    {\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n        );\n    }\n\n    public function greet(string $name): \\Generator\n    {\n        // This is a blocking call that returns only after the activity has completed.\n        return yield $this->greetingActivity->composeGreeting('Hello', $name);\n    }\n}\n```\n\nIf different Activities need different options, like timeouts or a task queue, multiple client-side stubs can be created with different options.\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 minutes'))\n);\n```\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-handle-a-query-in-a-workflow-in-php.md","id":386,"title":"How to handle a Query in PHP","label":"Handle a Query","markdown_content":"\nYou can add custom Query types to handle Queries such as Querying the current state of a\nWorkflow, or Querying how many Activities the Workflow has completed. To do this, you need to set\nup a Query handler using method attribute `QueryMethod` or `Workflow::registerQueryHandler`.\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\QueryMethod]\n    public function getValue()\n    {\n        return 42;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // workflow code\n    }\n\n}\n```\n\nThe handler function can receive any number of input parameters, but all input parameters must be\nserializable. The following sample code sets up a Query handler that handles the Query type of\n`currentState`:\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private string $currentState;\n\n    #[Workflow\\QueryMethod('current_state')]\n    public function getCurrentState(): string\n    {\n        return $this->currentState;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // Your normal Workflow code begins here, and you update the currentState\n        // as the code makes progress.\n        $this->currentState = 'waiting timer';\n        try{\n            yield Workflow::timer(DateInterval::createFromDateString('1 hour'));\n        } catch (\\Throwable $e) {\n            $this->currentState = 'timer failed';\n            throw $e;\n        }\n\n        $yourActivity = Workflow::newActivityStub(\n            YourActivityInterface::class,\n            ActivityOptions::new()->withScheduleToStartTimeout(60)\n        );\n\n        $this->currentState = 'waiting activity';\n        try{\n            yield $yourActivity->doSomething('some input');\n        } catch (\\Throwable $e) {\n            $this->currentState = 'activity failed';\n            throw $e;\n        }\n\n        $this->currentState = 'done';\n\n        return null;\n    }\n}\n```\n\nYou can also issue a Query from code using the `QueryWorkflow()` API on a Temporal Client object.\n\nUse `WorkflowStub` to Query Workflow instances from your Client code (can be applied to both running and closed Workflows):\n\n```php\n$workflow = $workflowClient->newWorkflowStub(\n    YourWorkflow::class,\n    WorkflowOptions::new()\n);\n\n$workflowClient->start($workflow);\n\nvar_dump($workflow->getCurrentState());\nsleep(60);\nvar_dump($workflow->getCurrentState());\n```\n","is_empty":false},{"file_name":"how-to-handle-workflow-logic-requirements-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-handle-workflow-logic-requirements-in-php.md","id":387,"title":"How to handle Workflow logic requirements in PHP","label":"Activity Execution","markdown_content":"\n\\*\\*Temporal uses the [Microsoft Azure Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover the state of a Workflow object including its local variable values.\n\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nWhen replaying, side effects (such as Activity invocations) are ignored because they are already recorded in the Workflow event history.\nWhen writing Workflow logic, the replay is not visible, so the code should be written since it executes only once.\nThis design puts the following constraints on the Workflow implementation:\n\n- Do not use any mutable global variables because multiple instances of Workflows are executed in parallel.\n- Do not call any non-deterministic functions like non seeded random or `UUID` directly from the Workflow code.\n\nAlways do the following in the Workflow implementation code:\n\n- Don’t perform any IO or service calls as they are not usually deterministic. Use Activities for this.\n- Only use `Workflow::now()` to get the current time inside a Workflow.\n- Call `yield Workflow::timer()` instead of `sleep()`.\n- Do not use any blocking SPL provided by PHP (i.e. `fopen`, `PDO`, etc) in **Workflow code**.\n- Use `yield Workflow::getVersion()` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already open Workflows.\n- Don’t access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\nWorkflow method arguments and return values are serializable to a byte array using the provided [DataConverter](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html) interface.\nThe default implementation uses JSON serializer, but you can use any alternative serialization mechanism.\n\nMake sure to annotate your `WorkflowMethod` using `ReturnType` to specify concrete return type.\n\n> You can not use the default return type declaration as Workflow methods are generators.\n\nThe values passed to Workflows through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to Workflow workers with every event that the Workflow logic needs to process.\nA large execution history can thus adversely impact the performance of your Workflow.\nTherefore, be mindful of the amount of data that you transfer via Activity invocation parameters or return values.\nOtherwise, no additional limitations exist on Activity implementations.\\*\\*\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-remove-search-attributes-from-a-workflow-in-php.md","id":388,"title":"How to remove Search Attributes from a Workflow in PHP","label":"Remove Search Attributes","markdown_content":"\nTo remove a Search Attribute that was previously set, set it to an empty array `[]`.\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-send-a-signal-from-a-workflow-in-php.md","id":389,"title":"How to send Signal a Workflow in PHP","label":"Signal a Workflow","markdown_content":"\nTo send signal to a Workflow use `WorkflowClient`->`newWorkflowStub` or `WorkflowClient`->`newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient`->`newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with Workflow Id to send\nSignals to a running Workflow.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-send-a-signal-with-start-in-php.md","id":390,"title":"How to send Signal-With-Start in PHP","label":"Signal-With-Start","markdown_content":"\nIn cases where you may not know if a Workflow is running, and want to send a Signal to it, use `startwithSignal`.\nIf a running Workflow exists, the `startwithSignal` API sends the Signal.\nIf there is no running Workflow, the API starts a new Workflow Run and delivers the Signal to it.\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->startWithSignal(\n    $workflow,\n    'setValue',\n    [true], // signal arguments\n    [] // start arguments\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-cron-schedule-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-cron-schedule-in-php.md","id":391,"title":"How to set a CRON schedule in PHP","label":"Activity Execution","markdown_content":"\nSet your Cron Schedule with `CronSchedule('* * * * *')`.\n\nThe following example sets a Cron Schedule in PHP:\n\n```php\n  $workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()\n          ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n          ->withCronSchedule('* * * * *')\n          // Execution timeout limits total time. Cron will stop executing after this timeout.\n          ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n          // Run timeout limits duration of a single workflow invocation.\n          ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n  );\n\n  $output->writeln(\"Starting <comment>CronWorkflow</comment>... \");\n\n  try {\n      $run = $this->workflowClient->start($workflow, 'Antony');\n      // ...\n  }\n```\n\nSetting `withCronSchedule` turns the Workflow Execution into a Temporal Cron Job.\nFor more information, see the [PHP samples](https://github.com/temporalio/samples-php/tree/master/app/src/Cron) for example code or the PHP SDK `WorkflowOptions` [source code](https://github.com/temporalio/sdk-php/blob/master/src/Client/WorkflowOptions.php).\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-for-an-activity-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-heartbeat-for-an-activity-in-php.md","id":392,"title":"How to set a Heartbeat for an Activity in PHP","label":"Heartbeat an Activity","markdown_content":"\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-heartbeat-timeout-in-php.md","id":393,"title":"How to set a Heartbeat Timeout in PHP","label":"Heartbeat Timeout","markdown_content":"\nSome Activities are long-running.\nTo react to a crash quickly, use the Heartbeat mechanism, `Activity::heartbeat()`, which lets the Temporal Server know that the Activity is still alive.\nThis acts as a periodic checkpoint mechanism for the progress of an Activity.\n\nYou can piggyback `details` on an Activity Heartbeat.\nIf an Activity times out, the last value of `details` is included in the `TimeoutFailure` delivered to a Workflow.\nThen the Workflow can pass the details to the next Activity invocation.\nAdditionally, you can access the details from within an Activity via `Activity::getHeartbeatDetails`.\nWhen an Activity is retried after a failure `getHeartbeatDetails` enables you to get the value from the last successful Heartbeat.\n\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-schedule-to-close-timeout-in-php.md","id":394,"title":"How to set Schedule-to-Close Timeout in PHP","label":"Schedule-to-Start Timeout","markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-schedule-to-start-timeout-in-php.md","id":395,"title":"How to set Schedule-to-Start Timeout in PHP","label":"Schedule-to-Start Timeout","markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `ScheduleToStartTimeout` set to 10 seconds.\n\n```php\n// Creating a stub for the activity.\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()\n                ->withScheduleToStartTimeout(CarbonInterval::seconds(10))\n        );\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-start-to-close-timeout-in-php.md","id":396,"title":"How to set Start-to-Close Timeout in PHP","label":"Start-to-Close Timeout","markdown_content":"\nBecause Activities are reentrant, only a single stub can be used for multiple Activity invocations.\nThe following code creates an Activity with a `StartToCloseTimeout` set to 2 seconds.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(CarbonInterval::seconds(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-execution-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-workflow-execution-timeout-in-php.md","id":397,"title":"How to set Workflow Execution Timeout in PHP","label":"Workflow Execution Timeout","markdown_content":"\nThe following code example creates a new Workflow and sets the Workflow ID. Then it sets the Workflow ID resuse policy and the Workflow Execution Timeout to 2 minutes.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    DynamicSleepWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(DynamicSleepWorkflow::WORKFLOW_ID)\n        ->withWorkflowIdReusePolicy(WorkflowIdReusePolicy::WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(2))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-workflow-id-in-php.md","id":398,"title":"How to set a Workflow Id in PHP","label":"Workflow Id","markdown_content":"\nThe following code example grabs the `userID` as an input and uses it to start the Workflow. The `userID` is used as Workflow Id. You can use this to cancel your Workflow later.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(string $userID);\n}\n```\n\nThe following code example, uses the input parameter `userID` as the Workflow Id.\n\n```php\n#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(\n        string $userID\n    );\n}\n```\n\nYou can also set the Workflow Id as a constant, for example:\n\n```php\n public const WORKFLOW_ID = Your-Workflow-Id\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-run-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-workflow-run-timeout-in-php.md","id":399,"title":"How to set Workflow Run Timeout in PHP","label":"Workflow Run Timeout","markdown_content":"\n`WorkflowRunTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-workflow-task-queue-in-php.md","id":400,"title":"How to set a Workflow Task Queue in PHP","label":"Task Queues","markdown_content":"\nIn PHP, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```php\n// Create new Workflow Options and set the Task Queue\n$workflowOptions = WorkflowOptions::new()\n  ->withTaskQueue(\"Workflow-Task-Queue-1\")\n  // ...\n\n$yourWorkflow = $workflowClient->newWorkflowStub(\n  YourWorkflowInterface::class,\n  $workflowOptions\n);\n\n$result = $yourWorkflow->workflowMethod();\n\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```php\nuse Temporal\\WorkerFactory;\n\n// Create a Worker Factory\n$factory = WorkerFactory::create();\n\n// Set the Task Queue when creating the Worker\n$worker = $factory->newWorker(\"Workflow-Task-Queue-1\");\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(YourWorkflow::class);\n\n// start primary loop\n$factory->run();\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```php\nclass YourWorkflow implements YourWorkflowInterface\n{\n  private $yourActivity;\n\n  public function __construct()\n  {\n    // Create Activity options and set the Task Queue\n    $activityOptions = ActivityOptions::new()\n      ->withTaskQueue(\"Activity-Task-Queue-1\")\n      // ...\n\n    // Create a new Activity Stub and pass the options\n    $this->yourActivity = Workflow::newActivityStub(\n      YourActivityInterface::class,\n      $activityOptions\n    );\n  }\n\n  public function workflowMethod(): \\Generator\n  {\n    // Call the Activity\n    return yield $this->yourActivity->activityMethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```php\n//Create new Child Workflow Options and set the Task Queue\n$childWorkflowOptions = ChildWorkflowOptions::new()\n    ->withTaskQueue(\"Child-Workflow-Task-Queue-1\")\n    // ...\n\n// Create a new Child Workflow Stub and set the Task Queue\n$childWorkflow = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    $childWorkflowOptions\n);\n\n// Call the Child Workflow method\n$promise = $childWorkflow->workflowMethod();\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-timeout-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-a-workflow-task-timeout-in-php.md","id":401,"title":"How to set Workflow Task Timeout in PHP","label":"Workflow Task Timeout","markdown_content":"\n`WorkflowTaskTimeout` runs timeout limits duration of a single Workflow invocation.\n\n```php\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        ->withWorkflowTaskTimeout(CarbonInterval::minute(1))\n);\n```\n","is_empty":false},{"file_name":"how-to-set-activity-retry-options-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-activity-retry-options-in-php.md","id":402,"title":"How to set Activity Retry Options in PHP","label":"Activity Retry Options","markdown_content":"\nTo enable Activity Retry, set `{@link RetryOptions}` on `{@link ActivityOptions}`.\nThe follow example creates a new Activity with the given options.\n\n```php\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(10))\n        ->withRetryOptions(\n            RetryOptions::new()\n                ->withInitialInterval(CarbonInterval::seconds(1))\n                ->withMaximumAttempts(5)\n                ->withNonRetryableExceptions([\\InvalidArgumentException::class])\n        )\n);\n}\n```\n\nFor an executable code sample, see [ActivityRetry sample](https://github.com/temporalio/samples-php/tree/master/app/src/ActivityRetry) in the PHP samples repository.\n","is_empty":false},{"file_name":"how-to-set-asynchronous-activity-completion-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-set-asynchronous-activity-completion-in-php.md","id":403,"title":"How to set asynchronous Activity completion in PHP","label":"Asynchronous Activity completion","markdown_content":"\nSometimes Workflows need to perform certain operations in parallel.\n\nInvoking activity stub without the use of `yield` will return the Activity result promise which can be resolved at later moment.\nCalling `yield` on promise blocks until a result is available.\n\n> Activity promise also exposes `then` method to construct promise chains.\n> Read more about Promises [here](https://github.com/reactphp/promise).\n\nAlternatively you can explicitly wrap your code (including `yield` constucts) using `Workflow::async` which will execute nested code in parallel with main Workflow code.\nCall `yeild` on Promise returned by `Workflow::async` to merge execution result back to primary Workflow method.\n\n```php\npublic function greet(string $name): \\Generator\n{\n    // Workflow::async runs it's activities and child workflows in a separate coroutine. Use keyword yield to merge\n    // it back to parent process.\n\n    $first = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Bye', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    $second = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hola', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Chao', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    // blocks until $first and $second complete\n    return (yield $first) . \"\\n\" . (yield $second);\n}\n```\n\n**Async completion**\n\nThere are certain scenarios when moving on from an Activity upon completion of its function is not possible or desirable.\nFor example, you might have an application that requires user input to complete the Activity.\nYou could implement the Activity with a polling mechanism, but a simpler and less resource-intensive implementation is to asynchronously complete a Temporal Activity.\n\nThere are two parts to implementing an asynchronously completed Activity:\n\n1. The Activity provides the information necessary for completion from an external system and notifies the Temporal service that it is waiting for that outside callback.\n2. The external service calls the Temporal service to complete the Activity.\n\nThe following example demonstrates the first part:\n\n<!--SNIPSTART samples-php-async-activity-completion-activity-class-->\n<!--SNIPEND-->\n\nThe following code demonstrates how to complete the Activity successfully using `WorkflowClient`:\n\n<!--SNIPSTART samples-php-async-activity-completion-completebytoken-->\n<!--SNIPEND-->\n\nTo fail the Activity, you would do the following:\n\n```php\n// Fail the Activity.\n$activityClient->completeExceptionallyByToken($taskToken, new \\Error(\"activity failed\"));\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-child-workflow-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-spawn-a-child-workflow-execution-in-php.md","id":404,"title":"How to spawn a Child Workflow Execution in PHP","label":"Child Workflow Execution","markdown_content":"\nBesides Activities, a Workflow can also start other Workflows.\n\n`Workflow::executeChildWorkflow` and `Workflow::newChildWorkflowStub` enables the scheduling of other Workflows from within a Workflow's implementation.\nThe parent Workflow has the ability to monitor and impact the lifecycle of the child Workflow, similar to the way it does for an Activity that it invoked.\n\n```php\n// Use one stub per child workflow run\n$child = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    ChildWorkflowOptions::new()\n        // Do not specify WorkflowId if you want Temporal to generate a unique Id\n        // for the child execution.\n        ->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW')\n        ->withExecutionStartToCloseTimeout(DateInterval::createFromDateString('30 minutes'))\n);\n\n// This is a non blocking call that returns immediately.\n// Use yield $child->workflowMethod(name) to call synchronously.\n$promise = $child->workflowMethod('value');\n\n// Do something else here.\ntry{\n    $value = yield $promise;\n} catch(TemporalException $e) {\n    $logger->error('child workflow failed');\n    throw $e;\n}\n```\n\nLet's take a look at each component of this call.\n\nBefore calling `$child->workflowMethod()`, you must configure `ChildWorkflowOptions` for the invocation.\nThese options customize various execution timeouts, and are passed into the workflow stub defined by the `Workflow::newChildWorkflowStub`.\nOnce stub created you can invoke its Workflow method based on attribute `WorkflowMethod`.\n\nThe method call returns immediately and returns a `Promise`.\nThis allows you to execute more code without having to wait for the scheduled Workflow to complete.\n\nWhen you are ready to process the results of the Workflow, call the `yield $promise` method on the returned promise object.\n\nWhen a parent Workflow is cancelled by the user, the child Workflow can be cancelled or abandoned based on a configurable child policy.\n\nYou can also skip the stub part of child workflow initiation and use `Workflow::executeChildWorkflow` directly:\n\n```php\n// Use one stub per child workflow run\n$childResult = yield Workflow::executeChildWorkflow(\n    'ChildWorkflowName',\n    ['args'],\n    ChildWorkflowOptions::new()->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW'),\n    Type::TYPE_STRING // optional: defines the return type\n);\n```\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-php.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/how-to-spawn-an-activity-execution-in-php.md","id":405,"title":"How to spawn an Activity Execution in PHP","label":"Spawn an Activity Execution","markdown_content":"\nActivity implementation is an implementation of an Activity interface.\nThe following code example, uses a constructor that takes an Amazon S3 client and a local directory, and uploads a file to the S3 bucket.\nThen, the code uses a function to download a file from the S3 bucket passing a bucket name, remote name, and local name as arguments.\nFinally, it uses a function that takes a local file name as an argument and returns a string.\n\n```php\n// An implementation of an Activity interface.\nclass FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n    private S3Client $s3Client;\n\n    private string $localDirectory;\n\n    public function __construct(S3Client $s3Client, string $localDirectory) {\n        $this->s3Client = $s3Client;\n        $this->localDirectory = $localDirectory;\n    }\n\n    // Uploading a file to S3.\n    public function upload(string $bucketName, string $localName, string $targetName): void\n    {\n        $this->s3Client->putObject(\n            $bucketName,\n            $targetName,\n            fopen($this->localDirectory . $localName, 'rb+')\n        );\n    }\n\n// Downloading a file from S3.\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->s3Client->downloadObject(\n            $bucketName,\n            $remoteName,\n            fopen($this->localDirectory .$localName, 'wb+')\n        );\n    }\n\n// A function that takes a local file name as an argument and returns a string.\n    public function processFile(string $localName): string\n    {\n        // Implementation omitted for brevity.\n        return compressFile($this->localDirectory . $localName);\n    }\n\n    public function deleteLocalFile(string $fileName): void\n    {\n        unlink($this->localDirectory . $fileName);\n    }\n}\n```\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/index.md","id":406,"title":"How to use the Temporal PHP SDK","description":"Add the Temporal PHP SDK to your project.","tags":["developer-guide","php"],"markdown_content":"\n[![CI Status](https://github.com/temporalio/php-sdk/workflows/Unit/badge.svg)](https://github.com/temporalio/php-sdk/actions)\n[![Stable Release](https://poser.pugx.org/temporal/sdk/version)](https://packagist.org/packages/temporal/sdk)\n[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2Ftemporalio%2Fsdk-php?ref=badge_shield)\n\nThe Temporal PHP SDK is available as composer package and can be installed using the following command in a root of your project:\n\n```bash\ncomposer require temporal/sdk\n```\n\nThe Temporal PHP SDK requires the RoadRunner 2.0 application server and supervisor to run Activities and Workflows in a scalable way.\n\nInstall RoadRunner manually by downloading its binary from the [release page](https://github.com/roadrunner-server/roadrunner/releases/tag/v1.9.2).\n\nOr install RoadRunner through the CLI:\n\n```bash\ncomposer require spiral/roadrunner:v2.0 nyholm/psr7\n./vendor/bin/rr get-binary\n```\n","is_empty":false},{"file_name":"introduction.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/introduction.md","id":407,"title":"PHP SDK introduction","label":"PHP SDK introduction","markdown_content":"\n## Quick start\n\n1. Clone the [Temporal PHP SDK](https://github.com/temporalio/sdk-php) or add it as dependency to your project using a dependency management tool like composer:\n\n```composer\n\"require\": {\n    \"temporal/sdk\": \">=1.0\",\n  },\n```\n\n2. [Install and run the Temporal Server](/clusters/quick-install) using `docker compose`.\n\n## Tutorials\n\n- You should orient yourself to the Hello World with [the PHP Hello World Walkthrough](https://learn.temporal.io/getting_started/php/hello_world_in_php/).\n- For those interested in distributed transactions, see the [Booking Saga Tutorial and code sample](https://learn.temporal.io/tutorials/php/booking_saga/).\n- For a more non-trivial discussion of an application, see [the Subscription Tutorial](https://learn.temporal.io/tutorials/php/subscriptions/) or [browse the code directly](https://github.com/temporalio/subscription-workflow-project-template-php).\n\nMuch more detailed API samples can be viewed in [the Samples Repo](https://github.com/temporalio/samples-php).\n\n## Resources\n\n- Join the `#php-sdk` channel on the [Temporal Slack](https://temporal.io/slack) or [open issues on GitHub](https://github.com/temporalio/sdk-php/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc).\n- PHP SDK samples\n  - [Beginner-advanced library](https://github.com/temporalio/samples-php#samples)\n  - [Subscription Workflow sample](https://github.com/temporalio/subscription-workflow-project-template-php)\n- Talks\n  - 🆕 PHPConf 2021: [Fault tolerant workflow orchestration on PHP](https://www.youtube.com/watch?v=pdxHkIqX62A)\n  - PHPConf 2020: [Designing hybrid Go/PHP applications using RoadRunner](https://www.youtube.com/watch?v=mj6d-IGzSYE)\n  - (Slides) [Distributed Workflows on PHP](https://docs.google.com/presentation/d/1NBZlnJFCc-PgYxQk0_YYxUTmfKgzUf6Z-XHXfPETLac/edit?usp=sharing)\n  - (Russian) [Orchestrate it! Complex business processes in PHP](https://www.youtube.com/watch?v=upL8o-OXYEc) (2 hour workshop)\n  - (Russian) [Orchestration and Murphy's Law: Handling Errors-Business Processes](https://www.youtube.com/watch?v=0NCMEaFMj_M) (2 hour workshop)\n  - (Russian) PHP Russia https://phprussia.ru/moscow/2021/abstracts/7390 (video pending)\n  - (Russian) [FWDays Keynote: Fault Tolerant Workflow Orchestration on PHP](https://fwdays.com/en/event/php-fwdays-2021/review/fault-tolerant-workflow-orchestration-on-php) (video pending)\n- The PHP SDK is often used with [Roadrunner](https://roadrunner.dev/) (maintained by [SpiralScout](https://github.com/spiral?type=source), the maintainers of the PHP SDK)\n\n## The basics\n\n- [Workflows](/php/workflows)\n\n- [Activities](/php/activities)\n\n- [Workers](/php/workers)\n\n- [Task Queues](/php/task-queues)\n\n- [Signals](/php/signals)\n\n- [Queries](/php/queries)\n","is_empty":false},{"file_name":"queries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/queries.md","id":408,"title":"Queries in PHP","label":"Queries","tags":["php"],"markdown_content":"\nIf a Workflow execution has been stuck at a state for longer than an expected period of time, you\nmight want to query the current call stack. You can use the Temporal CLI to perform this query. For\nexample:\n\n`tctl --namespace samples-namespace workflow query -w your_workflow_id -r your_run_id -qt __stack_trace`\n\n> You can also access the stack trace from Temporal Web UI.\n\nThis command uses `__stack_trace`, which is a built-in query type supported by the Temporal client\nlibrary. You can add custom query types to handle queries such as querying the current state of a\nWorkflow, or querying how many Activities the Workflow has completed. To do this, you need to set\nup a query handler using method attribute `QueryMethod` or `Workflow::registerQueryHandler`.\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\QueryMethod]\n    public function getValue()\n    {\n        return 42;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // workflow code\n    }\n\n}\n```\n\nThe handler function can receive any number of input parameters, but all input parameters must be\nserializable. The following sample code sets up a query handler that handles the query type of\n`currentState`:\n\n```php\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private string $currentState;\n\n    #[Workflow\\QueryMethod('current_state')]\n    public function getCurrentState(): string\n    {\n        return $this->currentState;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // Your normal Workflow code begins here, and you update the currentState\n        // as the code makes progress.\n        $this->currentState = 'waiting timer';\n        try{\n            yield Workflow::timer(DateInterval::createFromDateString('1 hour'));\n        } catch (\\Throwable $e) {\n            $this->currentState = 'timer failed';\n            throw $e;\n        }\n\n        $yourActivity = Workflow::newActivityStub(\n            YourActivityInterface::class,\n            ActivityOptions::new()->withScheduleToStartTimeout(60)\n        );\n\n        $this->currentState = 'waiting activity';\n        try{\n            yield $YourActivity->doSomething('some input');\n        } catch (\\Throwable $e) {\n            $this->currentState = 'activity failed';\n            throw $e;\n        }\n\n        $this->currentState = 'done';\n\n        return null;\n    }\n}\n```\n\nYou can now query `current_state` by using the CLI:\n\n`tctl --namespace samples-namespace workflow query -w your_workflow_id -r your_run_id -qt current_state`\n\nYou can also issue a query from code using the `QueryWorkflow()` API on a Temporal client object.\n\nUse WorkflowStub to query workflow instances from your client code (can be applied to running workflows as well):\n\n```php\n$workflow = $workflowClient->newWorkflowStub(\n    YourWorkflow::class,\n    WorkflowOptions::new()\n);\n\n$workflowClient->start($workflow);\n\nvar_dump($workflow->getCurrentState());\nsleep(60);\nvar_dump($workflow->getCurrentState());\n```\n","is_empty":false},{"file_name":"retries.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/retries.md","id":409,"title":"Activity and Workflow Retries","markdown_content":"\nActivities and Workflows can fail for a number of expected and unexpected reasons.\nIn most failure cases, we want to retry the failed Activity or child Workflow or even the parent Workflow.\nBy default, Temporal retries Activities, but not Workflows.\nTo change the default behavior, a custom retry policy can be provided.\n\nTo change the default behavior, a custom retry policy can be provided.\n\nA retry policy is defined as a `Temporal\\Common\\RetryOptions` object:\n\n```php\nuse Temporal\\Common\\RetryOptions;\n\n$retry = RetryOptions::new()\n\n    // Backoff interval for the first retry. If coefficient is 1.0\n    // then it is used for all retries. Required, no default value.\n    ->withInitialInterval(120) // seconds or DateInterval\n\n    // Coefficient used to calculate the next retry backoff interval.\n    // The next retry interval is previous interval multiplied\n    // by this coefficient.\n    // Must be 1 or larger. Default is 2.0.\n    ->withBackoffCoefficient(1)\n\n    // Maximum backoff interval between retries. Exponential backoff\n    // leads to interval increase. This value is the cap of the interval.\n    // Default is 100x of initial interval.\n    ->withMaximumInterval(600) // seconds or DateInterval\n\n    // Maximum number of attempts. When exceeded the retries stop even\n    // if not expired yet. If not set or set to 0, it means unlimited\n    ->withMaximumAttempts(10)\n\n    // Non-Retriable errors. This is optional. Temporal server will stop\n    // retry if error type matches this list.\n    //\n    // Note:\n    //  - cancellation is not a failure, so it won't be retried,\n    //  - only StartToClose or Heartbeat timeouts are retryable.\n    ->withNonRetryableExceptions([\\App\\DatabaseException::class]);\n```\n\nTo enable or customize retries, provide a custom retry policy as part of `ActivityOptions` or `ChildWorkflowOptions`.\n\n```php\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(10))\n        ->withRetryOptions(\n            RetryOptions::new()->withMaximumAttempts(10)\n        )\n);\n```\n\nIf an Activity heartbeat its progress before it failed, the retry attempt will have access to the progress information,\nso that the Activity implementation could resume from the failed step. Here's an example of how this can be implemented:\n\n```php\nuse Temporal\\Activity;\nuse Temporal\\DataConverter\\Type;\n// ...\n\n#[Activity\\ActivityInterface('YourActivity_')]\nclass YourActivity\n{\n  public function sampleActivity(int $startIndex, int $lastIndex)\n  {\n      if (Activity::hasHeartbeatDetails()) {\n          // Recover from finished progress.\n          $lastIndex = Activity::getHeartbeatDetails(Type::TYPE_INT);\n          $startIndex = $lastIndex + 1;// Start from next one.\n      }\n\n      // Normal Activity logic...\n      for ($i = $startIndex; $i < $lastIndex; $i++) {\n          // Code for processing item i goes here...\n          Activity::recordHeartbeat($i); // Report progress.\n      }\n  }\n}\n```\n\nTo enable retries for a Workflow, you need to provide a retry policy via `ChildWorkflowOptions` for child Workflows or\nvia `WorkflowOptions` for top-level Workflows.\n\nThere are some subtle nuances to how Workflow's history events are recorded when a `RetryOptions` is used.\nFor an Activity with a `RetryOptions`:\n\n- The `ActivityTaskScheduledEvent` will have extended `ScheduleToStartTimeout` and `ScheduleToCloseTimeout`.\n- The `ActivityTaskStartedEvent` will not show up in history until the Activity is completed or failed with no more retry.\n  This is to avoid filling the history with noise records of intermittent failures and retries.\n  For Activities being retried, `DescribeWorkflowExecution` will return a `PendingActivityInfo` that includes `attemptCount`.\n\nFor a Workflow with `RetryOptions`:\n\n- If a Workflow fails and a retry policy is configured for it, the Workflow execution will be closed with a `ContinueAsNew` event.\n  This event will have the `ContinueAsNewInitiator` field set to `RetryOptions` and the new `RunId` for the next retry attempt.\n- The new attempt will be created immediately. But the first workflow task won't be scheduled until the backoff duration.\n  That duration is recorded as the `firstWorkflowTaskBackoff` field of the new run's `WorkflowExecutionStartedEventAttributes` event.\n","is_empty":false},{"file_name":"side-effect.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/side-effect.md","id":410,"title":"SideEffect","markdown_content":"\n`Workflow::sideEffect` is useful for short, nondeterministic code snippets, such as getting a random\nvalue or generating a UUID. It executes the provided function once and records its result into the\nWorkflow history. `Workflow::sideEffect` does not re-execute upon replay, but instead returns the\nrecorded result. It can be seen as an \"inline\" Activity.\n\nSomething to note about `Workflow::sideEffect`\nis that, unlike the Temporal guarantee of at-most-once execution for Activities, there is no such\nguarantee with `Workflow::sideEffect` . Under certain failure conditions, `Workflow::sideEffect` can\nend up executing a function more than once.\n\nThe only way to fail `sideEffect` is to throw an exception, which causes a workflow task failure. After the\ntimeout, Temporal reschedules and then re-executes the workflow task, giving `SideEffect` another chance\nto succeed. Do not return any data from `sideEffect` other than through its recorded return value.\n\nThe following sample demonstrates how to use `SideEffect`:\n\n```php\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        $random = yield Workflow::sideEffect(fn()=> return random_int(0, 100));\n        if ($random < 100) {\n            // ...\n        } else {\n            // ...\n        }\n    }\n}\n```\n","is_empty":false},{"file_name":"signals.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/signals.md","id":411,"title":"Signals in PHP","label":"Signals","tags":["php"],"markdown_content":"\nimport {RelatedReadContainer, RelatedReadItem} from '../components/RelatedReadList.js'\n\n<!-- prettier-ignore -->\nimport * as WhatIsASignal from '../concepts/what-is-a-signal.md'\n\n<RelatedReadContainer>\n  <RelatedReadItem page={WhatIsASignal} />\n</RelatedReadContainer>\n\n```php\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private bool $value;\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        yield Workflow::await(fn()=> $this->value);\n        return 'OK';\n    }\n\n    #[Workflow\\SignalMethod]\n    public function setValue(bool $value)\n    {\n        $this->value = $value;\n    }\n}\n```\n\nIn the example above the workflow updates the protected value. Main workflow coroutine waits for such value to change using\n`Workflow::await` function.\n\nTo send signal to workflow use `WorkflowClient`->`newWorkflowStub` or `WorkflowClient`->`newUntypedWorkflowStub`:\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\nUse `WorkflowClient`->`newRunningWorkflowStub` or `WorkflowClient->newUntypedRunningWorkflowStub` with workflow id to send\nsignals to already running workflows.\n\n```php\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n\n## SignalWithStart\n\nYou may not know if a Workflow is running and can accept a signal. The\n`WorkflowClient`->`startWithSignal` API\nallows you to send a signal to the current Workflow instance if one exists or to create a new\nrun and then send the signal.\n\n```php\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->startWithSignal(\n    $workflow,\n    'setValue',\n    [true], // signal arguments\n    [] // start arguments\n);\n```\n","is_empty":false},{"file_name":"task-queues.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/task-queues.md","id":412,"title":"Task Queues in PHP","label":"Task Queues","markdown_content":"\nIn PHP, a Task Queue is represented in code by its name as a `string`.\nThere are four places where the name of the Task Queue is supplied by the developer.\n\n1. When starting a Workflow, a Task Queue name must be provided in the `StartWorkflowOptions`.\n\n```php\n// Create new Workflow Options and set the Task Queue\n$workflowOptions = WorkflowOptions::new()\n  ->withTaskQueue(\"Workflow-Task-Queue-1\")\n  // ...\n\n$yourWorkflow = $workflowClient->newWorkflowStub(\n  YourWorkflowInterface::class,\n  $workflowOptions\n);\n\n$result = $yourWorkflow->workflowMethod();\n\n```\n\n2. A Task Queue name must be provided as a parameter when creating a Worker.\n\n```php\nuse Temporal\\WorkerFactory;\n\n// Create a Worker Factory\n$factory = WorkerFactory::create();\n\n// Set the Task Queue when creating the Worker\n$worker = $factory->newWorker(\"Workflow-Task-Queue-1\");\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(YourWorkflow::class);\n\n// start primary loop\n$factory->run();\n```\n\nA single Worker can listen to only one Task Queue.\nAnd, it is important to remember that the name of the Task Queue the Worker is listening to must match the name of the Task Queue provided in the options to any given Workflow or Activity.\n\nAll Workers listening to the same Task Queue name must be registered to handle the exact same Workflows Types and Activity Types.\n\nIf a Worker polls a Task for a Workflow Type or Activity Type it does not know about, it will fail that Task.\nHowever, the failure of the Task will not cause the associated Workflow Execution to fail.\n\n3. Optionally, the name of a Task Queue can be provided in the `ActivityOptions` when calling an Activity from a Workflow.\n\n```php\nclass YourWorkflow implements YourWorkflowInterface\n{\n  private $yourActivity;\n\n  public function __construct()\n  {\n    // Create Activity options and set the Task Queue\n    $activityOptions = ActivityOptions::new()\n      ->withTaskQueue(\"Activity-Task-Queue-1\")\n      // ...\n\n    // Create a new Activity Stub and pass the options\n    $this->yourActivity = Workflow::newActivityStub(\n      YourActivityInterface::class,\n      $activityOptions\n    );\n  }\n\n  public function workflowMethod(): \\Generator\n  {\n    // Call the Activity\n    return yield $this->yourActivity->activityMethod();\n  }\n}\n```\n\nIf a Task Queue name is not provided in the `ActivityOptions`, then the Activity Tasks are placed in the same Task Queue as the Workflow Task Queue.\n\n4. Optionally, the name of a Task Queue can be provided in the `ChildWorkflowOptions` when calling a Child Workflow.\n\n```php\n//Create new Child Workflow Options and set the Task Queue\n$childWorkflowOptions = ChildWorkflowOptions::new()\n    ->withTaskQueue(\"Child-Workflow-Task-Queue-1\")\n    // ...\n\n// Create a new Child Workflow Stub and set the Task Queue\n$childWorkflow = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    $childWorkflowOptions\n);\n\n// Call the Child Workflow method\n$promise = $childWorkflow->workflowMethod();\n```\n\nIf a Task Queue name is not provided in the `ChildWorkflowOptions`, then the Child Workflow Tasks are placed in the same Task Queue as the Parent Workflow Task Queue.\n","is_empty":false},{"file_name":"testing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/testing.md","id":413,"title":"Testing PHP Workflows","label":"Testing","markdown_content":"\n## Testing Workflows\n\nThe PHP SDK provides tools for testing Workflows without running a regular Temporal Cluster. Instead, it uses a light-weight testing server.\n\n### Quick start\n\n1. Create `bootstrap.php` in `tests` folder with the following contents:\n\n```php\ndeclare(strict_types=1);\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse Temporal\\Testing\\Environment;\n\n$environment = Environment::create();\n$environment->start();\nregister_shutdown_function(fn () => $environment->stop());\n```\n\n2. Add `bootstrap.php` to your `phpunit.xml`:\n\n```xml\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/9.3/phpunit.xsd\"\n         bootstrap=\"tests/bootstrap.php\"\n>\n</phpunit>\n```\n\n3. Add test server executable to `.gitignore`:\n\n```gitignore\ntemporal-test-server\n```\n\n### How it works\n\nFor testing workflows there is no need to run a full Temporal server (with storage and UI interface).\nInstead, we can use a light-weight test server.\n\nThe code in `bootstrap.php` will start/stop (and download if it doesn't exist) Temporal test\nserver and RoadRunner for every phpunit run. Test server runs as a regular server on 7233 port.\nThus, if you use default connection settings, there is no need to change them.\n\nUnder the hood RoadRunner is started with `rr serve` command. You can specify your own command in `bootstrap.php`:\n\n```php\n$environment->start('./rr serve -c .rr.test.yaml -w tests');\n```\n\nThe snippet above will start Temporal test server and RoadRunner with `.rr.test.yaml` config and `tests` working\n\ndirectory. Having a separate RoadRunner config file for tests can be useful to mock you activities. For\nexample, you can create a separate _worker_ that registers activity implementations mocks:\n\n```yaml\n# test/.rr.test.yaml\nserver:\n  command: \"php worker.test.php\"\n```\n\nAnd within the worker you register your Workflows and mock Activities:\n\n```php\n// worker.test.php\n$factory = WorkerFactory::create();\n\n$worker = $factory->newWorker();\n$worker->registerWorkflowTypes(YourWorkflow::class);\n$worker->registerActivity(MyActvivityMock::class);\n$factory->run();\n```\n\nYou can test Workflows by running them with a Workflow Client like this:\n\n```php\nfinal class SimpleWorkflowTestCase extends TestCase\n{\n    private WorkflowClient $workflowClient;\n\n    protected function setUp(): void\n    {\n        $this->workflowClient = new WorkflowClient(\n            ServiceClient::create('localhost:7233')\n        );\n\n        parent::setUp();\n    }\n\n    public function testWorkflowReturnsUpperCasedInput(): void\n    {\n        $workflow = $this->workflowClient->newWorkflowStub(SimpleWorkflow::class);\n        $run = $this->workflowClient->start($workflow, 'hello');\n        $this->assertSame('HELLO', $run->getResult('string'));\n    }\n}\n```\n\n### Time management\n\nIf we consider Activities as some external code that can be mocked than unit-testing your Workflows becomes\nstraight-forward:\n\n1. Register activity mocks in a separate \"test\" worker.\n2. In your test create a `WorkflowClient`.\n3. Use `WorkflowClient` to run the Workflow and assert the result.\n\nThe problem may occur when your Workflow depends on some time changes: it waits for timeout or some other conditions.\nIn unit tests we don't want to waste time waiting for timeouts. Thus, by default, the test server starts with\n\na _\"time-skipping\"_ option. It means that if the workflow has a timer, the server doesn't wait for it and\ncontinues immediately. For example, when testing such a workflow the test server will not wait for a minute:\n\n```php\n#[WorkflowInterface]\nfinal class WaitWorkflow\n{\n    #[WorkflowMethod]\n    public function run(string $input)\n    {\n        $simple = Workflow::newActivityStub(\n            SimpleActivity::class,\n            ActivityOptions::new()->withStartToCloseTimeout(5)\n        );\n\n        yield Workflow::timer('1 minute');\n\n        return yield $simple->echo($input);\n    }\n}\n```\n\nThe activity will be called immediately. But, there may be cases when you do need to wait. So, to change this behaviour\nyou can use `TestService` class:\n\n```php\n$testService = TestService::create('localhost:7233');\n$testService->lockTimeSkipping();\n\n// ...\n$testService->unlockTimeSkipping();\n```\n\nClass `TestService` communicates with a test server and provides method for _time management_. Time skipping\ncan be switched on/off with `unlockTimeSkipping()` and `lockTimeSkipping()` method:\n\n```php\nfinal class WaitTestCase extends TestCase\n{\n    private WorkflowClient $workflowClient;\n\n    protected function setUp(): void\n    {\n        $this->workflowClient = new WorkflowClient(\n            ServiceClient::create('localhost:7233')\n        );\n\n        parent::setUp();\n    }\n\n    public function testSimpleAwait()\n    {\n        $testService = TestService::create('localhost:7233');\n        $testService->lockTimeSkipping();\n\n        $wait = $this->workflowClient->newWorkflowStub(WaitWorkflow::class);\n        $run = $this->workflowClient->start($wait, 'hello');\n\n        $testService->unlockTimeSkipping();\n        $this->assertSame('HELLO', $run->getResult('string'));\n    }\n}\n```\n\nFor convenience if you don't want to skip time in the whole `TestCase` class use `WithoutTimeSkipping`:\n\n```php\nfinal class WaitTestCase extends TestCase\n{\n    use WithoutTimeSkipping;\n\n    // ...\n}\n```\n\nIn case you need to emulate some \"waiting\" on a test server, you can use `sleep(int seconds)` or `sleepUntil(int $timestamp)` methods.\n\nCurrent server time can be retrieved with `getCurrentTime(): Carbon` method.\n","is_empty":false},{"file_name":"versioning.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/versioning.md","id":414,"title":"Versioning","markdown_content":"\nThe definition code of a Temporal Workflow must be deterministic because Temporal uses event sourcing\nto reconstruct the Workflow state by replaying the saved history event data on the Workflow\ndefinition code. This means that any incompatible update to the Workflow definition code could cause\na non-deterministic issue if not handled correctly.\n\n## Workflow::getVersion()\n\nConsider the following Workflow definition:\n\n```php\npublic function yourWorkflow(string $data)\n{\n    $yourActivity = Workflow::newActivityStub(\n        YourActivityInterface::class,\n        ActivityOptions::new()\n            ->withScheduleToStartTimeout(60)\n    );\n\n    $result1 = yield $yourActivity->activityA($data);\n    $result2 = yield $yourActivity->activityB($result1);\n\n    return $result2;\n}\n```\n\nNow let's say we have replaced `ActivityA` with `ActivityC`, and deployed the updated code. If there\nis an existing Workflow execution that was started by the original version of the Workflow code, where\n`ActivityA` had already completed and the result was recorded to history, the new version of the Workflow\ncode will pick up that Workflow execution and try to resume from there. However, the Workflow **will fail**\nbecause the new code expects a result for `ActivityC` from the history data, but instead it gets the\nresult for `ActivityA`. This causes the Workflow to fail on the non-deterministic error.\n\nThus we use `Workflow::getVersion()`.\n\n```php\n$yourActivity = Workflow::newActivityStub(\n    YourActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToStartTimeout(60)\n);\n\n$v = yield Workflow::getVersion('Step1', Workflow::DEFAULT_VERSION, 1);\n\nif ($v === Workflow::DEFAULT_VERSION) {\n    $result1 = yield $yourActivity->activityA($data);\n} else {\n    $result1 = yield $yourActivity->activityC($data);\n}\n\n$result2 = yield $yourActivity->activityB($result1);\n\nreturn $result2;\n```\n\nWhen `Workflow::getVersion()` is run for the new Workflow execution, it records a marker in the Workflow\nhistory so that all future calls to `GetVersion` for this change Id--`Step 1` in the example--on this\nWorkflow execution will always return the given version number, which is `1` in the example.\n\nIf you make an additional change, such as replacing ActivityC with ActivityD, you need to\nadd some additional code:\n\n```php\n$v = yield Workflow::getVersion('Step1', Workflow::DEFAULT_VERSION, 2);\n\nif ($v === Workflow::DEFAULT_VERSION) {\n    $result1 = yield $yourActivity->activityA($data);\n} elseif ($v === 1) {\n    $result1 = yield $yourActivity->activityC($data);\n} else {\n    $result1 = yield $yourActivity->activityD($data);\n}\n```\n\nNote that we have changed `maxSupported` from 1 to 2. A Workflow that had already passed this\n`GetVersion()` call before it was introduced will return `DEFAULT_VERSION`. A Workflow that was run\nwith `maxSupported` set to 1, will return 1. New Workflows will return 2.\n\nAfter you are sure that all of the Workflow executions prior to version 1 have completed, you can\nremove the code for that version. It should now look like the following:\n\n```php\n$v = yield Workflow::getVersion('Step1', 1, 2);\n\nif ($v === 1) {\n    $result1 = yield $yourActivity->activityC($data);\n} else {\n    $result1 = yield $yourActivity->activityD($data);\n}\n```\n\nYou'll note that `minSupported` has changed from `DEFAULT_VERSION` to `1`. If an older version of the\nWorkflow execution history is replayed on this code, it will fail because the minimum expected version\nis 1. After you are sure that all of the Workflow executions for version 1 have completed, then you\ncan remove 1 so that your code would look like the following:\n\n```php\nyield Workflow::getVersion('Step1', 2, 2);\n\n$result1 = yield $yourActivity->activityD($data);\n```\n\nNote that we have preserved the call to `GetVersion()`. There are two reasons to preserve this call:\n\n1. This ensures that if there is a Workflow execution still running for an older version, it will\n   fail here and not proceed.\n2. If you need to make additional changes for `Step1`, such as changing ActivityD to ActivityE, you\n   only need to update `maxVersion` from 2 to 3 and branch from there.\n\nYou only need to preserve the first call to `GetVersion()` for each `changeID`. All subsequent calls to\n`GetVersion()` with the same change Id are safe to remove. If necessary, you can remove the first\n`GetVersion()` call, but you need to ensure the following:\n\n- All executions with an older version are completed.\n- You can no longer use `Step1` for the changeId. If you need to make changes to that same part in\n  the future, such as change from ActivityD to ActivityE, you would need to use a different changeId\n  like `Step1-fix2`, and start minVersion from DefaultVersion again. The code would look like the\n  following:\n\n```php\n$v = yield Workflow::getVersion('Step1-fix2', Workflow::DEFAULT_VERSION, 1);\n\nif ($v === Workflow::DEFAULT_VERSION) {\n    $result1 = yield $yourActivity->activityD($data);\n} else {\n    $result1 = yield $yourActivity->activityE($data);\n}\n```\n\nUpgrading a Workflow is straightforward if you don't need to preserve your currently running\nWorkflow executions. You can simply terminate all of the currently running Workflow executions and\nsuspend new ones from being created while you deploy the new version of your Workflow code, which does\nnot use `GetVersion()`, and then resume Workflow creation. However, that is often not the case, and\nyou need to take care of the currently running Workflow executions, so using `GetVersion()` to update\nyour code is the method to use.\n\nHowever, if you want your currently running Workflows to proceed based on the current Workflow logic,\nbut you want to ensure new Workflows are running on new logic, you can define your Workflow as a\nnew `WorkflowType`, and change your start path (calls to `StartWorkflow()`) to start the new Workflow\ntype.\n\n## Sanity checking\n\nThe Temporal client SDK performs a sanity check to help prevent obvious incompatible changes.\nThe sanity check verifies whether a Command made in replay matches the event recorded in history,\nin the same order. The Command is generated by calling any of the following methods:\n\n- Workflow::executeActivity()\n- Workflow::executeChildWorkflow()\n- Workflow::timer()\n- Workflow::sideEffect()\n- Workflow::newActivityStub() execute\n- Workflow::newChildWorkflowStub() start and signal\n- Workflow::newExternalWorkflowStub() start and signal\n\nAdding, removing, or reordering any of the above methods triggers the sanity check and results in\na non-deterministic error.\n\nThe sanity check does not perform a thorough check. For example, it does not check on the Activity's\ninput arguments or the timer duration. If the check is enforced on every property, then it becomes\ntoo restricted and harder to maintain the Workflow code. For example, if you move your Activity code\nfrom one package to another package, that changes the `ActivityType`, which technically becomes a different\nActivity. But, we don't want to fail on that change, so we only check the function name part of the\n`ActivityType`.\n","is_empty":false},{"file_name":"workers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/workers.md","id":415,"title":"Workers in PHP","label":"Workers","markdown_content":"\nThe [RoadRunner application server](https://roadrunner.dev/) will launch multiple Temporal PHP worker processes based on provided `.rr.yaml` configuration.\n\nEach worker might connect to one or multiple task queues. Worker poll _Temporal service_ for tasks, performs those tasks,\nand communicates task execution results back to the _Temporal service_.\n\nWorker code are developed, deployed, and operated by Temporal customers. To create a worker use `Temporal\\WorkerFactory`:\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nuse Temporal\\WorkerFactory;\n\nini_set('display_errors', 'stderr');\ninclude \"vendor/autoload.php\";\n\n// factory initiates and runs task queue specific activity and workflow workers\n$factory = WorkerFactory::create();\n\n// Worker that listens on a task queue and hosts both workflow and activity implementations.\n$worker = $factory->newWorker();\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n\n// Activities are stateless and thread safe.\n$worker->registerActivity(App\\DemoActivity::class);\n// In case an activity class requires some external dependencies provide a callback - factory\n// that creates or builds a new activity instance. The factory should be a callable which accepts\n// an instance of ReflectionClass with an activity class which should be created.\n$worker->registerActivity(App\\DemoActivity::class, fn(ReflectionClass $class) => $container->create($class->getName()));\n// If you want to clean up some resources after activity is done, you may register\n// a finalizer. This callback is called after each activity invocation.\n$worker->registerActivityFinalizer(fn () => $kernel->showtdown());\n\n// start primary loop\n$factory->run();\n```\n\nYou can configure task queue name using first argument of `WorkerFactory`->`newWorker`:\n\n```php\n$worker = $factory->newWorker('your-task-queue');\n```\n\nAs mentioned above you can create as many task queue connections inside a single worker as you need.\n\nTo configure additional worker options use `Temporal\\Worker\\WorkerOptions`:\n\n```php\nuse Temporal\\Worker\\WorkerOptions;\n\n$worker = $factory->newWorker(\n    'your-task-queue',\n    WorkerOptions::new()\n        ->withMaxConcurrentWorkflowTaskPollers(10)\n);\n```\n\nMake sure to point the worker file in application server configuration:\n\n```yaml\nrpc:\n  listen: tcp://127.0.0.1:6001\n\nserver:\n  command: \"php worker.php\"\n\ntemporal:\n  address: \"temporal:7233\"\n  activities:\n    num_workers: 10\n```\n\n> You can serve HTTP endpoints using the same server setup.\n","is_empty":false},{"file_name":"workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/php/workflows.md","id":416,"title":"Workflows in PHP","description":"The core abstraction of the Temporal solution is a fault-oblivious stateful Workflow.","label":"Workflows","markdown_content":"\nimport RelatedReadList from '../components/RelatedReadList.js'\n\n## What is a Workflow?\n\nIn PHP, a Workflow is a class method.\nClasses must implement interfaces that are annotated with `#[WorkflowInterface]`.\nThe method that is the Workflow must be annotated with `#[WorkflowMethod]`.\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n}\n```\n\nWorkflow methods return a `Generator`.\nTo properly typecast the Workflow's return value in the client code use the `#[ReturnType()]` annotation.\n\n```php\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n}\n```\n\nWorkflows can also answer synchronous [Queries](/php/queries) and receive [Signals](/php/signals).\n\nAll interface methods must have one of the following annotations:\n\n- **#[WorkflowMethod]** indicates an entry point to a Workflow.\n  It contains parameters that specify timeouts and a Task Queue name.\n  Required parameters (such as `executionStartToCloseTimeoutSeconds`) that are not specified through the annotation must be provided at runtime.\n- **#[SignalMethod]** indicates a method that reacts to external signals. It must have a `void` return type.\n- **#[QueryMethod]** indicates a method that reacts to synchronous query requests. It must have a non `void` return type.\n\n> It is possible (though not recommended for usability reasons) to annotate concrete class implementation.\n\nYou can have more than one method with the same annotation (except #[WorkflowMethod]).\n\nFor example:\n\n```php\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nNote that name parameter of Workflow method annotations can be used to specify name of Workflow, signal and query types.\nIf name is not specified the short name of the Workflow interface is used.\n\nIn the above code the `#[WorkflowMethod(name)]` is not specified, thus the Workflow type defaults to `\"FileProcessingWorkflow\"`.\n\n## Workflow Interface Inheritance\n\nWorkflow interfaces can form inheritance hierarchies.\nIt may be useful for creating components reusable across multiple Workflow types.\nFor example imaging a UI or CLI button that allows to call `retryNow` signal on any Workflow.\nTo implement this feature you can redesign the above interface to:\n\n```php\n#[WorkflowInterface\ninterface Retryable {\n    #[SignalMethod]\n    public function retryNow(): void;\n}\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow extends Retryable {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\nThen some other Workflow can implement it as well:\n\n```php\n#[WorkflowInterface]\ninterface MediaProcessingWorkflow extends Retryable {\n    #[WorkflowMethod]\n    public function processBlob(Argument $args);\n}\n```\n\nThen it would be possible to send signal to both of them using the Retryable interface only:\n\n```php\n$r = $workflowClient->newRunningWorkflowStub(Retryable::class, $workflowId);\n$r->retryNow();\n```\n\nThe same technique can be used to query Workflows through a base interface.\n\nNote that an attempt to start Workflow through a base interface annotated with `#[WorkflowInterface]` is not going to work.\nLet's look at the following **invalid** example:\n\n```php\n\n// INVALID CODE!\n\n#[WorkflowInterface]\ninterface BaseWorkflow {\n    #[WorkflowMethod]\n    public function start();\n}\n\n#[WorkflowInterface]\ninterface Workflow1 extends BaseWorkflow {}\n\n#[WorkflowInterface]\ninterface Workflow2 extends BaseWorkflow {}\n```\n\nAn attempt to register implementations of Workflow1 and Workflow2 are going to fail as they are going to use the same Workflow type.\nThe type is defined by the type of the class which is annotated with `#[WorkflowInterface]`.\nIn this case `BaseWorkflow`.\nThe solution is to remove `#[WorkflowInterface]` annotation from BaseWorkflow.\nThe following is valid code:\n\n```php\ninterface BaseWorkflow {\n    #[WorkflowMethod]\n    public function start();\n}\n\n#[WorkflowInterface]\ninterface Workflow1 extends BaseWorkflow {}\n\n#[WorkflowInterface]\ninterface Workflow2 extends BaseWorkflow {}\n```\n\nImplementations of Workflow1 and Workflow2 can registered with the same worker as they will have types defined by their interfaces.\n\n## Implementing Workflows\n\nA Workflow implementation implements a Workflow interface.\nEach time a new Workflow execution is started, a new instance of the Workflow implementation object is created.\nThen, one of the methods (depending on which Workflow type has been started) annotated with `#[WorkflowMethod]` is invoked.\nAs soon as this method returns, the Workflow execution is closed.\nWhile Workflow execution is open, it can receive calls to signal and query methods.\nNo additional calls to Workflow methods are allowed.\nThe Workflow object is stateful, so query and signal methods can communicate with the other parts of the Workflow through Workflow object fields.\n\n### Constraints\n\nTemporal uses the [Microsoft Azure Event Sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) to recover the state of a Workflow object including its local variable values.\n\nIn essence, every time a Workflow state has to be restored, its code is re-executed from the beginning.\nWhen replaying, side effects (such as Activity invocations) are ignored because they are already recorded in the Workflow event history.\nWhen writing Workflow logic, the replay is not visible, so the code should be written since it executes only once.\nThis design puts the following constraints on the Workflow implementation:\n\n- Do not use any mutable global variables because multiple instances of Workflows are executed in parallel.\n- Do not call any non-deterministic functions like non seeded random or `UUID` directly from the Workflow code.\n\nAlways do the following in the Workflow implementation code:\n\n- Don’t perform any IO or service calls as they are not usually deterministic. Use Activities for this.\n- Only use `Workflow::now()` to get the current time inside a Workflow.\n- Call `yield Workflow::timer()` instead of `sleep()`.\n- Do not use any blocking SPL provided by PHP (i.e. `fopen`, `PDO`, etc) in **Workflow code**.\n- Use `yield Workflow::getVersion()` when making any changes to the Workflow code. Without this, any deployment of updated Workflow code\n  might break already open Workflows.\n- Don’t access configuration APIs directly from a Workflow because changes in the configuration might affect a Workflow execution path.\n  Pass it as an argument to a Workflow function or use an Activity to load it.\n\nWorkflow method arguments and return values are serializable to a byte array using the provided [DataConverter](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/DataConverter.html) interface.\nThe default implementation uses JSON serializer, but you can use any alternative serialization mechanism.\n\nMake sure to annoate your `WorkflowMethod` using `ReturnType` to specify concrete return type.\n\n> You can not use the default return type declaration as Workflow methods are generators.\n\nThe values passed to Workflows through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to Workflow workers with every event that the Workflow logic needs to process.\nA large execution history can thus adversely impact the performance of your Workflow.\nTherefore, be mindful of the amount of data that you transfer via Activity invocation parameters or return values.\nOtherwise, no additional limitations exist on Activity implementations.\n\n## Awaits\n\nUse specialized construct `Workflow::await` and `Workflow::awaitWithTimeout` to wait for Closure function become positive.\n\n```php\n$done = false;\nWorkflow::async(\n    function () use (&$done) {\n        $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n\n        $done = true;\n    }\n);\n\n// wait for $done to become true\nyield Workflow::await(fn() => $done);\n```\n\nYou can not use any activity, timer or child workflow invocation inside `await` or `awaitWithTimeout` method.\nHowever, you can use variables referenced by other coroutines.\n\n## Timers\n\nUse `Workflow::timer()` to yield long sleeps:\n\n```php\nyield Workflow::timer(300); // sleep for 5 minutes\n```\n\n## Starting Workflows\n\nWorkflows can be started both synchronously and asynchronously. You can use typed or untyped workflows stubs available\nvia `Temporal\\Client\\WorkflowClient`. To create workflow client:\n\n```php\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$workflowClient = WorkflowClient::create(ServiceClient::create('localhost:7233'));\n```\n\n### Synchronous start\n\nA Synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the\ninvocation process and will continue executing even if the waiting process crashes or stops.\n\nMake sure to acquire workflow interface or class name you want to start. For example:\n\n```php\n#[WorkflowInterface]\ninterface AccountTransferWorkflowInterface\n{\n    #[WorkflowMethod(name: \"MoneyTransfer\")]\n    #[ReturnType('int')]\n    public function transfer(\n        string $fromAccountId,\n        string $toAccountId,\n        string $referenceId,\n        int $amountCents\n    );\n}\n```\n\nTo start such workflow in sync mode:\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$result = $accountTransfer->transfer(\n    'fromID',\n    'toID',\n    'refID',\n    1000\n);\n```\n\n### Asynchronous start\n\nAn asynchronous start initiates a Workflow execution and immediately returns to the caller without waiting for a result.\nThis is the most common way to start Workflows in a live environment.\n\nTo start a Workflow asynchronously pass workflow stub instance and start parameters into `WorkflowClient`->`start`\nmethod.\n\n```php\n$accountTransfer = $workflowClient->newWorkflowStub(\n    AccountTransferWorkflowInterface::class\n);\n\n$run = $this->workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n```\n\nOnce started you can receive workflow ID and run ID via `WorkflowRun` object returned by start method:\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getExecution()->getID());\n```\n\n### Recurring start\n\nYou can start a Workflow Execution on a regular schedule with [the CronSchedule option](distributed-cron).\n\n## Connect to Running Workflows\n\nIf you need to wait for the completion of a Workflow after an asynchronous start, make a blocking call to\nthe `WorkflowRun`->`getResult` method.\n\n```php\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\n\nvar_dump($run->getResult());\n```\n\nYou can always connect to existing workflow and wait for its completion from another process using workflow id. Use\n`WorkflowClient`->`newUntypedRunningWorkflowStub` for such purposes.\n\n```php\n$workflow = $workflowClient->newUntypedRunningWorkflowStub('workflowID');\n\nvar_dump($workflow->getResult());\n```\n\n## Child Workflows\n\nBesides Activities, a Workflow can also start other Workflows.\n\n<RelatedReadList\nreadlist={[\n[\"What is a Child Workflow Execution?\",\"/concepts/what-is-a-child-workflow-execution\",\"explanation\"],  \n]}\n/>\n\n## PHP Child Workflow API\n\n`Workflow::executeChildWorkflow` and `Workflow::newChildWorkflowStub` enables the scheduling of other Workflows from within a Workflow's implementation.\nThe parent Workflow has the ability to monitor and impact the lifecycle of the child Workflow, similar to the way it does for an Activity that it invoked.\n\n```php\n// Use one stub per child workflow run\n$child = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    ChildWorkflowOptions::new()\n        // Do not specify WorkflowId if you want Temporal to generate a unique Id\n        // for the child execution.\n        ->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW')\n        ->withExecutionStartToCloseTimeout(DateInterval::createFromDateString('30 minutes'))\n);\n\n// This is a non blocking call that returns immediately.\n// Use yield $child->workflowMethod(name) to call synchronously.\n$promise = $child->workflowMethod('value');\n\n// Do something else here.\ntry{\n    $value = yield $promise;\n} catch(TemporalException $e) {\n    $logger->error('child workflow failed');\n    throw $e;\n}\n```\n\nLet's take a look at each component of this call.\n\nBefore calling `$child->workflowMethod()`, you must configure `ChildWorkflowOptions` for the invocation.\nThese options customize various execution timeouts, and are passed into the workflow stub defined by the `Workflow::newChildWorkflowStub`.\nOnce stub created you can invoke it's workflow method based on attribute `WorkflowMethod`.\n\nThe method call returns immediately and returns a `Promise`.\nThis allows you to execute more code without having to wait for the scheduled Workflow to complete.\n\nWhen you are ready to process the results of the Workflow, call the `yield $promise` method on the returned promise object.\n\nWhen a parent Workflow is cancelled by the user, the child Workflow can be cancelled or abandoned based on a configurable child policy.\n\nYou can also skip the stub part of child workflow initiation and use `Workflow::executeChildWorkflow` directly:\n\n```php\n// Use one stub per child workflow run\n$childResult = yield Workflow::executeChildWorkflow(\n    'ChildWorkflowName',\n    ['args'],\n    ChildWorkflowOptions::new()->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW'),\n    Type::TYPE_STRING // optional: defines the return type\n);\n```\n\n## Large event histories\n\nWorkflows that need to rerun periodically could naively be implemented as a big **while** loop with a sleep where the entire logic of the Workflow is inside the body of the **while** loop.\nThe problem with this approach is that the history for that Workflow will keep growing to a point where it reaches the maximum size enforced by the service.\n\n**ContinueAsNew** is the low level construct that enables implementing such Workflows without the risk of failures down the road.\nThe operation atomically completes the current execution and starts a new execution of the Workflow with the same **Workflow Id**.\nThe new execution will not carry over any history from the old execution.\n\nTo trigger this behavior, use `Workflow::continueAsNew` or `Workflow::newContinueAsNewStub` method:\n\n```php\n#[Workflow\\WorkflowMethod]\npublic function periodic(string $name, int $value = 0)\n{\n    for ($i = 0; $i < 100; $i++) {\n        // do something\n        $value++;\n    }\n\n    // maintain $value counter between runs\n    return Workflow::newContinueAsNewStub(self::class)->periodic($name, $value);\n}\n```\n","is_empty":false},{"file_name":"activities.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/activities.md","id":417,"title":"Activities in TypeScript","description":"Activities are the only way to interact with external resources in Temporal, like making an HTTP request or accessing the file system. Unlike Workflows, Activities execute in the standard Node.js environment.","label":"Activities","markdown_content":"\n**`@temporalio/activity`** [![NPM](https://img.shields.io/npm/v/@temporalio/activity)](https://www.npmjs.com/package/@temporalio/activity) [API reference](https://typescript.temporal.io/api/namespaces/activity) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/activity)\n\n> _Background reading: [Activities in Temporal](/activities)_\n\n**Activities are the only way to interact with external resources in Temporal**, such as making an HTTP request or accessing the file system.\n\n- Unlike [Workflows](/typescript/determinism), Activities execute in the standard Node.js environment. Any code that needs to talk to the outside world needs to be in an Activity, not a Workflow.\n- **Separate from Workflows**: Activities cannot be in the same file as Workflows and must be separately registered (see below for [How to register an Activity on a Worker](#how-to-register-an-activity-on-a-worker))\n- **Idempotency**: Activities may be retried repeatedly, so you may need to use [idempotency keys](https://stripe.com/blog/idempotency) for critical side effects.\n- The `'@temporalio/activity'` package offers useful utilities for Activity functions such as sleeping, Heartbeating, cancellation, and retrieving metadata (see [docs on Activity Context utilities](#activity-context-utilities) below).\n\n## How to write an Activity Function\n\nActivities are _simply functions_.\nBelow is a simple Activity that accepts a string parameter and returns a string:\n\n<!--SNIPSTART typescript-hello-activity {\"enable_source_link\": false}-->\n<!--SNIPEND-->\n\n## How to import and use Activities in a Workflow\n\nYou must first retrieve an Activity from an \"Activity Handle\" before you can call it.\nNote that we only import the type of our activities, the TypeScript compiler will drop the import statement on compilation.\n\n<!--SNIPSTART typescript-hello-workflow {\"enable_source_link\": false}-->\n<!--SNIPEND-->\n\n:::danger Wrong way to import activities\n\nYou may be tempted to import activities directly instead of using `proxyActivities`:\n\n```ts\nimport { greet } from './activities';\n// error when you try to use the function in your code\ngreet('Hello world');\n```\n\nThis will result in a Webpack error, because the Temporal Worker will try to bundle this as part of the Workflow.\nMake sure you're using `proxyActivities` to retrieve an Activity rather than calling the function directly.\nThis indirection comes from the fact that Activities are run in the regular Node.js environment, not the deterministic `vm` where Workflows are run.\n\nSee also our [docs on Webpack troubleshooting](/typescript/troubleshooting/).\n\n:::\n\nThe return value of `proxyActivities` is not a normal object, it is a [`Proxy`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) object that calls the TypeScript SDK's internal `scheduleActivity()` function when you reference an activity.\nThis is necessary due to the decoupled nature of Workflows and Activities, but also allows strong typing from a single import, and some nice patterns we explain below.\n\n### Activity Options\n\nWhen you call `proxyActivities` in a Workflow function, there are [a range of ActivityOptions](https://typescript.temporal.io/api/interfaces/common.ActivityOptions) you can set:\n\n```ts\n// Sample of typical options you can set while creating a proxy for the `greet` Activity\nconst { greet } = proxyActivities<typeof activities>({\n  // recommended\n  startToCloseTimeout: '30s',\n  // useful\n  scheduleToCloseTimeout: '5m',\n  // The below is a Retry Policy. It is used to retry the Activity if it fails.\n  retry: {\n    // These are the values of the Default Retry Policy\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n\nWe explain the Timeouts and Retries below. You can also specify `namespace`, `taskQueue`, `cancellationType`, and `activityId`, but most users will not need these.\n\n### Activity Timeouts\n\nTimeouts and Retries are the most immediate benefit of moving code onto Temporal.\nThere are [four Activity Timeouts](/blog/activity-timeouts) you can set.\nWhen a Timeout happens, your activity will be retried according to your [`RetryPolicy`](/concepts/what-is-a-retry-policy/).\n\n- `startToCloseTimeout`: Maximum time of a single Activity execution attempt. **We recommend always setting this**. [More info](/concepts/what-is-a-start-to-close-timeout/)\n- `scheduleToCloseTimeout`: Total time that a workflow is willing to wait for Activity to complete. [More info](/concepts/what-is-a-schedule-to-close-timeout/)\n- `heartbeatTimeout`: A best practice to set for long-running activities. [More info](/concepts/what-is-a-heartbeat-timeout/)\n- `scheduleToStartTimeout`: Not recommended; Only for task routing. [More info](/concepts/what-is-a-schedule-to-start-timeout/)\n\nYou can specify timeouts as number of milliseconds, or a string to be parsed to number of milliseconds by the [`ms`](https://www.npmjs.com/package/ms) package:\n\n```ts\n// Example 1\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute', // translates to 60000 ms\n});\n\n// Example 2\nconst { longRunningActivity } = proxyActivities<typeof activities>({\n  // translates to 300000 ms\n  scheduleToCloseTimeout: '5m',\n  // translates to 30000 ms\n  startToCloseTimeout: '30s',\n  // equivalent to '10 seconds'\n  heartbeatTimeout: 10000,\n});\n```\n\n### Activity Retry Policy\n\nYou can set a `retry` policy with [RetryPolicy](https://typescript.temporal.io/api/interfaces/client.retrypolicy/) that define how activity is retried in case of failure.\n\n```ts\n// Example 1 - default\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '20s',\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n\n// Example 2 - no retries\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '20s',\n  retry: {\n    // guarantee no retries\n    maximumAttempts: 1,\n  },\n});\n\n// Example 3 - linear retries up to 5x\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '20s',\n  retry: {\n    // retry every 1s, no exponential backoff\n    backoffCoefficient: 1,\n    // max 5 attempts\n    maximumAttempts: 5,\n  },\n});\n```\n\nFor a proper guide to each Retry Option, see the [RetryPolicy API Reference](https://typescript.temporal.io/api/interfaces/client.retrypolicy/).\n\nAs you customize your Workflow errors to be more descriptive, advanced users will want to become familiar with [Temporal's Failure classes](/typescript/handling-failure).\n\n## How to register an Activity on a Worker\n\nAll activities must be registered by a Worker, or you will get an error that looks like `\"Activity function yourActivity is not registered on this Worker\"` when you try to invoke it from a Workflow.\n\n```ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\n// ...\nconst worker = await Worker.create({\n  // ...\n  activities,\n});\n```\n\n:::tip Sticky Activities\n\n**Any matching Worker can pick up your Activity**, meaning your Activities are not guaranteed to execute on the same machine if you have a fleet of Workers.\nYou can route tasks to specific machines with the [Sticky Queues pattern](/typescript/workers#example-sticky-queues).\n\n:::\n\nAdvanced users can also register [Activity Interceptors](/typescript/interceptors) here.\nFor more on Activity and Workflow registration, see [the Worker docs](/typescript/workers) for more details.\n\n### Using pure ESM Node Modules\n\nThe JavaScript ecosystem is increasingly moving towards publishing ES Modules over CommonJS, for example `node-fetch@3` is ESM while `node-fetch@2` is CJS.\n\n**If you are importing a pure ESM dependency, see our [fetch ESM](https://github.com/temporalio/samples-typescript/tree/main/fetch-esm) sample** for necessary config changes you will need:\n\n- `package.json` must have `\"type\": \"module\"` attribute\n- `tsconfig.json` should output in `esnext` format\n- Imports [must](https://nodejs.org/api/esm.html#esm_mandatory_file_extensions) include the `.js` file extension\n\n## Important Design Patterns\n\nHere are some important (and frequently asked) patterns for using our Activities APIs, to illustrate common needs and usecases.\n\n### Sharing dependencies in Activity functions (Dependency Injection)\n\nBecause Activities are \"just\" functions, you can also create functions that create Activities.\nThis is a helpful pattern for using closures to:\n\n- store expensive dependencies for sharing, such as database connections\n- injecting secret keys (such as environment variables) from the Worker to the Activity\n\n<!--SNIPSTART typescript-activity-with-deps-->\n<!--SNIPEND-->\n\n<details>\n  <summary>See full example</summary>\n\nWhen you register these in the Worker, pass your shared dependencies accordingly:\n\n<!--SNIPSTART typescript-activity-deps-worker {\"enable_source_link\": false}-->\n<!--SNIPEND-->\n\nSince Activities are always referenced by name, inside the Workflow they can be proxied as normal, though the types need some adjustment:\n\n<!--SNIPSTART typescript-activity-deps-workflow-->\n<!--SNIPEND-->\n\n</details>\n\n### Importing multiple Activities at once\n\nYou may proxy multiple Activities from the same `proxyActivities` call if you want them to share the same timeouts/retries/options:\n\n```ts\nexport async function Workflow(name: string): Promise<string> {\n  // destructuring multiple activities with the same options\n  const { act1, act2, act3 } =\n    proxyActivities<typeof activities>(/* activityOptions */);\n  await act1();\n  await Promise.all([act2, act3]);\n}\n```\n\n### Dynamically referencing Activities\n\nSince, under the hood, Activities are only referenced by their string name, you can reference them dynamically if needed:\n\n```js\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts['activity1']();\n\n  // dynamic reference to activities using activityName\n  let result = await acts[activityName](...args);\n}\n```\n\nType safety is still supported here, but you are encouraged to validate and handle mismatches in Activity names. An invalid Activity name will lead to a `NotFoundError` with a message that looks like:\n\n```\nApplicationFailure: Activity function actC is not registered on this Worker, available activities: [\"actA\", \"actB\"]\n```\n\n## Activity Context utilities\n\nTemporal SDK also exports a [`Context`](https://typescript.temporal.io/api/classes/activity.context/) class with useful features for activities: `import { Context } from '@temporalio/activity'`\n\n| Activity Context properties            | Description                                                                                                                                                                                    |\n| -------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `Context.current().cancellationSignal` | An `AbortSignal` which can be used to cancel requests on Activity cancellation. Typically used by the `fetch` and `child_process` libraries but is supported by a few other libraries as well. |\n| `Context.current().cancelled`          | Await this promise in an Activity to get notified of cancellation. This promise will never be resolved; it will only be rejected with a `CancelledFailure`.                                    |\n| `Context.current().heartbeat()`        | Send a Heartbeat from an Activity.                                                                                                                                                             |\n| `Context.current().info`               | Holds [information](https://typescript.temporal.io/api/interfaces/activity.Info) about the current executing Activity                                                                          |\n| `Context.current().sleep()`            | Helper function for sleeping in an Activity - resolves when deadline is reached or rejects when the Context is cancelled. Prefer this to `setTimeout`.                                         |\n\n### Heartbeating\n\nLong running activities should Heartbeat their progress back to the Workflow for earlier detection of stalled activities (with Heartbeat timeouts) and resuming stalled activities from checkpoints (with Heartbeat details).\n\n<details>\n<summary>\nWhat activities should Heartbeat?\n</summary>\n\nHeartbeating is best thought about not in terms of time, but in terms of \"How do you know you are making progress\"? If an operation is so short that it doesn't make any sense to say \"I am still working on this\", then don't heartbeat. Vice versa for longer operations.\n\n- If your underlying task can report definite progress, that is ideal.\n  - However, do note that your Workflow cannot read this progress information while the Activity is still executing (or it would have to store it in Event History). You may report progress to external sources if you need it exposed to the user.\n- Even without a \"progress you may get something useful from just verifying that the Worker processing your Activity is at the very least \"still alive\" (has not run out of memory or silently crashed).\n\nSuitable for Heartbeating:\n\n- Read a large file from S3\n- Run a ML training job on some local GPUs\n\nNot suitable for Heartbeating:\n\n- Reading a small file from disk\n- Making a quick API call\n\n</details>\n\n```ts\n// activity implementation\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  for (let progress = 1; progress <= 1000; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    Context.current().heartbeat();\n  }\n}\n\n// workflow code calling activity\nconst { example } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 hour',\n  heartbeatTimeout: '10s',\n});\n```\n\nWithout Heartbeating, if your activity `StartToCloseTimeout` is 1 hour and the activity stalled or activity worker died, Temporal would have to wait out the 1 hour before retrying.\nBut if you used the Heartbeat API, set a `heartbeatTimeout` for 10 seconds, the absence of Heartbeats in the `heartbeatTimeout` window would inform the Server that the Activity has stalled and should be retried right away rather than at the end of the `StartToCloseTimeout`.\n\nThe second major benefit of Heartbeating is being able to resume from failure by checkpointing data as `heartbeatDetails`.\nExtending the example above:\n\n```ts\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  const startingPoint = Context.current().info.heartbeatDetails || 1; // allow for resuming from heartbeat\n  for (let progress = startingPoint; progress <= 100; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    Context.current().heartbeat(progress);\n  }\n}\n```\n\nThis way, if the Activity Worker experiences a `heartbeatTimeout`, when a retry happens, it will pick up where the previous attempt left off.\n\n### Activity Cancellation\n\nActivity Cancellation is an optional capability that lets you do graceful cleanup if it's originating Workflow is canceled. There are some additional usage notes:\n\n- Activities may be cancelled only if they emit heartbeats.\n- A Workflow can request to cancel an Activity by cancelling its containing [cancellation scope](/typescript/cancellation-scopes).\n\nThere are 3 ways to handle Activity cancellation:\n\n1. Await on [`Context.current().cancelled`](https://typescript.temporal.io/api/classes/activity.context#cancelled)\n2. Catch a [`CancelledFailure`](/typescript/handling-failure/) while awaiting \"cancellation-aware\" APIs like `Context.current().sleep`. Errors can be validated with the `isCancellation(err)` utility function (see example below)\n3. Pass the context's abort Signal at [`Context.current().cancellationSignal`](https://typescript.temporal.io/api/classes/activity.context#cancelled) to a library that supports it like `fetch`\n\n[`heartbeat()`](https://typescript.temporal.io/api/classes/activity.context/#heartbeat) in the TypeScript SDK is a background operation and does not propagate errors to the caller, such as when the scheduling Workflow has already completed or the Activity has been closed by the Server (due to timeout for instance). These errors are translated into cancellation and can be handled using the methods above.\n\n#### Example: Activity that fakes progress and can be cancelled\n\nThe [`sleep`](https://typescript.temporal.io/api/classes/activity.context#sleep) method exposed in `Context.current()` is comparable to a standard `sleep` function: `new Promise(resolve => setTimeout(resolve, sleepMS));` except that it also rejects if the Activity is cancelled.\n\n<!--SNIPSTART typescript-activity-fake-progress-->\n<!--SNIPEND-->\n\n#### Example: Activity that makes a cancellable HTTP request with cancellationSignal\n\nThe [`Context.current().cancellationSignal`](https://typescript.temporal.io/api/classes/activity.Context#cancellationsignal) returns an `AbortSignal` that is typically used by the `node_fetch` and `child_process` libraries but is supported by a few other libraries as well as the Web-standard [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal).\n\n<!--SNIPSTART typescript-activity-cancellable-fetch-->\n<!--SNIPEND-->\n\n## Advanced Features\n\nThese are Activity features that most users will not need, but are available for advanced users.\nPlease get in touch with us if you find the need for them.\n\n### Activity Interceptors\n\nInterceptors are a mechanism for users to modify inbound and outbound SDK calls. Interceptors are commonly used to add tracing and authorization to the scheduling and execution of Workflows and Activities, but you can also use them to run code after an Activity failure (and before the next retry). See the [Interceptors docs](/typescript/interceptors) and the [SDK API Reference](https://typescript.temporal.io/api/interfaces/worker.ActivityInboundCallsInterceptor) for more information.\n\n### Async Activity Completion\n\nNormally, an Activity is started and ended in the same Worker, for example a short HTTP call.\nHowever, sometimes you may want to record an Activity completion in a different process than when you started it.\n\n> If you are modeling human actions, we recommend using Signals rather than Async Activity Completion.\n> This is because Activities only have one timeout and, if your Activity is split into two steps, one for kicking off the process (for example, storing information in the data base), and one for human based resolution, it's best to use the timeout to detect failure in the former so it can be retried by the system.\n\nAsync Activity completion is done through a two step process:\n\n- Throw a `CompleteAsyncError` from an Activity\n- Use a `AsyncCompletionClient` to mark it as completed, failed, or more.\n\nYou can [read the tests](https://github.com/temporalio/sdk-typescript/blob/7d47f501cb56cced27118b5f0abb320cc0ba03ef/packages/test/src/test-async-completion.ts#L40-L98) for more information.\n\n### Local Activities (experimental)\n\nTemporal has an optimization feature called Local Activities.\n\nThis document is still a WIP. For more details, see [What is a Local Activity?](/concepts/what-is-a-local-activity/)\n\nTo call Local Activities in TS, use [`proxyLocalActivities`](https://typescript.temporal.io/api/namespaces/workflow/#proxylocalactivities).\n\n```ts\nimport * as workflow from '@temporalio/workflow';\n\nconst { getEnvVar } = workflow.proxyLocalActivities({\n  startToCloseTimeout: '2 seconds',\n});\n\nexport async function yourWorkflow(): Promise<void> {\n  const someSetting = await getEnvVar('SOME_SETTING');\n  // ...\n}\n```\n\nLocal Activities must be registered with the Worker the same way non-local Activities are.\n","is_empty":false},{"file_name":"api-reference-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/api-reference-typescript.md","id":418,"title":"API reference","label":"API reference","markdown_content":"\nThe Temporal TypeScript SDK API reference is published on [typescript.temporal.io](https://typescript.temporal.io).\n","is_empty":false},{"file_name":"cancellation-scopes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/cancellation-scopes.md","id":419,"markdown_content":"# Cancellation Scopes\n\nIn the TypeScript SDK, Workflows are represented internally by a tree of **Cancellation Scopes**, each with cancellation behaviors you can specify.\nEverything runs in the \"root\" scope by default.\n\nScopes are created using the [`CancellationScope`](https://typescript.temporal.io/api/classes/workflow.cancellationscope) constructor, or one of 3 static helpers:\n\n- [`cancellable(fn)`](https://typescript.temporal.io/api/classes/workflow.cancellationscope#cancellable-1): children are automatically cancelled when their containing scope is cancelled.\n  - Equivalent to `new CancellationScope().run(fn)`.\n- [`nonCancellable(fn)`](https://typescript.temporal.io/api/classes/workflow.cancellationscope#noncancellable): prevents cancellation from propagating to children.\n  - Equivalent to `new CancellationScope({ cancellable: false }).run(fn)`.\n- [`withTimeout(timeoutMs, fn)`](https://typescript.temporal.io/api/classes/workflow.cancellationscope#withtimeout): if timeout triggers before `fn` resolves the scope will be cancelled, triggering cancellation of enclosed operations, such as activities and timers.\n  - Equivalent to `new CancellationScope({ cancellable: true, timeout: timeoutMs }).run(fn)`.\n\nCancellations are applied to _cancellation scopes_, which can encompass an entire workflow or just part of one. Scopes can be nested, and cancellation propagates from outer scopes to inner ones. A Workflow's `main` function runs in the outermost scope. Cancellations are handled by catching `CancelledFailure`s thrown by _cancellable operations_ (see below).\n\n`CancellationScope.run()` and the static helpers mentioned above all return native JS Promises, so you can use the familiar Promise APIs like `Promise.all` and `Promise.race` to model your async logic.\nOther APIs you can use:\n\n- `CancellationScope.current()`: get the current scope\n- `scope.cancel()`: cancel all operations inside a `scope`\n- `scope.run(fn)`: run an async function within a `scope`, returns the result of `fn`\n- `scope.cancelRequested`: a promise that resolves when a scope cancellation is requested, e.g. when Workflow code calls `cancel()` or the entire Workflow is cancelled by an external client.\n\nWhen a `CancellationScope` is cancelled, it propagates cancellation in any child scopes and of any _cancellable operations_ created within it, such as:\n\n- Activities\n- Timers (created with the [`sleep`](https://typescript.temporal.io/api/namespaces/workflow#sleep) function)\n- [`Trigger`](https://typescript.temporal.io/api/classes/workflow.trigger)s\n\n### [CancelledFailure](/typescript/handling-failure/#cancelledfailure)\n\n`Timer`s and `Trigger`s throw `CancelledFailure` when cancelled while Activities and Child Workflows throw `ActivityFailure` and `ChildWorkflowFailure` with cause set to `CancelledFailure`.\nOne exception is when an Activity or Child Workflow is scheduled in an already cancelled scope (or workflow) in which case they'll propagate the `CancelledFailure` that was thrown to cancel the scope.\n\nIn order to simplify checking for cancellation, use the [`isCancellation(err)`](https://typescript.temporal.io/api/namespaces/workflow#iscancellation) function.\n\n## Internal cancellation example\n\n<!--SNIPSTART typescript-cancel-a-timer-from-workflow-->\n<!--SNIPEND-->\n\nAlternatively, the preceding can be written as:\n\n<!--SNIPSTART typescript-cancel-a-timer-from-workflow-alternative-impl-->\n<!--SNIPEND-->\n\n## External cancellation example\n\nHandle Workflow cancellation by an external client while an Activity is running:\n\n<!-- TODO: add a sample here of how this Workflow could be cancelled using a WorkflowHandle -->\n\n<!--SNIPSTART typescript-handle-external-workflow-cancellation-while-activity-running-->\n<!--SNIPEND-->\n\n## `nonCancellable` example\n\n`CancellationScope.nonCancellable` prevents cancellation from propagating to children:\n\n<!--SNIPSTART typescript-non-cancellable-shields-children-->\n<!--SNIPEND-->\n\n## `withTimeout` example\n\nA very common operation is to cancel one or more activities if a deadline elapses, `withTimeout` creates a `CancellationScope` that is automatically cancelled after a given timeout.\n\n<!--SNIPSTART typescript-multiple-activities-single-timeout-workflow-->\n<!--SNIPEND-->\n\n## `scope.cancelRequested`\n\nYou can await `cancelRequested` to make Workflow aware of cancellation while waiting on `nonCancellable` scopes:\n\n<!--SNIPSTART typescript-cancel-requested-with-non-cancellable-->\n<!--SNIPEND-->\n\n## CancellationScopes and callbacks\n\nCallbacks are not particularly useful in Workflows because all meaningful asynchronous operations return Promises.\nIn the rare case that user code utilizes callbacks and needs to handle cancellation, a callback can be used to consume the `CancellationScope.cancelRequested` `Promise`.\n\n<!--SNIPSTART typescript-cancellation-scopes-with-callbacks-->\n<!--SNIPEND-->\n\n## Nesting Cancellation Scopes\n\nComplex flows may be achieved by nesting cancellation scopes:\n\n<!--SNIPSTART typescript-nested-cancellation-scopes-->\n<!--SNIPEND-->\n\n## Sharing promises between scopes\n\nOperations like timers and Activities are cancelled by the cancellation scope they were created in. Promises returned by these operations can be awaited in different scopes.\n\n<!--SNIPSTART typescript-shared-promise-scopes-->\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-shield-awaited-in-root-scope-->\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"clients.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/clients.md","id":420,"title":"Workflow Clients in TypeScript","description":"Workflow Clients are embedded in your application code, and connect to Temporal Server via gRPC. They are the only way to schedule new Workflow Executions with Temporal Server.","label":"Clients","markdown_content":"\n<!-- prettier-ignore -->\nimport * as WhatIsATemporalCronJob from '../concepts/what-is-a-temporal-cron-job.md'\n\n**`@temporalio/client`** [![NPM](https://img.shields.io/npm/v/@temporalio/client)](https://www.npmjs.com/package/@temporalio/client) [API reference](https://typescript.temporal.io/api/namespaces/client) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/client)\n\n**Workflow Clients are embedded in your application code and connect to Temporal Server via gRPC**.\nThey are the only way to schedule new Workflow Executions with Temporal Server.\n\n- Workflow Clients can run in any Node.js application, for example, in a serverless function, Express.js API route handler or CLI/script run.\n- The primary use of Workflow Clients is to start new Workflow Executions (including [Cron Workflows](#scheduling-cron-workflows)).\n  Given a `workflowId`, a Workflow Client can also get a Handle to a running Workflow Execution or retrieve/wait for its result.\n- **Workflow Handles** are bindings to specific Workflow Executions that expose more APIs for control.\n\n  **We strongly recommend familiarizing yourself with Workflow Handle APIs** because they are the main way you will signal, query, describe, cancel, terminate, and await the result of running Workflow Executions.\n\n- Advanced users can also use the `WorkflowService` exposed by a Workflow Client to make **raw gRPC calls** (usually for introspection).\n\nWorkflow Clients are separate from Workers, but communicate with them through Task Queues to start Workflow Executions.\nFor more information, see [Workers and Task Queues in TypeScript](/typescript/workers) and [Workflows in TypeScript](/typescript/workflows).\n\n## Full Example\n\nThe following code is a `WorkflowClient` example, from our Hello World sample:\n\n<!--SNIPSTART typescript-hello-client -->\n<!--SNIPEND-->\n\nThe rest of this document explains each step in detail with practical usage tips.\n\n## Create a new Workflow Client\n\nCreate a [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.workflowclient) with the requisite gRPC [`Connection`](https://typescript.temporal.io/api/classes/client.Connection):\n\n```ts\nimport { Connection, WorkflowClient } from '@temporalio/client';\nconst connection = await Connection.connect({\n  address: 'temporal.prod.my.org',\n}); // to configure for production\nconst client = new WorkflowClient({ connection });\n```\n\nIf you omit the connection and just call `new WorkflowClient()`, it creates a default connection that will work locally. Just remember you will need to configure your Connection and Namespace when [deploying to production](/typescript/security#encryption-in-transit-with-mtls).\n\n## Start a Workflow Execution\n\nWhen you have a Workflow Client, you can schedule the start of a Workflow with `client.start`, specifying `workflowId`, `taskQueue`, and `args` and returning a Workflow Handle (see below) immediately after the Server acknowledges receipt.\n\n```ts\n// // STEP ONE: client.start\n// Option 1: Specifying args and workflowId\nconst handle = await client.start(example, {\n  workflowId: 'business-meaningful-id',\n  taskQueue: 'tutorial',\n  args: ['foo', 'bar', 'baz'], // this is typechecked against workflowFn's args\n});\n\n// Option 2: Just using string name; no need to import Workflow, but no type inference\nimport { WorkflowStartOptions } from '@temporalio/client';\ntype WFType = (key: number) => Promise<string>; // arg types intentionally wrong to prove a point\nconst handle = await client.start<string>('example', {\n  workflowId: 'business-meaningful-id',\n  taskQueue: 'tutorial',\n  args: [123], // typechecked, but actually wrong at runtime because wrong type signature\n} as WorkflowStartOptions<WFType>);\n\n// // STEP TWO: client.getHandle\n// Continue in a different process (such as a serverless function)\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result(); // wait for Workflow to complete and get result. See below for other Handle APIs\n\n// alternative combination of STEP ONE + TWO\nconst result = await client.execute(example /*...*/); // start and immediately wait for Workflow to complete and get result\n```\n\n<details>\n<summary>Note: Scheduling is not the same as Starting Workflows\n</summary>\n\nCalling `client.start` (or `client.execute`) merely sends a Command to Temporal Server to schedule a new Workflow Execution on the specified Task Queue; it does not actually start until a Worker (that has a matching Workflow Type) polling that Task Queue picks it up.\n\nYou can test this by executing a Workflow Client command without a matching Worker.\nTemporal Server records the command in Event History but does not make progress with the Workflow Execution until a Worker starts polling with a matching Task Queue and Workflow Definition.\n\nThis queuing mechanic makes your application tolerant to outages and horizontally scalable, but can be confusing to newcomers if they expect that calling `client.execute(YourWorkflow)` directly executes the Workflow code on the same machine as the Client.\n\n</details>\n\n### Workflow Options\n\nA brief guide to the [WorkflowOptions](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions) available to you:\n\n- `workflowId`, `taskQueue`, and `args` (if required) are the main ones you will regularly use\n- Optional features:\n  - `memo` (simple annotation of Workflows)\n  - `searchAttributes` (see [Search Attributes](/typescript/search-attributes))\n  - `cronSchedule` (see important notes in [Cron Workflows](#scheduling-cron-workflows) section below)\n- Advanced features you probably won't need: `followRuns` and `workflowIdReusePolicy`.\n\n:::caution\n\nWorkflow-level Retries and Timeouts are not recommended.\n\nYou will see that there are `workflowRunTimeout`, `workflowExecutionTimeout`, `workflowTaskTimeout`, and `retryPolicy` options in [WorkflowOptions](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions).\nWe discourage using them unless you know what you are doing.\nDo not rely on Workflows to timeout or fail - you probably want to push this logic down to an Activity instead.\n\n:::\n\n## Workflow Handle APIs\n\n**Workflow Handles** are returned after you start a Workflow (or retrieve an existing one with `client.getHandle`) and are bound to a single Workflow instance. They represent already-started Workflow Executions, and let you `signal`, `query`, `describe`, `cancel`, or `terminate` their instance:\n\n```ts\n// Get a handle if you don't already have it\nconst handle = client.getHandle(workflowId);\n\n// Handle API quick examples\nawait handle.cancel(); // cancel with cleanup\nawait handle.terminate(); // kill immediately\nconst WFdescription = await handle.describe(); // get Workflow Execution internal info\nawait handle.signal<Args>(mySignal, ...args); // see Signal docs\nconst queryResult = await handle.query<ReturnType, Args>(myQuery, ...args); // see Query docs\nconst result = await handle.result(); // block until the workflow completes and/or get return value\nconst result = await client.execute(example /*...*/); // Alternative API for starting and immediately waiting for Workflow completion\n```\n\nThe [Workflow Handle APIs](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle) let you externally control your Workflow:\n\n| Handle API            | Description                                                                                                                               |\n| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| `client`              | Readonly accessor to the underlying Workflow Client.                                                                                      |\n| `workflowId`          | The `workflowId` of the current Workflow.                                                                                                 |\n| `firstExecutionRunId` | The `runId` of the initial run of the bound Workflow (available on handles created with `start`).                                         |\n| `signaledRunId`       | The `runId` of the signalled run of the bound Workflow (available on handles created with `startWithStart`).                              |\n| `query()`             | Call to query a Workflow after it's been started even if it has already completed. `const value = await handle.query(getValue, ...args);` |\n| `signal()`            | Call to signal a _running_ Workflow. `await handle.signal(increment, ...args);`                                                           |\n| `cancel()`            | Cancels a running Workflow.                                                                                                               |\n| `terminate()`         | Terminates a running Workflow.                                                                                                            |\n| `describe()`          | Describes the current Workflow Execution.                                                                                                 |\n| `result()`            | Promise that resolves when Workflow Execution completes.                                                                                  |\n\nThe following covers how to use many of these APIs, you will want to be fluent with them as they cover the basics of Workflow manipulation.\n\n### Get a Workflow's result\n\nWorkflow functions may or may not return a result when they complete.\n\nIf you started a Workflow with `handle.start`, you can choose to wait for the result anytime with `handle.result()`.\n\n```ts\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result(); // block until the workflow completes, if you wish\n```\n\nUsing a Workflow Handle isn't necessary with `client.execute` by definition.\n\n- **Don't forget to handle errors here.**\n  If you call `result()` on a Workflow that prematurely ended for some reason, it throws a [WorkflowFailedError](https://typescript.temporal.io/api/classes/client.WorkflowFailedError) error that reflects that reason.\n\n  ```ts\n  const handle = client.getHandle(workflowId);\n  try {\n    const result = await handle.result(); // block until the workflow completes, if you wish\n  } catch (err) {\n    if (err instanceof WorkflowFailedError) {\n      throw new Error('Temporal workflow failed: ' + workflowId, {\n        cause: err,\n      });\n    } else {\n      throw new Error('error from Temporal workflow ' + workflowId, {\n        cause: err,\n      });\n    }\n  }\n  ```\n\n- You can also specify a `runId`, but you will almost never need it, because most people only want the results of the latest run (a Workflow may run multiple times if failed or continued as new).\n\n### Cancel a Workflow\n\nTo cancel a Workflow Execution, call the [`handle.cancel()`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#cancel) method on a Workflow Handle.\n\n```ts\n// Start the Workflow without waiting its completion\nawait handle.start(args);\n// ... Later on, cancel the workflow\nawait handle.cancel();\n```\n\nWith `handle.cancel()`, Timers and Child Workflows have the opportunity to execute cleanup code.\nIf you wish to skip that, you can also [`handle.terminate()`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#terminate) forcefully.\n\nTemporal gives you fine grained control over what happens when you cancel a workflow. See our docs on [Cancellation Scopes](/typescript/cancellation-scopes) for details and examples.\n\n## Scheduling Cron Workflows\n\nYou can set each workflow to repeat on a schedule with the `cronSchedule` option:\n\n```ts\nconst handle = await client.start(scheduledWorkflow, {\n  workflowId: 'business-meaningful-id',\n  taskQueue: 'tutorial',\n  cronSchedule: '* * * * *', // start every minute\n});\n```\n\n:::info Should I use Cron Workflows or Timers?\n\nThis section is specifically about <preview page={WhatIsATemporalCronJob}>Temporal Cron Jobs</preview>, which are Workflows that have the `cronSchedule` option set in Temporal.\nBecause Temporal Workflows have [Timers](/typescript/workflows#timers), can loop indefinitely, and can spawn [Child Workflows](/typescript/workflows#child-workflows), it is natural to ask when to use which.\n\nCron Workflows are rigid and come with a lot of caveats.\nThey are a great choice if you have Workflows that need to run as rigidly as the native Linux `cron` utility (except distributed and fault tolerant).\nHowever, if you have any advanced needs (including needing overlaps, or canceling individual executions without affecting the overall schedule), use Timers.\n\n:::\n\nYou can set each Workflow to repeat on a schedule with the `cronSchedule` option:\n\n```ts\nconst handle = await client.start(scheduledWorkflow, {\n  taskQueue: 'test',\n  cronSchedule: '* * * * *', // start every minute\n});\n```\n\nFor more information, see the Typescript SDK [`workflowOptions` source code](https://typescript.temporal.io/api/interfaces/client.workflowoptions/#cronschedule).\n\n## Note: Child Workflows and External Workflows\n\nYou can start Child Workflows only from within another Workflow, and not from a Client.\n\n**Hence the main Child Workflows documentation is on the [Workflow APIs](/typescript/workflows#child-workflows) page.**\n\nA lot of the same concepts about starting, executing, and signaling Workflow Executions apply:\n\n```ts\n// inside Workflow code\nimport { startChild } from '@temporalio/workflow';\n\nexport async function example(WFname: string, args: string[]): Promise<string> {\n  const childHandle = await startChild(WFname, {\n    // workflowId is optional only for child workflows\n    // task queue and other options inherited from parent, can override\n    args,\n  });\n  const result = await childHandle.result();\n  // // equivalent to\n  // const result = await executeChild(WFname, /* ... */)\n  return result;\n}\n```\n\nYou should use [cancellationScopes](/typescript/cancellation-scopes) if you need to cancel Child Workflows.\n\nThe same concept of \"Workflow Handles\" applies to retrieving handles for Child and External Workflows—as long as you have the Workflow Id:\n\n```ts\n// inside Workflow code\nimport { getExternalWorkflowHandle } from '@temporalio/workflow';\n\nexport async function CancelExternalWorkflow(wfId: string): void {\n  const extHandle = getExternalWorkflowHandle(wfId);\n  // ...\n}\n```\n\nAgain, see [Workflows in TypeScript](/typescript/workflows#external-workflows) for full details.\n\n## Advanced: Making raw gRPC calls\n\nUnder the hood of a `WorkflowClient`, the `Connection` is actually powered by a `WorkflowService` driver that makes the raw gRPC calls to Temporal Server.\nThis Service is capable of making a wider range of introspection calls.\n\n<!--SNIPSTART typescript-grpc-call-basic-->\n<!--SNIPEND-->\n\nUsing gRPC calls is often the only way to access some of the more advanced queries you can make from Temporal Server.\nWe highlight some queries of interest here:\n\n<details>\n<summary><a class=\"font-mono\" href=\"https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.WorkflowService-1#getworkflowexecutionhistory\">getWorkflowExecutionHistory</a>\n</summary>\n\n<!--SNIPSTART typescript-grpc-call-getWorkflowExecutionHistory-->\n<!--SNIPEND-->\n\nOutputs something like:\n\n```\n{\n  events: [\n    HistoryEvent {\n      eventId: [Long],\n      eventTime: [Timestamp],\n      eventType: 1,\n      taskId: [Long],\n      workflowExecutionStartedEventAttributes: [WorkflowExecutionStartedEventAttributes]\n    },\n    HistoryEvent {\n      eventId: [Long],\n      eventTime: [Timestamp],\n      eventType: 5,\n      taskId: [Long],\n      workflowTaskScheduledEventAttributes: [WorkflowTaskScheduledEventAttributes]\n    },\n    HistoryEvent {\n      eventId: [Long],\n      eventTime: [Timestamp],\n      eventType: 6,\n      taskId: [Long],\n      workflowTaskStartedEventAttributes: [WorkflowTaskStartedEventAttributes]\n    }\n  ]\n}\n```\n\n</details>\n\n<details>\n<summary><a class=\"font-mono\" href=\"https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.WorkflowService-1#listworkflowexecutions) (requires ElasticSearch)\">listWorkflowExecutions</a>\n</summary>\n\n<!--SNIPSTART typescript-grpc-call-listWorkflowExecutions-->\n<!--SNIPEND-->\n\nOutputs something like:\n\n```\n┌─────────┬───────────────────────────────────────────────────────────────────────────────────────────────────┬──────────────────────────────────┬─────────────────────────────────────────────────┬─────────────────────────────────────────────────┬────────┬───────────────┬─────────────────────────────────────────────────┬─────────────────────┬──────────────────────────────────────────────┬────────────┬──────────────────────┐\n│ (index) │                                             execution                                             │               type               │                    startTime                    │                    closeTime                    │ status │ historyLength │                  executionTime                  │        memo         │               searchAttributes               │ taskQueue  │ stateTransitionCount │\n├─────────┼───────────────────────────────────────────────────────────────────────────────────────────────────┼──────────────────────────────────┼─────────────────────────────────────────────────┼─────────────────────────────────────────────────┼────────┼───────────────┼─────────────────────────────────────────────────┼─────────────────────┼──────────────────────────────────────────────┼────────────┼──────────────────────┤\n│    0    │ WorkflowExecution { workflowId: 'your-business-id', runId: '2798482a-46d8-4f1e-ab87-1ba3f7ddda1c' } │ WorkflowType { name: 'example' } │ Timestamp { seconds: [Long], nanos: 125158275 } │ Timestamp { seconds: [Long], nanos: 263021256 } │   2    │    [Long]     │ Timestamp { seconds: [Long], nanos: 125158275 } │ Memo { fields: {} } │ SearchAttributes { indexedFields: [Object] } │ 'tutorial' │        [Long]        │\n│    1    │ WorkflowExecution { workflowId: 'your-business-id', runId: '76f1171b-7a73-46a3-ba66-b77bab0b73f8' } │ WorkflowType { name: 'example' } │ Timestamp { seconds: [Long], nanos: 841243925 } │ Timestamp { seconds: [Long], nanos: 935283589 } │   2    │    [Long]     │ Timestamp { seconds: [Long], nanos: 841243925 } │ Memo { fields: {} } │ SearchAttributes { indexedFields: [Object] } │ 'tutorial' │        [Long]        │\n│    2    │ WorkflowExecution { workflowId: 'your-business-id', runId: '6d1197b7-41b8-47be-89b4-f1ef3446de1a' } │ WorkflowType { name: 'example' } │ Timestamp { seconds: [Long], nanos: 425778697 } │ Timestamp { seconds: [Long], nanos: 523022091 } │   2    │    [Long]     │ Timestamp { seconds: [Long], nanos: 425778697 } │ Memo { fields: {} } │ SearchAttributes { indexedFields: [Object] } │ 'tutorial' │        [Long]        │\n└─────────┴───────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────────────────────────┴─────────────────────────────────────────────────┴─────────────────────────────────────────────────┴────────┴───────────────┴─────────────────────────────────────────────────┴─────────────────────┴──────────────────────────────────────────────┴────────────┴──────────────────────┘\n```\n\n</details>\n\n**For the full list of gRPC calls, see the Methods section of the [WorkflowService](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.WorkflowService-1#methods) API reference.**\n\nNote that if you are trying to do a lot of list-then-filter operations (e.g. `listClosedWorkflowExecutions`), the [Visibility APIs](/typescript/search-attributes) are a better choice for Temporal deployments with [ElasticSearch enabled](/clusters/how-to-integrate-elasticsearch-into-a-temporal-cluster/) (this is enabled by default for all Temporal Cloud customers).\n","is_empty":false},{"file_name":"code-samples-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/code-samples-typescript.md","id":421,"title":"Code samples","label":"Code samples","markdown_content":"\nUse the [TypeScript samples library](https://github.com/temporalio/samples-typescript) stored on GitHub to demonstrate various capabilities of Temporal.\n\n**Where can I find video demos?**\n\n[Temporal Go TypeScript YouTube playlist](https://www.youtube.com/playlist?list=PLl9kRkvFJrlTavecydpk9r6cF7qBmQJvb).\n","is_empty":false},{"file_name":"data-converters.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/data-converters.md","id":422,"title":"Data Converters","description":"Learn and customize how data is serialized in the TypeScript SDK","label":"Data Converters","markdown_content":"\n> Background reading: [Data Converters in Temporal](/concepts/what-is-a-data-converter/)\n\nContents:\n\nimport TOCInline from '@theme/TOCInline'\n\n<TOCInline\n  toc={toc}\n  maxHeadingLevel={4}\n/>\n\n## Default Data Converter\n\nIn TypeScript, the default Data Converter supports:\n\n- `undefined`\n- `Uint8Array`\n- JSON\n\n## Custom Data Converter\n\n> API doc: [DataConverter](https://typescript.temporal.io/api/interfaces/worker.dataconverter/)\n\nTo send values that are not [JSON-serializable](https://en.wikipedia.org/wiki/JSON#Data_types) like `BigInt`s or `Date`s, provide a custom Data Converter to the Client and Worker:\n\n- [`new WorkflowClient({ ..., dataConverter })`](https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions#dataconverter)\n- [`Worker.create({ ..., dataConverter })`](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#dataconverter)\n\nData Converters have [two parts](/concepts/what-is-a-data-converter#payload-codecs):\n\n- [`PayloadConverter`](#payloadconverter): sync methods that sometimes run inside the Workflow isolate (and are thus [limited](/typescript/determinism#imports-in-workflow-code))\n- [`PayloadCodec`](#payloadcodec): async methods that are run outside the isolate\n\n```ts\ninterface DataConverter {\n  payloadConverterPath?: string;\n  payloadCodecs?: PayloadCodec[];\n}\n```\n\n### `PayloadConverter`\n\n> API doc: [PayloadConverter](https://typescript.temporal.io/api/interfaces/common.PayloadConverter)\n\n```ts\ninterface PayloadConverter {\n  /**\n   * Converts a value to a {@link Payload}.\n   * @param value The value to convert. Example values include the Workflow args sent by the client and the values returned by a Workflow or Activity.\n   */\n  toPayload<T>(value: T): Payload;\n\n  /**\n   * Converts a {@link Payload} back to a value.\n   */\n  fromPayload<T>(payload: Payload): T;\n}\n```\n\n#### Custom implementation\n\nSome example implementations are in the SDK itself:\n\n- [`common/src/converter/payload-converters.ts`](https://github.com/temporalio/sdk-typescript/blob/main/packages/common/src/converter/payload-converters.ts)\n- [`common/src/converter/protobuf-payload-converters.ts`](https://github.com/temporalio/sdk-typescript/blob/main/packages/common/src/converter/protobuf-payload-converters.ts)\n\nThere's also a sample project that creates an EJSON custom `PayloadConverter`: [samples-typescript/ejson](https://github.com/temporalio/samples-typescript/tree/main/ejson)\n\nIt implements `PayloadConverterWithEncoding` instead of `PayloadConverter` so that it could be used with [`CompositePayloadConverter`](https://typescript.temporal.io/api/classes/common.compositepayloadconverter/):\n\n<!--SNIPSTART typescript-ejson-converter-impl -->\n<!--SNIPEND-->\n\nThen we instantiate one and export it:\n\n<!--SNIPSTART typescript-ejson-converter -->\n<!--SNIPEND-->\n\nWe provide it to the Worker and Client:\n\n<!--SNIPSTART typescript-ejson-worker -->\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-ejson-client-setup -->\n<!--SNIPEND-->\n\nThen we can use supported data types in arguments:\n\n<!--SNIPSTART typescript-ejson-client -->\n<!--SNIPEND-->\n\nAnd they get parsed correctly for the Workflow:\n\n<!--SNIPSTART typescript-ejson-workflow -->\n<!--SNIPEND-->\n\n#### Protobufs\n\nTo serialize values as [Protocol Buffers](https://en.wikipedia.org/wiki/Protocol_Buffers):\n\n- Use [`protobufjs`](https://protobufjs.github.io/protobuf.js/)\n- Use runtime-loaded messages (not generated classes) and `MessageClass.create` (not `new MessageClass()`)\n- Generate `json-module.js` with a command like:\n\n  ```sh\n  pbjs -t json-module -w commonjs -o protos/json-module.js protos/*.proto\n  ```\n\n- Patch `json-module.js`:\n\n<!--SNIPSTART typescript-protobuf-root -->\n<!--SNIPEND-->\n\n- Generate `root.d.ts` with:\n\n  ```sh\n  pbjs -t static-module protos/*.proto | pbts -o protos/root.d.ts -\n  ```\n\n- Create a [`DefaultPayloadConverterWithProtobufs`](https://typescript.temporal.io/api/classes/protobufs.defaultpayloadconverterwithprotobufs/):\n\n<!--SNIPSTART typescript-protobuf-converter -->\n<!--SNIPEND-->\n\nAlternatively, we can use Protobuf Payload Converters directly, or with other converters. If we know that we only use Protobuf objects, and we want them binary encoded (which saves space over proto3 JSON, but can't be viewed in the Web UI), we could do:\n\n```ts\nimport { ProtobufBinaryPayloadConverter } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new ProtobufBinaryPayloadConverter(root);\n```\n\nSimilarly, if we wanted binary encoded Protobufs in addition to the other [default types](#default-data-converter), we could do:\n\n```ts\nimport {\n  BinaryPayloadConverter,\n  CompositePayloadConverter,\n  JsonPayloadConverter,\n  UndefinedPayloadConverter,\n} from '@temporalio/common';\nimport { ProtobufBinaryPayloadConverter } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new CompositePayloadConverter(\n  new UndefinedPayloadConverter(),\n  new BinaryPayloadConverter(),\n  new ProtobufBinaryPayloadConverter(root),\n  new JsonPayloadConverter()\n);\n```\n\n- Provide it to the Worker:\n\n<!--SNIPSTART typescript-protobuf-worker -->\n<!--SNIPEND-->\n\n[`WorkerOptions.dataConverter`](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#dataconverter)\n\n- Provide it to the Client:\n\n<!--SNIPSTART typescript-protobuf-client -->\n<!--SNIPEND-->\n\n- Use protobufs in our Workflows and Activities:\n\n<!--SNIPSTART typescript-protobuf-workflow -->\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-protobuf-activity -->\n<!--SNIPEND-->\n\n### `PayloadCodec`\n\n> API doc: [PayloadCodec](https://typescript.temporal.io/api/interfaces/common.PayloadCodec)\n\nThe default `PayloadCodec` does nothing. To create a custom one, we implement this interface:\n\n```ts\ninterface PayloadCodec {\n  /**\n   * Encode an array of {@link Payload}s for sending over the wire.\n   * @param payloads May have length 0.\n   */\n  encode(payloads: Payload[]): Promise<Payload[]>;\n\n  /**\n   * Decode an array of {@link Payload}s received from the wire.\n   */\n  decode(payloads: Payload[]): Promise<Payload[]>;\n}\n```\n\n#### Encryption\n\n> Background: [Data Converter ➡️ Encryption](/concepts/what-is-a-data-converter#encryption)\n\nHere's an example class that implements the `PayloadCodec` interface:\n\n<!--SNIPSTART typescript-encryption-codec -->\n<!--SNIPEND-->\n\nThe encryption and decryption code is in [`src/crypto.ts`](https://github.com/temporalio/samples-typescript/tree/main/encryption/src/crypto.ts). Since encryption is CPU-intensive, and doing AES with Node's built-in crypto module blocks the main thread, we use `@ronomon/crypto-async`, which uses Node's threadpool.\n\nAs before, we provide a custom data converter to the Client and Worker:\n\n<!--SNIPSTART typescript-encryption-client -->\n<!--SNIPEND-->\n\n<!--SNIPSTART typescript-encryption-worker -->\n<!--SNIPEND-->\n\nWhen the Client sends `'Alice: Private message for Bob.'` to the Workflow, it gets encrypted on the Client and decrypted in the Worker. The Workflow receives the decrypted message and appends another message. When it returns that longer string, the string gets encrypted by the Worker and decrypted by the Client.\n\n<!--SNIPSTART typescript-encryption-workflow -->\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"determinism.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/determinism.md","id":423,"markdown_content":"# Determinism in Workflows\n\nTemporal Workflows are executed differently than conventional code as they can be restored at any point.\nA Workflow can sleep for months, and even if your Worker crashes or Temporal Cluster is down, timers and timeouts are persisted and will fire as scheduled.\nAs soon as your Worker and Cluster are back up, your code will _appear_ to resume where it left off.\nThis also means that sleeping or retrying code does not tie up the process - you can run thousands of timers off a single Worker.\n\n```js\nimport * as wf from '@temporalio/workflow';\nconst { yourActivity } = wf.proxyActivities({\n  // persisted\n  startToCloseTimeout: '1 week',\n  retry: {\n    // persisted\n    initialInterval: '1 day',\n  },\n});\n\nexport async function ExampleWorkflow() {\n  let state = []; // mutable local state\n  while (true) {\n    await wf.sleep('30 days'); // persisted\n    state.push(yourActivity()); // activity results can be replayed\n  }\n}\n```\n\nFor this to be possible, Workflow code must be completely deterministic, meaning it does the exact same thing every time it is rerun.\nDeterminism brings limitations: you can't just call an external service, get the current time, or generate a random number, as these are all dependent on the state of the world at the time they're called, and may produce different values.\nThe Temporal SDKs come with a set of tools that allow you to overcome these limitations.\n\n### How a Workflow is executed\n\nThe Temporal TypeScript SDK runs each Workflow in a separate v8 isolate — a \"sandbox\" environment using Node's built in `vm` with its own global variables, just like in the browser.\n\n- When we need to defer execution (such as for a timer or activity), we simply destroy the `vm` context.\n- When we need to continue execution, Temporal Server sends over the Event History, and we replay through the code from the start until the end to restore state.\n  - The serialization takes time, which is why we recommend keeping Event History [under 10,000 events](/kb/temporal-platform-limits-sheet). [\"Sticky\" optimizations exist to make this faster for common situations](/concepts/what-is-a-sticky-execution).\n  - If the execution logic has changed enough to affect Event History, you need to [patch new code](/typescript/patching).\n- The Workflow runtime is completely deterministic: functions like `Math.random`, `Date`, and `setTimeout` are replaced by deterministic versions, and the only way for a Workflow to interact with the world is via Activities.\n- When an Activity completes, its result is stored in the Workflow history to be replayed in case a Workflow is restored.\n\nThe SDK does not throw an exception to suspend execution (like React Suspense), nor does it use VM snapshotting (yet), nor does it do any AST magic.\n\n### Imports in Workflow code\n\nWorkflow code is bundled on Worker creation using [Webpack](https://webpack.js.org), you may import any JS package, **as long as it doesn't reference Node or DOM APIs**.\n\n### Sources of non-determinism\n\n- `Math.random` - replaced by the runtime\n- `uuid4` - provided by the runtime\n- `Date` - replaced by the runtime\n  - `new Date()` and `Date.now()` are both set on the first invocation of the Workflow Task\n- `WeakRef | FinalizationRegistry` - cannot be used, as GC is non-deterministic and the Workflow code may observe its effect; deleted by the runtime\n- Timers - `setTimeout` and `clearTimeout` are replaced by the runtime.\n  - We recommend you use the `@temporal/workflow` package's exported `sleep` function because it plays well with [cancellation scopes](/typescript/cancellation-scopes): `import { sleep } from '@temporalio/workflow'`\n- Activities - use to run non-deterministic code; results are replayed from history\n- Node built ins:\n  - `process` global\n  - `path` module, `fs` module\n\n### Deterministic examples\n\nHow `Date` is deterministic:\n\n```js\nimport { sleep } from '@temporalio/workflow';\n\n// this prints the *exact* same timestamp repeatedly\nfor (let x = 0; x < 10; ++x) {\n  console.log(Date.now());\n}\n\n// this prints timestamps increasing roughly 1s each iteration\nfor (let x = 0; x < 10; ++x) {\n  await sleep('1 second');\n  console.log(Date.now());\n}\n```\n","is_empty":false},{"file_name":"failures.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/failures.md","id":424,"title":"Handling Failures in TypeScript","description":"Failures in Temporal are structured and typed. They represent a variety of failure scenarios across the different SDKs and the server.","label":"Handling Failures","markdown_content":"\nFailures in Temporal are structured and typed. They represent a variety of failure scenarios across the different SDKs and the server.\n\nIn the TypeScript SDK, failures are represented by [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) classes. They can be caught in both Workflow code and non-Workflow code.\n\n<details>\n<summary>\nFailures are serializable over the network and chainable to enable root-cause analysis anywhere in the failure chain.\n</summary>\n\nIf, for example, a TypeScript Workflow starts a Java Child Workflow which calls an Activity in Golang and that activity fails, the TypeScript Workflow will throw a `ChildWorkflowFailure` with `cause` set to an `ActivityFailure`, and the `ActivityFailure`'s `cause` is set to `ApplicationFailure`, which represents the error that occurred in the Golang Activity.\n\n<!--TODO: use snipsync-->\n\n```ts\nimport { executeChild } from '@temporalio/workflow';\nimport {\n  ActivityFailure,\n  ApplicationFailure,\n  ChildWorkflowFailure,\n} from '@temporalio/common';\n\n// Define the TypeScript version of the Java Workflow interface\n// to get a type safe child WorkflowHandle\nexport type JavaWorkflow = () => Promise<void>;\n\nasync function yourWorkflow(): Promise<void> {\n  try {\n    await executeChild<JavaWorkflow>('RunAnActivityWorkflow');\n  } catch (err) {\n    if (\n      err instanceof ChildWorkflowFailure &&\n      err.cause instanceof ActivityFailure &&\n      err.cause.cause instanceof ApplicationFailure\n    ) {\n      console.log(\n        'Child workflow failure root cause was a failed activity',\n        err.cause.cause.message\n      );\n    }\n    throw err;\n  }\n}\n```\n\n</details>\n\nOutside of Workflow code, failure classes are attached to the `cause` of [`WorkflowFailedError`](https://typescript.temporal.io/api/classes/client.workflowfailederror), which is thrown when executing a Workflow with a [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.workflowclient/) or [`WorkflowHandle`](https://typescript.temporal.io/api/interfaces/client.workflowhandle/).\n\n## Failures and retries\n\nActivities and Workflows scheduled in the system have a configurable [retry policy](https://typescript.temporal.io/api/interfaces/proto.coresdk.common.iretrypolicy), which many contain an array of `nonRetryableErrorTypes`.\n\nWhen a Workflow or Activity fails with an unhandled error, Temporal checks if the error name is present in the array of `nonRetryableErrorTypes` and stops retrying if there's a match.\n\nWorkflows and Activities may also throw [`ApplicationFailure.nonRetryable`](https://typescript.temporal.io/api/classes/client.applicationfailure#nonretryable-1) to expressly prevent retries.\n\nPropagated Activity and child Workflow failures are considered retryable and will be retried according to the parent Workflow's retry policy.\n\nThe expected behavior is:\n\n- Non retryable application failure -> fails the workflow and cannot be retried\n- Retryable application failure -> fails the workflow and can be retried according to the retry policy\n- Other TemporalFailures -> same as retryable application failure\n- Any other error -> fails the workflow task and can be retried\n\n> Note: Before TypeScript SDK v0.17.0, throwing any error in a Workflow would cause the Workflow execution to fail - in other words, all errors were \"retryable\". The semantics of this was corrected in v0.17.\n\n### Pattern: Wrapping Errors with Interceptors\n\nTo make other error types fail the workflow, use the `WorkflowInboundCallsInterceptor` methods (`execute` and `handleSignal`) to catch errors thrown from the Workflow and convert them to `ApplicationFailures`, e.g:\n\n```ts\nasync function wrapError<T>(fn: () => Promise<T>): Promise<T> {\n  try {\n    return await fn();\n  } catch (err) {\n    if (err instanceof MySpecialRetryableError) {\n      throw ApplicationFailure.retryable(\n        err.message,\n        'MySpecialRetryableError'\n      ); // can also make this nonRetryable if that is the intent. remember to change the error name.\n    }\n    throw err;\n  }\n}\n\nclass WorkflowErrorInterceptor implements WorkflowInboundCallsInterceptor {\n  async execute(\n    input: WorkflowExecuteInput,\n    next: Next<WorkflowInboundCallsInterceptor, 'execute'>\n  ): Promise<unknown> {\n    return await wrapError(() => next(input));\n  }\n\n  async handleSignal(\n    input: SignalInput,\n    next: Next<WorkflowInboundCallsInterceptor, 'handleSignal'>\n  ): Promise<void> {\n    return await wrapError(() => next(input));\n  }\n}\n```\n\n## `isCancellation` utility\n\nFailures are also used to represent [cancellation](/typescript/cancellation-scopes#cancelledfailure) of Activities and Child Workflows.\n\nAs explained above, cancellation might not be the immediate cause of failure — it might happen further down the chain. Use the [`isCancellation`](https://typescript.temporal.io/api/namespaces/workflow/#iscancellation) helper function to inspect the chain recursively and look for a `CancelledFailure`.\n\n```ts\nimport {\n  CancellationScope,\n  proxyActivities,\n  isCancellation,\n} from '@temporalio/workflow';\nimport * as activities from '../activities';\n\nexport function yourWorkflow(\n  urls: string[],\n  timeoutMs: number\n): Promise<any[]> {\n  const { httpGetJSON } = proxyActivities<typeof activities>({\n    scheduleToCloseTimeout: timeoutMs,\n  });\n\n  try {\n    return await CancellationScope.withTimeout(timeoutMs, () =>\n      Promise.all(urls.map((url) => httpGetJSON(url)))\n    );\n  } catch (err) {\n    if (isCancellation(err)) {\n      console.log('Deadline exceeded while waiting for activities to complete');\n    }\n    throw err;\n  }\n}\n```\n\n## Failure classes reference\n\n### [TemporalFailure](https://typescript.temporal.io/api/classes/client.temporalfailure)\n\nThe base class of all other failure classes in the SDK.\n\n### [ApplicationFailure](https://typescript.temporal.io/api/classes/client.applicationfailure)\n\n`ApplicationFailure` is used to communicate application-specific failures between Workflows and Activities.\n\nThrow this exception to have full control over type and details of the exception delivered to the caller Workflow or client.\n\nAny unhandled exception that doesn't extend [`TemporalFailure`](#temporalfailure) is converted to an instance of `ApplicationFailure` before being returned to a caller.\n\n### [CancelledFailure](https://typescript.temporal.io/api/classes/client.cancelledfailure)\n\n`CancelledFailure` is thrown in a Workflow when a cancellation scope or the entire Workflow has been cancelled or set as the cause for when a child Workflow or Activity has been cancelled.\n\nIn an Activity, it may be thrown if the Activity was requested to be cancelled. More on activity cancellation [here](/typescript/activities#activity-cancellation).\n\n### [ActivityFailure](https://typescript.temporal.io/api/classes/client.activityfailure)\n\nContains information about an Activity failure. Always contains the original reason for the failure as its cause. For example, if an Activity timed out, the cause is set to `TimeoutFailure`.\n\n**This exception is expected to be thrown only by the framework code.**\n\n### [ChildWorkflowFailure](https://typescript.temporal.io/api/classes/client.childworkflowfailure)\n\nContains information about a child Workflow failure. Always contains the original reason for the\nfailure as its cause. For example, if a child workflow was terminated, the cause is set to `TerminatedFailure`.\n\n**This exception is expected to be thrown only by the framework code.**\n\n### [TimeoutFailure](https://typescript.temporal.io/api/classes/client.timeoutfailure)\n\nUsed to represent timeouts of Activities and Workflows.\n\nWhen an activity times out, the last heartbeat details it emitted is attached to this failure.\n\n### [TerminatedFailure](https://typescript.temporal.io/api/classes/client.terminatedfailure)\n\nUsed as the cause for when a Workflow has been terminated.\n\n### [ServerFailure](https://typescript.temporal.io/api/classes/client.serverfailure)\n\nUsed for exceptions originated at the Temporal service.\n","is_empty":false},{"file_name":"how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-add-custom-search-attributes-to-workflow-executions-at-start-time-in-typescript.md","id":425,"title":"How to add custom Search Attributes to Workflow Executions at start time in TypeScript","description":"Add custom Search Attributes to Workflow Executions at start time","label":"Add custom Search Attributes to Workflow Executions at start time","tags":["developer-guide","typescript","client"],"markdown_content":"\nUse [`WorkflowOptions.searchAttributes`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions#searchattributes).\n\n<!--SNIPSTART typescript-search-attributes-client-->\n<!--SNIPEND-->\n\nThe type of `searchAttributes` is `Record<string, string[] | number[] | boolean[] | Date[]>`.\n","is_empty":false},{"file_name":"how-to-configure-tracing-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-configure-tracing-in-typescript.md","id":426,"title":"How to configure tracing in TypeScript","description":"Configure tracing","label":"Configure tracing","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nThe [`interceptors-opentelemetry`](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry) sample shows how to use the SDK's built-in OpenTelemetry tracing to trace everything from starting a Workflow to Workflow Execution to running an Activity from that Workflow.\n\nThe built-in tracing uses protobuf message headers (like [this one](https://github.com/temporalio/api/blob/b2b8ae6592a8730dd5be6d90569d1aea84e1712f/temporal/api/workflowservice/v1/request_response.proto#L161) when starting a Workflow) to propagate the tracing information from the client to the Workflow and from the Workflow to its successors (when Continued As New), children, and Activities.\nAll of these executions are linked with a single trace identifier and have the proper `parent -> child` span relation.\n\nTracing is compatible between different Temporal SDKs as long as compatible [context propagators](https://opentelemetry.lightstep.com/core-concepts/context-propagation/) are used.\n\n**Context propagation**\n\nThe TypeScript SDK uses the global OpenTelemetry propagator.\n\nTo extend the default ([Trace Context](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#w3ctracecontextpropagator-propagator) and [Baggage](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#baggage-propagator) propagators) to also include the [Jaeger propagator](https://www.npmjs.com/package/@opentelemetry/propagator-jaeger), follow these steps:\n\n- `npm i @opentelemetry/propagator-jaeger`\n\n- At the top level of your Workflow code, add the following lines:\n\n  ```js\n  import { propagation } from '@opentelemetry/api';\n  import {\n    CompositePropagator,\n    W3CTraceContextPropagator,\n    W3CBaggagePropagator,\n  } from '@opentelemetry/core';\n  import { JaegerPropagator } from '@opentelemetry/propagator-jaeger';\n\n  propagation.setGlobalPropagator(\n    new CompositePropagator({\n      propagators: [\n        new W3CTraceContextPropagator(),\n        new W3CBaggagePropagator(),\n        new JaegerPropagator(),\n      ],\n    })\n  );\n  ```\n\nSimilarly, you can customize the OpenTelemetry `NodeSDK` propagators by following the instructions in the [Initialize the SDK](https://github.com/open-telemetry/opentelemetry-js/tree/main/experimental/packages/opentelemetry-sdk-node#initialize-the-sdk) section of the README.\n","is_empty":false},{"file_name":"how-to-create-a-temporal-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-create-a-temporal-client-in-typescript.md","id":427,"title":"How to create a Temporal Client in TypeScript","description":"Create a Temporal Client","label":"Create a Temporal Client","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nUse a new `WorflowClient()` with the requisite gRPC [`Connection`](https://typescript.temporal.io/api/classes/client.Connection#service) to create a new Client.\n\n```typescript\nimport { Connection, WorkflowClient } from '@temporalio/client';\nconst connection = await Connection.connect(); // to configure for production\nconst client = new WorkflowClient({ connection });\n```\n\nDeclaring the `WorflowClient()` creates a new connection to the Temporal service.\n\nIf you omit the connection and just call the `new WorkflowClient()`, you create a default connection that works locally.\nHowever, always configure your connection and Namespace when [deploying to production](/typescript/security/#encryption-in-transit-with-mtls).\n\nThe following example, creates a Client, connects to an account, and declares your Namespace.\n\n```typescript\nimport { Connection, WorkflowClient } from '@temporalio/client';\n\nconst connection = await Connection.connect({\n  address: '<Namespace_ID>.tmprl.cloud',\n});\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'your.namespace',\n});\n```\n","is_empty":false},{"file_name":"how-to-define-a-signal-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-define-a-signal-in-typescript.md","id":428,"title":"How to define a Signal in TypeScript","description":"Define Signal","label":"Define Signal","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`defineSignal`](https://typescript.temporal.io/api/namespaces/workflow/#definesignal)\n\n```ts\nimport { defineSignal } from '@temporalio/workflow';\n\ninterface JoinInput {\n  userId: string;\n  groupId: string;\n}\n\nexport const joinSignal = defineSignal<[JoinInput]>('join');\n```\n","is_empty":false},{"file_name":"how-to-define-activity-parameters-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-define-activity-parameters-in-typescript.md","id":429,"markdown_content":"","is_empty":false},{"file_name":"how-to-define-activity-return-values-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-define-activity-return-values-in-typescript.md","id":430,"title":"How to define Activity Return Values in TypeScript","description":"Define Activity Return Values","label":"Define Activity Return Values","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo import the types of the Activities defined in `./activities`, you must first retrieve an Activity from an _Activity Handle_ before you can call it, then define Return Types in your Activity.\n\n```typescript\nimport type * as activities from './activities';\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\n// A workflow that simply calls an activity\nexport async function example(name: string): Promise<string> {\n  return await greet(name);\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-parameters-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-define-workflow-parameters-in-typescript.md","id":431,"title":"How to define Workflow parameters in TypeScript","description":"Define Workflow parameters","label":"Define Workflow parameters","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nYou can define and pass parameters in your Workflow. In this example, you define your arguments in your `client.ts` file and pass those parameters to `workflow.ts` through your Workflow function.\n\nStart a Workflow with the parameters that are in the `client.ts` file. In this example we set the `name` parameter to `Temporal` and `born` to `2019`. Then set the Task Queue and Workflow Id.\n\n`client.ts`\n\n```typescript\nimport { example } from './workflows';\n\n...\nawait client.start(example, {\n  args: [{ name: 'Temporal', born: 2019 }],\n  taskQueue: 'your-queue',\n  workflowId: 'business-meaningful-id',\n});\n```\n\nIn `workflows.ts` define the type of the parameter that the Workflow function takes in. The interface `ExampleParam` is a name we can now use to describe the requirement in the previous example. It still represents having the two properties called `name` and `born` that is of the type `string`. Then define a function that takes in a parameter of the type `ExampleParam` and return a `Promise<string>`. The `Promise` object represents the eventual completion, or failure, of `await client.start()` and its resulting value.\n\n```ts\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({ name, born }: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n","is_empty":false},{"file_name":"how-to-define-workflow-return-values-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-define-workflow-return-values-in-typescript.md","id":432,"title":"How to define Workflow return values in TypeScript","description":"Define Workflow return values","label":"Define Workflow return values","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo return a value of the Workflow function, use `Promise<something>`. The `Promise` is used to make asynchronous calls and comes with guarantees.\n\nThe following example uses a `Promise<string>` to eventually return a `name` and `born` parameter.\n\n```typescript\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({ name, born }: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-a-worker-program-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-develop-a-worker-program-in-typescript.md","id":433,"title":"How to develop a Worker program in TypeScript","description":"Develop a Worker program","label":"Develop a Worker program","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nCreate a Worker with `Worker.create()` (which establishes the initial gRPC connection), then call `worker.run()` on it (to start polling the Task Queue).\n\nBelow is an example of starting a Worker that polls the Task Queue named `tutorial`.\n\n<!--SNIPSTART typescript-hello-worker {\"enable_source_link\": false}-->\n<!--SNIPEND-->\n\n`taskQueue` is the only required option, but you will also use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nA full example for Workers looks like this:\n\n```typescript\nimport { Worker, NativeConnection } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  const connection = await NativeConnection.connect({\n    // defaults port to 7233 if not specified\n    address: 'foo.bar.tmprl.cloud',\n    tls: {\n      // set to true if TLS without mTLS\n      // See docs for other TLS options\n      clientCertPair: {\n        crt: clientCert,\n        key: clientKey,\n      },\n    },\n  });\n\n  const worker = await Worker.create({\n    connection,\n    namespace: 'foo.bar', // as explained in Namespaces section\n    // ...\n  });\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\nSee below for more Worker options.\n\n**Workflow and Activity registration**\n\nWorkers bundle Workflow code and `node_modules` using Webpack v5 and execute them inside V8 isolates.\nActivities are directly required and run by Workers in the Node.js environment.\n\nWorkers are very flexible – you can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers in a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker. Not the path.\n- Workflow bundle:\n- Either specify a `workflowsPath` to your `workflows.ts` file to pass to Webpack, e.g., `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n- Or pass a prebuilt bundle to `workflowBundle` instead if you prefer to handle the bundling yourself.\n\n**Additional Worker Options**\n\nThis is a selected subset of options you are likely to use. Even more advanced options, particularly for performance tuning, are available in [the API reference](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions).\n\n| Options         | Description                                                                                                                           |\n| --------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| `dataConverter` | Encodes and decodes data entering and exiting a Temporal Server. Supports `undefined`, `UintBArray`, and JSON.                        |\n| `sinks`         | Allows injection of Workflow Sinks (Advanced feature: see [Logging docs](/typescript/logging))                                        |\n| `interceptors`  | A mapping of interceptor type to a list of factories or module paths (Advanced feature: see [Interceptors](/typescript/interceptors)) |\n\n**Operation guides:**\n\n- [How to tune Workers](/application-development/worker-performance)\n","is_empty":false},{"file_name":"how-to-develop-a-workflow-definition-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-develop-a-workflow-definition-in-typescript.md","id":434,"title":"How to develop a Workflow Definition in TypeScript","description":"Develop a Workflow Definition","label":"Develop a Workflow Definition","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWorkflow Definitions are _just functions_, which can store state and orchestrate Activity Functions.\nThe following code snippet uses `proxyActivities` to schedule a `greet` Activity in the system to say hello.\n\nA Workflow Definition can have multiple parameters; however, we recommend using a single object parameter.\n\n```typescript\ntype ExampleArgs = {\n  name: string;\n};\n\nexport async function example(\n  args: ExampleArgs\n): Promise<{ greeting: string }> {\n  const greeting = await greet(args.name);\n  return { greeting };\n}\n```\n","is_empty":false},{"file_name":"how-to-develop-an-activity-definition-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-develop-an-activity-definition-in-typescript.md","id":435,"title":"How to develop an Activity Definition in TypeScript","description":"Develop an Activity Definition","label":"Develop an Activity Definition","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n- Activities execute in the standard Node.js environment.\n- Activities cannot be in the same file as Workflows and must be separately registered.\n- Activities may be retried repeatedly, so you may need to use idempotency keys for critical side effects.\n\nActivities are _just functions_. The following is an Activity that accepts a string parameter and returns a string.\n\n```typescript\nexport async function greet(name: string): Promise<string> {\n  return `Hello, ${name}!`;\n}\n```\n","is_empty":false},{"file_name":"how-to-emit-metrics-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-emit-metrics-typescript.md","id":436,"title":"How to emit metrics in TypeScript","description":"Emit metrics","label":"Emit metrics","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWorkers can emit metrics and traces. There are a few [telemetry options](https://typescript.temporal.io/api/interfaces/worker.TelemetryOptions) that can be provided to [`Runtime.install`](https://typescript.temporal.io/api/classes/worker.runtime/#install). The common options are:\n\n- `metrics: { otel: { url } }`: The URL of a gRPC [OpenTelemetry collector](https://opentelemetry.io/docs/collector/).\n- `metrics: { prometheus: { bindAddress } }`: Address on the Worker host that will have metrics for [Prometheus](https://prometheus.io/) to scrape.\n\nTo set up tracing of Workflows and Activities, use our [opentelemetry-interceptors](/typescript/logging#opentelemetry-tracing) package.\n\n```typescript\n  telemetryOptions: {\n      metrics: {\n        prometheus: { bindAddress: '0.0.0.0:9464' },\n      },\n      logging: { forward: { level: 'DEBUG' } },\n    },\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-a-workflow-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-get-the-result-of-a-workflow-execution-in-typescript.md","id":437,"title":"How to get the result of a Workflow execution in TypeScript","description":"Get the result of a Workflow execution","label":"Workflow result","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo return the results of a Workflow Execution:\n\n```typescript\nreturn (\n  'Completed ' +\n  wf.workflowInfo().workflowId +\n  ', Total Charged: ' +\n  totalCharged\n);\n```\n\n`totalCharged` is just a function declared in your code. For a full example, see [subscription-workflow-project-template-typescript/src/workflows.ts](https://github.com/temporalio/subscription-workflow-project-template-typescript/blob/main/src/workflows.ts).\n\nA Workflow function may return a result. If it doesn’t (in which case the return type is `Promise<void>`), the result will be `undefined`.\n\nIf you started a Workflow with `handle.start()`, you can choose to wait for the result anytime with `handle.result()`.\n\n```typescript\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nUsing a Workflow Handle isn't necessary with `client.execute()`.\n\nWorkflows that prematurely end will throw a `WorkflowFailedError` if you call `result()`.\n\nIf you call `result()` on a Workflow that prematurely ended for some reason, it throws a [`WorkflowFailedError` error](https://typescript.temporal.io/api/classes/client.workflowfailederror/) that reflects the reason. For that reason, it is recommended to catch that error.\n\n```typescript\nconst handle = client.getHandle(workflowId);\ntry {\n  const result = await handle.result();\n} catch (err) {\n  if (err instanceof WorkflowFailedError) {\n    throw new Error('Temporal workflow failed: ' + workflowId, {\n      cause: err,\n    });\n  } else {\n    throw new Error('error from Temporal workflow ' + workflowId, {\n      cause: err,\n    });\n  }\n}\n```\n","is_empty":false},{"file_name":"how-to-get-the-result-of-an-activity-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-get-the-result-of-an-activity-execution-in-typescript.md","id":438,"title":"How to get the result of an Activity Execution in TypeScript","description":"Get the result of an Activity Execution","label":"Get the result of an Activity Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nSince Activities are referenced by their string name, you can reference them dynamically to get the result of an Activity Execution.\n\n```typescript\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts['activity1']();\n\n  let result = await acts[activityName](...args);\n  return result;\n}\n```\n\nThe `proxyActivities()` returns an object that calls the Activities in the function. `acts[activityName]()` references the Activity using the Activity name, then it returns the results.\n","is_empty":false},{"file_name":"how-to-handle-a-query-in-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-handle-a-query-in-a-workflow-in-typescript.md","id":439,"title":"How to handle a Query in a Workflow in TypeScript","description":"To handle a Query in a Workflow, define a Query handler method using the `handle.query(query, ...args)` annotation in the Workflow interface.","label":"Handle Query","tags":["typescript","developer-guide"],"markdown_content":"\nQuery Handlers can return values inside a Workflow in TypeScript.\n\nYou make a Query with `handle.query(query, ...args)`. A Query needs a return value, but can also take arguments.\n\n```typescript\nimport * as wf from '@temporalio/workflow';\n\nexport const unblockSignal = wf.defineSignal('unblock');\nexport const isBlockedQuery = wf.defineQuery<boolean>('isBlocked');\n\nexport async function unblockOrCancel(): Promise<void> {\n  let isBlocked = true;\n  wf.setHandler(unblockSignal, () => void (isBlocked = false));\n  wf.setHandler(isBlockedQuery, () => isBlocked);\n  console.log('Blocked');\n  try {\n    await wf.condition(() => !isBlocked);\n    console.log('Unblocked');\n  } catch (err) {\n    if (err instanceof wf.CancelledFailure) {\n      console.log('Cancelled');\n    }\n    throw err;\n  }\n}\n```\n","is_empty":false},{"file_name":"how-to-handle-a-signal-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-handle-a-signal-in-typescript.md","id":440,"title":"How to handle a Signal in TypeScript","description":"Handle Signal","label":"Handle Signal","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`setHandler`](https://typescript.temporal.io/api/namespaces/workflow/#sethandler)\n\n```ts\nimport { setHandler } from '@temporalio/workflow';\n\nexport async function yourWorkflow() {\n  const groups = new Map<string, Set<string>>();\n\n  setHandler(joinSignal, ({ userId, groupId }: JoinInput) => {\n    const group = groups.get(groupId);\n    if (group) {\n      group.add(userId);\n    } else {\n      groups.set(groupId, new Set([userId]));\n    }\n  });\n}\n```\n","is_empty":false},{"file_name":"how-to-heartbeat-an-activity-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-heartbeat-an-activity-in-typescript.md","id":441,"title":"How to Heartbeat an Activity in TypeScript","description":"Heartbeat Activities to track their progress and get details of the Activity Execution.","label":"Activity Heartbeat","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nLong-running Activities should Heartbeat their progress back to the Workflow for earlier detection of stalled Activities (with [Heartbeat Timeout](/concepts/what-is-a-heartbeat-timeout)) and resuming stalled Activities from checkpoints (with Heartbeat details).\n\nTo set Activity Heartbeat, use `Context.current().heartbeat()` in your Activity implementation, and set `heartbeatTimeout` in your Workflow.\n\n```ts\n// activity implementation\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  for (let progress = 1; progress <= 1000; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    // record activity heartbeat\n    Context.current().heartbeat();\n  }\n}\n\n//...\n\n// workflow code calling activity\nconst { example } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 hour',\n  heartbeatTimeout: '10s',\n});\n```\n\nIn the previous example, setting the Heartbeat informs the Temporal Server of the Activity's progress at regular intervals.\nIf the Activity stalls or the Activity Worker becomes unavailable, the absence of Heartbeats prompts the Temporal Server to retry the Activity immediately, without waiting for `startToCloseTimeout` to complete.\n\nYou can also add `heartbeatDetails` as a checkpoint to collect data about failures during the execution, and use it to resume the Activity from that point.\n\nThe following example extends the previous sample to include a `heartbeatDetails` checkpoint.\n\n```ts\nexport async function example(sleepIntervalMs = 1000): Promise<void> {\n  const startingPoint = Context.current().info.heartbeatDetails || 1; // allow for resuming from heartbeat\n  for (let progress = startingPoint; progress <= 100; ++progress) {\n    await Context.current().sleep(sleepIntervalMs);\n    Context.current().heartbeat(progress);\n  }\n}\n```\n\nIn this example, when the `heartbeatTimeout` is reached and the Activity is retried, the Activity Worker picks up the execution from where the previous attempt left off.\n","is_empty":false},{"file_name":"how-to-list-search-attributes-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-list-search-attributes-in-typescript.md","id":442,"title":"How to list Search Attributes in TypeScript","description":"List Search Attributes","label":"List Search Attributes","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n**Listing**\n\nFor now, we can call [`client.service.listWorkflowExecutions()`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.WorkflowService-1#listworkflowexecutions). A friendlier `client.listWorkflows()` function that does Payload decoding is planned.\n\n```ts\nconst { executions, nextPageToken } =\n  await client.service.listWorkflowExecutions({\n    namespace: 'default',\n    ...(input || {}),\n  });\nconst decodedWorkflows = executions.map(\n  ({\n    execution,\n    type,\n    startTime,\n    closeTime,\n    status,\n    historyLength,\n    parentNamespaceId,\n    parentExecution,\n    executionTime,\n    memo: memoRaw,\n    searchAttributes: searchAttributesRaw,\n    // autoResetPoints,\n    taskQueue,\n    stateTransitionCount,\n  }) => {\n    let memo: Record<string, unknown> | undefined | null = null;\n    let searchAttributes: Record<string, unknown> | undefined | null = null;\n\n    try {\n      memo = mapFromPayloads(defaultConverter, memoRaw?.fields);\n      searchAttributes = mapFromPayloads(\n        searchAttributeConverter,\n        searchAttributesRaw?.indexedFields\n      );\n    } catch (e) {\n      // unable to convert with default converter\n    }\n\n    return {\n      id: execution!.workflowId,\n      runId: execution!.runId,\n      type: type!.name,\n      status: status!,\n      taskQueue: taskQueue!,\n      historyLength: historyLength!.toInt(),\n      startTime: tsToDate(startTime!),\n      executionTime: tsToDate(executionTime!),\n      closeTime: optionalTsToDate(closeTime),\n      parentExecution,\n      parentNamespace: parentNamespaceId || null, // convert empty string to null\n      memo: memo && Object.keys(memo!).length === 0 ? null : memo, // convert empty object to null\n      searchAttributes,\n      stateTransitionCount: stateTransitionCount!.toInt(),\n    } as unknown as Workflow;\n  }\n);\n```\n","is_empty":false},{"file_name":"how-to-list-workflow-executions-using-the-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-list-workflow-executions-using-the-client-in-typescript.md","id":443,"title":"How to list Workflow Executions using the Client in TypeScript","description":"List Workflow Executions using the Client","label":"List Workflow Executions using the Client","tags":["developer-guide","typescript","client"],"markdown_content":"\nUse [`WorkflowService.listWorkflowExecutions`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#listworkflowexecutions):\n\n```typescript\nimport { Connection } from '@temporalio/client';\n\nconst connection = await Connection.connect();\nconst response = await connection.workflowService.listWorkflowExecutions({\n  query: `ExecutionStatus = \"Running\"`,\n});\n```\n\nwhere `query` is a [List Filter](/concepts/what-is-a-list-filter/).\n","is_empty":false},{"file_name":"how-to-log-from-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-log-from-a-workflow-in-typescript.md","id":444,"title":"How to log from a Workflow in TypeScript","description":"Log from a Workflow","label":"Log from a Workflow","tags":["developer-guide","sdk","typescript","log"],"markdown_content":"\nLogging from Workflows is tricky for two reasons:\n\n1. Workflows run in a sandboxed environment and cannot do any I/O.\n1. Workflow code might get replayed at any time, generating duplicate log messages.\n\nTo work around these limitations, we recommend using the Sinks feature in the TypeScript SDK.\nSinks enable one-way export of logs, metrics, and traces from the Workflow isolate to the Node.js environment.\n\n<!--\nWorkflows in Temporal may be replayed from the beginning of their history when resumed. In order for Temporal to recreate the exact state Workflow code was in, the code is required to be fully deterministic. To prevent breaking [determinism](/typescript/determinism), in the TypeScript SDK, Workflow code runs in an isolated execution environment and may not use any of the Node.js APIs or communicate directly with the outside world. -->\n\nSinks are written as objects with methods. Similar to Activities, they are declared in the Worker and then proxied in Workflow code, and it helps to share types between both.\n\n<details>\n  <summary>Comparing Sinks, Activities and Interceptors</summary>\n  \nSinks are similar to Activities in that they are both registered on the Worker and proxied into the Workflow.\nHowever, they differ from Activities in important ways:\n\n- Sink functions don't return any value back to the Workflow and cannot not be awaited.\n- Sink calls are not recorded in Workflow histories (no timeouts or retries).\n- Sink functions are _always_ run on the same Worker that runs the Workflow they are called from.\n\n</details>\n\n**Declaring the Sink Interface**\n\nExplicitly declaring a Sink's interface is optional, but is useful for ensuring type safety in subsequent steps:\n\n<!--SNIPSTART typescript-logger-sink-interface-->\n<!--SNIPEND-->\n\n**Implementing Sinks**\n\nImplementing Sinks is a two-step process.\n\nImplement and inject the Sink function into a Worker\n\n<!--SNIPSTART typescript-logger-sink-worker-->\n<!--SNIPEND-->\n\n- Sink function implementations are passed as an object into [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#sinks)\n- You can specify whether you want the injected function to be called during Workflow replay by setting the `callDuringReplay` boolean option.\n\n**Proxy and call a Sink function from a Workflow**\n\n<!--SNIPSTART typescript-logger-sink-workflow-->\n<!--SNIPEND-->\n\nSome important features of the [InjectedSinkFunction](https://typescript.temporal.io/api/interfaces/worker.InjectedSinkFunction) interface:\n\n- **Injected WorkflowInfo argument**: The first argument of a Sink function implementation is a [`workflowInfo` object](https://typescript.temporal.io/api/interfaces/workflow.workflowinfo/) that contains useful metadata.\n- **Limited arguments types**: The remaining Sink function arguments are copied between the sandbox and the Node.js environment using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n- **No return value**: To prevent breaking determinism, Sink functions cannot return values to the Workflow.\n\n**Advanced: Performance considerations and non-blocking Sinks**\n\nThe injected sink function contributes to the overall Workflow Task processing duration.\n\n- If you have a long-running sink function, such as one that tries to communicate with external services, you might start seeing Workflow Task timeouts.\n- The effect is multiplied when using `callDuringReplay: true` and replaying long Workflow histories because the Workflow Task timer starts when the first history page is delivered to the Worker.\n","is_empty":false},{"file_name":"how-to-remove-search-attributes-from-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-remove-search-attributes-from-a-workflow-in-typescript.md","id":445,"title":"How to remove Search Attributes from a Workflow in TypeScript","description":"How to remove Search Attributes from a Workflow","label":"Remove Search Attributes from a Workflow","tags":["developer-guide","typescript","client"],"markdown_content":"\n```typescript\nimport { upsertSearchAttributes } from '@temporalio/workflow';\n\nasync function yourWorkflow() {\n  upsertSearchAttributes({ CustomIntField: [1, 2, 3] });\n\n  // ... later, to remove:\n  upsertSearchAttributes({ CustomIntField: [] });\n}\n```\n","is_empty":false},{"file_name":"how-to-replay-a-workflow-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-replay-a-workflow-execution-in-typescript.md","id":446,"title":"How to replay a Workflow Execution in TypeScript","description":"Replay a Workflow Execution","label":"Replay a Workflow Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWorkflows in Temporal may be replayed from the beginning of their history when resumed. In order for Temporal to recreate the exact state Workflow code was in, the code is required to be fully deterministic. To prevent breaking [determinism](/typescript/determinism), in the TypeScript SDK, Workflow code runs in an isolated execution environment and may not use any of the Node.js APIs or communicate directly with the outside world.\n\nSee how to replay in [this video](https://www.youtube.com/watch?v=fN5bIL7wc5M).\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-send-a-signal-from-a-client-in-typescript.md","id":447,"title":"How to send a Signal from a Client in TypeScript","description":"Send a Signal from Client","label":"Send a Signal from Client","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`WorkflowHandle.signal`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#signal)\n\n```typescript\nimport { WorkflowClient } from '@temporalio/client';\nimport { joinSignal } from './workflows';\n\nconst client = new WorkflowClient();\n\nconst handle = client.getHandle('workflow-id-123');\n\nawait handle.signal(joinSignal, { userId: 'user-1', groupId: 'group-1' });\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-from-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-send-a-signal-from-a-workflow-in-typescript.md","id":448,"title":"How to send a Signal from Workflow in TypeScript","description":"Send a Signal from Workflow","label":"Send a Signal from Workflow","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`getExternalWorkflowHandle`](https://typescript.temporal.io/api/namespaces/workflow#getexternalworkflowhandle)\n\n```typescript\nimport { getExternalWorkflowHandle } from '@temporalio/workflow';\nimport { joinSignal } from './other-workflow';\n\nexport async function yourWorkflowThatSignals() {\n  const handle = getExternalWorkflowHandle('workflow-id-123');\n  await handle.signal(joinSignal, { userId: 'user-1', groupId: 'group-1' });\n}\n```\n","is_empty":false},{"file_name":"how-to-send-a-signal-with-start-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-send-a-signal-with-start-in-typescript.md","id":449,"title":"How to send a Signal with Start in TypeScript","description":"Send a Signal with Start","label":"Send a Signal with Start","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[`WorkflowClient.signalWithStart`](https://typescript.temporal.io/api/classes/client.WorkflowClient#signalwithstart)\n\n```typescript\nimport { WorkflowClient } from '@temporalio/client';\nimport { yourWorkflow, joinSignal } from './workflows';\n\nconst client = new WorkflowClient();\n\nawait client.signalWithStart(yourWorkflow, {\n  workflowId: 'workflow-id-123',\n  args: [{ foo: 1 }],\n  signal: joinSignal,\n  signalArgs: [{ userId: 'user-1', groupId: 'group-1' }],\n});\n```\n","is_empty":false},{"file_name":"how-to-send-logs-from-activities-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-send-logs-from-activities-in-typescript.md","id":450,"title":"How to send logs from Activities in TypeScript","description":"Send logs from Activities","label":"Send logs from Activities","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nActivities run in the standard Node.js environment and can use any Node.js logger.\n\n<details>\n<summary>\nInject Activity context via interceptor and log all Activity executions\n</summary>\n\n<!--SNIPSTART typescript-activity-logging-interceptor-->\n<!--SNIPEND-->\n\n</details>\n\n<details>\n<summary>\nUse the injected logger from an Activity\n</summary>\n\n<!--SNIPSTART typescript-activity-use-injected-logger -->\n<!--SNIPEND-->\n\n</details>\n","is_empty":false},{"file_name":"how-to-send-logs-in-workers-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-send-logs-in-workers-in-typescript.md","id":451,"title":"How to send logs from Workflows in TypeScript","description":"Send logs from Workflows","label":"Send logs from Workflows","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n**Logging in Workers and Clients**\n\nThe Worker comes with a default logger which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThere are 5 levels in total:\n\n- `TRACE`\n- `DEBUG`\n- `INFO`\n- `WARN`\n- `ERROR`\n\nThe reason we only offer a default logger is to minimize Worker dependencies and allow SDK users to bring their own logger.\n\n**Customizing the default logger**\n\nTemporal ships a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.defaultlogger/) that implements the basic interface.\n\n**Set Default logger level**\n\nThe following example creates a new logger that will log all messages with a level `WARN` and higher.\n\n```ts\nimport { Runtime, DefaultLogger } from '@temporalio/worker';\n\n// Creating a new logger that will log all messages with level WARN and higher.\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\nRuntime.install({ logger });\n```\n\n**Example: Accumulate logs for testing/reporting**\n\nThe following example creates a logger that will log all the messages to an array.\n\n```ts\nimport { DefaultLogger, LogEntry } from '@temporalio/worker';\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger('TRACE', (entry) => logs.push(entry));\nlog.debug('hey', { a: 1 });\nlog.info('ho');\nlog.warn('lets', { a: 1 });\nlog.error('go');\n```\n\nThe log levels are [listed here](https://typescript.temporal.io/api/namespaces/worker#loglevel) in increasing order of severity.\n","is_empty":false},{"file_name":"how-to-set-a-cron-job-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-a-cron-job-in-typescript.md","id":452,"title":"How to set a cron job in TypeScript","description":"Set a cron job","label":"Set a cron job","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nYou can set each Workflow to repeat on a schedule with the `cronSchedule` option:\n\n```typescript\nconst handle = await client.start(scheduledWorkflow, {\n  // ...\n  cronSchedule: '* * * * *', // start every minute\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-custom-logger-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-a-custom-logger-in-typescript.md","id":453,"title":"How to set a custom logger in TypeScript","description":"Set a custom logger","label":"Set a custom logger","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n**Logging in Workers and Clients**\n\nThe Worker comes with a default logger which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThe following [log levels](https://typescript.temporal.io/api/namespaces/worker#loglevel) are listed in increasing order of severity.\n\n**Customizing the default logger**\n\nTemporal uses a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.defaultlogger/) that implements the basic interface:\n\n```ts\nimport { Runtime, DefaultLogger } from '@temporalio/worker';\n\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\nRuntime.install({ logger });\n```\n\nThe previous code example sets the default logger to only log messages with level `WARN` and higher.\n\n**Accumulate logs for testing and reporting**\n\n```ts\nimport { DefaultLogger, LogEntry } from '@temporalio/worker';\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger('TRACE', (entry) => logs.push(entry));\nlog.debug('hey', { a: 1 });\nlog.info('ho');\nlog.warn('lets', { a: 1 });\nlog.error('go');\n```\n\nA common logging use case is logging to a file to be picked up by a collector like the [Datadog Agent](https://docs.datadoghq.com/logs/log_collection/nodejs/?tab=winston30).\n\n```ts\nimport { Runtime } from '@temporalio/worker';\nimport winston from 'winston';\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  transports: [new transports.File({ filename: '/path/to/worker.log' })],\n});\nRuntime.install({ logger });\n```\n","is_empty":false},{"file_name":"how-to-set-a-heartbeat-timeout-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-a-heartbeat-timeout-in-typescript.md","id":454,"title":"How to set a Heartbeat Timeout in TypeScript","description":"Set a Heartbeat Timeout","label":"Set a Heartbeat Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo set a Heartbeat Timeout, use [`ActivityOptions.heartbeatTimeout`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#heartbeattimeout). If the Activity takes longer than that between heartbeats, the Activity is failed.\n\n```typescript\n// Creating a proxy for the activity.\nconst { longRunningActivity } = proxyActivities<typeof activities>({\n  // translates to 300000 ms\n  scheduleToCloseTimeout: '5m',\n  // translates to 30000 ms\n  startToCloseTimeout: '30s',\n  // equivalent to '10 seconds'\n  heartbeatTimeout: 10000,\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-close-timeout-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-a-schedule-to-close-timeout-in-typescript.md","id":455,"title":"How to set a Schedule to Close Timeout in TypeScript","description":"Set a Schedule to Close Timeout","label":"Set a Schedule to Close Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault: ∞ (infinity – no limit)\n\nIn this example, you can set the `scheduleToCloseTimeout` to 5 m.\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: '5m',\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-schedule-to-start-timeout-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-a-schedule-to-start-timeout-in-typescript.md","id":456,"title":"How to set a Schedule to Start Timeout in TypeScript","description":"Set a Schedule to Start Timeout","label":"Set a Schedule to Start Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault: ∞ (infinity – no limit)\n\nIn this example, you can set the `scheduleToStartTimeout` to 60 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: '5m',\n  scheduleToStartTimeout: '60s',\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-start-to-close-timeout-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-a-start-to-close-timeout-in-typescript.md","id":457,"title":"How to set a Start to Close Timeout in TypeScript","description":"Set a Start to Close Timeout","label":"Set a Start to Close Timeout","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWhen you call `proxyActivities` in a Workflow Function, you can set a range of `ActivityOptions`.\n\nEither `scheduleToCloseTimeout` or `scheduleToStartTimeout` must be set.\n\nType: time.Duration\nDefault: ∞ (infinity – no limit)\n\nIn this example, you can set the `startToCloseTimeout` to 30 seconds.\n\n```typescript\n// Sample of typical options you can set\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '30s', // recommended\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-a-workflow-id-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-a-workflow-id-in-typescript.md","id":458,"title":"How to set a Workflow Id in TypeScript","description":"Set a Workflow Id","label":"Set a Workflow Id","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nConnect to a Client with `client.start()` and any arguments. Then specify your `taskQueue` and set your `workflowId` to a meaningful business identifier.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: 'yourWorkflowId',\n  taskQueue: 'yourTaskQueue',\n  args: ['your', 'arg', 'uments'],\n});\n```\n\nThis starts a new Client with the given Workflow Id, Task Queue name, and an argument.\n","is_empty":false},{"file_name":"how-to-set-a-workflow-task-queue-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-a-workflow-task-queue-in-typescript.md","id":459,"title":"How to set a Workflow Task Queue in TypeScript","description":"Set a Workflow Task Queue","label":"Set a Workflow Task Queue","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nA Task Queue is a dynamic queue in Temporal polled by one or more Workers.\n\nWorkers bundle Workflow code and node modules using Webpack v5 and execute them inside V8 isolates. Activities are directly required and run by Workers in the Node.js environment.\n\nWorkers are flexible. You can host any or all of your Workflows and Activities on a Worker, and you can host multiple Workers on a single machine.\n\nThere are three main things the Worker needs:\n\n- `taskQueue`: the Task Queue to poll. This is the only required argument.\n- `activities`: Optional. Imported and supplied directly to the Worker.\n- Workflow bundle, specify one of the following options:\n  - a `workflowsPath` to your `workflows.ts` file to pass to Webpack. For example, `require.resolve('./workflows')`. Workflows will be bundled with their dependencies.\n  - Or pass a prebuilt bundle to `workflowBundle`, if you prefer to handle the bundling yourself.\n\n```ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  // Step 1: Register Workflows and Activities with the Worker and connect to\n  // the Temporal server.\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    activities,\n    taskQueue: 'hello-world',\n  });\n  // Worker connects to localhost by default and uses console.error for logging.\n  // Customize the Worker by passing more options to create():\n  // https://typescript.temporal.io/api/classes/worker.Worker\n  // If you need to configure server connection parameters, see docs:\n  // /typescript/security#encryption-in-transit-with-mtls\n\n  // Step 2: Start accepting tasks on the `tutorial` queue\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n`taskQueue` is the only required option; however, use `workflowsPath` and `activities` to register Workflows and Activities with the Worker.\n\nWhen scheduling a Workflow, a `taskQueue` must be specified.\n\n```ts\nimport { Connection, WorkflowClient } from '@temporalio/client';\n// This is the code that is used to start a workflow.\nconst connection = await Connection.create();\nconst client = new WorkflowClient({ connection });\nconst result = await client.execute(yourWorkflow, {\n  // required\n  taskQueue: 'your-task-queue',\n  // required\n  workflowId: 'your-workflow-id',\n});\n```\n\nWhen creating a Worker, you must pass the `taskQueue` option to the `Worker.create()` function.\n\n```ts\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: 'your-task-queue',\n});\n```\n\nOptionally, in Workflow code, when calling an Activity, you can specify the Task Queue by passing the `taskQueue` option to `proxyActivities()`, `startChild()`, or `executeChild()`. If you do not specify a `taskQueue`, then the TypeScript SDK places Activity and Child Workflow Tasks in the same Task Queue as the Workflow Task Queue.\n","is_empty":false},{"file_name":"how-to-set-an-activity-retry-policy-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-an-activity-retry-policy-in-typescript.md","id":460,"title":"How to set an Activity Retry Policy in TypeScript","description":"Set an Activity Retry Policy","label":"Set an Activity Retry Policy","markdown_content":"\nTo set Activity Retry Policies in TypeScript, pass [`ActivityOptions.retry`](https://typescript.temporal.io/api/interfaces/common.ActivityOptions#retry) to [`proxyActivities`](https://typescript.temporal.io/api/namespaces/workflow/#proxyactivities).\n\n```typescript\n// Sample of typical options you can set\nconst { yourActivity } = proxyActivities<typeof activities>({\n  // ...\n  retry: {\n    // default retry policy if not specified\n    initialInterval: '1s',\n    backoffCoefficient: 2,\n    maximumAttempts: Infinity,\n    maximumInterval: 100 * initialInterval,\n    nonRetryableErrorTypes: [],\n  },\n});\n```\n","is_empty":false},{"file_name":"how-to-set-cluster-address-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-cluster-address-in-typescript.md","id":461,"title":"How to set a Cluster address in TypeScript","description":"Set Cluster address","label":"Set Cluster address","tags":["TypeScript","how-to"],"markdown_content":"\nUse the [`address`](https://typescript.temporal.io/api/interfaces/client.connectionoptions/#address) connection option from the [`Client`](https://typescript.temporal.io/api/namespaces/client).\n\n```typescript\nconst connection = await Connection.connect({\n  address: 'foo.bar.tmprl.cloud',\n  // ...\n});\n```\n","is_empty":false},{"file_name":"how-to-set-mtls-configuration-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-mtls-configuration-in-typescript.md","id":462,"title":"How to set mTLS configuration in TypeScript","description":"To set the mTLS configuration in TypeScript, use the `tls` connection option from the `Client` class to connect to a Temporal Client with mTLS.","label":"Set mTLS configuration","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo set the mTLS configuration in TypeScript, use the [`tls`](https://typescript.temporal.io/api/interfaces/client.connectionoptions/#tls) connection option from the [`Client`](https://typescript.temporal.io/api/namespaces/client) class to connect to a Temporal Client with mTLS.\n\n```typescript\nconst connection = await Connection.connect({\n  address: 'foo.bar.tmprl.cloud',\n  tls: {\n    clientCertPair: {\n      crt: clientCertPath,\n      key: clientKeyPath,\n    },\n  },\n});\nconst client = new WorkflowClient({ connection, namespace: 'foo.bar' });\n```\n\n[The Hello World mTLS sample](https://github.com/temporalio/samples-typescript/tree/main/hello-world-mtls/) demonstrates sample code used to connect to a Temporal Cloud account.\nWhen signing up to Temporal Cloud, you should receive a Namespace, a Server address, and a Client certificate and key. Use the following environment variables to set up the sample:\n\n- **TEMPORAL_ADDRESS**: looks like `foo.bar.tmprl.cloud` (NOT web.foo.bar.tmprl.cloud)\n- **TEMPORAL_NAMESPACE**: looks like `foo.bar`\n- **TEMPORAL_CLIENT_CERT_PATH**: `/tls/ca.pem` (file contents start with -----BEGIN CERTIFICATE-----)\n- **TEMPORAL_CLIENT_KEY_PATH**: `/tls/ca.key` (file contents start with -----BEGIN PRIVATE KEY-----)\n\nYou can leave the remaining variables, like `TEMPORAL_SERVER_NAME_OVERRIDE` and `TEMPORAL_SERVER_ROOT_CA_CERT_PATH`, blank.\nIf needed, you can customize `TEMPORAL_TASK_QUEUE`; the following example defaults to `hello-world-mtls`.\n\n```typescript\nexport function getEnv(): Env {\n  return {\n    // NOT web.foo.bar.tmprl.cloud\n    address: 'web.<Namespace_ID>.tmprl.cloud',\n    // as assigned\n    namespace: 'your.namespace',\n    // in project root\n    clientCertPath: 'foobar.pem',\n    clientKeyPath: 'foobar.key',\n    // just to ensure task queue is same on client and worker, totally optional\n    taskQueue: process.env.TEMPORAL_TASK_QUEUE || 'hello-world-mtls',\n    // not usually needed:\n    // serverNameOverride: process.env.TEMPORAL_SERVER_NAME_OVERRIDE,\n    // serverRootCACertificatePath: process.env.TEMPORAL_SERVER_ROOT_CA_CERT_PATH,\n  };\n}\n```\n\nIf you are using mTLS, it is completely up to you how to get the `clientCert` and `clientKey` pair into your code, whether it is reading from file system, secrets manager, or both. Just keep in mind that they are whitespace sensitive, and some environment variable systems have been known to cause frustration because they modify whitespace.\n\nThe following code example works for local development and for certifications hosted in an Amazon S3 bucket.\n\n```typescript\nlet serverRootCACertificate: Buffer | undefined;\nlet clientCertificate: Buffer | undefined;\nlet clientKey: Buffer | undefined;\nif (certificateS3Bucket) {\n  const s3 = new S3client({ region: certificateS3BucketRegion });\n  serverRootCACertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: serverRootCACertificatePath,\n  });\n  clientCertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientCertPath,\n  });\n  clientKey = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientKeyPath,\n  });\n} else {\n  serverRootCACertificate = fs.readFileSync(serverRootCACertificatePath);\n  clientCertificate = fs.readFileSync(clientCertPath);\n  clientKey = fs.readFileSync(clientKeyPath);\n}\n```\n","is_empty":false},{"file_name":"how-to-set-search-attributes-from-the-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-search-attributes-from-the-client-in-typescript.md","id":463,"title":"How to set Search Attributes from the Client in TypeScript","description":"Use Search Attributes from the Client","label":"Use Search Attributes from the Client","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWe can set [`WorkflowOptions.searchAttributes`](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions#searchattributes) during `client.start()` or `client.execute()` and read with [`handle.describe()`](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#describe):\n\n<!--SNIPSTART typescript-search-attributes-client -->\n<!--SNIPEND-->\n\nThe type of `searchAttributes` is `Record<string, string[] | number[] | boolean[] | Date[]>`.\n","is_empty":false},{"file_name":"how-to-set-search-attributes-in-a-workflow-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-search-attributes-in-a-workflow-in-typescript.md","id":464,"title":"How to set Search Attributes in a Workflow in TypeScript","description":"Use Search Attributes in a Workflow","label":"Use Search Attributes in a Workflow","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nInside a Workflow, we can read from [`WorkflowInfo.searchAttributes`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo#searchattributes) and call [`upsertSearchAttributes`](https://typescript.temporal.io/api/namespaces/workflow#upsertsearchattributes):\n\n<!--SNIPSTART typescript-search-attributes-workflow -->\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-set-the-default-logger-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-the-default-logger-in-typescript.md","id":465,"title":"How to set the default logger in TypeScript","description":"Set the default logger","label":"Set the default logger","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nSet the [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.DefaultLogger) to one of the following log levels: `'TRACE'` | `'DEBUG'` | `'INFO'` | `'WARN'` | `'ERROR'`.\n\nThe following is an example of setting the `DefaultLogger` to `'Debug'`.\n\n```typescript\nRuntime.install({\n  logger: new DefaultLogger('DEBUG'),\n  telemetryOptions: {\n    tracingFilter: 'temporal_sdk_core=DEBUG',\n    logging: { forward: { level: 'DEBUG' } },\n  },\n});\n```\n\nThe following code sets the `DefaultLogger` to `'Debug'` and creates a Worker that can execute Activities or Workflows.\n\n```typescript\nimport { Worker, Runtime, DefaultLogger } from '@temporalio/worker';\nimport * as activities from './activities';\nasync function main() {\n  const argv = arg({\n    '--debug': Boolean,\n  });\n  /* Setting the log level to DEBUG. */\n  if (argv['--debug']) {\n    Runtime.install({\n      logger: new DefaultLogger('DEBUG'),\n      telemetryOptions: {\n        tracingFilter: 'temporal_sdk_core=DEBUG',\n        logging: { forward: { level: 'DEBUG' } },\n      },\n    });\n  }\n  const worker = await Worker.create({\n    activities,\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'test',\n  });\n  await worker.run();\n  console.log('Worker gracefully shutdown');\n}\n```\n","is_empty":false},{"file_name":"how-to-set-the-namespace-for-a-temporal-client-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-set-the-namespace-for-a-temporal-client-in-typescript.md","id":466,"title":"How to set a Namespace for a Temporal Client in TypeScript","description":"Set the Namespace in Workflow Client Options Builder.","label":"Set Namespace","tags":["how-to","typescript"],"markdown_content":"\nSet the [`namespace`](https://typescript.temporal.io/api/namespaces/client/) field on the options object.\n\n```ts\nconst connection = await Connection.connect();\n// https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'your-custom-namespace',\n});\n```\n","is_empty":false},{"file_name":"how-to-spawn-a-workflow-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-spawn-a-workflow-execution-in-typescript.md","id":467,"title":"How to spawn a Workflow Execution in TypeScript","description":"Spawn a Workflow Execution","label":"Spawn a Workflow Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nWhen you have a Workflow Client, you can schedule the start of a Workflow with `client.start()`, specifying `workflowId`, `taskQueue`, and `args` and returning a Workflow handle immediately after the Server acknowledges the receipt.\n\n```typescript\nconst handle = await client.start(example, {\n  workflowId: 'your-workflow-id',\n  taskQueue: 'your-task-queue',\n  args: ['argument01', 'argument02', 'argument03'], // this is typechecked against workflowFn's args\n});\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\nCalling `client.start()` and `client.execute()` send a command to Temporal Server to schedule a new Workflow Execution on the specified Task Queue. It does not actually start until a Worker that has a matching Workflow Type, polling that Task Queue, picks it up.\n\nYou can test this by executing a Workflow Client command without a matching Worker. Temporal Server records the command in Event History, but does not make progress with the Workflow Execution until a Worker starts polling with a matching Task Queue and Workflow Definition.\n\nWorkflow Execution run in a separate V8 isolate context in order to provide a [deterministic runtime](/typescript/determinism).\n","is_empty":false},{"file_name":"how-to-spawn-an-activity-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-spawn-an-activity-execution-in-typescript.md","id":468,"title":"How to spawn an Activity Execution in TypeScript","description":"Spawn an Activity Execution","label":"Spawn an Activity Execution","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo spawn an Activity Execution, you must retrieve the _Activity handle_ in your Workflow.\n\n```typescript\nimport { proxyActivities } from '@temporalio/workflow';\n// Only import the activity types\nimport type * as activities from './activities';\n\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\n// A workflow that calls an activity\nexport async function example(name: string): Promise<string> {\n  return await greet(name);\n}\n```\n\nThis imports the individual Activities and declares the type alias for each Activity.\n","is_empty":false},{"file_name":"how-to-strucutre-a-project-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-strucutre-a-project-in-typescript.md","id":469,"title":"How to structure a project in TypeScript","description":"Structure a project","label":"Structure a project","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nA typical Temporal project written in TypeScript consists of the following components:\n\n```\nproject-root/\n  activities/\n      activity.ts\n  workflows/\n      workerflow.ts\n  workers/\n      worker.ts\n  starter-script.ts\n```\n\nActivities cannot be in the same file as Workflows and must be separately registered.\nActivities may be retried, so you may need to use [idempotency keys](https://stripe.com/blog/idempotency) for critical side effects.\n","is_empty":false},{"file_name":"how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-upsert-custom-search-attributes-to-a-workflow-executions-during-execution-in-typescript.md","id":470,"title":"How to upsert custom Search Attributes to Workflow during Execution","label":"How to upsert custom Search Attributes to Workflow during Execution","tags":["developer-guide","typescript"],"markdown_content":"\nInside a Workflow, we can read from [`WorkflowInfo.searchAttributes`](https://typescript.temporal.io/api/interfaces/workflow.WorkflowInfo#searchattributes) and call [`upsertSearchAttributes`](https://typescript.temporal.io/api/namespaces/workflow#upsertsearchattributes):\n\n<!--SNIPSTART typescript-search-attributes-workflow -->\n<!--SNIPEND-->\n","is_empty":false},{"file_name":"how-to-use-environment-variables-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-use-environment-variables-in-typescript.md","id":471,"title":"How to use environment variables in TypeScript","description":"Use Environment Variables","label":"Use Environment Variables","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n**Using in Activity code**\n\n```ts\nasync function runWorker(): Promise<void> {\n  const activities = createActivities({ apiKey: process.env.MAILGUN_API_KEY });\n\n  const worker = await Worker.create({\n    taskQueue: 'example',\n    activities,\n    workflowsPath: require.resolve('./workflows'),\n  });\n  await worker.run();\n}\n\nconst createActivities = (envVars: { apiKey: string }) => ({\n  async sendNotificationEmail(): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: 'post',\n      params: { to, from, subject, html },\n      auth: {\n        username: 'api',\n        password: envVars.apiKey,\n      },\n    });\n  },\n});\n```\n\n**Getting into Workflow**\n\nIf we needed environment variables in our Workflow, here's how we'd use a Local Activity:\n\n```ts\nconst worker = await Worker.create({\n  taskQueue: 'example',\n  activities: createActivities(process.env),\n  workflowsPath: require.resolve('./workflows'),\n});\n\ntype EnvVars = Record<string, string>;\n\nconst createActivities = (envVars: EnvVars) => ({\n  async getEnvVars(): Promise<EnvVars> {\n    return envVars;\n  },\n  async sendNotificationEmail(apiKey: string): Promise<void> {\n    // ...\n    await axios({\n      url: `https://api.mailgun.net/v3/your-domain/messages`,\n      method: 'post',\n      params: { to, from, subject, html },\n      auth: {\n        username: 'api',\n        password: apiKey,\n      },\n    });\n  },\n});\n```\n\n```ts\nconst { getEnvVars } = proxyLocalActivities({\n  startToCloseTimeout: '1m',\n});\n\nconst { sendNotificationEmail } = proxyActivities({\n  startToCloseTimeout: '1m',\n});\n\nasync function yourWorkflow() {\n  const envVars = await getEnvVars();\n  if (!envVars.apiKey) {\n    throw new Error('missing env var apiKey');\n  }\n  await sendNotificationEmail(envVars.apiKey);\n}\n```\n","is_empty":false},{"file_name":"how-to-use-signals-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/how-to-use-signals-in-typescript.md","id":472,"title":"How to use Signals in TypeScript","description":"Use Signals","label":"Use Signals","tags":["developer-guide","sdk","typescript"],"markdown_content":"\nTo add a Signal to a Workflow, call `defineSignal()` with a name, and then attach a listener with `setHandler()`.\n\n- Handlers to take arguments, which can be used inside `setHandler()` logic.\n- Signal handlers can mutate state, Signal handlers cannot return valeus.\n\n**Declare your Signal as constants outside the Workflow Definition**\n\n```typescript\nimport * as wf from '@temporalio/workflow';\n\nexport const unblockSignal = wf.defineSignal('unblock');\n let isBlocked = true;\n wf.setHandler(unblockSignal, () => void (isBlocked = false));\n console.log('Blocked');\n try {\n   await wf.condition(() => !isBlocked);\n   console.log('Unblocked');\n } catch (err) {\n   if (err instanceof wf.CancelledFailure) {\n     console.log('Cancelled');\n   }\n   throw err;\n }\n}\n```\n\nThis code defines a Signal as _unblock_ and declares the variable as _isBlocked_ as true. Then the code tries to execute the condition and print _Unblocked_ to the console if it becomes unblocked. Finally, the code catches any errors, and if the error is `CancelledFailure`, then it prints `Cancelled` to the console.\n\nThis helps provide type safety, since you can export the type signature of the Signal or Query to be called on the client side.\n\n##### Declare your Signals dynamically\n\nFor more flexible usecases, you may want a dynamic Signal, such as a generated identifier. You may handle it in two ways:\n\n- avoid making it dynamic by collapsing all signals in one handler and move the identifier to the payload.\n- actually make the Signal name dynamic by inlining the Signal definition per handler.\n\n```typescript\nimport * as wf from '@temporalio/workflow';\n\nwf.setHandler(`genericSignal`, (payload) => {\n  switch (payload.taskId) {\n    case taskAId:\n      // do task A things\n      break;\n    case taskBId:\n      // do task B things\n      break;\n    default:\n      throw new Error('Unexpected task.');\n  }\n});\n\n// \"inline definition\" solution\nwf.setHandler(wf.defineSignal(`task-${taskAId}`), (payload) => {\n  /* do task A things */\n});\nwf.setHandler(wf.defineSignal(`task-${taskBId}`), (payload) => {\n  /* do task B things */\n});\n\n// utility \"inline definition\" helper\nconst inlineSignal = (signalName, handler) =>\n  wf.setHandler(wf.defineSignal(signalName), handler);\ninlineSignal(`task-${taskBId}`, (payload) => {\n  /* do task B things */\n});\n```\n\n:::note\n\nThe semantics of `defineSignal()` and `defineQuery()` is intentional, in that they return Signal/Query Definitions, not unique instances of Signals and Queries themselves.\nSignals and Queries are only instantiated in `setHandler()` and are specific to a particular Workflow Execution.\n\nThese distinctions may seem minor, but they model how Temporal works under the hood, because Signals and Queries are messages identified by _just strings_ and don't have meaning independent of the Workflow having a listener to handle them.\n\nWe named it `setHandler` instead of `subscribe` because Signals and Queries can only have one handler at a time, whereas `subscribe` could imply an observable with multiple consumers, and is a higher level construct.\n:::\n\n#### Start a Signal from the Client\n\nSending Signals requires a Workflow handle from a Temporal Client.\n\n- You send a Signal with `handle.signal(signal, ...args)`. A Signal has no return value by definition.\n- You can refer to a Signal by string name, which is useful for dynamic reference, but you will lose type inference\n\nThe following code is from inside the Client code.\n\n```typescript\nimport { increment, count } from './workflow';\n\n// init client code omitted - see Client docs\nconst handle = client.getHandle(workflowId);\n\n// these three are equivalent\nawait handle.signal(increment, 1);\nawait handle.signal<[number]>('increment', 1);\nawait client.getHandle(workflowId).signal(increment, 1);\n```\n","is_empty":false},{"file_name":"index.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/index.md","id":473,"title":"How to use the Temporal TypeScript SDK","description":"Add the Temporal TypeScript SDK to your project.","label":"Temporal TypeScript SDK","tags":["developer-guide","sdk","typescript"],"markdown_content":"\n[![CI Status](https://img.shields.io/github/workflow/status/temporalio/sdk-typescript/Continuous%20Integration?style=for-the-badge)](https://www.npmjs.com/package/temporalio)\n[![NPM](https://img.shields.io/npm/v/temporalio.svg?style=for-the-badge)](https://www.npmjs.com/package/temporalio)\n\nTo download the latest version of the Temporal TypeScript Command, run the following command:\n\n```bash\nnpm i @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity\n```\n\nOr clone the TypeScript SDK repo to your preferred location:\n\n```bash\ngit clone git@github.com:temporalio/sdk-typescript.git\n```\n\nThis project requires Node.js 14 or later.\n\n:::note\nBoth TypeScript and JavaScript can be used with the TypeScript SDK.\n:::\n\n**Create a new project**\n\n```bash\nnpx @temporalio/create@latest ./your-app\n```\n\n**Add to an existing project**\n\n```bash\nnpm install @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity @temporalio/common\n```\n","is_empty":false},{"file_name":"interceptors.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/interceptors.md","id":474,"title":"Interceptors in TypeScript SDK","description":"Interceptors are a mechanism for users to modify inbound and outbound SDK calls. Interceptors are commonly used to add tracing and authorization to the scheduling and execution of Workflows and Activities. You can compare these to \"middleware\" in other frameworks.","label":"Interceptors","markdown_content":"\nInterceptors are a mechanism for users to modify inbound and outbound SDK calls.\nInterceptors are commonly used to add tracing and authorization to the scheduling and execution of Workflows and Activities.\nYou can compare these to \"middleware\" in other frameworks.\n\nThe TypeScript SDK comes with an optional interceptor package that adds tracing with [opentelemetry](https://www.npmjs.com/package/@temporalio/interceptors-opentelemetry). See how to use it in this [sample](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry).\n\n## Interceptor types\n\n- [WorkflowInboundCallsInterceptor](https://typescript.temporal.io/api/interfaces/workflow.workflowinboundcallsinterceptor/) - Intercept Workflow inbound calls like execution, signals, and queries.\n- [WorkflowOutboundCallsInterceptor](https://typescript.temporal.io/api/interfaces/workflow.workflowoutboundcallsinterceptor/) - Intercept Workflow outbound calls to Temporal APIs like scheduling Activities and starting Timers.\n- [ActivityInboundCallsInterceptor](https://typescript.temporal.io/api/interfaces/worker.activityinboundcallsinterceptor) - Intercept inbound calls to an Activity (for example, `execute`).\n- [WorkflowClientCallsInterceptor](https://typescript.temporal.io/api/interfaces/client.workflowclientcallsinterceptor/) - Intercept methods of [`WorkflowClient`](https://typescript.temporal.io/api/classes/client.workflowclient/) and [`WorkflowHandle`](https://typescript.temporal.io/api/interfaces/client.workflowhandle) like starting or signaling a Workflow.\n\n## How interceptors work\n\nInterceptors are run in a chain, all the interceptors work similarly, they accept 2 arguments: `input` and `next` where `next` calls the next interceptor in the chain.\nAll interceptor methods are optional—it's up to the implementor to choose which methods to intercept.\n\n## Interceptor examples\n\n<!--TODO use snipsync-->\n\n### Log start and completion of Activities\n\n```ts\nimport {\n  ActivityInput,\n  Next,\n  WorkflowOutboundCallsInterceptor,\n} from '@temporalio/workflow';\n\nexport class ActivityLogInterceptor\n  implements WorkflowOutboundCallsInterceptor\n{\n  constructor(public readonly workflowType: string) {}\n\n  async scheduleActivity(\n    input: ActivityInput,\n    next: Next<WorkflowOutboundCallsInterceptor, 'scheduleActivity'>\n  ): Promise<unknown> {\n    console.log('Starting activity', { activityType: input.activityType });\n    try {\n      return await next(input);\n    } finally {\n      console.log('Completed activity', {\n        workflow: this.workflowType,\n        activityType: input.activityType,\n      });\n    }\n  }\n}\n```\n\n### Authorization\n\n```ts\nimport {\n  defaultDataConverter,\n  Next,\n  WorkflowInboundCallsInterceptor,\n  WorkflowInput,\n} from '@temporalio/workflow';\n\n/**\n * WARNING: This demo is meant as a simple auth example.\n * Do not use this for actual authorization logic.\n * Auth headers should be encrypted and credentials\n * stored outside of the codebase\n */\nexport class DumbWorkflowAuthInterceptor\n  implements WorkflowInboundCallsInterceptor\n{\n  public async execute(\n    input: WorkflowInput,\n    next: Next<WorkflowInboundCallsInterceptor, 'execute'>\n  ): Promise<unknown> {\n    const authHeader = input.headers.auth;\n    const { user, password } = authHeader\n      ? await defaultDataConverter.fromPayload(authHeader)\n      : undefined;\n\n    if (!(user === 'admin' && password === 'admin')) {\n      throw new Error('Unauthorized');\n    }\n    return await next(input);\n  }\n}\n```\n\nTo properly do authorization from Workflow code, the Workflow would need to access encryption keys and possibly authenticate against an external user database, which requires the Workflow to break isolation.\nPlease contact us if you need to discuss this further.\n\n## Interceptor registration\n\n### Activity and client interceptors registration\n\n- Activity interceptors are registered on Worker creation by passing an array of [`ActivityInboundCallsInterceptor` factory functions](https://typescript.temporal.io/api/interfaces/worker.activityinboundcallsinterceptorfactory) through [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.workeroptions#interceptors).\n\n- Client interceptors are registered on `WorkflowClient` construction by passing an array of [`WorkflowClientCallsInterceptor` factory functions](https://typescript.temporal.io/api/interfaces/client.workflowclientcallsinterceptorfactory) via [WorkflowClientOptions](https://typescript.temporal.io/api/interfaces/client.workflowclientoptions#interceptors).\n\n### Workflow interceptors registration\n\nWorkflow interceptor registration is different from the other interceptors because they run in the Workflow isolate. To register Workflow interceptors, export an `interceptors` function from a file located in the `workflows` directory and provide the name of that file to the Worker on creation via [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.workeroptions#interceptors).\n\nAt the time of construction, the Workflow Context is already initialized for the current Workflow.\nUse [`workflowInfo`](https://typescript.temporal.io/api/namespaces/workflow#workflowinfo) to add Workflow specific information in the interceptor.\n\n`src/workflows/your-interceptors.ts`\n\n```ts\nimport { workflowInfo } from '@temporalio/workflow';\n\nexport const interceptors = () => ({\n  outbound: [new ActivityLogInterceptor(workflowInfo().workflowType)],\n  inbound: [],\n});\n```\n\n`src/worker/index.ts`\n\n```ts\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  interceptors: {\n    workflowModules: [require.resolve('./workflows/your-interceptors')],\n  },\n});\n```\n","is_empty":false},{"file_name":"introduction.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/introduction.md","id":475,"title":"TypeScript SDK introduction","description":"The TypeScript SDK lets developers write highly scalable, reliable, annd long-running workflows without being a distributed systems expert.","label":"Introduction","markdown_content":"\nThe Temporal TypeScript SDK lets you write highly scalable and reliable long-running Workflows without being a distributed systems expert.\nIt is designed with TypeScript-first developer experience in mind, but works equally well with JavaScript.\n\n[Introduction to Temporal](https://youtu.be/2HjnQlnA5eY)\n\nYou can view:\n\n- [Code samples on GitHub](https://github.com/temporalio/samples-typescript)\n  - Fastest way to try these out is in the browser [![Gitpod ready-to-code](https://img.shields.io/badge/Gitpod-ready--to--code-908a85?logo=gitpod)](https://gitpod.io/#https://github.com/temporalio/samples-typescript/) ([90 second demo](https://youtu.be/FdEQQC9EdfU))\n- [Searchable full API reference](https://typescript.temporal.io)\n- [SDK source on GitHub](https://github.com/temporalio/sdk-typescript) [![GitHub stars](https://img.shields.io/github/stars/temporalio/sdk-typescript)](https://github.com/temporalio/sdk-typescript/stargazers) (give us a star!)\n- [See version diffs on our Changelog](https://github.com/temporalio/sdk-typescript/blob/HEAD/CHANGELOG.md)\n\n## Getting started\n\nChoose your own adventure:\n\n<details>\n<summary>\nRun \"Hello Temporal\" in the cloud (~2 minutes)\n</summary>\n\n[Open our Samples repo in Gitpod](https://gitpod.io/#https://github.com/temporalio/samples-typescript/) and login to try out our Hello World example with no need for local Docker setup.\n\nWhen you click on that link above and log in (there is a generous free tier), Gitpod will launch 4 terminals:\n\n- Pane 1: Temporal Cluster\n  - Left: [Temporal Server](https://github.com/temporalio/docker-compose) - always running\n  - Right: [Temporal Web](/web-ui) and [Temporal `tctl` CLI](/tctl)\n- Pane 2: Hello World\n  - Left: [Temporal Worker](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/worker.ts) - running and hot reloading\n  - Right: [Temporal Client](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/client.ts) - run `npm run workflow`\n\nIt takes ~3 minutes for the Docker Compose setup to start up.\nOnce you have it up and running (Temporal Web should show the first Workflow Execution), you can use our [Hello World Walkthrough](https://learn.temporal.io/getting_started/typescript/hello_world_in_typescript/) tutorial to orient you to the sample file structure.\n\n</details>\n\n<details>\n<summary>\nRun \"Hello Temporal\" locally (~10 minutes)\n</summary>\n\n:::note Prerequisites\n\n<strong>Node.js 14+</strong>: this project requires Node.js version 14 or later.\n\n<details>\n<summary>\n<strong>Temporal Server</strong>: make sure it is running locally!\n</summary>\n\nRun Temporal Server (requires [Docker](https://docs.docker.com/engine/install) and [Docker Compose](https://docs.docker.com/compose/install/)):\n\n```bash\ngit clone https://github.com/temporalio/docker-compose.git temporal\ncd temporal\ndocker-compose up\n```\n\nIf you want to run Temporal without Docker, DataDog has created an experimental project called [temporalite](https://github.com/DataDog/temporalite) you can try.\n\n</details>\n\n:::\n\n### Step 1: Create a new project\n\nUse the [package initializer](/typescript/package-initializer) to create a new project:\n\n```bash\nnpx @temporalio/create@latest ./example\ncd example\n```\n\nThis will set up with [the basic Hello World sample](https://github.com/temporalio/samples-typescript/tree/main/hello-world) using our [Package Initializer](/typescript/package-initializer) (think of it like `create-temporal-app`!)\n\n### Step 2: Run your Workflow\n\nRun the Worker:\n\n```bash\n# this runs ts-node src/worker.ts with nodemon to auto-reload on changes\n$ npm run start.watch\n```\n\n<details>\n<summary>Expected Terminal Output</summary>\n\n```bash\n# this runs ts-node src/worker.ts with nodemon to auto-reload on changes\n$ npm run start.watch\n\n> temporal-hello-world@0.1.0 start.watch\n> nodemon src/worker.ts\n\n[nodemon] 2.0.13\n[nodemon] to restart at any time, enter `rs`\n[nodemon] watching path(s): src/**/*\n[nodemon] watching extensions: ts\n[nodemon] starting `ts-node src/worker.ts`\n2022-06-17T23:47:12.854Z [INFO] asset main.js 352 KiB [emitted] (name: main) 1 related asset\n2022-06-17T23:47:12.855Z [INFO] runtime modules 2.03 KiB 5 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./packages/test/lib/workflows/*.js 91.7 KiB 95 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./packages/workflow/lib/*.js 90.9 KiB\n2022-06-17T23:47:12.855Z [INFO]   ./packages/workflow/lib/worker-interface.js 11.2 KiB [built] [code generated]\n2022-06-17T23:47:12.855Z [INFO]   + 10 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./packages/common/lib/ 46.9 KiB\n2022-06-17T23:47:12.855Z [INFO]   modules by path ./packages/common/lib/converter/*.js 27 KiB 8 modules\n2022-06-17T23:47:12.855Z [INFO]   modules by path ./packages/common/lib/*.js 19.9 KiB 2 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./packages/internal-workflow-common/lib/*.js 13.5 KiB\n2022-06-17T23:47:12.855Z [INFO]   ./packages/internal-workflow-common/lib/index.js 1.3 KiB [built] [code generated]\n2022-06-17T23:47:12.855Z [INFO]   + 9 modules\n2022-06-17T23:47:12.855Z [INFO] modules by path ./node_modules/ 43.5 KiB\n2022-06-17T23:47:12.855Z [INFO]   modules by path ./node_modules/ramda/src/ 1.42 KiB 3 modules\n2022-06-17T23:47:12.855Z [INFO]   + 2 modules\n2022-06-17T23:47:12.855Z [INFO] __temporal_custom_payload_converter (ignored) 15 bytes [built] [code generated]\n2022-06-17T23:47:12.855Z [INFO] webpack 5.72.0 compiled successfully in 351 ms\n2022-06-17T23:47:12.857Z [INFO] Workflow bundle created { size: '0.34MB' }\n2022-06-17T23:47:12.987Z [INFO] Worker state changed { state: 'RUNNING' }\n```\n\n</details>\n\n> If this step fails, make sure you have the correct version of Node and other prerequisites listed above.\n\nThen start your Workflow:\n\n```bash\n$ npm run workflow # runs ts-node src/client.ts\nHello, Temporal! # success!\n```\n\nThis \"Hello, Temporal!\" message comes from the combination of:\n\n- [`client.ts`](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/client.ts) passing `'Temporal'` as an argument to the Workflow.\n- The [Workflow](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/workflows.ts) passing the argument to the Activity.\n- The [Activity](https://github.com/temporalio/samples-typescript/blob/main/hello-world/src/activities.ts) taking the argument as `name` and returning `Hello, ${name}!`.\n\n<details>\n<summary>Viewing your Workflow Execution in Temporal Web\n</summary>\n\nYou can verify execution in Temporal Web (available at [`localhost:8080](http://localhost:8080/) on the default [`docker-compose`](https://github.com/temporalio/docker-compose)):\n\n![image](https://user-images.githubusercontent.com/6764957/118865735-d7255f80-b913-11eb-8ace-a7dbdc351f8e.png)\n\n</details>\n\n## Next Steps\n\nFor a full code walkthrough of our Hello World example, see our [Hello World documentation](https://learn.temporal.io/getting_started/typescript/hello_world_in_typescript/).\n\nIf you want an example of what it's like to integrate Temporal into an existing full-stack app, check our [Next.js One-Click Buy Tutorial](/typescript/nextjs-tutorial).\n\n</details>\n\n<details>\n<summary>Read through the core API docs (~20 minutes)\n</summary>\n\nThese are the essential pages to have a passing knowledge of our Core APIs:\n\n- [Workflows](/typescript/workflows): How to write Temporal's core orchestration code\n  - Workflows use [Activities](/typescript/activities) to act on the outside world (e.g. call an API with retries and timeouts, or access the filesystem)\n  - see [Workflow APIs](/typescript/workflows) for Signals, Queries, Timers, Child Workflows, Infinite Workflows, and more!\n- [Workers and Task Queues](/typescript/workers): How Workflows and Activities are routed to and executed on machines you control\n- [Clients](/typescript/clients): How to start, signal, query, cancel, or otherwise handle Workflows.\n\n</details>\n\n## Getting Help\n\nFor quick questions, we are always available on [the Temporal Slack](https://temporal.io/slack).\n\nFor long form/FAQs, please search and ask on [the Temporal community forum](https://community.temporal.io/) instead.\n\n## TS SDK Intro Workshop\n\nWe held a 2-hour introduction workshop explaining every core concept from scratch: [https://www.youtube.com/watch?v=CeHSmv8oF_4][https://www.youtube.com/watch?v=cehsmv8of_4]\n\nTimestamps:\n\n- [00:00:00](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=0s) Part 1: TS SDK Intro\n- [00:12:15](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=735s) Part 2: Your First Workflow\n- [00:16:42](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=1002s) Part 3: Workflows vs Activities\n- [00:23:52](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=1432s) Live Code Demo\n- [00:36:00](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=2160s) Part 4: Timeouts and Retries\n- [00:57:00](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=3420s) Part 5: Workflow APIs\n- [01:24:00](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=5040s) Signals and Queries\n- [01:29:40](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=5380s) Fullstack Next.js App\n- [01:41:50](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=6110s) Part 6: Workers and Task Queues\n- [01:45:19](https://www.youtube.com/watch?v=CeHSmv8oF_4&t=6319s) Recap and Q&A\n\nAnd of course you can [join the #typescript-sdk channel](https://temporal.io/slack) to ask any questions as you get set up.\nDesign partners are already [putting us in production](https://youtu.be/GpbOkDjpeYU), and we are eager to hear your feedback.\n","is_empty":false},{"file_name":"logging.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/logging.md","id":476,"title":"Logging and Sinks in TypeScript SDK","description":"Workflow Sinks allow you to export information from the Workflow back to the Node.js environment, often used for logging, metrics, tracing.","label":"Logging & Sinks","markdown_content":"\n:::note Sample available\n\nA complete sample for setting up the instrumentation for the different components of the SDK is available on our [samples repo](https://github.com/temporalio/samples-typescript/tree/main/instrumentation).\n:::\n\n## Logging from Activities\n\nActivities run in the standard Node.js environment and can use any Node.js logger.\n\n<details>\n<summary>\nInject Activity context via interceptor and log all Activity executions\n</summary>\n\n<!--SNIPSTART typescript-activity-logging-interceptor-->\n<!--SNIPEND-->\n\n</details>\n\n<details>\n<summary>\nUse the injected logger from an Activity\n</summary>\n\n<!--SNIPSTART typescript-activity-use-injected-logger -->\n<!--SNIPEND-->\n\n</details>\n\n## Logging from Workflows with Workflow Sinks\n\nLogging from Workflows is tricky for two reasons:\n\n1. Workflows run in a sandboxed environment and cannot do any I/O.\n1. Workflow code might get replayed at any time, generating duplicate log messages.\n\nTo work around these limitations, we recommend using the Sinks feature in the TypeScript SDK.\nSinks enable one-way export of logs, metrics, and traces from the Workflow isolate to the Node.js environment.\n\n<!--\nWorkflows in Temporal may be replayed from the beginning of their history when resumed. In order for Temporal to recreate the exact state Workflow code was in, the code is required to be fully deterministic. To prevent breaking [determinism](/typescript/determinism), in the TypeScript SDK, Workflow code runs in an isolated execution environment and may not use any of the Node.js APIs or communicate directly with the outside world. -->\n\nSinks are written as objects with methods. Similar to Activities, they are declared in the Worker and then proxied in Workflow code, and it helps to share types between both.\n\n<details>\n  <summary>Comparing Sinks, Activities and Interceptors</summary>\n  \nSinks are similar to Activities in that they are both registered on the Worker and proxied into the Workflow.\nHowever, they differ from Activities in important ways:\n\n- Sink functions don't return any value back to the Workflow and cannot not be awaited.\n- Sink calls are not recorded in Workflow histories (no timeouts or retries).\n- Sink functions are _always_ run on the same Worker that runs the Workflow they are called from.\n\n</details>\n\n### Declaring the Sink Interface\n\nExplicitly declaring a Sink's interface is optional, but is useful for ensuring type safety in subsequent steps:\n\n<!--SNIPSTART typescript-logger-sink-interface-->\n<!--SNIPEND-->\n\n### Implementing Sinks\n\nImplementing Sinks is a two-step process.\n\n#### Implement and inject the Sink function into a Worker\n\n<!--SNIPSTART typescript-logger-sink-worker-->\n<!--SNIPEND-->\n\n- Sink function implementations are passed as an object into [WorkerOptions](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#sinks)\n- You can specify whether you want the injected function to be called during Workflow replay by setting the `callDuringReplay` boolean option.\n\n#### Proxy and call a Sink function from a Workflow\n\n<!--SNIPSTART typescript-logger-sink-workflow-->\n<!--SNIPEND-->\n\nSome important features of the [InjectedSinkFunction](https://typescript.temporal.io/api/interfaces/worker.InjectedSinkFunction) interface:\n\n- **Injected WorkflowInfo argument**: The first argument of a Sink function implementation is a [`workflowInfo` object](https://typescript.temporal.io/api/interfaces/workflow.workflowinfo/) that contains useful metadata.\n- **Limited arguments types**: The remaining Sink function arguments are copied between the sandbox and the Node.js environment using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n- **No return value**: To prevent breaking determinism, Sink functions cannot return values to the Workflow.\n\n#### Advanced: Performance considerations and non-blocking Sinks\n\nThe injected sink function contributes to the overall Workflow Task processing duration.\n\n- If you have a long-running sink function, such as one that tries to communicate with external services, you might start seeing Workflow Task timeouts.\n- The effect is multiplied when using `callDuringReplay: true` and replaying long Workflow histories because the Workflow Task timer starts when the first history page is delivered to the Worker.\n\n## Logging in Workers and Clients\n\nThe Worker comes with a default logger which defaults to log any messages with level `INFO` and higher to `STDERR` using `console.error`.\nThere are 5 levels in total: `TRACE`, `DEBUG`, `INFO`, `WARN`, and `ERROR`.\n\nThe reason we only offer a default logger is to minimize Worker dependencies and allow SDK users to bring their own logger.\n\n### Customizing the default logger\n\nTemporal ships a [`DefaultLogger`](https://typescript.temporal.io/api/classes/worker.defaultlogger/) that implements the basic interface:\n\n#### Example: Set up the DefaultLogger to only log messages with level WARN and higher\n\n```ts\nimport { Runtime, DefaultLogger } from '@temporalio/worker';\n\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\nRuntime.install({ logger });\n```\n\n#### Example: Accumulate logs for testing/reporting\n\n```ts\nimport { DefaultLogger, LogEntry } from '@temporalio/worker';\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger('TRACE', (entry) => logs.push(entry));\nlog.debug('hey', { a: 1 });\nlog.info('ho');\nlog.warn('lets', { a: 1 });\nlog.error('go');\n```\n\nThe log levels are [listed here](https://typescript.temporal.io/api/namespaces/worker#loglevel) in increasing order of severity.\n\n### Using a custom logger\n\nA common logging use case is logging to a file to be picked up by a collector like the [Datadog Agent](https://docs.datadoghq.com/logs/log_collection/nodejs/?tab=winston30).\n\n```ts\nimport { Runtime } from '@temporalio/worker';\nimport winston from 'winston';\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  transports: [new transports.File({ filename: '/path/to/worker.log' })],\n});\nRuntime.install({ logger });\n```\n\n## Metrics\n\nFor information about metrics, see the [Metrics section on the Deploy Checklist](/typescript/production-deploy#metrics) page.\n\n## OpenTelemetry tracing\n\nThe [`interceptors-opentelemetry`](https://github.com/temporalio/samples-typescript/tree/main/interceptors-opentelemetry) sample shows how to use the SDK's built-in OpenTelemetry tracing to trace everything from starting a Workflow to Workflow Execution to running an Activity from that Workflow.\n\nThe built-in tracing uses protobuf message headers (like [this one](https://github.com/temporalio/api/blob/b2b8ae6592a8730dd5be6d90569d1aea84e1712f/temporal/api/workflowservice/v1/request_response.proto#L161) when starting a Workflow) to propagate the tracing information from the client to the Workflow and from the Workflow to its successors (when Continued As New), children, and Activities.\nAll of these executions are linked with a single trace identifier and have the proper parent->child span relation.\n\nTracing is compatible between different Temporal SDKs as long as compatible [context propagators](https://opentelemetry.lightstep.com/core-concepts/context-propagation/) are used.\n\n### Context propagation\n\nThe TypeScript SDK uses the global OpenTelemetry propagator.\n\nTo extend the default ([Trace Context](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#w3ctracecontextpropagator-propagator) and [Baggage](https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-core/README.md#baggage-propagator) propagators) to also include the [Jaeger propagator](https://www.npmjs.com/package/@opentelemetry/propagator-jaeger), follow these steps:\n\n- `npm i @opentelemetry/propagator-jaeger`\n\n- At the top level of your Workflow code, add the following lines:\n\n  ```js\n  import { propagation } from '@opentelemetry/api';\n  import {\n    CompositePropagator,\n    W3CTraceContextPropagator,\n    W3CBaggagePropagator,\n  } from '@opentelemetry/core';\n  import { JaegerPropagator } from '@opentelemetry/propagator-jaeger';\n\n  propagation.setGlobalPropagator(\n    new CompositePropagator({\n      propagators: [\n        new W3CTraceContextPropagator(),\n        new W3CBaggagePropagator(),\n        new JaegerPropagator(),\n      ],\n    })\n  );\n  ```\n\nSimilarly, you can customize the OpenTelemetry `NodeSDK` propagators by following the instructions in the [Initialize the SDK](https://github.com/open-telemetry/opentelemetry-js/tree/main/experimental/packages/opentelemetry-sdk-node#initialize-the-sdk) section of the README.\n","is_empty":false},{"file_name":"nextjs.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/nextjs.md","id":477,"title":"Integrating Temporal into an Existing Next.js Application","description":"In this tutorial, we'll talk about how Temporal integrates into an existing Next.js application using Next.js API routes. This gives you the ability to write full-stack, long-running applications end to end in TypeScript.","label":"Next.js Tutorial","markdown_content":"\nIn this tutorial, we'll talk about how Temporal integrates into an **existing Next.js application** using Next.js API routes.\nThis gives you the ability to write full-stack, long-running applications end to end in TypeScript.\n\n:::info Notes to user\n\nThis tutorial is written for a reasonably experienced TypeScript/Next.js developer.\nWhether you are using [Gatsby Functions](https://www.gatsbyjs.com/docs/reference/functions/), [Blitz.js API Routes](https://blitzjs.com/docs/api-routes) or just have a standard Express.js app, you should be able to adapt this tutorial with only minor modifications.\nIf you run into trouble, you are welcome to reach out on the [Temporal Slack](https://temporal.io/slack) for help, but we cannot promise help with non-Temporal build tooling related questions.\n\n**To skip straight to a fully working example, you can check our [samples-typescript repo](https://github.com/temporalio/samples-typescript/tree/main/nextjs-ecommerce-oneclick)**, which you can also clone from scratch with [package initializer](/typescript/package-initializer) skeleton:\n\n```bash\nnpx @temporalio/create@latest nextjs-temporal-app --sample nextjs-ecommerce-oneclick\n```\n\n- We go through the setup assuming you want to use TypeScript.\n  You should be able to skip some steps if you want to use vanilla JavaScript.\n- We also assume that you have [Temporal's prerequisites](/typescript/introduction#getting-started) already set up.\n- Temporal doesn't prescribe folder structure; feel free to ignore or modify these instructions per your own needs.\n\n:::\n\n## Add Temporal to your Next.js project\n\nYou can install Temporal's packages with a single dependency, then set up folders and files for your Workflow, Activity, and Worker code:\n\n```bash\nnpm i @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity # in Next.js project root\nmkdir -p temporal/src # create folder, recursively\ncd temporal\ntouch src/worker.ts src/workflows.ts src/activities.ts\n```\n\n<details>\n<summary>\n\nConfigure TypeScript to compile from `temporal/src` to `temporal/lib` with a `tsconfig.json`.\n\n</summary>\n\nSample `tsconfig.json` to get you started:\n\n```js\n// /temporal/tsconfig.json\n{\n  \"extends\": \"@tsconfig/node16/tsconfig.json\", // optional but nice to have\n  \"version\": \"4.4.2\",\n  \"compilerOptions\": {\n    \"emitDecoratorMetadata\": false,\n    \"experimentalDecorators\": false,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"composite\": true,\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./lib\"\n  },\n  \"include\": [\"src/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n</details>\n\n<details>\n<summary>\n\nFor convenience, you may want to set up some npm scripts to run the builds in your project root `package.json`.\n\n</summary>\n\n```js\n// /package.json\n  \"scripts\": {\n    \"dev\": \"npm-run-all -l build:temporal --parallel dev:temporal dev:next start:worker\",\n    \"dev:next\": \"next dev\",\n    \"dev:temporal\": \"tsc --build --watch ./temporal/tsconfig.json\",\n    \"build:next\": \"next build\",\n    \"build:temporal\": \"tsc --build ./temporal/tsconfig.json\",\n    \"start\": \"npm run dev\",\n    \"start:worker\": \"nodemon ./temporal/lib/worker\",\n    \"lint\": \"eslint .\"\n  },\n```\n\nIn the above example we use `npm-run-all` and `nodemon` so that we are able to do 4 things:\n\n- build Temporal once\n- start Next.js locally\n- start a Temporal Worker\n- rebuild Temporal files on change\n\nin a single `npm run dev` command.\n\n</details>\n\n## Write your first Workflow, Activity and Worker\n\nInside of `/temporal/src/activities.ts` we'll write a simple Activity function to start with:\n\n```ts\n// /temporal/src/activities.ts\nimport { Context } from '@temporalio/activity';\n\nexport async function purchase(id: string): Promise<string> {\n  console.log(`Purchased ${id}!`);\n  return Context.current().info.activityId;\n}\n```\n\nActivities are the only way to interact with the outside world in Temporal (e.g. making API requests, or accessing the filesystem).\nSee the [Activities docs](/typescript/activities) for more info.\n\nInside of `/temporal/src/workflows.ts` we'll write a Workflow function that calls this Activity:\n\n```ts\n// /temporal/src/workflows.ts\nimport { proxyActivities, sleep } from '@temporalio/workflow';\nimport type * as activities from './activities'; // purely for type safety\n\nconst { purchase } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\nexport async function OneClickBuy(id: string): Promise<string> {\n  const result = await purchase(id); // calling the activity\n  await sleep('10 seconds'); // demo use of timer\n  console.log(`Activity ID: ${result} executed!`);\n}\n```\n\nWorkflow code is bundled and run inside a [deterministic v8 isolate](/typescript/determinism) so we can persist and replay every state change.\nThis is why Workflow code must be separate from Activity code, and why we have to `proxyActivities` instead of directly importing them.\nWorkflows also have access to a special set of [Workflow APIs](/typescript/workflows#workflow-apis) which we recommend exploring next.\n\nWith your Workflows and Activities done, you can now write the Worker that will host both and poll the `tutorial` Task Queue:\n\n```ts\n// /temporal/src/worker.ts\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nrun().catch((err) => console.log(err));\n\nasync function run() {\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'), // passed to Webpack for bundling\n    activities, // directly imported in Node.js\n    taskQueue: 'tutorial',\n  });\n  await worker.run();\n}\n```\n\nSee the full [Worker docs](/typescript/workers) for more info.\nYou should now be able to run your Worker with `npm run build:temporal && npm run start:worker`, but it's not very exciting because you have no way to start a Workflow yet.\n\n:::tip Pro tip\n\nYou actually _can_ start a Workflow with [`tctl`](/tctl/workflow/start) with just a Worker running, and no Client code written!\nIt is out of scope for this tutorial but try to `brew install tctl` and then `tctl workflow run --tq tutorial --wt OneClickBuy --et 60 -i '\"Temporal CLI\"'` if you enjoy developing with CLIs.\n\n:::\n\n## Write a Temporal Client inside a Next.js API Route\n\nWe will use Next.js API routes to expose a serverless endpoint that can be called by our frontend and then communicate with Temporal on the backend:\n\n```bash\n# in Next.js project root\nmkdir pages/api\ntouch pages/api/startBuy.ts\n```\n\nNow we will create a Client and start a Workflow Execution:\n\n```ts\n// pages/api/startBuy.ts\nimport { Connection, WorkflowClient } from '@temporalio/client';\nimport { OneClickBuy } from '../../temporal/lib/workflows.js';\n\nexport default async function startBuy(req, res) {\n  const { itemId } = req.body; // TODO: validate itemId and req.method\n  const client = new WorkflowClient();\n  const handle = await client.start(OneClickBuy, {\n    workflowId: 'business-meaningful-id',\n    // must match the taskQueue polled by Worker above\n    taskQueue: 'tutorial',\n    args: [itemId],\n    // workflowId: // TODO: use business-meaningful user/transaction ID here\n  }); // kick off the purchase async\n\n  res.status(200).json({ workflowId: handle.workflowId });\n}\n```\n\nNow if you have Next.js and Temporal running, you can at least start a Workflow Execution:\n\n```bash\nnpm run dev # start Temporal and Next.js in parallel\ncurl -d '{\"itemId\":\"item123\"}' -H \"Content-Type: application/json\" -X POST http://localhost:3000/api/startBuy\n```\n\nThe terminal that has your Temporal Worker will print `Purchased item123` if everything is working properly.\n\n## Call the API Route from the Next.js frontend\n\nIf you are an experienced React/Next.js dev you should know what to do here.\nFor tutorial purposes we will just assume you have an `itemId` to use here; in real life you are likely to pull this from some other data source like Shopify or a database.\n\n```ts\n// /pages/index.ts or whatever page you are on\n// inside event handler\nfetch('/api/startBuy', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ itemId }),\n});\n```\n\nWe recommend tracking the state of this API call and possibly toasting success, [per our sample code](https://github.com/temporalio/samples-typescript/blob/1f76cb6f78ef494074b937268c14fcc078e36956/nextjs-ecommerce-oneclick/pages/index.tsx#L143), but of course it is up to you what UX you want to provide.\n\n## Deploying your Temporal + Next.js app\n\nYour Next.js app, including Next.js API Routes with Temporal Clients in them, can be deployed anywhere Next.js can be deployed, including in serverless environments like Vercel or Netlify.\n\n:::important\n\nHowever, your Temporal Workers **must** be deployed in traditional \"serverful\" environments (e.g. with EC2, Digital Ocean or Render, not a serverless environment).\n\n:::\n\n**Both Temporal Clients and Temporal Workers must be configured to communicate with a Temporal Server instance**, whether self-hosted or Temporal Cloud.\nYou will need to configure gRPC connection address, namespace, and mTLS cert and key (strongly recommended).\n\n```ts\n// before Worker.create call in worker.ts\nconst connection = await NativeConnection.connect({\n  address,\n  tls: {\n    serverNameOverride,\n    serverRootCACertificate,\n    clientCertPair: {\n      crt: fs.readFileSync(clientCertPath),\n      key: fs.readFileSync(clientKeyPath),\n    },\n  },\n});\n\n// inside each Client call inside API Route\nconst connection = await Connection.connect({\n  address,\n  tls: {\n    serverNameOverride,\n    serverRootCACertificate,\n    clientCertPair: {\n      crt: fs.readFileSync(clientCertPath),\n      key: fs.readFileSync(clientKeyPath),\n    },\n  },\n});\n```\n\n[See the mTLS tutorial](/typescript/security#mtls-tutorial) for full details, or get in touch with us on Slack if you have reached this stage.\n\n## Production Concerns\n\nAs you move into production with your app, please review our docs on:\n\n- [Securing](/typescript/security)\n- [Testing](/typescript/testing)\n- [Patching](/typescript/patching) (aka migrating code to new versions)\n- [Logging](/typescript/logging)\n- [Production Deploy Checklist](/typescript/production-deploy)\n\nYou will also want to have a plan for **monitoring and scaling your Temporal Workers** that host and execute your Activity and Workflow code (separately from monitoring and scaling Temporal Server itself).\n\n## Next Steps\n\nAt this point, you have a working full stack example of a Temporal Workflow running inside your Next.js app.\n\nYou can explore adding [Signals and Queries](/typescript/workflows/#signals-and-queries) to your Workflow, then adding a new API Route to call them.\nYou can choose to set up one API Route per Signal or Query, or have one API Route handle all of them, Temporal has no opinion on how you set up routing.\n\nAgain, for a fully working example, you can check our [samples-typescript repo](https://github.com/temporalio/samples-typescript/tree/main/nextjs-ecommerce-oneclick).\n","is_empty":false},{"file_name":"package-initializer.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/package-initializer.md","id":478,"title":"@temporalio/create Package Initializer","description":"temporalio/create is an optional tool to set up a new Temporal project starting from our samples repo. `npx @temporalio/create@latest ./example`","label":"@temporalio/create","markdown_content":"\n> **@temporalio/create** [![NPM](https://img.shields.io/npm/v/@temporalio/create)](https://www.npmjs.com/package/@temporalio/create) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/create-project)\n\n`@temporalio/create` is an optional tool to set up a new Temporal project starting from [our samples repo](https://github.com/temporalio/samples-typescript).\n\n### Usage\n\n> See the [Getting started](/typescript/introduction/#getting-started) guide for basic usage and environment set up before running this tool.\n\n```bash\nnpx @temporalio/create@latest ./example\n```\n\n#### Optional flags\n\n- `--sample` — Which sample to bootstrap the app with. You can use the name of a sample\n  from [github.com/temporalio/samples-typescript](https://github.com/temporalio/samples-typescript) or use a GitHub URL. The URL can have a branch and/or subdirectory: for example, `https://github.com/your-org/your-app/tree/main/foo/bar`.\n- `--list-samples` — List available projects from [our samples repo](https://github.com/temporalio/samples-typescript).\n- `--use-yarn` — Use Yarn instead of npm.\n- `--[no-]git-init` - Initialize an empty git repository.\n- `--sdk-version <version>` - Specify which version of the `@temporalio/*` npm packages to use.\n\n### Project structure\n\nTypically, the generated project consists of 4 main components:\n\n- Workflows\n- Activities\n- Worker that executes Workflows and Activities\n- A script to execute a Workflow (using a Temporal Client)\n\n### Working with the created project\n\nMost sample projects come with these scripts:\n\n- `npm start` — Run the Worker with `ts-node` (does not require a compilation step)\n- `npm run start.watch` — Watch files with `nodemon` and re-run Worker on change\n- `npm run build` — Compile TypeScript\n- `npm run build.watch` — Watch files and compile on change\n- `npm run workflow` — Execute a Workflow\n\nIf you aren't familiar with the tradeoffs between these choices, we recommend primarily running `npm run start.watch` to have a live-reloading Worker good enough for most situations, and then `npm run workflow` to start individual Workflow executions.\n","is_empty":false},{"file_name":"patching.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/patching.md","id":479,"title":"Patching TypeScript Workflows","description":"Any Workflow code change that affects the order in which commands are generated breaks this assumption. So we have to keep both the old and new code when migrating Workflows while they are still running.","label":"Patching (Migrating)","markdown_content":"\n## Alternatives\n\nBefore you explore our patching/versioning API, check if your needs can be addressed in other ways:\n\n- [Version Task Queue](#version-task-queue)\n- [Version Workflow Name](#version-workflow-name)\n\nBoth options mean that Workflows running `v1` code will never migrate to `v2` code: they will run `v1` code to completion.\nIf you would like to update Workflows running `v1` _while they are still running_, you [may need to \"patch in\" code](#do-i-need-to-patch).\n\n### Version Task Queue\n\nIf we're currently running our v1 Workflow code on Workers that poll on `queue1`, we can run v2 Workflow code on Workers that poll on `queue2`:\n\n1. Leave some Workers running your v1 `Workflow`, on the `queue1` Task Queue.\n1. Change your `Workflow` code and spin up new Workers that are polling a `queue2` Task Queue.\n1. Cut over your Clients to only call `Workflow` on `queue2` from now on.\n1. Remove your v1 Workers when all the v1 Workflows have completed.\n\n### Version Workflow Name\n\nWhile versioning the Task Queue is usually easier, we can also create a new version of a Workflow by copying it and changing its name:\n\n1. Copy `Workflow1`'s code to a `Workflow2` function and change what you need.\n1. Register `Workflow2` in your Workers alongside `Workflow1`.\n1. Cut over your Clients to only call `Workflow2` from now on.\n1. Remove `Workflow1` code when none of them are running anymore.\n\n## Do I need to Patch?\n\nYou may need to patch if:\n\n- You want to change the remaining logic of a Workflow while it is still running\n- If your new logic can result in a different execution path\n\nThis added `sleep()` can result in a different execution path:\n\n```ts\n// from v1\nexport async function yourWorkflow(value: number): Promise<number> {\n  await runActivity();\n  return 7;\n}\n\n// to v2\nexport async function yourWorkflow(value: number): Promise<number> {\n  await sleep('1 day');\n\n  await runActivity();\n  return 7;\n}\n```\n\nIf v2 is deployed while there's a Workflow on the `runActivity` step, when the Activity completes, the Worker will try to replay the Workflow (in order to continue Workflow execution), notice that the sleep command is called and doesn't match with the Workflow's Event History, and throw a nondeterminism error.\n\nAdding a Signal Handler for a Signal type that has never been sent before does not need patching:\n\n```ts\n// from v1\nexport async function yourWorkflow(value: number): Promise<number> {\n  await sleep('1 days');\n  return value;\n}\n\n// to v2\nconst updateValueSignal = defineSignal<[number]>('updateValue');\n\nexport async function yourWorkflow(value: number): Promise<number> {\n  setHandler(updateValueSignal, (newValue) => (value = newValue));\n\n  await sleep('1 days');\n  return value;\n}\n```\n\n## Migrating Workflows in Patches\n\nWorkflow code has to be [deterministic](/typescript/determinism) by taking the same code path when replaying history events.\nAny Workflow code change that affects the order in which commands are generated breaks this assumption.\n\nSo we have to keep both the old and new code when migrating Workflows while they are still running:\n\n- When replaying, use the original code version that generated the ongoing event history.\n- When executing a new code path, always execute the\n  new code.\n\n<details>\n<summary>30 Min Video: Introduction to Versioning\n</summary>\n\nBecause we design for potentially long-running Workflows at scale, versioning with Temporal works differently than with other Workflow systems.\nWe explain more in this optional 30 minute introduction: [https://www.youtube.com/watch?v=kkP899WxgzY](https://www.youtube.com/watch?v=kkP899WxgzY)\n\n</details>\n\n## TypeScript SDK Patching API\n\nIn principle, the TypeScript SDK's patching mechanism works in a similar \"feature-flag\" fashion to the other SDK's, however, the \"versioning\" API has been updated to a notion of \"patching in\" code.\nThere are three steps to this reflecting three stages of migration:\n\n- Running v1 code with v2 patched in concurrently\n- Running v2 code with deprecation markers for v2 patches\n- Running \"just\" v2 code.\n\nThis is best explained in sequence (click through to follow along using our SDK sample).\n\nGiven an initial Workflow version `v1`:\n\n<!--SNIPSTART typescript-patching-1-->\n<!--SNIPEND-->\n\nWe decide to update our code and run `activityB` instead.\nThis is our desired end state, `v2`.\n\n<!--SNIPSTART typescript-patching-final-->\n<!--SNIPEND-->\n\n**Problem: We cannot directly deploy `v2` until we know for sure there are no more running Workflows created using `v1` code.**\n\nInstead we must deploy `v2` (below) and use the [`patched`](https://typescript.temporal.io/api/namespaces/workflow#patched) function to check which version of the code should be executed.\n\nPatching is a three step process:\n\n1. Patch in new code with `patched` and run it alongside old code\n2. Remove old code and `deprecatePatch`\n3. When you are sure all old Workflows are done executing, remove `deprecatePatch`\n\n### Step 1: Patch in new code\n\n`patched` inserts a marker into the Workflow history.\n\n![image](https://user-images.githubusercontent.com/6764957/139673361-35d61b38-ab94-401e-ae7b-feaa52eae8c6.png)\n\nDuring replay, when a Worker picks up a history with that marker it will fail the Workflow task when running Workflow code that does not emit the same patch marker (in this case `your-change-id`); therefore it is safe to deploy code from `v2` in a \"feature flag\" alongside the original version (`v1`).\n\n<!--SNIPSTART typescript-patching-2-->\n<!--SNIPEND-->\n\n### Step 2: Deprecate patch\n\nOnce we know that all Workflows started with `v1` code have completed we can [deprecate the patch](https://typescript.temporal.io/api/namespaces/workflow#deprecatepatch).\nDeprecated patches bridge between `v1patch` and `v2` (the end result), they work similarly to regular patches by recording a marker in the Workflow history, this marker does not fail replay when Workflow code does not emit it.\n\nIf while we're deploying `v2deprecatedpatch` (below) there are still live Workers running `v1patch` code and those Workers pick up Workflow histories generated by `v2deprecatedpatch`, they will safely use the patched branch.\n\n<!--SNIPSTART typescript-patching-3-->\n<!--SNIPEND-->\n\n### Step 3: Solely deploy new code\n\n`v2` is safe to deploy once all `v1patch` or earlier Workflows are complete due to the assertion mentioned above.\n\n## Upgrading Workflow dependencies\n\nUpgrading Workflow dependencies (such as ones installed into `node_modules`) _might_ break determinism in unpredictable ways.\nWe recommended using a lock file (`package-lock.json` or `yarn.lock`) to fix Workflow dependency versions and gain control of when they're updated.\n","is_empty":false},{"file_name":"production-deploy.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/production-deploy.md","id":480,"title":"Production Deploy Checklist for TypeScript SDK","description":"Recommended steps to take before deploying your Temporal app to production.","label":"Deploy Checklist","markdown_content":"\nThe following are recommended steps to take before deploying your Temporal application to production.\n\n## Production Temporal Cluster\n\nEither use Temporal Cloud ([join the waitlist](https://pages.temporal.io/cloud-early-access)) or deploy a self-hosted Temporal Cluster:\n\n- [Deployment guide](/server/production-deployment/)\n- [Scaling checklist](/server/production-deployment#checklist-for-scaling-temporal)\n\n## Linting and types\n\nIf you started your project with [`@temporalio/create`](/typescript/package-initializer), you already have our recommended TypeScript and ESLint configurations.\n\nIf you incrementally added Temporal to an existing app, we do recommend setting up linting and types as they will help catch bugs well before you ship them to production, and improve your development feedback loop.\nTake a look at [our recommended .eslintrc file](https://github.com/temporalio/samples-typescript/blob/main/.shared/.eslintrc.js) and tweak to taste.\n\n## Configure Connections and Namespaces\n\nTemporal Clients and Workers connect with Temporal Clusters through gRPC.\n\n- While you were developing locally, all these connections were set to their [default gRPC ports](/concepts/what-is-a-temporal-cluster) on localhost.\n- In production, you will need to configure address, Namespace, and encryption settings:\n\n  ```ts\n  export function getEnv(): Env {\n    return {\n      // NOT web.foo.bar.tmprl.cloud\n      address: 'foo.bar.tmprl.cloud',\n      namespace: 'foo.bar',\n      // in project root\n      clientCertPath: 'foobar.pem',\n      clientKeyPath: 'foobar.key',\n      // just to ensure task queue is same on client and worker, totally optional\n      taskQueue: process.env.TEMPORAL_TASK_QUEUE || 'hello-world-mtls',\n      // not usually needed:\n      // serverNameOverride: process.env.TEMPORAL_SERVER_NAME_OVERRIDE,\n      // serverRootCACertificatePath: process.env.TEMPORAL_SERVER_ROOT_CA_CERT_PATH,\n    };\n  }\n  ```\n\n  For more information, see [Connecting to Temporal Cloud (with mTLS)](/typescript/security#local-mtls-sample-tutorial).\n\n## Pre-build code\n\nIn most of our samples:\n\n- We use `ts-node`, which compiles TypeScript on the fly.\n- Our Workers bundle Workflow code at runtime.\n\nWe can improve our Worker's startup time by building code in advance.\n\n### Worker code\n\nThe Worker code can be built and run with:\n\n```sh\nnpm run build\nnode lib/worker.js\n```\n\n### Workflow code\n\nYou can programmatically bundle Workflow code on your own with [`bundleWorkflowCode`](/typescript/workers#prebuilt-workflow-bundles):\n\n```ts\nconst { code } = await bundleWorkflowCode({\n  workflowsPath: require.resolve('src/workflows'),\n});\n\nawait writeFile(path.join(__dirname, 'workflow-bundle.js'), code);\n```\n\nAnd then the bundle can be passed to the Worker:\n\n```ts\nconst worker = await Worker.create({\n  workflowBundle: { path: require.resolve('workflow-bundle.js') },\n  activities,\n  taskQueue,\n});\n```\n\nYou can also bundle code on your own and pass it to the `workflowBundle`.\n\nWe can see this process working in the [production sample](https://github.com/temporalio/samples-typescript/tree/main/production):\n\n<!--SNIPSTART typescript-production-worker-->\n<!--SNIPEND-->\n\n## Logging\n\nSend logs and errors to a logging service, so that when things go wrong, you can see what happened.\n\nFor more information about sending logs, see [Logging](/typescript/logging).\n\n## Metrics and tracing\n\n### Options\n\nWorkers can emit metrics and traces. There are a few [telemetry options](https://typescript.temporal.io/api/interfaces/worker.TelemetryOptions) that can be provided to [`Runtime.install`](https://typescript.temporal.io/api/classes/worker.runtime/#install). The common options are:\n\n- `metrics: { otel: { url } }`: The URL of a gRPC [OpenTelemetry collector](https://opentelemetry.io/docs/collector/).\n- `metrics: { prometheus: { bindAddress } }`: Address on the Worker host that will have metrics for [Prometheus](https://prometheus.io/) to scrape.\n\nTo set up tracing of Workflows and Activities, use our [opentelemetry-interceptors](/typescript/logging#opentelemetry-tracing) package.\n\n### Monitoring\n\nHere is the [full list of SDK metrics](/references/sdk-metrics/). Some of them are used in the [Worker Tuning Guide](/application-development/worker-performance) to determine how to change your deployment configuration. The guide also assumes you track the host-level metrics that are important for measuring your application's load (for many applications, this is just CPU, but some applications may run into other bottlenecks—like with Activities that use a lot of memory, or open a lot of sockets). How you track host-level metrics depends on where you deploy your Workers.\n\n## Performance tuning\n\nIf you are experiencing system performance issues, make sure that you have checked that the bottleneck is not with your Temporal Cluster before turning to the performance of your Workers.\n\nWe endeavor to give you good defaults, so you don't have to worry about them, but there are a few key settings you may want to explore if you are pushing system limits:\n\n- [Worker Options](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#maxcachedworkflows), for example:\n  - `maxCachedWorkflows` to limit Workflow cache size and trade memory for CPU (biggest lever for Worker performance)\n  - `maxConcurrentActivityTaskExecutions` and other options for tuning concurrency\n  - `stickyQueueScheduleToStartTimeout` to determine how quickly Temporal stops trying to send work to Workers that are no longer present, via [Sticky Queues](/concepts/what-is-a-sticky-execution)\n  - See [Worker Tuning Guide](/application-development/worker-performance)\n- [Activity Timeouts and Retries](/typescript/activities#activity-timeouts) as you gain an understanding of Temporal and the services you rely on, you will likely want to adjust the timeouts and Retry Policy to reflect your desired behavior.\n  - Note that there are separate [Timeouts and Retry Policy](https://typescript.temporal.io/api/interfaces/client.workflowoptions/#workflowruntimeout) at the Workflow level, but we do not encourage their usage unless you know what you are doing.\n- _to be completed as we get more user feedback_\n\n## Do not use Alpine\n\nAlpine replaces glibc with musl, which is incompatible with the Rust core of the TypeScript SDK.\nIf you receive errors like below, it's probably because you are using Alpine.\nYou can use the `slim` tag for the Docker image, if you are looking for a lightweight alternative.\n\n```sh\nError: Error loading shared library ld-linux-x86-64.so.2: No such file or directory (needed by /opt/app/node_modules/@temporalio/core-bridge/index.node)\n```\n\nOr like this:\n\n```sh\nError: Error relocating /opt/app/node_modules/@temporalio/core-bridge/index.node: __register_atfork: symbol not found\n```\n\n## Install ca-certificates for TLS transport\n\nBy default, the `slim` Docker images do not come with `ca-certificates` installed.\nThis might lead to a `[TransportError: transport error]` runtime error because the certificates cannot be verified.\nThe `ca-certificates` package installs the common certificate authorities and fixes this issue.\nThis package is required even when connecting to a local Temporal Server, and when using a server connection config that doesn't explicitly use TLS.\n\nAdd the following line to your Dockerfile if you use Debian-based images:\n\n```sh\nRUN apt update && apt install -y ca-certificates\n```\n","is_empty":false},{"file_name":"search-attributes.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/search-attributes.md","id":481,"title":"Default and Custom Search Attributes in TypeScript Workflows","description":"Search Attributes enable eventually-consistent, business-logic-focused search and filter queries for Workflow Executions.","label":"Search Attributes","markdown_content":"\nSee: [Application Development Guide ▶️ Observability ▶️ Visibility](/application-development/observability?lang=typescript#visibility).\n","is_empty":false},{"file_name":"security.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/security.md","id":482,"title":"Connection and Encryption in the TypeScript SDK","description":"A summary of the security features you should know as a TypeScript SDK user.","label":"Connection & Security","markdown_content":"\nTemporal Workers and Clients connect with your Temporal Cluster via gRPC, and must be configured securely for production.\nThere are three main features to know:\n\n- **Namespaces** help isolate code from each other\n- **TLS Encryption** helps encrypt code in transit\n- **Data Converter** helps encrypt code at rest (available soon)\n\nTemporal Server internally has [other Security features](/server/security), particularly Authorization.\n\nAn important part of Temporal's security model is that Temporal Server only manages state and time - it never actually sees or runs your Workflow/Activity code.\nCode is hosted by Temporal Workers that you run, and Temporal Server only sees inbound/outbound gRPC messages.\nThis eliminates a whole class of problems particularly when providing Temporal to multiple teams in your company, or when working with Temporal Cloud as a customer.\n\n## Namespaces\n\nimport Content from '../concepts/what-is-a-namespace.md'\n\n<Content />\n\nAll SDK connections (whether Workers or Clients) are to a specific namespace.\nIf not specified in [WorkflowClientOptions](https://typescript.temporal.io/api/interfaces/client.WorkflowClientOptions), this defaults to the `default` namespace.\n\n```ts\nconst connection = await Connection.connect();\n\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'your-custom-namespace', // defaults to 'default'\n});\n```\n\n## Encryption in transit with mTLS\n\nThere are two classes in the SDK that connect to the Temporal server, the [Worker](https://typescript.temporal.io/api/classes/worker.worker) and the client [Connection](https://typescript.temporal.io/api/classes/client.connection/).\nWhen instantiating either of them, you may choose whether to connect securely or not.\n\n- In order to connect to the server using TLS, set a _truthy_ value (`true` or [TLSConfig](https://typescript.temporal.io/api/interfaces/common.tlsconfig/) for custom options) in the `tls` configuration option.\n- Use [`ServerOptions.tls`](https://typescript.temporal.io/api/interfaces/worker.serveroptions#tls) when [creating](https://typescript.temporal.io/api/classes/worker.worker/#create) a new Worker and\n  [`ConnectionOptions.tls`](https://typescript.temporal.io/api/interfaces/client.connectionoptions#tls) for the [`Connection`](https://typescript.temporal.io/api/classes/client.connection) constructor.\n- The client connection also accepts [gRPC credentials](https://grpc.github.io/grpc/node/grpc.credentials.html) at [`ConnectionOptions.credentials`](https://typescript.temporal.io/api/interfaces/client.connectionoptions#tls) as long as `tls` is not also specified.\n\nA full example for Clients looks like this:\n\n```js\nimport { Connection, WorkflowClient } from '@temporalio/client';\n\nconst connection = await Connection.connect({\n  // defaults port to 7233 if not specified\n  address: 'foo.bar.tmprl.cloud',\n  tls: {\n    // set to true if TLS without mTLS\n    // See docs for other TLS options\n    clientCertPair: {\n      crt: clientCert,\n      key: clientKey,\n    },\n  },\n});\nconst client = new WorkflowClient({\n  connection,\n  namespace: 'foo.bar', // as explained in Namespaces section\n});\n```\n\nA full example for Workers looks like this:\n\n```js\nimport { Worker, NativeConnection } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  const connection = await NativeConnection.connect({\n    address: 'foo.bar.tmprl.cloud', // defaults port to 7233 if not specified\n    tls: {\n      // set to true if TLS without mTLS\n      // See docs for other TLS options\n      clientCertPair: {\n        crt: clientCert,\n        key: clientKey,\n      },\n    },\n  });\n\n  const worker = await Worker.create({\n    connection,\n    namespace: 'foo.bar', // as explained in Namespaces section\n    // ...\n  });\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\nIf you are using mTLS, is completely up to you how to get the `clientCert` and `clientKey` pair into your code, whether it is reading from filesystem, secrets manager, or both.\nJust keep in mind that they are whitespace sensitive and some environment variable systems have been known to cause frustration because they modify whitespace.\n\n<details>\n<summary>\n  Example code that works for local dev and for certs hosted on AWS S3\n</summary>\n\n```ts\nlet serverRootCACertificate: Buffer | undefined;\nlet clientCertificate: Buffer | undefined;\nlet clientKey: Buffer | undefined;\nif (certificateS3Bucket) {\n  const s3 = new S3client({ region: certificateS3BucketRegion });\n  serverRootCACertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: serverRootCACertificatePath,\n  });\n  clientCertificate = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientCertPath,\n  });\n  clientKey = await s3.getObject({\n    bucket: certificateS3Bucket,\n    key: clientKeyPath,\n  });\n} else {\n  serverRootCACertificate = fs.readFileSync(serverRootCACertificatePath);\n  clientCertificate = fs.readFileSync(clientCertPath);\n  clientKey = fs.readFileSync(clientKeyPath);\n}\n```\n\n_Thanks to our Design Partner [Mina Abadir](https://twitter.com/abadir_) for sharing this.\\_\n\n</details>\n\n<span id=\"mtls-tutorial\"></span>\n\n### Connecting to Temporal Cloud (with mTLS)\n\n[The Hello World mTLS sample](https://github.com/temporalio/samples-typescript/tree/main/hello-world-mtls/) shows how to connect to a Temporal Cloud account.\nAfter signing up for Temporal Cloud, you should have a namespace, a server address, and a client certificate and key. Use the following environment variables to set up the sample:\n\n- **TEMPORAL_ADDRESS**: looks like `foo.bar.tmprl.cloud` (NOT web.foo.bar.tmprl.cloud)\n- **TEMPORAL_NAMESPACE**: looks like `foo.bar`\n- **TEMPORAL_CLIENT_CERT_PATH**: e.g. `/tls/ca.pem` (file contents start with -----BEGIN CERTIFICATE-----)\n- **TEMPORAL_CLIENT_KEY_PATH**: e.g. `/tls/ca.key` (file contents start with -----BEGIN PRIVATE KEY-----)\n\nYou can leave the remaining vars, like `TEMPORAL_SERVER_NAME_OVERRIDE` and `TEMPORAL_SERVER_ROOT_CA_CERT_PATH` blank.\nThere is another var, `TEMPORAL_TASK_QUEUE`, which the example defaults to `'hello-world-mtls'` but you can customize as needed.\n\n<details>\n<summary>Example environment settings</summary>\n\n```ts\nexport function getEnv(): Env {\n  return {\n    // NOT web.foo.bar.tmprl.cloud\n    address: 'foo.bar.tmprl.cloud',\n    namespace: 'foo.bar',\n    // in project root\n    clientCertPath: 'foobar.pem',\n    clientKeyPath: 'foobar.key',\n    // just to ensure task queue is same on client and worker, totally optional\n    taskQueue: process.env.TEMPORAL_TASK_QUEUE || 'hello-world-mtls',\n    // // not usually needed\n    // serverNameOverride: process.env.TEMPORAL_SERVER_NAME_OVERRIDE,\n    // serverRootCACertificatePath: process.env.TEMPORAL_SERVER_ROOT_CA_CERT_PATH,\n  };\n}\n```\n\n</details>\n\nIf you have misconfigured your connection somehow, you will get an opaque `[TransportError: transport error]` error. Read through your settings carefully and contact us if you are sure you have checked everything.\n\nNote the difference between the gRPC and Temporal Web endpoints:\n\n- The gRPC endpoint has a DNS address of `<Namespace_ID>.tmprl.cloud`, for example: `accounting-production.f45a2.tmprl.cloud`.\n- The Temporal Web endpoint is `web.<Namespace_ID>.tmprl.cloud`, for example: `https://web.accounting-production.f45a2.tmprl.cloud`.\n\n### Local mTLS sample tutorial\n\nFollow this tutorial for setting up mTLS (Mutual TLS authentication) with Temporal Server, Client, and Worker locally.\n**For Temporal Cloud customers, there is a separate tutorial above.**\n\n1. Set up Temporal Server with mTLS encryption locally\n   - Clone the [server samples repo](https://github.com/temporalio/samples-server/) and change to the `tls/tls-simple` directory\n   - Follow [these instructions](https://github.com/temporalio/samples-server/tree/master/tls/tls-simple#readme) to set up a local server with mTLS\n   - The sample does not register the default Namespace on startup, register it with: `docker exec -it tls-simple_temporal-admin-tools_1 tctl n re --retention 1 default`\n1. Configure your Temporal Client and Worker to connect with mTLS\n   - Scaffold a new Temporal project with `npx @temporalio/create@latest` using the `hello-world-mtls` template, or copy the relevant configuration from the snippets below into an existing project.\n   - Export the required environment variables:\n     ```bash\n     export TEMPORAL_ADDRESS=localhost\n     export TEMPORAL_NAMESPACE=default\n     export TEMPORAL_CLIENT_CERT_PATH=/path/to/samples-server/tls/tls-simple/certs/client.pem\n     export TEMPORAL_CLIENT_KEY_PATH=/path/to/samples-server/tls/tls-simple/certs/client.key\n     # just for the local mTLS sample\n     export TEMPORAL_SERVER_ROOT_CA_CERT_PATH=/path/to/samples-server/tls/tls-simple/certs/ca.cert\n     export TEMPORAL_SERVER_NAME_OVERRIDE=tls-sample\n     ```\n1. Test the connection with `npm run start.watch` and `npm run workflow`.\n   You should see everything working as per the regular Hello World tutorial.\n\nTemporal has no opinions on production deployment strategy other than the connections and architecture displayed here.\n\n## Encryption at rest with Payload Codec\n\n- [Data Converter ➡️ Encryption](/concepts/what-is-a-data-converter#encryption)\n- [Data Converters in TypeScript ➡️ Encryption](/typescript/data-converters#encryption)\n","is_empty":false},{"file_name":"set-task-queue-in-typescript.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/set-task-queue-in-typescript.md","id":483,"markdown_content":"In Temporal, a Task Queue is represented in code by its name as a `string`.\n\nThere are two main places where the name of the Task Queue is supplied by the developer.\nWhen scheduling a Workflow, a `taskQueue` must be specified.\n\n```typescript\nimport { WorkflowClient } from '@temporalio/client';\nconst client = new WorkflowClient();\nconst result = await client.execute(yourWorkflow, {\n  // required\n  taskQueue: 'testhttp',\n  workflowId: 'business-meaningful-id',\n});\n```\n\nWhen creating a Worker, you must pass the `taskQueue` option to the [`Worker.create()` function](https://typescript.temporal.io/api/classes/worker.worker#create).\n\n```typescript\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: 'your-task-queue',\n});\n```\n\nOptionally, in a Workflow Function, when calling an Activity, you can specify the Task Queue by passing the `taskQueue` option to [`proxyActivities()`](https://typescript.temporal.io/api/namespaces/workflow/#proxyActivities) or [`startChild/executeChild`](https://typescript.temporal.io/api/namespaces/workflow/#startchild).\nIf you do not specify a `taskQueue`, then the Temporal TypeScript SDK places Activity and Child Workflow Tasks in the same Task Queue as the Workflow Task Queue.\n","is_empty":false},{"file_name":"testing.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/testing.md","id":484,"title":"Testing TypeScript Workflows","label":"Testing","markdown_content":"\n:::note Sample available\n\nA complete sample for testing with Jest can be found in our [samples repo](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/workflows.test.ts).\n:::\n\nThe TypeScript SDK comes with an optional test framework (npm `@temporalio/testing`).\n\nUpon installation, it will automatically download a test server with time skipping support (more on that later).\n\nThe test framework provides utilities for testing both Activities and Workflows.\n\n## Testing Activities\n\nActivities can be tested with [`MockActivityEnvironment`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment)\n\nThe constructor accepts an optional partial Activity [`Info`](https://typescript.temporal.io/api/classes/activity.Info) object in case any info fields are needed for the test.\n\n### Running an activity in Context\n\n[`MockActivityEnvironment.run()`](https://typescript.temporal.io/api/classes/testing.MockActivityEnvironment#run) runs a function in an Activity [Context](https://typescript.temporal.io/api/classes/activity.context).\n\n```ts\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport { Context } from '@temporalio/activity';\n\nconst env = new MockActivityEnvironment({ attempt: 2 });\nconst result = await env.run(\n  async (x) => x + Context.current().info.attempt,\n  2\n);\nassert.equal(result, 4);\n```\n\n### Heartbeats and cancellation\n\n`MockActivityEnvironment` is an [`EventEmitter`](https://nodejs.org/api/events.html#class-eventemitter) that emits a `heartbeat` event which you can use to listen for heartbeats emitted by the Activity.\n\n> NOTE: When run by a `Worker`, heartbeats are throttled to avoid overloading the server.\n> `MockActivityEnvironment` on the other hand does not apply any throttling.\n\nIt also exposes a `cancel` method which cancels the Activity Context.\n\n```ts\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport { CancelledFailure, Context } from '@temporalio/activity';\n\nconst env = new MockActivityEnvironment();\n\nenv.on('heartbeat', (d: unknown) => {\n  if (d === 6) {\n    env.cancel('test');\n  }\n});\n\nawait assert.rejects(\n  () =>\n    env.run(async () => {\n      Context.current().heartbeat(6);\n      await Context.current().sleep(100); // <- sleep is cancellation aware\n    }),\n  (err) => {\n    assert.ok(err instanceof CancelledFailure);\n  }\n);\n```\n\n## Testing Workflows\n\nWorkflows can be tested with [`TestWorkflowEnvironment`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment).\n\nA typical test suite would set up a single instance of the test environment to be reused in all tests (e.g. in a [jest](https://jestjs.io/) `beforeAll` hook).\n\nWhen creating an environment, [`TestWorkflowEnvironment.create`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#create) will automatically start a test server that you can access with [`workflowClient`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#workflowclient) and [`nativeConnection`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#nativeconnection).\n\n### Example setup\n\n> NOTE: `beforeAll` and `afterAll` are injected by `jest`.\n\n```ts\nimport { TestWorkflowEnvironment } from '@temporalio/testing';\nimport { Worker } from '@temporalio/worker';\nimport { v4 as uuid4 } from 'uuid';\nimport { httpWorkflow } from './workflows';\nimport type * as Activities from './activities'; // Uses types to ensure our mock signatures match\n\nlet testEnv: TestWorkflowEnvironment;\n\nbeforeAll(async () => {\n  testEnv = await TestWorkflowEnvironment.create();\n});\n\nafterAll(async () => {\n  await testEnv?.teardown();\n});\n```\n\n### Mocking Activities\n\nSince the `TestWorkflowEnvironment` is meant for testing Workflows, you'd typically want to mock your Activities in tests to avoid generating side effects.\n\n```ts\ntest('httpWorkflow with mock activity', async () => {\n  const { workflowClient, nativeConnection } = testEnv;\n\n  // Implement only the relevant activities for this workflow\n  const mockActivities: Partial<typeof Activities> = {\n    makeHTTPRequest: async () => '99',\n  };\n  const worker = await Worker.create({\n    connection: nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('./workflows'),\n    activities: mockActivities,\n  });\n  const result = await worker.runUntil(\n    await workflowClient.execute(httpWorkflow, {\n      workflowId: uuid4(),\n      taskQueue: 'test',\n    })\n  );\n  expect(result).toEqual('The answer is 99');\n});\n```\n\n### Time skipping in Workflows\n\nThe built-in test server automatically \"skips\" (fast forwards) time when no Activities are executing.\nThe test server starts in \"normal\" time, using the `TestWorkflowEnvironment.workflowClient` `execute` or `result`\nmethods switch the test server to \"skipped\" time mode until the Workflow completes.\nIf a Workflow sleeps for days, running it in the test environment will cause it to complete almost immediately.\n\n`workflows.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\n\nexport async function sleeperWorkflow() {\n  await sleep('1 day');\n}\n```\n\n`test.ts`\n\n```ts\ntest('sleep completes almost immediately', async () => {\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('../workflows'),\n  });\n  // Does not wait an entire day\n  await worker.runUntil(\n    testEnv.workflowClient.execute(sleeperWorkflow, {\n      workflowId: uuid(),\n      taskQueue: 'test',\n    })\n  );\n});\n```\n\n### Time skipping in Tests\n\nYou can also call `testEnv.sleep()` from your test code to advance the test server's time.\nThis is useful for testing intermediate state, or for testing infinite Workflows.\nHowever, to advance time using `testEnv.sleep()`, you need to start the Workflow using `start()`, not `execute()`.\n\n`workflow.ts`\n\n```ts\nimport { sleep } from '@temporalio/workflow';\nimport { defineQuery, setHandler } from '@temporalio/workflow';\n\nexport const daysQuery = defineQuery('days');\n\nexport async function sleeperWorkflow() {\n  let numDays = 0;\n\n  setHandler(daysQuery, () => numDays);\n\n  for (let i = 0; i < 100; ++i) {\n    await sleep('1 day');\n    ++numDays;\n  }\n}\n```\n\n`test.ts`\n\n```ts\ntest('advancing time using `testEnv.sleep()`', async function () {\n  const client = testEnv.workflowClient;\n\n  // Important: `start()` starts the test server in \"normal\" mode,\n  // not skipped time mode. If you don't advance time using `testEnv.sleep()`,\n  // then `sleeperWorkflow()` will run for days.\n  handle = await client.start(sleeperWorkflow, {\n    taskQueue,\n    workflowId: uuidv4(),\n  });\n\n  let numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 0);\n\n  // Advance the test server's time by 25 hours and assert that\n  // `sleeperWorkflow()` correctly incremented `numDays`.\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 1);\n\n  // Advance the test server's time by an additional 25 hours and\n  // assert that `sleeperWorkflow()` incremented `numDays` a second time.\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 2);\n});\n```\n\n### Time skipping in Activities\n\nWhen an Activity is executing time switches back to \"normal\",\n[`TestWorkflowEnvironment.sleep`](https://typescript.temporal.io/api/classes/testing.testworkflowenvironment/#sleep)\ncan be used outside of Workflow code to skip time.\n\n<details>\n<summary>\nWorkflow implementation\n</summary>\n\n<!--SNIPSTART typescript-timer-reminder-workflow-->\n<!--SNIPEND-->\n\n</details>\n\n```ts\ntest('countdownWorkflow sends reminder email if processing does not complete in time', async () => {\n  // NOTE: this tests doesn't actually take days to complete, the test environment starts a test\n  // server that automatically skips time when there are no running activities.\n  let emailSent = false;\n  // createActivities defintion omitted for brevity\n  const activities: ReturnType<typeof createActivities> = {\n    async processOrder() {\n      // Test server switches to \"normal\" time while an activity is executing.\n      // Call `sleep` to skip time by \"2 days\".\n      await testEnv.sleep('2 days');\n    },\n    async sendNotificationEmail() {\n      emailSent = true;\n    },\n  };\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('../workflows'),\n    activities,\n  });\n  await worker.runUntil(\n    testEnv.workflowClient.execute(processOrderWorkflow, {\n      workflowId: uuid(),\n      taskQueue: 'test',\n      args: [\n        {\n          orderProcessingMS: ms('3 days'),\n          sendDelayedEmailTimeoutMS: ms('1 day'),\n        },\n      ],\n    })\n  );\n  expect(emailSent).toBe(true);\n});\n```\n\n### Test arbitrary functions in Workflow context\n\nIn case you need to test a function in your Workflow code that's not exported in [`workflowsPath`](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#workflowspath), export it in a different path and register it with the Worker.\n\n`workflows/file-with-workflow-function-to-test.ts`\n\n```ts\nimport * as wf from '@temporalio/workflow';\nimport { someWorkflowToRunAsChild } from './some-workflow';\n\nexport { someWorkflowToRunAsChild }; // Must be re-exported here for Worker registration\n\nexport async function functionToTest() {\n  await wf.executeChild(someWorkflowToRunAsChild);\n  // Other test code\n}\n```\n\n`test.ts`\n\n```ts\nconst worker = await Worker.create({\n  ...someOtherOptions,\n  connection: testEnv.nativeConnection,\n  workflowsPath: require.resolve(\n    './workflows/file-with-workflow-function-to-test'\n  ),\n});\n\nawait worker.runUntil(\n  testEnv.workflowClient.execute(functionToTest, workflowOptions)\n);\n```\n\n### Asserting from Workflow code\n\nIn some cases it's useful to assert directly in Workflow context.\n\nThe Workflow context is injected with the Node.js [`assert`](https://nodejs.org/api/assert.html) module and can be imported with `import assert from 'assert'`.\n\nBy default, failed `assert` statements throw `AssertionError`s which cause Workflow Tasks to fail and be indefinitely retried.\nTo prevent this, use `workflowInterceptorModules` from `@temporalio/testing`. These interceptors catch `AssertionError`s and turn them into `ApplicationFailure`s that fail the entire Workflow Execution (not just the Workflow Task).\n\n`workflows/file-with-workflow-function-to-test.ts`\n\n```ts\nimport assert from 'assert';\n\nexport async function functionToTest() {\n  assert.ok(false);\n}\n```\n\n`test.ts`\n\n```ts\nimport {\n  TestWorkflowEnvironment,\n  workflowInterceptorModules,\n} from '@temporalio/testing';\n\nconst worker = await Worker.create({\n  ...someOtherOptions,\n  connection: testEnv.nativeConnection,\n  interceptors: {\n    workflowModules: workflowInterceptorModules,\n  },\n  workflowsPath: require.resolve(\n    './workflows/file-with-workflow-function-to-test'\n  ),\n});\n\nawait worker.runUntil(\n  testEnv.workflowClient.execute(functionToTest, workflowOptions) // Throws WorkflowFailedError\n);\n```\n","is_empty":false},{"file_name":"troubleshooting.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/troubleshooting.md","id":485,"title":"Troubleshooting Issues with the TypeScript SDK","description":"This document is a quick checklist of common user errors for your reference.","label":"Troubleshooting","markdown_content":"\nThis document is a quick checklist of common user errors for your reference.\n\n## Two Locations to Watch\n\n- Workflow Errors are reflected in Temporal Web\n- Worker errors and logs are reflected in the terminal.\n\nIf something isn't behaving the way you expect, make sure to check both locations for helpful error messages.\n\n## Stale Workflows\n\nIf you are developing Workflows and finding that code isn't executing as expected, the first place to look is whether old Workflows are still running.\n\nIf those old Workflows have the same name and are on the same task queue, Temporal will try to continue executing them on your new code by design.\nYou may get errors that make no sense to you because\n\n- Temporal is trying to execute old Workflow code that no longer exists in your codebase, or\n- your new Client code is expecting Temporal to execute old Workflow/Activity code it doesn't yet know about.\n\nThe biggest sign that this is happening is if you notice Temporal is acting non-deterministically: running the same Workflow twice gets different results.\n\nStale workflows are usually a non-issue because the errors generated are just noise from code you no longer want to run.\nIf you need to terminate old stale Workflows, you can do so with Temporal Web or `tctl`.\n\n## Workflow/Activity registration errors\n\n**If your Workflows or Activities are not imported or spelled correctly**, here are some errors we've seen:\n\n- `ApplicationFailure: 'MyFunction' is not a function`\n- `Workflow did not register a handler for MyQuery`\n\nDouble check that your Workers are registering the right Workflow and Activity Definitions (function names) on the right Task Queues.\n\n**If you are running Temporal in a monorepo**, then your `node_modules` may be in a different location than where Temporal expects to find it by default, which results in errors like:\n\n```bash\n[ERROR] Module not found: Error: Can't resolve '@temporalio/workflow/lib/worker-interface.js' in '/src'\n```\n\nOur [Next.js tutorial](/typescript/nextjs-tutorial) is written for people setting up Temporal **within an existing monorepo** which may be of use here.\n\nWhen you pass a `workflowsPath`, our Webpack config expects to find `node_modules` in the same or a parent/ancestor directory.\n\n**If you are custom bundling your own Workflows** you may get errors like these:\n\n```bash\n[ERROR] Failed to activate workflow {\n  runId: 'aaf84a83-51ce-462a-9ab7-6a641a703bff',\n  error: ReferenceError: exports is not defined,\n  workflowExists: false\n}\n```\n\nTemporal Workflow Bundles need to [export a set of methods that fit the compiled `worker-interface.ts` from `@temporalio/workflow`](https://github.com/temporalio/sdk-typescript/blob/eaa2d205c9bc5ff4a3b17c0b34f2dcf6b1e0264a/packages/worker/src/workflow/bundler.ts#L81) as an entry point.\nWe do offer a [bundleWorkflowCode](/typescript/workers/#prebuilt-workflow-bundles) method to assist you with this, though it uses our Webpack settings.\n\n## Webpack errors\n\nThe TypeScript SDK's [Worker](/typescript/workers) bundles Workflows based on `workflowsPath` with [Webpack](https://webpack.js.org/) and run them inside v8 isolates.\n\nIf Webpack fails to create the bundle, the SDK will throw an error and emit webpack logs using the SDK's [logger](/typescript/logging#logs-generated-by-sdk-components).\n\nIf you do not see Webpack output in your terminal make sure that you have not disabled SDK logging (see reference to `Runtime.install()` in the link above).\n\n**A common mistake for newcomers to the TypeScript SDK is trying to use Node.js built-ins and modules in their Workflow code.** Usually, the best thing to do is move that code to an Activity.\n\nSome common examples that will **not** work in the Workflow isolate:\n\n<details>\n<summary>\nImporting node built-in modules\n</summary>\n\n:::danger Antipattern\n\n```ts\nimport fs from 'fs';\n\nconst config = fs.readFileSync('config.json', 'utf8');\n```\n\n:::\n\nThis is invalid because reading from the filesystem is a non-deterministic operation: the file may change from the time of the original Workflow execution to when the Workflow is replayed.\n\nYou'll typically see an error in this form in the Webpack output:\n\n```\n2021-10-14T19:22:00.606Z [INFO] Module not found: Error: Can't resolve 'fs' in '/Users/you/your-project/src'\n2021-10-14T19:22:00.606Z [INFO] resolve 'fs' in '/Users/you/your-project/src'\n2021-10-14T19:22:00.606Z [INFO]   Parsed request is a module\n2021-10-14T19:22:00.606Z [INFO]   using description file: /Users/you/your-project/package.json (relative path: ./src)\n2021-10-14T19:22:00.606Z [INFO]     Field 'browser' doesn't contain a valid alias configuration\n```\n\n</details>\n\n<details>\n<summary>\nImporting and calling Activities directly from Workflow code\n</summary>\n\n:::danger Antipattern\n\n```ts\nimport { makeHTTPRequest } from './activities';\n\nexport async function yourWorkflow(): Promise<string> {\n  return await makeHTTPRequest('https://temporal.io');\n}\n```\n\n:::\n\nThis is invalid because activity implementations should not be directly referenced by Workflow code.\nActivities are used by Workflows in order make network calls and reading from the filesystem, operations which are non-deterministic by nature because they rely on external state.\nTemporal records Activity results in the Workflow history and in case your Workflow is replayed, completed Activities will not be rerun, instead their recorded result will be delivered to the Workflow.\n\nYou'll typically see an error in this form in the Webpack output:\n\n```\n2021-10-14T19:46:52.731Z [INFO] ERROR in ./src/activities.ts 8:31-46\n2021-10-14T19:46:52.731Z [INFO] Module not found: Error: Can't resolve 'http' in '/Users/you/your-project/src'\n2021-10-14T19:46:52.731Z [INFO]\n2021-10-14T19:46:52.731Z [INFO] BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.\n2021-10-14T19:46:52.731Z [INFO] This is no longer the case. Verify if you need this module and configure a polyfill for it.\n2021-10-14T19:46:52.731Z [INFO]\n2021-10-14T19:46:52.731Z [INFO] If you want to include a polyfill, you need to:\n2021-10-14T19:46:52.731Z [INFO]         - add a fallback 'resolve.fallback: { \"http\": require.resolve(\"stream-http\") }'\n2021-10-14T19:46:52.731Z [INFO]         - install 'stream-http'\n2021-10-14T19:46:52.731Z [INFO] If you don't want to include a polyfill, you can use an empty module like this:\n2021-10-14T19:46:52.731Z [INFO]         resolve.fallback: { \"http\": false }\n```\n\nTo properly call your Activities from Workflow code use `proxyActivities` and make sure to only import the Activity types.\n\n```ts\nimport { proxyActivities } from '@temporalio/workflow';\n\nimport type * as activities from './activities';\nconst { makeHTTPRequest } = proxyActivities<typeof activities>();\n\nexport async function yourWorkflow(): Promise<string> {\n  return await makeHTTPRequest('https://temporal.io');\n}\n```\n\n</details>\n\n## Works in Dev, but not in Prod\n\nThe two main sources of dev-prod discrepancies are in bundling and connecting.\n\n### Production Bundling\n\nIf you are getting errors like this:\n\n```\nError: 3 INVALID_ARGUMENT: WorkflowType is not set on request.\n```\n\nThis is due to your bundler stripping out Workflow function names, which we rely on to set the \"Workflow Type\" in Temporal. Turn it off and it should work.\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs\ndefaultValue=\"webpackterser\"\nvalues={[\n{label: 'Webpack with Terser', value: 'webpackterser'},\n{label: 'ESbuild', value: 'esbuild'},\n]\n}>\n\n<TabItem value=\"webpackterser\">\n\n```js\n// webpack.config.js\nmodule.exports = {\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          keep_fnames: true, // don't strip funciton names in production\n        },\n      }),\n    ],\n  },\n};\n```\n\n</TabItem>\n<TabItem value=\"esbuild\">\n\n```js\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  minify: true,\n  keepNames: true,\n  outfile: 'out.js',\n});\n```\n\nSee esbuild docs: https://esbuild.github.io/api/#keep-names\n\n</TabItem>\n</Tabs>\n\n### Connecting to Temporal Server\n\nIf you are trying to connect in production and getting this:\n\n```bash\n[TransportError: transport error]\n```\n\nIt is a sign that something is wrong with your Cert/Key pair.\nLog it out and make sure it is an exact match with what is expected (often, the issue can be whitespace when injecting from your production secrets management environment).\n\n## Resetting Workflows to deal with logical bugs\n\nYou can \"rewind time\" using the `tctl` CLI, resetting Workflow History to some previous point in time. You can read the CLI docs on:\n\n- [Restarting and resetting Workflows by ID](/tctl/how-to-use-tctl/#restart-reset-workflow)\n- [Resetting all Workflows by binary checksum identifier](/tctl/how-to-use-tctl/#recovery-from-bad-deployment----auto-reset-workflow)\n\nIf you need to reset programmatically, the TS SDK does not have any high level APIs for this, but you can make raw gRPC calls to [resetWorkflowExecution](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#resetworkflowexecution).\n\nResetting should only be used to deal with serious logical bugs in your code: it's not for handling transient failures, like a downstream service being unreachable. It should not be used in the course of normal application flows.\n\n## gRPC call timeouts (context deadline exceeded)\n\nThe opaque `context deadline exceeded` error comes from `gRPC`:\n\n```\nError: 4 DEADLINE_EXCEEDED: context deadline exceeded\n    at Object.callErrorFromStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/call.js:31:26)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client.js:179:52)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client-interceptors.js:336:141)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client-interceptors.js:299:181)\n    at /Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/call-stream.js:145:78\n    at processTicksAndRejections (node:internal/process/task_queues:78:11) {\n  code: 4,\n  details: 'context deadline exceeded',\n  metadata: Metadata {\n    internalRepr: Map(1) { 'content-type' => [Array] },\n    options: {}\n  },\n  page: '/api/getBuyState'\n}\n```\n\nSeveral conditions can cause this error, including network hiccups, timeouts that are too short, and an overloaded server.\nQuerying a Workflow Execution whose query handler causes an error can result in the query call timing out.\n\nSome troubleshooting actions you can take:\n\n- Verify the connection from your Worker to the Temporal Server is working and doesn't have unusually high latency\n- If you are running Temporal Server yourself, check your [server metrics](/server/production-deployment/#scaling-and-metrics) to ensure it's not overloaded\n- If what's timing out is a query, check the logs of your Workers to see if they are having issues handling the query\n\nIf none of the preceding actions help you discover why timeouts are occurring, please try to produce a minimal repro and we'll be glad to help.\n","is_empty":false},{"file_name":"tsconfig.json","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/tsconfig.json","id":486,"markdown_content":"{\n  \"compilerOptions\": {\n    \"moduleResolution\": \"node\",\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noResolve\": true,\n    \"allowUnusedLabels\": true,\n    \"skipLibCheck\": true,\n    \"noEmitOnError\": true,\n    \"strict\": false,\n    \"removeComments\": false,\n    \"module\": \"ESNext\",\n    \"target\": \"ESNext\",\n    \"alwaysStrict\": false\n  }\n}\n","is_empty":false},{"file_name":"workers.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/workers.md","id":487,"title":"Workers and Task Queues in TypeScript","description":"A Worker is a process that connects to the Temporal Server, polls Task Queues for Commands sent from Clients, and executes Workflows and Activities in response to those Commands.","label":"Workers","markdown_content":"\n**`@temporalio/worker`** [![NPM](https://img.shields.io/npm/v/@temporalio/worker)](https://www.npmjs.com/package/@temporalio/worker) [API reference](https://typescript.temporal.io/api/namespaces/worker) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/worker)\n\n> _Background reading: [Workers in Temporal](/workers)_\n\n## What is a Worker?\n\nA Worker is a process that connects to the Temporal Server, polls **Task Queues** for Tasks sent from Clients, and executes [Workflows](/typescript/workflows) and [Activities](/typescript/activities) in response.\n\n- **Workers host Workflows and Activities.**\n  - TypeScript SDK Workers bundle Workflows based on `workflowsPath` with [Webpack](https://webpack.js.org/) and run them inside v8 isolates.\n  - TypeScript SDK Workers directly run `activities` inside the normal Node.js environment.\n- **Workers are extremely scalable.**\n  - Workers connect to the Temporal Server, poll their configured **Task Queue** for Tasks, execute chunks of code in response to those Tasks, and then communicate the results back.\n  - Workers are distinct from Clients and scaled independently of Temporal Server, which has its own internal services to scale.\n  - Workers are stateless, and can be brought up and down at any time with no Temporal data loss impact.\n    To migrate to new versions of your Workflows and Activities, you restart your Workers with the new versions (and optionally use [the `patch` API to migrate](/typescript/patching) still-running Workflows of the older version).\n  - Use the `@temporalio/worker` package's [`Worker`](https://typescript.temporal.io/api/classes/worker.Worker) class to create and run as many Workers as your use case demands, across any number of hosts.\n- **Workers are run on user-controlled hosts.** This is an important security feature which means Temporal Server (or Temporal Cloud) never executes your Workflow or Activity code, and that Workers can have different hardware (e.g. custom GPUs for Machine Learning) than the rest of the system.\n\n<details>\n<summary>\nYour Workflows will only progress if there are Workers polling the right Task Queues, and they must have the right Workflows and Activities registered to execute those Tasks.\n</summary>\n\nThe TypeScript SDK uses TypeScript, but cannot completely protect you from typos.\nIf you are experiencing issues, you can check the status of Workers and the Task Queues they poll with [tctl](/tctl) or the [Temporal Web UI](/web-ui).\n\n![Temporal Web Task Queues view](https://user-images.githubusercontent.com/6764957/126413160-18663430-bb7a-4d3a-874e-80598e1fa07d.png)\n\n</details>\n\n### How to develop a Worker\n\nimport Content from '../typescript/how-to-develop-a-worker-program-in-typescript.md'\n\n<Content />\n\n<details>\n<summary>\nThe Worker package embeds the <a href=\"https://github.com/temporalio/sdk-core\">Temporal Rust Core SDK</a>.\nIt comes pre-compiled for most installations.\n</summary>\n\nWe've provided pre-compiled binaries for:\n\n- Mac with an Intel chip: `x86_64-apple-darwin`\n- Mac with an Apple chip: `aarch64-apple-darwin`\n- Linux with x86_64 architecture: `x86_64-unknown-linux-gnu`\n- Linux with aarch64 architecture: `aarch64-unknown-linux-gnu`\n- Windows with x86_64 architecture: `x86_64-pc-windows-gnu` (Windows is not yet supported but it is a [priority for us](https://github.com/temporalio/sdk-typescript/issues/12)).\n\nIf you need to compile the Worker yourself, set up the Rust toolchain by following the instructions [here](https://rustup.rs/).\n\n</details>\n\n### Prebuilt Workflow Bundles\n\nAdvanced users can pass a prebuilt bundle instead of `workflowsPath`, or you can use Temporal's `bundleWorkflowCode` helper:\n\n```ts\nimport { bundleWorkflowCode, Worker } from '@temporalio/worker';\n\n// Option 1: passing path to prebuilt bundle\nconst worker = await Worker.create({\n  taskQueue,\n  workflowBundle: {\n    codePath: './path-to-bundle.js',\n    sourceMapPath: './path-to-bundle.js.map',\n  },\n});\n\n// Option 2: bundling code using Temporal's bundler settings\nconst workflowBundle = await bundleWorkflowCode({\n  workflowsPath: require.resolve('./path-to-your-workflows'),\n});\nconst worker = await Worker.create({\n  taskQueue,\n  workflowBundle,\n});\n```\n\n### How to shut down a Worker and track its state\n\nWorkers shut down if they receive any of these [`shutdownSignals`](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#shutdownsignals): `['SIGINT', 'SIGTERM', 'SIGQUIT', 'SIGUSR2']`. In development, we shut down Workers with `Ctrl-C` (`SIGINT`) or [`nodemon`](https://github.com/temporalio/samples-typescript/blob/c37bae3ea235d1b6956fcbe805478aa46af973ce/hello-world/package.json#L10) (`SIGUSR2`). In production, we usually want to give Workers a [`shutdownGraceTime`](https://typescript.temporal.io/api/interfaces/worker.workeroptions/#shutdowngracetime) long enough for them to finish any in-progress Activities. As soon as they receive a shutdown signal or request, the Worker stops polling for new Tasks and allows in-flight Tasks to complete until `shutdownGraceTime` is reached. Any Activities that are still running at that time will stop running, and will be rescheduled by Temporal Server when an [Activity timeout](/typescript/activities#activity-timeouts) occurs.\n\nWe may want to programmatically shut down Workers (with `worker.shutdown()`) in integration tests or when automating a fleet of Workers.\n\n#### Worker states\n\nAt any point in time, we can Query Worker state with `worker.getState()`.\nA Worker is in one of 7 states at any given point:\n\n- `INITIALIZED` - The initial state of the Worker after calling Worker.create and successful connection to the server\n- `RUNNING` - `worker.run()` was called, polling Task Queues\n- `FAILED` - Worker encountered an unrecoverable error, `worker.run()` should reject with the error\n- The last 4 states are related to the Worker shutdown process:\n  - `STOPPING` - `worker.shutdown()` was called or received shutdown Signal, Worker will forcefully shutdown after `shutdownGraceTime`\n  - `DRAINING` - Core has indicated that shutdown is complete and all Workflow tasks have been drained, waiting for activities and cached Workflows eviction\n  - `DRAINED` - All activities and Workflows have completed, ready to shutdown\n  - `STOPPED` - Shutdown complete, `worker.run()` resolves\n\nIf you need even more visibility into internal Worker state, [see the API reference for more](https://typescript.temporal.io/api/classes/worker.Worker).\n\n## Rust Core and Worker Networking\n\nIn development, the TypeScript SDK usually handles all of the communication between the Worker and the Temporal Server behind the scenes.\n\nIn production settings, you can configure the `address` and `namespace` the Worker speaks to via [the Rust Core SDK](https://github.com/temporalio/sdk-core) [`NativeConnection`](https://typescript.temporal.io/api/classes/worker.nativeconnection/), and configure the Core [`Runtime`](https://typescript.temporal.io/api/classes/worker.runtime/#install) with [RuntimeOptions](https://typescript.temporal.io/api/interfaces/worker.RuntimeOptions):\n\n```js\nimport {\n  Worker,\n  DefaultLogger,\n  Runtime,\n  NativeConnection,\n} from '@temporalio/worker';\n\nconst logger = new DefaultLogger('DEBUG');\nRuntime.install({\n  logger,\n  telemetryOptions: { logForwardingLevel: 'INFO' },\n});\nconst connection = await NativeConnection.connect({\n  address: 'temporal.myorg.io',\n});\nconst worker = await Worker.create({\n  connection,\n  namespace: 'your-custom-namespace',\n  /* standard Worker options from here */\n});\n```\n\nTemporal also supports mTLS encryption (required by Temporal Cloud) this way - please read our [Security docs](/typescript/security#encryption-in-transit-with-mtls) for more information.\n\n## Task Queues\n\nimport WhatIsATaskQueue from '../concepts/what-is-a-task-queue.md'\n\n<details>\n<summary>\nA Task Queue is a dynamic queue in Temporal Server polled by one or more Workers.\n</summary>\n\n<WhatIsATaskQueue />\n\n</details>\n\n### Where Task Queues are used\n\nIn Temporal, a Task Queue is represented in code by its name as a `string`.\n\nThere are two main places where the name of the Task Queue is supplied by the developer.\n\n<details>\n<summary>\n\nWhen scheduling a Workflow, a `taskQueue` must be specified.\n\n</summary>\n\n```ts\nimport { Connection, WorkflowClient } from '@temporalio/client';\nconst connection = await Connection.connect();\nconst client = new WorkflowClient({ connection });\nconst result = await client.execute(yourWorkflow, {\n  // required\n  taskQueue: 'testhttp',\n  workflowId: 'business-meaningful-id',\n});\n```\n\n</details>\n<details>\n<summary>\n\nWhen creating a Worker, you **must** pass the `taskQueue` option to the [`Worker.create()` function](https://typescript.temporal.io/api/classes/worker.worker#create).\n\n</summary>\n\n```ts\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: 'your-task-queue',\n});\n```\n\n</details>\n\nOptionally, in Workflow code, when calling an Activity, you can specify the Task Queue by passing the `taskQueue` option to [`proxyActivities()`](https://typescript.temporal.io/api/namespaces/workflow/#proxyActivities) or [`startChild/executeChild`](https://typescript.temporal.io/api/namespaces/workflow/#startchild).\nIf you do not specify a `taskQueue`, then the TypeScript SDK places Activity and Child Workflow Tasks in the same Task Queue as the Workflow Task Queue.\n\n### Example: Sticky Activities\n\nAny Worker that polls a Task Queue is allowed to pick up the next task; sometimes this is undesirable because you want tasks to execute sequentially on the same machine.\n\nFortunately, there is a design pattern for this we call _Sticky Activities_.\nBecause Task Queues are dynamically created and very lightweight, you can use them for task routing by creating a new Task Queue per machine.\n\nThe main strategy is:\n\n1. Create a `getUniqueTaskQueue` Activity that generates a unique Task Queue name, (for example, `uniqueWorkerTaskQueue`).\n   It doesn't matter where this Activity is run so this can be \"non sticky\" as per Temporal default behavior\n2. For Activities intended to be _sticky_, register them in one Worker, and have that be the only Worker listening on that `uniqueWorkerTaskQueue`.\n   - Multiple Workers can be created inside the same process.\n3. Execute Workflows from the Client like normal.\n   - Activities will execute in sequence on the same machine because they are all routed by the `uniqueWorkerTaskQueue`.\n\nWorkflow Code:\n\n<!--SNIPSTART typescript-sticky-queues-workflow-->\n<!--SNIPEND-->\n\nWorker Code:\n\n<!--SNIPSTART typescript-sticky-queues-worker-->\n<!--SNIPEND-->\n\nThis pattern is [in use at Netflix](https://www.youtube.com/watch?v=LliBP7YMGyA&t=24s).\nNote that this is unrelated to [Sticky Queues](/concepts/what-is-a-sticky-execution), which are an internal implementation detail.\n","is_empty":false},{"file_name":"workflows.md","file_path":"/Users/flossypurse/Temporal/documentation/docs/typescript/workflows.md","id":488,"title":"Workflows in TypeScript","description":"Workflows are async functions that can orchestrate Activities and access special Workflow APIs, subject to deterministic limitations.","label":"Workflows","markdown_content":"\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\nimport RelatedReadList, {RelatedReadContainer, RelatedReadItem} from '../components/RelatedReadList.js'\n\n<!-- prettier-ignore -->\nimport * as WhatIsASignal from '../concepts/what-is-a-signal.md'\nimport * as WhatIsAQuery from '../concepts/what-is-a-query.md'\n\n**`@temporalio/workflow`** [![NPM](https://img.shields.io/npm/v/@temporalio/workflow)](https://www.npmjs.com/package/@temporalio/workflow) [API reference](https://typescript.temporal.io/api/namespaces/workflow) | [GitHub](https://github.com/temporalio/sdk-typescript/tree/main/packages/workflow)\n\n> _Background reading: [Workflows in Temporal](/workflows)_\n\n**Workflows are async functions that can orchestrate Activities and access special Workflow APIs, subject to deterministic limitations**.\n\nEach Workflow function has two parts:\n\n- The function name is known as the **Workflow Type**.\n- The function implementation code (body) is known as the **Workflow Definition**.\n\nEach Workflow Definition is bundled with any third party dependencies, and registered by Workflow Type in a [Worker](/typescript/workers).\nA Workflow function becomes a **Workflow Execution** (instance) only when started from a [**Workflow Client**](/typescript/clients) using its Workflow Type.\n\n<!-- todo: we need a diagram here to show the relationship -->\n\n## How to write a Workflow function\n\nWorkflow Definitions are \"just functions\", which can store state, and orchestrate [Activity functions](/typescript/activities).\n\n<!--SNIPSTART typescript-hello-workflow {\"enable_source_link\": false}-->\n<!--SNIPEND-->\n\nThe snippet above uses `proxyActivities` to create functions that, when called, schedule a `greet` Activity in the system to say \"Hello World\".\n\nA Workflow function can have multiple parameters, but we encourage you to use a single object parameter, as that helps with backward compatibility:\n\n```ts\ntype ExampleArgs = {\n  name: string;\n};\n\nexport async function example(\n  args: ExampleArgs\n): Promise<{ greeting: string }> {\n  const greeting = await greet(args.name);\n  return { greeting };\n}\n```\n\n### Workflow Limitations\n\nWorkflow code must be [deterministic](/typescript/determinism), and the TypeScript SDK replaces common sources of nondeterminism for you, like `Date.now()`, `Math.random`, and `setTimeout` (we recommend using our [`sleep`](/typescript/workflows#sleep) API instead).\nHowever, there are other important limitations:\n\n- No Node built-ins like `process` or the `path` and `fs` modules\n- No filesystem access\n- No network access\n\nThese constraints don't apply inside Activities.\n**If you need to ping an API, or access the filesystem (e.g. for building a CI/CD system), move that code into Activities.**\n\n## How to Start and Cancel Workflows\n\nSee the [TypeScript SDK Client docs](/typescript/clients) for how to use `WorkflowHandle`s to start, cancel, signal, query, describe and more.\n\n### Workflow Options\n\nWorkflows have options that determine what Task Queue they run on, what Search Attributes they are tagged with, Cron schedule, and more, but they are only set in the Temporal Client call (i.e. when you start or execute a Workflow) rather than _inside_ the Workflow code itself.\n\nPlease see the [Temporal Client docs](/typescript/clients) or the [API Reference](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions) for more info on Workflow Options.\n\n## Workflow APIs\n\nThe `@temporalio/workflow` package exports all the useful primitives that you can use in Workflows. See the [API reference](https://typescript.temporal.io/api/namespaces/workflow) for the full list, but the main ones are:\n\n| APIs                         | Purpose                                                                                                                                                                                                                                                                                                                                                                                                   |\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `proxyActivities`            | Make idempotent side effects (like making a HTTP request) with Activities ([see Activities doc](/typescript/activities))                                                                                                                                                                                                                                                                                  |\n| `proxyLocalActivities`       | Make idempotent side effects (like making a HTTP request) with Activities ([see Activities doc](/typescript/activities))                                                                                                                                                                                                                                                                                  |\n| `defineSignal`/`defineQuery` | [Signal and Query](#signals-and-queries) Workflows while they are running                                                                                                                                                                                                                                                                                                                                 |\n| `sleep`                      | Defer execution by [sleeping](#sleep) for fixed time                                                                                                                                                                                                                                                                                                                                                      |\n| `condition`                  | Defer execution until a [`condition`](#condition) is true, with optional timeout                                                                                                                                                                                                                                                                                                                          |\n| `startChild`/`executeChild`  | Spawn new [Child Workflows](#child-workflows) with customizable ParentClosePolicy                                                                                                                                                                                                                                                                                                                         |\n| `continueAsNew`              | Truncate Event History for [Entity Workflows](#entity-workflows)                                                                                                                                                                                                                                                                                                                                          |\n| `patched`/`deprecatePatch`   | Migrate Workflows to new versions ([see Patching doc](/typescript/patching))                                                                                                                                                                                                                                                                                                                              |\n| `uuid4`                      | Generate an RFC compliant V4 [uuid](https://typescript.temporal.io/api/namespaces/workflow/#uuid4) without needing to call an Activity or Side Effect.                                                                                                                                                                                                                                                    |\n| APIs for advanced users      | including [`workflowInfo`](https://typescript.temporal.io/api/namespaces/workflow#workflowinfo) (to retrieve Workflow metadata), Workflow data [`Sinks`](/typescript/logging), [Cancellation Scopes](/typescript/cancellation-scopes), [Failure types](/typescript/handling-failure), and [`getExternalWorkflowHandle`](https://typescript.temporal.io/api/namespaces/workflow#getexternalworkflowhandle) |\n\nYou can import them individually or as a group:\n\n```js\n// Option 1\nimport { sleep } from '@temporalio/workflow';\n\n// Option 2\nimport * as wf from '@temporalio/workflow';\n```\n\nWe fully expect that developers will bundle these into their own reusable Workflow libraries.\nIf you do, please [get in touch on Slack](https://temporal.io/slack), we would love to work with you and promote your work.\n\nThe rest of this document explains the major Workflow APIs you should know:\n\n- Signals and Queries: `defineSignal`, `defineQuery`, and `setHandler`\n- Deferred Execution: `sleep` and `condition`\n- Child Workflows: `startChild` and `executeChild`\n- Entity (indefinitely long-running) Workflows: `continueAsNew`\n\n## Signals and Queries\n\n> _Background reading: [Signals and Queries in Temporal](/workflows/#signals)_\n\n<RelatedReadContainer>\n  <RelatedReadItem page={WhatIsASignal} />\n  <RelatedReadItem page={WhatIsAQuery} />\n</RelatedReadContainer>\n\n#### How to define and receive Signals and Queries\n\n### Define Signals and Queries inside a Workflow\n\n- To add a Signal to a Workflow, call [`defineSignal`](https://typescript.temporal.io/api/namespaces/workflow/#definesignal) with a name, and then attach a listener with `setHandler`.\n- To add a Query to a Workflow, call [`defineQuery`](https://typescript.temporal.io/api/namespaces/workflow/#definequery) with a name, and then attach a listener with `setHandler`.\n- Handlers for both Signals and Queries can take arguments, which can be used inside `setHandler` logic.\n- Only Signal Handlers can mutate state, and only Query Handlers can return values.\n\n#### Define Signals and Queries Statically\n\nIf you know the name of your signals and queries upfront, we recommend declaring them outside of the Workflow Definition.\n\n<!--SNIPSTART typescript-blocked-workflow-->\n<!--SNIPEND-->\n\nThis helps provide type safety, since you can export the type signature of the signal or query to be called on the clientside.\n\n#### Define Signals and Queries Dynamically\n\nFor more flexible usecases, you may want a dynamic Signal (such as a generated ID).\nYou may handle it in two ways:\n\n- avoid making it dynamic by collapsing all signals in one handler and move the ID to the payload, or\n- actually make the Signal name dynamic by inlining the Signal definition per handler.\n\n```ts\nimport * as wf from '@temporalio/workflow';\n\n// \"fat handler\" solution\nwf.setHandler(`genericSignal`, (payload) => {\n  switch (payload.taskId) {\n    case taskAId:\n      // do task A things\n      break;\n    case taskBId:\n      // do task B things\n      break;\n    default:\n      throw new Error('Unexpected task.');\n  }\n});\n\n// \"inline definition\" solution\nwf.setHandler(wf.defineSignal(`task-${taskAId}`), (payload) => {\n  /* do task A things */\n});\nwf.setHandler(wf.defineSignal(`task-${taskBId}`), (payload) => {\n  /* do task B things */\n});\n\n// utility \"inline definition\" helper\nconst inlineSignal = (signalName, handler) =>\n  wf.setHandler(wf.defineSignal(signalName), handler);\ninlineSignal(`task-${taskBId}`, (payload) => {\n  /* do task B things */\n});\n```\n\n<details>\n  <summary>\n    API Design FAQs\n  </summary>\n\n#### Why not `new Signal` and `new Query`?\n\nThe semantic of `defineSignal`/`defineQuery` is intentional, in that they return Signal/Query **Definitions**, not unique instances of Signals and Queries themselves. [This is their entire source code](https://github.com/temporalio/sdk-typescript/blob/fc658d3760e6653aec47732ab17a0062b7dd23fc/packages/workflow/src/workflow.ts#L884-L907):\n\n```ts\n/**\n * Define a signal method for a Workflow.\n */\nexport function defineSignal<Args extends any[] = []>(\n  name: string\n): SignalDefinition<Args> {\n  return {\n    type: 'signal',\n    name,\n  };\n}\n\n/**\n * Define a query method for a Workflow.\n */\nexport function defineQuery<Ret, Args extends any[] = []>(\n  name: string\n): QueryDefinition<Ret, Args> {\n  return {\n    type: 'query',\n    name,\n  };\n}\n```\n\nSignals/Queries are only instantiated in `setHandler` and are specific to a particular Workflow Execution.\n\nThese distinctions may seem minor, but they model how Temporal works under the hood, because Signals and Queries are messages identified by \"just strings\" and don't have meaning independent of the Workflow having a listener to handle them.\nThis will be clearer if you refer to the Client-side APIs below.\n\n#### Why `setHandler` and not OTHER_API?\n\nWe named it `setHandler` instead of `subscribe` because Signals/Queries can only have one \"handler\" at a time, whereas `subscribe` could imply an Observable with multiple consumers, and is a higher level construct.\n\n```ts\nwf.setHandler(MySignal, handlerFn1);\nwf.setHandler(MySignal, handlerFn2); // replaces handlerFn1\n```\n\nIf you are familiar with [RxJS](https://rxjs.dev/), you are free to wrap your Signal and Query into Observables if you wish, or you could dynamically reassign the listener based on your business logic or Workflow state.\n\n</details>\n\n### Invoke Signals and Queries from a Client\n\nSending Signals and making Queries requires having a Workflow handle from a [Temporal Client](/typescript/clients).\n\n- You send a Signal with `handle.signal(signal, ...args)`. A Signal has no return value by definition.\n- You make a Query with `handle.query(query, ...args)`. A Query needs a return value, but can also take args.\n- You can refer to either by string name, which is useful for dynamic reference, but you will lose type inference.\n\n```ts\n// // inside Client code! not Workflow code!\nimport { increment, count } from './workflow';\n\n// init client code omitted - see Client docs\nconst handle = client.getHandle(workflowId);\n\n// these three are equivalent\nawait handle.signal(increment, 1);\nawait handle.signal<[number]>('increment', 1);\nawait client.getHandle(workflowId).signal(increment, 1);\n\n// these three are equivalent\nlet state = await handle.query(count);\nlet state = await handle.query<number>('count');\nlet state = await client.getHandle(workflowId).query(count);\n```\n\nBy design of these Workflow handles, two different Workflows can use the same Signal or Query and there is still no ambiguity, because you always have to specify which Workflow you are signalling (`workflowHandle1.signal(MySignal)` vs `workflowHandle2.signal(MySignal)`).\n\n### Signals and Queries design patterns\n\nBecause Signals and Queries are intentionally flexible, you can wrap them up into reusable functions:\n\n<Tabs\ndefaultValue=\"export\"\nvalues={[\n{label: 'Exportable', value: 'export'},\n{label: 'Concise', value: 'short'},\n]\n}>\n\n<TabItem value=\"export\">\n\n```ts\n// implementation of queryable + signallable State in Workflow file\nimport * as wf from '@temporalio/workflow';\n\nfunction useState<T = any>(name: string, initialValue: T) {\n  const signal = wf.defineSignal<[T]>(name);\n  const query = wf.defineQuery<T>(name);\n  let state: T = initialValue;\n  return {\n    signal,\n    query,\n    get value() {\n      // need to use closure because function doesn't rerun unlike React Hooks\n      return state;\n    },\n    set value(newVal: T) {\n      state = newVal;\n    },\n  };\n}\n\n// usage in Workflow file\nconst store = useState('your-store', 10);\nfunction YourWorkflow() {\n  wf.setHandler(store.signal, (newValue: T) => {\n    // console.log('updating', newValue) // optional but useful for debugging\n    store.value = newValue;\n  });\n  wf.setHandler(store.query, () => store.value);\n  while (true) {\n    console.log('sleeping for ', store.value);\n    wf.sleep(store.value++ * 100); // you can mutate the value as well\n  }\n}\n\n// usage in Client file\nawait handle.signal(store.signal, 30);\nconst storeState = handle.query<number>(store.query); // 30\n```\n\n</TabItem>\n<TabItem value=\"short\">\n\n```ts\n// alternative, more concise but slightly less safe implementation\nimport * as wf from '@temporalio/workflows';\n\nfunction useState<T = any>(name: string, initialValue: T) {\n  const signal = wf.defineSignal<[T]>(name);\n  const query = wf.defineQuery<T>(name);\n  let state: T = initialValue;\n  wf.setHandler(signal, (newVal: T) => void (newVal = state));\n  wf.setHandler(query, () => state);\n  return {\n    signal,\n    query,\n    get value() {\n      return state;\n    },\n    set value(newVal: T) {\n      state = newVal;\n    },\n  };\n}\n\n// usage in Workflow file\nfunction YourWorkflow() {\n  const store = useState('your-store', 10); // needs to be inside because function uses setHandler\n  while (true) {\n    console.log('sleeping for ', store.value);\n    wf.sleep(store.value++ * 100); // you can mutate the value as well\n  }\n}\n\n// usage in Client file\nawait handle.signal('your-store', 30);\nconst storeState = handle.query<number>('your-store'); // 30\n```\n\n</TabItem>\n</Tabs>\n\nYou can even conditionally set handlers, or set handlers inside handlers:\n\n```ts\nimport * as wf from '@temporalio/workflow';\nfunction YourWorkflow(signallable: boolean, signalNames: string[]) {\n  // conditional setting of handlers\n  if (signallable) {\n    wf.setHandler(MySignal, handler);\n  }\n\n  // set same handler for an array of signals by name\n  signalNames.forEach((name) => wf.setHandler(name, handler));\n\n  // signal handler that sets signal handlers\n  // // would be nice to send a function but we can't because it is not serializable\n  wf.setHandler(MySignal, (handlerName) => {\n    wf.setHandler(handlerName, handlers[handlerName]);\n  });\n}\n```\n\n### Additional Signals and Queries Notes\n\n#### Type-safety for Signals and Queries\n\nThe Signals and Queries API has been designed with type safety in mind:\n\n- `wf.defineQuery<Ret, Args>(name): QueryDefinition<Ret, Args>`\n- `wf.defineSignal<Args>(name): SignalDefinition<Args>`\n- `handle.query<Ret, Args>(def, ...args): Promise<Ret>`\n- `handle.signal<Args>(def, ...args): Promise<Ret>`\n\nYou can either:\n\n- Define the argument type (and, for Queries, the return type) up front and import it for type inference with the `WorkflowHandle`\n- Define the expected type at the call site when you invoke the Signal/Query.\n\n```ts\nconst increment =\n  wf.defineSignal<[number /* more args can be added here */]>('increment');\nconst count = wf.defineQuery<number /*, Arg[] can be added here */>('count');\n\n// type safety inferred from definitions\nawait handle.signal(increment, 1);\nawait handle.signal(increment); // Expected 2 arguments, but got 1.\nawait handle.signal(increment, '1'); // Argument of type 'string' is not assignable to parameter of type 'number'\n\n// common problems when you lack type safety\nawait handle.signal('increment'); // No TS error but insufficient arguments\nawait handle.signal('increment', '1'); // No TS error but sending in wrong type\n\n// add type safety at callsite\nawait handle.signal<[number]>('increment'); // Expected 2 arguments, but got 1.\nlet state = await handle.query<number, [string]>('print', 'Count: ');\n```\n\n#### Notes on Signals\n\n- Signal handlers are only guaranteed to be called in order **per Signal Type**, not across all of them.\n  If you need strict ordering across multiple Signals, either:\n  - Combine them into one Signal Type and use a `switch` statement.\n  - Register handlers statically (call `setHandler` outside of the Workflow function).\n- `WorkflowHandle.signal` resolves as soon as Temporal Server has persisted the Signal, before the Workflow's Signal handler is called.\n- `WorkflowHandle.signal` Promise resolves with no value; **Signal handlers cannot return data to the caller.**\n- **No Synchronous Updates**.\n  Users often want Signals to return a value, for example, a validation error.\n  However Temporal has no way to surface any error to the external invocation.\n  Signals are always asynchronous, in other words, **a Signal always succeeds**.\n  Long term, the solution to this is \"Synchronous Update\" and [it is under active development](https://github.com/temporalio/proposals/pull/53).\n\nFor now [the best workaround](https://community.temporal.io/t/signalling-system-human-driven-workflows/160/2) is to use a Query to return Workflow state after signaling.\nTemporal guarantees read-after-write consistency of Signals-followed-by-Queries.\n\n#### Notes on Queries\n\n> 🚨 WARNING: NEVER mutate Workflow state inside a query! Generating Commands in Query handlers can lead to unexpected behaviors on subsequent executions.\n\n:::danger How NOT to write a Query\n\nThis mutates Workflow state - do not do this:\n\n```ts\nexport function badExample() {\n  let someState = 123;\n  wf.setHandler(query, () => {\n    return someState++; // bad! don't do this!\n  });\n}\n```\n\n:::\n\n#### Reusing Signals and Queries in Libraries\n\nBecause Signal and Query Definitions are separate from Workflow Definitions, we can now compose them together:\n\n```ts\n// basic reusable Workflow component\nexport async function unblocked() {\n  let isBlocked = true;\n  wf.setHandler(unblockSignal, () => (isBlocked = false));\n  wf.setHandler(isBlockedQuery, () => isBlocked);\n  await wf.condition(() => !isBlocked);\n}\n\n// usage: signals can be sent to each Workflow separately\nexport async function yourWorkflow1() {\n  await unblocked();\n}\nexport async function yourWorkflow2() {\n  await unblocked();\n}\n```\n\nAnother example of componentization can be found in our [code samples](https://github.com/temporalio/samples-typescript/blob/854c78955601a6b63aa8ea412cfb5eaf61bd78ee/expense/src/workflows.ts#L19).\n\n### `signalWithStart`\n\nIf you're not sure if a Workflow is running, you can `signalWithStart` a Workflow to send it a Signal and optionally start the Workflow if it is not running.\nArguments for both are sent as needed.\n\n```ts\n// Signal With Start in Client file\nconst client = new WorkflowClient();\nawait client.signalWithStart(YourWorkflow, {\n  workflowId,\n  args: [arg1, arg2],\n  signal: MySignal,\n  signalArgs: [arg3, arg4],\n});\n```\n\nSee the [Workflow Client](/typescript/clients/#workflow-options) docs for more notes on how starting Workflows and Workflow Options look like.\n\n## Deferred Execution\n\n`sleep` and `condition` help you write durable asynchronous code in Temporal by offering an easy to use Promise-like API, but deferring, persisting, and resuming execution behind the scenes.\n\n- In other words, they do not \"lock\" the process, allowing one Worker to concurrently process hundreds of Workflows that sleep and await arbitrary conditions.\n- They are also \"cancellation aware\", allowing for graceful cleanup if the Workflow they are linked to is canceled.\n  For more information, see [Cancellation Scopes](/typescript/cancellation-scopes).\n\nThe Workflow's V8 isolate environment completely replaces the JavaScript [`setTimeout`](https://typescript.temporal.io/api/namespaces/workflow/#timers) global, including inside libraries that you use, to provide a complete JavaScript runtime.\nWe recommend using our [`sleep(timeout)`](https://typescript.temporal.io/api/namespaces/workflow/#sleep) API instead, because it is a cancellation-aware Promise wrapper for `setTimeout`.\n\n<details>\n<summary>\nWhy Durable Timers Are a Hard Problem\n</summary>\n\nJavaScript has a `setTimeout`, which seems relatively straightforward.\nHowever, they are held in memory - if your system goes down, those timers are gone.\n\nA lot of careful code is required to make these timeouts fully reliable (aka recoverable in case of outage) and cancellation aware.\n\n<!-- Note: these are rough Durable Timer notes from Maxim - we should build out examples and really hit home why you want to use us rather than write your own, in future.\nWhen writing Workflows with timers, you need to take care that it handles jumps of time.\nWhat we mean by \"handling jumps\": if you had timers that were supposed to go off at 1.15, 1.30, and 1.45pm, and your system goes down from 1pm to 2pm, then at 2pm when the system comes back up all 3 timers will fire at once. If your workflow code relies on the timers resolving in precise order, write these checks yourself.\n-->\n\nBeyond that, further engineering is needed to scale this - imagine 100,000 independently running timers in your system, firing every minute.\nThat is the kind of scale Temporal handles.\n\n</details>\n\n### `sleep`\n\n`sleep` sets a durable timer for a fixed time period (an \"Updatable Timer\" pattern is documented below).\nIt uses the [ms](https://www.npmjs.com/package/ms) package to take either a string or number of milliseconds, and returns a promise that you can `await` and `catch` when the Workflow Execution is cancelled.\n\n```ts\nimport { sleep } from '@temporalio/workflow';\n\nawait sleep('30 days'); // string API\nawait sleep(30 * 24 * 60 * 60 * 1000); // numerical API\n\n// `sleep` is cancellation-aware\n// when workflow gets canceled during sleep, promise is rejected\nawait sleep('30 days').catch(() => {\n  // clean up code if workflow is canceled during sleep\n});\n\n// NOT VALID\nawait sleep('1 month'); // ms package doesnt support \"months\" https://github.com/vercel/ms/issues/57\n// use date-fns and sleepUntil instead, see below\n```\n\nWith this primitive, you can build other abstractions. For example, a `sleepUntil` function that converts absolute time to relative time with `date-fns`:\n\n```ts\nimport * as wf from '@temporalio/workflow';\nimport differenceInMilliseconds from 'date-fns/differenceInMilliseconds';\n\nasync function sleepUntil(futureDate, fromDate = new Date()) {\n  const timeUntilDate = differenceInMilliseconds(\n    new Date(futureDate),\n    fromDate\n  );\n  return wf.sleep(timeUntilDate);\n}\n\nsleepUntil('30 Sep ' + (new Date().getFullYear() + 1)); // wake up when September ends\nsleepUntil('5 Nov 2022 00:12:34 GMT'); // wake up at specific time and timezone\n```\n\nYou can check the valid ISO string formats on [MDN's Date docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse). The upcoming [ECMAScript Temporal API](https://tc39.es/proposal-temporal/docs/index.html) will offer more time utilities natively in JavaScript, alongside unfortunate name collision for Temporal developers.\n\n:::caution Preventing Confusion: Workflow sleep vs Activity sleep\n\nThere is an unrelated [`sleep` utility function](https://typescript.temporal.io/api/classes/activity.context/#sleep) available in **Activity Context** that is not durable, but is cancellation aware. See [the Activities docs for details](/typescript/activities).\n\n:::\n\n### `condition`\n\nThe `condition(fn, timeout?)` API returns a promise that resolves:\n\n- `true` when the given predicate function (**must be synchronous**) returns `true` or\n- (optional) `false` if a timeout (given as a string or number of milliseconds) happens first.\n\nThis API is comparable to `Workflow.await` in other SDKs and often used to wait for Signals, since Signals are the main way to asynchronously update internal Workflow state (looped Activities are another).\n\nThe timeout also uses the [ms](https://www.npmjs.com/package/ms) package to take either a string or number of milliseconds.\n\n```ts\n// type signature\nexport function condition(\n  fn: () => boolean,\n  timeout: number | string\n): Promise<boolean>;\nexport function condition(fn: () => boolean): Promise<void>;\n\n// Usage\nimport * as wf from '@temporalio/workflow';\n\nlet x = 0;\n// do stuff with x, eg increment every time you receive a signal\nawait wf.condition(() => x > 3);\n// you only reach here when x > 3\n\n// await either x > 3 or 30 minute timeout, whichever comes first\nif (await wf.condition(() => x > 3, '30 mins')) {\n  // reach here if predicate true\n} else {\n  // reach here if timed out\n}\n\n// track user progress with condition\nexport async function trackStepChanges(): Promise<void> {\n  let step = 0;\n  wf.setHandler(updateStep, (s) => void (step = s));\n  wf.setHandler(getStep, () => step);\n  await wf.condition(() => step === 1);\n  await wf.condition(() => step === 2);\n}\n```\n\n<details>\n<summary>Example usage in our Next.js One-Click Buy code sample</summary>\n\n`condition` only returns true when the function evaluates to `true`; if the `condition` resolves as `false`, then a timeout has occurred.\nThis leads to some nice patterns, like placing `await condition` inside an `if`:\n\n<!--SNIPSTART typescript-oneclick-buy-->\n<!--SNIPEND-->\n\n</details>\n\n:::warning `condition` Antipatterns\n\n- No time based condition functions are allowed in your function as this is very error prone.\n  Use the optional `timeout` arg or a `sleep` timer.\n- `condition` only accepts **synchronous** functions that return a boolean.\n  Do not put async functions, like Activities, inside the `condition` function.\n\n:::\n\n<!--TODO: give an idea of what the bad code looks like and why its bad-->\n\n### Async design patterns\n\nThe real value of `sleep` and `condition` is in knowing how to use them to model asynchronous business logic.\nHere are some examples we use the most; we welcome more if you can think of them!\n\n<details>\n<summary>\nRacing Timers\n</summary>\n\nUse `Promise.race` with Timers to dynamically adjust delays.\n\n```ts\nexport async function processOrderWorkflow({\n  orderProcessingMS,\n  sendDelayedEmailTimeoutMS,\n}: ProcessOrderOptions): Promise<void> {\n  let processing = true;\n  const processOrderPromise = processOrder(orderProcessingMS).then(() => {\n    processing = false;\n  });\n\n  await Promise.race([processOrderPromise, sleep(sendDelayedEmailTimeoutMS)]);\n\n  if (processing) {\n    await sendNotificationEmail();\n    await processOrderPromise;\n  }\n}\n```\n\n</details>\n<details>\n<summary>\nRacing Signals\n</summary>\n\nUse `Promise.race` with Signals and Triggers to have a promise resolve at the earlier of either system time or human intervention.\n\n```ts\nimport { Trigger, sleep, defineSignal } from '@temporalio/workflow';\n\nconst userInteraction = new Trigger<boolean>();\nconst completeUserInteraction = defineSignal('completeUserInteraction');\n\nexport async function yourWorkflow(userId: string) {\n  setHandler(completeUserInteraction, () => userInteraction.resolve(true)); // programmatic resolve\n  const userInteracted = await Promise.race([\n    userInteraction,\n    sleep('30 days'),\n  ]);\n  if (!userInteracted) {\n    await sendReminderEmail(userId);\n  }\n}\n```\n\nYou can invert this to create a Reminder pattern where the promise resolves IF no Signal is received.\n\n:::warning Antipattern: Racing sleep.then\n\nBe careful when racing a chained `sleep`. This may cause bugs because the chained `.then` will still continue to execute.\n\n```js\nawait Promise.race([\n  sleep('5s').then(() => (status = 'timed_out')),\n  somethingElse.then(() => (status = 'processed')),\n]);\n\nif (status === 'processed') await complete(); // takes more than 5 seconds\n// status = timed_out\n```\n\n:::\n\n</details>\n\n<details>\n<summary>\nUpdatable Timer\n</summary>\n\nHere is how you can build an updatable timer with `condition`:\n\n```ts\nimport * as wf from '@temporalio/workflow';\n\n// usage\nexport async function countdownWorkflow(): Promise<void> {\n  const target = Date.now() + 24 * 60 * 60 * 1000; // 1 day!!!\n  const timer = new UpdatableTimer(target);\n  console.log('timer set for: ' + new Date(target).toString());\n  wf.setHandler(setDeadlineSignal, (deadline) => {\n    // send in new deadlines via Signal\n    timer.deadline = deadline;\n    console.log('timer now set for: ' + new Date(deadline).toString());\n  });\n  wf.setHandler(timeLeftQuery, () => timer.deadline - Date.now());\n  await timer; // if you send in a signal with a new time, this timer will resolve earlier!\n  console.log('countdown done!');\n}\n```\n\nThis is available in the third party [`temporal-time-utils`](https://www.npmjs.com/package/temporal-time-utils#user-content-updatabletimer) package where you can also see the implementation:\n\n```ts\n// implementation\nexport class UpdatableTimer implements PromiseLike<void> {\n  deadlineUpdated = false;\n  #deadline: number;\n\n  constructor(deadline: number) {\n    this.#deadline = deadline;\n  }\n\n  private async run(): Promise<void> {\n    /* eslint-disable no-constant-condition */\n    while (true) {\n      this.deadlineUpdated = false;\n      if (\n        !(await wf.condition(\n          () => this.deadlineUpdated,\n          this.#deadline - Date.now()\n        ))\n      ) {\n        break;\n      }\n    }\n  }\n\n  then<TResult1 = void, TResult2 = never>(\n    onfulfilled?: (value: void) => TResult1 | PromiseLike<TResult1>,\n    onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>\n  ): PromiseLike<TResult1 | TResult2> {\n    return this.run().then(onfulfilled, onrejected);\n  }\n\n  set deadline(value: number) {\n    this.#deadline = value;\n    this.deadlineUpdated = true;\n  }\n\n  get deadline(): number {\n    return this.#deadline;\n  }\n}\n```\n\n</details>\n\n### Triggers\n\n[Triggers](https://typescript.temporal.io/api/classes/workflow.trigger) are a Promise-like concept in the TypeScript SDK.\n\nTriggers, like the [`condition()`](#condition) return value and other Promises, can be awaited and expose a `then` method.\nUnlike Promises, they export `resolve` or `reject` methods, so you can programmatically control them.\n\n<details>\n<summary>\nTrigger Code Example\n</summary>\n\n```ts\nimport { Trigger, sleep, defineSignal } from '@temporalio/workflow';\n\nconst userInteraction = new Trigger<boolean>();\nconst completeUserInteraction = defineSignal('completeUserInteraction');\n\nexport async function yourWorkflow(userId: string) {\n  setHandler(completeUserInteraction, () => userInteraction.resolve(true)); // programmatic resolve\n  const userInteracted = await Promise.race([\n    userInteraction,\n    sleep('30 days'),\n  ]);\n  if (!userInteracted) {\n    await sendReminderEmail(userId);\n  }\n}\n```\n\n`Trigger` is `CancellationScope`-aware. It is linked to the current scope on construction and throws when that scope is cancelled.\n\n</details>\n\n## Child Workflows\n\nBesides Activities, a Workflow can also start other, \"Child\" Workflows.\nChild Workflows have a subset of APIs from [Temporal Clients](/typescript/clients), including how to start/execute/handle Workflows.\n\n[`startChild`](https://typescript.temporal.io/api/namespaces/workflow/#startchild) starts a child workflow without awaiting completion, and returns a [`ChildWorkflowHandle`](https://typescript.temporal.io/api/interfaces/workflow.ChildWorkflowHandle):\n\n```ts\nimport { startChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(names: string[]) {\n  const childHandle = await startChild(childWorkflow, {\n    args: [name],\n    // workflowId, // add business-meaningful workflow id here\n    // // regular workflow options apply here, with two additions (defaults shown):\n    // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n    // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n  });\n  // you can use childHandle to signal or get result here\n  await childHandle.signal('anySignal');\n  const result = childHandle.result();\n  // you can use childHandle to signal, query, cancel, terminate, or get result here\n}\n```\n\nYou should use [cancellationScopes](/typescript/cancellation-scopes) if you need to cancel Child Workflows.\n\n[`executeChild`](https://typescript.temporal.io/api/namespaces/workflow/#executechild) starts a child workflow and awaits (blocks until) its completion:\n\n<!--SNIPSTART typescript-child-workflow-->\n<!--SNIPEND-->\n\nTo control any running Workflow from inside a Workflow, use [`getExternalWorkflowHandle(workflowId)`](https://typescript.temporal.io/api/namespaces/workflow/#getexternalworkflowhandle).\n\n```ts\nimport { getExternalWorkflowHandle, workflowInfo } from '@temporalio/workflow';\n\nexport async function terminateWorkflow() {\n  const { workflowId } = workflowInfo(); // no await needed\n  const handle = getExternalWorkflowHandle(workflowId); // sync function, not async\n  await handle.cancel();\n}\n```\n\nSpecial Notes:\n\n- Child Workflow options automatically inherit their values from the Parent Workflow options if they are not explicitly set. They have two advanced options unique to Child Workflows:\n  - [`cancellationType`](https://typescript.temporal.io/api/enums/proto.coresdk.child_workflow.ChildWorkflowCancellationType): Controls at which point to throw the CanceledFailure exception when a child workflow is cancelled\n  - `parentClosePolicy`: Explained below\n- Child Workflow executions are [`CancellationScope`](/typescript/cancellation-scopes) aware and will automatically be cancelled when their containing scope is cancelled.\n\n<details>\n<summary>\nWhen to use Child Workflows vs Activities\n</summary>\n\nChild Workflows and Activities are both started from Workflows, so you may feel confused about when to use which.\nHere are some important differences:\n\n- Child Workflows have access to all Workflow APIs, but are subject to [Workflow Limitations](/typescript/workflows#workflow-limitations). Activities have the inverse pros and cons.\n- Child Workflows can continue on if their Parent is canceled, with a [ParentClosePolicy](/concepts/what-is-a-parent-close-policy/) of `ABANDON`, whereas Activities are _always_ canceled when their Workflow is canceled (they may react to a [cancellationSignal](/typescript/activities#activity-cancellation) for cleanup if canceled). The decision is roughly analogous to spawning a child process in a terminal to do work vs doing work in the same process.\n- Temporal tracks all state changes within Child Workflows in Event History, whereas only the input, output, and retry attempts of Activities are tracked.\n\nActivities usually model a single operation on the external world. Workflows are modeling composite operations that consist of multiple activities or other child workflows.\n\n**When in doubt, use Activities.**\n\n</details>\n\n<RelatedReadList\nreadlist={[\n[\"What is a Child Workflow Execution?\",\"/concepts/what-is-a-child-workflow-execution\",\"explanation\"]\n]}\n/>\n\n### Parent Close Policy\n\nimport PCP from '../concepts/what-is-a-parent-close-policy.md'\n\n<PCP />\n\n<span id=\"continueasnew\" />\n\n## `continueAsNew`\n\nWe need to call `continueAsNew` before our Workflow hits the 50,000 Event limit. [Events](../concepts/what-is-an-event) are generated when a Workflow does various things involving Temporal Server, including calling an Activity, receiving a Signal, or calling `sleep`, but not handling a Query.\n\n<details>\n<summary>More info</summary>\n\n[What is Continue-As-New?](/concepts/what-is-continue-as-new)\n\n</details>\n\n[`continueAsNew`](https://typescript.temporal.io/api/namespaces/workflow#continueasnew) stops the current Workflow Execution and starts another one with new arguments and an empty Event History. Note that this is done immediately, so make sure that your Signal handlers have finished running before calling `continueAsNew`.\n\n<!--SNIPSTART typescript-continue-as-new-workflow-->\n<!--SNIPEND-->\n\nYou can also call `continueAsNew` from a signal handler or `continueAsNew` to a different Workflow (or different Task Queue) using [`makeContinueAsNewFunc`](https://nodejs.temporal.io/api/namespaces/workflow/#makecontinueasnewfunc).\n\nIf you need to know whether a Workflow was started via `continueAsNew`, you can pass an optional last argument as true:\n\n```ts\nexport async function loopingWorkflow(foo: any, isContinued?: boolean) {\n  // some logic based on foo, branching on isContinued\n\n  (await continueAsNew)<typeof loopingWorkflow>(foo, true);\n}\n```\n\n### Don't overuse\n\nYou should not try to call `continueAsNew` too often - if at all!\nIt's primary purpose is to truncate event history, which if too large may slow down your workflows and eventually cause an error. Calling it too frequently to be preemptive can cause other performance issues as each new Workflow Execution has overhead.\n\nTemporal's default limits are set to warn you at 10,000 events in a single Workflow Execution, and error at 50,000.\nThis is sufficient for:\n\n- If executing one activity a day, it can support an infinite loop for over 2 decades (27 years)\n- If executing one activity an hour, it can support an infinite loop for over 1 year (417 days)\n- If executing one activity a minute, it can support an infinite loop for over 1 week (7 days)\n\nwithout even resorting to `continueAsNew`.\n\nOur recommendation is to size it to continue as new between once a day to once a week, to ensure old version branches can be removed in a timely manner.\n\n### Example\n\nHere is a simple pattern that we recommend to represent a single entity. It keeps track of the number of iterations regardless of frequency, and calls `continueAsNew` while properly handling pending updates from Signals.\n\n```tsx\ninterface Input {\n  /* define your workflow input type here */\n}\ninterface Update {\n  /* define your workflow update type here */\n}\n\nconst MAX_ITERATIONS = 1;\n\nexport async function entityWorkflow(\n  input: Input,\n  isNew = true\n): Promise<void> {\n  try {\n    const pendingUpdates = Array<Update>();\n    setHandler(updateSignal, (updateCommand) => {\n      pendingUpdates.push(updateCommand);\n    });\n\n    if (isNew) {\n      await setup(input);\n    }\n\n    for (let iteration = 1; iteration <= MAX_ITERATIONS; ++iteration) {\n      // Ensure that we don't block the Workflow Execution forever waiting\n      // for updates, which means that it will eventually Continue-As-New\n      // even if it does not receive updates.\n      await condition(() => pendingUpdates.length > 0, '1 day');\n\n      while (pendingUpdates.length) {\n        const update = pendingUpdates.shift();\n        await runAnActivityOrChildWorkflow(update);\n      }\n    }\n  } catch (err) {\n    if (isCancellation(err)) {\n      await CancellationScope.nonCancellable(async () => {\n        await cleanup();\n      });\n    }\n    throw err;\n  }\n  await continueAsNew<typeof entityWorkflow>(input, false);\n}\n```\n\n<span id=\"putting-it-all-together-schedule-workflow-example\" />\n\n## Putting it all together\n\nIndividually, the core Workflow APIs (Signals/Queries, sleep/condition, startChild/executeChild, and continueAsNew) are interesting, but they become truly powerful when wielded together.\n\nWe can illustrate this by building an example Workflow that combines them.\n\n### Schedule Workflow Example\n\nOne common request from users is for more powerful alternatives to [Cron Workflows](/typescript/clients#scheduling-cron-workflows). We can try implementing them with the Workflow API primitives we have learned here.\n\nSome desirable requirements:\n\n- One Parent Workflow that schedules `ChildWorkflow`s based on either a:\n  - Cron string (with timezone support, eg \"at 8am every day\")\n  - or \"unaligned\" sleep period (eg \"every 3 hours\")\n- Allows setting:\n  - a random \"jitter\" period to spread out execution\n  - a maximum number of invocations, or have the schedules end by a set date\n  - a \"paused\" or \"running\" state (that can also be queried)\n- Allows querying:\n  - the expected times of the next N invocations\n  - the number of invocations so far\n- Allows manual trigger at any point\n\nTake some time to think about how you would implement these features, and then look at our suggested solution below.\n\n<details>\n<summary>Example CronScheduleWorkflow\n</summary>\n\nThe desired clientside usage would look something like this:\n\n```ts\n// client.ts\nconst handle = await client.start(MyScheduleWorkflow, {\n  args: [\n    {\n      cronParser: {\n        // every day 8am\n        expression: '0 8 * * *',\n        options: {\n          currentDate: '2016-03-27 00:00:01',\n          endDate: new Date('Wed, 26 Dec 2012 14:40:00 UTC'),\n          tz: 'Europe/Athens',\n        },\n      },\n      maxInvocations: 500,\n      jitterMs: 1000,\n      userId, // defined elsewhere\n    },\n  ],\n  taskQueue: 'scheduler',\n  workflowId: 'schedule-for-' + userId,\n});\n```\n\nThis Workflow would want a `sleepUntil` timer at its core to power the scheduling - ideal for implementing clock-aligned \"run at a set time\" semantics. Temporal doesn't export `sleepUntil` for you - you can write your own with some simple time math.\n\n```ts\nimport * as wf from '@temporalio/workflow';\nimport parser from 'cron-parser';\nimport differenceInMilliseconds from 'date-fns/differenceInMilliseconds';\n\n// example atomic unit of work you are scheduling, can be workflow or activity or whatever\nasync function spawnChild(\n  userId: string,\n  nextTime: string,\n  invocation: number\n) {\n  return wf.executeChild(childWorkflow, {\n    args: [userId],\n    workflowId: `childWorkflow-${invocation}-${nextTime}`,\n    // // regular workflow options apply here, with two additions (defaults shown):\n    // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n    // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n  });\n}\n\nexport async function sleepUntil(futureDate: string, fromDate = new Date()) {\n  const timeUntilDate = differenceInMilliseconds(\n    new Date(futureDate),\n    fromDate\n  );\n  return wf.sleep(timeUntilDate);\n}\n\n// queries\nexport const numInvocationsQuery = wf.defineQuery('numInvocationsQuery');\nexport const futureScheduleQuery = wf.defineQuery('futureScheduleQuery');\nexport const manualTriggerSignal = wf.defineSignal('manualTriggerSignal');\nexport type ScheduleWorkflowState = 'RUNNING' | 'PAUSED' | 'STOPPED';\nexport const stateSignal =\n  wf.defineSignal<[ScheduleWorkflowState]>('stateSignal');\nexport const stateQuery = wf.defineQuery<ScheduleWorkflowState>('stateQuery');\n\nexport async function CronScheduleWorkflow(\n  args: {\n    cronParser: {\n      expression: string;\n      options: parser.ParserOptions;\n    };\n    callbackFn: (nextTime?: string, invocations?: number) => Promise<void>;\n    maxInvocations?: number;\n    jitterMs?: number;\n    userId?: string;\n  },\n  invocations = 1\n) {\n  // signal and query handlers\n  wf.setHandler(numInvocationsQuery, () => invocations);\n  wf.setHandler(manualTriggerSignal, () =>\n    spawnChild(userId, nextTime.toString(), invocations++)\n  );\n  let scheduleWorkflowState = 'RUNNING' as ScheduleWorkflowState;\n  wf.setHandler(stateQuery, () => scheduleWorkflowState);\n  wf.setHandler(stateSignal, (state) => void (scheduleWorkflowState = state));\n\n  const interval = parser.parseExpression(\n    args.cronParser.expression,\n    args.cronParser.options\n  );\n  const nextTime = interval.next().toString();\n  wf.setHandler(futureScheduleQuery, (numEntriesInFutureSchedule?: number) => {\n    const interval = parser.parseExpression(\n      args.cronParser.expression,\n      args.cronParser.options\n    ); // reset interval\n    return {\n      futureSchedule: genNextTimes(numEntriesInFutureSchedule, () =>\n        interval.next().toString()\n      ),\n      timeLeft: differenceInMilliseconds(new Date(nextTime), new Date()),\n    };\n  });\n\n  // timer logic\n  try {\n    await sleepUntil(nextTime);\n    if (args.jitterMs) {\n      await wf.sleep(Math.floor(Math.random() * (args.jitterMs + 1)));\n    }\n    if (scheduleWorkflowState === 'PAUSED') {\n      await wf.condition(() => scheduleWorkflowState === 'RUNNING');\n    }\n    await spawnChild(userId, nextTime.toString(), invocations); // no need to increment invocations bc relying on continueAsNew for that\n    if (args.maxInvocations && args.maxInvocations > invocations) {\n      await wf.continueAsNew<typeof CronScheduleWorkflow>(\n        args,\n        invocations + 1\n      );\n    } else {\n      scheduleWorkflowState = 'STOPPED';\n    }\n  } catch (err) {\n    if (wf.isCancellation(err)) scheduleWorkflowState = 'STOPPED';\n    else throw err;\n  }\n}\n\n// shared\nfunction genNextTimes<T extends string | Date>(\n  number = 5,\n  getNextTimes: () => T\n): T[] {\n  const times = [];\n  for (let i = 0; i < number; i++) {\n    times.push(getNextTimes());\n  }\n  return times;\n}\n```\n\n</details>\n\nYou can extend or add features as you please. For example, notice that we only implemented a very trivial cancellation cleanup step. By default, if a Parent Workflow is cancelled, all child workflows will be cancelled as well. What if you wanted them to carry on to completion? (Hint: check the `ParentClosePolicy`).\n\n### Workflow Utility Libraries\n\nAs you build up strong opinions of how you'd like to compose behavior, you may want to publish reusable Temporal utility function or Temporal Workflow libraries. Let us know and we'd be happy to feature them here!\n\n- [temporal-time-utils](https://www.npmjs.com/package/temporal-time-utils): Contains reusable versions of `sleepUntil`, `UpdatableTimer`, and `ScheduleWorkflow` described on this page.\n\nJust keep in mind the difference between utility functions (deterministic, uses Workflow APIs but have to be inlined into Workflows rather than used standalone) and Workflow functions (can be used standalone, and subject to all Workflow limitations, including that all args and results must be JSON-serializable.)\n","is_empty":false}]
